'From SqueakLight4 of 9 April 2011 [latest update: #11160] on 9 April 2011 at 7:22:57 am'!!Object methodsFor: 'error handling' stamp: 'edc 7/31/2008 06:39'!dpsTraceUntilRoot: anObject	| reportString context count |		Transcript open.		reportString := (anObject respondsTo: #asString) 			ifTrue: [anObject asString] ifFalse: [anObject printString].	(Smalltalk at: #Decompiler ifAbsent: [nil]) 	ifNil: 		[Transcript cr; show: reportString]	ifNotNil:		[context := thisContext.		count := 1.		[Transcript cr.			Transcript show: count printString, ': '.						reportString notNil			ifTrue:				[Transcript show: context home class name 			, '/' , context sender selector,  ' (' , reportString , ')'.				context := context sender.				reportString := nil]			ifFalse:				[(context notNil and: [(context := context sender) notNil])				ifTrue: [Transcript show: context receiver class name , '/' , context selector.					count := count + 1]].	context sender notNil]whileTrue]! !!Object methodsFor: 'evaluating' stamp: 'edc 7/18/2005 10:51'!ancestors|  nonMetaClass  classList |	nonMetaClass := self theNonMetaClass.			classList := OrderedCollection new.		nonMetaClass allSuperclasses reverseDo: 		[:aClass | 		classList add: aClass name.		].	^ classList! !!Object methodsFor: 'evaluating' stamp: 'edc 7/18/2005 10:51'!othersClassList|classList metodosSospechosos | classList := Set new.metodosSospechosos := self  methodDict .metodosSospechosos isEmpty		ifFalse: [metodosSospechosos				collect: [:cm | cm literals						select: [:any | any isVariableBinding]						thenCollect: [:each | (Smalltalk at: each key ifAbsent:[])								ifNotNil: [  classList add: each key]]]].					metodosSospechosos := self class methodDict .metodosSospechosos isEmpty		ifFalse: [metodosSospechosos				collect: [:cm | cm literals						select: [:any | any isVariableBinding]						thenCollect: [:each | (Smalltalk at: each key ifAbsent:[])								ifNotNil: [classList add: each key]]]].					classList remove: self name  ifAbsent: [].					^classList					! !!Object methodsFor: 'objects from disk' stamp: 'edc 9/6/2008 19:40'!fileOutCompressed| unzipped zipped buffer aFileName |aFileName := self class name asFileName.	"do better?"	aFileName := UIManager default 				request: 'File name?' translated initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ Beeper beep].Cursor writeshowWhile: [unzipped := RWBinaryOrTextStream on: ''.unzipped fileOutClass: nil andObject: self.unzipped reset.zipped := FileDirectory default newFileNamed: aFileName , 'obz'.zipped binary.zipped := GZipWriteStream on: zipped.buffer := ByteArray new: 50000.'Compressing ' , self namedisplayProgressAt: Sensor cursorPointfrom: 0to: unzipped sizeduring: [:bar | [unzipped atEnd]whileFalse: [bar value: unzipped position.zippednextPutAll: (unzipped nextInto: buffer)].zipped close.unzipped close]]! !!Object methodsFor: 'objects from disk' stamp: 'edc 9/5/2008 08:57'!saveOnFileNamed: aString 	"Ask the user for a filename and save myself on a	SmartReferenceStream file. Writes out the version and class structure.	The file is fileIn-able. UniClasses will be filed out.	This save objects as .obj"	| aFileName fileStream |	aString isEmpty		ifTrue: [^ Beeper beep].	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := aString , '.obj'.	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self! !!Object class methodsFor: 'objects from disk' stamp: 'edc 6/11/2008 07:37'!readAndInspect: inputStreaminputStream setConverterForCode.(inputStream fileInObjectAndCode ) inspect! !!Object class methodsFor: '*services-extras' stamp: 'edc 2/14/2008 08:24'!fileReaderServicesForFile: fullName suffix: suffix	| services |	services _ OrderedCollection new.		(fullName asLowercase endsWith: '.obj')		ifTrue: [ services add: self serviceLoadObject ].	^services! !!Object class methodsFor: '*services-extras' stamp: 'edc 7/27/2008 08:11'!readCompressedObject: aFileStream 		self readAndInspect: (MultiByteBinaryOrTextStream with: (GZipReadStream on: aFileStream) upToEnd) reset! !!Object class methodsFor: '*services-extras' stamp: 'edc 7/27/2008 07:40'!serviceCompressedObject	"Answer a service for opening a saved Object"	^ (SimpleServiceEntry		provider: Object		label: 'gz saved Object'		selector: #readCompressedObject:		description: 'open a gz Object'		buttonLabel: 'object')		argumentGetter: [:fileList | 						fileList readOnlyStream]! !!Object class methodsFor: '*services-extras' stamp: 'edc 2/14/2008 08:26'!serviceLoadObject"Answer a service for opening a saved Object"	^ (SimpleServiceEntry 		provider: self 		label: 'saved Object'		selector: #readAndInspect:		description: 'open a Object'		buttonLabel: 'object')		argumentGetter: [:fileList | fileList readOnlyStream]! !