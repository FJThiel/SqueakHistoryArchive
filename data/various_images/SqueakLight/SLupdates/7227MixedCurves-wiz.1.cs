'From SqueakLight|II of 31 May 2008 [latest update: #7226] on 10 June 2009 at 6:30:58 am'!"Change Set:		7227MixedCurves-wizDate:			10 June 2009Author:			Edgar J. De CleeneThis coimpletes Jerome Peace code for having more fancy PolygonMorphs.For some reason , not before into SqueakLightII, I discover when try new version of Rompecabezas"!!MixedCurveMorph commentStamp: '<historical>' prior: 0!A MixedCurveMorph is Curve that can be broken up into separately curved segments. It allows for the creation of matching edges( e. g. for jigsaw puzzle pieces).Instance Variables	slopeClamps:		<Array>slopeClamps	- elements of array are either 0 or nil. Indicating whether slope for the corresponding vertex is 0@0 or unknown and therefore to be calculated. There is one element for each vertex.		!!MixedCurveMorph methodsFor: 'smoothing' stamp: 'wiz 2/12/2006 23:34'!slopes: knots 	"Choose slopes according to state of polygon and preferences"	| myClamps |	self isCurvy		ifFalse: [^ knots segmentedSlopes].	^ (closed			and: [self isCurvier])		ifTrue: [myClamps := self clamps .			(myClamps allSatisfy: [ :e | e == nil ] )			ifTrue: [ knots closedCubicSlopes ]			ifFalse: [knots clampedCubicSlopes: myClamps] ]		ifFalse: [knots clampedNaturalCubicSlopes: self clamps ]! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 1/29/2006 16:30'!assertSlopesClampedWith: knots from: start to: end   "	We trust everything has been checked. 	The following assertions should hold at this point: "			self assert: [ self size = knots size ] . 	"Sizes must be consistent." 	self assert: [ end > start + 1 ]. 	"There must be at least one slope to clamp." 	self assert: [ 0 < start and: [start <= knots size] ]. 	"The clamped slope may be the last one."	self assert: [  end  < knots size + start ] . 	"We can wrap. There may be only one known slope."	self assert: [ (self at: start ) class  = (self at: end ) class ] . 	"Slopes must be consistent."	self assert: [ (self at: start ) isNumber or: [   (self at: start ) isPoint ] ] . 	"And a known and reasonalble value."		^true	! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/7/2006 17:22'!assertSlopesWith: knots from: start to: end   "	We trust everything has been checked. 	The following assertions should hold at this point: "			| slope |	self assert: [ self size = knots size ] . 	"Sizes must be consistent." 	self assert: [ end > start]. 	"There must be at least one slope to clamp." 	self assert: [ 0 < start and: [start <= knots size] ]. 	"The clamped slope may be the last one."	self assert: [  end  <= knots size + start ] . 	"We can wrap. There may be only one known slope."	self assert: [ end = knots size + start ifTrue: [ (self at: start) notNil ] ] .		"If we overlap slope must be known."	{ start . end } 		do: [ :index | slope := (self at: index )	self assert: [ slope isNil 				or: [ slope isNumber 				or: [ slope isPoint ] ] ] ] . 	"And a known and reasonalble value or nil." 		^true 	! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/12/2006 23:24'!clampedCubicSlopes: clampedSlopes	"Sent to knots returns a copy of clampedSlopes with the values of the undefined (nil)  slopes filled in.	This is a modification of naturalCubicSlopes 	"	" clampedSlopes must be the same size as knots and at least one slope must be clamped (i.e. not nil)" 		"/* Between known slopes we solve the equation for knots with end conditions:  	4*b1+b2 = 3(a2 - a0) - b0 	bN2+4*bN1 = 3*(aN-aN2) - bN	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.  	"	| slopes  |	slopes := clampedSlopes copy. "slopes will be modified."	clampedSlopes closedFillinList do: [ :r | slopes slopesClampedWith: self from: r first to: r last ] .		^ slopes! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/8/2006 20:20'!clampedNaturalCubicSlopes: clampedSlopes	"Sent to knots returns a copy of clampedSlopes with the values of the undefined (nil)  slopes filled in.	This is a modification of naturalCubicSlopes 	"	" clampedSlopes must be the same size as knots and at least one slope must be clamped (i.e. not nil)" 		"/* Between known slopes we solve the equation for knots with end conditions:  	4*b1+b2 = 3(a2 - a0) - b0 	bN2+4*bN1 = 3*(aN-aN2) - bN	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.	 	by using row operations to convert the matrix to upper  	triangular  	and then back sustitution. The D[i] are the derivatives at the  	knots.  	"	| slopes  |	slopes := clampedSlopes copy. "slopes will be modified."	clampedSlopes naturalFillinList do: [ :r | slopes slopesWith: self from: r first to: r last ] .		^ slopes! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/8/2006 00:45'!closedFillinList	"Answers a list of ranges between which values are undertermined.	Reciever is a list that combines known values and nil entries for	undetermined values.	Answer a list of ranges. Each range starts and ends with a known	value. 	The range inbetween the known values are nil. The ranges start and	ends may overlap. 	Each nil element in the list appears in exactly one range. 	If the list starts or ends with nil the last range will wrap around to the	next known value. There may be only one known value in the list but	there must be atleast one know value.		(self allsatisfy: [ :e | e isNil ] ) ifTrue: [ self error: 'list must contain at	least one known value' ] 	"	| changes n |	changes := self nilTransitions .	changes isEmpty ifTrue: [ self error: ' At least one value must be known' ] .	 	changes = #(1) ifTrue: [ ^ #() "Special case. no unknowns." ] . 	changes = { n :=  self size } ifTrue: [ ^ { n to: n + n } ] .	"Special case. Only last element known."		changes size even ifTrue: 			[changes add: self size							+ (changes at: 1)]						ifFalse: [		changes first = 1 ifFalse: [ changes add: self size + 1;											add: self size + changes first ]								].	^ changes allButFirst pairsCollect: [ :s :e | ( s - 1 to: e ) ] .	! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/12/2006 23:14'!slopesClampedWith: knots from: start to: end 	"Sent to modifiable list of slopes. Fills in the slope values between start	and end.	We expect that the parameters meets the assertions in	self assertSlopesClampedWith: knots from: start to: end."	"		/* We solve the equation for knots with end conditions: 	4*b1+b2 = 3(a2 - a0)- b0	bN2+4*bN1 = 3*(aN-aN1)-bN	b0, bN are the known starting and ending slopes.	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.	"	| gamma delta n1 |	n1 := self size.	gamma := Array new: n1.	delta := Array new: n1.	gamma at: start put: 0.0.	(start + 1 to: end - 1)		do: [:i | gamma atWrap: i put: 1.0 / (4.0						- (gamma atWrap: i - 1))].	"gamma atWrap: end put: 1.0 / (4.0	- (gamma atWrap: end))."	delta		at: start		put: (self at: start).	(start + 1 to: end - 1)		do: [:i | delta atWrap: i put: 3.0 * ((knots atWrap: i + 1)						- (knots atWrap: i - 1))					- (delta atWrap: i - 1)					* (gamma atWrap: i)].	delta		atWrap: end		put: (self atWrap: end).	(start + 1 to: end - 1)		reverseDo: [:i | self atWrap: i put: (delta atWrap: i)					- ((gamma atWrap: i)							* (self atWrap: i + 1)) ]! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'wiz 2/9/2006 01:33'!slopesWith: knots from: start to: end 	"Sent to modifiable list of slopes. Fills in the slope values between start	and end. Start and end slopes can be either clamped or nil. 	If nil the natural slope for that value will be filled in. 	We expect that the parameters meets the assertions in	self assertSlopesWith: knots from: start to: end."	"		/* We solve the equation for knots with end conditions either known or unknown: 	4*b1+b2 = 3(a2 - a0)- b0			b0 known	Or	2*b0+b1 = 3(a1 - a0) .			b0 == nil		bN2+4*bN1 = 3*(aN-aN2)-bN		bN known	Or	bN1+2*bN = 3*(aN-aN1)			bN == nil	 .	b0, bN are starting and ending slopes.					and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	by using row operations to convert the matrix to upper 	triangular and then back substitution. 	"	| gamma delta n range |	n := self size.	gamma := Array new: n.	delta := Array new: n.	(self at: start)		ifNotNil: [			gamma at: start put: 0.0.			delta				at: start				put: (self at: start).			range := ( start + 1 to: end - 1 ) .			] " clamped initial conditions"		ifNil: [			gamma at: start put: 2.0 reciprocal.			delta				at: start				put: 3.0 * ((knots atWrap: start + 1)					- knots at: start ) * (gamma at: start) .			range := ( start  to: end - 1 ) .				] "natural initial conditions " .	(start + 1 to: end - 1)		do: [:i | gamma atWrap: i put: 1.0 / (4.0						- (gamma atWrap: i - 1))].	(start + 1 to: end - 1)		do: [:i | delta atWrap: i put: 3.0 * ((knots atWrap: i + 1)						- (knots atWrap: i - 1))					- (delta atWrap: i - 1)					* (gamma atWrap: i)].	(self atWrap: end) 		ifNil: [ 			gamma atWrap: end put: 1.0 / (2.0  										- (gamma atWrap: end - 1 )).			delta				atWrap: end				put: 3.0 * ((knots atWrap: end )						- knots atWrap: end - 1 ) - (delta at: end -1 )* (gamma atWrap: end) .			self atWrap: end put: (delta atWrap: end ) .				] "natural end conditions"	ifNotNil: [ 			gamma atWrap: end put: 0.0 .			delta				atWrap: end				put: (self atWrap: end)  .					] "clamped end conditions" .			range		reverseDo: [:i | self atWrap: i put: 					(delta atWrap: i)					- ((gamma atWrap: i)							* (self atWrap: i + 1)) ] .	" reciever now contains the filled in slopes."	^ self ! !