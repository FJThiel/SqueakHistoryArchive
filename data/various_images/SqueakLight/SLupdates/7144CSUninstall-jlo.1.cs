'From SqueakLight|II of 31 May 2008 [latest update: #7125] on 11 June 2008 at 8:42:47 am'!"Change Set:		7144CSUninstall-jloDate:			11 June 2008Author:			Edgar J. De CleeneThis was the unistall for regular cs Jason ask and Javier made"!!ChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/12/2007 15:39'!className^class! !!ChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/12/2007 15:36'!className: aClassclass := aClass! !!ChangeSet methodsFor: 'isolation layers' stamp: 'jlo 8/30/2007 14:31'!uninstall	| priorDefinition i |	ChangeSet newChanges: self.	('Uninstalling ' , ChangeSet current name)		displayProgressAt: Display center		from: 0 to: (self classRemoves size + self changedClasses size)		during: [:bar |				i := 0.				self classRemoves do: [:class |									bar value: i + 1.									priorDefinition := (self changeRecorderFor: class) priorDefinition.									(RWBinaryOrTextStream with: priorDefinition) reset fileIn.									(self changeRecorderFor: class) removeChangeType: #add ].					self changedClasses					do: [:class | 						bar value: i + 1.						((self wasAdded: class) and: [class isMeta not])							ifTrue: [Object removeSubclass: class.									class removeFromSystem]							ifFalse: [									(self hasMethodChangesForClass: class)										ifTrue: [self uninstallMethodsForClass: class].									priorDefinition := (self changeRecorderFor: class) priorDefinition.									priorDefinition															ifNotNil: [												class isMeta													ifTrue: [priorDefinition := class name															, (priorDefinition copyFrom: 12 to: priorDefinition size)].												(RWBinaryOrTextStream with: priorDefinition) reset fileIn]]]].	SystemOrganization removeEmptyCategories.	ChangeSorter removeChangeSet: self! !!ChangeSet methodsFor: 'moving changes' stamp: 'jlo 8/30/2007 14:05'!uninstallMethodsForClass: aClass 	| versions otherCsVersions csVersionMethod csEstimatedPosition |	(self changedSelectorsForClass: aClass)		do: [:selector | 						versions := self versionsOf: selector atClass: aClass.			csVersionMethod := versions						detect: [:version | (version originalChangeSetForSelector: selector) name = self name]						ifNone: [nil].			versions := versions select: [:version | (version originalChangeSetForSelector: selector) ~= nil ].			csVersionMethod				ifNil: [otherCsVersions := versions]				ifNotNil: [					csEstimatedPosition := csVersionMethod position.					otherCsVersions := versions								select: [:version | (version originalChangeSetForSelector: selector) name ~= self name and: [(version originalChangeSetForSelector: selector) ~= #sources ifTrue:[ version position < csEstimatedPosition] ifFalse: [true]]]].			otherCsVersions				ifEmpty: [aClass removeSelector: selector]				ifNotEmpty: [otherCsVersions := otherCsVersions								asSortedCollection: [:a :b | a position < b position].					otherCsVersions						do: [:v | 							(v originalChangeSetForSelector: selector)								ifNotNil: [	(v originalChangeSetForSelector: selector) = #sources												ifTrue: [ChangeSet newChanges: ((ChangeSet named: 'sources') ifNil: [ChangeSet basicNewChangeSet: 'sources'])]												ifFalse: [ChangeSet newChanges: (v originalChangeSetForSelector: selector)].																						v fileIn]].						ChangeSet newChanges: self]]! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/14/2007 08:55'!changedSelectorsForClass: aClass^(self changeRecorderFor: aClass) methodChanges keys! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/15/2007 10:07'!hasMethodChangesForClass: aClass^(self changedSelectorsForClass: aClass) notEmpty! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/14/2007 09:06'!versionsOf: selector atClass: aClass| method category sourcePointer pair versions |(aClass includesSelector: selector)		ifTrue: [method := aClass compiledMethodAt: selector.				category := aClass whichCategoryIncludesSelector: selector.				sourcePointer := nil]		ifFalse: [pair := self methodInfoFromRemoval: {aClass name. selector}.				pair ifNil: [^ nil].				sourcePointer := pair first.				method := CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category := pair last].versions := ChangeSet scanVersionsOf: method class: aClass meta: aClass isMeta category: category selector: selector.aClass isMeta ifTrue: [versions := versions do: [:v | v className: (v className subStrings at: 1) asString ]].^versions! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/15/2007 10:03'!wasAdded: aClass^(self changeRecorderFor: aClass) includesChangeType: #add! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jlo 8/23/2007 18:02'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.	self update! !!Class methodsFor: 'initialize-release' stamp: 'jlo 8/28/2007 23:29'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	| meta |	(ChangeSet current changeRecorderFor: self) notePriorDefinition: self.	self selectors do: [:selector |				(ChangeSet current) removeSelector: selector class: self priorMethod: (self compiledMethodAt: selector) lastMethodInfo: {(self compiledMethodAt: selector) sourcePointer. self whichCategoryIncludesSelector: selector}].	meta := self class.	meta selectors do: [:selector |				(ChangeSet current) removeSelector: selector class: meta priorMethod: (meta compiledMethodAt: selector) lastMethodInfo: {(meta compiledMethodAt: selector) sourcePointer. meta whichCategoryIncludesSelector: selector}].	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/23/2007 17:16'!removeChangeType: aSymbol	changeTypes remove: aSymbol! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/23/2007 17:34'!noteNewMethod: newMethod		currentMethod _ newMethod.! !