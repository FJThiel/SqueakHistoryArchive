'From SqueakLight|II of 31 May 2008 [latest update: #7068] on 2 June 2008 at 7:49:57 am'!Collection subclass: #CharacterSetComplement	instanceVariableNames: 'absent'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!CharacterSetComplement commentStamp: 'nice 3/23/2007 02:27' prior: 0!CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)instance variables:	absent <CharacterSet> contains character that are not in the set (i.e. my complement)!!Character methodsFor: 'printing' stamp: 'lr 1/3/2007 19:30'!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	(value between: 33 and: 255)		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:28'!byteComplement	"return a character set containing precisely the single byte characters the receiver does not"		| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:19'!= anObject	"Implementation note: we do not test if equal to a WideCharacterSet,	because it is unlikely that WideCharacterSet is as complete as self"		^self class == anObject class and: [		absent = anObject complement ]! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:16'!hash	^absent hash bitXOr: self class hash! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!add: aCharacter	"a character is present if not absent"		(absent includes: aCharacter) ifTrue: [absent remove: aCharacter].	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:11'!do: aBlock	"evaluate aBlock with each character in the set.	don't do it, there are too many..."	self shouldNotImplement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:07'!includes: aCharacter	^(absent includes: aCharacter) not! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!reject: aBlock	"Implementation note: rejecting present is selecting absent"		^(absent select: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!remove: aCharacter	"This means a character is absent from myself"		^absent add: aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!select: aBlock	"Implementation note: selecting present is rejecting absent"		^(absent reject: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:10'!size	"Is this 2**32-absent size ?"		^self shouldNotImplement! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 3/23/2007 02:21'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^absent byteArrayMap collect: [:i | 1 - i]! !!CharacterSetComplement methodsFor: 'converting' stamp: 'nice 3/23/2007 02:08'!complement	"return a character set containing precisely the characters the receiver does not"		^absent copy! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 3/23/2007 02:25'!complement: aCharacterSet	"initialize with the complement"		absent := aCharacterSet! !!CharacterSetComplement methodsFor: 'testing' stamp: 'nice 3/23/2007 02:12'!hasWideCharacters	"This is a guess that absent is not holding each and every possible wideCharacter..."		^true! !!CharacterSetComplement class methodsFor: 'instance creation' stamp: 'nice 3/23/2007 02:25'!of: aCharacterSet	"answer the complement of aCharacterSet"		^ super new complement: aCharacterSet! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !