'From SqueakLight|II of 31 May 2008 [latest update: #7125] on 11 June 2008 at 7:49:19 am'!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos '	classVariableNames: 'LocalTimeZone ClockProvider LastTickSemaphore DaysSinceEpoch LastTick LastMilliSeconds MilliSecondOffset LocalOffset '	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!!DateAndTime methodsFor: 'squeak protocol' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o.! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'kph 12/14/2006 00:36'!now 	| nanoTicks msm |	nanoTicks _ (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [ LastTick := nanoTicks.								^ self todayAtMilliSeconds: msm ].	LastTickSemaphore critical:	[	 	 		LastTick _  LastTick + 1.				^ self todayAtNanoSeconds: LastTick	]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/11/2006 21:13'!millisecondClockValue	^ self clock millisecondClockValue! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/9/2006 23:46'!totalSeconds	^ self clock totalSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 6/13/2007 23:07'!localOffset	"Answer the duration we are offset from UTC"	^ LocalOffset ifNil:[ LocalOffset := self localTimeZone offset ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 6/16/2007 06:44'!milliSecondsSinceMidnight		| msm msClock |		msClock := self millisecondClockValue. 	(msClock < LastMilliSeconds) 		ifTrue:[ "rolled over" MilliSecondOffset := MilliSecondOffset + SmallInteger maxVal + 1 ].	LastMilliSeconds := msClock.	[ msm := msClock + MilliSecondOffset. 	 (msm >= 86400000) ] 		whileTrue: [ "next day" 			LastTick := -1.			DaysSinceEpoch := DaysSinceEpoch + 1. 			MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	((LastTick = -1) and: [		(Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: 								(self clock totalSeconds)) days ~= DaysSinceEpoch ]) 		ifTrue: 				[  self initializeOffsets. 				 ^ self milliSecondsSinceMidnight ].		^msm! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/19/2006 15:01'!readFrom: aStream	| bc year month day hour minute second nanos offset buffer ch |	aStream peek = $- ifTrue: [ aStream next. bc _ -1] ifFalse: [bc _ 1].	year _ (aStream upTo: $-) asInteger * bc.	month _ (aStream upTo: $-) asInteger.	day _ (aStream upTo: $T) asInteger.	hour _ (aStream upTo: $:) asInteger. 	buffer _ '00:' copy. ch _ nil.	minute _ WriteStream on: buffer.	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ minute nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $: ].	minute _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '00.' copy.	second _ WriteStream on: buffer.	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ second nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $. ].	second _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '000000000+' copy.	(ch = $.) ifTrue: [ 		nanos _ WriteStream on: buffer.		[ aStream atEnd | ((ch := aStream next) = $+) | (ch = $-) ]			whileFalse: [ nanos nextPut: ch. ].		(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $+ ].	].	nanos _ buffer asInteger.	aStream atEnd		ifTrue: [ offset _ self localOffset ]		ifFalse:		 	[offset _ Duration fromString: (ch asString, '0:', aStream upToEnd).			(offset = self localOffset) ifTrue: [ offset _ self localOffset ]].	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond:  nanos		offset: offset.	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtMilliSeconds: milliSecondsSinceMidnight	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun.    "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtNanoSeconds: nanoSecondsSinceMidnight	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'clock provider' stamp: 'kph 12/11/2006 20:14'!clock 	 "the provider of real time seconds/milliseconds."	^ ClockProvider ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/13/2007 23:05'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LocalOffset := nil.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/16/2007 06:51'!initializeOffsets 	| epochianSeconds secondsSinceMidnight nowSecs  |	  	LastTick := 0.  	nowSecs :=  self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue. 	epochianSeconds := Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: nowSecs.	DaysSinceEpoch := epochianSeconds days.	secondsSinceMidnight := (epochianSeconds - (Duration days: DaysSinceEpoch hours: 0 minutes: 0 seconds: 0)) asSeconds.  	MilliSecondOffset := (secondsSinceMidnight * 1000 - LastMilliSeconds).	LocalOffset := nil.  ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 12/13/2006 21:46'!startUp: resuming 	resuming ifFalse: [^ self].		[ self initializeOffsets ] fork.	! !!DateAndTime class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone _ TimeZone default ]! !!DateAndTime class methodsFor: 'accessing' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:17'!milliSecondsSinceMidnight	^ DateAndTime milliSecondsSinceMidnight! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:18'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	| ms |		ms := self milliSecondsSinceMidnight.	^ self seconds:  (ms // 1000) nanoSeconds: (ms \\ 1000) * 1000000! !!Time class methodsFor: 'clock' stamp: 'kph 12/14/2006 01:43'!secondsWhenClockTicks	"waits for the moment when a new second begins"	| lastSecond delay |	delay :=  Delay forMilliseconds: 1.	lastSecond _ self primSecondsClock.	[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ]. 	^ lastSecond + 1! !DateAndTime initialize!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'ClockProvider DaysSinceEpoch LastMilliSeconds LastTick LastTickSemaphore LocalOffset LocalTimeZone MilliSecondOffset'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!