'From SqueakLight|II of 31 May 2008 [latest update: #7212] on 8 November 2008 at 9:06:45 am'!!AbstractFont methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ false.! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'wiz 1/1/2007 20:21'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue		ifTrue: [^self].	self changed .	self image: (images at:	(imageIndex _ imageIndex \\ images size + 1)).	self changed . 	d _ (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 5/7/2007 11:34'!openNewArchive	|  result |	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	self fileName: (result directory fullNameFor: result name).! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 7/13/2006 17:46'!saveArchive	| result name |		name := FileDirectory  localNameFor: labelString .	self canSaveArchive ifFalse: [ ^self ].	result := FillInTheBlank		request: 'Name this zip '		initialAnswer:  name		centerAt: Display center.	result ifNil: [ ^self ].		(archive canWriteToFileNamed: result)		ifFalse: [ self inform: name, ' is used by one or more membersin your archive, and cannot be overwritten.Try writing to another file name'.			^self ].	[ archive writeToFileNamed: result ] on: Error do: [ :ex | self inform: ex description. ].	self setLabel: name asString.	self changed: #memberList	"in case CRC's and compressed sizes got set"! !!ArchiveViewer methodsFor: 'initialization' stamp: 'edc 11/23/2007 09:32'!createListHeadingUsingFont: font	| sm |	sm := StringMorph contents: ' order  uncomp   comp   CRC-32       date     time     file name'.	font ifNotNil: [ sm font: font ].	^(AlignmentMorph newColumn)		color: self defaultBackgroundColor;		addMorph: sm;		yourself.! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:32'!displayLineFor: aMember	| stream dateTime index |	index := self archive members indexOf: aMember.	stream := WriteStream on: (String new: 60).	dateTime := Time dateAndTimeFromSeconds: aMember lastModTime. 	stream	nextPutAll: (index printString padded: #left to: 4 with: $  );	space;		nextPutAll: (aMember uncompressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember compressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember crc32String );		space; space.	dateTime first printOn: stream format: #(3 2 1 $- 2 1 2).	stream space; space.	dateTime second print24: true showSeconds: false on: stream.	stream space; space;		nextPutAll: (aMember fileName ).	^stream contents! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:51'!memberMenu: menu shifted: shifted	| services |	menu		add: 'Comment archive' target: self selector: #commentArchive;		balloonTextForLastItem: 'Add a comment for the entire archive'.	self selectedMember ifNotNilDo: [ :member |		menu			addLine;			add: 'Inspect member' target: self selector: #inspectMember;			balloonTextForLastItem: 'Inspect the selected member';			add: 'Comment member' target: self selector: #commentMember;			balloonTextForLastItem: 'Add a comment for the selected member';			addLine;			add: 'member go up in order ' target: self selector: #upMember;			add: 'member go down in order ' target: self selector: #downMember;			add: 'select member order ' target: self selector: #toIndexPlace;			addLine.		services := FileList itemsForFile: member fileName.		menu addServices2: services for: self extraLines: #().	].	^menu! !!ArchiveViewer methodsFor: 'member operations' stamp: 'edc 7/13/2006 12:10'!addMember	| result local full |	self canAddMember ifFalse: [ ^self ].	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	local := result directory localNameFor: result name.	full := result directory fullNameFor: result name.		(archive addFile: full as: local)		desiredCompressionMethod: ZipArchive compressionDeflated.	self memberIndex: self members size.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:18'!downMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  + 1).	self archive members at: (memberIndex  +1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!toIndexPlace| index max temp |max := self archive members size.index :=0.[index := (FillInTheBlank		request: 'To which index '		initialAnswer:  '1'		centerAt: Display center) asInteger.		index between: 1 and: max] whileFalse.	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: index).	self archive members at: index put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!upMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  -1).	self archive members at: (memberIndex  -1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer class methodsFor: 'fileIn/Out' stamp: 'edc 6/26/2007 07:09'!services		^ Array 		with: self serviceAddToNewZip		with: self serviceOpenInZipViewer										! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'al 6/12/2006 10:48'!basicLocalSelectors	"Direct accessor for the instance variable localSelectors.	Because of hardcoded ivar indexes of Behavior and Class in the VM, Class and	Metaclass declare the needed ivar and override this method as an accessor. 	By returning nil instead of declaring this method as a subclass responsibility,	Behavior can be instantiated for creating anonymous classes."		^nil! !!Behavior methodsFor: 'adding/removing methods' stamp: 'mtf 5/9/2008 13:39'!addSelectorSilently: selector withMethod: compiledMethod	self methodDictAddSelectorSilently: selector withMethod: compiledMethod! !!Behavior methodsFor: 'adding/removing methods' stamp: 'mtf 5/8/2008 17:42'!removeSelector: aSelector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method"	self basicRemoveSelector: aSelector	! !!Behavior methodsFor: 'initialization' stamp: 'mtf 4/25/2008 09:23'!obsolete	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary]! !!Behavior methodsFor: 'initialize-release' stamp: 'mtf 4/25/2008 09:38'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ aClass.	format _ fmt.	methodDict _ mDict.! !!Behavior methodsFor: 'testing' stamp: 'kph 5/15/2007 23:20'!traitCompositionString	^ '{}'! !!Behavior methodsFor: 'testing method dictionary' stamp: 'al 9/16/2005 14:16'!includesLocalSelector: aSymbol	^self basicLocalSelectors isNil		ifTrue: [self includesSelector: aSymbol]		ifFalse: [self localSelectors includes: aSymbol]! !!BlockClosure methodsFor: 'accessing' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: literal	"Answer true if literal is identical to any literal imbedded in my method"	method == literal ifTrue: [^ true].	^ method hasLiteralThorough: literal from: self! !!BlockClosure methodsFor: 'comparing' stamp: 'ms 8/8/2007 11:49'!= other	self class == other class ifFalse: [^ false].	self env = other env ifFalse: [^ false].	self method == other method ifTrue: [^true].	^ self method = other method! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:14'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.					"start up the watchdog"		self ensure:[							"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:15'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34'!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37'!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !!BorderedStringMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:34'!drawOn: aCanvas	| nameForm |	font _ self fontToUse.	nameForm _ Form extent: bounds extent depth: 8.	nameForm getCanvas drawString: contents at: 0@0 font: self fontToUse color: Color black.	(bounds origin + 1) eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: self borderColor.	].	aCanvas		stencil: nameForm 		at: bounds origin + 1 		color: color.	! !!BorderedStringMorph methodsFor: 'initialization' stamp: 'ar 12/14/2001 20:02'!initWithContents: aString font: aFont emphasis: emphasisCode	super initWithContents: aString font: aFont emphasis: emphasisCode.	self borderStyle: (SimpleBorder width: 1 color: Color white).! !!BorderedStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	self		borderStyle: (SimpleBorder width: 1 color: Color white)! !!BorderedStringMorph methodsFor: 'accessing' stamp: 'ar 12/12/2001 03:03'!measureContents	^super measureContents +2.! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!Browser methodsFor: 'accessing' stamp: 'mtf 5/1/2008 11:51'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^self classDefinitionText].	editSelection == #editComment 		ifTrue:			[(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'mtf 4/25/2008 07:22'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass _ self selectedClass.			theClass				ifNil: 					[self inform: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			self changed: #classCommentText.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[self inform: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'class functions' stamp: 'mtf 4/25/2008 07:24'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.		keywdIx _ defTokens findFirst: [:x | x beginsWith: 'category'].	envt _ Smalltalk.	keywdIx _ defTokens findFirst: [:x | '*subclass*' match: x].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self clearUserEditFlag.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'class functions' stamp: 'mtf 4/25/2008 07:21'!newClass	self editClass.	editSelection _ #newClass.	self contentsChanged! !!Browser methodsFor: 'message functions' stamp: 'mtf 5/1/2008 11:52'!inspectInstances	"Inspect all instances of the selected class.  1/26/96 sw"	| myClass |	((myClass _ self selectedClassOrMetaClass) isNil)		ifFalse: [myClass theNonMetaClass inspectAllInstances]! !!Browser methodsFor: 'message functions' stamp: 'mtf 5/1/2008 11:52'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses  1/26/96 sw"	| aClass |	((aClass _ self selectedClassOrMetaClass))		ifFalse: [			aClass _ aClass theNonMetaClass.			aClass inspectSubInstances].! !!Browser methodsFor: 'message functions' stamp: 'edc 7/31/2007 07:16'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	ServiceGui browser: self messageListMenu: aMenu.	ServiceGui onlyServices ifTrue: [^ aMenu].	shifted		ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)							('copy Selector'				copySelector)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('tile scriptor'			openSyntaxView)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'message functions' stamp: 'mtf 4/25/2008 07:23'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation == 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation == 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!ByteString methodsFor: 'converting' stamp: 'edc 11/19/2007 10:49'!asJoliet|badChars |badChars := #( $: $< $> $| $/ $\ $? $* $") asSet.^ self copyWithoutAll: badChars! !!ByteString methodsFor: 'converting' stamp: 'ar 7/21/2007 21:51'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := self indexOfAnyOf: CSNonSeparators 							startingAt: end+1 ifAbsent: [ nil ].	beginning ~~ nil ] whileTrue: [		"find the end"		end := self indexOfAnyOf: CSSeparators 					startingAt: beginning ifAbsent: [ self size + 1 ].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:33'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange := changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass := aChange methodClass) notNil				and: [ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:34'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream := WriteStream on: (String new: 200).	(all := ChangesOrganizer allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index := (UIManager default chooseFrom: (aStream contents substrings)).	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/12/2007 15:39'!className^class! !!ChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/12/2007 15:36'!className: aClassclass := aClass! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'edc 10/18/2008 06:16'!fileOut	"File out the receiver, to a file whose name is a function of the 	change-set name and either of the date & time or chosen to have a 	unique numeric tag, depending on the preference 	'changeSetVersionNumbers'"	| slips nameToUse internalStream |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , FileStream cs].				nameToUse := nameToUse asJoliet.	nameToUse := self defaultChangeSetDirectory fullNameFor: nameToUse.		 Cursor write				showWhile: [internalStream := WriteStream								on: (String new: 10000).					internalStream header; timeStamp.					self fileOutPreambleOn: internalStream.					self fileOutOn: internalStream.					self fileOutPostscriptOn: internalStream.					internalStream trailer.					FileStream						writeSourceCodeFrom: internalStream						baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3)						isSt: false						useHtml: false].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'edc 5/15/2005 12:11'!fileOutCompressed	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse internalStream shortnameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	(Preferences warningForMacOSFileNameLength			and: [nameToUse size > 30])		ifTrue: [nameToUse := FillInTheBlank						request: (nameToUse , '\has ' , nameToUse size asString , ' letters - too long for Mac OS.\Suggested replacement is:') withCRs						initialAnswer: (nameToUse contractTo: 30).			nameToUse = ''				ifTrue: [^ self]].shortnameToUse _ nameToUse.	nameToUse := self defaultChangeSetDirectory fullNameFor: nameToUse.	Cursor write showWhile: [			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name].CodeLoader compressFileNamed: shortnameToUse in: self defaultChangeSetDirectory! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'mtf 4/25/2008 09:31'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| list |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].			list := self class superclassOrder: self changedClasses asOrderedCollection.		"First put out rename, max classDef and comment changes."	list do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	list do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	list reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'isolation layers' stamp: 'jlo 8/30/2007 14:31'!uninstall	| priorDefinition i |	ChangeSet newChanges: self.	('Uninstalling ' , ChangeSet current name)		displayProgressAt: Display center		from: 0 to: (self classRemoves size + self changedClasses size)		during: [:bar |				i := 0.				self classRemoves do: [:class |									bar value: i + 1.									priorDefinition := (self changeRecorderFor: class) priorDefinition.									(RWBinaryOrTextStream with: priorDefinition) reset fileIn.									(self changeRecorderFor: class) removeChangeType: #add ].					self changedClasses					do: [:class | 						bar value: i + 1.						((self wasAdded: class) and: [class isMeta not])							ifTrue: [Object removeSubclass: class.									class removeFromSystem]							ifFalse: [									(self hasMethodChangesForClass: class)										ifTrue: [self uninstallMethodsForClass: class].									priorDefinition := (self changeRecorderFor: class) priorDefinition.									priorDefinition															ifNotNil: [												class isMeta													ifTrue: [priorDefinition := class name															, (priorDefinition copyFrom: 12 to: priorDefinition size)].												(RWBinaryOrTextStream with: priorDefinition) reset fileIn]]]].	SystemOrganization removeEmptyCategories.	ChangeSorter removeChangeSet: self! !!ChangeSet methodsFor: 'moving changes' stamp: 'jlo 8/30/2007 14:05'!uninstallMethodsForClass: aClass 	| versions otherCsVersions csVersionMethod csEstimatedPosition |	(self changedSelectorsForClass: aClass)		do: [:selector | 						versions := self versionsOf: selector atClass: aClass.			csVersionMethod := versions						detect: [:version | (version originalChangeSetForSelector: selector) name = self name]						ifNone: [nil].			versions := versions select: [:version | (version originalChangeSetForSelector: selector) ~= nil ].			csVersionMethod				ifNil: [otherCsVersions := versions]				ifNotNil: [					csEstimatedPosition := csVersionMethod position.					otherCsVersions := versions								select: [:version | (version originalChangeSetForSelector: selector) name ~= self name and: [(version originalChangeSetForSelector: selector) ~= #sources ifTrue:[ version position < csEstimatedPosition] ifFalse: [true]]]].			otherCsVersions				ifEmpty: [aClass removeSelector: selector]				ifNotEmpty: [otherCsVersions := otherCsVersions								asSortedCollection: [:a :b | a position < b position].					otherCsVersions						do: [:v | 							(v originalChangeSetForSelector: selector)								ifNotNil: [	(v originalChangeSetForSelector: selector) = #sources												ifTrue: [ChangeSet newChanges: ((ChangeSet named: 'sources') ifNil: [ChangeSet basicNewChangeSet: 'sources'])]												ifFalse: [ChangeSet newChanges: (v originalChangeSetForSelector: selector)].																						v fileIn]].						ChangeSet newChanges: self]]! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/14/2007 08:55'!changedSelectorsForClass: aClass^(self changeRecorderFor: aClass) methodChanges keys! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/15/2007 10:07'!hasMethodChangesForClass: aClass^(self changedSelectorsForClass: aClass) notEmpty! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/14/2007 09:06'!versionsOf: selector atClass: aClass| method category sourcePointer pair versions |(aClass includesSelector: selector)		ifTrue: [method := aClass compiledMethodAt: selector.				category := aClass whichCategoryIncludesSelector: selector.				sourcePointer := nil]		ifFalse: [pair := self methodInfoFromRemoval: {aClass name. selector}.				pair ifNil: [^ nil].				sourcePointer := pair first.				method := CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category := pair last].versions := ChangeSet scanVersionsOf: method class: aClass meta: aClass isMeta category: category selector: selector.aClass isMeta ifTrue: [versions := versions do: [:v | v className: (v className subStrings at: 1) asString ]].^versions! !!ChangeSet methodsFor: 'as yet unclassified' stamp: 'jlo 8/15/2007 10:03'!wasAdded: aClass^(self changeRecorderFor: aClass) includesChangeType: #add! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21'!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !!ChangeSet class methodsFor: 'services' stamp: 'edc 6/29/2008 07:31'!fileReaderServicesForFile: fullName suffix: suffix(fullName endsWith: 'sqz')		ifTrue: [ ^Array with: self serviceInstallCompressedCode ].		(fullName endsWith: 'cs') |(fullName endsWith: 'st')		ifTrue: [ ^Array with: self serviceFileIntoNewChangeSet].		^#()! !!ChangeSet class methodsFor: 'services' stamp: 'edc 6/25/2008 09:44'!installCompressedCodeStream: aStandardFileStream named: aString	"Browse the selected file in fileIn format."	| zipped unzipped |	[zipped := GZipReadStream on: aStandardFileStream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString]		ensure: [aStandardFileStream close].	unzipped reset.	self newChangesFromStream: unzipped named: aString! !!ChangeSet class methodsFor: 'services' stamp: 'edc 6/25/2008 09:15'!serviceInstallCompressedCode	"Answer a service for opening a changelist browser on a file"	^ (SimpleServiceEntry 		provider: self 		label: 'install'		selector: #installCompressedCodeStream:named:		description: 'install this compressed code in a new Change Set'		buttonLabel: 'install')		argumentGetter: [ :fileList | {fileList readOnlyStream .fileList fileName}]! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:34'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet := ChangesOrganizer assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:35'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList := self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[ChangesOrganizer fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet :=  ChangesOrganizer assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup] ! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet } , parameters! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet }, parameters].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet]! !!ChangeSorter methodsFor: 'access' stamp: 'pk 10/17/2006 09:37'!showChangeSetNamed: aName	self showChangeSet: (ChangesOrganizer changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:37'!annotationForPackageforSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing 	information about the given selector and class"	"requestList"| aCategory |aClass ifNil: [ ^nil] .aSelector ifNil: [ aClass theNonMetaClass category asString ] .aSelector ifNotNil: [ aCategory := aClass organization categoryOfElement: aSelector.(aCategory notNil and: [ aCategory first = $* ]) 	ifTrue: [^ aCategory asString]] .	"Ok. So the selector catagory does not indicate our package. We defer to the class catagory"^ aClass theNonMetaClass category asString.	! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!beginNote"return the string at the beginning of item annotation"^' {'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!endNote"return the string at the beginning of item annotation"^'}'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:21'!noteString: aString^ self beginNote , aString asString , self endNote! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:39'!packageNoteForClass: aClass selector: aSelector "return the category name that represents the package name for aClass>>aSelector.when selector is nil or in a normal catagory return "| package |package := (self annotationForPackageforSelector: aSelector			ofClass: aClass) ifNil: ['<class was deleted???>'] .^ self noteString: package! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:17'!withoutItemAnnotation: aStringOrNil"return the current item without the package annotation we added on"| endItemIndex |aStringOrNil ifNil: [^nil] .( endItemIndex := aStringOrNil findString: self beginNote) = 0	ifTrue: [^ aStringOrNil ] .^ aStringOrNil first: endItemIndex - 1! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!changeSetCategories	^ ChangesOrganizer changeSetCategories! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'edc 9/23/2005 09:11'!changeSetMenu: aMenu shifted: isShifted 	"Set up aMenu to hold commands for the change-set-list pane. 	This could be for a single or double changeSorter"	isShifted		ifTrue: [^ self shiftedChangeSetMenu: aMenu].	Smalltalk isMorphic		ifTrue: [aMenu title: 'Change Set'.			aMenu addStayUpItemSpecial]		ifFalse: [aMenu title: 'Change Set:' , myChangeSet name].	aMenu add: 'make changes go to me (m)' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set... (n)' action: #newSet.	aMenu add: 'find...(f)' action: #findCngSet.	aMenu add: 'show category... (s)' action: #chooseChangeSetCategory.	aMenu balloonTextForLastItem: 'Lets you choose which change sets should be listed in this change sorter'.	aMenu add: 'select change set...' action: #chooseCngSet.	aMenu addLine.	aMenu add: 'rename change set (r)' action: #rename.	aMenu add: 'file out (o)' action: #fileOut.	aMenu add: 'file out Compressed' action: #fileOutCompressed.	aMenu add: 'browse methods (b)' action: #browseChangeSet.	aMenu add: 'browse change set (B)' action: #openChangeSetBrowser.	aMenu addLine.	parent		ifNotNil: [aMenu add: 'copy all to other side (c)' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side (-)' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: [aMenu add: 'edit preamble (p)' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble (p)' action: #addPreamble].	myChangeSet hasPostscript		ifTrue: [aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'category functions...' action: #offerCategorySubmenu.	aMenu balloonTextForLastItem: 'Various commands relating to change-set-categories'.	aMenu addLine.	aMenu add: 'destroy change set (x)' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #offerShiftedChangeSetMenu.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats := self changeSetCategories elementsInOrder.	aMenu := SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result := aMenu startUp.	result ifNotNil:		[changeSetCategory := result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategoryInMorphic	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Choose the category ofchange sets to show inthis Change Sorter(red = current choice)'.	self changeSetCategories elementsInOrder do:		[:aCategory |			aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.			aCategory == changeSetCategory ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: aCategory documentation].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically := self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen := (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangesOrganizer changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'edc 11/18/2007 08:26'!fileOut	"File out the current change set."	myChangeSet fileOut.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'edc 7/16/2005 11:02'!fileOutCompressed	"File out the current change set."	myChangeSet fileOutCompressed.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName := UIManager default request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName := catName asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := StaticChangeSetCategory new categoryName: catName.	self changeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName := self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName := UIManager default request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName := ('Changes to ', clsName) asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	self changeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName := changeSetCategory categoryName), '?') ifFalse: [^ self].	self changeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName := myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message := 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg := myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber := myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangesOrganizer removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName := UIManager default request: 'Please give the new category a name' initialAnswer:  (oldName := changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName := catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	self changeSetCategories removeElementAt: oldName.	self changeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	| aMenu |	Smalltalk isMorphic		ifFalse:			[self inform:'Only available in morphic, right now, sorry.It would not take much to make thisalso work in mvc, so if you areinclined to do that, thanks in advance...']		ifTrue:			[aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Categories whichcontain change set"', myChangeSet name, '"'.			self changeSetCategories elementsInOrder do:				[:aCategory |					(aCategory includesChangeSet: myChangeSet)						ifTrue:							[aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.						aCategory == changeSetCategory ifTrue:							[aMenu lastItem color: Color red]].						aMenu balloonTextForLastItem: aCategory documentation].				aMenu popUpInWorld]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:37'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory := aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jlo 8/23/2007 18:02'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.	self update! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:14'!basicClassList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:35'!classList	"return the classlist with package note appended."		^ self basicClassList collect: [: each | 		each asString, (self packageNoteForClass: (Smalltalk classNamed: each) selector: nil) ] .! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:37'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet := self class newChangeSet: (self withoutItemAnnotation: currentClassName).	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:38'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: (self withoutItemAnnotation: currentClassName).		currentClassName := nil.		currentSelector := nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'code pane' stamp: 'wiz 2/3/2007 01:34'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType | 	self clearUserEditFlag.	currentClassName ifNil: [^ contents := myChangeSet preambleString ifNil: ['']].	class := self selectedClassOrMetaClass.	(sel := self selectedMessageName) == nil		ifFalse: [changeType := (myChangeSet atSelector: (sel := sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents := 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents := 'Added then removed (see versions)'].			class ifNil: [^ contents := 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents := 'Method was added, but cannot be found!!'].			contents := class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs) includes: contentsSymbol) ifTrue:				[contents :=  class prettyPrinterClass					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showingAnyKindOfDiffs				ifTrue: [contents := self diffFromPriorSourceFor: contents].			^ contents := contents asText makeSelectorBoldIn: class]		ifTrue: [strm := WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents := strm contents].! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:13'!basicMessageList 	| probe newSelectors className |	currentClassName ifNil: [^ #()].	className := (self withoutItemAnnotation: currentClassName) .	probe := (className endsWith: ' class')		ifTrue: [className]		ifFalse: [className asSymbol].	newSelectors := myChangeSet selectorsInClass: probe.	(newSelectors includes: (self selectedMessageName)) 		ifFalse: [currentSelector := nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other := (parent other: self) changeSet.		cls := self selectedClassOrMetaClass.		sel := self selectedMessageName.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!messageList 	| thisClass |	(thisClass := self selectedClassOrMetaClass) ifNil: [^ #() ] .	^self basicMessageList collect: [ :each |		each asString , (self packageNoteForClass: thisClass selector: each) ] .! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 3/5/2001 18:26'!messageMenu: aMenu shifted: shifted	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	aMenu title: 'message list'.	Smalltalk isMorphic ifTrue: [aMenu addStayUpItemSpecial].	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from changeSet (d)'	forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			('browse protocol (p)'				browseFullProtocol)			-			('fileOut'							fileOutMessage)			('printOut'							printOutMessage)			-			('senders of... (n)'					browseSendersOfMessages)			('implementors of... (m)'				browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			('more...'							shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 7/22/2007 22:13'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^self].	self okToChange ifFalse: [^Beeper beep].	currentSelector ifNotNil: 			[other := (parent other: self) changeSet.			other == myChangeSet ifTrue: [^Beeper  beep].			cls := self selectedClassOrMetaClass.			sel := self selectedMessageName.			other 				absorbMethod: sel				class: cls				from: myChangeSet.			(parent other: self) showChangeSet: other.			self forget	"removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:33'!selectedMessageName	currentSelector ifNil: [^ nil].	^ (self withoutItemAnnotation: currentSelector) asSymbol! !!ChangeSorter methodsFor: 'toolbuilder' stamp: 'wiz 2/1/2007 15:37'!buildWith: builder	"		ToolBuilder open: ChangeSorter.	"	|  windowSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec label: 'Change Sorter'.	windowSpec model: self.	windowSpec children: OrderedCollection new.	self buildWith: builder in: windowSpec rect: (0@0 extent: 1@1).	^builder build: windowSpec! !!ChangeSorter methodsFor: 'traits' stamp: 'wiz 2/3/2007 01:34'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName tName className |	currentClassName ifNil: [^ nil].	className := (self withoutItemAnnotation: currentClassName) .	(className endsWith: ' class')		ifTrue: [cName _ (className copyFrom: 1 to: className size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	(currentClassName endsWith: ' classTrait')		ifTrue: [tName _ (className copyFrom: 1 to: className size-11) asSymbol.				^ (Smalltalk at: tName ifAbsent: [^nil]) classTrait].	cName _ className asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !!ChangeSorter commentStamp: '<historical>' prior: 0!I display a ChangeSet.  Two of me are in a DualChangeSorter.!!ChangeSorter class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:10'!initialize	"ChangeSorter initialize"	FileList registerFileReader: self.	self registerInFlapsRegistry.! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 08:59'!allChangeSetNames	^ ChangesOrganizer allChangeSetNames! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:00'!allChangeSets	^ ChangesOrganizer allChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!allChangeSetsWithClass: class selector: selector	^ ChangesOrganizer allChangeSetsWithClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:19'!assuredChangeSetNamed: aName	^ ChangesOrganizer assuredChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!basicNewChangeSet: newName	^ ChangesOrganizer basicNewChangeSet: newName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAdditions: aChangeSet	^ ChangesOrganizer belongsInAdditions: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAll: aChangeSet	^ ChangesOrganizer belongsInAll: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInMyInitials: aChangeSet	^ ChangesOrganizer belongsInMyInitials: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	^ ChangesOrganizer belongsInNumbered: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInProjectChangeSets: aChangeSet	^ ChangesOrganizer belongsInProjectChangeSets: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInProjectsInRelease:  aChangeSet	^ ChangesOrganizer belongsInProjectsInRelease:  aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInRecentUpdates: aChangeSet	^ ChangesOrganizer belongsInRecentUpdates: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!buildAggregateChangeSet	^ ChangesOrganizer buildAggregateChangeSet	! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSet: aChangeSet containsClass: aClass	^ ChangesOrganizer changeSet: aChangeSet containsClass: aClass! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetCategoryNamed: aName	^ ChangesOrganizer changeSetCategoryNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetNamed: aName	^ ChangesOrganizer changeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetNamesInReleaseImage	^ ChangesOrganizer changeSetNamesInReleaseImage! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:08'!changeSetNamesInThreeOh	^ ChangesOrganizer changeSetNamesInThreeOh! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer changeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!countOfChangeSetsWithClass: aClass andSelector: aSelector	^ ChangesOrganizer countOfChangeSetsWithClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!deleteChangeSetsNumberedLowerThan: anInteger	^ ChangesOrganizer deleteChangeSetsNumberedLowerThan: anInteger! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	^ ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!existingOrNewChangeSetNamed: aName	^ ChangesOrganizer existingOrNewChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:23'!fileOutChangeSetsNamed: nameList	^ ChangesOrganizer fileOutChangeSetsNamed: nameList! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!gatherChangeSets	^ ChangesOrganizer gatherChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!highestNumberedChangeSet	^ ChangesOrganizer highestNumberedChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:10'!initializeChangeSetCategories	^ ChangesOrganizer initializeChangeSetCategories! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!mostRecentChangeSetWithChangeForClass: class selector: selector	^ ChangesOrganizer mostRecentChangeSetWithChangeForClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!newChangeSet	^ ChangesOrganizer newChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangeSet: aName	^ ChangesOrganizer newChangeSet: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangesFromStream: aStream named: aName	^ ChangesOrganizer newChangesFromStream: aStream named: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:11'!noteChangeSetsInRelease	^ ChangesOrganizer noteChangeSetsInRelease! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:14'!promoteToTop: aChangeSet	^ ChangesOrganizer promoteToTop: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!recentUpdateMarker	^ ChangesOrganizer recentUpdateMarker! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!recentUpdateMarker: aNumber	^ ChangesOrganizer recentUpdateMarker: aNumber! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!removeChangeSet: aChangeSet	^ ChangesOrganizer removeChangeSet: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeChangeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer removeChangeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeEmptyUnnamedChangeSets	^ ChangesOrganizer removeEmptyUnnamedChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!reorderChangeSets	^ ChangesOrganizer reorderChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!secondaryChangeSet	^ ChangesOrganizer secondaryChangeSet! !!ChangesOrganizer commentStamp: 'pk 10/17/2006 09:25' prior: 0!Changes organizer!!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSets	"Return the list of all current ChangeSets"	^ChangeSet allChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ChangeSet named: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetsNamedSuchThat: nameBlock	^ChangeSet changeSetsNamedSuchThat: nameBlock! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!existingOrNewChangeSetNamed: aName	^ChangeSet existingOrNewChangeSetNamed: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!gatherChangeSets		"ChangeSorter gatherChangeSets"	^ChangeSet gatherChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (ChangeSet allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!promoteToTop: aChangeSet	"Make aChangeSet the first in the list from now on"	^ChangeSet promoteToTop: aChangeSet! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString := aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease := self changeSetNamesInThreeOh]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 10:03'!initialize	"Initialize the class variables"	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker := 0.! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories := ElementCategory new categoryName: #ChangeSetCategories.	aCategory := ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease := (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!basicNewChangeSet: newName	^ChangeSet basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangesFromStream: aStream named: aName	^ChangeSet newChangesFromStream: aStream named: aName! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	self removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangesOrganizer deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	^ChangeSet removeChangeSet: aChangeSet! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSetsNamedSuchThat: nameBlock	(self changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker := 0]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker := aNumber! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead := OrderedCollection new.	newMid := OrderedCollection new.	newTail := OrderedCollection new.	ChangeSet allChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	ChangeSet allChangeSets: newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!secondaryChangeSet	^ChangeSet secondaryChangeSet! !!ChangesOrganizer class methodsFor: 'utilities' stamp: 'pk 2/6/2006 09:49'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | (aChangeSet := self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!Character methodsFor: 'printing' stamp: 'lr 1/3/2007 19:30'!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	(value between: 33 and: 255)		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'wiz 4/9/2006 20:30'!nbsp	"non-breakable space. Latin1 encoding common usage."	^ Character value: 160! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:09'!includes: aCharacter	aCharacter asciiValue >= 256		ifTrue: ["Guard against wide characters"			^false].	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!remove: aCharacter	aCharacter asciiValue >= 256		ifFalse: ["Guard against wide characters"			map at: aCharacter asciiValue + 1 put: 0].	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:02'!size	^map sum! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:28'!byteComplement	"return a character set containing precisely the single byte characters the receiver does not"		| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:23'!hasWideCharacters	^false! !!CharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 23:22'!wideCharacterMap	"used for comparing with WideCharacterSet"		| wide |	wide := WideCharacterSet new.	wide addAll: self.	^wide wideCharacterMap! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:19'!= anObject	"Implementation note: we do not test if equal to a WideCharacterSet,	because it is unlikely that WideCharacterSet is as complete as self"		^self class == anObject class and: [		absent = anObject complement ]! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:16'!hash	^absent hash bitXOr: self class hash! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!add: aCharacter	"a character is present if not absent"		(absent includes: aCharacter) ifTrue: [absent remove: aCharacter].	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:11'!do: aBlock	"evaluate aBlock with each character in the set.	don't do it, there are too many..."	self shouldNotImplement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:07'!includes: aCharacter	^(absent includes: aCharacter) not! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!reject: aBlock	"Implementation note: rejecting present is selecting absent"		^(absent select: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!remove: aCharacter	"This means a character is absent from myself"		^absent add: aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!select: aBlock	"Implementation note: selecting present is rejecting absent"		^(absent reject: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:10'!size	"Is this 2**32-absent size ?"		^self shouldNotImplement! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 3/23/2007 02:21'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^absent byteArrayMap collect: [:i | 1 - i]! !!CharacterSetComplement methodsFor: 'converting' stamp: 'nice 3/23/2007 02:08'!complement	"return a character set containing precisely the characters the receiver does not"		^absent copy! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 3/23/2007 02:25'!complement: aCharacterSet	"initialize with the complement"		absent := aCharacterSet! !!CharacterSetComplement methodsFor: 'testing' stamp: 'nice 3/23/2007 02:12'!hasWideCharacters	"This is a guess that absent is not holding each and every possible wideCharacter..."		^true! !!CharacterSetComplement commentStamp: 'nice 3/23/2007 02:27' prior: 0!CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)instance variables:	absent <CharacterSet> contains character that are not in the set (i.e. my complement)!!CharacterSetComplement class methodsFor: 'instance creation' stamp: 'nice 3/23/2007 02:25'!of: aCharacterSet	"answer the complement of aCharacterSet"		^ super new complement: aCharacterSet! !!CircleMorph methodsFor: 'parts bin' stamp: 'wiz 1/5/2007 16:23'!initialize	^super initialize		extent: 40@40;		color: Color green lighter;		yourself! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30'!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!Class methodsFor: 'initialize-release' stamp: 'jlo 8/28/2007 23:29'!removeFromSystem: logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	| meta |	(ChangeSet current changeRecorderFor: self) notePriorDefinition: self.	self selectors do: [:selector |				(ChangeSet current) removeSelector: selector class: self priorMethod: (self compiledMethodAt: selector) lastMethodInfo: {(self compiledMethodAt: selector) sourcePointer. self whichCategoryIncludesSelector: selector}].	meta := self class.	meta selectors do: [:selector |				(ChangeSet current) removeSelector: selector class: meta priorMethod: (meta compiledMethodAt: selector) lastMethodInfo: {(meta compiledMethodAt: selector) sourcePointer. meta whichCategoryIncludesSelector: selector}].	self deactivate; unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'organization' stamp: 'al 3/18/2006 13:46'!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	self basicCategory ifNotNilDo: [ :symbol |		((SystemOrganization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	self basicCategory: (result := SystemOrganization categoryOfElement: self name).	^result! !!ClassBuilder methodsFor: 'class definition' stamp: 'mtf 4/25/2008 09:18'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Create a new subclass of the given superclass with the given specification."	| newFormat newClass |	"Compute the format of the new class"	newFormat := 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	(oldClass == nil or:[oldClass isMeta not]) 		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]		ifFalse:[newClass := oldClass clone].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars.	oldClass ifNotNil:[		newClass organization: oldClass organization.		"Recompile the new class"		oldClass hasMethods 			ifTrue:[newClass compileAllFrom: oldClass].		self recordClass: oldClass replacedBy: newClass.	].	(oldClass == nil or:[oldClass isObsolete not]) 		ifTrue:[newSuper addSubclass: newClass]		ifFalse:[newSuper addObsoleteSubclass: newClass].	^newClass! !!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/23/2007 17:16'!removeChangeType: aSymbol	changeTypes remove: aSymbol! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'mtf 4/25/2008 09:24'!definitionST80	"Answer a String that defines the receiver."	| aStream |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [aStream nextPutAll: superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'mtf 5/9/2008 13:39'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'mtf 5/9/2008 13:41'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self methodDict keys select: [:sel |		(self compiledMethodAt: sel) fileIndex > 1].	self		fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'organization updating' stamp: 'mtf 4/25/2008 08:47'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory changedCategories |	changedCategories _ IdentitySet new.	currentCategory _ self organization categoryOfElement: aSymbol.	newCategoryOrNil isNil ifTrue: [		currentCategory ifNotNil: [changedCategories add: currentCategory].		self organization removeElement: aSymbol.	] ifFalse: [		((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ newCategoryOrNil]) ifTrue: [			currentCategory ifNotNil: [changedCategories add: currentCategory].			self organization 				classify: aSymbol 				under: newCategoryOrNil				suppressIfDefault: false]].	^ changedCategories! !!Clipboard methodsFor: 'accessing' stamp: 'edc 5/8/2007 17:04'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| string decodedString |	string := self primitiveClipboardText withSqueakLineEndings.	(string isEmpty			or: [string = contents asString])		ifTrue: [^ contents].	decodedString := self interpreter fromSystemClipboard: string.	^ decodedString = contents asString 		ifTrue: [contents]		ifFalse: [decodedString asText].! !!CodeHolder methodsFor: 'annotation' stamp: 'pk 10/17/2006 09:38'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'commands' stamp: 'mtf 5/1/2008 11:53'!makeSampleInstance	| aClass nonMetaClass anInstance |	((aClass _ self selectedClassOrMetaClass) isNil) ifTrue: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(Smalltalk isMorphic and: [anInstance isMorph])		ifTrue:			[self currentHand attachMorph: anInstance]		ifFalse:			[anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!CodeHolder methodsFor: 'commands' stamp: 'mtf 5/1/2008 11:53'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	((cls _ self selectedClass) isNil) ifTrue: [^ self].	aList _ self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport _ String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name! !!CodeHolder methodsFor: 'commands' stamp: 'mtf 5/1/2008 11:59'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	((cls _ self selectedClassOrMetaClass) isNil) ifTrue: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!CodeHolder methodsFor: 'commands' stamp: 'mtf 5/1/2008 11:57'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)		ifNil: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior _ selectedClassOrMetaClass.			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	Smalltalk isMorphic		ifTrue: ["this workaround only needed in morphic"			newBrowser assureSelectionsShow]! !!CodeHolder methodsFor: 'controls' stamp: 'edc 4/6/2005 10:53'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"If the receiver wishes it, add a button pane to the window, and answer the verticalOffset plus the height added"	| delta buttons divider width |width _ 10.	self wantsOptionalButtons ifFalse: [^verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self optionalButtonRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [Color gray alpha: 0.2]);		borderWidth: 0.	Preferences alternativeWindowLook ifTrue:[		buttons color: Color transparent.		buttons submorphsDo:[:m| m borderWidth: 2; borderColor: #raised.width _ width + m width].	].	divider _ BorderedSubpaneDividerMorph forBottomEdge.	Preferences alternativeWindowLook ifTrue:[		divider extent: 4@4; color: Color transparent; borderColor: #raised; borderWidth: 2.	].window width: width.	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeHolder methodsFor: 'controls' stamp: 'dtl 1/28/2007 09:17'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as written')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')(colorPrint		toggleColorPrint				colorPrintString				'colorPrint'			'the method source in a standard text format with colors to distinguish structural parts') -(showDiffs		toggleRegularDiffing		showingRegularDiffsString	'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!CodeHolder methodsFor: 'controls' stamp: 'edc 4/6/2005 10:48'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	| aList |	aList _ #(	('browse'			browseMethodFull			'view this method in a browser')	('local senders' browseLocalSendersOfMessages 'browse local senders of...')	('senders' 			browseSendersOfMessages	'browse senders of...')	('implementors'		browseMessages				'browse implementors of...')	('versions'			browseVersions				'browse versions')), 	(Preferences decorateBrowserButtons		ifTrue:			[{#('inheritance'		methodHierarchy 'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the abovepink: is an override but doesn''t call superpinkish tan: has override(s), also is an override but doesn''t call super' )}]		ifFalse:			[{#('inheritance'		methodHierarchy			'browse method inheritance')}]),	#(	('hierarchy'		classHierarchy				'browse class hierarchy')	('inst vars'			browseInstVarRefs			'inst var refs...')	('class vars'			browseClassVarRefs			'class var refs...')).	^ aList! !!CodeLoader methodsFor: 'accessing' stamp: 'edc 7/2/2008 10:37'!segments^ segments! !!CodeLoader methodsFor: 'installing' stamp: 'edc 7/2/2008 10:16'!installSegment: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted inputStream |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	inputStream := (MultiByteBinaryOrTextStream with: contents) reset .	inputStream setConverterForCode.(inputStream fileInObjectAndCode ) inspect! !!CodeLoader methodsFor: 'installing' stamp: 'edc 6/28/2008 09:47'!installSourceFiles| packName pos |	"Install the previously loaded source files"	sourceFiles == nil		ifTrue: [^ self].	sourceFiles		do: [:req | (req url endsWith: '.mcz')				ifTrue: [					pos := req url lastPositionOf: $/.					packName := req url copyFrom: pos + 1 to: req url size.					self tryVersion: packName ].				(req url endsWith: '.sar')				ifTrue: [ SARInstaller new fileInFrom: req contentStream].				(req url endsWith: '.cs') |(req url endsWith: 'st')				ifTrue: [self installSourceFile: req contentStream]].	sourceFiles := nil! !!CodeLoader methodsFor: 'installing' stamp: 'edc 7/2/2008 10:27'!readObject: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted inputStream |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	inputStream := (MultiByteBinaryOrTextStream with: contents) reset .	inputStream setConverterForCode.^(inputStream fileInObjectAndCode ) ! !!CodeLoader methodsFor: 'debugging' stamp: 'edc 7/10/2008 06:09'!tryVersion: packageName | mcw montiNames package version |mcw := MCWorkingCopyBrowser new repository: (MCHttpRepository				location: baseURL				user: ''				password: '').mcw repository ifNotNilDo: [:repos | montiNames := repos readableFileNames ].				package := (montiNames detect:[:ea| ea beginsWith: packageName] ifNone:[] ) .	package ifNotNil: [MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: baseURL)]..	version := mcw repository loadVersionFromFileNamed: package.	version load].^version! !!CodeLoader commentStamp: '<historical>' prior: 0!CodeLoader provides a simple facility for loading code from the network.Examples:	| loader |	loader _ CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!CodeLoader class methodsFor: 'accessing' stamp: 'edc 8/16/2008 17:34'!tryHttpURL: aHttpURL| loader pos baseUrl packName wName mcc  lista |loader := self new.pos := aHttpURL printString lastPositionOf: $/.	baseUrl := aHttpURL printString  copyFrom: 1 to: pos.	loader baseURL: baseUrl.	packName :=  aHttpURL printString  copyFrom: pos + 1 to: aHttpURL printString size.Transcript show: packName;cr.wName :=  packName copyUpToLast: $..(UGlobalInstaller unwantedPackages includes: wName) ifTrue:[Transcript show: 'Avoid loading';cr.	^self].mcc := MCWorkingCopyBrowser new.mcc  repository: MCCacheRepository default.lista := mcc workingCopies select:		[:wc |		 wc ancestors notEmpty] thenCollect: [:ea| ea ancestry ancestors first  name].(lista includes: wName) ifTrue:[Transcript show: 'Was loaded';cr.	^self].	loader loadSourceFiles: (Array with: packName).		(packName endsWith: '.sar') ifTrue:[^loader installSourceFiles].	loader tryVersion: packName! !!Color methodsFor: 'html' stamp: 'hmm 11/1/2006 23:28'!printHtmlString	"answer a string whose characters are the html representation  	of the receiver"	^ ((self red * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self green * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self blue * 255) asInteger printStringBase: 16 length: 2 padded: true)! !!ColorSwatch methodsFor: 'as yet unclassified' stamp: 'sw 7/13/1999 13:39'!argument: arg	argument _ arg! !!ColorSwatch methodsFor: 'setting' stamp: 'sw 3/23/2001 12:12'!setTargetColor: aColor	"Set the target color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents _ aColor.		target perform: self putSelector withArguments: (Array with: argument with: aColor)]! !!ColorSwatch methodsFor: 'target access' stamp: 'dgd 2/22/2003 13:32'!readFromTarget	"Obtain a value from the target and set it into my lastValue"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	v := target perform: getSelector with: argument.	lastValue := v.	^v! !!ColorSwatch methodsFor: 'testing' stamp: 'sw 7/13/1999 18:39'!stepTime	^ 1000! !!CompiledMethod methodsFor: 'literals' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: aLiteral from: aBlock	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	| literal |	self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral) ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		literal == aLiteral  ifTrue: [ ^ true ].		literal == aBlock ifFalse:[ (literal hasLiteralThorough: aLiteral) ifTrue: [ ^ true ]] ].	^ false.! !!CompiledMethod methodsFor: 'printing' stamp: 'edc 10/6/2008 09:54'!author self timeStamp isEmpty ifFalse: [^self timeStamp substrings first] ifTrue:[^'unknown']	! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:47'!compiledMethodFor: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result _ self				compiledMethodFor: aString 				in: aContext 				to: aReceiver 				notifying: nil				ifFail: [^#Failed] 				logged: false.	^ result! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:48'!compiledMethodFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].		logFlag ifTrue: [SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^ method.! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !!Compiler class methodsFor: 'utilities' stamp: 'mtf 4/25/2008 09:48'!recompileAll	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	Smalltalk allClasses do: [:class | class compileAll] displayingProgress: 'Recompiling all classes'. ! !!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29'!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!ContextPart methodsFor: 'private' stamp: 'dik 9/3/2007 13:00'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"					(primitiveIndex = 19) ifTrue:[		ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 186 ifTrue: [ "closure value"		| m |		m _ receiver method.		arguments size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: arguments			receiver: receiver			class: receiver class].	primitiveIndex = 187 ifTrue: [ "closure valueWithArguments:"		| m args |		m _ receiver method.		args _ arguments first.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	primitiveIndex = 188 ifTrue: [ "object withArgs:executeMethod:"		| m args |		args _ arguments first.		m _ arguments second.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'apb 2/15/2007 15:22'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002) beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 4/13/2006 10:21'!asUTC	^ offset isZero		ifTrue: [self]		ifFalse: [self utcOffset: 0]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 00:55'!asDuration	"Answer the duration since midnight."	^ Duration seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o.! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 22:59'!normalize: i ticks: ticks base: base	| tick div quo rem |	tick := ticks at: i.	div := tick digitDiv: base neg: tick negative.	quo := (div at: 1) normalize.	rem := (div at: 2) normalize.	rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].	ticks at: (i-1) put: ((ticks at: i-1) + quo).	ticks at: i put: rem! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 23:01'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	self normalize: 3 ticks: ticks base: NanosInSecond.	self normalize: 2 ticks: ticks base: SecondsInDay.	jdn	_ ticks at: 1.	seconds	_ ticks at: 2.	nanos := ticks at: 3.	offset := utcOffset! !!DateAndTime commentStamp: '<historical>' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 00:49'!clockPrecision	"One nanosecond precision"	^ Duration seconds: 0 nanoSeconds: 1! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'KLC 5/9/2008 20:13'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick _  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'gk 8/31/2006 01:00'!fromSeconds: seconds	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"	^ self basicNew ticks: (Array with: SqueakEpoch with: seconds with: 0) offset: self localOffset! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/11/2006 21:13'!millisecondClockValue	^ self clock millisecondClockValue! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/9/2006 23:46'!totalSeconds	^ self clock totalSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 6/13/2007 23:07'!localOffset	"Answer the duration we are offset from UTC"	^ LocalOffset ifNil:[ LocalOffset := self localTimeZone offset ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 10/20/2007 13:56'!milliSecondsSinceMidnight		| msm msClock |		msClock := self millisecondClockValue. 	(msClock < LastMilliSeconds) 		ifTrue:[ "rolled over" MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[ msm := msClock + MilliSecondOffset. 	 (msm >= 86400000) ] 		whileTrue: [ "next day" 			LastTick := -1.			DaysSinceEpoch := DaysSinceEpoch + 1. 			MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	((LastTick = -1) and: [		(Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: 								(self clock totalSeconds)) days ~= DaysSinceEpoch ]) 		ifTrue: 				[  self initializeOffsets. 				 ^ self milliSecondsSinceMidnight ].		^msm! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/19/2006 15:01'!readFrom: aStream	| bc year month day hour minute second nanos offset buffer ch |	aStream peek = $- ifTrue: [ aStream next. bc _ -1] ifFalse: [bc _ 1].	year _ (aStream upTo: $-) asInteger * bc.	month _ (aStream upTo: $-) asInteger.	day _ (aStream upTo: $T) asInteger.	hour _ (aStream upTo: $:) asInteger. 	buffer _ '00:' copy. ch _ nil.	minute _ WriteStream on: buffer.	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ minute nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $: ].	minute _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '00.' copy.	second _ WriteStream on: buffer.	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ second nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $. ].	second _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '000000000+' copy.	(ch = $.) ifTrue: [ 		nanos _ WriteStream on: buffer.		[ aStream atEnd | ((ch := aStream next) = $+) | (ch = $-) ]			whileFalse: [ nanos nextPut: ch. ].		(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $+ ].	].	nanos _ buffer asInteger.	aStream atEnd		ifTrue: [ offset _ self localOffset ]		ifFalse:		 	[offset _ Duration fromString: (ch asString, '0:', aStream upToEnd).			(offset = self localOffset) ifTrue: [ offset _ self localOffset ]].	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond:  nanos		offset: offset.	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtMilliSeconds: milliSecondsSinceMidnight	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun.    "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtNanoSeconds: nanoSecondsSinceMidnight	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'clock provider' stamp: 'kph 12/11/2006 20:14'!clock 	 "the provider of real time seconds/milliseconds."	^ ClockProvider ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/13/2007 23:05'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LocalOffset := nil.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/16/2007 06:51'!initializeOffsets 	| epochianSeconds secondsSinceMidnight nowSecs  |	  	LastTick := 0.  	nowSecs :=  self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue. 	epochianSeconds := Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: nowSecs.	DaysSinceEpoch := epochianSeconds days.	secondsSinceMidnight := (epochianSeconds - (Duration days: DaysSinceEpoch hours: 0 minutes: 0 seconds: 0)) asSeconds.  	MilliSecondOffset := (secondsSinceMidnight * 1000 - LastMilliSeconds).	LocalOffset := nil.  ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 12/13/2006 21:46'!startUp: resuming 	resuming ifFalse: [^ self].		[ self initializeOffsets ] fork.	! !!DateAndTime class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone _ TimeZone default ]! !!DateAndTime class methodsFor: 'accessing' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!Debugger methodsFor: 'initialize' stamp: 'ab 3/23/2005 14:03'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list _ #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')		('Tally'			tally				'time in milliseconds to execute')).	Preferences restartAlsoProceeds ifTrue:		[list _ list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!Debugger methodsFor: 'accessing' stamp: 'mtf 4/25/2008 09:27'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNode].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getSelectedText	| m interval text |	m := self getTextMorphWithSelection.	interval := m selectionInterval.	text := m text.	^ text copyFrom: interval first to: interval last	! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getTextMorphWithSelection	"This is extremely ugly... We I need to get a reference of the code pane, which is not easily accessible"	^ (self dependents select: [:m| m isKindOf: PluggableTextMorph]) 		detect: [:m| m selectionInterval first > 1] ifNone: [nil]! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 13:35'!tally	self getTextMorphWithSelection ifNotNilDo: [:o| o tallyIt] ifNil: [Beeper beep]! !!DockingBarMorph class methodsFor: 'samples' stamp: 'edc 6/2/2008 17:17'!example1	" 	DockingBarMorph example1.  	 	(Color lightBlue wheel: 4) do:[:c | DockingBarMorph example1 	color: c; borderColor: c twiceDarker]. 	 	World deleteDockingBars.	"	| instance |	instance := DockingBarMorph new.	""	instance addSpace: 10.	"instance		addMorphBack: (ClockMorph new show24hr: true).	instance addSpacer.	instance		addMorphBack: (ClockMorph new show24hr: true)."	instance addSpace: 10.	""	instance adhereToTop.	""	instance autoGradient: true.	instance layoutInset: 10.	""	^ instance openInWorld! !!DockingBarMorph class methodsFor: 'samples' stamp: 'edc 6/2/2008 17:18'!example2	" 	DockingBarMorph example2.  	World deleteDockingBars.  	"	| menu |	menu := DockingBarMorph new.	""	menu addSpace: 10.	menu		add: 'Squeak'		icon: MenuIcons smallConfigurationIcon		subMenu: self squeakMenu.	menu		add: 'Configuration'		icon: MenuIcons smallWindowIcon		subMenu: self squeakMenu.	menu addSpace: 10.	menu addLine.	menu addSpace: 10.	menu		addMorphBack: (ImageMorph new image: MenuIcons smallBackIcon).	menu addSpace: 10.	menu		addMorphBack: (ImageMorph new image: MenuIcons smallForwardIcon).	menu addSpace: 10.	menu addLine.	menu addSpacer.	""	menu addMorphBack: ProjectNavigationMorph new speakerIcon.	""	menu addSpace: 10.	"menu		addMorphBack: (ClockMorph new show24hr: true).	menu addSpace: 10."	""	menu adhereToTop.	""	menu autoGradient: true.	""	^ menu openInWorld! !!DualChangeSorter methodsFor: 'initialization' stamp: 'edc 7/16/2005 10:46'!morphicWindow		| window |		leftCngSorter _ ChangeSorter new myChangeSet: ChangeSet current.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	^ window! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:18'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ ColorTheme current dialogBorderColor! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:19'!defaultBorderWidth	"answer the default border width for the receiver"	^ ColorTheme current dialogBorderWidth! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54'!initialize	"initialize the state of the receiver"super initialize.""	namedFields _ Dictionary new.		self rebuild! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 18:05'!rebuild	"rebuilds the receiver"	^ self! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 7/12/2003 12:33'!genericTextFieldNamed: aString 	| newField |	newField := ShowEmptyTextMorph new beAllFont: self myFont;				 extent: 400 @ 20;				 contentsWrapped: ''.	namedFields at: aString put: newField.	^ newField! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:18'!inAColumnForText: someMorphs 	^ (self inAColumn: someMorphs) hResizing: #shrinkWrap;		 color: ColorTheme current dialogTextBoxColor;		 borderColor: ColorTheme current dialogTextBoxBorderColor;		 borderWidth: ColorTheme current dialogButtonBorderWidth;		 useRoundedCorners! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:13'!lockedString: aString 	^ self lockedString: aString font: self myFont! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:13'!lockedString: aString font: aFont	^ self inAColumn: {(StringMorph contents: aString font: aFont) lock}! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 7/12/2003 12:29'!myFont	^ Preferences standardEToysFont! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:53'!rightLockedString: aString 	^ self rightLockedString: aString font: self myFont! !!EToyGenericDialogMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:54'!rightLockedString: aString font: aFont 	^ self inARightColumn: {(StringMorph contents: aString font: aFont) lock}! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:55'!rebuild	| bottomButtons |	self removeAllMorphs.	self addARow: {		self			lockedString: 'Please describe this project' translated			font: Preferences standardEToysTitleFont.	}.	self addARow: {self space }.	self addARow: {		self rightLockedString: 'Name:' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self expandedFormat ifTrue: [		self fieldToDetailsMappings do: [ :each |			self addARow: {				self rightLockedString: each third translated.				self inAColumnForText: {(self genericTextFieldNamed: each first) height: each fourth}			}.		].	].	self addARow: {self space }.	bottomButtons _ self expandedFormat		ifTrue: [ { self okButton. self cancelButton } ]		ifFalse: [ { self okButton. self expandButton. self cancelButton } ].	self addARow: bottomButtons.	self fillInDetails.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:29'!space	^ RectangleMorph new extent: 5 @ 5;		 color: Color transparent;		 borderWidth: 0 ! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:56'!copyOutDetails	| newDetails |	newDetails _ Dictionary new.	self fieldToDetailsMappings do: [ :each |		namedFields at: each first ifPresent: [ :field |			newDetails at: each second put: field contents string		].	].	namedFields at: 'projectname' ifPresent: [ :field |		newDetails at: 'projectname' put: field contents string withBlanksTrimmed.	].	^newDetails! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/20/2000 09:45'!doExpand	self expandedFormat: true.	self copyOutDetails.	self rebuild.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:43'!doOK	self validateTheProjectName ifFalse: [^false].	actionBlock value: self copyOutDetails.	self delete.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:24'!expandButton	^self		buttonNamed: 'More' translated		action: #doExpand 		color: self buttonColor 		help: 'Show more info on this project.' translated.! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'dgd 3/16/2004 12:10'!expandedFormat	^ Preferences expandedPublishing			or: [self valueOfProperty: #expandedFormat ifAbsent: [false]]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/20/2000 09:40'!expandedFormat: aBoolean	self setProperty: #expandedFormat toValue: aBoolean! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:33'!fieldToDetailsMappings	^#(		(#description 'projectdescription' 'Description:' 100) 		(#author 'projectauthor' 'Author:' 20) 		(#category 'projectcategory' 'Category:' 20)		(#subCategory 'projectsubcategory' 'Sub-category:' 20)		(#keywords 'projectkeywords' 'Key words:' 20)	)! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55'!fillInDetails	theProject ifNotNil: [		namedFields at: 'projectname' ifPresent: [ :field |			field contentsWrapped: theProject name		].	].	projectDetails ifNotNil: [		self fieldToDetailsMappings do: [ :each |			namedFields at: each first ifPresent: [ :field |				projectDetails at: each second ifPresent: [ :data |					field contentsWrapped: data				].			].		].	].! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:45'!project: aProject actionBlock: aBlock	theProject _ aProject.	actionBlock _ aBlock.	projectDetails _ theProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 11:08'!projectDetails: aDictionary	projectDetails _ aDictionary.! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 15:52'!getFullInfoFor: aProject ifValid: aBlock expandedFormat: expandedFormat	| me |	(me _ self basicNew)		expandedFormat: expandedFormat;		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			].			me delete.			aBlock value.		];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'mir 6/19/2001 10:17'!test1: aProject"EToyProjectDetailsMorph test1: Project current"	(self basicNew)		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			]		];		initialize;		openCenteredInWorld! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/21/2000 15:01'!buttonColor	^color darker! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:25'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f _ SimpleButtonMorph new		target: self;		label: aString translated font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString translated.	col _ (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:24'!cancelButton	^ self		buttonNamed: 'Cancel'		action: #doCancel		color: ColorTheme current cancelColor		help: 'Cancel this Publish operation.'! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/21/2000 15:06'!doCancel	self delete.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:55'!doOK	self validateTheProjectName ifFalse: [^self].	self delete.	actionBlock value: (namedFields at: 'projectname') contents string withBlanksTrimmed.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:25'!fieldForProjectName	| tm |	tm _ self genericTextFieldNamed: 'projectname'.	tm crAction: (MessageSend receiver: self selector: #doOK).	tm setBalloonText: 'Pick a name 24 characters or less and avoid the following characters: : < > | / \ ? * " .' translated.	^tm	! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:23'!okButton	^ self		buttonNamed: 'OK'		action: #doOK		color: ColorTheme current okColor		help: 'Change my name and continue publishing.'! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55'!project: aProject actionBlock: aBlock	theProject _ aProject.	actionBlock _ aBlock.	(namedFields at: 'projectname') contentsWrapped: theProject name.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:36'!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: 'Please name this project'.	}.	self addARow: {		self inAColumnForText: {self fieldForProjectName}	}.	self addARow: {		self okButton.		self cancelButton.	}.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/8/2003 18:53'!validateTheProjectName	| proposed |	proposed _ (namedFields at: 'projectname') contents string withBlanksTrimmed.	proposed isEmpty ifTrue: [		self inform: 'I do need a name for the project' translated.		^false	].	proposed size > 24 ifTrue: [		self inform: 'Please make the name 24 characters or less' translated.		^false	].	(Project isBadNameForStoring: proposed) ifTrue: [		self inform: 'Please remove any funny characters from the name' translated.		^false	].	proposed = theProject name ifTrue: [^true].	(ChangeSorter changeSetNamed: proposed) ifNotNil: [		Utilities inform: 'Sorry that name is already used' translated.		^false	].	^true! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 11/2/2004 21:09'!defaultColor	"answer the default color/fill style for the receiver"	^ ColorTheme current dialogColor! !!EToyProjectRenamerMorph methodsFor: 'initialization' stamp: 'dgd 1/7/2005 19:21'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 useRoundedCorners;		 rebuild! !!EToyProjectRenamerMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:35'!validate: aProject andDo: aBlock	(self new)		project: aProject actionBlock: aBlock;		openCenteredInWorld! !!FileList methodsFor: 'file list menu' stamp: 'edc 4/22/2008 07:03'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: self fullName) binary contentsOfEntireFile)) binary reset.	morphOrList _ aFileStream fileInObjectAndCode.	"(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList _ morphOrList contentsMorph]."	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!FileList methodsFor: 'own services' stamp: 'edc 4/24/2007 09:49'!viewContentsInWorkspace	"View the contents of my selected file in a new workspace"		| aString aFileStream aName |	aString := (aFileStream := directory readOnlyFileNamed: self fullName) setConverterForCode contentsOfEntireFile.	aName := aFileStream localName.	aFileStream close.	UIManager default edit: aString withSqueakLineEndings label: 'Workspace from ', aName! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet pseudoClass: pseudoClass selector: selector	"Returns the source code for a conflict if a conflict is found, otherwise returns nil."	| classOrMeta allChangeSets moreRecentChangeSets conflictingChangeSets changeRecordSource classAndMethodPrintString |	classAndMethodPrintString _ pseudoClass name, (pseudoClass hasMetaclass ifTrue: [' class'] ifFalse: ['']), '>>', selector asString.	changeRecordSource _ pseudoClass sourceCode at: selector.	changeRecordSource isText		ifTrue: [changeRecordSource _ Text					fromString: 'method: ', classAndMethodPrintString, ' was removed']		ifFalse: [changeRecordSource stamp isEmptyOrNil ifTrue:					[self notify: 'Warning: ', classAndMethodPrintString, ' in ', self packageName, ' has no timestamp/initials!!']].	pseudoClass exists ifFalse:		[(self classes at: pseudoClass name) hasDefinition			ifTrue: [^ nil  "a method was added for a newly defined class; not a conflict"]			ifFalse: [self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString, '... class ', pseudoClass name asString, ' does not exist in the image and is not defined in the file'.					^ changeRecordSource]].	classOrMeta _ pseudoClass realClass.	"Only printout the replacing methods here, but we still check for removed methods too in the rest of this method."	(self class verboseConflicts and: [classOrMeta includesSelector: selector])		ifTrue: [self class logCr; log: '...checking ', classOrMeta asString, '>>', selector asString].	allChangeSets _ ChangesOrganizer allChangeSets.	moreRecentChangeSets _ allChangeSets				copyFrom: (allChangeSets indexOf: updateNumberChangeSet)				to: (allChangeSets size).	conflictingChangeSets _ (moreRecentChangeSets select:		[:cs | (cs atSelector: selector class: classOrMeta) ~~ #none]).	conflictingChangeSets isEmpty ifTrue: [^ nil].	self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString,				(' with newer changeset' asPluralBasedOn: conflictingChangeSets).	conflictingChangeSets do: [:cs | self class log: ' ', cs name].	^ changeRecordSource! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!findUpdateChangeSetMatching: updateNumber	"Find update-changeset beginning with updateNumber, or reasonably close."	"This is to account for the fact that many changeset files are output from final releases, but may be tested for conflicts in a following alpha image, which will often not include that particular update-changeset from the final release but will contain ones near it.  For example, if the file updateNumber is 5180 (from 3.5 final), but the image has no update-changeset beginning with 5180 because it's a 3.6alpha image (which starts at 5181), it will try up to 5190 and down to 5170 for a close match."	| updateNumberChangeSet updateNumberToTry |	updateNumberToTry _ updateNumber.	updateNumberChangeSet _ nil.	[updateNumberChangeSet isNil and: [updateNumberToTry notNil]] whileTrue:		[updateNumberChangeSet _ ChangesOrganizer allChangeSets			detect: [:cs | (cs name beginsWith: updateNumberToTry asString)							and: [(cs name at: (updateNumberToTry asString size + 1)) isDigit not]]			ifNone: [nil].		updateNumberToTry >= updateNumber ifTrue:			[updateNumberToTry < (updateNumber + 10)				ifTrue: [updateNumberToTry _ updateNumberToTry + 1]				ifFalse: [updateNumberToTry _ updateNumber]].		updateNumberToTry <= updateNumber ifTrue:			[updateNumberToTry > (updateNumber - 10)				ifTrue: [updateNumberToTry _ updateNumberToTry - 1]				ifFalse: [updateNumberToTry _ nil  "we're done trying"]].		].	updateNumberChangeSet ifNil:		[(self confirm: 'Warning: No changeset beginning with ',updateNumber asString, ' (within +/- 10) was found in the image.You must have changesets going back this far in your imagein order to accurately check for conflicts.Proceed anyway?')			ifTrue: [updateNumberChangeSet _ ChangesOrganizer allChangeSets first]].	^ updateNumberChangeSet! !!FileStream methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:39'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: (self localName)! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'rej 9/29/2007 09:04'!initialize	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	baseFont := StrikeFont defaultSized: 12.	self passwordFont! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 4/11/2008 08:40'!defaultsQuadsDefiningScriptingFlap	"Answer a structure defining the default items in the Scripting flap.	previously in quadsDeiningScriptingFlap"	^ #(	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')		(ScriptingSystem 		scriptControlButtons 			'Status'				'Buttons to run, stop, or single-step scripts')	(AllScriptsTool			allScriptsToolForActiveWorld	'All Scripts' 		'A tool that lets you control all the running scripts in your world')	(ScriptingSystem		newScriptingSpace			'Scripting'			'A confined place for drawing and scripting, with its own private stop/step/go buttons.')	(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')	(ScriptableButton		authoringPrototype		'Button'			'A Scriptable button')	(ScriptingSystem		prototypicalHolder 		'Holder'			'A place for storing alternative pictures in an animation, etc.')	(RandomNumberTile		new		'Random'		'A tile that will produce a random number in a given range')	(ScriptingSystem		anyButtonPressedTiles	'ButtonDown?'	'Tiles for querying whether the mouse button is down')	(ScriptingSystem		noButtonPressedTiles		'ButtonUp?'		'Tiles for querying whether the mouse button is up')	(SimpleSliderMorph		authoringPrototype		'Slider'			'A slider for showing and setting numeric values.')	(JoystickMorph			authoringPrototype		'Joystick'		'A joystick-like control')	(TextFieldMorph			exampleBackgroundField		'Scrolling Field'	'A scrolling data field which will have a different value on every card of the background')	(PasteUpMorph			authoringPrototype		'Playfield'		'A place for assembling parts or for staging animations')	"(StackMorph 			authoringPrototype		'Stack' 			'A multi-card data base'	)"	(TextMorph				exampleBackgroundLabel	'Background Label' 'A piece of text that will occur on every card of the background')	(TextMorph				exampleBackgroundField		'Background Field'	'A  data field which will have a different value on every card of the background')		) asOrderedCollection! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 4/22/2008 09:08'!defaultsQuadsDefiningStackToolsFlap	"Answer a structure defining the items on the default system Stack Tools flap.	previously in quadsDefiningStackToolsFlap"	^ #(	"(StackMorph 			authoringPrototype		'Stack' 				'A multi-card data base'	)	(StackMorph			stackHelpWindow		'Stack Help'			'Some hints about how to use Stacks')"	(TextMorph				authoringPrototype		'Simple Text'		'Text that you can edit into anything you wish')	(TextMorph				fancyPrototype			'Fancy Text' 		'A text field with a rounded shadowed border, with a fancy font.')	(ScrollableField			newStandAlone			'Scrolling Text'		'Holds any amount of text; has a scroll bar')	(ScriptableButton		authoringPrototype		'Scriptable Button'	'A button whose script will be a method of the background Player')	(StackMorph			previousCardButton 		'Previous Card' 		'A button that takes the user to the previous card in the stack')	(StackMorph			nextCardButton			'Next Card'			'A button that takes the user to the next card in the stack')) asOrderedCollection! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 12/9/2006 09:23'!defaultsQuadsDefiningWidgetsFlap	"Answer a structure defining the default Widgets flap.     previously in quadsDefiningWidgetsFlap"	^ #(	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')	(AllScriptsTool			allScriptsToolForActiveWorld	'AllScripts' 		'A tool that lets you see and control all the runningscripts in your project')	(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')	(GeeMailMorph			new						'Gee-Mail'			'A place to present annotated content')	(RecordingControlsMorph	authoringPrototype		'Sound'				'A device for making sound recordings.')	"(MPEGMoviePlayerMorph	authoringPrototype		'MoviePlayer'		'A Player for MPEG movies')"	(FrameRateMorph		authoringPrototype			'FrameRate'		'An indicator of how fast your system is running')	(MagnifierMorph		newRound					'Magnifier'			'A magnifying glass')	(ScriptingSystem		newScriptingSpace			'Scripting'			'A confined place for drawing and scripting, with its ownprivate stop/step/go buttons.')	(ScriptingSystem		holderWithAlphabet			'Alphabet'			'A source for single-letter objects')	(BouncingAtomsMorph	new						'BouncingAtoms'	'Atoms, mate')	(ObjectsTool				newStandAlone				'ObjectCatalog'		'A tool that lets you browse the catalog of objects')	) asOrderedCollection! !!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 4/10/2008 08:52'!addStandardFlaps	"Initialize the standard default out-of-box set of global flaps. 	This method creates them and places them in my class 	variable #SharedFlapTabs, but does not itself get them 	displayed."	SharedFlapTabs		ifNil: [SharedFlapTabs := OrderedCollection new].	SharedFlapTabs add: self newSqueakFlap.	SharedFlapTabs add: self newSuppliesFlap.	SharedFlapTabs add: self newToolsFlap.	SharedFlapTabs add: self newWidgetsFlap.	"SharedFlapTabs add: self newStackToolsFlap."	Preferences showProjectNavigator		ifTrue: [SharedFlapTabs add: self newNavigatorFlap].	"SharedFlapTabs add: self newPaintingFlap."	SharedFlapTabs add: self newObjectsFlap.	"self disableGlobalFlapWithID: 'Stack Tools' translated.	self disableGlobalFlapWithID: 'Painting' translated."	Preferences showProjectNavigator		ifTrue: [self disableGlobalFlapWithID: 'Navigator' translated].	^ SharedFlapTabs! !!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 5/31/2008 12:05'!newSqueakFlap	"Answer a new default 'Squeak' flap for the left edge of the screen"	| aFlap aFlapTab aButton aClock buttonColor anOffset bb aFont |	aFlap _ PasteUpMorph newSticky borderWidth: 0.	aFlapTab _ FlapTab new referent: aFlap.	aFlapTab setName: 'Squeak' translated edge: #left color: Color brown lighter lighter.	aFlapTab position: (0 @ ((Display height - aFlapTab height) // 2)).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aFlap cellInset: 14@14.	aFlap beFlap: true.	aFlap color: (Color brown muchLighter lighter "alpha: 0.3").	aFlap extent: 150 @ self currentWorld height.	aFlap layoutPolicy: TableLayout new.	aFlap wrapCentering: #topLeft.	aFlap layoutInset: 2.	aFlap listDirection: #topToBottom.	aFlap wrapDirection: #leftToRight.	"self addProjectNavigationButtonsTo: aFlap."	anOffset _ 16.	"aClock _ ClockMorph newSticky.	aClock color: Color red.	aClock showSeconds: false.	aClock font: (TextStyle default fontAt: 3).	aClock step.	aClock setBalloonText: 'The time of day.  If you prefer to see seconds, check out my menu.' translated.	aFlap addCenteredAtBottom: aClock offset: anOffset."	buttonColor _  Color cyan muchLighter.	bb _ SimpleButtonMorph new target: SmalltalkImage current.	bb color: buttonColor.	aButton _ bb copy.	aButton actionSelector: #saveSession.	aButton setBalloonText: 'Make a complete snapshot of the current state of the image onto disk.' translated.	aButton label: 'save' translated font: (aFont _ ScriptingSystem fontForTiles).	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton _ bb copy target: Utilities.	aButton actionSelector: #updateFromServer.	aButton label: 'load code updates' translated font: aFont.	aButton color: buttonColor.	aButton setBalloonText: 'Check the Squeak server for any new code updates, and load any that are found.' translated.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton _ SimpleButtonMorph new target: SmalltalkImage current; actionSelector: #aboutThisSystem;		label: 'about this system' translated font: aFont.	aButton color: buttonColor.	aButton setBalloonText: 'click here to find out version information' translated.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aFlap addCenteredAtBottom: (Preferences themeChoiceButtonOfColor: buttonColor font: aFont) offset: anOffset.	aButton _ TrashCanMorph newSticky.	aFlap addCenteredAtBottom: aButton offset: anOffset.	aButton startStepping.	^ aFlapTab"Flaps replaceGlobalFlapwithID: 'Squeak' translated "! !!Flaps class methodsFor: 'predefined flaps' stamp: 'sw 4/3/2003 16:35'!twiddleSuppliesButtonsIn: aStrip	"Munge item(s) in the strip whose names as seen in the parts bin should be different from the names to be given to resulting torn-off instances"	(aStrip submorphs detect: [:m | m target == StickyPadMorph] ifNone: [nil])		ifNotNilDo:			[:aButton | aButton arguments: {#newStandAlone.  'tear off'}]! !!Form methodsFor: 'testing' stamp: 'ar 7/21/2007 21:37'!isAllWhite	"Answer whether all bits in the receiver are white"	| word |	self unhibernate.	word := Color white pixelWordForDepth: self depth.	1 to: bits size do: [:i | (bits at: i) = word ifFalse: [^ false]].	^ true! !!Fraction methodsFor: 'converting' stamp: 'nice 1/10/2007 02:07'!asFloat	"Answer a Float that closely approximates the value of the receiver.	This implementation will answer the closest floating point number to	the receiver.	It uses the IEEE 754 round to nearest even mode	(can happen in case denominator is a power of two)"		| a b q r exponent floatExponent n ha hb hq q1 |	a := numerator abs.	b := denominator abs.	ha := a highBit.	hb := b highBit.		"If both numerator and denominator are represented exactly in floating point number,	then fastest thing to do is to use hardwired float division"	(ha < 54 and: [hb < 54]) ifTrue: [^numerator asFloat / denominator asFloat].		"Try and obtain a mantissa with 54 bits.	First guess is rough, we might get one more bit or one less"	exponent := ha - hb - 54.	exponent > 0		ifTrue: [b := b bitShift: exponent]		ifFalse: [a := a bitShift: exponent negated].	q := a quo: b.	r := a - (q * b).	hq := q highBit.		"check for gradual underflow, in which case we should use less bits"	floatExponent := exponent + hq - 1.	n := floatExponent > -1023		ifTrue: [54]		ifFalse: [54 + floatExponent + 1022].		hq > n		ifTrue: [exponent := exponent + hq - n.			r := (q bitAnd: (1 bitShift: hq - n) - 1) * b + r.			q := q bitShift: n - hq].	hq < n		ifTrue: [exponent := exponent + hq - n.			q1 := (r bitShift: n - hq) quo: b.			q := (q bitShift: n - hq) bitAnd: q1.			r := (r bitShift: n - hq) - (q1 * b)].			"check if we should round upward.	The case of exact half (q bitAnd: 1) isZero not & (r isZero)	will be handled by Integer>>asFloat"	((q bitAnd: 1) isZero or: [r isZero])		ifFalse: [q := q + 1].			^ (self positive		ifTrue: [q asFloat]		ifFalse: [q asFloat negated])		timesTwoPower: exponent! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:40'!fileIntoNewChangeSet: fullFileName	"FileIn the contents of a gzipped file"	| zipped unzipped cs |	cs := Smalltalk at: #ChangesOrganizer ifAbsent: [ ^self ].	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	cs newChangesFromStream: unzipped named: (FileDirectory localNameFor: fullFileName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:41'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	(suffix = 'gz') | (suffix = '*')		ifFalse: [^ #()].	services := OrderedCollection new.	(suffix = '*') | (fullName asLowercase endsWith: '.cs.gz') | (fullName asLowercase endsWith: '.mcs.gz')		ifTrue: [services add: self serviceFileIn.			(Smalltalk includesKey: #ChangSet)				ifTrue: [services add: self serviceFileIntoNewChangeSet]].	services addAll: self services.	^ services! !!HTTPSocket class methodsFor: 'get the page' stamp: 'edc 6/28/2008 11:18'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	doc := doc  asUnHtml withSqueakLineEndings.	(StringHolder new contents: doc) openLabel: url.! !!HandMorph methodsFor: 'accessing' stamp: 'wiz 12/4/2006 00:16'!targetPoint	"Return the new position of the target.	I.E. return the position of the hand less 	the original distance between hand and target position"	^ self position - targetOffset! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'edc 6/29/2008 08:29'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  Anobject in the segment is the wrong size for the modern version of theclass.  Construct a fake class that is the old size.  Replace themodern class with the old one in outPointers.  Load the segment.Traverse the instances, making new instances by copying fields, andrunning conversion messages.  Keep the new instances.  Bulk forwardbecome the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.Globalize new classes.  Caller may want to do some special install oncertain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClassesrootsToUnhiberhate myProject existing |	RecentlyRenamedClasses _ nil.		"in case old datahanging around"	mapFakeClassesToReal _ smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.Substitute them in outPointers."	ccFixups _ self remapCompactClasses: mapFakeClassesToReal				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is notcompatible'].	endMarker _ segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker _ 'End' clone].	self fixCapitalizationOfSymbols.	arrayOfRoots _ self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream:smartRefStream	].	"When a Project is stored, arrayOfRoots has all objects inthe project, except those in outPointers"	arrayOfRoots do: [:importedObject |		((importedObject isMemberOf: WideString) or: [importedObject isMemberOf: WideSymbol]) ifTrue: [			importedObject mutateJISX0208StringToUnicode.			importedObject class = WideSymbol ifTrue: [				"self halt."				Symbol hasInterned: importedObject asString ifTrue: [:multiSymbol |					multiSymbol == importedObjectifFalse: [						importedObjectbecomeForward: multiSymbol.					].				].			].		].		(importedObject isKindOf: TTCFontSet) ifTrue: [			existing _ TTCFontSet familyName:importedObject familyName						pointSize:importedObject pointSize.	"supplies default"			existing == importedObject ifFalse:[importedObject becomeForward: existing].		].	].	"Smalltalk garbageCollect.   MultiSymbol rehash.  These taketime and are not urgent, so don't to them.  In the normal case, nobad MultiSymbols will be found."	receiverClasses _ self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject |		importedObject class class == Metaclass ifTrue: [selfdeclare: importedObject]].	arrayOfRoots do: [:importedObject |		(importedObject isKindOf: CompiledMethod) ifTrue: [			importedObject sourcePointer > 0 ifTrue:[importedObject zapSourcePointer]].		(importedObject isKindOf: Project) ifTrue: [			myProject _ importedObject.			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences.			self dependentsRestore: importedObject.			"ScriptEditorMorph writingUniversalTiles:				((importedObject projectPreferenceAt:#universalTiles) ifNil: [false])"]].	rootsToUnhiberhate _ arrayOfRoots select: [:importedObject |		importedObject respondsTo: #unhibernate	"ScriptEditors and ViewerFlapTabs"	].	myProject ifNotNil: [		myProject world setProperty: #thingsToUnhibernatetoValue: rootsToUnhiberhate	].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal keys do: [:aFake |			aFake indexIfCompact > 0 ifTrue: [aFakebecomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!Inspector methodsFor: 'accessing' stamp: 'edc 2/16/2007 08:27'!baseFieldList	"Answer an Array consisting of 'self' 	and the instance variable names of the inspected object."	^ (Array with: 'self' with: 'all inst vars')		, object class allInstVarNames asSortedCollection! !!Inspector methodsFor: 'menu commands' stamp: 'edc 7/26/2008 08:36'!copyName	"Copy the name of the current variable, so the user can paste it into the	window below and work with is. If collection, do (xxx at: 1)."	| aClass variableNames |	self selectionUnmodifiable		ifTrue: [^ self changed: #flash].	aClass := self object class.	variableNames := aClass allInstVarNames asSortedCollection at: self selectionIndex - 2.		Clipboard clipboardText: variableNames asText! !!Inspector methodsFor: 'menu commands' stamp: 'edc 11/18/2007 07:26'!defsOfSelection	"Open a browser on all defining references to the selected instance variable, if that's what currently selected. "	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass := self object class) isVariable ifTrue: [^ self changed: #flash].	sel := aClass allInstVarNames asSortedCollection at: self selectionIndex - 2.	self systemNavigation  browseAllStoresInto: sel from: aClass! !!Inspector methodsFor: 'menu commands' stamp: 'edc 7/3/2008 08:42'!referencesToSelection	"Open a browser on all references to the selected instance variable, if that's what currently selected.  1/25/96 sw"	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass := self object class) isVariable ifTrue: [^ self changed: #flash].	sel := (aClass allInstVarNames asSortedCollection) at: self selectionIndex  - 2.	self systemNavigation   browseAllAccessesTo: sel from: aClass! !!Inspector methodsFor: 'selecting' stamp: 'edc 2/16/2007 10:05'!selection	"The receiver has a list of variables of its inspected object.  	One of these is selected. Answer the value of the selected  	variable."	| basicIndex varName |	selectionIndex = 0		ifTrue: [^ ''].	selectionIndex = 1		ifTrue: [^ object].	selectionIndex = 2		ifTrue: [^ object longPrintString].	selectionIndex - 2 <= object class instSize		ifTrue: [varName := object class allInstVarNames asSortedCollection at: selectionIndex - 2 .			^ object instVarNamed: varName].	basicIndex := selectionIndex - 2 - object class instSize.	(object basicSize <= (self i1 + self i2)			or: [basicIndex <= self i1])		ifTrue: [^ object basicAt: basicIndex]		ifFalse: [^ object basicAt: object basicSize - (self i1 + self i2) + basicIndex]! !!Integer methodsFor: 'printing' stamp: 'JPF 6/26/2007 21:11'!hex"receiver is in range 0 to 255. Returns a two 'digit' hexadecimal representation of the receiver.If you want no padding use asHexDigit or printStringHex. i.e.     15 printStringHex ==  'F'     15 asHexDigit == $F     15 hex == '0F'"^self printStringBase: 16 length: 2 padded: true!]style[(3 126 99 62)f2b,f2,f1,f2! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!Interval methodsFor: 'accessing' stamp: 'BG 6/15/2004 22:58'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock   "  startIndex is an positive integer, the collection index where the search is started. "   " during the computation of  val , floats are only used when the receiver contains floats "   | index val |   (self rangeIncludes: anElement)       ifFalse: [^0].   	val _ (anElement - self first)  / self increment.	val fractionPart abs * 100000000 < step abs	  ifFalse: [^0]	  ifTrue: [index := val rounded + 1].   " finally, the value of  startIndex  comes into play: "   ^index < startIndex      ifTrue: [0]      ifFalse: [index].! !!Interval methodsFor: 'enumerating' stamp: 'apb 4/22/2007 12:38'!reverseDo: aBlock 	"Evaluate aBlock for each element of my interval, in reverse order."	| aValue |	aValue := self last.	step < 0		ifTrue: [[start >= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]		ifFalse: [[start <= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'wiz 9/8/2007 00:19'!isFontAvailable	| encoding f |	encoding := self leadingChar + 1.	f _ TextStyle defaultFont.	f isFontSet ifTrue: [		f fontArray			at: encoding			ifAbsent: [^ false].		^ true	].	encoding = 1 ifTrue: [^ true].	f fallbackFont isFontSet ifFalse: [^false].	f fallbackFont fontArray		at: encoding		ifAbsent: [^ false].	^ true! !!LanguageEnvironment commentStamp: '<historical>' prior: 0!The name multilingualized Squeak suggests that you can use multiple language at one time.  This is true, of course, but the system still how to manage the primary language; that provides the interpretation of data going out or coming in from outside world. It also provides how to render strings, as there rendering rule could be different in one language to another, even if the code points in a string is the same.  Originally, LanguageEnvironment and its subclasses only has class side methods.  After merged with Diego's Babel work, it now has instance side methods.  Since this historical reason, the class side and instance side are not related well.  When we talk about the interface with the outside of the Squeak world, there are three different "channels"; the keyboard input, clipboard output and input, and filename.  On a not-to-uncommon system such as a Unix system localized to Japan, all of these three can have (and does have) different encodings.  S   o       w   e       n   e   e   d       t   o       m   a   n   a   g   e       t   h   e   m       s   e   p   a   r   a   t   e   l   y   .           N   o   t   e       t   h   a   t       t   h   e       e   n   c   o   d   i   n   g       i   n       a       f   i   l   e       c   a   n       b   e       a   n   y   t   h   i   n   g   .           W   h   i   l   e       i   t       i   s       n   i   c   e       t   o       p   r   o   v   i   d   e       a       s   u   g   g   e   s   t   e   d       g   u   e   s   s       f   o   r       t   h   i   s       '   d   e   f   a   u   l   t       s   y   s   t   e   m       f   i   l   e       c   o   n   t   e   n   t       e   n   c   o   d   i   n   g   '   ,       i   t       i   s       n   o   t       c   r   i   t   i   c   a   l   .                 R   e   n   d   e   r   i   n   g       s   u   p   p   o   r   t       i   s       l   i   m   i   t   e   d       b   a   s   i   c       L   -   t   o   -   R       r   e   n   d   e   r   i   n   g       s   o       f   a   r   .           B   u   t       y   o   u       c   a   n       p   r   o   v   i   d   e       d   i   f   f   e   r   e   n   t       l   i   n   e   -   w   r   a   p       r   u   l   e   ,       a   t       l   e   a   s   t   .      !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:48'!defaultClipboardInterpreter	SmalltalkImage current platformName = 'Win32' ifTrue:[^UTF8ClipboardInterpreter new].	ClipboardInterpreterClass ifNil: [ClipboardInterpreterClass := self currentPlatform class clipboardInterpreterClass].	^ ClipboardInterpreterClass new.! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:49'!defaultFileNameConverter	SmalltalkImage current  platformName = 'Win32' ifTrue:[^UTF8TextConverter new].	FileNameConverterClass		ifNil: [FileNameConverterClass := self currentPlatform class fileNameConverterClass].	^ FileNameConverterClass new! !!LinedTTCFont class methodsFor: 'as yet unclassified' stamp: 'ar 11/14/2006 15:18'!fromTTCFont: aTTCFont emphasis: code	| inst |	inst := self new.	inst ttcDescription: aTTCFont ttcDescription.	inst pointSize: aTTCFont pointSize.	inst emphasis: (aTTCFont emphasis bitOr: code).	inst lineGlyph: (aTTCFont ttcDescription at: $_).	^ inst.! !!MCClassDefinition methodsFor: 'installing' stamp: 'edc 6/14/2008 07:19'!createClass	| superClass |	superClass := Smalltalk at: superclassName.	^ (ClassBuilder new)			name: name 			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category! !!MCDependencySorter methodsFor: 'private' stamp: 'edc 7/11/2008 09:04'!removeRequirement: anObject	required  removeKey: anObject ifAbsent: [#()].! !!MCPackageLoader methodsFor: 'public' stamp: 'edc 7/5/2008 18:48'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty		ifFalse: [			self warnAboutDependencies].	self		useNewChangeSetNamedLike: baseName		during: [self basicLoad]! !!MCPackageLoader methodsFor: 'private' stamp: 'edc 7/11/2008 09:39'!analyze	| sorter solved |		sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	solved := Set new.	 requirements		do: [:cl | Object lookForClass: cl.			sorter removeRequirement: cl.			solved add: cl].		requirements := requirements difference: solved.	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.	sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed  ! !!MCPackageLoader methodsFor: 'private' stamp: 'pk 10/17/2006 09:41'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MailComposition methodsFor: 'interface' stamp: 'edc 11/19/2007 10:53'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave suggestedName |	stringToSave := (RWBinaryOrTextStream with: messageText  string) reset.	suggestedName := stringToSave  upToAll: 'Subject: ';nextLine.				suggestedName := (suggestedName, '.text' ) asJoliet.						fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave reset; close]! !!MenuMorph methodsFor: 'construction' stamp: 'pf 11/15/2006 16:42'!addTitle: aString icon: aForm updatingSelector: aSelector updateTarget: aTarget 	"Add a title line at the top of this menu Make aString its initial  	contents.  	If aSelector is not nil, then periodically obtain fresh values for  	its  	contents by sending aSelector to aTarget.."	| title titleContainer |	title := AlignmentMorph newColumn.	self setTitleParametersFor: title.	""	aForm isNil		ifTrue: [titleContainer := title]		ifFalse: [| pair | 			pair := AlignmentMorph newRow.			pair color: Color transparent.			pair hResizing: #shrinkWrap.			pair layoutInset: 0.			""			pair addMorphBack: aForm asMorph.			""			titleContainer := AlignmentMorph newColumn.			titleContainer color: Color transparent.			titleContainer vResizing: #shrinkWrap.			titleContainer wrapCentering: #center.			titleContainer cellPositioning: #topCenter.			titleContainer layoutInset: 0.			pair addMorphBack: titleContainer.			""			title addMorphBack: pair].	""	aSelector		ifNil: [""			aString asString				linesDo: [:line | titleContainer						addMorphBack: (StringMorph contents: line font: Preferences standardMenuFont)]]		ifNotNil: [| usm | 			usm := UpdatingStringMorph on: aTarget selector: aSelector.			usm font: Preferences standardMenuFont.			usm useStringFormat.			usm lock.			titleContainer addMorphBack: usm].	""	title setProperty: #titleString toValue: aString.	self addMorphFront: title.	""	title useSquareCorners.	(self hasProperty: #needsTitlebarWidgets)		ifTrue: [self addStayUpIcons]! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!MessageSet methodsFor: 'private' stamp: 'sd 11/20/2005 21:27'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB: special handling for uniclasses."	| s |	messageList := OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil:					[class isUniClass						ifTrue:							[s := class typicalInstanceName, ' ', sel]						ifFalse:							[s := class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex := messageList isEmpty ifTrue: [0] ifFalse: [1].	contents := ''! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'mtf 4/25/2008 09:33'!definitionST80	"Refer to the comment in ClassDescription|definition."	^ String streamContents: 		[:strm |		strm print: self.		strm			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'mtf 4/25/2008 09:44'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [self methodDict size > 0]! !!Metaclass methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!isSelfEvaluating	^ true! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'jlo 8/23/2007 17:34'!noteNewMethod: newMethod		currentMethod _ newMethod.! !!MethodContext methodsFor: 'closure support' stamp: 'mvl 3/13/2007 11:42'!isExecutingBlock	"Is this executing a block versus a method"	^ self method notNil and: [self method isBlockMethod]! !!MethodContext methodsFor: 'printing' stamp: 'mvl 3/13/2007 11:40'!printString	"Answer an emphasized string in case of a breakpoint method"	^(self method notNil and: [self method hasBreakpoint])		ifTrue:[(super printString , ' [break]') asText allBold]		ifFalse:[super printString]! !!MethodHolder methodsFor: 'menu' stamp: 'pk 11/20/2007 09:54'!doItReceiver	"If there is an instance associated with me, answer it, for true mapping of self.  If not, then do what other code-bearing tools do, viz. give access to the class vars."	^ self selectedClass ifNil: [FakeClassPool new]"KernelImageOverride - EToys removed"! !!MethodNode methodsFor: 'initialize-release' stamp: 'md 2/5/2007 15:40'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 		self 		selector: selOrFalse		arguments: args		precedence: p		temporaries: temps		block: blk encoder:		anEncoder 		primitive: prim 		properties: MethodProperties new.! !!MethodNode methodsFor: 'printing' stamp: 'md 2/3/2007 11:53'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword = #primitive:				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					( (each argumentAt: 1) isNumber and: [(each argumentAt: 1) between: 255 and: 519])						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodReference methodsFor: '*monticello' stamp: 'al 10/9/2005 20:05'!isLocalSelector	^self actualClass		includesLocalSelector: self methodSymbol! !!MethodReference methodsFor: 'queries' stamp: 'edc 5/31/2008 09:38'!systemPackage^(Smalltalk at: self classSymbol) category ! !!MethodReference methodsFor: 'string version' stamp: 'edc 5/23/2007 09:32'!stringVersionstringVersion ifNil: [ stringVersion := self actualClass name, ' >> ', methodSymbol].	^stringVersion! !!ModifiedClassDefinitionEvent methodsFor: '*Kernel-Classes' stamp: 'mtf 4/25/2008 09:36'!anyChanges	^ self isSuperclassModified or: [self areInstVarsModified or: [self areClassVarsModified or: [self areSharedPoolsModified]]]! !!ModifiedClassDefinitionEvent methodsFor: '*Kernel-Classes' stamp: 'mtf 4/25/2008 09:36'!printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' Super: ';		print: self isSuperclassModified;		nextPutAll: ' InstVars: ';		print: self areInstVarsModified;		nextPutAll: ' ClassVars: ';		print: self areClassVarsModified;		nextPutAll: ' SharedPools: ';		print: self areSharedPoolsModified.! !!Morph methodsFor: 'geometry' stamp: 'nk 4/27/2003 16:16'!intersects: aRectangle	"Answer whether aRectangle, which is in World coordinates, intersects me."	^self fullBoundsInWorld intersects: aRectangle! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53'!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !!Morph methodsFor: 'macpal' stamp: 'pk 11/13/2007 10:59'!currentVocabulary	"Answer the receiver's current vocabulary"		^ super currentVocabulary		"KernelImageOverride - EToys processing removed"! !!Morph methodsFor: 'menus' stamp: 'wiz 12/4/2006 00:24'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsOfColor:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsOfColor:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'edc 6/7/2008 11:39'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	self mustBeBackmost ifFalse:		[aMenu add: 'send to back' translated action: #goBehind.		aMenu add: 'bring to front' translated action: #comeToFront.		self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.		aMenu addLine].	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addBorderStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	"self addStackItemsTo: aMenu."	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'wiz 10/19/2006 00:35'!adhereToEdge: edgeSymbol 	| edgeMessage |	(owner isNil or: [owner isHandMorph]) ifTrue: [^self].	(owner class canUnderstand:  edgeSymbol) ifFalse:  [^self].	(self class canUnderstand: ( edgeMessage := (edgeSymbol , ':') asSymbol ))		 ifFalse:  [^self].		self perform: edgeMessage		withArguments: (Array with: (owner perform: edgeSymbol))! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 11/9/2006 23:04'!potentialTargetsAt: aPoint 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| realOwner |	realOwner := self topRendererOrSelf	owner		ifNil: [^ #()].	^ realOwner		morphsAt: aPoint		! !!Morph methodsFor: 'naming' stamp: 'edc 4/22/2008 07:05'!choosePartName	"Pick an unused name for this morph."	| className |	self world ifNil: [^nil].	"(self world model isKindOf: Component) ifTrue:		[self knownName ifNil: [^ self nameMeIn: self world]					ifNotNil: [^ self renameMe]]."	className _ self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	^ self world model addPartNameLike: className withValue: self! !!Morph methodsFor: 'structure' stamp: 'wiz 12/7/2006 15:12'!renderedMorph	"This now  gets overridden by rendering morphs."	^self! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'pk 11/13/2007 11:29'!delete	"Remove the receiver as a submorph of its owner and make its 	new owner be nil."	| aWorld |	self removeHalo.	aWorld := self world ifNil: [World].	"Terminate genie recognition focus"	"I encountered a case where the hand was nil, so I put in a little 	protection - raa "	" This happens when we are in an MVC project and open	  a morphic window. - BG "	aWorld ifNotNil:	  [self disableSubmorphFocusForHand: self activeHand.	  self activeHand releaseKeyboardFocus: self;		  releaseMouseFocus: self.].	owner ifNotNil:[ self privateDelete.].	"KernelImageOverride - Players processing removed"! !!Morph methodsFor: 'testing' stamp: 'pk 11/13/2007 11:41'!renameTo: aName 		^aName	"KernelImageOverride - TODO: this method should be safely removed"! !!Morph methodsFor: 'private' stamp: 'pk 11/13/2007 10:37'!privateMoveBy: delta 	"Private!! Use 'position:' instead."	| fill |	bounds _ bounds translateBy: delta.	fullBounds ifNotNil: [fullBounds _ fullBounds translateBy: delta].	fill _ self fillStyle.	fill isOrientedFill ifTrue: [fill origin: fill origin + delta]	"KernelImageOverride - removed extension processing"! !!Morph class methodsFor: 'fileIn/Out' stamp: 'pk 11/20/2007 11:14'!fromFileName: fullName	"Reconstitute a Morph from the file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	aFileStream _ (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: fullName) binary contentsOfEntireFile)) binary reset.	morphOrList _ aFileStream fileInObjectAndCode.	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			morphOrList openInWorld]		"KernelImageOverride - SqueakPage removed"! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'edc 6/25/2008 10:11'!fileName" I need this hack for have the local fila name when drag and drop a file "| fileName pos  |fileName := (self name findTokens: FileDirectory slash) last.			pos := fileName findString: '.sqz'.			fileName := fileName copyFrom: 1 to: pos - 1.			^ fileName! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'apb 2/19/2007 13:31'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002)					beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!Number methodsFor: 'printing' stamp: 'fcs 12/13/2006 19:47'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point.  It now handles negative numbers between 0 and -1 and rounds correctly in more cases.  This method probably could be optimized -- improvements welcomed.  Category was/is 'converting' but should be 'printing' "	| precision rounded frac sign integerString fractionString result |	placesDesired <= 0 ifTrue: [^ self rounded printString].	precision _ Utilities floatPrecisionForDecimalPlaces: placesDesired.	rounded _ self roundTo: precision.	sign := rounded negative ifTrue: ['-'] ifFalse: [''].	integerString := rounded abs integerPart asInteger printString.	frac := ((rounded abs fractionPart roundTo: precision) * (10 raisedToInteger: placesDesired)) asInteger.	fractionString := frac printString padded: #right to: placesDesired with: $0.	result := sign , integerString , '.' , fractionString.	^result"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 2-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2Number categoryForSelector: #printShowingDecimalPlaces:"! !!Object methodsFor: 'error handling' stamp: 'edc 7/31/2008 06:39'!dpsTraceUntilRoot: anObject	| reportString context count |		Transcript open.		reportString := (anObject respondsTo: #asString) 			ifTrue: [anObject asString] ifFalse: [anObject printString].	(Smalltalk at: #Decompiler ifAbsent: [nil]) 	ifNil: 		[Transcript cr; show: reportString]	ifNotNil:		[context := thisContext.		count := 1.		[Transcript cr.			Transcript show: count printString, ': '.						reportString notNil			ifTrue:				[Transcript show: context home class name 			, '/' , context sender selector,  ' (' , reportString , ')'.				context := context sender.				reportString := nil]			ifFalse:				[(context notNil and: [(context := context sender) notNil])				ifTrue: [Transcript show: context receiver class name , '/' , context selector.					count := count + 1]].	context sender notNil]whileTrue]! !!Object methodsFor: 'evaluating' stamp: 'edc 7/18/2005 10:51'!ancestors|  nonMetaClass  classList |	nonMetaClass := self theNonMetaClass.			classList := OrderedCollection new.		nonMetaClass allSuperclasses reverseDo: 		[:aClass | 		classList add: aClass name.		].	^ classList! !!Object methodsFor: 'evaluating' stamp: 'edc 7/18/2005 10:51'!othersClassList|classList metodosSospechosos | classList := Set new.metodosSospechosos := self  methodDict .metodosSospechosos isEmpty		ifFalse: [metodosSospechosos				collect: [:cm | cm literals						select: [:any | any isVariableBinding]						thenCollect: [:each | (Smalltalk at: each key ifAbsent:[])								ifNotNil: [  classList add: each key]]]].					metodosSospechosos := self class methodDict .metodosSospechosos isEmpty		ifFalse: [metodosSospechosos				collect: [:cm | cm literals						select: [:any | any isVariableBinding]						thenCollect: [:each | (Smalltalk at: each key ifAbsent:[])								ifNotNil: [classList add: each key]]]].					classList remove: self name  ifAbsent: [].					^classList					! !!Object methodsFor: 'message handling' stamp: 'st 11/5/2004 16:19'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: 'objects from disk' stamp: 'edc 9/6/2008 19:40'!fileOutCompressed| unzipped zipped buffer aFileName |aFileName := self class name asFileName.	"do better?"	aFileName := UIManager default 				request: 'File name?' translated initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ Beeper beep].Cursor writeshowWhile: [unzipped := RWBinaryOrTextStream on: ''.unzipped fileOutClass: nil andObject: self.unzipped reset.zipped := FileDirectory default newFileNamed: aFileName , 'obz'.zipped binary.zipped := GZipWriteStream on: zipped.buffer := ByteArray new: 50000.'Compressing ' , self namedisplayProgressAt: Sensor cursorPointfrom: 0to: unzipped sizeduring: [:bar | [unzipped atEnd]whileFalse: [bar value: unzipped position.zippednextPutAll: (unzipped nextInto: buffer)].zipped close.unzipped close]]! !!Object methodsFor: 'objects from disk' stamp: 'edc 9/5/2008 08:57'!saveOnFileNamed: aString 	"Ask the user for a filename and save myself on a	SmartReferenceStream file. Writes out the version and class structure.	The file is fileIn-able. UniClasses will be filed out.	This save objects as .obj"	| aFileName fileStream |	aString isEmpty		ifTrue: [^ Beeper beep].	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := aString , '.obj'.	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self! !!Object methodsFor: 'testing' stamp: 'pmm 7/6/2006 20:46'!isTrait	"Return true if the receiver is a trait.	Note: Do not override in any class except TraitBehavior."	^false! !!Object class methodsFor: 'instance creation' stamp: 'edc 9/6/2008 08:57'!lookForClass: aClass 	| path inputStream fcb superPseudo pseudo |	path := self lookForClassIn3dot10: aClass.	inputStream := HTTPLoader default retrieveContentsFor: path.	inputStream := RWBinaryOrTextStream with: inputStream content unzipped.	fcb := FilePackage new fullName: aClass;								fileInFrom: (MultiByteBinaryOrTextStream with: inputStream contents).	pseudo := fcb classes at: aClass.	superPseudo := pseudo definition copyUpTo: Character space.	Smalltalk		at: superPseudo asSymbol		ifAbsent: [self lookForClass: superPseudo].	ChangeSorter newChangesFromStream: inputStream named: aClass asString! !!Object class methodsFor: 'instance creation' stamp: 'edc 9/6/2008 10:54'!lookForClassIn3dot10: aClass 	| inputStream cat path |		Missing3dot10		ifNil: [inputStream := HTTPLoader default retrieveContentsFor: 'ftp.squeak.org/various_images/SqueakLight//SLupdates/Organizer3dot10.obj'.			inputStream := (MultiByteBinaryOrTextStream with: inputStream contents) reset.			inputStream setConverterForCode.			Smalltalk at: #Missing3dot10 put: inputStream fileInObjectAndCode].	cat := Missing3dot10				at: aClass				ifAbsent: [^ self lookForClassIn3dot9: aClass].	^ path := 'http://squeakros.atspace.com/3dot10/' , cat , '/' , aClass asString , '.sqz'! !!Object class methodsFor: 'instance creation' stamp: 'edc 9/6/2008 10:52'!lookForClassIn3dot9: aClass 	| inputStream cat path |	Missing3dot9		ifNil: [inputStream := HTTPLoader default retrieveContentsFor: 'ftp.squeak.org/various_images/SqueakLight//SLupdates/Organizer3dot9.obj'.			inputStream := (MultiByteBinaryOrTextStream with: inputStream contents) reset.			inputStream setConverterForCode.			Smalltalk at: #Missing3dot9 put: inputStream fileInObjectAndCode].	cat := Missing3dot9				at: aClass				ifAbsent: [^ self error: aClass , ' is not on  server '].	^path := 'http://squeakros.atspace.com/3dot9/' , cat , '/' , aClass asString , '.sqz'.	! !!Object class methodsFor: 'objects from disk' stamp: 'edc 7/27/2008 07:33'!readAndInspect: inputStream 	inputStream setConverterForCode.	inputStream fileInObjectAndCodeForProject inspect! !!Object class methodsFor: 'objects from disk' stamp: 'edc 7/27/2008 08:11'!readCompressedObject: aFileStream 		self readAndInspect: (MultiByteBinaryOrTextStream with: (GZipReadStream on: aFileStream) upToEnd) reset! !!Object class methodsFor: '*services-extras' stamp: 'edc 7/27/2008 06:55'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	services := OrderedCollection new.	(fullName asLowercase endsWith: '.obz')		ifTrue: [services add: self serviceCompressedObject].	(fullName asLowercase endsWith: '.obj')		ifTrue: [services add: self serviceLoadObject].	^ services! !!Object class methodsFor: '*services-extras' stamp: 'edc 7/27/2008 07:40'!serviceCompressedObject	"Answer a service for opening a saved Object"	^ (SimpleServiceEntry		provider: Object		label: 'gz saved Object'		selector: #readCompressedObject:		description: 'open a gz Object'		buttonLabel: 'object')		argumentGetter: [:fileList | 						fileList readOnlyStream]! !!Object class methodsFor: '*services-extras' stamp: 'edc 2/14/2008 08:26'!serviceLoadObject"Answer a service for opening a saved Object"	^ (SimpleServiceEntry 		provider: self 		label: 'saved Object'		selector: #readAndInspect:		description: 'open a Object'		buttonLabel: 'object')		argumentGetter: [:fileList | fileList readOnlyStream]! !!ObjectsTool methodsFor: 'categories' stamp: 'edc 12/4/2007 15:34'!showCategory: aCategoryName fromButton: aButton 	"Project items from the given category into my lower pane"	| quads |	"self partsBin removeAllMorphs. IMHO is redundant, "		Cursor wait		showWhile: [quads := OrderedCollection new.			Morph withAllSubclasses				do: [:aClass | aClass theNonMetaClass						addPartsDescriptorQuadsTo: quads						if: [:aDescription | aDescription translatedCategories includes: aCategoryName]].			quads := quads						asSortedCollection: [:q1 :q2 | q1 third <= q2 third].			self installQuads: quads fromButton: aButton]! !!PackageInfo methodsFor: 'dependencies' stamp: 'edc 5/31/2008 09:43'!externalPackages	 ^self externalUsers collect: [:mr | mr key systemPackage]		! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 5/22/2007 11:28'!tallyIt	^ self tallySelection! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 3/23/2005 16:49'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt cm v valueAsString |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: (Array with: ctxt)].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'mtf 5/1/2008 12:01'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isBehavior)					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil.		] ifFalse:[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'edc 6/2/2008 18:40'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ MenuMorph fromArray: {		{'explain' translated.						#explain}.		{'pretty print' translated.					#prettyPrint}.		{'pretty print with color' translated.		#prettyPrintWithColor}.		{'file it in (G)' translated.					#fileItIn}.		"{'tiles from it' translated.					#selectionAsTiles}."		{'spawn (o)' translated.						#spawn}.		#-.		{'browse it (b)' translated.					#browseIt}.		{'senders of it (n)' translated.				#sendersOfIt}.		{'implementors of it (m)' translated.		#implementorsOfIt}.		{'references to it (N)' translated.			#referencesToIt}.		#-.		{'selectors containing it (W)' translated.	#methodNamesContainingIt}.		{'method strings with it (E)' translated.	#methodStringsContainingit}.		{'method source with it' translated.		#methodSourceContainingIt}.		{'class names containing it' translated.	#classNamesContainingIt}.		{'class comments with it' translated.		#classCommentsContainingIt}.		{'change sets with it' translated.			#browseChangeSetsWithSelector}.		#-.		{'save contents to file...' translated.		#saveContentsInFile}.		{'send contents to printer' translated.	#sendContentsToPrinter}.		{'printer setup' translated.					#printerSetup}.		#-.		{'special menu...' translated.				#presentSpecialMenu}.		{'more...' translated.						#yellowButtonActivity}.	}! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'edc 7/1/2008 07:27'!yellowButtonExpertMenu	^ MenuMorph fromArray: {			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.					#doIt}.			{'print it (p)' translated.				#printIt}.			{'inspect it (i)' translated.				#inspectIt}.			{'explore it (I)' translated.				#exploreIt}.			{'debug it' translated.					#debugIt}.			{'tally it' translated.			#tallyIt}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.			#-.			{'show bytecodes' translated.			#showBytecodes}.			#-.			{'copy html' translated.					#copyHtml}.			#-.			{'more...' translated.					#shiftedTextPaneMenuRequest}.		}.! !!ParagraphEditor class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 14:10'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'instance creation'!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 4/4/2006 16:04'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.			"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.		"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.			"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.			"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.			"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"	'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].	'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	"triplet = {character. comment selector. novice appropiated}"	#(		($a		#selectAll:				true)		($b		#browseIt:				false)		($c		#copySelection:			true)		($d		#doIt:						false)		($e		#exchange:				true)		($f		#find:						true)		($g		#findAgain:				true)		($h		#setSearchString:		true)		($i		#inspectIt:				false)		($j		#doAgainOnce:			true)		($k		#offerFontMenu:		true)		($l		#cancel:					true)		($m	#implementorsOfIt:		false)		($n		#sendersOfIt:			false)		($o		#spawnIt:				false)		($p		#printIt:					false)		($q		#querySymbol:			false)		($s		#save:					true)		($t		#tempCommand:		false)		($u		#align:					true)		($v		#paste:					true)		($w	#backWord:				true)		($x		#cut:						true)		($y		#swapChars:				true)		($z		#undo:					true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet | cmdMap at: triplet first asciiValue + 1 put: triplet second].	CmdActions := cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 10/4/2004 13:53'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap |	"shift-command and control shortcuts"	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.				"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.				"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.				"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.				"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	"triplet = {character. comment selector. novice appropiated}"	#(		($a		argAdvance:						false)		($b		browseItHere:					false)		($c		compareToClipboard:			false)		($d		duplicate:							true)		($e		methodStringsContainingIt:	false)		($f		displayIfFalse:					false)		($g		fileItIn:							false)		($h		cursorTopHome:					true)		($i		exploreIt:							false)		($j		doAgainMany:					true)		($k		changeStyle:						true)		($l		outdent:							true)		($m	selectCurrentTypeIn:			true)		($n		referencesToIt:					false)		($p		makeProjectLink:				true)		($r		indent:							true)		($s		search:							true)		($t		displayIfTrue:					false)		($u		changeLfToCr:					false)		($v		pasteInitials:						false)		($w	methodNamesContainingIt:	false)		($x		makeLowercase:					true)		($y		makeUppercase:					true)		($z		makeCapitalized:				true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet |			cmdMap at: (triplet first asciiValue         + 1) put: triplet second.		"plain keys"			cmdMap at: (triplet first asciiValue - 32 + 1) put: triplet second.		"shifted keys"			cmdMap at: (triplet first asciiValue - 96 + 1) put: triplet second.		"ctrl keys"		].	ShiftCmdActions _ cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sps 7/24/2003 17:25'!multiRedoOverride"Call this to set meta-r to perform the multilevel redo (or tweak the code below to have it bound to some other key sequence).""ParagraphEditor multiRedoOverride."	CmdActions at: $r asciiValue + 1 put: #multiRedo: ! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sbw 10/8/1999 21:42'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!Parser methodsFor: 'error correction' stamp: 'rr 10/3/2007 09:58'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[(UIManager default 				confirm: (temp , ' appears to be\unused in this method.\OK to remove it?') withCRs)				ifTrue: [end _ tempsMark.						["Beginning at right temp marker..."						start _ end - temp size + 1.						end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isAlphaNumeric not & (str at: end+1) isAlphaNumeric not]]]						whileFalse: ["Search left for the unused temp"									end _ requestor nextTokenFrom: end direction: -1].						end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start _ start-1].						requestor correctFrom: start to: end with: ''.						str _ str copyReplaceFrom: start to: end with: ''. 						madeChanges _ true.						tempsMark _ tempsMark - (end-start+1)]]]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48'!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04'!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50'!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!PartsBin methodsFor: '*BabySRE-connectors-initialization' stamp: 'edc 12/4/2007 16:01'!listDirection: aListDirection quadList: quadList buttonClass: buttonClass	"Initialize the receiver to run horizontally or vertically, obtaining its elements from the list of tuples of the form:		(<receiver> <selector> <label> <balloonHelp>)"	| aButton aClass |	self layoutPolicy: TableLayout new.	self listDirection: aListDirection.	self wrapCentering: #topLeft.	self layoutInset: 2.	self cellPositioning: #bottomCenter.	aListDirection == #leftToRight		ifTrue:			[self vResizing: #rigid.			self hResizing: #spaceFill.			self wrapDirection: #topToBottom]		ifFalse:			[self hResizing: #rigid.			self vResizing: #spaceFill.			self wrapDirection: #leftToRight].	quadList do:		[:tuple |			aClass _ Smalltalk at: tuple first.			aButton _ buttonClass new .			aButton color: self color;		initializeToShow: (self class thumbnailForQuad: tuple) withLabel:  tuple third andSend: tuple second to: aClass.			(tuple size > 3 and: [tuple fourth isEmptyOrNil not]) ifTrue:				[aButton setBalloonText: tuple fourth]. 			self addMorphBack: aButton].! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'edc 11/8/2008 08:51'!addCustomMenuItems: menu hand: aHandMorph 	"Add morph-specific menu itemns to the menu for the hand"	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	Preferences noviceMode		ifFalse: ["self addStackMenuItems: menu hand: aHandMorph."			self addPenMenuItems: menu hand: aHandMorph.			self addPlayfieldMenuItems: menu hand: aHandMorph].	self isWorldMorph		ifTrue: [menu addLine.			Preferences noviceMode				ifFalse: [(owner isKindOf: BOBTransformationMorph)						ifTrue: [self addScalingMenuItems: menu hand: aHandMorph]].			menu addUpdating: #showWorldMainDockingBarString action: #toggleShowWorldMainDockingBar.			Flaps sharedFlapsAllowed				ifTrue: [menu						addUpdating: #suppressFlapsString						target: Project current						action: #toggleFlapsSuppressed].			Project current showWorldMainDockingBar				ifFalse: [menu addLine.					TheWorldMainDockingBar instance fillMenuItemsBar: menu].			Preferences noviceMode				ifFalse: [| twm | 					menu addLine.					twm := TheWorldMenu new.					twm						world: self						project: Project current						hand: aHandMorph.					menu add: 'old desktop menu... (W)' translated subMenu: twm buildWorldMenu]]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'edc 4/21/2005 09:55'!collapseAll	"Collapse all windows"	self collapseAllWindows.	self collapseNonWindows! !!PasteUpMorph methodsFor: 'world menu' stamp: 'edc 4/21/2005 09:43'!collapseAllWindows	"World  collapseAllWindows  "| tl |tl _ (30@40) asPoint. self submorphsDo:  [:each | (each isKindOf: SystemWindow  )ifTrue: [ each collapse. each topLeft: tl .tl _ tl +( 0@30) asPoint]]! !!PasteUpMorph methodsFor: 'world state' stamp: 'wiz 12/4/2006 00:32'!paintArea	"What rectangle should the user be allowed to create a new painting in??	An area beside the paintBox. Allow playArea to override with its own	bounds!! "	| playfield paintBoxBounds |	playfield := self				submorphNamed: 'playfield'				ifNone: [].	playfield		ifNotNil: [^ playfield bounds].	paintBoxBounds := self paintBox bounds.	self firstHand targetPoint x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left @ bounds bottom"paint on left side"]		ifFalse: [^ paintBoxBounds right @ bounds top corner: bounds bottomRight]! !!PasteUpMorph class methodsFor: 'project' stamp: 'edc 6/2/2008 17:16'!newWorldTesting	| world ex |	ex _ 500@500.	world _ PasteUpMorph newWorldForProject: nil.	world extent: ex; color: Color orange.	world openInWorld.	world viewBox: (0@0 extent: ex).	"BouncingAtomsMorph new openInWorld: world.""-----	| world window |	world _ PasteUpMorph newWorldForProject: nil.	world extent: 300@300; color: Color orange.	world viewBox: (0@0 extent: 300@300).	window _ (SystemWindow labelled: 'the new world') model: world.	window color: Color orange.	window addMorph: world frame: (0@0 extent: 1.0@1.0).	window openInWorld.---"! !!PluggableListMorph methodsFor: 'model access' stamp: 'apb 5/23/2007 14:16'!basicKeyPressed: aChar 	| oldSelection nextSelection max milliSeconds slowKeyStroke nextSelectionList nextSelectionText |	nextSelection := oldSelection := self getCurrentSelectionIndex.	max := self maximumSelection.	milliSeconds := Time millisecondClockValue.	slowKeyStroke := milliSeconds - lastKeystrokeTime > 300.	lastKeystrokeTime := milliSeconds.	nextSelectionList := OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: ((oldSelection - 1) max: 0)).	slowKeyStroke		ifTrue: ["forget previous keystrokes and search in following elements"			lastKeystrokes := aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addLast: (self getList at: oldSelection)]]		ifFalse: ["append quick keystrokes but don't move selection if it still matches"			lastKeystrokes := lastKeystrokes , aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addFirst: (self getList at: oldSelection)]].	"Get rid of blanks and style used in some lists"	nextSelectionText := nextSelectionList		detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]		ifNone: [^ self flash "match not found"].	"No change if model is locked"	model okToChange ifFalse: [^ self].	nextSelection := self getList findFirst: [:a | a = nextSelectionText].	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'ge 9/6/2006 19:02'!numSelectionsInView	"Answer the scroller's height based on the average number of submorphs."		(scroller submorphCount > 0) ifFalse:[ ^0 ].		"ugly hack, due to code smell.	PluggableListMorph added another level of indirection, 	There is always only one submorph - a LazyListMorph which holds the actual list,	but TransformMorph doesn't know that and we are left with a breach of interface.		see vUnadjustedScrollRange for another bad example."			^scroller numberOfItemsPotentiallyInViewWith: (scroller 												submorphs last getListSize).! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ab 3/23/2005 16:50'!tallyIt	self handleEdit: [textMorph editor tallyIt]! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:21'!back	"Go back one element and return it."	self position = 0 ifTrue: [self errorCantGoBack].	self skip: -1.	^ self peek! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:20'!oldBack	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"	"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)"	self position = 0 ifTrue: [self errorCantGoBack].	self position = 1 ifTrue: [self position: 0.  ^ nil].	self skip: -2.	^ self next! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:02'!peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element := self oldBack.	self skip: 1.	^ element! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'dc 8/1/2007 16:02'!backChunk	"Answer the contents of the receiver back to the previous terminator character.  Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	[(ch := self oldBack) == nil] whileFalse: 			[ch == terminator 				ifTrue: 					[self peekBack == terminator 						ifTrue: [self oldBack	"skip doubled terminator"]						ifFalse: [^ out contents reversed]].			out nextPut: ch].	^ out contents reversed! !!PositionableStream methodsFor: 'positioning' stamp: 'nice 3/10/2008 22:29'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	(anInteger >= 0 and: [anInteger <= readLimit])		ifTrue: [position := anInteger]		ifFalse: [self positionError]! !!PositionableStream methodsFor: 'testing' stamp: 'dc 2/27/2007 16:16'!isEmpty	"Answer whether the receiver's contents has no elements."	"Returns true if both the set of past and future sequence values ofthe receiver are empty. Otherwise returns false"	^ self atEnd and: [position = 0]! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12'!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13'!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14'!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!Process methodsFor: 'changing process state' stamp: 'ar 10/5/2007 18:01'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock inSema |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList := nil.		self primitiveSuspend.	] ifFalse: [		"Since the receiver is not the active process, drop its priority to rock-bottom so that		it doesn't accidentally preempt the process that is trying to terminate it."		priority := 10.		myList ifNotNil: [			myList remove: self ifAbsent: [].			"Figure out if the receiver was terminated while waiting on a Semaphore"			inSema := myList class == Semaphore.			myList := nil].		suspendedContext ifNotNil: [			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(inSema == true and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!Project methodsFor: 'file in/out' stamp: 'edc 2/15/2008 18:30'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world isMorph ifFalse: [		self projectParameters at: #isMVC put: true.		^ false].	"Only Morphic projects for now"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	"ScriptEditorMorph writingUniversalTiles: (self projectParameterAt: #universalTiles ifAbsent: [false])."	holder _ Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots _ OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots _ roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is _ ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is _ ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str _ ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str _ str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans _ (UIManager default				 chooseFrom: #('Do not write file' 'Write file anyway' 'Debug')				 title: str).		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!Project methodsFor: 'file in/out' stamp: 'edc 2/15/2008 18:31'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can containits own classes"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.world currentHand pasteBuffer: nil.	  "don't write the paste buffer."world currentHand mouseOverHandler initialize.	  "forget about anyreferences here"	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState; releaseViewers.world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages."ScriptEditorMorph writingUniversalTiles: (self projectParameterAt:#universalTiles ifAbsent: [false])."holder _ Project allProjects.	"force them in to outPointers, whereDiskProxys are made""Just export me, not my previous version"revertSeg _ self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots _ OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand.	"; addAll: classList; addAll: (classList collect: [:cls | cls class])"roots _ roots reject: [ :x | x isNil].	"early saves may not haveactive hand or thumbnail"	fd _ aDirectory directoryNamed: self resourceDirectoryName.	fd assureExistence.	"Clean up resource references before writing out"	mgr _ self resourceManager.	self resourceManager: nil.	ResourceCollector current: ResourceCollector new.	ResourceCollector current localDirectory: fd.	ResourceCollector current baseUrl: self resourceUrl.	ResourceCollector current initializeFrom: mgr.	ProgressNotification signal: '2:findingResources' extra:'(collecting resources...)' translated.	"Must activate old world because this is run at #armsLength.	Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent	will not be captured correctly if referenced from blocks or user code."	world becomeActiveDuring:[		is _ ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is _ ImageSegment newcopyFromRootsForExport: roots asArray)"	].	self resourceManager: mgr.	collector _ ResourceCollector current.	ResourceCollector current: nil.	ProgressNotification signal: '2:foundResources' extra: ''.	is state = #tooBig ifTrue: [		collector replaceAll.		^ false].str _ ''."considered legal to save a project that has never been entered"(is outPointers includes: world) ifTrue: [	str _ str, '\Project''s own world is not in the segment.' translated withCRs].str isEmpty ifFalse: [	ans _ (PopUpMenu labels: 'Do not write fileWrite file anywayDebug' translated) startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at:#revertToMe put: revertSeg].		collector replaceAll.		^ false].	ans = 3 ifTrue: [		collector replaceAll.		self halt: 'Segment not written' translated]].	stacks _ is findStacks.	is		writeForExportWithSources: aFileName		inDirectory: fd		changeSet: aChangeSetOrNil.	SecurityManager default signFile: aFileName directory: fd.	"Compress all files and update check sums"	collector forgetObsolete.	self storeResourceList: collector in: fd.	self storeHtmlPageIn: fd.	self storeManifestFileIn: fd.	self writeStackText: stacks in: fd registerIn: collector.	"local proj.005.myStack.t"	self compressFilesIn: fd to: aFileName in: aDirectoryresources: collector.			"also deletes the resource directory"	"Now update everything that we know about"	mgr updateResourcesFrom: collector.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.collector replaceAll.world flapTabs do: [:ft |		(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].is arrayOfRoots do: [:obj |	obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].^ true! !!Project methodsFor: 'file in/out' stamp: 'edc 2/15/2008 18:31'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |(World == world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World checkCurrentHandForObjectToPaste2.is _ ImageSegment new copyFromRootsLocalFileFor: 		(Array with: world presenter with: world)	"world, and all Players"	sizeHint: 0.is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ Beeper beep].false ifTrue: [	str _ String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter)  ifTrue: [				strm cr. out printOn: strm.				self systemNavigation					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				self systemNavigation					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !!Project methodsFor: 'menu messages' stamp: 'edc 6/29/2008 08:51'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.' translated.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards _ guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to' translated]]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' translated withCRs			trueChoice: 'Revert to saved version' translated			falseChoice: 'Cancel' translated.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to' translated]]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old _ CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject _ nil	] ifFalse: [		returningFlag			ifTrue: [nextProject _ CurrentProject]			ifFalse: [previousProject _ CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject _ self.	self installProjectPreferences.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil _ World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install.			"world transferRemoteServerFrom: old world."			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result _" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world triggerEvent: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess _ [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!ProjectNavigationMorph methodsFor: 'buttons' stamp: 'edc 5/31/2008 12:05'!makeTheAdvancedButtons	^{		self buttonNewProject.		"self buttonShare."		self buttonPrev.		self buttonNext.		self buttonPublish.		self buttonNewer.		self buttonTell.		self buttonFind.		self buttonFullScreen.		"self buttonFlaps."		self buttonPaint.	},	(		Preferences includeSoundControlInNavigator ifTrue: [{self buttonSound}] ifFalse: [#()]	),	{		self buttonLanguage.		self buttonUndo.		self buttonQuit.	}! !!ReadStream methodsFor: 'accessing' stamp: 'ar 3/18/2007 03:16'!nextFloat	"Read a floating point value from the receiver. This method is highly optimized for cases	where many floating point values need to be read subsequently. And if this needs to go	even faster, look at the inner loops fetching the characters - moving those into a plugin	would speed things up even more."	| buffer count sign index cc value digit fraction exp startIndex anyDigit digitNeeded |	buffer := collection.	count := readLimit.	index := position+1.	"Skip separators"	index := ByteString findFirstInString: buffer inSet: String noSeparatorMap startingAt: index.	index = 0 ifTrue:[self setToEnd. ^nil].	"check for sign"	digitNeeded := false.	sign := 1. cc := buffer byteAt: index.	cc = 45 "$- asciiValue"		ifTrue:[sign := -1. index := index+1. digitNeeded := true]		ifFalse:[cc =  43 "$+ asciiValue" ifTrue:[index := index+1. digitNeeded := true]].	"Read integer part"	startIndex := index.	value := 0.	[index <= count and:[		digit := (buffer byteAt: index) - 48. "$0 asciiValue"		digit >= 0 and:[digit <= 9]]] whileTrue:[			value := value * 10 + digit.			index := index + 1.	].	anyDigit := index > startIndex.	index > count ifTrue:[		(digitNeeded and:[anyDigit not]) ifTrue:[^self error: 'At least one digit expected'].		self setToEnd. ^value asFloat * sign].	(buffer byteAt: index) = 46 "$. asciiValue" ifTrue:["<integer>.<fraction>"		index := index+1.		startIndex := index.		"NOTE: fraction and exp below can overflow into LargeInteger range. If they do, then things slow down horribly due to the relatively slow LargeInt -> Float conversion. This can be avoided by changing fraction and exp to use floats to begin with (0.0 and 1.0 respectively), however, this will give different results to Float>>readFrom: and it is not clear if that is acceptable here."		fraction := 0. exp := 1.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				fraction := fraction * 10 + digit.				exp := exp * 10.				index := index + 1.		].		value := value + (fraction asFloat / exp asFloat).		anyDigit := anyDigit or:[index > startIndex].	].	value := value asFloat * sign.	"At this point we require at least one digit to avoid allowing:		- . ('0.0' without leading digits)		- e32 ('0e32' without leading digits) 		- .e32 ('0.0e32' without leading digits)	but these are currently allowed:		- .5 (0.5)		- 1. ('1.0')		- 1e32 ('1.0e32')		- 1.e32 ('1.0e32')		- .5e32 ('0.5e32')	"	anyDigit ifFalse:["Check for NaN/Infinity first"		(count - index >= 2 and:[(buffer copyFrom: index to: index+2) = 'NaN'])			ifTrue:[position := index+2. ^Float nan * sign].		(count - index >= 7 and:[(buffer copyFrom: index to: index+7) = 'Infinity'])			ifTrue:[position := index+7. ^Float infinity * sign].		^self error: 'At least one digit expected'	].	index > count ifTrue:[self setToEnd. ^value asFloat].	(buffer byteAt: index) = 101 "$e asciiValue" ifTrue:["<number>e[+|-]<exponent>"		index := index+1. "skip e"		sign := 1. cc := buffer byteAt: index.		cc = 45 "$- asciiValue"			ifTrue:[sign := -1. index := index+1]			ifFalse:[cc = 43 "$+ asciiValue" ifTrue:[index := index+1]].		startIndex := index.		exp := 0. anyDigit := false.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				exp := exp * 10 + digit.				index := index + 1.		].		index> startIndex ifFalse:[^self error: 'Exponent expected'].		value := value * (10.0 raisedToInteger: exp * sign).	].	position := index-1.	^value! !!RecentMessageSet methodsFor: 'update' stamp: 'kph 4/13/2007 05:43'!updateListsAndCodeIn: aWindow 	self canDiscardEdits ifFalse: [^ self].  	(messageList first = Utilities mostRecentlySubmittedMessage)		ifFalse:			[self reformulateList]		ifTrue:			[self updateCodePaneIfNeeded]! !!ReleaseBuilder methodsFor: 'utilities' stamp: 'edc 3/13/2008 08:36'!fixObsoleteReferences	"ReleaseBuilder new fixObsoleteReferences"	| informee obsoleteBindings obsName realName realClass  |	Preference allInstances do: [:each | 		informee := each instVarNamed: #changeInformee.		((informee isKindOf: Behavior)			and: [informee isObsolete])			ifTrue: [				Transcript show: each name; cr.							each instVarNamed: #changeInformee put:  (Smalltalk at: (informee name copyReplaceAll: 'AnObsolete' with: '') asSymbol  ifAbsent:[])]]. 	CompiledMethod allInstances do: [:method |		obsoleteBindings := method literals select: [:literal |			literal isVariableBinding				and: [literal value isBehavior]				and: [literal value isObsolete]].		obsoleteBindings do: [:binding |			obsName := binding value name.			Transcript show: obsName; cr.			realName := obsName copyReplaceAll: 'AnObsolete' with: ''.			realClass := Smalltalk at: realName asSymbol ifAbsent: [UndefinedObject].			binding isSpecialWriteBinding				ifTrue: [binding privateSetKey: binding key value: realClass]				ifFalse: [binding key: binding key value: realClass]]].	Behavior flushObsoleteSubclasses.	Smalltalk garbageCollect; garbageCollect.	SystemNavigation default obsoleteBehaviors size > 0		ifTrue: [SystemNavigation default inspect]! !!ReleaseBuilderFor3dot10 methodsFor: 'accessing' stamp: 'edc 5/11/2007 14:36'!packagesList | mcc lista pos |lista := OrderedCollection new.mcc := MCWorkingCopyBrowser new.mcc  repository: MCCacheRepository default.lista := mcc workingCopies select:		[:wc |		((wc modified = true) & wc ancestors notEmpty)] thenCollect: [:ea| |packName| packName := ea  ancestry ancestors first name.		pos := packName indexOf: $-.		packName := packName copyFrom: 1 to: pos -1.		lista add: packName].	^ lista! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'edc 4/5/2007 10:18'!addRepositoryToPackageNamed: aString		|pa|	pa := MCPackage named: aString.	pa workingCopy repositoryGroup addRepository: self repository.	^pa workingCopy repositoryGroup! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'rej 3/5/2007 08:17'!flushCaches	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Smalltalk garbageCollect.		"Initialization required for tests: strange why this is not a teardwon method"	SendCaches initializeAllInstances.! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'edc 6/24/2007 10:07'!loadPackages: packageNames	self loadTogether: (packageNames findTokens: ' ', String cr) merge: false! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'edc 7/14/2007 07:01'!loadTogether: aCollection merge: aBoolean	| loader |	loader := aBoolean		ifTrue: [ MCVersionMerger new ]		ifFalse: [ MCVersionLoader new].	aCollection do: [:eachVersion | self addRepositoryToPackageNamed: (eachVersion copyUpTo: $- )].	(self newerVersionsIn: aCollection)		do: [:fn | loader addVersion: (self repository loadVersionFromFileNamed: fn)]  	  	displayingProgress: 'Adding versions...'.	aBoolean		ifTrue: [[loader merge] on: MCMergeResolutionRequest do: [:request |					request merger conflicts isEmpty						ifTrue: [request resume: true]						ifFalse: [request pass]]]		ifFalse: [loader load].		SystemNavigation default obsoleteBehaviors size > 0        ifTrue: [            SystemNavigation default obsoleteBehaviors inspect.            self error:'The changes should be reviewed'].self flushCaches! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'rej 1/29/2007 21:49'!newerVersionsIn: aCollection	^aCollection reject: [:each |		MCWorkingCopy allManagers anySatisfy: [:workingcopy |			workingcopy ancestry ancestorString , '.mcz' = each]].! !!ReleaseBuilderFor3dot10 methodsFor: 'managing updates' stamp: 'rej 1/29/2007 21:58'!updatePackages: packageNames	self loadTogether: (packageNames findTokens: ' ', String cr) merge: true! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'edc 2/26/2007 16:30'!installInBoxAnd310			MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/310' ; user: 'squeak'; password: 'squeak');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'edc 3/14/2007 09:24'!loadLastVersion: aListOfPackageNames | mcw montiNames package version |mcw := MCWorkingCopyBrowser new repository: (MCHttpRepository				location: 'http://source.squeakfoundation.org/39a'				user: ''				password: '').mcw repository ifNotNilDo: [:repos | montiNames := repos readableFileNames ].		aListOfPackageNames do: [:mo |		package := (montiNames detect:[:ea| ea beginsWith: mo] ifNone:[] ) .	package ifNotNil: [	version := mcw repository loadVersionFromFileNamed: package.	version load]].^version! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'muOuser 3/11/2007 10:06'!packages7067	^ 'System-edc.102(sd.101).mcdTests-edc.20(sd.19).mcdKernel-edc.151(sd.150).mcdST80-edc.38.mczMonticello-edc.311.mczCollectionsTests-edc.35.mczGraphics-edc.40(ar.39).mcdSystemChangeNotification-Tests-edc.7.mczGraphicsTests-edc.10(ar.9).mcdSMBase-edc.86(sd.85).mcdKernelTests-edc.51(sd.50).mcdTraits-edc.226.mczFiles-edc.20.mczToolBuilder-Kernel-rej.18.mczXML-Parser-mir.3.mczUniverses-ls.19.mcz'! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'edc 3/14/2007 09:16'!packagesInfluenced" This is a partial response to Ralph request.Lets know what packages could touch some code file what we wish go into image.Intended to load Mantis fix and convert the result to Monticello ""ReleaseBuilderFor3dot10 new packagesInfluenced "| realClass cat p  monti fileName cs |monti := Set new.fileName := UIManager default chooseFileMatching: #('st' 'cs').cs := FilePackage fromFileNamed: fileName.cs classes do: [:cl|  realClass := Smalltalk at: cl name ifAbsent: [ self error: 'This image do not have ', cl asString] .cat := (realClass category findTokens: '-') first.        p := (PackageInfo allPackages collect:[:pi| pi packageName]) .    (p includes: cat) ifTrue:[ monti add: cat]].^ monti.! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'edc 4/1/2007 08:46'!packagesInfluenced: aStream named: aFileName" This is a partial response to Ralph request.Lets know what packages could touch some code file what we wish go into image.Intended to load Mantis fix and convert the result to Monticello ""ReleaseBuilderFor3dot10 new packagesInfluenced "| realClass cat p  monti cs |monti := Set new.cs := FilePackage new fromStream: aStream reset named: aFileName.cs classes do: [:cl|  realClass := Smalltalk at: cl name ifAbsent: [ self error: 'This image do not have ', cl asString] .cat := (realClass category findTokens: '-') first.        p := (PackageInfo allPackages collect:[:pi| pi packageName]) .    (p includes: cat) ifTrue:[ monti add: cat]].packagesList addAll:  monti.! !!ReleaseBuilderFor3dot10 methodsFor: 'packages' stamp: 'edc 7/24/2007 07:41'!saveNewVersion: vv repositoryGroup: (self addRepositoryToPackageNamed: v package name).repository user ifEmpty:[repository user:  (UIManager default request: '3.10 Repository username').repository	password: (UIManager default request: '3.10 Repository  password')].repository storeVersion:  (v newVersionWithName: v uniqueVersionName message: self postcriptTemplate, mantisNo asString)  .! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'rej 1/29/2007 22:27'!advanceToThreeDotTenAlpha"Offer the chance to advance the version number."(self confirm: 'There are no further updates for Squeak 3.9.Do you wish to advance to version 3.10alpha?[Yes] Your system will be marked as 3.10alpha, and you willsubsequently receive ''test pilot'' updates for 3.10.[No] Your system will be marked as 3.9, allowing youto receive only final fixes for the 3.9 stable release.[Neither] You may choose No, and immediately quit without saving,allowing you to make a backup copy before adopting this change.DO YOU WANT TO ADVANCE to Version 3.10alpha now?')	ifTrue: [SystemVersion newVersion: 'Squeak3.10alpha'.			SystemVersion current date: Time now asDate.			self inform: 'You may now save this Version 3.10alpha imageand retrieve updates again for 3.10alpha and beyond.']	ifFalse: [SystemVersion current version: 'Squeak3.9'; date: Time now asDate..			self inform: 'You may now save this Version 3.9 final imageand retrieve updates again for any final fixes to 3.9.- - - - -(If you quit without saving now, your image will revert to3.9without any of the updates you just loaded)']! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'rej 1/29/2007 21:33'!createBackgroundColor| gf |gf := GradientFillStyle  ramp: {0.0->(Color r: 0.97 g: 0.98 b: 1.0) .1.0->(Color r: 0.0 g: 0.658 b: 0.474)}.	gf	origin: 0 @ 0;		direction: 0@400;		normal: 640@0;		radial: false.World fillStyle: gf! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 2/27/2007 07:20'!makeSqueakRelease	| monti |			self unloadSome.		monti := MCWorkingCopyBrowser new.	monti unsortedWorkingCopies		do: [:ea | ((PackageOrganizer default packageNames) includes: (ea package name)) ifFalse:[ ea unregister]].	monti flushAllCaches.			3		timesRepeat: [Smalltalk garbageCollect].	DataStream initialize.	Flaps replaceGlobalFlapwithID: 'Tools' translated.	Flaps replaceGlobalFlapwithID: 'Widgets' translated.	self cleanUpEtoys.	SmalltalkImage current fixObsoleteReferences.		Smalltalk garbageCollect.	ScheduledControllers := nil.	Behavior flushObsoleteSubclasses.	3		timesRepeat: [Smalltalk garbageCollect]! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 5/30/2008 11:02'!makeSqueakThreeTenRelease	"ReleaseBuilderFor3dot10 new makeSqueakThreeTenRelease"World removeAllMorphs.	Transcript open.	self 		makeSqueakThreeTenReleasePhasePrepare;		makeSqueakRelease; 				makeSqueakThreeTenReleasePhaseCleanup;		installInBoxAnd310! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 4/6/2007 06:57'!makeSqueakThreeTenReleasePhaseCleanup	"ReleaseBuilderFor3dot10 new makeSqueakThreeTenReleasePhaseCleanup"| newVersion |	Smalltalk at: #Browser ifPresent:[:br| br initialize].self cleanUnwantedCs.	"Remove existing player references"	References keys do: [:k | References removeKey: k].	Smalltalk garbageCollect.	ScheduledControllers := nil.	Behavior flushObsoleteSubclasses.	SystemNavigation default obsoleteBehaviors isEmpty 		ifFalse: [self error: 'Still have obsolete behaviors'].	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	self fixObsoleteReferences.	"Smalltalk abandonTempNames."	Smalltalk zapAllOtherProjects.	Smalltalk forgetDoIts.	Smalltalk flushClassNameCache.	3 timesRepeat: 			[Smalltalk garbageCollect.			Symbol compactSymbolTable]."SystemVersion current registerUpdate: 7069." "We only need for when start the release"	newVersion := 'Squeak3.10alpha.' , SystemVersion currenthighestUpdate printString. 		newVersion := newVersion ,'.'.	(SourceFiles at: 2) ifNotNil:		[SmalltalkImage current closeSourceFiles; "so copying thechanges file will always work"			 saveChangesInFileNamed: (SmalltalkImage currentfullNameForChangesNamed: newVersion)].	SmalltalkImage current saveImageInFileNamed: (SmalltalkImage currentfullNameForImageNamed: newVersion)		! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 4/5/2007 07:12'!makeSqueakThreeTenReleasePhasePrepare	"ReleaseBuilderFor3dot10 new makeSqueakThreeTenReleasePhasePrepare"	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	Preferences initialize.	"(Object classPool at: #DependentsFields) size > 1 ifTrue: [selferror:'Still have dependents']."	Undeclared isEmpty ifFalse: [self error:'Please clean outUndeclared'].	"Dump all projects"	Project allSubInstancesDo:[:prj| prj == Project currentifFalse:[Project deletingProject: prj]].	"Set new look so we don't need older fonts later"	StandardScriptingSystem applyNewEToyLook.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	ScriptingSystem deletePrivateGraphics.	self cleanUnwantedCs.	"Reinitialize DataStream; it may hold on to some zapped entitities"	DataStream initialize.	"Remove existing player references"	References keys do:[:k| References removeKey: k].	Smalltalk garbageCollect.	ScheduledControllers := nil.	Smalltalk garbageCollect.! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 2/24/2007 12:01'!testObsolete"if we do some classes go, also his test should go"^#(WatchMorphTest)! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 6/28/2007 07:42'!unloadMorphicClasses"These classes don't seem to be used, so unload them.  They always can be loaded later."SystemOrganization classifyAll: #(BorderedStringMorph MouseActionIndicatorMorph CommandTilesMorphTestClickExerciser SpectrumAnalyzerMorph FishEyeMorph SoundDemoMorphMultiuserTinyPaint KidNavigationMorph CodecDemoMorph BlobMorph SoundMorph SubpaneDividerMorphRolloverButtonMorph ClipboardMorph VeryPickyMorphClassRepresentativeMorph PhraseWrapperMorph WatchMorphUpdatingTextMorph PluggableTabBarMorph PartsWindow HeadingMorphZoomMorph UpdatingStringMorphWithArgument SoundSequencerMorphImageMorphWithSpotlight TinyPaint InfoStringMorphUpdatingBooleanStringMorph DrawErrorMorph ViewerRowBalloonRectangleMorph  ViewerEntry MidiInputMorphCachingMorph MovingEyeMorph MIDIPianoKeyboardMorphDoubleClickExample MorphExample RulerMorph LabelStringMorph) under:'Morphic-CandidatesForGo'.(MCPackage named: 'Morphic-CandidatesForGo') unload .#(TheWorldMenu FileServices AppRegistry Preferences FileList) do: [:cl|(Smalltalk at: cl) removeObsolete].self testObsolete do: [:cl|Smalltalk removeClassNamed: cl].3 timesRepeat: [Smalltalk garbageCollect].! !!ReleaseBuilderFor3dot10 methodsFor: 'squeakThreeTen' stamp: 'edc 4/13/2007 18:46'!unloadSome	World removeAllMorphs.	CommandHistory resetAllHistory.	#('Flash' 'StarSqueak' 'SmaCC' 'Speech' 'Movies' 'FixUnderscores' 'OB' 'OmniBrowser' )		do: [:ea | (MCPackage named: ea) unload.			PackageOrganizer default unregisterPackageNamed: ea].	#(#TheWorldMenu #FileServices #AppRegistry #Preferences #FileList )		do: [:cl | (Smalltalk at: cl) removeObsolete].		self unloadMorphicClasses.	SystemOrganization removeEmptyCategories.	! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 4/5/2007 07:11'!cleanUnwantedCs	ChangeSet 		removeChangeSetsNamedSuchThat: [:cs | cs name ~= ChangeSetcurrent name].	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk garbageCollect.! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 4/1/2007 08:22'!newUpdatepackagesList := Set new! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 5/15/2007 08:03'!newUpdateFor: aBugNo"  ReleaseBuilderFor3dot10 new  newUpdateFor: nnnn"|cs updateNo  newName newSet lastName|mantisNo := aBugNo.updateNo := SystemVersion current highestUpdate + 1.lastName := ChangeSet allChangeSetNames last.	newName _ UIManager default		request: 'Please name the new change set:'		initialAnswer: updateNo asString, lastName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet _ ChangeSet basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	cs := newSet .cs preamble:  '"',(Installer mantis preambleCsForRB: aBugNo) withSqueakLineEndings asUnHtml , '"'.cs postscript: '"', self postcriptTemplate, aBugNo asString, '"ReleaseBuilderFor3dot10 new updatePackages: '.self updateToNext.cs editPostscript! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 4/1/2007 10:44'!postcriptTemplate^'To follow this seehttp://bugs.squeak.org/view.php?id= '! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'rej 3/5/2007 09:05'!repository   repository isNil ifTrue: [		repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/310'                user: ''                password: ''.].  ^repository! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'muOuser 3/11/2007 10:06'!updateFrom7067	"ReleaseBuilderFor3dot10 new updateFrom7067"	self updatePackages: 'Monticello-rej.309.mcz'.	"Enable atomic loading"	self addRepositoryToPackageNamed: 'SystemChangeNotification-Tests'.	self updatePackages: self packages7067.	self flushCaches! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 3/16/2007 07:21'!updateTo7070^'EToys-edc.23(md.22).mcd'! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 3/16/2007 07:26'!updateTo7071^'Collections-edc.72(md.71).mcdCollectionsTests-edc.36(35).mcd'! !!ReleaseBuilderFor3dot10 methodsFor: 'updates' stamp: 'edc 7/24/2007 07:30'!updateToNext|  pos packString number stream p1 mcc  |stream := RWBinaryOrTextStream on: String new.mcc := MCWorkingCopyBrowser new.mcc  repository: MCCacheRepository default.mcc workingCopies select:		[:wc |		(wc modified = true)] thenDo: [:ea| self saveNewVersion: ea.				packString :=  ea ancestry ancestorString .		pos := packString indexOf: $..		p1 := packString copyFrom: 1 to: pos -1.		number := (packString copyFrom: pos + 1 to: packString size) asNumber.		packString := p1 ,'.', number  asString , '(', (number - 1) asString ,').mcd'.		packString := packString, Character cr asString.		stream nextPutAll: packString		].ChangeSet current postscript: ChangeSet current postscript, stream contents! !!ReleaseBuilderFor3dot10 commentStamp: 'edc 4/5/2007 10:06' prior: 0!This class has two functions.  One is to hold a few methods that are used by the release team to make an initial or a final release.  These will not be used much.  The other is to manage the update stream.  In general, an update will be a set of Montecello versions.  There will be a "packages" method that lists them, and an "update" method that loads them.  The actual update file will just load these two methods from Montecello and execute them.Once the 3.10 release cycle is over, this class will be useless except for tracking history.For do a new update:With a regular web browser like Firefox you go to http://bugs.squeak.org/view.php?id= nnnnIf you think what this should go into image, then in a Workspace doInstaller mantis createRBforBug: nnnn !!ReleaseBuilderFor3dot10 class methodsFor: 'instance creation' stamp: 'edc 4/1/2007 08:32'!clear" ReleaseBuilderFor3dot10 clear "	current:= nil! !!ReleaseBuilderFor3dot10 class methodsFor: 'instance creation' stamp: 'edc 4/1/2007 08:33'!current" ReleaseBuilderFor3dot10 current inspect "	^current ifNil: [current := (self new) newUpdate]! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 4/22/2008 07:40'!cleanupPhaseFinal" ReleaseBuilderFor3dot11 new cleanupPhaseFinal "| tasks |    tasks := OrderedCollection new                        add: [Smalltalk removeEmptyMessageCategories];                add: [Workspace                        allSubInstancesDo: [:each | each setBindings: Dictionary new]];                add: [Undeclared removeUnreferencedKeys];                add: [Categorizer sortAllCategories];                add: [Symbol compactSymbolTable];	add: [#(#TheWorldMenu #FileServices #AppRegistry #Preferences #FileList )		do: [:cl | (Smalltalk at: cl) removeObsolete]]; add:[Flaps freshFlapsStart]; add:[MCFileBasedRepository flushAllCaches];                 add: [HandMorph releaseCachedState;	initForEvents.self fixObsoleteReferences];                add: [Smalltalk forgetDoIts.	DataStream initialize.	Behavior flushObsoleteSubclasses.	"The pointer to currentMethod is not realy needed (anybody care to fix this) and often holds on to obsolete bindings"	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].Smalltalk garbageCollectMost];                 yourself.Utilities        informUserDuring: [:bar | tasks                do: [:block |                    bar value: block printString.                    [block value]                        on: Error                        do: [:error | Transcript show: error;                                 cr]]]. SystemNavigation default obsoleteClasses isEmpty        ifTrue: [SmalltalkImage current saveSession]        ifFalse: [SystemNavigation default obsoleteClasses                do: [:each | .self halt.[PointerFinder on: each]                        on: Error                        do: [:error | Transcript show: error; cr]]]! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 7/1/2008 07:06'!cleanupPhasePrepareself cleanUnwantedCs.                "SMSqueakMap default clearCaches."" Commented out for no Undeclared on image "#(zapMVCprojects zapAllOtherProjects discardFlash discardFFIcomputeImageSegmentation discardSpeech ) do:[:ea| SystemDictionary removeSelector:ea].#( reserveUrl: saveAsResource saveDocPane saveOnURL saveOnURL:saveOnURLbasic isTurtleRow objectViewed inATwoWayScrollPane) do:[:ea| Morph removeSelector: ea].#(playfieldOptionsMenu presentPlayfieldMenu allScriptEditorsattemptCleanupReporting: modernizeBJProjectscriptorForTextualScript:ofPlayer:) do:[:ea| PasteUpMorph removeSelector:   ea].#(isUniversalTiles noteDeletionOf:fromWorld: scriptorsForSelector:inWorld: tilesToCall: handMeTilesToFire) do:[:ea| Player removeSelector:   ea].Player class removeCategory: 'turtles'.Player removeCategory: 'slots-user'.Morph removeCategory: 'scripting'.ColorType removeCategory: 'tiles'.TheWorldMainDockingBar removeSelector: #hideAllViewersIn: .#(test1 test2) do:[:ea|WorldWindow class removeSelector:   ea].SystemOrganization removeCategoriesMatching: 'UserObjects'.FileList2 class organization classify: #morphicViewOnDirectory: under: 'morphic ui'.FileList2 class organization classify: #morphicView under: 'morphic ui'.SystemOrganization classifyAll: #(AbstractMediaEventMorph ColorSwatch) under: 'MorphicExtras-AdditionalSupport'.! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 2/5/2008 07:33'!getRidOfUnwantedMorphs| objFl aButton  partBin unwantedMorph |aButton _ SimpleButtonMorph new label: 'Tools'.			aButton actWhen: #buttonDown.objFl := Flaps globalFlapTabWithID: 'Objects'.objFl referent showCategory: 'Tools' fromButton: aButton.partBin := objFl referent submorphs at: 1.unwantedMorph := partBin submorphThat: [:any| (any arguments at: 2) = 'SUnit Runner'] ifNone: [].unwantedMorph delete.2 timesRepeat: [unwantedMorph := partBin submorphThat: [:any| (any arguments at: 2) = 'Package Loader'] ifNone: []. "we have two of this "unwantedMorph delete].objFl := Flaps globalFlapTabWithID: 'Tools'.partBin := objFl referent.unwantedMorph := partBin submorphThat: [:any| (any arguments at: 2) = 'Package Loader'] ifNone: [].unwantedMorph delete.unwantedMorph := partBin submorphThat: [:any| (any arguments at: 2) = 'SUnit Runner'] ifNone: [].unwantedMorph delete.! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 4/11/2008 04:41'!prepareforUnloadBookMorphandFriendsSystemOrganization addCategory: #BookMorphandFriends.SystemOrganization classifyAll: #( BookMorph BookPageSorterMorph BookPageThumbnailMorph BooklikeMorph FlexMorph FloatingBookControlsMorph KedamaMorph MethodMorph  MorphThumbnail   StoryboardBookMorph ) under: 'BookMorphandFriends'.! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 6/5/2008 08:08'!prepareforUnloadEtoysSmalltalk removeClassNamed: #FlexibleVocabulariesInfo.SystemOrganization classifyAll: #(ActorState MethodMorph Player Presenter StickySketchMorph UnscriptedPlayer SlotInformation UnscriptedCardPlayer) under: 'MorphicExtras-EToys-Scripting'.#( actorState actorState: isPartsDonor isPartsDonor: player player:) do: [:method|MorphExtension organization classify: method under: '*MorphicExtras-accessing' suppressIfDefault: false].HaloMorph organization classify: #doMakeSiblingOrDup:with: under: 'Old Etoys-handles'.HaloMorph organization classify: #doDupOrMakeSibling:with: under: 'Old Etoys-handles'."self loadTogether: #('Morphic-CandidatesForGo-edc.3.mcz' ) merge: false."SystemOrganization classifyAll: #(ScriptEditorMorph TwoWayScrollPane TabSorterMorph) under:'Morphic-CandidatesForGo'.#('*eToys-queries' '*eToys-eToy vocabularies' '*eToys-color' '*eToys-customevents-custom events' '*eToys-type vocabularies') do:[:ea| Vocabulary class removeCategory: ea].#('*flexibleVocabularies-flexiblevocabularies-scripting' '*flexibleVocabularies-flexibleVocabularies' '*eToys-scripting' '*eToys-new-morph participation' '*eToys-customevents-user events') do:[:ea|Morph class removeCategory:  ea].#(nascentUserScriptInstance userScriptForPlayer: selector:  ) do:[:ea|Player class removeSelector:  ea].Smalltalk removeClassNamed: #FlexibleVocabulariesInfo.Preferences removePreference: #allowEtoyUserCustomEvents. Morph organization classify: #partName:categories:documentation:sampleImageForm: under: '*MorphicExtras-new-morph participation'.#(possiblyReplaceEToyFlaps twiddleSuppliesButtonsIn:) do: [:ea| Flaps class removeSelector:   ea].Flaps clobberFlapTabList.Flaps addStandardFlaps.SystemOrganization classifyAll: #(ComponentLikeModel) under: 'MorphicExtras-Components'! !!ReleaseBuilderFor3dot11 methodsFor: 'cleaning' stamp: 'edc 2/15/2008 10:19'!prepareforUnloadNebraskaSystemOrganization addCategory: #'Nebraska-Refactoring'.SystemOrganization classifyAll: #(EToyGenericDialogMorph EToyProjectDetailsMorph EToyProjectHistoryMorph EToyProjectQueryMorph EToyProjectRenamerMorph EtoyUpdatingThreePhaseButtonMorph) under: 'Nebraska-Refactoring'.WorldState organization classify: #remoteCanvasesDo: under: '*MorphicExtras-nebraska compatible'.! !!ReleaseBuilderFor3dot11 methodsFor: 'squeakThreeEleven' stamp: 'edc 2/5/2008 07:21'!createBackgroundColor| gf |gf := GradientFillStyle  ramp: {0.0->(Color r: 0.97 g: 0.98 b: 1.0) .1.0->(Color r: 0.0 g: 0.658 b: 0.474)}.	gf	origin: 0 @ 0;		direction: 0@400;		normal: 640@0;		radial: false.World fillStyle: gf! !!ReleaseBuilderFor3dot11 methodsFor: 'squeakThreeEleven' stamp: 'edc 5/31/2008 10:09'!makeSqueakThreeTenEleven	"ReleaseBuilderFor3dot11 new makeSqueakThreeTenEleven"	"World removeAllMorphs."	Transcript open.	self cleanupPhasePrepare;getRidOfUnwantedMorphs	"prepareforUnloadBookMorphandFriends;"	;prepareforUnloadEtoys;	prepareforUnloadNebraska	;groupingTests;	unloadSomeMore;unloadSomeMore3;cleanupPhaseFinal;createBackgroundColor! !!ReleaseBuilderFor3dot11 methodsFor: 'squeakThreeEleven' stamp: 'edc 6/5/2008 08:12'!saveInLadrillos: packageName 	| monti ances repo montiNames |	monti := MCWorkingCopyBrowser new.	repo := MCHttpRepository				location: 'http://www.squeaksource.com/Ladrillos'				user: ''				password: ''.	montiNames := repo readableFileNames.		(SystemOrganization categoriesMatching: packageName , '*')		do: [:cat | 			| workingCopy | 			PackageInfo registerPackageName: cat asString.			workingCopy := MCWorkingCopy						forPackage: (MCPackage new name: cat asString).			workingCopy repositoryGroup addRepository: repo.			repo user				ifEmpty: [repo						user: (UIManager default request: 'Ladrillos Repository username').					repo						password: (UIManager default request: 'Ladrillos Repository  password')].			ances := montiNames						detect: [:ea | ea beginsWith: cat asString]						ifNone: [].			ances				ifNil: [repo						storeVersion: (workingCopy newVersionWithName: workingCopy uniqueVersionName message: 'Starting Morphic partition')].			monti workingCopyListChanged; changed: #workingCopySelection; changed: #repositoryList]! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 2/5/2008 07:56'!groupingTests" this is how I build Tests-edc.35 for unload "| classList |classList := OrderedCollection new.	#(TestCase TestResource) do: [:cl|  (Smalltalk at:  cl)		allSubclassesWithLevelDo: [:c :i | classList addFirst: c]		startingLevel: 0].						 	Smalltalk organization addCategory: 'Tests-Others'.	 classList select: [:ea| ((ea basicCategory asString) beginsWith: 'Tests') not] thenDo: [:any|  SystemOrganization classify: any name under: 'Tests-Others']	! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 6/2/2008 09:33'!prepareToUnloadTraits"ReleaseBuilderFor3dot11 new  prepareToUnloadTraits"SystemChangeNotifier uniqueInstancenoMoreNotificationsFor: ProvidedSelectors current;noMoreNotificationsFor: RequiredSelectors current;noMoreNotificationsFor: LocalSends current.self unloadTraitsStubOutAcessors.[ClassDescription subclass: #MetaclassinstanceVariableNames: 'thisClass'classVariableNames: ' 'poolDictionaries: ' 'category: 'Kernel-Classes'.ClassDescription subclass: #ClassinstanceVariableNames: 'subclasses name classPool sharedPools environment category'classVariableNames: ' 'poolDictionaries: ' 'category: 'Kernel-Classes'.] on: Warning do: [:warning | warning resume].Smalltalk allTraits do: [:trait | trait removeFromSystem. trait := nil]."Recompile all methods that were part of a trait"SystemNavigation default allBehaviorsDo: [:class | class selectorsAndMethodsDo: [:sel :method | class ~~ method methodClass ifTrue: [class recompile: sel]. method := nil]. class := nil]."Remove references to traits from various places in the code"self unloadTraits! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 3/13/2008 10:29'!unloadSomeMore#('Tests' 'SMLoader' 'SMBase' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'Universes' 'Installer' 'XML-Parser' )		do: [:ea | (MCPackage named: ea) unload].		self fixObsoleteReferences ! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 3/13/2008 10:29'!unloadSomeMore2"ReleaseBuilderFor3dot11 new unloadSomeMore2;cleanupPhaseFinal "#('BookMorphandFriends'   )		do: [:ea | (MCPackage named: ea) unload].self fixObsoleteReferences! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 5/31/2008 10:09'!unloadSomeMore3"ReleaseBuilderFor3dot11 new unloadSomeMore3;cleanupPhaseFinal;cleanUnwantedCs "#('MorphicExtras-Demo'  'Morphic-CandidatesForGo' 'Nebraska' )		do: [:ea | (MCPackage named: ea) unload].		SystemOrganization removeCategoriesMatching: 'EToys*'.		self fixObsoleteReferences! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 6/2/2008 10:14'!unloadTraits	"ReleaseBuilderFor3dot11 new unloadTraits"	self saveInLadrillos: 'Traits'.	self unloadTraitsClearRefs.	(MCPackage named: 'Traits') unload.	self unloadTraitsTraitsStubs.	self fixObsoleteReferences! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 6/2/2008 09:44'!unloadTraitsClearRefs| loader |	loader _ CodeLoader new.	loader baseURL:'http://installer.pbwiki.org/f/'.		"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('UnloadTraits-ClearRefs.cs' ).	! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 6/2/2008 09:34'!unloadTraitsStubOutAcessors| loader |	loader _ CodeLoader new.	loader baseURL:'http://installer.pbwiki.org/f/'.		"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('UnloadTraits-StubOutAcessors.cs' ).	! !!ReleaseBuilderFor3dot11 methodsFor: 'unloadPackages' stamp: 'edc 6/2/2008 09:45'!unloadTraitsTraitsStubs| loader |	loader _ CodeLoader new.	loader baseURL:'http://installer.pbwiki.org/f/'.		"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('UnloadTraits-TraitsStubs.cs' ).	! !!RunArray methodsFor: 'accessing' stamp: 'nice 2/14/2007 21:59'!at: index put: aValue 	"Set an element of the RunArray"	| runIndex offsetInRun lastValue runLength runReplacement valueReplacement iStart iStop |	index isInteger		ifFalse: [self errorNonIntegerIndex].	(index >= 1			and: [index <= self size])		ifFalse: [self errorSubscriptBounds: index].	self		at: index		setRunOffsetAndValue: [:run :offset :value | 			runIndex := run.			offsetInRun := offset.			lastValue := value].	aValue = lastValue		ifTrue: [^ aValue].	runLength := runs at: runIndex.	runReplacement := Array				with: offsetInRun				with: 1				with: runLength - offsetInRun - 1.	valueReplacement := Array				with: lastValue				with: aValue				with: lastValue.	iStart := offsetInRun = 0				ifTrue: [2]				ifFalse: [1].	iStop := offsetInRun = (runLength - 1)				ifTrue: [2]				ifFalse: [3].	self		setRuns: (runs copyReplaceFrom: runIndex to: runIndex with: (runReplacement copyFrom: iStart to: iStop))		setValues: (values copyReplaceFrom: runIndex to: runIndex with: (valueReplacement copyFrom: iStart to: iStop)).	self coalesce.	^ aValue! !!RunArray class methodsFor: 'instance creation' stamp: 'dc 5/24/2007 10:53'!new: aSize	^ self new: aSize withAll: nil! !!SARInstaller methodsFor: 'client services' stamp: 'edc 6/14/2008 08:33'!fileInMemberNamed: csName	"This is to be used from preamble/postscript code to file in zip members as ChangeSets."	| cs name |	cs _ self memberNamed: csName.	cs ifNil: [ ^self errorNoSuchMember: csName ].		name := csName copyUpToLast: $..	self class fileIntoChangeSetNamed: csName sansPeriodSuffix fromStream: cs contentStream text setConverterForCode.	self installed: cs.! !!SARInstaller methodsFor: 'client services' stamp: 'edc 7/23/2008 14:15'!installMember: memberOrName	| memberName extension isGraphic stream member |	member _ self memberNamed: memberOrName.	member ifNil: [ ^false ].	memberName _ member fileName.	extension _ (FileDirectory extensionFor: memberName) asLowercase.	Smalltalk at: #CRDictionary ifPresent: [ :crDictionary |		(extension = crDictionary fileNameSuffix) ifTrue: [  self fileInGenieDictionaryNamed: memberName. ^true ] ].	extension caseOf: {		[ Project projectExtension ] -> [ self fileInProjectNamed: memberName createView: true ].		[ FileStream st ] -> [ self fileInPackageNamed: memberName ].		[ FileStream cs  ] -> [  self fileInMemberNamed: memberName  ].	[ 'sqz'] -> [  self fileInCompressedCodeNamed: memberName  ]."		[ FileStream multiSt ] -> [  self fileInMemberNamedAsUTF8: memberName  ].		[ FileStream multiCs -> [  self fileInMemberNamedAsUTF8: memberName  ]."['sar'] -> [  self fileInFrom: member contentStream].	[ 'mc' ] -> [ self fileInMonticelloPackageNamed: memberName ].		[ 'mcv' ] -> [ self fileInMonticelloVersionNamed: memberName ].		[ 'mcz' ] -> [ self fileInMonticelloZipVersionNamed: memberName ].		[ 'morph' ] -> [ self fileInMorphsNamed: member addToWorld: true ].		[ 'ttf' ] -> [ self fileInTrueTypeFontNamed: memberName ].		[ 'translation' ] -> [  self fileInMemberNamed: memberName  ].	} otherwise: [		('t*xt' match: extension) ifTrue: [ self openTextFile: memberName ]			ifFalse: [ stream _ member contentStream.		isGraphic _ ImageReadWriter understandsImageFormat: stream.		stream reset.		isGraphic			ifTrue: [ self openGraphicsFile: member ]			ifFalse: [ "now what?" ^false ]]	].	^true! !!SARInstaller methodsFor: 'fileIn' stamp: 'edc 7/23/2008 14:15'!fileInCompressedCodeNamed: csName| cs name |	cs _ self memberNamed: csName.	cs ifNil: [ ^self errorNoSuchMember: csName ].		name := csName copyUpToLast: $..		ChangeSet installCompressedCodeStream: cs contentStream text setConverterForCode		named: csName sansPeriodSuffix .	self installed: cs.! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: 'Sorry that name is already used'. ^nil ].	^ChangeSet basicNewNamed: newName.! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!ScrollBar methodsFor: 'initialize' stamp: 'wiz 12/22/2007 23:01'!initializeMenuButton"initialize the receiver's menuButton"	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	(Preferences valueOfFlag: #scrollBarsWithoutMenuButton)		ifTrue: [menuButton := nil .^ self].	menuButton _ self roundedScrollbarLook		ifTrue: [RectangleMorph					newBounds: ((bounds isWide							ifTrue: [upButton bounds topRight]							ifFalse: [upButton bounds bottomLeft])							extent: self buttonExtent)]		ifFalse: [RectangleMorph					newBounds: (self innerBounds topLeft extent: self buttonExtent)					color: self thumbColor].	menuButton		on: #mouseEnter		send: #menuButtonMouseEnter:		to: self.	menuButton		on: #mouseDown		send: #menuButtonMouseDown:		to: self.	menuButton		on: #mouseLeave		send: #menuButtonMouseLeave:		to: self.	"menuButton 	addMorphCentered: (RectangleMorph 	newBounds: (0 @ 0 extent: 4 @ 2) 	color: Color black)."	self updateMenuButtonImage.	self roundedScrollbarLook		ifTrue: [menuButton color: Color veryLightGray.			menuButton				borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [menuButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: menuButton! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'kph 4/13/2007 05:17'!markMatchingClasses	"If an example is used, mark classes matching the example instance with an asterisk."	| unmarkedClassList firstPartOfSelector receiverString receiver |	self flag: #mref.	"allows for old-fashioned style"	"Only 'example' queries can be marked."	(contents asString includes: $.) ifFalse: [^ self].	unmarkedClassList := classList copy.	"Get the receiver object of the selected statement in the message list."	firstPartOfSelector := (Scanner new scanTokens: (selectorList at: selectorIndex)) second.	receiverString := (ReadStream on: (selectorList at: selectorIndex))						upToAll: firstPartOfSelector.	receiver := Compiler evaluate: receiverString.	unmarkedClassList do: [ :classAndMethod | | class |		(classAndMethod isKindOf: MethodReference) ifTrue: [			(receiver isKindOf: classAndMethod actualClass) ifTrue: [				classAndMethod stringVersion: '*', classAndMethod asStringOrText.			]		] ifFalse: [			class := Compiler evaluate:					((ReadStream on: classAndMethod) upToAll: firstPartOfSelector).			(receiver isKindOf: class) ifTrue: [				classList add: '*', classAndMethod.				classList remove: classAndMethod			]		].	].! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock				"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue caught |	caught := false.	[		caught := true.		self wait.		blockValue := mutuallyExcludedBlock value	] ensure: [caught ifTrue: [self signal]].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:33'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical:[[mutuallyExcludedBlock value] ifCurtailed: terminationBlock]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	self critical:[		blockValue := [mutuallyExcludedBlock value] ifError:[:msg :rcvr|			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:34'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!ShowEmptyTextMorph methodsFor: 'drawing' stamp: 'RAA 2/6/2001 14:09'!drawOn: aCanvas	self setDefaultContentsIfNil.	aCanvas paragraph: self paragraph bounds: bounds color: color.! !!ShowEmptyTextMorph commentStamp: '<historical>' prior: 0!A slight modification on TextMorph to show empty fields just as one would fields with data: with a cursor and without the pink field!!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetPoint.	target := rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SimpleButtonMorph methodsFor: 'objects from disk' stamp: 'pk 11/20/2007 15:59'!objectForDataStream: refStrm	"I am about to be written on an object file.  If I send a message to a BookMorph, it would be bad to write that object out.  Create and write out a URLMorph instead."	| bb |	(actionSelector == #goToPageMorph:fromBookmark:) | 		(actionSelector == #goToPageMorph:) ifFalse: [			^ super objectForDataStream: refStrm].	"normal case"	"Later force target book to get a url."		bb _ SimpleButtonMorph new.	"write out a dummy"		bb label: self label.		bb bounds: bounds.		refStrm replace: self with: bb.		^ bb			"KernelImageOverride - EToys removed"! !!SketchMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:10'!decimalDigitLength	"Answer the number of digits printed out in base 10.	Note that this only works for positive SmallIntegers."		^ self < 10000		ifTrue: [self < 100				ifTrue: [self < 10						ifTrue: [1]						ifFalse: [2]]				ifFalse: [self < 1000						ifTrue: [3]						ifFalse: [4]]]		ifFalse: [self < 1000000				ifTrue: [self < 100000						ifTrue: [5]						ifFalse: [6]]				ifFalse: [self < 100000000						ifTrue: [self < 10000000								ifTrue: [7]								ifFalse: [8]]						ifFalse: [self < 1000000000								ifTrue: [9]								ifFalse: [10]]]]! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:08'!printString	"Highly optimized version for base 10	and that we know it is a SmallInteger."		| integer next result len |	self = 0 ifTrue: [^'0'].	self < 0 ifTrue: [^'-', self negated printString].	len := self decimalDigitLength.	result := String new: len.	integer := self.	len to: 1 by: -1 do: [:i |		next := integer // 10.		result byteAt: i put: 48 + (integer - (next * 10)).		integer := next].	^result! !!SmalltalkImage methodsFor: 'image cleanup' stamp: 'edc 5/30/2008 10:16'!cleanup	"SmalltalkImage current cleanup"	| tasks |    tasks := OrderedCollection new                        add: [Smalltalk removeEmptyMessageCategories];                add: [Workspace                        allSubInstancesDo: [:each | each setBindings: Dictionary new]];                add: [Undeclared removeUnreferencedKeys];                add: [Categorizer sortAllCategories];                add: [Symbol compactSymbolTable];	add: [#(#TheWorldMenu #FileServices #AppRegistry #Preferences #FileList )		do: [:cl | (Smalltalk at: cl) removeObsolete]]; add:[Flaps freshFlapsStart]; add:[MCFileBasedRepository flushAllCaches];                 add: [HandMorph releaseCachedState;	initForEvents.self fixObsoleteReferences];                add: [Smalltalk forgetDoIts.	DataStream initialize.	Behavior flushObsoleteSubclasses.	"The pointer to currentMethod is not realy needed (anybody care to fix this) and often holds on to obsolete bindings"	MethodChangeRecord allInstancesDo: [:each | each noteNewMethod: nil].Smalltalk garbageCollectMost];                 yourself.Utilities        informUserDuring: [:bar | tasks                do: [:block |                    bar value: block printString.                    [block value]                        on: Error                        do: [:error | Transcript show: error;                                 cr]]]. SystemNavigation default obsoleteClasses isEmpty        ifTrue: [SmalltalkImage current saveSession]        ifFalse: [SystemNavigation default obsoleteClasses                do: [:each | .self halt.[PointerFinder on: each]                        on: Error                        do: [:error | Transcript show: error; cr]]]	! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'edc 7/11/2008 07:37'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "| tell choice  newName answ code |	self flag: #bobconv.	tell := 'Reading an instance of ', oldName, '.Which modern class should it translate to?'.answ := (UIManager default 		chooseFrom: #('Let me type the name now' 'Let me think about it''Let me find this on the server') 		title: tell). answ = 1 ifTrue: [	tell := 'Name of the modern class {1} should translate to:' translated format: {oldName}.	choice := UIManager default request: tell.		"class name"	(choice size = 0) 		ifTrue: [answ := 'conversion method needed']		ifFalse: [newName := choice.			answ := Smalltalk at: newName asSymbol 				ifAbsent: ['conversion method needed'].			answ isString ifFalse: [renamed at: oldName asSymbol put: answ name]]].(answ = 3) | (answ = 0) ifTrue: [self close.		^ Object lookForClass:oldName ].answ = 2 ifTrue: [answ := 'conversion method needed'].answ = 'conversion method needed' ifTrue: [		self close.  		newName := 'PutNewClassHere'].code := WriteStream on: (String new: 500).code nextPutAll: sel; cr.code cr; tab; nextPutAll: '^ ', newName.	"Return new class"self class compile: code contents classified: 'conversion'.newName = 'PutNewClassHere' ifTrue: [	self inform: 'Please complete the following method and then read-in the object file again.'.	SystemNavigation default browseAllImplementorsOf: sel asSymbol]. 	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^ answ! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:48'!reverseInPlace	"Change this colleciton into its reversed.	Do not make a copy like reversed do, but change self in place."		| newFirstIndex oldSortBlock |	newFirstIndex := 1 + array size - lastIndex.	lastIndex := 1 + array size - firstIndex.	firstIndex := newFirstIndex.	array := array reversed.	oldSortBlock := (sortBlock ifNil: [[:a :b | a <= b]]) copy.	sortBlock := [:a :b | oldSortBlock value: b value: a] fixTemps! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:28'!reversed	"Answer a collection that Sort elements in reverse order"		^self shallowCopy reverseInPlace! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 2/26/2008 22:52'!testReversed		| sc1 sc2 sc3 |	sc1 := #(1 2 3 4) asSortedCollection.	self assert: sc1 reversed asArray = sc1 asArray reversed.		self		assert: sc1 reversed class = SortedCollection		description: 'reversing a SortedCollection should answer a SortedCollection'.		sc1 removeFirst; removeLast.	sc2 := sc1 reversed.	self assert: sc2 reversed asArray = sc1 asArray.		sc2 add: 3/2; add: 1/2; add: 7/2.	self assert: sc2 asArray = {7/2. 3. 2. 3/2. 1/2}.			sc3 := #(1 2 3 3.0 4) asSortedCollection.	self assert: sc3 reversed asArray = #(4 3.0 3 2 1).	self assert: (sc3 reversed at: 2) class = Float.	! !!SparseLargeTable methodsFor: 'accessing' stamp: 'kwl 6/30/2006 03:02'!zapDefaultOnlyEntries	| lastIndex newInst |	1 to: self basicSize do: [:i |		(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].	].	lastIndex _ self findLastNonNilSubTable.	lastIndex = 0 ifTrue: [^ self].		newInst _ self class new: lastIndex*chunkSize chunkSize: chunkSize arrayClass: (self basicAt: lastIndex) class base: base defaultValue: defaultValue.	newInst privateSize: self size.	base to: newInst size do: [:i | newInst at: i put: (self at: i)].	1 to: newInst basicSize do: [:i |		(newInst allDefaultValueSubtableAt: i) ifTrue: [newInst basicAt: i put: nil].	].	" this is not allowed in production: self becomeForward: newInst. "	^ newInst.! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 3/10/2008 23:13'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	| p |	p := aRadix lowBit - 1.	^k positive		ifTrue: [(m * (((aRadix bitShift: p negated) raisedToInteger: k))) asFloat timesTwoPower: p*k]		ifFalse: [(Fraction numerator: m denominator: (((aRadix bitShift: p negated) raisedToInteger: k negated) bitShift: p*k negated)) asFloat]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:50'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa decimalMultiplier decimalFraction value numberOfTrailingZeroInFractionPart |	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base ifFail: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].		(sourceStream nextMatchAll: 'Infinity')			ifTrue: [^ neg					ifTrue: [Float infinity negated]					ifFalse: [Float infinity]].		^self expected: ['a digit between 0 and 9']].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			(sourceStream peekFor: $-)				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [fractionPart := self						nextUnsignedIntegerBase: base						ifFail: [sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated]								ifFalse: [integerPart]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			self readExponent				ifFalse: [self readScale						ifTrue: [decimalMultiplier := base raisedTo: numberOfNonZeroFractionDigits.							decimalFraction := integerPart * decimalMultiplier + fractionPart / decimalMultiplier.							neg								ifTrue: [decimalFraction := decimalFraction negated].							^ ScaledDecimal newFromNumber: decimalFraction scale: scale]].			fractionPart isZero				ifTrue: [mantissa := integerPart								// (base raisedTo: numberOfTrailingZeroInIntegerPart).					exponent := exponent + numberOfTrailingZeroInIntegerPart]				ifFalse: [mantissa := integerPart								* (base raisedTo: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).					exponent := exponent - numberOfNonZeroFractionDigits].			"very naive algorithm"			value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.			^ neg				ifTrue: [value isZero						ifTrue: [Float negativeZero]						ifFalse: [value negated]]				ifFalse: [value]]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:44'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in	instVar "		^ self		nextUnsignedIntegerBase: aRadix		ifFail: [self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:27'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in instVar"		| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[sourceStream atEnd				or: [digit := sourceStream next digitValue.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	nDigits = 0		ifTrue: [errorBlock value].	^value! !!StrikeFont methodsFor: 'emphasis' stamp: 'rej 9/29/2007 09:02'!setupDefaultFallbackFont	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	self fallbackFont: (StrikeFont defaultSized: self height).	self reset.! !!StrikeFont class methodsFor: 'accessing' stamp: 'rej 9/29/2007 08:50'!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	^f! !!StrikeFontSet methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!String methodsFor: 'accessing' stamp: 'nice 3/15/2007 21:03'!indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock 	"returns the index of the first character in the given set, starting from start "		| ans |	ans := self isWideString				ifTrue: ["Fallback to naive implementation"					self class						findFirstInString: self						inCharacterSet: aCharacterSet						startingAt: start]				ifFalse: ["We know we contain only byte characters						So use a byteArrayMap opimized for primitive call"					self class						findFirstInString: self						inSet: aCharacterSet byteArrayMap						startingAt: start].	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!String methodsFor: 'converting' stamp: 'dc 8/1/2007 16:02'!asSignedInteger	"Returns the first signed integer it can find or nil."	| start stream |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	stream := (ReadStream on: self) position: start.	stream oldBack = $- ifTrue: [stream oldBack].	^ Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'edc 4/23/2007 09:38'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in := ReadStream on: self.	out := WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char := in next) = $&						ifTrue: [rest := in upTo: $;.								did := out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $].								rest = 'quot' ifTrue: [out nextPut: $"].								rest = 'nbsp' ifTrue: [out nextPut: Character nbsp].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'dc 4/10/2007 09:36'!keywords	"Answer an array of the keywords that compose the receiver."	| kwd char keywords |	keywords := Array streamContents:		[:kwds | kwd := WriteStream on: (String new: 16).		1 to: self size do:			[:i |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'ar 7/21/2007 21:50'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := end+1.	[beginning <= self size and:[(self at: beginning) isSeparator]]		whileTrue:[beginning := beginning + 1].	beginning <= self size] whileTrue: [		"find the end"		end := beginning.		[end <= self size and:[(self at: end) isSeparator not]]			whileTrue:[end := end + 1].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!utf8ToSqueak	"Convert the receiver from a UTF8-encoded string"	^self convertFromWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: 'testing' stamp: 'edc 6/27/2008 19:46'!lastPositionOf: aChar	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i)= aChar) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!String class methodsFor: 'instance creation' stamp: 'dc 2/12/2007 10:47'!space	"Answer a string containing a single space character."	^ self with: Character space! !!String class methodsFor: 'primitives' stamp: 'nice 3/15/2007 20:59'!findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start 	"Trivial, non-primitive version"		start		to: aString size		do: [:i | (aCharacterSet					includes: (aString at: i))				ifTrue: [^ i]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:21'!noSeparatorMap	^CSNonSeparators byteArrayMap! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:28'!separatorMap	^CSSeparators byteArrayMap! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:02'!browseClassRefs	| cls |	cls := self selectedClass.	(cls notNil)		ifTrue: [self systemNavigation browseAllCallsOnClass: cls theNonMetaClass]! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:03'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls := self selectedClass.	(cls notNil)		ifTrue: [self systemNavigation  browseClassVarRefs: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:02'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls := self selectedClass.	(cls notNil)		ifTrue: [self systemNavigation  browseClassVariables: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:03'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	| aClass |	(Smalltalk isMorphic and: [Smalltalk includesKey: #Lexicon]) ifFalse: [^ self spawnFullProtocol].	((aClass := self selectedClassOrMetaClass) notNil) ifTrue:		[(Smalltalk at: #Lexicon) new openOnClass: aClass inWorld: ActiveWorld showingSelector: self selectedMessageName]! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:03'!browseInstVarDefs 	| cls |	cls := self selectedClassOrMetaClass.	(cls notNil)		ifTrue: [self systemNavigation browseInstVarDefs: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'mtf 5/1/2008 12:04'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls := self selectedClassOrMetaClass.	(cls notNil)		ifTrue: [self systemNavigation browseInstVarRefs: cls]! !!StringHolder methodsFor: '*Tools' stamp: 'edc 7/31/2007 07:30'!copySelector	"Copy the selected selector to the clipboard"	|  class selector  |	class := self selectedClassOrMetaClass printString.	selector := self selectedMessageName printString.	(selector := self selectedMessageName) ifNotNil:		[Clipboard clipboardText: class, ' ', selector asString]! !!StringHolder methodsFor: '*Tools' stamp: 'edc 10/18/2008 06:11'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName		ifNotNil: [Cursor write				showWhile: [self selectedClassOrMetaClass fileOutMethod: self selectedMessageName asJoliet]]! !!StringHolder methodsFor: 'message list menu' stamp: 'edc 7/16/2005 10:54'!offerDurableMenuFrom: menuRetriever shifted: aBoolean	"Pop up (morphic only) a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state; put a stay-up item at the top of the menu."	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.		self perform: menuRetriever with: aMenu with: aBoolean.		aMenu popUpInWorld! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'mtf 4/25/2008 10:50'!classNamed: aString	"aString is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names."	| meta baseName baseClass |	(aString endsWith: ' class')		ifTrue: [meta _ true.				baseName _ aString copyFrom: 1 to: aString size - 6]		ifFalse: [meta _ false.				baseName _ aString].	baseClass _ Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass classSide]		ifFalse: [^ baseClass]! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'mtf 4/25/2008 07:28'!traitNames	"Answer a SortedCollection of all traits (not including class-traits) names."	^ #()! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'mtf 4/25/2008 09:49'!condenseChanges	"Move all the changes onto a compacted sources file."	"Smalltalk condenseChanges"	| f oldChanges count |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.	'Condensing Changes File...'		displayProgressAt: Sensor cursorPoint		from: 0		to: self classNames size		during: [:bar | 			count := 0.			self				allClassesDo: [:class | 					bar value: (count := count + 1).					class moveChangesTo: f.					class putClassCommentToCondensedChangesFile: f.					class classSide moveChangesTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old';		 rename: oldChanges name toBe: oldChanges name , '.old';		 rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles		at: 2		put: (StandardFileStream oldFileNamed: oldChanges name)! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'mtf 4/25/2008 09:51'!condenseSources		"Move all the changes onto a compacted sources file."	"Smalltalk condenseSources"	| f dir newVersionString count |	Utilities fixUpProblemsWithAllCategory.	"The above removes any concrete, spurious '-- all --' categories, which mess up the process."	dir := FileDirectory default.	newVersionString := UIManager default request: 'Please designate the versionfor the new source code file...' initialAnswer: SmalltalkImage current sourceFileVersionString.	newVersionString ifNil: [^ self].	newVersionString = SmalltalkImage current sourceFileVersionString ifTrue:		[^ self error: 'The new source file must not be the same as the old.'].	SmalltalkImage current sourceFileVersionString: newVersionString.	"Write all sources with fileIndex 1"	f := FileStream newFileNamed: SmalltalkImage current sourcesName.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during:		[:bar | count := 0.		Smalltalk allClassesDo:			[:class | bar value: (count := count + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	SmalltalkImage current closeSourceFiles.	dir rename: SmalltalkImage current changesName		toBe: SmalltalkImage current changesName , '.old'.	(FileStream newFileNamed: SmalltalkImage current changesName)		header; timeStamp; close.	SmalltalkImage current lastQuitLogPosition: 0.	self setMacFileInfoOn: SmalltalkImage current changesName.	self setMacFileInfoOn: SmalltalkImage current sourcesName.	SmalltalkImage current openSourceFiles.	self inform: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'mtf 4/25/2008 09:52'!reconstructChanges		"Move all the changes and its histories onto another sources file."	"Smalltalk reconstructChanges"	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesWithVersionsTo: f.			class putClassCommentToCondensedChangesFile: f.			class classSide moveChangesWithVersionsTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name)! !!SystemDictionary methodsFor: 'retrieving' stamp: 'kph 5/9/2007 03:05'!allTraits	"dummy"	^ #()! !!SystemDictionary methodsFor: '*kernel-extensions' stamp: 'mtf 4/25/2008 07:13'!globals	"Smalltalk  inspectGlobals"		| associations |		associations := OrderedCollection new.		self keysAndValuesDo: [ :key :value |				(value isKindOf: Class)		ifFalse: [ associations add: (key -> value) ]	].	^ associations asSortedCollection: [ :a :b | a key <= b key ].  ! !!SystemNavigation methodsFor: 'browse' stamp: 'mtf 5/1/2008 12:06'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	"SystemNavigation default 		methodHierarchyBrowserForClass: ParagraphEditor 		selector: #isControlActive"		| list tab stab aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ self].	sel ifNil: [^ self].	aClassNonMeta _ aClass theNonMetaClass.	isMeta _ aClassNonMeta ~~ aClass.	list _ OrderedCollection new.	tab _ ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , theClassOrMeta name, ' ', sel]]	 	startingLevel: 0.	self browseMessageList: list name: 'Inheritance of ' , sel! !!SystemNavigation methodsFor: 'query' stamp: 'mtf 4/25/2008 07:15'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses and Traits).	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous	behaviors for which the following should be executed:		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: ProtoObject.	ProtoObject allSubclassesDoGently: aBlock.		"don't bring in ImageSegments"	"Classes outside the ProtoObject hierarchy"	Class subclassesDo: [:aClass |		(aClass == ProtoObject class			or: [aClass isInMemory not			or: [aClass isMeta not]]) ifFalse:			["Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDoGently: aBlock]].! !!SystemNavigation methodsFor: 'query' stamp: 'mtf 4/25/2008 09:52'!allImplementedMessagesWithout: classesAndMessagesPair 	"Answer a Set of all the messages that are implemented in the system,  	computed in the absence of the supplied classes and messages. Note this  	reports messages that are in the absent selectors set."	| messages absentClasses |	messages _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:. "sd 29/04/03" 	Cursor execute showWhile: [		Smalltalk classNames			do: [:name | ((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | messages addAll: each selectors]]].	^ messages! !!SystemNavigation methodsFor: 'query' stamp: 'mtf 4/25/2008 09:53'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent _ IdentitySet new: CompiledMethod instanceCount.	absentClasses _ classesAndMessagesPair first.	absentSelectors _ classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute showWhile: [		Smalltalk classNames do: [:name |			((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | (absentSelectors isEmpty						ifTrue: [each selectors]						ifFalse: [each selectors copyWithoutAll: absentSelectors])						do: [:sel | "Include all sels, but not if sent by self"							(each compiledMethodAt: sel) literals								do: [:m | 									(m isSymbol)										ifTrue: ["might be sent"											m == sel												ifFalse: [sent add: m]].									(m isMemberOf: Array)										ifTrue: ["might be performed"											m												do: [:x | (x isSymbol)														ifTrue: [x == sel																ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'mtf 4/25/2008 09:34'!fileOutCategory: category on: aFileStream initializing: aBool	"Store on the file associated with aFileStream, all the traits and classes associated 	with the category and any requested shared pools in the right order."	| first poolSet tempClass classes |	classes _ self superclassOrder: category.	poolSet _ Set new.	classes do:  [:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue: [		tempClass _ Class new.		tempClass shouldFileOutPools ifTrue: [			poolSet _ poolSet select: [:aPool |				tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first _ true.	classes do: [:each | 		first			ifTrue: [first _ false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		each			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false].	aBool ifTrue: [classes do: [:cls | cls fileOutInitializerOn: aFileStream]].! !!SystemOrganizer methodsFor: 'remove' stamp: 'mtf 4/25/2008 09:35'!removeSystemCategory: category	"remove all the classes and traits associated with the category"	 (self superclassOrder: category)		reverseDo: [:each | each removeFromSystem].	self removeCategory: category.! !!SystemVersion methodsFor: '*smbase-extension' stamp: 'jcg 11/2/2004 10:03'!majorMinorVersion	"Return the major/minor version number of the form X.Y, without any 'alpha' or 'beta' or other suffix."	"(SystemVersion new version: 'Squeak3.7alpha') majorMinorVersion" "  -->  'Squeak3.7' "	"SystemVersion current majorMinorVersion"		| char stream |	stream := ReadStream on: version, 'x'.	stream upTo: $..	char := stream next.	char ifNil: [^ version].	"eg: 'Jasmine-rc1' has no $. in it."	[char isDigit]		whileTrue: [char := stream next].	^ version copyFrom: 1 to: stream position - 1! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:35'!ascent	ascent ifNil:[ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y].	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:43'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := (ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender)) * Scale y + 1].! !!TTCFont methodsFor: 'accessing' stamp: 'rej 7/15/2007 19:02'!fallbackFont: aFontSetOrNil	aFontSetOrNil == self ifTrue: [self error: 'recursive font'].	fallbackFont _ aFontSetOrNil.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:44'!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize * Scale y]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!maxAscii	"Answer the max. code point in this font. The name of this method is historical."	^maxAscii ifNil:[ttcDescription size].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!minAscii	"Answer the min. code point in this font. The name of this method is historical."	^ 0.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!cache	^cache! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:40'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| form glyphInfo destX destY hereX nextX actualFont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo at: 1.		hereX := glyphInfo at: 2.		nextX := glyphInfo at: 3.		(actualFont := glyphInfo at: 5) ==  aBitBlt lastFont			ifFalse: [actualFont installOn: aBitBlt].		destY := baselineY - (glyphInfo at: 4). 		aBitBlt sourceForm: form.		aBitBlt destX: destX.		aBitBlt destY: destY.		aBitBlt sourceX: hereX; sourceY: 0.		aBitBlt width: nextX - hereX.		aBitBlt height: form height.		aBitBlt copyBits.		destX := destX + (nextX - hereX) + kernDelta.	].	^ destX @ destY! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:26'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	self foregroundColor: fgColor. "install color"	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self flushCache.! !!TTCFont methodsFor: 'public' stamp: 'ar 6/2/2007 21:16'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	aCharacter charCode > self maxAscii ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:19'!at: char put: form	| assoc |	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!formOf: char	| code form |	char charCode > self maxAscii		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:43'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!hasGlyphOf: aCharacter	"Answer whether this font includes a glyph for the given character"	^ aCharacter charCode <= self maxAscii! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:17'!flushCache	"Flush the cache of this font"	cache := foregroundColor := colorToCacheMap := nil.! !!TTCFont methodsFor: 'initialize' stamp: 'ar 6/2/2007 21:14'!foregroundColor: fgColor	"Install the given foreground color"	foregroundColor = fgColor ifFalse:[		foregroundColor := fgColor.		colorToCacheMap ifNil:[colorToCacheMap := Dictionary new].		cache := colorToCacheMap at: fgColor ifAbsentPut:[WeakArray new: self maxAscii+1].		ShutdownList ifNotNil:[ShutdownList add: self].	].! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:48'!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:28'!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.	ShutdownList ifNotNil:[ShutdownList do:[:fnt| fnt flushCache]].	ShutdownList := WeakSet new.! !!TTCFont class methodsFor: 'other' stamp: 'ar 11/14/2006 15:19'!recreateCache"	self recreateCache."	self allSubInstances do: [:inst | inst flushCache].	Smalltalk garbageCollect.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!TTCFontSet class methodsFor: 'as yet unclassified' stamp: 'wiz 6/2/2008 14:09'!registry	^ TTCFont registry .! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:15'!size	"Answer the logical number of characters in this font"	^glyphTable size - 1! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 18:00'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap := assoc value.	assoc key = 0 ifTrue: "Unicode table"		[charTable := SparseLargeTable new: cmap size			chunkSize: 256 arrayClass: Array base: 1			defaultValue: glyphs first.		1 to: charTable size do:			[:i |			glyph := glyphs at: (cmap at: i) + 1 ifAbsent: [glyphs first].			charTable at: i put: glyph].		charTable zapDefaultOnlyEntries.		^charTable].	charTable := Array new: 256 withAll: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue: "Mac encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: (self macToWin: i) put: glyph]].	assoc key = 3 ifTrue: "Win encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: i put: glyph]].	^ charTable! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 16:28'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset := entry offset.	entry skip: 2. "Skip table version"	nSubTables := entry nextUShort.	1 to: nSubTables do:[:i|		pID := entry nextUShort.		sID := entry nextUShort.		offset := entry nextULong.		"Check if this is either a Unicode (0), Macintosh (1),		or a Windows (3) encoded table"		(#(0 1 3) includes: pID) ifTrue:[			"Go to the beginning of the table"			copy := entry copy.			copy offset: initialOffset + offset.			cmap := self decodeCmapFmtTable: copy.			(pID = 0 and: [cmap notNil]) "Prefer Unicode encoding over everything else"				ifTrue: [^ pID -> cmap].			assoc := pID -> cmap. "Keep it in case we don't find a better table"		].	].	^assoc! !!TTFontReader methodsFor: 'private' stamp: 'bf 6/12/2006 17:14'!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		entryCount := segments inject: 0 into: [:max :seg | max max: seg second].		cmap := Array new: entryCount+1 withAll: 0..		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |				seg last > 0 ifTrue:					["offset to glypthIdArray - this is really C-magic!!"					entry offset: i - seg first - 1 * 2 + seg last + si + si + offset. 					code := entry nextUShort.					code > 0 ifTrue: [code := code + seg third]]				ifFalse:					["simple offset"					code := i + seg third].				cmap at: i + 1 put: code]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'edc 4/21/2005 09:57'!windowsMenu        "Build the windows menu for the world."        ^ self fillIn: (self menu: 'windows') from: {                  { 'find window' . { #myWorld . #findWindow: }. 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'}.                { 'find changed browsers...' . { #myWorld . #findDirtyBrowsers: }. 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.                { 'find changed windows...' . { #myWorld . #findDirtyWindows: }. 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'}.			nil.                { 'find a transcript (t)' . { #myWorld . #findATranscript: }. 'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'}.               { 'find a fileList (L)' . { #myWorld . #findAFileList: }. 'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.			{ 'find message names (W)' . { #myWorld . #findAMessageNamesWindow: }. 'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'}.			 nil.                { #staggerPolicyString . { self . #toggleWindowPolicy }. 'stagger: new windows positioned so you can see a portion of each one.                tile: new windows positioned so that they do not overlap others, if possible.'}.                nil.                { 'collapse all windows' . { #myWorld . #collapseAllWindows }. 'Reduce all open windows to collapsed forms that only show titles.'}.                { 'expand all windows' . { #myWorld . #expandAll }. 'Expand all collapsed windows back to their expanded forms.'}.                { 'close top window (w)' . { SystemWindow . #closeTopWindow }. 'Close the topmost window if possible.'}.                { 'send top window to back (\)' . { SystemWindow . #sendTopWindowToBack  }. 'Make the topmost window become the backmost one, and activate the window just beneath it.'}.			 { 'move windows onscreen' . { #myWorld . #bringWindowsFullOnscreen }. 'Make all windows fully visible on the screen'}.                nil.                { 'delete unchanged windows' . { #myWorld . #closeUnchangedWindows }. 'Deletes all windows that do not have unsaved text edits.'}.                { 'delete non-windows' . { #myWorld . #deleteNonWindows }. 'Deletes all non-window morphs lying on the world.'}.                { 'delete both of the above' . { self . #cleanUpWorld }. 'deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'}.        }! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:17'!milliSecondsSinceMidnight	^ DateAndTime milliSecondsSinceMidnight! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:18'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	| ms |		ms := self milliSecondsSinceMidnight.	^ self seconds:  (ms // 1000) nanoSeconds: (ms \\ 1000) * 1000000! !!Time class methodsFor: 'clock' stamp: 'kph 12/14/2006 01:43'!secondsWhenClockTicks	"waits for the moment when a new second begins"	| lastSecond delay |	delay :=  Delay forMilliseconds: 1.	lastSecond _ self primSecondsClock.	[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ]. 	^ lastSecond + 1! !!Transcripter methodsFor: 'command line' stamp: 'kph 4/13/2007 05:25'!readEvalPrint	| line okToRevert |	okToRevert _ true.	[#('quit' 'exit' 'done' ) includes: (line _ self request: '>')]		whileFalse:		[line = 'revert'		ifTrue: [okToRevert			ifTrue: [Utilities revertLastMethodSubmission.					self cr; show: 'reverted: ' , Utilities mostRecentlySubmittedMessage asStringOrText.					okToRevert _ false]			ifFalse: [self cr; show: 'Only one level of revert currently supported']]		ifFalse: [self cr; show: ([Compiler evaluate: line] ifError: [:err :ex | err])]]! !!TransformMorph methodsFor: 'geometry' stamp: 'ge 9/6/2006 17:51'!numberOfItemsPotentiallyInViewWith: submorphCount	"Answer the number of items that could potentially be viewed in full,	computed as my visible height divided by the average height of my submorphs.	Ignore visibility of submorphs."	^self innerBounds height // (self localSubmorphBounds height / submorphCount)! !!TransformationMorph methodsFor: 'accessing' stamp: 'wiz 12/7/2006 19:10'!forwardDirection	"Return the rendee's forward direction. 	If I have no rendee then return 0.0 degrees "	| rendee |	( rendee := self renderedMorph) == self  ifTrue: [ ^ 0.0 ] .		^ rendee forwardDirection! !!TransformationMorph methodsFor: 'classification' stamp: 'wiz 12/7/2006 14:05'!renderedMorph"We are a renderer. Answer appropriately."submorphs isEmpty ifTrue: [^self].	^self firstSubmorph renderedMorph! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 19:10'!forwardDirection: degrees "If we have a rendee set its forward direction. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee forwardDirection: degrees! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 16:30'!heading	"End recusion when necessary."	| rendee |	(rendee := self renderedMorph) == self ifTrue: [ ^0.0 ] .	^ rendee heading! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 4/18/2007 01:16'!heading: newHeading "If we have a rendee set its heading. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee heading: newHeading! !!TransformationMorph methodsFor: 'testing' stamp: 'wiz 11/24/2006 00:09'!isStickysubmorphs isEmpty ifFalse: [ ^ 	submorphs first isSticky ] .	^false! !!UCodeLoader commentStamp: 'edc 7/4/2008 09:39' prior: 0!Some things you could doFor inspecting the 3.10 saved UniversesUCodeLoader knowPackages inspectFor ask about your wished packageUCodeLoader lookFor!]style[(65 32 36 19 1)f2,f2dUCodeLoader knowPackages inspect;;,f2,f2dUCodeLoader lookFor;;,f2!!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 9/4/2008 06:47'!addRepository: repository toPackageNamed: aString 	| pa |	pa := MCPackage named: aString.	(MCHttpRepository new location:repository ;					 user: 'squeak';					 password: 'squeak').	pa workingCopy repositoryGroup addRepository: repository.	^ pa workingCopy repositoryGroup! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 9/4/2008 06:51'!addRepositoryTo: aPackage 	| uPackage url |	uPackage := self foundMe: aPackage.	url := uPackage url printString.	self addRepository: url toPackageNamed: (aPackage copyUpTo: $.)! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 9/4/2008 06:41'!addRepositoryToPackageNamed: aString 	| pa |	pa := MCPackage named: aString.	pa workingCopy repositoryGroup addRepository: self repository.	^ pa workingCopy repositoryGroup! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 8/27/2008 07:44'!foundMe: aString | pos v |^UCodeLoader knowPackages detect: [:ea| pos := ea url fullPath lastPositionOf: $/.	v := ea url fullPath  copyFrom: pos + 1 to: ea url fullPath size.	v = aString] ifNone: [self guess: aString].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 8/27/2008 09:11'!guess: aString| found pos v g xxx |g := aString copyUpTo: $..g := g,'*'.found := UCodeLoader knowPackages detect: [:ea| 	pos := ea url fullPath lastPositionOf: $/.	v := ea url fullPath  copyFrom: pos + 1 to: ea url fullPath size.	g match: v.	] ifNone: [].xxx := found url printString.pos := xxx lastPositionOf: $/.xxx := xxx copyFrom: 1 to: pos.xxx := xxx , aString.found  guessedUrl: xxx.^ found! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 07:51'!knowPackages	| file dir server |	KnowPackages ifNil:[^self loadKnowPackages ].	server := ServerDirectory serverNamed: 'SL'.	dir := server directoryNamed: 'SLupdates'.	file := dir entries				detect: [:c | c name = 'KnowPackages.obz']				ifNone: [].	^ KnowPackages! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 07:23'!knowPackages: aObject	 KnowPackages :=  aObject! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 07:51'!loadKnowPackages	"UCodeLoader loadKnowPackages"	| obj loader req |	loader := CodeLoader new.	loader baseURL: 'ftp.squeak.org/various_images/SqueakLight/SLupdates/'.	req := loader createRequestFor: 'KnowPackages.obz' in: HTTPLoader default.	obj := loader readObject: req.	^KnowPackages := obj! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/11/2008 18:21'!lookFor	"UCodeLoader lookFor"	| menu aPackageName sel thisPack |	aPackageName := FillInTheBlank request: 'Package name ? '.	menu := CustomMenu new.		menu := SelectionMenu selections: (self selectedPackages: aPackageName).	sel := menu startUpCenteredWithCaption: 'Select the one to install '.	thisPack := self foundMe:  sel.	(thisPack url fullPath endsWith: '.sar') ifTrue:[^self  tryHttpURL: thisPack url ].	thisPack		ifNotNil: [UGlobalInstaller new planToInstallPackage: thisPack]! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/4/2008 10:09'!newestPackageNamed: aName	| potentials sorted |	potentials _ self packagesNamed: aName.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].		^sorted last! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/4/2008 09:36'!packagesNamed: aPackageName| sort |sort := SortedCollection new.^UCodeLoader knowPackages select:[:ea| aPackageName,'*' match: ea name ]thenDo:[:any| sort add: any name].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 07:52'!selectedPackages: aPackageName	| sort pos v |	sort := SortedCollection new.	UCodeLoader knowPackages		do: [:ea | 			pos := ea url fullPath lastPositionOf: $/.	v := ea url fullPath  copyFrom: pos + 1 to: ea url fullPath size.			(aPackageName , '*' match: v) ifTrue: [ sort add: v]].			sort		ifEmpty: [^ self error: aPackageName , ' seems not in the Universes '].	^sort! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 19:03'!solveMissing: requirements 	| sourceFile server dir fn |	server := ServerDirectory serverNamed: 'SL'.	dir := server directoryNamed: 'SLupdates'.	requirements		do: [:ea | 			fn := ea asString , '.sqz'.			(dir fileExists: fn)				ifTrue: [sourceFile := HTTPLoader default retrieveContentsFor: 'ftp.squeak.org/various_images/SqueakLight//SLupdates/',fn.					sourceFile := RWBinaryOrTextStream with: sourceFile content unzipped.					sourceFile reset.					ChangeSorter newChangesFromStream: sourceFile named: ea asString]				ifFalse: [self error: ea asString.					' is not in to server ']]! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:38'!allPackages	^ universe packageNames asSortedCollection.! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/22/2007 12:27'!allPossibleUpgrades	^ universe packageNames		inject: OrderedCollection new		into: [ :upgrades :name |			(configuration includesPackageNamed: name)			ifTrue: [| cpack mypack |				cpack := configuration packageNamed: name.				mypack := universe newestPackageNamed: name.				(mypack version > cpack version)					ifTrue: [upgrades add: mypack]].								upgrades].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'edc 7/10/2008 09:10'!installedPackageVersions| packNames |	 packNames := MCWorkingCopyBrowser new workingCopyList select:[:ea| (ea findTokens: ' ') last ~= '()'] thenCollect:[:any| (any findTokens: ' ') last ].	^ packNames collect:[:ea| ea copyFrom: 2 to: ea size -1]! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'edc 7/10/2008 09:32'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider list isInstalled |	newPackages := Set new.	packagesToConsider := OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ]		whileFalse: [| package |			package := packagesToConsider removeFirst.			(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName | 			isInstalled :=self installedPackageVersions detect:[ :any| depName	, '*' match: any] ifNone:[].  isInstalled ifNil:[					"the dependency is needed but is not installed or planned to be installed"					list := (UCodeLoader packagesNamed: depName).										list  ifNotNil: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (UCodeLoader newestPackageNamed: depName) ]					ifNil: [						^errorBlock value: depName ] ] ] ]].		^newPackages! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'edc 7/10/2008 09:33'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^ orderedPackages! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/21/2007 12:43'!anyPackageSelected	^ selectedPackageVersions notEmpty! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!configuration: aConfiguration 	configuration := aConfiguration! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!universe: aUniverse 	universe := aUniverse! !!UGlobalInstaller methodsFor: 'actions' stamp: 'edc 7/5/2008 08:03'!doInstall	| orderedPackages |	self anyPackageSelected not		ifTrue: [^ self].	orderedPackages := self orderPackagesByDependency: selectedPackageVersions.	orderedPackages		do: [:p | Utilities				informUser: 'installing ' , p printString				during: [CodeLoader  tryHttpURL: p url]].	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'actions' stamp: 'edc 7/4/2008 10:24'!planToInstallPackage: initialPackage	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	| newPackages |	"find all packages needed to install this one"	newPackages := self allPackagesNeededToInstall: initialPackage						orIfImpossible: [ :missingDep |								^self notify: 'could not find necessary package: ', missingDep ].		selectedPackageVersions removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | selectedPackageVersions add: p ].	self doInstall.! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:54'!planToInstallPackageNamed: aPackageName	self planToInstallPackage: (universe newestPackageNamed: aPackageName)! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:27'!selectAllUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self allPossibleUpgrades 		do: [:package | self planToInstallPackage: package]! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initialize	super initialize.	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initializeSelectedPackageVersions	selectedPackageVersions := Set new! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'dc 4/21/2007 12:41'!selectedPackageVersions	^ selectedPackageVersions! !!UGlobalInstaller commentStamp: 'dc 7/24/2007 11:43' prior: 0!I'm used by universe browsers to keep track of the configuration, the universe, the selected packages... I provide features to install new packages, to upgrade the system...!!UGlobalInstaller class methodsFor: 'accessing' stamp: 'edc 8/16/2008 17:28'!unwantedPackages^ unwantedPackages! !!UGlobalInstaller class methodsFor: 'accessing' stamp: 'edc 8/16/2008 17:28'!unwantedPackages: aPackagesListunwantedPackages := aPackagesList! !!UPackage methodsFor: 'accessing' stamp: 'edc 7/5/2008 08:38'!category	^category ifNil: ['Uncategorized' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!depends	^depends! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!description	^description! !!UPackage methodsFor: 'accessing' stamp: 'edc 8/27/2008 09:11'!guessedUrl: aString	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	url := Url absoluteFromText: aString! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05'!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33'!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!name	^name! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29'!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 11:37'!squeakMapID	^ squeakMapID! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30'!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32'!version	^version! !!UPackage methodsFor: 'printing' stamp: 'ls 8/31/2007 12:25'!longDescription	^Text streamContents: [ :str |		str nextPutAll: self description; cr; cr.		str nextPutAll: 'Category: '; print: self category; cr.		self provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self  depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self  depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self  maintainer); cr.		str nextPutAll: 'Downloads from: '.		self  url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self  url asString ].		str cr.		self  homepage ifNotNil: [			str nextPutAll: 'Homepage: '.			str nextPutAll: (Text string: self homepage asString attribute: (TextURL new url: self homepage asString)).			str cr].		self squeakMapID ifNotNil: [			| smurl |			str nextPutAll: 'SqueakMap UUID: ', self squeakMapID asString, String cr.			smurl := 'http://map.squeak.org/package/', self squeakMapID asString.			str nextPutAll: (Text string: '[browse SqueakMap web page]' attribute: (TextURL new url: smurl)).			str cr.						str nextPutAll: (Text string: '[open SqueakMap browser]' attribute: (TextDoIt evalString: 'USqueakMapUtil browsePackageID: (UUID fromString: ''', self squeakMapID asString, ''')')).			str cr.			]. ] .! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05'!components	^components! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!name	^name! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!version	^version! !!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:47'!fromSystemClipboard: aString	^aString utf8ToSqueak! !!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:48'!toSystemClipboard: aString	^aString squeakToUtf8! !!UUID methodsFor: '*smbase-macsafe' stamp: 'gk 1/27/2004 14:15'!asString36	"Encode the UUID as a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems."	| candidate num |	num _ 0.	1 to: self size do: [:i | num _ num + ((256 raisedTo: i - 1) * (self at: i))].	candidate _ num printStringBase: 36.	^(candidate copyFrom: 4 to: candidate size) asLowercase! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33'!components	^components! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28'!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15'!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31'!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02'!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'edc 7/12/2008 08:08'!subclass: nameOfClass instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictnames category: category 	"Calling this method is now considered an accident. If you really 	want to create a class with a nil superclass, then create the 	class and then set the superclass using #superclass:"	self halt.	Transcript show: 'Attempt to create ' , nameOfClass , ' as a subclass of nil.  Possibly a class is being loaded before its superclass.';		 cr.	^self class lookForClass: nameOfClass! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:55'!isDigit: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Nd! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:56'!isLetter: char 	| value codeCat |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (codeCat := GeneralCategory at: value + 1) >= Ll		and: [codeCat <= Lu]! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:57'!isLowercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Ll! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:58'!isUppercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Lu! !!Unicode class methodsFor: 'class initialization' stamp: 'kwl 6/30/2006 02:53'!initialize	" Unicode initialize "	(self classPool keys		select: [:sym | sym size = 2 and: sym first isUppercase and: sym last isLowercase]) asSortedCollection		inject: 1		into: [:index :sym | sym = #Cn				ifTrue: [self classPool at: sym put: 0. index]				ifFalse: [self classPool at: sym put: index. index + 1]]! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents	^ contents! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents: c	contents _ c! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 16:31'!getSelector	"Answer the getSelector"	^ getSelector! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector _ aSymbol.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 1/6/2005 01:28'!isEtoyReadout	"Answer whether the receiver can serve as an etoy readout"	^ true! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector	^ putSelector! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector: aSymbol	putSelector _ aSymbol! !!UpdatingRectangleMorph methodsFor: 'accessing'!target	^ target! !!UpdatingRectangleMorph methodsFor: 'accessing'!target: anObject	target _ anObject.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 11/15/2001 16:22'!userEditsAllowed	"Answer whether it is suitable for a user to change the value represented by this readout"	^ putSelector notNil! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target _ deepCopier references at: target ifAbsent: [target].! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target _ target.		Weakly copied"lastValue _ lastValue veryDeepCopyWith: deepCopier."getSelector _ getSelector.		a Symbol""putSelector _ putSelector.		a Symbol"contents _ contents veryDeepCopyWith: deepCopier.! !!UpdatingRectangleMorph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 18:45'!handlesMouseDown: evt 	^putSelector notNil! !!UpdatingRectangleMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 18:54'!mouseUp: evt	self changeColorTarget: self selector: #setTargetColor: originalColor: color hand: evt hand.! !!UpdatingRectangleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color lightGray lighter! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 23:26'!setTargetColor: aColor	"Set my target's color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents _ aColor.		self valueProvider perform: self putSelector withArguments: (Array with: aColor)]! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 13:24'!valueProvider	"Answer the object to which my get/set messages should be sent.  This is inefficient and contorted in order to support grandfathered content for an earlier design"	^ target isMorph		ifTrue:			[target topRendererOrSelf player ifNil: [target]]		ifFalse:			[target]! !!UpdatingRectangleMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:27'!step	| s |	super step.	s _ self readFromTarget.	s = contents ifFalse:		[self contents: s.		self color: s]! !!UpdatingRectangleMorph methodsFor: 'target access' stamp: 'dgd 2/22/2003 14:40'!readFromTarget	"Read the color value from my target"	| v |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	target isMorph ifTrue: [target isInWorld ifFalse: [^contents]].	v := self valueProvider perform: getSelector.	lastValue := v.	^v! !!UpdatingRectangleMorph methodsFor: 'testing'!stepTime	^ 50! !!UpdatingRectangleMorph commentStamp: '<historical>' prior: 0!Intended for use as a color swatch coupled to a color obtained from the target, but made just slightly more general than that.!!UpdatingStringMorph methodsFor: 'accessing' stamp: 'pk 11/13/2007 13:18'!valueFromContents	"Return a new value from the current contents string.""	| expression tilePadMorphOrNil asNumberBlock |	asNumberBlock _ [:string | [string asNumber]				on: Error				do: []].	format = #string		ifTrue: [^ contents].	expression _ Vocabulary eToyVocabulary translationKeyFor: contents.	expression isNil		ifTrue: [expression _ contents].	^ Compiler evaluate: expression"	format = #symbol ifTrue: [^ lastValue].	format = #string ifTrue: [^ contents].	^ Compiler evaluate: contents"KernelImageOverride - EToys removed"! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 10/15/2008 07:39'!slUpdates	"Utilities slUpdates"	| numero server dir count sourceFile fileName pos |	numero := (ChangeSorter highestNumberedChangeSet + 1) asString.	server := ServerDirectory serverNamed: 'SL'.	dir := server directoryNamed: 'SLupdates'.	count := 0.	dir entries		select: [:c | c name startsWithDigit & (c name > numero)]		thenCollect: [:any | 			(any name endsWith: '.sqz')				ifTrue: [fileName := any name.					pos := fileName findString: '.sqz'.					fileName := fileName copyFrom: 1 to: pos - 1.					sourceFile := HTTPLoader default retrieveContentsFor: 'ftp.squeak.org/various_images/SqueakLight//SLupdates/' , any name.					sourceFile := RWBinaryOrTextStream with: sourceFile content unzipped]				ifFalse: [sourceFile := RWBinaryOrTextStream with: (dir getFileNamed: any name) contents.					sourceFile reset.					self saveUpdate: sourceFile onFile: any name].			ChangeSorter newChangesFromStream: sourceFile named: any name.			count := count + 1].	PopUpMenu inform: count asString , ' new update file(s) processed.'.	SystemVersion current registerUpdate: ChangeSorter highestNumberedChangeSet! !!Utilities class methodsFor: 'identification' stamp: 'edc 10/6/2008 09:58'!methodsWithInitials: targetInitials inClass: aClass	"Based on a do-it contributed to the Squeak mailing list by Gran Hultgen: Browse methods whose initials (in the time-stamp, as logged to disk) match the given initials. Print out the complete time-stamp table to the Transcript. Answer a list of (initials -> count) associations.CAUTION: It may take several minutes for this to complete."	"Time millisecondsToRun: [Utilities methodsWithInitials: 'bf']"	| methodList methodListClass |	methodList := aClass methodDict select:[:cm| 		cm  author = targetInitials].	methodListClass := aClass class methodDict select:[:cm| cm  author = targetInitials].		^methodList,methodListClass	! !!Utilities class methodsFor: 'recent method submissions' stamp: 'kph 4/13/2007 05:28'!mostRecentlySubmittedMessage	"Answer a MethodReference indicating the most recently submitted method that is still extant"	self flag: #mref.	"fix for faster references to methods"	self assureMostRecentSubmissionExists.	^ RecentSubmissions last! !!Utilities class methodsFor: 'summer97 additions' stamp: 'mtf 4/25/2008 09:53'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores tab, space, & cr characters in the pattern"	| toMatch potentialClassNames classNames exactMatch index |	(toMatch _  pattern copyWithoutAll:			{Character space.  Character cr.  Character tab})		isEmpty ifTrue: [^ nil].	Symbol hasInterned: toMatch ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch _ (toMatch copyWithout: $.) asLowercase.	potentialClassNames _ (Smalltalk classNames) asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [UIManager default chooseFrom: classNames lines: #() title: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				UIManager default chooseFrom: classNames lines: #(1) title: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !!Vocabulary class methodsFor: 'class initialization' stamp: 'edc 6/2/2008 17:33'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllStandardVocabularies list."	AllStandardVocabularies _ nil.	"self addStandardVocabulary: EToyVocabulary new.	self addStandardVocabulary: EToyVectorVocabulary new."	self addStandardVocabulary: self newPublicVocabulary.	self addStandardVocabulary: FullVocabulary new.	self addStandardVocabulary: self newQuadVocabulary.	self addStandardVocabulary: ColorType new.	self addStandardVocabulary: BooleanType new.	self addStandardVocabulary: GraphicType new.	"self addStandardVocabulary: PlayerType new."	self addStandardVocabulary: SoundType new.	self addStandardVocabulary: StringType new.	self addStandardVocabulary: MenuType new.	self addStandardVocabulary: UnknownType new.	"self addStandardVocabulary: ScriptNameType new."	self addStandardVocabulary: (SymbolListType new symbols: #(simple raised inset complexFramed complexRaised complexInset complexAltFramed complexAltRaised complexAltInset); vocabularyName: #BorderStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(lines arrows arrowheads dots); vocabularyName: #TrailStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(leftToRight rightToLeft topToBottom bottomToTop); vocabularyName: #ListDirection; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(topLeft bottomRight center justified); vocabularyName: #ListCentering; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(buttonDown whilePressed buttonUp); vocabularyName: #ButtonPhase; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(rotate #'do not rotate' #'flip left right' #'flip up down'); vocabularyName: #RotationStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(rigid spaceFill shrinkWrap); vocabularyName: #Resizing; yourself).	self addStandardVocabulary: self newSystemVocabulary.  "A custom vocabulary for Smalltalk -- still under development)"	self numberVocabulary.  		"creates and adds it"	self wonderlandVocabulary.  	"creates and adds it"	self vocabularyForClass: Time.   "creates and adds it"	"self addStandardVocabulary: (KedamaPatchType new vocabularyName: #Patch; yourself)."	self addStandardVocabulary: (SymbolListType new symbols: #(wrap stick bouncing); vocabularyName: #EdgeMode; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(logScale linear color); vocabularyName: #PatchDisplayMode; yourself).	"Vocabulary initialize"! !!Vocabulary class methodsFor: 'standard vocabulary access' stamp: 'edc 5/31/2008 11:33'!removingObsoletes"Vocabulary removingObsoletes"AllStandardVocabularies keysAndValuesDo: [:k :v| (SystemNavigation default obsoleteClasses includes: v class) ifTrue:[self removingVocabulary: v vocabularyName]] .Smalltalk garbageCollect! !!Vocabulary class methodsFor: 'standard vocabulary access' stamp: 'edc 5/31/2008 11:17'!removingVocabulary: aSymbol(AllStandardVocabularies at: aSymbol ifAbsent:[]) ifNotNil:[ AllStandardVocabularies removeKey: aSymbol ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!= anObject	^self species == anObject species and: [		self wideCharacterMap = anObject wideCharacterMap ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/10/2006 00:26'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 8. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 11/15/2007 21:26'!hash	"Answer a hash code aimed at storing and retrieving the receiver in a Set or Dictionary.	Two equal objects should have equal hash.	Note: as the receiver can be equal to an ordinary CharacterSet,	the hash code must reflect this"		^self hasWideCharacters		ifTrue: [map hash]		ifFalse: [self asCharacterSet hash]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!species	^self hasWideCharacters		ifTrue: [WideCharacterSet]		ifFalse: [CharacterSet]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:14'!wideCharacterMap	^map! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: [WordArray new: 2048].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/10/2006 00:21'!do: aBlock 	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | aBlock						value: (Character value: ((high bitShift: 16) bitOr: low))]]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:49'!includes: aCharacter 	| val high low |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	^(self		bitmap: (map				at: high				ifAbsent: [^ false])		at: low) isZero not! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 9/25/2007 21:01'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map				at: high				ifAbsent: [^ aCharacter].	self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:00'!size	| size |	size := 0.	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | size := size + 1]].	^ size! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/10/2006 00:10'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:47'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:25'!hasWideCharacters	"Answer true if i contain any wide character"		self do: [:e | e asciiValue >= 256 ifTrue: [^true]].	^false! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 5/9/2006 22:31'!initialize	map := Dictionary new.! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!WideCharacterSet methodsFor: 'copying' stamp: 'nice 11/20/2007 00:57'!postCopy	map := map collect: [:each | each copy]! !!WideCharacterSet commentStamp: 'nice 5/9/2006 23:33' prior: 0!WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.Implementation should be efficient in memory if sets are sufficently sparse.Wide Characters are at most 32bits.We split them into 16 highBits and 16 lowBits.map is a dictionary key: 16 highBits value: map of 16 lowBits.Maps of lowBits  are stored as arrays of bits in a WordArray.If a bit is set to 1, this indicate that corresponding character is present.Only 2048 entries are necessary in each lowmap.And only lowmap corresponding to a present high value are stored.!!WideCharacterSet class methodsFor: 'instance creation' stamp: 'nice 11/15/2007 22:38'!newFrom: aCollection	| newCollection |	newCollection := self new.	newCollection addAll: aCollection.	^newCollection! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07'!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!WordArray methodsFor: 'array arithmetic' stamp: 'pk 11/18/2007 21:50'!* other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := FloatArray new: self size.			^ self primMulScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primMulScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primMulArray: self and: other into: result.	].	(other isMemberOf: FloatArray) ifTrue: [			result := FloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other."KernelImageOverride - Float array instead of KedamaFloatArray"! !!Workspace methodsFor: 'variable declarations' stamp: 'sumim 11/26/2006 03:52'!mustDeclareVariableWording		^ mustDeclareVariables not		ifTrue: ['<yes> automatically create variable declaration' translated]		ifFalse: ['<no> automatically create variable declaration' translated]! !!WriteStream methodsFor: 'accessing' stamp: 'dc 2/11/2007 14:18'!ensureEndsWith: anObject	"Append anObject to the receiver IFF there is not one on the end."	(position > 0 and: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/26/2003 08:01'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd |	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex].	newEnd _ position + anInteger.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.	position _ newEnd.	^aCollection! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position _ newEnd.! !!WriteStream methodsFor: 'character writing' stamp: 'dc 2/11/2007 14:18'!ensureASpace	"Append a space character to the receiver IFF there is not one on the end."	self ensureEndsWith: Character space! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger   " anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize _ collection size.     newSize := anInteger + (oldSize // 4 max: 20).	grownCollection _ collection class new: newSize.	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.! !Smalltalk condenseChanges!'From SqueakLight|II of 31 May 2008 [latest update: #7211] on 5 November 2008 at 6:34:24 pm'!Flaps class removeSelector: #twiddleSuppliesButtonsIn:!!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 11/8/2008 09:12' prior: 20909541!newSuppliesFlapFromQuads: quads positioning: positionSymbol 	"Answer a fully-instantiated flap named 'Supplies' to be placed at the	bottom of the screen. Use #center as the positionSymbol to have it	centered at the bottom of the screen, or #right to have it placed off	near the right edge."	| aFlapTab aStrip hPosition |	aStrip := PartsBin				newPartsBinWithOrientation: #leftToRight				andColor: Color red muchLighter				from: quads.	"self twiddleSuppliesButtonsIn: aStrip."	aFlapTab := FlapTab new referent: aStrip beSticky.	aFlapTab		setName: 'Supplies' translated		edge: #bottom		color: Color red lighter.	hPosition := positionSymbol == #center				ifTrue: [Display width // 2 - (aFlapTab width // 2)]				ifFalse: [Display width - (aFlapTab width + 22)].	aFlapTab position: hPosition @ (self currentWorld height - aFlapTab height).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip extent: self currentWorld width @ 136.	aStrip beFlap: true.	aStrip autoLineLayout: true.	^ aFlapTab"Flaps replaceGlobalFlapwithID: 'Supplies' translated"! !----STARTUP----an Array(8 November 2008 9:17:38 am) as /Users/admin/Sites/SqueakLightII.7212.image!'From SqueakLight|II of 31 May 2008 [latest update: #7212] on 8 November 2008 at 9:17:26 am'!"Change Set:		7213CleanUndeclaredFixesDate:			8 November 2008Author:			Edgar J. De CleeneFix some undeclared.Save image when end"Undeclared removeUnreferencedKeys; inspect.!!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 11/8/2008 09:12' prior: 20909541!newSuppliesFlapFromQuads: quads positioning: positionSymbol 	"Answer a fully-instantiated flap named 'Supplies' to be placed at the	bottom of the screen. Use #center as the positionSymbol to have it	centered at the bottom of the screen, or #right to have it placed off	near the right edge."	| aFlapTab aStrip hPosition |	aStrip := PartsBin				newPartsBinWithOrientation: #leftToRight				andColor: Color red muchLighter				from: quads.	"self twiddleSuppliesButtonsIn: aStrip."	aFlapTab := FlapTab new referent: aStrip beSticky.	aFlapTab		setName: 'Supplies' translated		edge: #bottom		color: Color red lighter.	hPosition := positionSymbol == #center				ifTrue: [Display width // 2 - (aFlapTab width // 2)]				ifFalse: [Display width - (aFlapTab width + 22)].	aFlapTab position: hPosition @ (self currentWorld height - aFlapTab height).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip extent: self currentWorld width @ 136.	aStrip beFlap: true.	aStrip autoLineLayout: true.	^ aFlapTab"Flaps replaceGlobalFlapwithID: 'Supplies' translated"! !Flaps class removeSelector: #twiddleSuppliesButtonsIn:!Flaps class removeSelector: #twiddleSuppliesButtonsIn:!----End fileIn of /Users/admin/Sites/7213CleanUndeclaredFixes.1.cs----!'From SqueakLight3.7.1 of ''4 September 2004'' [latest update: #5985] on 16 August 2006 at 9:25:18 am'!----End fileIn of a stream----!self submorphs first color: Color white!self color: Color black.self submorphs first color: Color white!self color: Color black.self submorphs first color: Color white!self color: Color black.self submorphs first color: Color white!self color: Color white.self submorphs first color: Color black!self color: Color white.self submorphs first color: Color black!self color: Color white.self submorphs first color: Color black!self target: MCWorkingCopyBrowser!----QUIT----an Array(8 November 2008 10:03:27 am) SqueakLightII.7212.image priorSource: 945391!----STARTUP----an Array(16 November 2008 11:19:08 am) as /Users/admin/Sites/SqueakLightII.7212.image!'From Squeak3.10beta of 22 July 2007 [latest update: #7159] on 16 November 2008 at 11:18:10 am'!!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!squeakToUtf8	"Convert the receiver into a UTF8-encoded string"	^self convertToWithConverter: UTF8TextConverter new.! !----End fileIn of /Users/admin/Sites/String-squeakToUtf8.st----!'From SqueakLight|II of 31 May 2008 [latest update: #7212] on 8 November 2008 at 9:17:26 am'!"Change Set:		7213CleanUndeclaredFixesDate:			8 November 2008Author:			Edgar J. De CleeneFix some undeclared.Save image when end"Undeclared removeUnreferencedKeys; inspect.!!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 11/8/2008 09:12' prior: 33957603!newSuppliesFlapFromQuads: quads positioning: positionSymbol 	"Answer a fully-instantiated flap named 'Supplies' to be placed at the	bottom of the screen. Use #center as the positionSymbol to have it	centered at the bottom of the screen, or #right to have it placed off	near the right edge."	| aFlapTab aStrip hPosition |	aStrip := PartsBin				newPartsBinWithOrientation: #leftToRight				andColor: Color red muchLighter				from: quads.	"self twiddleSuppliesButtonsIn: aStrip."	aFlapTab := FlapTab new referent: aStrip beSticky.	aFlapTab		setName: 'Supplies' translated		edge: #bottom		color: Color red lighter.	hPosition := positionSymbol == #center				ifTrue: [Display width // 2 - (aFlapTab width // 2)]				ifFalse: [Display width - (aFlapTab width + 22)].	aFlapTab position: hPosition @ (self currentWorld height - aFlapTab height).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip extent: self currentWorld width @ 136.	aStrip beFlap: true.	aStrip autoLineLayout: true.	^ aFlapTab"Flaps replaceGlobalFlapwithID: 'Supplies' translated"! !Flaps class removeSelector: #twiddleSuppliesButtonsIn:!----End fileIn of a stream----!'From SqueakLight|II of 31 May 2008 [latest update: #7212] on 16 November 2008 at 11:19:58 am'!!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32' prior: 33959850!squeakToUtf8	"Convert the receiver into a UTF8-encoded string"	^self convertToWithConverter: UTF8TextConverter new.! !----End fileIn of a stream----!self target: StandardToolSet!----SNAPSHOT----an Array(16 November 2008 11:28:43 am) SqueakLightII.7214.image priorSource: 405057!----QUIT----an Array(16 November 2008 11:29:09 am) SqueakLightII.7214.image priorSource: 407502!