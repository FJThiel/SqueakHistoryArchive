'From SqueakLight|II of 31 May 2008 [latest update: #7193] on 10 July 2008 at 9:33:25 am'!!CodeLoader methodsFor: 'debugging' stamp: 'edc 7/10/2008 06:09'!tryVersion: packageName | mcw montiNames package version |mcw := MCWorkingCopyBrowser new repository: (MCHttpRepository				location: baseURL				user: ''				password: '').mcw repository ifNotNilDo: [:repos | montiNames := repos readableFileNames ].				package := (montiNames detect:[:ea| ea beginsWith: packageName] ifNone:[] ) .	package ifNotNil: [MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: baseURL)]..	version := mcw repository loadVersionFromFileNamed: package.	version load].^version! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 07:33'!foundMe: aString | pos v |^UCodeLoader knowPackages detect: [:ea| pos := ea url fullPath lastPositionOf: $/.	v := ea url fullPath  copyFrom: pos + 1 to: ea url fullPath size.	v = aString] ifNone: [].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 07:23'!knowPackages: aObject	 KnowPackages :=  aObject! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 06:58'!lookFor	"UCodeLoader lookFor"	| menu aPackageName sel thisPack |	aPackageName := FillInTheBlank request: 'Package name ? '.	menu := CustomMenu new.		menu := SelectionMenu selections: (self selectedPackages: aPackageName).	sel := menu startUpCenteredWithCaption: 'Select the one to install '.	thisPack := self foundMe:  sel.	thisPack		ifNotNil: [UGlobalInstaller new planToInstallPackage: thisPack].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/10/2008 07:52'!selectedPackages: aPackageName	| sort pos v |	sort := SortedCollection new.	UCodeLoader knowPackages		do: [:ea | 			pos := ea url fullPath lastPositionOf: $/.	v := ea url fullPath  copyFrom: pos + 1 to: ea url fullPath size.			(aPackageName , '*' match: v) ifTrue: [ sort add: v]].			sort		ifEmpty: [^ self error: aPackageName , ' seems not in the Universes '].	^sort! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'edc 7/10/2008 09:10'!installedPackageVersions| packNames |	 packNames := MCWorkingCopyBrowser new workingCopyList select:[:ea| (ea findTokens: ' ') last ~= '()'] thenCollect:[:any| (any findTokens: ' ') last ].	^ packNames collect:[:ea| ea copyFrom: 2 to: ea size -1]! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'edc 7/10/2008 09:32'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider list isInstalled |	newPackages := Set new.	packagesToConsider := OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ]		whileFalse: [| package |			package := packagesToConsider removeFirst.			(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName | 			isInstalled :=self installedPackageVersions detect:[ :any| depName	, '*' match: any] ifNone:[].  isInstalled ifNil:[					"the dependency is needed but is not installed or planned to be installed"					list := (UCodeLoader packagesNamed: depName).										list  ifNotNil: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (UCodeLoader newestPackageNamed: depName) ]					ifNil: [						^errorBlock value: depName ] ] ] ]].		^newPackages! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'edc 7/10/2008 09:33'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^ orderedPackages! !