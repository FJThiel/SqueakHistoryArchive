'From SqueakLight|II of 31 May 2008 [latest update: #7077] on 10 June 2008 at 10:20:37 am'!"Change Set:		ChangeSorterNotes-wizDate:			3 February 2007Author:			(wiz) Jerome Peace			wiz 2/3/2007 15:41copied the sysNav method for package annotation into changeSorter. This is a less good refactoring but it keeps all the needed changes in the one class.Ideally the annotation responsibilities should not belong to changesorter but to sysnav where they can be reused.Transitionally, having them is a smaller number of packages improves robustness. Until somebody realizes whats wrong with the packaging of pieces.wiz 2/3/2007 15:31Moved SysNavAnnotations-wiz.16 methods tohere. (with the annotated change sorter). Leaving behind the bulk of the SysNav changes since they are not relevant to this fix. The previous log follows:Change Set:		SysNavAnnotations-wizDate:			23 August 2006Author:			(wiz) Jerome Peace			wiz 2/3/2007 01:47removed class WizaSort from changes list. (In the process proving that the modified #forget method works.)			wiz 2/3/2007 01:45Copied (i.e. committed) the remaining WizaSort methods to change sorter			wiz 2/3/2007 01:18move basic...List 's up to ChangeSorter, removing them from WizaSorter.			wiz 2/2/2007 01:42And this one is just filed out from a Wizasorter.			wiz 2/2/2007 01:40Removed WizaSorter>>currentSelector: which was for debugging.wiz 2/2/2007 01:37I changed basicMessageList to use selectedMessageName and things started working.Strange. wiz 2/1/2007 20:51fixed bugs so lists would display.cant seem to get anything selected in method list.Checkpoint save.			wiz 2/1/2007 20:50			forgot some parens.						wiz 2/1/2007 19:22Well we learned quite a bit from the last two tries. This one uses a variation on the experimental sorter name. WizaSorter instead of the original WizSorter.I added methods to changesorter to ease the addition of annotation notes and made the users of the selectbyItem ivars remove the notes just before the ivars contents will make a difference.There is a correction for the #buildWith: doit comment.And I changed package annotation stuff so it will take nil in the arguments w/o protest.O yeah this is the save before crash test.			wiz 1/24/2007 23:31added handlers for #selector#class#packageto SysNav>>annotations:etc. I have partially tested stuff.To do I have no idea if this will work for deleted routines. I wonder what Bert did?wiz 1/23/2007 21:09Added additional selectors to #annotation:etc.for completeness should be able to get the selector and the class and the package for the method.wiz 8/23/2006 02:17The annotation methods have been implemented in CodeHolder.They cried out for refactoring.Here the methods that only depend on the arguments of the methods have been moved to system navigation.I have also made the requestList a parameter of a method instead of checking preferences inside the method. This to allow reports to be customized by the user.ToDo implement the request handler as a dictionary with requests as keys and [ :class :method | '' ] blocks as values. (cmBlock value: aClass value: aSelector ) should always return aString."!!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:37'!annotationForPackageforSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing 	information about the given selector and class"	"requestList"| aCategory |aClass ifNil: [ ^nil] .aSelector ifNil: [ aClass theNonMetaClass category asString ] .aSelector ifNotNil: [ aCategory := aClass organization categoryOfElement: aSelector.(aCategory notNil and: [ aCategory first = $* ]) 	ifTrue: [^ aCategory asString]] .	"Ok. So the selector catagory does not indicate our package. We defer to the class catagory"^ aClass theNonMetaClass category asString.	! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!beginNote"return the string at the beginning of item annotation"^' {'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!endNote"return the string at the beginning of item annotation"^'}'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:21'!noteString: aString^ self beginNote , aString asString , self endNote! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:39'!packageNoteForClass: aClass selector: aSelector "return the category name that represents the package name for aClass>>aSelector.when selector is nil or in a normal catagory return "| package |package := (self annotationForPackageforSelector: aSelector			ofClass: aClass) ifNil: ['<class was deleted???>'] .^ self noteString: package! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:17'!withoutItemAnnotation: aStringOrNil"return the current item without the package annotation we added on"| endItemIndex |aStringOrNil ifNil: [^nil] .( endItemIndex := aStringOrNil findString: self beginNote) = 0	ifTrue: [^ aStringOrNil ] .^ aStringOrNil first: endItemIndex - 1! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:14'!basicClassList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:35'!classList	"return the classlist with package note appended."		^ self basicClassList collect: [: each | 		each asString, (self packageNoteForClass: (Smalltalk classNamed: each) selector: nil) ] .! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:37'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet := self class newChangeSet: (self withoutItemAnnotation: currentClassName).	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:38'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: (self withoutItemAnnotation: currentClassName).		currentClassName := nil.		currentSelector := nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'code pane' stamp: 'wiz 2/3/2007 01:34'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType | 	self clearUserEditFlag.	currentClassName ifNil: [^ contents := myChangeSet preambleString ifNil: ['']].	class := self selectedClassOrMetaClass.	(sel := self selectedMessageName) == nil		ifFalse: [changeType := (myChangeSet atSelector: (sel := sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents := 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents := 'Added then removed (see versions)'].			class ifNil: [^ contents := 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents := 'Method was added, but cannot be found!!'].			contents := class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs) includes: contentsSymbol) ifTrue:				[contents :=  class prettyPrinterClass					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showingAnyKindOfDiffs				ifTrue: [contents := self diffFromPriorSourceFor: contents].			^ contents := contents asText makeSelectorBoldIn: class]		ifTrue: [strm := WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents := strm contents].! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:13'!basicMessageList 	| probe newSelectors className |	currentClassName ifNil: [^ #()].	className := (self withoutItemAnnotation: currentClassName) .	probe := (className endsWith: ' class')		ifTrue: [className]		ifFalse: [className asSymbol].	newSelectors := myChangeSet selectorsInClass: probe.	(newSelectors includes: (self selectedMessageName)) 		ifFalse: [currentSelector := nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other := (parent other: self) changeSet.		cls := self selectedClassOrMetaClass.		sel := self selectedMessageName.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!messageList 	| thisClass |	(thisClass := self selectedClassOrMetaClass) ifNil: [^ #() ] .	^self basicMessageList collect: [ :each |		each asString , (self packageNoteForClass: thisClass selector: each) ] .! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 7/22/2007 22:13'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^self].	self okToChange ifFalse: [^Beeper beep].	currentSelector ifNotNil: 			[other := (parent other: self) changeSet.			other == myChangeSet ifTrue: [^Beeper  beep].			cls := self selectedClassOrMetaClass.			sel := self selectedMessageName.			other 				absorbMethod: sel				class: cls				from: myChangeSet.			(parent other: self) showChangeSet: other.			self forget	"removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:33'!selectedMessageName	currentSelector ifNil: [^ nil].	^ (self withoutItemAnnotation: currentSelector) asSymbol! !!ChangeSorter methodsFor: 'toolbuilder' stamp: 'wiz 2/1/2007 15:37'!buildWith: builder	"		ToolBuilder open: ChangeSorter.	"	|  windowSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec label: 'Change Sorter'.	windowSpec model: self.	windowSpec children: OrderedCollection new.	self buildWith: builder in: windowSpec rect: (0@0 extent: 1@1).	^builder build: windowSpec! !!ChangeSorter methodsFor: 'traits' stamp: 'wiz 2/3/2007 01:34'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName tName className |	currentClassName ifNil: [^ nil].	className := (self withoutItemAnnotation: currentClassName) .	(className endsWith: ' class')		ifTrue: [cName _ (className copyFrom: 1 to: className size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	(currentClassName endsWith: ' classTrait')		ifTrue: [tName _ (className copyFrom: 1 to: className size-11) asSymbol.				^ (Smalltalk at: tName ifAbsent: [^nil]) classTrait].	cName _ className asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !