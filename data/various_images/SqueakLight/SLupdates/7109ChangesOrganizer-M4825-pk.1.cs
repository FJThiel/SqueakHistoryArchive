'From SqueakLight|II of 31 May 2008 [latest update: #7077] on 10 June 2008 at 10:16:21 am'!Object subclass: #ChangesOrganizer	instanceVariableNames: ''	classVariableNames: 'ChangeSetCategories ChangeSetNamesInRelease RecentUpdateMarker'	poolDictionaries: ''	category: 'Tools-Changes'!!ChangesOrganizer commentStamp: 'pk 10/17/2006 09:25' prior: 0!Changes organizer!CodeHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory '	classVariableNames: 'ChangeSetCategories ChangeSetNamesInRelease RecentUpdateMarker '	poolDictionaries: ''	category: 'Tools-Changes'!!ChangeSorter commentStamp: '<historical>' prior: 0!I display a ChangeSet.  Two of me are in a DualChangeSorter.!!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:34'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet := ChangesOrganizer assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:35'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList := self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[ChangesOrganizer fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet :=  ChangesOrganizer assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup] ! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet } , parameters! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet }, parameters].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSets	"Return the list of all current ChangeSets"	^ChangeSet allChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ChangeSet named: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetsNamedSuchThat: nameBlock	^ChangeSet changeSetsNamedSuchThat: nameBlock! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!existingOrNewChangeSetNamed: aName	^ChangeSet existingOrNewChangeSetNamed: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!gatherChangeSets		"ChangeSorter gatherChangeSets"	^ChangeSet gatherChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (ChangeSet allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!promoteToTop: aChangeSet	"Make aChangeSet the first in the list from now on"	^ChangeSet promoteToTop: aChangeSet! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString := aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease := self changeSetNamesInThreeOh]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 10:03'!initialize	"Initialize the class variables"	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker := 0.! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories := ElementCategory new categoryName: #ChangeSetCategories.	aCategory := ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease := (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!basicNewChangeSet: newName	^ChangeSet basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangesFromStream: aStream named: aName	^ChangeSet newChangesFromStream: aStream named: aName! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	self removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangesOrganizer deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	^ChangeSet removeChangeSet: aChangeSet! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSetsNamedSuchThat: nameBlock	(self changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker := 0]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker := aNumber! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead := OrderedCollection new.	newMid := OrderedCollection new.	newTail := OrderedCollection new.	ChangeSet allChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	ChangeSet allChangeSets: newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!secondaryChangeSet	^ChangeSet secondaryChangeSet! !!ChangesOrganizer class methodsFor: 'utilities' stamp: 'pk 2/6/2006 09:49'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | (aChangeSet := self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!CodeHolder methodsFor: 'annotation' stamp: 'pk 10/17/2006 09:38'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:33'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange := changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass := aChange methodClass) notNil				and: [ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:34'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream := WriteStream on: (String new: 200).	(all := ChangesOrganizer allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index := (UIManager default chooseFrom: (aStream contents substrings)).	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeSorter methodsFor: 'access' stamp: 'pk 10/17/2006 09:37'!showChangeSetNamed: aName	self showChangeSet: (ChangesOrganizer changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!changeSetCategories	^ ChangesOrganizer changeSetCategories! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats := self changeSetCategories elementsInOrder.	aMenu := SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result := aMenu startUp.	result ifNotNil:		[changeSetCategory := result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategoryInMorphic	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Choose the category ofchange sets to show inthis Change Sorter(red = current choice)'.	self changeSetCategories elementsInOrder do:		[:aCategory |			aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.			aCategory == changeSetCategory ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: aCategory documentation].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically := self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen := (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangesOrganizer changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName := UIManager default request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName := catName asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := StaticChangeSetCategory new categoryName: catName.	self changeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName := self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName := UIManager default request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName := ('Changes to ', clsName) asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	self changeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName := changeSetCategory categoryName), '?') ifFalse: [^ self].	self changeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName := myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message := 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg := myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber := myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangesOrganizer removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName := UIManager default request: 'Please give the new category a name' initialAnswer:  (oldName := changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName := catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	self changeSetCategories removeElementAt: oldName.	self changeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	| aMenu |	Smalltalk isMorphic		ifFalse:			[self inform:'Only available in morphic, right now, sorry.It would not take much to make thisalso work in mvc, so if you areinclined to do that, thanks in advance...']		ifTrue:			[aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Categories whichcontain change set"', myChangeSet name, '"'.			self changeSetCategories elementsInOrder do:				[:aCategory |					(aCategory includesChangeSet: myChangeSet)						ifTrue:							[aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.						aCategory == changeSetCategory ifTrue:							[aMenu lastItem color: Color red]].						aMenu balloonTextForLastItem: aCategory documentation].				aMenu popUpInWorld]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:37'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory := aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:10'!initialize	"ChangeSorter initialize"	FileList registerFileReader: self.	self registerInFlapsRegistry.! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 08:59'!allChangeSetNames	^ ChangesOrganizer allChangeSetNames! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:00'!allChangeSets	^ ChangesOrganizer allChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!allChangeSetsWithClass: class selector: selector	^ ChangesOrganizer allChangeSetsWithClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:19'!assuredChangeSetNamed: aName	^ ChangesOrganizer assuredChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!basicNewChangeSet: newName	^ ChangesOrganizer basicNewChangeSet: newName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAdditions: aChangeSet	^ ChangesOrganizer belongsInAdditions: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAll: aChangeSet	^ ChangesOrganizer belongsInAll: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInMyInitials: aChangeSet	^ ChangesOrganizer belongsInMyInitials: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	^ ChangesOrganizer belongsInNumbered: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInProjectChangeSets: aChangeSet	^ ChangesOrganizer belongsInProjectChangeSets: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInProjectsInRelease:  aChangeSet	^ ChangesOrganizer belongsInProjectsInRelease:  aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInRecentUpdates: aChangeSet	^ ChangesOrganizer belongsInRecentUpdates: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!buildAggregateChangeSet	^ ChangesOrganizer buildAggregateChangeSet	! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSet: aChangeSet containsClass: aClass	^ ChangesOrganizer changeSet: aChangeSet containsClass: aClass! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetCategoryNamed: aName	^ ChangesOrganizer changeSetCategoryNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetNamed: aName	^ ChangesOrganizer changeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetNamesInReleaseImage	^ ChangesOrganizer changeSetNamesInReleaseImage! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:08'!changeSetNamesInThreeOh	^ ChangesOrganizer changeSetNamesInThreeOh! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer changeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!countOfChangeSetsWithClass: aClass andSelector: aSelector	^ ChangesOrganizer countOfChangeSetsWithClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!deleteChangeSetsNumberedLowerThan: anInteger	^ ChangesOrganizer deleteChangeSetsNumberedLowerThan: anInteger! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	^ ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!existingOrNewChangeSetNamed: aName	^ ChangesOrganizer existingOrNewChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:23'!fileOutChangeSetsNamed: nameList	^ ChangesOrganizer fileOutChangeSetsNamed: nameList! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!gatherChangeSets	^ ChangesOrganizer gatherChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!highestNumberedChangeSet	^ ChangesOrganizer highestNumberedChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:10'!initializeChangeSetCategories	^ ChangesOrganizer initializeChangeSetCategories! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!mostRecentChangeSetWithChangeForClass: class selector: selector	^ ChangesOrganizer mostRecentChangeSetWithChangeForClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!newChangeSet	^ ChangesOrganizer newChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangeSet: aName	^ ChangesOrganizer newChangeSet: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangesFromStream: aStream named: aName	^ ChangesOrganizer newChangesFromStream: aStream named: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:11'!noteChangeSetsInRelease	^ ChangesOrganizer noteChangeSetsInRelease! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:14'!promoteToTop: aChangeSet	^ ChangesOrganizer promoteToTop: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!recentUpdateMarker	^ ChangesOrganizer recentUpdateMarker! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!recentUpdateMarker: aNumber	^ ChangesOrganizer recentUpdateMarker: aNumber! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!removeChangeSet: aChangeSet	^ ChangesOrganizer removeChangeSet: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeChangeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer removeChangeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeEmptyUnnamedChangeSets	^ ChangesOrganizer removeEmptyUnnamedChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!reorderChangeSets	^ ChangesOrganizer reorderChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!secondaryChangeSet	^ ChangesOrganizer secondaryChangeSet! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet pseudoClass: pseudoClass selector: selector	"Returns the source code for a conflict if a conflict is found, otherwise returns nil."	| classOrMeta allChangeSets moreRecentChangeSets conflictingChangeSets changeRecordSource classAndMethodPrintString |	classAndMethodPrintString _ pseudoClass name, (pseudoClass hasMetaclass ifTrue: [' class'] ifFalse: ['']), '>>', selector asString.	changeRecordSource _ pseudoClass sourceCode at: selector.	changeRecordSource isText		ifTrue: [changeRecordSource _ Text					fromString: 'method: ', classAndMethodPrintString, ' was removed']		ifFalse: [changeRecordSource stamp isEmptyOrNil ifTrue:					[self notify: 'Warning: ', classAndMethodPrintString, ' in ', self packageName, ' has no timestamp/initials!!']].	pseudoClass exists ifFalse:		[(self classes at: pseudoClass name) hasDefinition			ifTrue: [^ nil  "a method was added for a newly defined class; not a conflict"]			ifFalse: [self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString, '... class ', pseudoClass name asString, ' does not exist in the image and is not defined in the file'.					^ changeRecordSource]].	classOrMeta _ pseudoClass realClass.	"Only printout the replacing methods here, but we still check for removed methods too in the rest of this method."	(self class verboseConflicts and: [classOrMeta includesSelector: selector])		ifTrue: [self class logCr; log: '...checking ', classOrMeta asString, '>>', selector asString].	allChangeSets _ ChangesOrganizer allChangeSets.	moreRecentChangeSets _ allChangeSets				copyFrom: (allChangeSets indexOf: updateNumberChangeSet)				to: (allChangeSets size).	conflictingChangeSets _ (moreRecentChangeSets select:		[:cs | (cs atSelector: selector class: classOrMeta) ~~ #none]).	conflictingChangeSets isEmpty ifTrue: [^ nil].	self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString,				(' with newer changeset' asPluralBasedOn: conflictingChangeSets).	conflictingChangeSets do: [:cs | self class log: ' ', cs name].	^ changeRecordSource! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!findUpdateChangeSetMatching: updateNumber	"Find update-changeset beginning with updateNumber, or reasonably close."	"This is to account for the fact that many changeset files are output from final releases, but may be tested for conflicts in a following alpha image, which will often not include that particular update-changeset from the final release but will contain ones near it.  For example, if the file updateNumber is 5180 (from 3.5 final), but the image has no update-changeset beginning with 5180 because it's a 3.6alpha image (which starts at 5181), it will try up to 5190 and down to 5170 for a close match."	| updateNumberChangeSet updateNumberToTry |	updateNumberToTry _ updateNumber.	updateNumberChangeSet _ nil.	[updateNumberChangeSet isNil and: [updateNumberToTry notNil]] whileTrue:		[updateNumberChangeSet _ ChangesOrganizer allChangeSets			detect: [:cs | (cs name beginsWith: updateNumberToTry asString)							and: [(cs name at: (updateNumberToTry asString size + 1)) isDigit not]]			ifNone: [nil].		updateNumberToTry >= updateNumber ifTrue:			[updateNumberToTry < (updateNumber + 10)				ifTrue: [updateNumberToTry _ updateNumberToTry + 1]				ifFalse: [updateNumberToTry _ updateNumber]].		updateNumberToTry <= updateNumber ifTrue:			[updateNumberToTry > (updateNumber - 10)				ifTrue: [updateNumberToTry _ updateNumberToTry - 1]				ifFalse: [updateNumberToTry _ nil  "we're done trying"]].		].	updateNumberChangeSet ifNil:		[(self confirm: 'Warning: No changeset beginning with ',updateNumber asString, ' (within +/- 10) was found in the image.You must have changesets going back this far in your imagein order to accurately check for conflicts.Proceed anyway?')			ifTrue: [updateNumberChangeSet _ ChangesOrganizer allChangeSets first]].	^ updateNumberChangeSet! !!FileStream methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:39'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: (self localName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:40'!fileIntoNewChangeSet: fullFileName	"FileIn the contents of a gzipped file"	| zipped unzipped cs |	cs := Smalltalk at: #ChangesOrganizer ifAbsent: [ ^self ].	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	cs newChangesFromStream: unzipped named: (FileDirectory localNameFor: fullFileName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:41'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	(suffix = 'gz') | (suffix = '*')		ifFalse: [^ #()].	services := OrderedCollection new.	(suffix = '*') | (fullName asLowercase endsWith: '.cs.gz') | (fullName asLowercase endsWith: '.mcs.gz')		ifTrue: [services add: self serviceFileIn.			(Smalltalk includesKey: #ChangSet)				ifTrue: [services add: self serviceFileIntoNewChangeSet]].	services addAll: self services.	^ services! !!MCPackageLoader methodsFor: 'private' stamp: 'pk 10/17/2006 09:41'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: 'Sorry that name is already used'. ^nil ].	^ChangeSet basicNewNamed: newName.! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !ChangeSorter initialize!CodeHolder subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!ChangesOrganizer initialize!