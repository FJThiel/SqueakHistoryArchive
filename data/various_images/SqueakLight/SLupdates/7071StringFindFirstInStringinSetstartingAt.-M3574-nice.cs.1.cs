'From SqueakLight|II of 31 May 2008 [latest update: #7068] on 2 June 2008 at 7:27:53 am'!"Change Set:		WideCharacterSet-copy-Patch-M3574-niceDate:			20 November 2007Author:			niceWideCharacterSet copy is shallow: changing a copy changes the original.This is a patch."!Collection subclass: #WideCharacterSet	instanceVariableNames: 'map'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!WideCharacterSet commentStamp: 'nice 5/9/2006 23:33' prior: 0!WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.Implementation should be efficient in memory if sets are sufficently sparse.Wide Characters are at most 32bits.We split them into 16 highBits and 16 lowBits.map is a dictionary key: 16 highBits value: map of 16 lowBits.Maps of lowBits  are stored as arrays of bits in a WordArray.If a bit is set to 1, this indicate that corresponding character is present.Only 2048 entries are necessary in each lowmap.And only lowmap corresponding to a present high value are stored.!!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:09'!includes: aCharacter	aCharacter asciiValue >= 256		ifTrue: ["Guard against wide characters"			^false].	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!remove: aCharacter	aCharacter asciiValue >= 256		ifFalse: ["Guard against wide characters"			map at: aCharacter asciiValue + 1 put: 0].	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:02'!size	^map sum! !!CharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:23'!hasWideCharacters	^false! !!CharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 23:22'!wideCharacterMap	"used for comparing with WideCharacterSet"		| wide |	wide := WideCharacterSet new.	wide addAll: self.	^wide wideCharacterMap! !!String methodsFor: 'accessing' stamp: 'nice 3/15/2007 21:03'!indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock 	"returns the index of the first character in the given set, starting from start "		| ans |	ans := self isWideString				ifTrue: ["Fallback to naive implementation"					self class						findFirstInString: self						inCharacterSet: aCharacterSet						startingAt: start]				ifFalse: ["We know we contain only byte characters						So use a byteArrayMap opimized for primitive call"					self class						findFirstInString: self						inSet: aCharacterSet byteArrayMap						startingAt: start].	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!String class methodsFor: 'primitives' stamp: 'nice 3/15/2007 20:59'!findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start 	"Trivial, non-primitive version"		start		to: aString size		do: [:i | (aCharacterSet					includes: (aString at: i))				ifTrue: [^ i]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!= anObject	^self species == anObject species and: [		self wideCharacterMap = anObject wideCharacterMap ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/10/2006 00:26'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 8. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 11/15/2007 21:26'!hash	"Answer a hash code aimed at storing and retrieving the receiver in a Set or Dictionary.	Two equal objects should have equal hash.	Note: as the receiver can be equal to an ordinary CharacterSet,	the hash code must reflect this"		^self hasWideCharacters		ifTrue: [map hash]		ifFalse: [self asCharacterSet hash]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!species	^self hasWideCharacters		ifTrue: [WideCharacterSet]		ifFalse: [CharacterSet]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:14'!wideCharacterMap	^map! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: [WordArray new: 2048].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/10/2006 00:21'!do: aBlock 	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | aBlock						value: (Character value: ((high bitShift: 16) bitOr: low))]]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:49'!includes: aCharacter 	| val high low |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	^(self		bitmap: (map				at: high				ifAbsent: [^ false])		at: low) isZero not! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 9/25/2007 21:01'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map				at: high				ifAbsent: [^ aCharacter].	self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:00'!size	| size |	size := 0.	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | size := size + 1]].	^ size! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/10/2006 00:10'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:47'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:25'!hasWideCharacters	"Answer true if i contain any wide character"		self do: [:e | e asciiValue >= 256 ifTrue: [^true]].	^false! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 5/9/2006 22:31'!initialize	map := Dictionary new.! !!WideCharacterSet methodsFor: 'copying' stamp: 'nice 11/20/2007 00:57'!postCopy	map := map collect: [:each | each copy]! !!WideCharacterSet class methodsFor: 'instance creation' stamp: 'nice 11/15/2007 22:38'!newFrom: aCollection	| newCollection |	newCollection := self new.	newCollection addAll: aCollection.	^newCollection! !!WideCharacterSet reorganize!('comparing' = byteArrayMap hash species wideCharacterMap)('collection ops' add: do: includes: remove: size)('private' bitmap:at: bitmap:do: clearBitmap:at: setBitmap:at:)('testing' hasWideCharacters)('initialize-release' initialize)('converting')('copying' postCopy)!!CharacterSet reorganize!('collection ops' add: do: includes: remove: size)('comparison' = hash species)('conversion' complement)('testing' hasWideCharacters)('private' byteArrayMap initialize wideCharacterMap)!