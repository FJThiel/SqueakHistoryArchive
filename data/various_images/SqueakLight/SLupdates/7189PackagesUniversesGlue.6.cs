'From SqueakLight|II of 31 May 2008 [latest update: #7192] on 6 July 2008 at 4:15:22 pm'!!CodeLoader commentStamp: '<historical>' prior: 0!CodeLoader provides a simple facility for loading code from the network.Examples:	| loader |	loader _ CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!CodeLoader subclass: #UCodeLoader	instanceVariableNames: ''	classVariableNames: 'KnowPackages'	poolDictionaries: ''	category: 'SLIIUniverses'!!UCodeLoader commentStamp: 'edc 7/4/2008 09:39' prior: 0!Some things you could doFor inspecting the 3.10 saved UniversesUCodeLoader knowPackages inspectFor ask about your wished packageUCodeLoader lookFor!]style[(65 32 36 19 1)f2,f2dUCodeLoader knowPackages inspect;;,f2,f2dUCodeLoader lookFor;;,f2!Object subclass: #UGlobalInstaller	instanceVariableNames: 'configuration selectedPackageVersions universe'	classVariableNames: ''	poolDictionaries: ''	category: 'SLIIUniverses'!!UGlobalInstaller commentStamp: 'dc 7/24/2007 11:43' prior: 0!I'm used by universe browsers to keep track of the configuration, the universe, the selected packages... I provide features to install new packages, to upgrade the system...!Object subclass: #UPackage	instanceVariableNames: 'name version category description provides depends url homepage maintainer squeakMapID'	classVariableNames: ''	poolDictionaries: ''	category: 'SLIIUniverses'!Object subclass: #UPackageCategory	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'SLIIUniverses'!Object subclass: #UPackageSpec	instanceVariableNames: 'name version'	classVariableNames: ''	poolDictionaries: ''	category: 'SLIIUniverses'!Magnitude subclass: #UVersion	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'SLIIUniverses'!!CodeLoader methodsFor: 'accessing' stamp: 'edc 7/2/2008 10:37'!segments^ segments! !!CodeLoader methodsFor: 'installing' stamp: 'edc 7/2/2008 10:16'!installSegment: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted inputStream |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	inputStream := (MultiByteBinaryOrTextStream with: contents) reset .	inputStream setConverterForCode.(inputStream fileInObjectAndCode ) inspect! !!CodeLoader methodsFor: 'installing' stamp: 'edc 6/28/2008 09:47'!installSourceFiles| packName pos |	"Install the previously loaded source files"	sourceFiles == nil		ifTrue: [^ self].	sourceFiles		do: [:req | (req url endsWith: '.mcz')				ifTrue: [					pos := req url lastPositionOf: $/.					packName := req url copyFrom: pos + 1 to: req url size.					self tryVersion: packName ].				(req url endsWith: '.sar')				ifTrue: [ SARInstaller new fileInFrom: req contentStream].				(req url endsWith: '.cs') |(req url endsWith: 'st')				ifTrue: [self installSourceFile: req contentStream]].	sourceFiles := nil! !!CodeLoader methodsFor: 'installing' stamp: 'edc 7/2/2008 10:27'!readObject: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted inputStream |	contentStream _ reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted _ SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents _ contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	inputStream := (MultiByteBinaryOrTextStream with: contents) reset .	inputStream setConverterForCode.^(inputStream fileInObjectAndCode ) ! !!CodeLoader methodsFor: 'debugging' stamp: 'edc 6/28/2008 09:50'!tryVersion: packageName | mcw montiNames package version |mcw := MCWorkingCopyBrowser new repository: (MCHttpRepository				location: baseURL				user: ''				password: '').mcw repository ifNotNilDo: [:repos | montiNames := repos readableFileNames ].				package := (montiNames detect:[:ea| ea beginsWith: packageName] ifNone:[] ) .	package ifNotNil: [	version := mcw repository loadVersionFromFileNamed: package.	version load].^version! !!CodeLoader class methodsFor: 'accessing' stamp: 'edc 7/4/2008 10:59'!tryHttpURL: aHttpURL| loader pos baseUrl packName |loader := self new.pos := aHttpURL printString lastPositionOf: $/.	baseUrl := aHttpURL printString  copyFrom: 1 to: pos.	loader baseURL: baseUrl.	packName :=  aHttpURL printString  copyFrom: pos + 1 to: aHttpURL printString size.Transcript show: packName;cr.	loader loadSourceFiles: (Array with: packName).	loader tryVersion: packName! !!Inspector methodsFor: 'menu commands' stamp: 'edc 7/3/2008 08:42'!referencesToSelection	"Open a browser on all references to the selected instance variable, if that's what currently selected.  1/25/96 sw"	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass := self object class) isVariable ifTrue: [^ self changed: #flash].	sel := (aClass allInstVarNames asSortedCollection) at: self selectionIndex  - 2.	self systemNavigation   browseAllAccessesTo: sel from: aClass! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!MCPackageLoader methodsFor: 'public' stamp: 'edc 7/5/2008 18:48'!loadWithNameLike: baseName 	self analyze.	unloadableDefinitions isEmpty		ifFalse: [			self warnAboutDependencies].	self		useNewChangeSetNamedLike: baseName		during: [self basicLoad]! !!MCPackageLoader methodsFor: 'private' stamp: 'edc 7/5/2008 19:04'!analyze	| sorter |	[	sorter := self sorterForItems: additions.	additions := sorter orderedItems.	requirements := sorter externalRequirements.	UCodeLoader solveMissing: requirements]		doWhileFalse: [requirements isEmpty].	unloadableDefinitions := sorter itemsWithMissingRequirements asSortedCollection.	sorter := self sorterForItems: removals.	removals := sorter orderedItems reversed! !!String methodsFor: 'testing' stamp: 'edc 6/27/2008 19:46'!lastPositionOf: aChar	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i)= aChar) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/3/2008 10:37'!foundMe: aString ^UCodeLoader knowPackages detect: [:ea| (ea name,' ',ea version name) = aString] ifNone: [].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 07:51'!knowPackages	| file dir server |	KnowPackages ifNil:[^self loadKnowPackages ].	server := ServerDirectory serverNamed: 'SL'.	dir := server directoryNamed: 'SLupdates'.	file := dir entries				detect: [:c | c name = 'KnowPackages.obz']				ifNone: [].	^ KnowPackages! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 07:51'!loadKnowPackages	"UCodeLoader loadKnowPackages"	| obj loader req |	loader := CodeLoader new.	loader baseURL: 'ftp.squeak.org/various_images/SqueakLight/SLupdates/'.	req := loader createRequestFor: 'KnowPackages.obz' in: HTTPLoader default.	obj := loader readObject: req.	^KnowPackages := obj! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 08:55'!lookFor	"UCodeLoader lookFor"	| menu aPackageName sel sort thisPack |	aPackageName := FillInTheBlank request: 'Package name ? '.	menu := CustomMenu new.	sort := SortedCollection new.	UCodeLoader knowPackages		select: [:ea | aPackageName , '*' match: ea name]		thenDo: [:any | sort add: any name , ' ' , any version name].	sort		ifEmpty: [^ self error: aPackageName , ' seems not in the Universes '].	menu := SelectionMenu selections: sort.	sel := menu startUpCenteredWithCaption: 'Select the one to install '.	thisPack := self foundMe: sel.	thisPack		ifNotNil: [UGlobalInstaller new planToInstallPackage: thisPack].	! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/4/2008 10:09'!newestPackageNamed: aName	| potentials sorted |	potentials _ self packagesNamed: aName.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].		^sorted last! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/4/2008 09:36'!packagesNamed: aPackageName| sort |sort := SortedCollection new.^UCodeLoader knowPackages select:[:ea| aPackageName,'*' match: ea name ]thenDo:[:any| sort add: any name].! !!UCodeLoader class methodsFor: 'as yet unclassified' stamp: 'edc 7/5/2008 19:03'!solveMissing: requirements 	| sourceFile server dir fn |	server := ServerDirectory serverNamed: 'SL'.	dir := server directoryNamed: 'SLupdates'.	requirements		do: [:ea | 			fn := ea asString , '.sqz'.			(dir fileExists: fn)				ifTrue: [sourceFile := HTTPLoader default retrieveContentsFor: 'ftp.squeak.org/various_images/SqueakLight//SLupdates/',fn.					sourceFile := RWBinaryOrTextStream with: sourceFile content unzipped.					sourceFile reset.					ChangeSorter newChangesFromStream: sourceFile named: ea asString]				ifFalse: [self error: ea asString.					' is not in to server ']]! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:38'!allPackages	^ universe packageNames asSortedCollection.! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/22/2007 12:27'!allPossibleUpgrades	^ universe packageNames		inject: OrderedCollection new		into: [ :upgrades :name |			(configuration includesPackageNamed: name)			ifTrue: [| cpack mypack |				cpack := configuration packageNamed: name.				mypack := universe newestPackageNamed: name.				(mypack version > cpack version)					ifTrue: [upgrades add: mypack]].								upgrades].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:39'!installedPackageVersions	^ configuration installedPackages 		asSortedCollection: [:p1 :p2 | p1 name < p2 name].! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'edc 7/4/2008 10:44'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider list |	newPackages := Set new.	packagesToConsider := OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ]		whileFalse: [| package |			package := packagesToConsider removeFirst.			(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName | 									"the dependency is needed but is not installed or planned to be installed"					list := (UCodeLoader packagesNamed: depName).										list  ifNotNil: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (UCodeLoader newestPackageNamed: depName) ]					ifNil: [						^errorBlock value: depName ] ] ] ].		^newPackages! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'dc 4/21/2007 13:13'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^ orderedPackages! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/21/2007 12:43'!anyPackageSelected	^ selectedPackageVersions notEmpty! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!configuration: aConfiguration 	configuration := aConfiguration! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!universe: aUniverse 	universe := aUniverse! !!UGlobalInstaller methodsFor: 'actions' stamp: 'edc 7/5/2008 08:03'!doInstall	| orderedPackages |	self anyPackageSelected not		ifTrue: [^ self].	orderedPackages := self orderPackagesByDependency: selectedPackageVersions.	orderedPackages		do: [:p | Utilities				informUser: 'installing ' , p printString				during: [CodeLoader  tryHttpURL: p url]].	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'actions' stamp: 'edc 7/4/2008 10:24'!planToInstallPackage: initialPackage	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	| newPackages |	"find all packages needed to install this one"	newPackages := self allPackagesNeededToInstall: initialPackage						orIfImpossible: [ :missingDep |								^self notify: 'could not find necessary package: ', missingDep ].		selectedPackageVersions removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | selectedPackageVersions add: p ].	self doInstall.! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:54'!planToInstallPackageNamed: aPackageName	self planToInstallPackage: (universe newestPackageNamed: aPackageName)! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:27'!selectAllUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self allPossibleUpgrades 		do: [:package | self planToInstallPackage: package]! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initialize	super initialize.	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initializeSelectedPackageVersions	selectedPackageVersions := Set new! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'dc 4/21/2007 12:41'!selectedPackageVersions	^ selectedPackageVersions! !!UPackage methodsFor: 'accessing' stamp: 'edc 7/5/2008 08:38'!category	^category ifNil: ['Uncategorized' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!depends	^depends! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!description	^description! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05'!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33'!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!name	^name! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29'!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 11:37'!squeakMapID	^ squeakMapID! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30'!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32'!version	^version! !!UPackage methodsFor: 'printing' stamp: 'ls 8/31/2007 12:25'!longDescription	^Text streamContents: [ :str |		str nextPutAll: self description; cr; cr.		str nextPutAll: 'Category: '; print: self category; cr.		self provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self  depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self  depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self  maintainer); cr.		str nextPutAll: 'Downloads from: '.		self  url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self  url asString ].		str cr.		self  homepage ifNotNil: [			str nextPutAll: 'Homepage: '.			str nextPutAll: (Text string: self homepage asString attribute: (TextURL new url: self homepage asString)).			str cr].		self squeakMapID ifNotNil: [			| smurl |			str nextPutAll: 'SqueakMap UUID: ', self squeakMapID asString, String cr.			smurl := 'http://map.squeak.org/package/', self squeakMapID asString.			str nextPutAll: (Text string: '[browse SqueakMap web page]' attribute: (TextURL new url: smurl)).			str cr.						str nextPutAll: (Text string: '[open SqueakMap browser]' attribute: (TextDoIt evalString: 'USqueakMapUtil browsePackageID: (UUID fromString: ''', self squeakMapID asString, ''')')).			str cr.			]. ] .! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05'!components	^components! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!name	^name! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!version	^version! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33'!components	^components! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28'!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15'!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31'!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02'!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !