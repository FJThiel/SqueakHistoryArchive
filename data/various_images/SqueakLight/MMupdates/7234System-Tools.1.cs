'From SqueakLight|II of 31 May 2008 [latest update: #7257] on 18 September 2009 at 6:18:24 am'!Object subclass: #BreakpointManager	instanceVariableNames: ''	classVariableNames: 'Installed'	poolDictionaries: ''	category: 'System-Tools'!!BreakpointManager commentStamp: '<historical>' prior: 0!This class manages methods that include breakpoints.It has several class methods to install and uninstall breakpoints.Evaluating "BreakpointManager clear" will remove all installed breakpoints in the system.Known issues:- currently, only break-on-entry type of breakpoints are supported- emphasis change not implemented for MVC browsers- uninstalling the breakpoint doesn't auto-update other browsers- uninstalling a breakpoint while debugging should restart-simulate the current methodErnest Micklei, 2002Send comments to emicklei@philemonworks.com!!FakeClassPool commentStamp: '<historical>' prior: 0!The sole purpose of this class is to allow the Browser code pane to evaluate the class variables of the class whose method it is showing.  It does this by stuffing a pointer to the classpool dictionary of the class being shown into its own classpool.  It does this just around a doIt in the code pane.  An instance of FakeClasspool is then used as the receiver of the doIt.!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs process '	classVariableNames: 'DefaultPollPeriod ObservedProcess Timer ShowProcesses '	poolDictionaries: ''	category: 'System-Tools'!!MessageTally commentStamp: '<historical>' prior: 0!My instances observe and report the amount of time spent in methods.NOTE: a higher-level user interface (combining the MessageTally result tree with a method browser) is available from TimeProfileBrowser.MessageTally provides two different strategies available for profiling:* spyOn: and friends use a high-priority Process to interrupt the block or process being spied on at periodic intervals. The interrupted call stack is then examined for caller information.* tallySends: and friends use the interpreter simulator to run the block, recording every method call.The two give you different results:* spyOn: gives you a view of where the time is being spent in your program, at least on a rough statistical level (assuming you've run the block for long enough and have a high enough poll rate). If you're trying to optimize your code, start here and optimize the methods where most of the time is being spent first.* tallySends: gives you accurate counts of how many times methods get called, and by exactly which route. If you're debugging, or trying to figure out if a given method is getting called too many times, this is your tool.You can change the printing format (that is, the whitespace and string compression) by using these instance methods: 	maxClassNameSize:	maxClassPlusSelectorSize:	maxTabs:You can change the default polling period (initially set to 1) by calling	MessageTally defaultPollPeriod: numberOfMillisecondsQ: How do you interpret MessageTally>>tallySendsA: The methods #tallySends and #spyOn: measure two very different quantities, but broken down in the same who-called-who format.  #spyOn: is approximate, but more indicative of real time spent, whereas #tallySends is exact and a precise record of how many times each method got executed.!!SpaceTally commentStamp: '<historical>' prior: 0!I'm responsible to help getting information about system space usage. The information I compute is represented by a spaceTallyItemtry something like: ((SpaceTally new spaceTally: (Array with: TextMorph with: Point)) 	asSortedCollection: [:a :b | a spaceForInstances > b spaceForInstances]) SpaceTally new systemWideSpaceTallyThis class has been created from a part of SystemDictionary. It still deserves a niceclean, such as using object instead of array having 4 slots.sd-20 June 2003!!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'nice 4/10/2008 22:00'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod := self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass basicAddSelector: aSymbol withMethod: breakMethod.! !!FakeClassPool class methodsFor: 'initialize' stamp: 'dvf 9/27/2005 19:05'!adopt: classOrNil	"Temporarily use the classPool and sharedPools of another class"	classOrNil isBehavior		ifFalse: [classPool := nil.				sharedPools := nil]		ifTrue: [classPool := classOrNil classPool.				sharedPools := classOrNil sharedPools]! !!MessageTally methodsFor: 'collecting leaves'!bump: hitCount	tally := tally + hitCount! !!MessageTally methodsFor: 'collecting leaves'!bump: hitCount fromSender: senderTally	"Add this hitCount to the total, and include a reference to the	sender responsible for the increment"	self bump: hitCount.	senders == nil ifTrue: [senders := OrderedCollection new].	senderTally == nil		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 3/4/2009 13:48'!into: leafDict fromSender: senderTally	| leafNode |	leafNode _ leafDict at: method		ifAbsent: [leafDict at: method			put: ((MessageTally new class: class method: method)				process: process)].	leafNode bump: tally fromSender: senderTally! !!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 3/4/2009 14:33'!leavesInto: leafDict fromSender: senderTally	| rcvrs |	rcvrs _ self sonsOver: 0.	rcvrs size = 0		ifTrue: [self into: leafDict fromSender: senderTally]		ifFalse: [						"Do not show 'other processes' "			"Please keep consistency with #rootPrintOn:total:totalTime:tallyExact:orThreshold: 			on showing them or not!!"			rcvrs anyOne process ifNil: [^self].						rcvrs do:				[:node |				node isPrimitives					ifTrue: [node leavesInto: leafDict fromSender: senderTally]					ifFalse: [node leavesInto: leafDict fromSender: self]]]! !!MessageTally methodsFor: 'comparing' stamp: 'ar 3/3/2009 19:36'!= aMessageTally	self species == aMessageTally species ifFalse: [^ false].	^ aMessageTally method == method and:[aMessageTally process == process]! !!MessageTally methodsFor: 'comparing' stamp: 'dtl 8/29/2009 12:49'!hash	"Hash is reimplemented because = is implemented."	^method identityHash! !!MessageTally methodsFor: 'comparing' stamp: 'jmv 3/4/2009 13:48'!sonsOver: threshold	| hereTally last sons |	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].	hereTally _ tally.	sons _ receivers select:  "subtract subNode tallies for primitive hits here"		[:son |		hereTally _ hereTally - son tally.		son tally > threshold].	hereTally > threshold		ifTrue: 			[last _ MessageTally new class: class method: method.			last process: process.			^sons copyWith: (last primitives: hereTally)].	^sons! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 3/4/2009 10:35'!close	(Timer isMemberOf: Process) ifTrue: [Timer terminate].	Timer := nil.	class := method := tally := receivers := nil! !!MessageTally methodsFor: 'initialize-release' stamp: 'nk 3/8/2004 12:29'!initialize	maxClassNameSize := self class defaultMaxClassNameSize.	maxClassPlusSelectorSize := self class defaultMaxClassPlusSelectorSize.	maxTabs := self class defaultMaxTabs.! !!MessageTally methodsFor: 'initialize-release' stamp: 'ar 9/4/2009 00:07'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay startTime time0 observedProcess |	(aBlock isBlock)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer := [		[true] whileTrue: [			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self tally: observedProcess suspendedContext				in: (ShowProcesses ifTrue: [observedProcess])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 9/12/2009 03:13'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay startTime time0 observedProcess |	aBlock isBlock		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer := [		[true] whileTrue: [			startTime := Time millisecondClockValue.			myDelay wait.			self tally: Processor preemptedProcess suspendedContext				in: (ShowProcesses ifTrue: [					observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil]])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer ifNotNil: [ Timer terminate ].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 3/4/2009 15:18'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay startTime time0 endTime sem observedProcess |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer := [			[				startTime := Time millisecondClockValue.				myDelay wait.				self tally: Processor preemptedProcess suspendedContext					in: (ShowProcesses ifTrue: [						observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil]])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 		gcStats at: idx put: (gcVal - gcStats at: idx)].	time := Time millisecondClockValue - time0! !!MessageTally methodsFor: 'printing' stamp: 'ar 3/3/2009 19:43'!fullPrintOn: aStream tallyExact: isExact orThreshold: perCent	| threshold |  	isExact ifFalse: [threshold _ (perCent asFloat / 100 * tally) rounded].	aStream nextPutAll: '**Tree**'; cr.	self rootPrintOn: aStream		total: tally		totalTime: time		tallyExact: isExact		orThreshold: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self leavesPrintOn: aStream		tallyExact: isExact		orThreshold: threshold! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!leavesPrintOn: aStream tallyExact: isExact orThreshold: threshold	| dict |	dict := IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	isExact ifTrue: 		[dict asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: nil tallyExact: isExact.				node printSenderCountsOn: aStream]]		ifFalse:		[(dict asOrderedCollection				select: [:node | node tally > threshold])			asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: time tallyExact: isExact]]! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!printSenderCountsOn: aStream	| mergedSenders mergedNode |	mergedSenders := IdentityDictionary new.	senders do:		[:node |		mergedNode := mergedSenders at: node method ifAbsent: [nil].		mergedNode == nil			ifTrue: [mergedSenders at: node method put: node]			ifFalse: [mergedNode bump: node tally]].	mergedSenders asSortedCollection do:		[:node | 		10 to: node tally printString size by: -1 do: [:i | aStream space].		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !!MessageTally methodsFor: 'printing' stamp: 'jmv 3/4/2009 15:19'!rootPrintOn: aStream total: total totalTime: totalTime tallyExact: isExact orThreshold: threshold 	| sons groups p |	ShowProcesses ifFalse:[		^self treePrintOn: aStream			tabs: OrderedCollection new			thisTab: ''			total: total			totalTime: totalTime			tallyExact: isExact			orThreshold: threshold.	].	sons := isExact ifTrue: [receivers] ifFalse: [self sonsOver: threshold].	groups := sons groupBy:[:aTally| aTally process] having:[:g| true].	groups do:[:g|		sons := g asSortedCollection.		p := g anyOne process.		"Do not show 'other processes' "		"Please keep consistency with #leavesInto:fromSender: 		on showing them or not!!"		p ifNotNil: [			aStream nextPutAll: '--------------------------------'; cr.			aStream nextPutAll: 'Process: ',  (p ifNil: [ 'other processes'] ifNotNil: [ p browserPrintString]); cr.			aStream nextPutAll: '--------------------------------'; cr.			(1 to: sons size) do:[:i | 				(sons at: i) 					treePrintOn: aStream					tabs: OrderedCollection new					thisTab: ''					total: total					totalTime: totalTime					tallyExact: isExact					orThreshold: threshold]].	].! !!MessageTally methodsFor: 'reporting' stamp: 'jmv 3/4/2009 09:27'!report: strm 	"Print a report, with cutoff percentage of each element of the tree 	(leaves, roots, tree), on the stream, strm."	self report: strm cutoff: 1! !!MessageTally methodsFor: 'reporting' stamp: 'ar 7/18/2001 22:12'!reportGCStatsOn: str	| oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime rootOverflows |	upTime := time.	oldSpaceEnd			:= gcStats at: 1.	youngSpaceEnd		:= gcStats at: 2.	memoryEnd			:= gcStats at: 3.	fullGCs				:= gcStats at: 7.	fullGCTime			:= gcStats at: 8.	incrGCs				:= gcStats at: 9.	incrGCTime			:= gcStats at: 10.	tenureCount			:= gcStats at: 11.	rootOverflows		:= gcStats at: 22.	str cr.	str	nextPutAll: '**Memory**'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str cr.	str	nextPutAll: '**GCs**'; cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	incrGCs = 0 ifFalse:		[str nextPutAll:', avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.	str	nextPutAll: '	root table	';		nextPutAll: rootOverflows asStringWithCommas; nextPutAll:' overflows'.	str cr.! !!MessageTally methodsFor: 'tallying'!bumpBy: count	tally := tally + count! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 10:36'!tally: context by: count	"Explicitly tally the specified context and its stack."	| sender |		"Add to this node if appropriate"	context method == method ifTrue: [^self bumpBy: count].		"No sender? Add new branch to the tree."	(sender := context home sender)ifNil: [		^ (self bumpBy: count) tallyPath: context by: count].		"Find the node for the sending context (or add it if necessary)"	^ (self tally: sender by: count) tallyPath: context by: count! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 09:42'!tally: context in: aProcess by: count	"Explicitly tally the specified context and its stack."	| sender |	"Add to this node if appropriate"	context method == method ifTrue: [^self bumpBy: count].		"No sender? Add new branch to the tree."	(sender := context home sender) ifNil: [		^ (self bumpBy: count) tallyPath: context in: aProcess by: count].		"Find the node for the sending context (or add it if necessary)"	^ (self tally: sender in: aProcess by: count) tallyPath: context in: aProcess by: count! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 10:36'!tallyPath: context by: count	| aMethod path |	aMethod :=context method.		"Find the correct child (if there)"	receivers do: [ :oldTally | 		oldTally method == aMethod ifTrue: [path := oldTally]].		"Add new child if needed"	path ifNil: [		path := MessageTally new class: context receiver class method: aMethod.		receivers := receivers copyWith: path].		^ path bumpBy: count! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 10:38'!tallyPath: context in: aProcess by: count	| aMethod path |	aMethod := context method.		"Find the correct child (if there)"	receivers do: [ :oldTally | 		(oldTally method == aMethod and: [oldTally process == aProcess])			ifTrue: [path := oldTally]].			"Add new child if needed"	path ifNil:[		path := MessageTally new class: context receiver class method: aMethod;			process: aProcess;			maxClassNameSize: maxClassNameSize;			maxClassPlusSelectorSize: maxClassPlusSelectorSize;			maxTabs: maxTabs.		receivers := receivers copyWith: path].	^ path bumpBy: count! !!MessageTally methodsFor: 'private'!class: aClass method: aMethod	class := aClass.	method := aMethod.	tally := 0.	receivers := Array new: 0! !!MessageTally methodsFor: 'private' stamp: 'jmv 3/4/2009 13:47'!copyWithTally: hitCount	^ (MessageTally new class: class method: method) 		process: process;		bump: hitCount! !!MessageTally methodsFor: 'private'!primitives: anInteger	tally := anInteger.	receivers := nil! !!MessageTally methodsFor: 'private' stamp: 'ar 3/3/2009 19:29'!process	^process! !!MessageTally methodsFor: 'private' stamp: 'ar 3/3/2009 19:29'!process: aProcess	process := aProcess! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 3/2/2009 12:32'!defaultMaxTabs	"Return the default number of tabs after which leading white space is compressed"	^120! !!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:41'!defaultPollPeriod	"Answer the number of milliseconds between interrupts for spyOn: and friends.	This should be faster for faster machines."	^DefaultPollPeriod ifNil: [ DefaultPollPeriod := 1 ]! !!MessageTally class methodsFor: 'defaults' stamp: 'ar 9/4/2009 00:09'!showProcesses	"Indicates whether to show each process separately or cumulatively.	For example, compare the spy results of the following with both values:			[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait] 	"	<preference: 'Show Tally Processes'		category: 'debug'		description: 'When true, show individual processes in MessageTally'		type: #Boolean>	^ShowProcesses! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 3/4/2009 10:29'!showProcesses: aBool	"Indicates whether to show each process separately or cumulatively.	For example, compare the spy results of the following with both values:			[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		[1000 timesRepeat: [30 factorial. Processor yield]] fork.		MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]	"	ShowProcesses := aBool.! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 3/4/2009 10:42'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node := self new.	result := node spyAllEvery: self defaultPollPeriod on: aBlock.	(StringHolder new contents: (String streamContents: [:s | node report: s; close]))		openLabel: 'Spy Results'.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 3/4/2009 15:12'!spyOn: aBlock	"	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]]	"	| node result |	node _ self new.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	(StringHolder new contents: (String streamContents: [:s | node report: s; close]))		openLabel: 'Spy Results'.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:34'!spyOn: aBlock toFileNamed: fileName 	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| file value node |	node := self new.	value := node spyEvery: self defaultPollPeriod on: aBlock.	file := FileStream newFileNamed: fileName.	node report: file; close.	file close.	^value! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 3/4/2009 15:13'!spyOnProcess: aProcess forMilliseconds: msecDuration 	"	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] fork.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] fork.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000	"	| node |	node := self new.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(StringHolder new		contents: (String				streamContents: [:s | node report: s;						 close]))		openLabel: 'Spy Results'! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:35'!spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName 	"Spy on the evaluation of aProcess. Write the data collected on a file  	named fileName. Will overwrite fileName"	| file node |	node := self new.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	file := FileStream fileNamed: fileName.	node report: file;		 close.	file close! !!MessageTally class methodsFor: 'spying' stamp: 'tk 5/4/1998 17:01'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"MessageTally tallySends: [3.14159 printString]"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime := Time millisecondClockValue.	tallies := MessageTally new class: aBlock receiver class							method: aBlock method.	prev := aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev := current]].	totalTime := Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].			tallies close]))		openLabel: 'Spy Results'! !!MessageTally class methodsFor: 'class initialization' stamp: 'jmv 3/4/2009 09:24'!initialize	"MessageTally initialize"	"By default, show each process separately"	ShowProcesses := true! !!MethodReference methodsFor: 'queries' stamp: 'md 8/27/2005 17:17'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 06:04'!setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol := classSym.	classIsMeta := isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 08:06'!setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'setting' stamp: 'kph 12/16/2006 10:06'!setStandardClass: aClass methodSymbol: methodSym	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := nil.! !!MethodReference methodsFor: 'string version' stamp: 'RAA 5/29/2001 14:44'!stringVersion: aString	stringVersion := aString! !!ModifiedClassDefinitionEvent methodsFor: '*Kernel-Classes' stamp: 'edc 9/18/2009 06:15'!isTraitCompositionModified	^ false! !!SpaceTally methodsFor: 'class analysis' stamp: 'efc 7/6/2004 00:30'!computeSpaceUsage	| entry c instanceCount |	1 to: results size do: [:i |		entry := results at: i.		c := self class environment at: entry analyzedClassName.		instanceCount := c instanceCount.		entry codeSize: c spaceUsed.		entry instanceCount: instanceCount.		entry spaceForInstances: (self spaceForInstancesOf: c withInstanceCount: instanceCount).		Smalltalk garbageCollectMost].	! !!SpaceTally methodsFor: 'class analysis' stamp: 'sd 6/20/2003 22:54'!preAllocateResultsFor: classes	results := OrderedCollection new: classes size.	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].	results := results asArray.! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 22:39'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys before after diff |	beforeDict := Dictionary new.	s := FileDirectory default fileNamed: beforeFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict := Dictionary new.	s := FileDirectory default fileNamed: afterFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer := WriteStream on: String new.	allKeys := (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asSortedCollection.	allKeys do: [ :each |		before := beforeDict at: each ifAbsent: [#(0 0 0)].		after := afterDict at: each ifAbsent: [#(0 0 0)].		diff := before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each,'  ',diff printString; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'space diffs'.	! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 23:03'!printSpaceAnalysis: threshold on: fileName	"SpaceTally new printSpaceAnalysis: 1000 on: 'STspace.text1'"	"sd-This method should be rewrote to be more coherent within the rest of the class 	ie using preAllocate and spaceForInstanceOf:"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.	results := OrderedCollection new: Smalltalk classNames size.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during: [:bar |	Smalltalk allClassesDo:		[:cl | codeSpace := cl spaceUsed.		bar value: (n := n+1).		Smalltalk garbageCollectMost.		instCount := cl instanceCount.		instSpace := (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize := cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace := instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace := instSpace + (cl instSize*instCount*4)].		results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).		totalCodeSpace := totalCodeSpace + codeSpace.		totalInstCount := totalInstCount + instCount.		totalInstSpace := totalInstSpace + instSpace]].	totalPercent := 0.0.	f := FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])				asSortedCollection: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].	results do:		[:s | f nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).		percent := s spaceForInstances*100.0/totalInstSpace roundTo: 0.1.		totalPercent := totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).	f close! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 23:07'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 22:59'!saveTo: aFileName	"| st |	st := SpaceTally new.	st spaceTally: (Array with: TextMorph with: Point).	st saveTo: 'spaceTally2'"	| s |	(FileDirectory default fileExists: aFileName) ifTrue: [		FileDirectory default deleteFileNamed: aFileName].	s := FileDirectory default fileNamed: aFileName.	results do: [:each | s nextPutAll: each analyzedClassName asString ; 						nextPutAll: ' '; nextPutAll: each codeSize printString; 						nextPutAll: ' '; nextPutAll: each instanceCount printString; 						nextPutAll: ' '; nextPutAll: each spaceForInstances printString; cr].	s close! !!SpaceTally methodsFor: 'instance size' stamp: 'efc 7/6/2004 00:30'!spaceForInstancesOf: aClass withInstanceCount: instCount	"Answer the number of bytes consumed by all instances of the given class, including their object headers."	| isCompact instVarBytes bytesPerElement contentBytes headerBytes total |	instCount = 0 ifTrue: [^ 0].	isCompact := aClass indexIfCompact > 0.	instVarBytes := aClass instSize * 4.	aClass isVariable		ifTrue: [			bytesPerElement := aClass isBytes ifTrue: [1] ifFalse: [4].			total := 0.			aClass allInstancesDo: [:inst |				contentBytes := instVarBytes + (inst size * bytesPerElement).				headerBytes :=					contentBytes > 255						ifTrue: [12]						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].				total := total + headerBytes + contentBytes].			^ total]		ifFalse: [			headerBytes :=				instVarBytes > 255					ifTrue: [12]					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].			^ instCount * (headerBytes + instVarBytes)].! !MessageTally initialize!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method process tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs'	classVariableNames: 'DefaultPollPeriod ShowProcesses Timer'	poolDictionaries: ''	category: 'System-Tools'!