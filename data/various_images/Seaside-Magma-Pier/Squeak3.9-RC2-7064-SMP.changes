'From Squeak3.9alpha of 4 July 2005 [latest update: #7054] on 7 September 2006 at 11:22:45 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Smalltalk condenseSources.SystemVersion current version: 'Squeak3.9gamma'; date: '23 July 2006'.self inform: 'The version number for this image hasnow been advanced to Squeak3.9gamma.'!----End fileIn of a stream----!"empty cs to bump cs number to 7056"!----End fileIn of a stream----!----SNAPSHOT----an Array(7 September 2006 11:23:23 pm) Squeak3.9b-7053.image priorSource: 0!----QUIT/NOSAVE----an Array(7 September 2006 11:23:29 pm) Squeak3.9b-7053.image priorSource: 670!----STARTUP----an Array(7 September 2006 11:23:48 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9b-7053:Squeak3.9b-7053.image!----SNAPSHOT----an Array(7 September 2006 11:28:13 pm) Squeak3.9b-7056.image priorSource: 670!----QUIT/NOSAVE----an Array(7 September 2006 11:28:23 pm) Squeak3.9b-7056.image priorSource: 993!----STARTUP----an Array(7 September 2006 11:28:50 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9b-7056.image!----SNAPSHOT----an Array(7 September 2006 11:28:55 pm) Squeak3.9g-7056.image priorSource: 993!----QUIT/NOSAVE----an Array(7 September 2006 11:29 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(7 September 2006 11:29:10 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9g-7056.image!----QUIT----an Array(7 September 2006 11:30 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(10 September 2006 8:06:33 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7056.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!cleaningCS	"self new cleaningCS" 	 	ChangeSorter removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59' prior: 29494449!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.305.mcz') load.ScriptLoader new updateFrom7056.!----End fileIn of a stream----!----SNAPSHOT----an Array(10 September 2006 8:13:08 pm) Squeak3.9g-7056.image priorSource: 1641!----SNAPSHOT----an Array(10 September 2006 8:13:23 pm) Squeak3.9g-7057.image priorSource: 4851!----QUIT----an Array(10 September 2006 8:13:29 pm) Squeak3.9g-7057.image priorSource: 4948!----STARTUP----an Array(14 September 2006 9:30:35 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7057.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33' prior: 29495067!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07' prior: 50891697!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11' prior: 50892769!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12' prior: 27893618!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13' prior: 27894402!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14' prior: 27896694!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.309.mcz') load.ScriptLoader new updateFrom7057.!----End fileIn of a stream----!----SNAPSHOT----an Array(14 September 2006 9:32:22 pm) Squeak3.9g-7058.image priorSource: 5045!----QUIT/NOSAVE----an Array(14 September 2006 9:32:27 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:45:56 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33568303!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!call                    ^ self isCalled! !!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!isCalled                    ^ 1! !Smalltalk removeClassNamed: #AClassForTest!testRequirement  "  self debug: #testRequirement!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29' prior: 33570915!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !ScriptLoader removeSelector: #script86!"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33573645!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!----QUIT/NOSAVE----an Array(22 September 2006 2:53:01 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:53:09 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33576725!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!----SNAPSHOT----an Array(22 September 2006 2:56:15 pm) Squeak3.9g-7061.image priorSource: 13446!----SNAPSHOT----an Array(22 September 2006 2:56:23 pm) Squeak3.9g-7061.image priorSource: 27219!----QUIT/NOSAVE----an Array(22 September 2006 2:56:29 pm) Squeak3.9g-7061.image priorSource: 27317!----STARTUP----an Array(14 October 2006 10:29:19 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7061/Squeak3.9g-7061.image!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!"Installed SUnit auto version 14".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '26bea8bf-733f-4715-b188-fa6d848984ad' autoVersion: '14' asVersion atSeconds: 3338274597 number: 3]!!SMLoader commentStamp: '<historical>' prior: 28830228!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 28832242!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 28845150!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 28850838!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 28841017!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 28856889!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 28856648!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 28837324!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 28857752!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 28850564!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28851422!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 28858069!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28852607!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 28838431!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 28858774!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338274602 number: 4]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SMSqueakMap default loadUpdates; upgradeOldPackages; purge.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !"ScriptLoader"!!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48' prior: 26575366!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26575484!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04' prior: 26576048!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26576424!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39' prior: 26576701!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50' prior: 26580110!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51' prior: 26580460!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26577682!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14' prior: 17771108!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15' prior: 24466852!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49' prior: 24469260!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!SMLoader commentStamp: '<historical>' prior: 33582520!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 33582749!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := squeakMap isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(squeakMap directory directoryEntryFor: squeakMap lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 5/5/2006 02:05' prior: 33583415!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [squeakMap cache directoryForPackage: item]				ifFalse: [squeakMap cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/12/2004 01:16' prior: 33583905!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((squeakMap categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/13/2004 15:49' prior: 33584511!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (squeakMap object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 04:07' prior: 33585646!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 03:58' prior: 33586541!installedReleaseOfMe	"Return the release of the installed package loader."	^squeakMap installedReleaseOf: (squeakMap packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/10/2004 18:51' prior: 33586817!loadUpdates	[Cursor wait showWhile: [		squeakMap loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/13/2004 17:07' prior: 33587103!noteChanged	packagesList := nil.	selectedCategoryWrapper := nil.	filters ifNil: [^self reOpen].	self changed: #categoryWrapperList.	self changed: #packageWrapperList.	self changed: #packagesListIndex.	"update my selection"	self contentsChanged! !!SMLoader methodsFor: 'initialization' stamp: 'gk 5/5/2006 02:05' prior: 33587467!on: aSqueakMap 	"Initialize instance."	squeakMap := aSqueakMap.	squeakMap synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33587747!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (squeakMap object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 11/18/2003 02:24' prior: 33588552!packages	"We request the packages as sorted by name by default."	^squeakMap packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33588729!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', squeakMap packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 15:25' prior: 33588995!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				squeakMap upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 33590719!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					squeakMap upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [squeakMap upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53' prior: 24733634!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !"Compiler"!"KernelTests"!"Morphic"!"SMLoader"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.316.mcz') load.ScriptLoader new updateFrom7061.!----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:37 am) Squeak3.9-RC2-7063.image priorSource: 27317!----SNAPSHOT----an Array(14 October 2006 10:38:53 am) Squeak3.9-RC2-7063.image priorSource: 61467!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7061] on 5 October 2006 at 12:48:11 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:40:44 am) Squeak3.9-RC2-7063.image priorSource: 61564!----QUIT/NOSAVE----an Array(14 October 2006 10:41:14 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:41:44 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 10:41:52 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:58:15 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 11:03:12 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 11:03:23 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07' prior: 29509092!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08' prior: 29508560!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !installInBoxAnd39	"self new installInBoxAnd39!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12' prior: 29503230!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !"ScriptLoader"!----SNAPSHOT----an Array(14 October 2006 11:15:30 am) Squeak3.9-RC2-7063.image priorSource: 61797!----QUIT/NOSAVE----an Array(14 October 2006 11:15:37 am) Squeak3.9-RC2-7063.image priorSource: 64335!----STARTUP----an Array(15 October 2006 11:15:59 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !"ScriptLoader"!!SMLoader commentStamp: '<historical>' prior: 33602792!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 33603020!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 33603697!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 33604195!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 33604805!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 33605944!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 33606822!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 33607078!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 33607368!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 33607705!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33607993!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 33608803!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33608984!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 33609254!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 33610978!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338363798 number: 5]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.318.mcz') load.ScriptLoader new updateFrom7063.!----End fileIn of a stream----!----SNAPSHOT----an Array(15 October 2006 11:23:41 am) Squeak3.9-RC2-7063.image priorSource: 64335!----QUIT/NOSAVE----an Array(15 October 2006 11:23:46 am) Squeak3.9-RC2-7063.image priorSource: 77325!----STARTUP----an Array(15 October 2006 11:24 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!----SNAPSHOT----an Array(15 October 2006 11:24:06 am) Squeak3.9-RC2-7064.image priorSource: 77325!----QUIT/NOSAVE----an Array(15 October 2006 11:24:10 am) Squeak3.9-RC2-7064.image priorSource: 77689!----STARTUP----an Array(19 October 2006 11:47:22 pm) as /media/hdb1/Squeak3.9-RC2-7063/Squeak3.9-RC2-7064.image!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 19 October 2006 at 12:56:57 pm'!----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 19 October 2006 at 6:59:56 pm'!----End fileIn of a stream----!!Installer commentStamp: 'kph 10/16/2006 13:42' prior: 0!Installer provides a simple Domain Specific Language for installing packages from monticello and squeakmap of various version.One design decision is to be able to paste scripts a workspace and run and tested from there without any special editing.Examples - Using SqueakMap1)squeakmap := Installer squeakmap.squeakmap install: 'DynamicBindings'.squeakmap open.2)Installer squeakmap install: 'DynamicBindings'.3) squeakmap := Installer squeakmap.squeakmap package: 'DynamicBindings'; install.Examples - Using Monticello1)squeaksource := Installer repository: 'http://www.squeaksource.com'.seaside := squeaksource project: 'Seaside'.seaside install: 'Comet-lr.8';		install: 'Scriptaculous'.2) squeaksource := Installer repository: 'http://www.squeaksource.com'		squeaksource project: 'Seaside';			  install: 'Comet-lr.8;			  install: 'Scriptaculous'. !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/15/2006 07:18'!installSMP"this is in a form specifically intended to be run in a workspace for testing/debugging"| squeaksource lukas squeakmap seaside magma |squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside		install: 'Seaside2.6b1';			install: 'Scriptaculous';			install: 'Comet'.			magma :=   squeaksource project: 'MagmaTester'.	magma		install: 'MagmaServerLoader';			install: 'Magma server';			install: 'Magma client';			install: 'Magma seaside';			install: 'Magma sunit'.squeaksource project: 'Seaside';			install: 'Seaside-Examples-Store-Magma';			yourself.lukas		project: 'magritte';			install: 'Magritte-All';			project: 'pier';			install: 'Pier-All';			install: 'Pier-Model';			install: 'Pier-Seaside';			install: 'Pier-Magma';			install: 'Pier-Tests';			install: 'Pier-ScriptingAPI';			install: 'Pier-Security';			install: 'Pier-Omnibrowser';			yourself.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 06:55'!mantis^self mantis: 'http://bugs.impara.de/'! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 06:56'!mantis: host^self new ma: host; yourself! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/15/2006 06:37'!repository: host^self new mc: host; yourself! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/15/2006 06:37'!repository: host user: uName password: pWord^self new mc: host; user: uName; password: pWord; yourself! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/15/2006 06:37'!squeakmap^self new sm: true; yourself! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 13:07'!answer: aString with: anAnswer^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 13:06'!answers^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!answers: anObject	"Set the value of answers"	answers := anObject! !!Installer methodsFor: 'mantis' stamp: 'kph 10/19/2006 12:21'!bug: aBugNo^ (self maFilesFor: aBugNo) keys! !!Installer methodsFor: 'mantis' stamp: 'kph 10/19/2006 13:55'!bug: aBugNo fix: aFileName	| stream |	self logCR: 'obtaining ', aFileName, '...'.	stream := self streamFor: aBugNo file: aFileName.	self log: 'installing...'.	[		(aFileName endsWith: '.cs') ifTrue: [ stream fileIn ].		(aFileName endsWith: '.st') ifTrue: [ stream fileIn ].		(aFileName endsWith: '.mcz') ifTrue: [ MczInstaller installStream: stream ].			] valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.	self log: 'done'.! !!Installer methodsFor: 'mantis' stamp: 'kph 10/19/2006 13:55'!bug: aBugNo retrieve: aFileName	^ (self streamFor: aBugNo file: aFileName) contents! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 13:41'!installself mc ifNotNil: [ self installMC ].self sm ifTrue: [ self installSM ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/18/2006 11:29'!install: packageNameCollectionOrDetectBlockself package: packageNameCollectionOrDetectBlock.self install! !!Installer methodsFor: 'monticello' stamp: 'kph 10/18/2006 13:11'!installMC| repository sortMczs files fileToLoad  version detectFileBlock  count |self logCR: 'installing ', self package asString, '...'.self package isString ifTrue: [ detectFileBlock := [ :file | file beginsWith: self package ] ].self package isArray ifTrue: [ detectFileBlock :=  [ :file | (self package detect: [ :item | file beginsWith: item ] ifNone: [ false ]) ~= false ] ].self package isBlock ifTrue: [ detectFileBlock := self package ].  repository := MCHttpRepository location: self mcUrl user: self user password: self password.sortMczs := [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] on: Error do: [:ex | false]].	"several attempts to read files - repository readableFileNames sometimes fails"count := 0. fileToLoad := nil.	[count := count + 1. (fileToLoad = nil) and:[ count < 5 ] ] whileTrue: [	files := repository readableFileNames asSortedCollection: sortMczs.	fileToLoad := files detect: detectFileBlock ifNone: [ nil ].].	version := repository versionFromFileNamed: fileToLoad.	version workingCopy repositoryGroup addRepository: repository.	repository creationTemplate: 'MCHttpRepository        	location: ''', self mcUrl, '''        	user: ''', self user, '''        	password: ''', self password, ''''.	self log: ' ', version fileName, '...'. [ version load ] valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.self log: 'done'.! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/17/2006 14:51'!installSM | pkgAndVersion releases release |pkgAndVersion := self smPackageAndVersion.self logCR: 'installing ', self package, ' from SqueakMap...'.	releases := (SMSqueakMap default packageWithName: pkgAndVersion first) releases. 		release := pkgAndVersion last isEmpty ifTrue: [ releases last ]					ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 	[ release install ] valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.self log: ' done'.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 12:13'!log: textTranscript show: text.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 12:14'!logCR: textTranscript cr; show: text.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!ma	"Answer the value of ma"	^ ma! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!ma: aUrl 	"Set the value of host"	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/19/2006 07:46'!maFilesFor: maBugNo  "  self mantis bug: 5251."  | file files bugPage id |   files := Dictionary new.  bugPage := (self ma, 'view.php?id=', maBugNo asString) asUrl retrieveContents contentStream. [  id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<.  ((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ].  id notEmpty ] whileTrue.^files ! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!mc	"Answer the value of mc"	^ mc! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!mc: aUrl 	"Set the value of host"	mc := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'monticello' stamp: 'kph 10/15/2006 07:59'!mcRepository^MCHttpRepository location: (self mcUrl) user: self user password: self password.! !!Installer methodsFor: 'monticello' stamp: 'kph 10/15/2006 06:49'!mcUrl^ self mc, self project! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 14:30'!messagesToSuppress^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!messagesToSuppress: anObject	"Set the value of messagesToSuppress"	messagesToSuppress := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 07:59'!open	self sm ifTrue: [ SMLoader open ].self mc ifNotNil: [self mcRepository morphicOpen: nil ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package	"Answer the value of package"	^ package! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package: anObject	"Set the value of package"	package := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 08:00'!packages	self sm ifTrue: [ ^SMLoader new packages ].self mc ifNotNil: [ ^self mcRepository allFileNames ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 08:57'!packagesMatching: aMatchself sm ifTrue: [ ^ (self packages select: [ :p | aMatch match: p name ]) collect: [ :p | self copy package: p name; yourself ] ].self mc ifNotNil: [ ^ (self packages select: [ :p | ( aMatch , '.mcz' ) match: p ]) collect: [ :p | self copy package: p ; yourself ] ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:16'!password	"Answer the value of password"	^ password  ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!password: anObject	"Set the value of password"	password := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 18:39'!printOn: s s nextPutAll: '(Installer'.self sm ifTrue: [ s nextPutAll: ' squeakmap' ].self mc ifNotNil: [ s nextPutAll: ' repository:''', self mc,'''' ].s nextPut: $).self project ifNotNil: [ s nextPutAll: ' project:';  						nextPutAll: '''', self project, ''''.					   self package ifNotNil: [ s nextPutAll: '; '] ].					self package ifNotNil: [ s nextPutAll: ' package:';  						 nextPutAll: '''', self package asString, '''' ].					s nextPut: $..! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:30'!project	"Answer the value of project"	^ project! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:33'!project: anObject	"Set the value of project"	project := anObject.	^self copy.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:55'!sm	"Answer the value of sm"	^ sm ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!sm: anObject	"Set the value of sm"	sm := anObject! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/17/2006 15:24'!smPackageAndVersion| p |p := ReadStream on: self package .^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'mantis' stamp: 'kph 10/19/2006 13:55'!streamFor: aBugNo file: aFileName	| fileId  | 	fileId :=  (self maFilesFor: aBugNo) at: aFileName. 	^ (self ma, 'file_download.php?file_id=' , fileId , '&type=bug') 		asUrl retrieveContents 	contentStream  ! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 14:30'!suppress: aMessagemessagesToSuppress add: aMessage! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 15:37'!unload: workingCopyPackageName self logCR: 'Unloading ', workingCopyPackageName. (MCWorkingCopy forPackage: (MCPackage new name: workingCopyPackageName)) unload! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:15'!user	"Answer the value of user"	^ user ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!user: anObject	"Set the value of user"	user := anObject! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:18'!testAnswerFillInTheBlank| i r |i := Installer new.i answer: 'Test*' with: '1 2 3'.r := [ FillInTheBlank request: 'Testing' ] valueSupplyingAnswers: i answers.self assert: ( r = '1 2 3').! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:33'!testPrintStringself assert: (Installer new printString = '(Installer).')! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:37'!testPrintStringMCself assert: ((Installer repository: 'http://www.squeaksource.com') printString = '(Installer repository:''http://www.squeaksource.com/'').')! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:35'!testPrintStringMCprojectself assert: (((Installer repository: 'http://www.squeaksource.com') project: 'Installer') printString = '(Installer repository:''http://www.squeaksource.com/'') project:''Installer''.')! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:29'!testPrintStringSMself assert: (Installer squeakmap printString = '(Installer squeakmap).')! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 13:29'!testPrintStringSMprojectself assert: ((Installer squeakmap project:'Installer') printString = '(Installer squeakmap) project:''Installer''.')! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 14:46'!testSMPackageAndVersion | squeakmap package |squeakmap := Installer squeakmap.package := (squeakmap package: 'KomServices 1.0') smPackageAndVersion.self assert: (package first = 'KomServices'). self assert: (package last = '1.0'). ! !!InstallerTest methodsFor: 'as yet unclassified' stamp: 'kph 10/17/2006 14:46'!testSMPackageNoVersion | squeakmap package |squeakmap := Installer squeakmap.package := (squeakmap package: 'KomServices')  smPackageAndVersion.self assert: (package first = 'KomServices'). self assert: (package last = ''). ! !"Installer"!"Installed Installer auto version 1".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '87605656-e3cb-4b57-ae35-4ad4627da335' autoVersion: '1' asVersion atSeconds: 3338754648 number: 6]!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.!!BindingsLocator commentStamp: 'svp 3/5/2003 10:58' prior: 0!I am used to find the runtime environment of a given ContextPart.  If no suitable handler is found, then I will install dummy contexts at the top of the stack that include a handler that returns the default bindings for the system (ie. "DynamicBindings root").!!BindingsLocator methodsFor: 'exceptionDescription' stamp: 'svp 2/4/2003 11:26'!defaultAction	"Finds the root context for the active stack, then installs a new	handler context that will answer the context containing the root 	environment.  This method depends on the implementation of	#valueWithBindings:."	| tmp defaultActionCtx |	tmp _ thisContext.	[tmp sender notNil] whileTrue: [tmp _ tmp sender].	defaultActionCtx _ thisContext.	[			tmp swapSender: thisContext sender.		thisContext sender sender sender swapSender: nil.		thisContext swapSender: defaultActionCtx.	] valueWithBindings: DynamicBindings root.	^tmp sender sender sender! !!ContextPart methodsFor: '*DynamicBindings' stamp: 'svp 2/1/2003 01:32'!bindings	"Answers the Dynamic Bindings that are currently visible in the receiver's context.  This is kind of a hack...we could do a better job of this if we used the exception handling primitives directly, however, this implementation has the benefit of being slightly more portable."		| oldSender answer |	oldSender _ thisContext swapSender: self.	answer _ BindingsLocator signal.	thisContext swapSender: oldSender.	^answer 	! !!BindingsAccessor commentStamp: 'svp 3/5/2003 10:55' prior: 0!I enable access to the current dynamic bindings.  My class initialization adds my default instance to the system dictionary as #Bindings.  This enables access to the active runtime environment using syntax like the following:   Bindings at: #AProcessLocalVariable put: aValue   Bindings at: #AProcessLocalVariableI also allow for the creation of new DynamicBindings as follows:   Bindings new.   "Creates a new empty DynamicBindings instance"   Bindings clamp: [].  "Creates new bindings that inherit from the current bindings"!!BindingsAccessor class methodsFor: 'class initialization' stamp: 'svp 12/18/2002 14:58'!default	^Default ifNil: [Default _ self new]! !!BindingsAccessor class methodsFor: 'class initialization' stamp: 'svp 2/1/2003 01:46'!initialize	"self initialize"	Smalltalk at: #Bindings put: self default.! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!associationsDo: aBlock	^self pvtBindings associationsDo: aBlock! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!at: aSymbol	^self pvtBindings at: aSymbol! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!at: aSymbol ifAbsent: absBlock	^self pvtBindings at: aSymbol ifAbsent: absBlock! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!at: aSymbol ifAbsentPut: absBlock	^self pvtBindings at: aSymbol ifAbsentPut: absBlock value! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!at: aSymbol ifPresent: presentBlock	^self pvtBindings at: aSymbol ifPresent: presentBlock! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!at: aSymbol put: obj	^self pvtBindings at: aSymbol put: obj! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/4/2003 16:56'!bind: anObject to: anotherObject	^self pvtBindings bind: anObject to: anotherObject! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/4/2003 16:54'!bindingFor: anObject ifNotBound: absBlock	^self pvtBindings at: anObject ifAbsent: absBlock! !!BindingsAccessor methodsFor: 'environment control' stamp: 'svp 2/4/2003 13:42'!clamp: aBlock"Ensures that any environment modifications that occur during the evaluation of aBlock will happen in an isolated environment and that the original environment will be restored after evaluation completes.  Concurrent changes in the parent bindings are visible while executing aBlock."	^aBlock valueWithBindings: self pvtBindings newChild! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!do: aBlock	^self pvtBindings do: aBlock! !!BindingsAccessor methodsFor: 'environment accessing' stamp: 'svp 2/4/2003 13:48'!explore	"This is just a handy way to allow you to directly explore the 	global symbol 'Bindings'"	self get explore! !!BindingsAccessor methodsFor: 'environment accessing' stamp: 'svp 2/1/2003 02:31'!get	^self pvtBindings! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!includesKey: anObject	^self pvtBindings includesKey: anObject! !!BindingsAccessor methodsFor: 'environment accessing' stamp: 'svp 2/4/2003 13:49'!inspect	"This is just a handy way to allow you to directly inspect the 	global symbol 'Bindings'"	self get inspect! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/4/2003 16:57'!isBound: anObject	^self pvtBindings isBound: anObject! !!BindingsAccessor methodsFor: 'environment control' stamp: 'svp 5/6/2003 10:49'!isolate	"Isolates the bindings of the active context such that changes to the 	active bindings are not visible anywhere except that portion of the active	stack for which the active bindings are assigned."	| ctx |	ctx := self pvtContext.	ctx tempAt: 1 put: (ctx tempAt: 1) copy.! !!BindingsAccessor methodsFor: 'environment control' stamp: 'svp 2/4/2003 13:42'!isolate: aBlock"Ensures that any environment modifications that occur during the evaluation of aBlock will happen in an isolated environment and that the original environment will be restored after evaluation completes.  Concurrent changes in the parent bindings are visible while executing aBlock."	^aBlock valueWithBindings: self pvtBindings copy! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:31'!keys	^self pvtBindings keys! !!BindingsAccessor methodsFor: 'environment creation' stamp: 'svp 2/1/2003 02:04'!new	"Creates a new runtime environment that is empty."	^DynamicBindings new.! !!BindingsAccessor methodsFor: 'environment creation' stamp: 'svp 7/31/2002 10:46'!newChild	"Creates a new runtime environment that inherits from the current environment."	^self get newChild! !!BindingsAccessor methodsFor: 'environment accessing' stamp: 'svp 2/4/2003 13:49'!parent	^self get parent! !!BindingsAccessor methodsFor: 'private' stamp: 'svp 2/1/2003 02:30'!pvtBindings	^self pvtContext tempAt: 1! !!BindingsAccessor methodsFor: 'private' stamp: 'svp 2/1/2003 01:33'!pvtContext	^BindingsLocator signal! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:32'!removeKey: aSymbol	^self pvtBindings removeKey: aSymbol! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/4/2003 16:19'!removeKey: aSymbol ifAbsent: absBlock	^self pvtBindings removeKey: aSymbol ifAbsent: absBlock! !!BindingsAccessor methodsFor: 'environment accessing' stamp: 'svp 7/31/2002 10:46'!root	^self get root! !!BindingsAccessor methodsFor: 'variable accessing' stamp: 'svp 2/1/2003 02:32'!values	^self pvtBindings values! !!Object methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:08'!binding	"Answer the DynamicBinding for the receiver (if any)"	^Bindings bindingFor: self ifNotBound: [nil]! !!Object methodsFor: '*DynamicBindings' stamp: 'svp 4/29/2003 00:35'!binding: anObject	"Set the dynamic binding for the receiver, if anObject is nil, then 	remove the receiver's dynamic binding (if any)"	^anObject 		ifNil: [self removeBinding]		ifNotNil: [Bindings bind: self to: anObject]! !!Object methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:09'!hasBinding	"Answer whether or not the receiver has a dynamic binding"	^Bindings includesKey: self! !!Object methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:09'!removeBinding	"Remove the dynamic binding associated with the receiver"	^Bindings removeKey: self ifAbsent: []! !!DynamicBindingsInfo commentStamp: 'svp 5/6/2003 11:13' prior: 0!DynamicBindings for Squeakby Stephen Pair <stephen@pairhome.net> ===== Introduction =====You may create a hierarchy of DynamicBindings and directly manipulate the keys and values of those instances (just as you would any dictionary).  There is a root DynamicBindings that you may use to create new children if you like (but you can also create entirely separate hierarchies).  You can access this root with "DynamicBindings root".  To force a process to use one of your sets of DynamicBindings, you write code as follows (note, I only use 'PATH' to highlight the similarity with normal OS environment variables):	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: '/bin:/usr/bin'.	myBindings bindDuring: 		[Bindings at: #PATH.  				"-> '/bin:/usr/bin'"		Bindings at: #PATH put: ('/usr/local/bin:', (Bindings at: #PATH)).		Bindings at: #PATH].  				"-> '/usr/local/bin:/bin:/usr/bin'"For convenience, two methods have been added to Object that enable more direct access to bindings.  The following exampel is equivalent to the first:	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: '/bin:/usr/bin'.	myBindings bindDuring: 		[#PATH binding.  				"-> '/bin:/usr/bin'"		#PATH binding: ('/usr/local/bin:', (#PATH binding)).		#PATH binding].  				"-> '/usr/local/bin:/bin:/usr/bin'"The first line creates a new set of bindings that is a child of the root bindings.  Any variables set in the root bindings are also visible in this new child environment.The second line sets the dynamic variable "PATH".The third line uses the evaluates the argument block in the context of our new set of bindings.The fourth line gets the value for the variable "PATH" (which we just set).The fifth line in the above example modifies the environment variable "PATH", but only for the duration that the enclosing block is active.Here is another example:	#PATH binding: '/bin'.	Bindings clamp:		[#PATH binding: '/usr/bin'.		#PATH binding]. 						"-> '/usr/bin'"	#PATH binding.								"-> '/bin'"This example shows the use of the #clamp: method to isolate a our dynamic bindings only for the duration of a block.  After the block finishes execution, the original set of bindings is restored.Scoping semantics:A dynamic variables' scope is defined at runtime by an enclosing activation context.  To locate the active lexicon of dynamic variables, the system follows the activation stack until a context is encountered that defines the active DynamicBindings (this lookup is implemented using the exception handling system).  Any changes to the active DynamicBindings are visible in all activation contexts where that set of DynamicBindings are being used (which may include contexts in more than one activation stack).A bit about how it's implemented:The bindings for a given method activation context are located using the exception handling mechanism (see BindingsLocator).  If a given stack does not have a handler that answers a set of bindings, then dummy contexts will be added to the top of the stack that will answer the global root set of bindings.Unlike other implementations, DynamicBindings do not use the activation stack to define the hierarchy of bindings.  Instances of DynamicBindings have their own parent instance variable and will locate enclosing variable scopes by following the chain of parents (*not* by looking for enclosing handlers of BindingsLocator).  Using this design, we are able to accomodate a broader range of usage scenarios.If you need to isolate the bindings of a given context stack such that future changes in the bindings are not visible to users of the current set of dynamic bindings (ie. if you use continuations), you can send the message #isolate to the BindingsAccessor (ie. use "Bindings isolate").===== Release History =====Version 1.1:	- Packaged using KomPackaging (Squeak version only)	- Made Object>>binding: answer its argument	- Cleaned up a few obsolete methods from the old RuntimeEnvironments implementationVersion 1.0:	- Initial release!!DynamicBindingsInfo methodsFor: 'as yet unclassified' stamp: 'svp 5/9/2003 17:30'!preambleText	"Executed first to load the package"	^'"' , self packageName , '"', String cr, 'Smalltalk at: #Bindings put: nil'! !!DynamicBindingsInfo methodsFor: 'as yet unclassified' stamp: 'svp 5/7/2003 10:18'!releaseName	^'1.1'! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:10'!forkWithBindings	"Create and schedule a new process that has the same 	dynamic bindings as the active process"	^self newProcessWithBindings resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:11'!forkWithBindings: dynamicBindings	"Create and schedule a new process with the given dynamic bindings"	^(self newProcessWithBindings: dynamicBindings) resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 2/4/2003 15:13'!forkWithClampedBindings	^self newProcessWithClampedBindings resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 2/4/2003 15:13'!forkWithClampedBindings: dynamicBindings	^(self newProcessWithClampedBindings: dynamicBindings) resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 2/4/2003 11:52'!forkWithIsolatedBindings	^self newProcessWithIsolatedBindings resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 2/4/2003 11:51'!forkWithIsolatedBindings: dynamicBindings	^(self newProcessWithIsolatedBindings: dynamicBindings) resume! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:10'!newProcessWithBindings	"Create a new process that has the same dynamic bindings	as the active process"	^self newProcessWithBindings: Bindings get! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:11'!newProcessWithBindings: dynamicBindings	"Create a new process with the given dynamic bindings"	^[self valueWithBindings: dynamicBindings] newProcess! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:18'!newProcessWithClampedBindings	"Create a new process with a nested set of the dynamicBindings of 	the active process"	^self newProcessWithClampedBindings: Bindings get! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:16'!newProcessWithClampedBindings: dynamicBindings	"Create a new process with a nested set of the given dynamicBindings"	^[Bindings clamp: self] newProcessWithBindings: dynamicBindings! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:15'!newProcessWithIsolatedBindings	"Create a new process with a copy of the dynamicBindings of the 	acitve process"	^self newProcessWithIsolatedBindings: Bindings get! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 3/6/2003 16:14'!newProcessWithIsolatedBindings: dynamicBindings	"Create a new process with a copy of the given dynamicBindings"	^[Bindings isolate: self] newProcessWithBindings: dynamicBindings! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 5/7/2003 02:37'!valueWithBindings: dynamicBindings	"Evaluate the receiver in the context of the given dynamicBindings"	^self valueWithBindingsContext: thisContext! !!BlockContext methodsFor: '*DynamicBindings' stamp: 'svp 5/7/2003 02:37'!valueWithBindingsContext: aContext	"Private. Evaluate the receiver in the context of the 	given dynamicBindings context"	^self		on: BindingsLocator		do: [ :n | n resume: aContext]! !!DynamicBindings commentStamp: 'svp 5/7/2003 10:36' prior: 0!DynamicBindings for Squeakby Stephen Pair <spair@pairhome.net>I am a dictionary with an added property that I can inherit associations from other instances (via the parent inst var).  I am intended to be used as a set of variable bindings that can be local to a process or shared among a group of processes.  I am an abstract class and should never be instantiated.  Here's how DynamicBindings work:You may create a hierarchy of DynamicBindings and directly manipulate the keys and values of those instances (just as you would any dictionary).  There is a root DynamicBindings that you may use to create new children if you like (but you can also create entirely separate hierarchies).  You can access this root with "DynamicBindings root".  To force a process to use one of your sets of DynamicBindings, you write code as follows (note, I only use 'PATH' to highlight the similarity with normal OS environment variables):	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: '/bin:/usr/bin'.	myBindings bindDuring: 		[Bindings at: #PATH.  				"-> '/bin:/usr/bin'"		Bindings at: #PATH put: ('/usr/local/bin:', (Bindings at: #PATH)).		Bindings at: #PATH].  				"-> '/usr/local/bin:/bin:/usr/bin'"For convenience, two methods have been added to Object that enable more direct access to bindings.  The following exampel is equivalent to the first:	myBindings _ DynamicBindings root newChild.	myBindings at: #PATH put: '/bin:/usr/bin'.	myBindings bindDuring: 		[#PATH binding.  				"-> '/bin:/usr/bin'"		#PATH binding: ('/usr/local/bin:', (#PATH binding)).		#PATH binding].  				"-> '/usr/local/bin:/bin:/usr/bin'"The first line creates a new set of bindings that is a child of the root bindings.  Any variables set in the root bindings are also visible in this new child environment.The second line sets the dynamic variable "PATH".The third line uses the evaluates the argument block in the context of our new set of bindings.The fourth line gets the value for the variable "PATH" (which we just set).The fifth line in the above example modifies the environment variable "PATH", but only for the duration that the enclosing block is active.Here is another example:	#PATH binding: '/bin'.	Bindings clamp:		[#PATH binding: '/usr/bin'.		#PATH binding]. 						"-> '/usr/bin'"	#PATH binding.								"-> '/bin'"This example shows the use of the #clamp: method to isolate a our dynamic bindings only for the duration of a block.  After the block finishes execution, the original set of bindings is restored.Scoping semantics:A dynamic variables' scope is defined at runtime by an enclosing activation context.  To locate the active lexicon of dynamic variables, the system follows the activation stack until a context is encountered that defines the active DynamicBindings (this lookup is implemented using the exception handling system).  Any changes to the active DynamicBindings are visible in all activation contexts where that set of DynamicBindings are being used (which may include contexts in more than one activation stack).A bit about how it's implemented:The bindings for a given method activation context are located using the exception handling mechanism (see BindingsLocator).  If a given stack does not have a handler that answers a set of bindings, then dummy contexts will be added to the top of the stack that will answer the global root set of bindings.Unlike other implementations, DynamicBindings do not use the activation stack to define the hierarchy of bindings.  Instances of DynamicBindings have their own parent instance variable and will locate enclosing variable scopes by following the chain of parents (*not* by looking for enclosing handlers of BindingsLocator).  Using this design, we are able to accomodate a broader range of usage scenarios.If you need to isolate the bindings of a given context stack such that future changes in the bindings are not visible to users of the current set of dynamic bindings (ie. if you use continuations), you can send the message #isolate to the BindingsAccessor (ie. use "Bindings isolate").!!DynamicBindings class methodsFor: 'class initialization' stamp: 'gk 4/27/2006 10:34'!clear	"self clear"	Root := DynamicBindings new! !!DynamicBindings class methodsFor: 'accessing' stamp: 'svp 2/4/2003 16:04'!example	" DynamicBindings example "	| sem1 sem2 proc1 proc2 |	sem1 := Semaphore new.	sem2 := Semaphore new.	proc1 := [		Bindings clamp: [			#Test binding: 'Test #1'.			"Wait here to demonstrate that we indeed have two			different sets of bindings with two different 			and concurrent values for #Test."			sem1 wait.			Transcript show: ('Proc1: ', #Test binding); cr.		].	] newProcess.	proc2 := [		Bindings clamp: [			#Test binding: 'Test #2'.			"Wait here to demonstrate that we indeed have two			different sets of bindings with two different 			and concurrent values for #Test."			sem2 wait.			Transcript show: ('Proc2: ', #Test binding); cr.		]	] newProcess.	proc1 resume.	proc2 resume.	sem1 signal.	sem2 signal.! !!DynamicBindings class methodsFor: 'class initialization' stamp: 'svp 2/4/2003 14:16'!initialize	"self initialize"	Root 		ifNil: [Root _ DynamicBindings new]		ifNotNil: [Root _ DynamicBindings newFrom: Root].! !!DynamicBindings class methodsFor: 'instance creation' stamp: 'svp 12/18/2002 15:34'!newFrom: anotherRuntimeEnvironment	| answer |	answer _ self new.	anotherRuntimeEnvironment associationsDo: [ :assn | answer add: assn].	^answer! !!DynamicBindings class methodsFor: 'accessing' stamp: 'svp 12/18/2002 14:48'!root	^Root! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 8/8/2002 09:20'!at: key ifAbsent: aBlock	| assoc tmp |	tmp := self.	[(assoc _ tmp array at: (tmp findElementOrNil: key)) == nil] 		whileTrue: [(tmp := tmp parent) ifNil: [^aBlock value]].	^assoc value! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 8/8/2002 09:21'!atThisLevel: key ifAbsent: aBlock	^super at: key ifAbsent: aBlock! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 2/6/2003 22:41'!bind: anObject to: anotherObject	^self at: anObject put: anotherObject! !!DynamicBindings methodsFor: 'scheduling' stamp: 'svp 2/4/2003 16:43'!bindDuring: aBlock	^aBlock valueWithBindings: self! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 2/4/2003 16:53'!bindingFor: anObject	^self at: anObject ifAbsent: [self error: 'binding not found']! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 3/6/2003 14:35'!bindingFor: anObject ifNotBound: aBlock	^self at: anObject ifAbsent: aBlock! !!DynamicBindings methodsFor: 'scheduling' stamp: 'svp 2/4/2003 16:23'!fork: aBlock	^aBlock forkWithBindings: self! !!DynamicBindings methodsFor: 'scheduling' stamp: 'svp 2/4/2003 16:24'!forkClamped: aBlock	^aBlock forkWithClampedBindings: self! !!DynamicBindings methodsFor: 'scheduling' stamp: 'svp 2/4/2003 16:23'!forkIsolated: aBlock	^aBlock forkWithIsolatedBindings: self! !!DynamicBindings methodsFor: 'scheduling' stamp: 'svp 2/4/2003 16:57'!isBound: anObject	^self includesKey: anObject! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 8/8/2002 09:23'!level	| tmp level |	tmp := self.	level := 0.	[tmp == nil] whileFalse:		[tmp := tmp parent.		level := level + 1].	^level! !!DynamicBindings methodsFor: 'isolation' stamp: 'svp 2/4/2003 13:36'!newChild	^self species new		parent: self;		yourself! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 8/8/2002 09:19'!parent	^parent! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 5/6/2003 10:43'!parent: aDynamicBindings	parent := aDynamicBindings! !!DynamicBindings methodsFor: 'accessing' stamp: 'svp 5/6/2003 10:44'!root	| tmp |	tmp := self.	[tmp parent notNil] whileTrue:		[tmp := tmp parent].	^tmp! !!DynamicBindingTests commentStamp: 'svp 3/5/2003 10:58' prior: 0!I test the DynamicBindings subsystem.!!DynamicBindingTests methodsFor: 'as yet unclassified' stamp: 'svp 5/6/2003 11:27'!testAccessor1	| val test1 |	Bindings clamp:		[#test binding: (val := 'Test Value').		test1 := (#test binding == val).		#test removeBinding].	self assert: test1.! !!DynamicBindingTests methodsFor: 'as yet unclassified' stamp: 'svp 5/6/2003 11:28'!testAccessor2	| val test1 test2 |	Bindings clamp:		[#test binding: (val _ 'Test Value').		test1 := (#test binding == val).		#test removeBinding.		test2 := ((Bindings at: #test ifAbsent: [ 'absent' ]) = 'absent')].	self assert: test1.	self assert: test2.! !!DynamicBindingTests methodsFor: 'as yet unclassified' stamp: 'svp 5/6/2003 11:28'!testFork	"In this test, we examine the isolation behavior when forking a process.  We are	checking to ensure that changes made to the environment in the forked process do	not impact the calling process.  We also check to make sure that the forked process	gets the current environment from the calling process at the time of the fork."	| sem test1 test2 test3 |	Bindings clamp:		[#test binding: 'Testing'.		sem := Semaphore new.			[#test2 binding: 'Testing2'.			test1 := (#test binding = 'Testing').			test2 := (#test2 binding = 'Testing2').			#test binding: 'Testing3'.			test3 := #test binding = 'Testing3'.			sem signal] forkWithIsolatedBindings.		sem wait.		self assert: test1.		self assert: test2.		self assert: test3.		self assert: (#test binding = 'Testing').		self assert: (#test2 hasBinding not)].	self assert: (#test hasBinding not).	self assert: (#test2 hasBinding not).! !!DynamicBindingTests methodsFor: 'as yet unclassified' stamp: 'svp 5/6/2003 11:29'!testSharedRuntimeEnvironment	"In this test, we examine the isolation behavior when forking processes and when those	processes share a runtime environment.  We are checking to ensure that both forked	processes see the changes made to the shared runtime environment even when their	own environments are isoldated from each other by a modification."	| test1 test2 test3 bindings sem1 sem2 isolateSem1 isolateSem2 modSem1 modSem2 test4 |	bindings := DynamicBindings root newChild.	bindings at: #sharedVar put: 'Shared Value'.	sem1 := Semaphore new.	sem2 := Semaphore new.	isolateSem1 := Semaphore new.	isolateSem2 := Semaphore new.	modSem1 := Semaphore new.	modSem2 := Semaphore new.	bindings forkClamped: 		[test1 := #sharedVar binding = 'Shared Value'.		#forceIsolation binding: 'testing'.		isolateSem1 signal.		modSem1 wait.		test2 := #sharedVar binding = 'Shared Value 2'.		sem1 signal].	bindings forkClamped:		[test3 := #sharedVar binding = 'Shared Value'.		#forceIsolation binding: 'testing'.		isolateSem2 signal.		modSem2 wait.		test4 := #sharedVar binding = 'Shared Value 2'.		sem2 signal].	isolateSem1 wait.	isolateSem2 wait.	bindings at: #sharedVar put: 'Shared Value 2'.	modSem1 signal.	modSem2 signal.	sem1 wait.	sem2 wait.	self assert: test1.	self assert: test2.	self assert: test3.	self assert: test4.! !"DynamicBindings"!"Installed DynamicBindings auto version 3".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '9f2cdda3-c666-459c-ba5e-55a91b428f40' autoVersion: '3' asVersion atSeconds: 3338754687 number: 7]!!Process class methodsFor: '*KomServices' stamp: 'svp 5/6/2003 13:44'!termMethod	^Process class methodDictionary at: #terminationOkDuring:! !!Process class methodsFor: '*KomServices' stamp: 'svp 4/25/2003 18:03'!terminationOkDuring: aBlock	^aBlock value! !!Process methodsFor: '*KomServices' stamp: 'svp 4/25/2003 18:05'!okToTerminate	self suspendedContext ifNotNilDo: 		[ :suspendedCtx |		suspendedCtx stackDo: 			[ :ctx |			ctx method == self class termMethod				ifTrue: [^true]]].	^false! !!ContextPart methodsFor: '*KomServices' stamp: 'svp 5/6/2003 13:42'!stackDo: aBlock	"Iterates the sender chain, evaluating aBlock for each context"	| thisCtx |	thisCtx := self.	[thisCtx notNil] whileTrue:		[aBlock value: thisCtx.		thisCtx := thisCtx sender]! !!ApplicationService commentStamp: '<historical>' prior: 0!I am an abstract superclass.  Subclass me to create your own service classes whose instances can be started and stopped.  Subclasses should override the #runWhile: method to do something useful. An instance of an ApplicationService will have a Process associated with it while it is running.  If you have the "Named Process" package loaded (available on SqueakMap), then processes associated with a ApplicationService will be named like their service name for easier process debugging.A ApplicationService can be in one of three states that are determined by the process and condiction instance variables:	running: condition == #run & process notNil	stopping: condition ~~ #run & process notNil 	stopped: process isNilInstance Variables:name <String | nil> - An optional name for the given serviceprocess <Process | nil> - The Process instance for a running service condition <#run | #stop> - Indicates whether the associated process should continue to run or whether it should stop runningdynamicBindings <DynamicBindings | nil> - A set of dynamic bindings that are active for the associated process; if used instead of global variables, then multiple services can run simultaneously a be bound to different sets of "globals"; see the class comments for DynamicBindings for more detailspriority <Number> - The priority at which the associated process will runlog - not yet implemented!!ApplicationService class methodsFor: 'registration' stamp: 'gc 7/8/2005 09:26'!addService: aService	self allServices add: aService! !!ApplicationService class methodsFor: 'accessing' stamp: 'gk 12/6/2005 23:06'!allServices	"Return all registered services.	Do not override this methid, override services instead."	^Services! !!ApplicationService class methodsFor: 'accessing' stamp: 'svp 9/19/2003 00:55'!defaultPriority	^Processor userBackgroundPriority! !!ApplicationService class methodsFor: 'initialization' stamp: 'svp 1/17/2003 16:02'!initialize	"self initialize"	Services _ Set new.	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self! !!ApplicationService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 16:10'!newNamed: aString	^self new name: aString; yourself! !!ApplicationService class methodsFor: 'registration' stamp: 'gc 7/8/2005 09:27'!removeService: aService	self allServices remove: aService ifAbsent: []! !!ApplicationService class methodsFor: 'accessing' stamp: 'gc 7/8/2005 09:10'!serviceNamed: aString	^self services 		serviceNamed: aString		ifAbsent: [self error: 'No service by that name']! !!ApplicationService class methodsFor: 'accessing' stamp: 'gc 7/8/2005 09:09'!serviceNamed: aString ifAbsent: aBlock	^self services 		detect: [ :ea | ea name = aString ] 		ifNone: aBlock! !!ApplicationService class methodsFor: 'accessing' stamp: 'gk 12/6/2005 23:07'!services	"Return all registered services. Override this method	in subclasses to provide specialized or partial lists	of services."	^ self allServices! !!ApplicationService class methodsFor: 'accessing' stamp: 'svp 1/17/2003 16:05'!servicesNamed: aString	^self services select: [ :ea | ea name = aString ]! !!ApplicationService class methodsFor: 'snapshots' stamp: 'svp 1/20/2003 22:43'!shutDown	self services do: 		[ :ea | ea prepareForShutdown]! !!ApplicationService class methodsFor: 'private' stamp: 'brp 10/14/2004 22:16'!sleepMethod	"This method is used to detect whether or not the 	service is currently sleeping"	^ self methodDict at: #sleepFor:! !!ApplicationService class methodsFor: 'snapshots' stamp: 'svp 1/17/2003 16:10'!startUp	self services do: 		[ :ea | ea prepareForStartup].! !!ApplicationService methodsFor: 'private' stamp: 'svp 4/26/2003 01:19'!addStopSignal	stopSignal ifNil: [stopSignal _ OrderedCollection new].	^stopSignal add: Semaphore new.! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 5/7/2003 04:53'!bindings	^bindings! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 5/7/2003 04:56'!bindings: aDynamicBindings	bindings := aDynamicBindings! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'svp 5/6/2003 13:08'!cancelStopRequest	"If the service is currently in a state of stopping, this method	will return the service to a state of running"	self releaseProcessesWaitingForStop.	stopSignal := nil.! !!ApplicationService methodsFor: 'private' stamp: 'brp 10/2/2004 15:29'!checkRequiredBindings	| missingBindings |	missingBindings := self requiredBindings reject: [ :ea | self bindings includesKey: ea ].	missingBindings notEmpty 		ifTrue: 			[self error: 'service is missing one or more required bindings'.			^false].	^true! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 5/6/2003 12:57'!defaultName	| title |	title := self class name.	^(title first isVowel ifTrue: ['an '] ifFalse: ['a ']), title! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 2/26/2003 10:32'!defaultPriority	^self class defaultPriority! !!ApplicationService methodsFor: 'initialize-release' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.	self register.	self initializeBindings! !!ApplicationService methodsFor: 'initialize-release' stamp: 'svp 5/7/2003 04:54'!initializeBindings	"Subclasses may wish to establish an isolated set of dynamic	bindings by overriding this method.  A subclass may also want	to go ahead and set some dynamic variables.  For example:		dynamicBindings := DynamicBindings root newChild.		dynamicBindings at: #example put: 'a value'.	In this example, the service is assigned a new set of dynamic bindings	that inherits the bindings of root set of bindings and the variable #example	is assigned a value. Code that is running in the context of this service can	then access this variable using the expressions:		#example binding		#example binding: aNewValue	"	bindings := DynamicBindings root newChild.! !!ApplicationService methodsFor: 'queries' stamp: 'svp 4/26/2003 01:50'!isRunning	^process notNil and: [stopSignal isNil]! !!ApplicationService methodsFor: 'queries' stamp: 'svp 4/24/2003 10:49'!isSleeping	process ifNil: [^false].	process suspendedContext ifNotNilDo: 		[ :suspendedCtx |		suspendedCtx stackDo: 			[ :ctx |			ctx method == self class sleepMethod				ifTrue: [^true]]].	^false! !!ApplicationService methodsFor: 'queries' stamp: 'svp 4/25/2003 16:12'!isStopped	^process isNil! !!ApplicationService methodsFor: 'queries' stamp: 'svp 4/26/2003 01:50'!isStopping	^process notNil and: [stopSignal notNil]! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'svp 4/26/2003 01:47'!kill	"Forcibly kill the service regardless of whether it is in a state where it is 	safe to do so.  Use stop unless the service is not responding."	process ifNotNil: [process terminate].	self processTerminated.! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 1/17/2003 16:30'!name	^name ifNil: [self defaultName]! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 5/6/2003 12:57'!name: aString	name := aString.	process ifNotNil: [process name: aString].! !!ApplicationService methodsFor: 'startup and shutdown' stamp: 'svp 5/6/2003 13:37'!prepareForShutdown	"The system is about to shutdown"! !!ApplicationService methodsFor: 'startup and shutdown' stamp: 'svp 5/6/2003 13:37'!prepareForStartup	"The system just started up"! !!ApplicationService methodsFor: 'printing' stamp: 'svp 4/25/2003 16:13'!printOn: aStream	aStream nextPutAll: self name.	self isRunning ifTrue: [aStream nextPutAll: ' [running]'].	self isStopping ifTrue: [aStream nextPutAll: ' [stopping]'].	self isStopped ifTrue: [aStream nextPutAll: ' [stopped]']! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 1/17/2003 22:29'!priority	^priority ifNil: [self defaultPriority]! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 5/6/2003 12:58'!priority: aNumber	priority := aNumber.	process ifNotNil: [process priority: aNumber].! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 1/17/2003 13:49'!process	^process! !!ApplicationService methodsFor: 'private' stamp: 'svp 5/6/2003 13:38'!processTerminated	"Private.  Nils out the process inst var (indication that the service is	stopped and signals any processes that are waiting on the service to 	stop."	process := nil.	self releaseProcessesWaitingForStop.! !!ApplicationService methodsFor: 'registration' stamp: 'svp 1/17/2003 16:06'!register	self class addService: self! !!ApplicationService methodsFor: 'private' stamp: 'svp 5/6/2003 13:39'!releaseProcessesWaitingForStop	"Private.  Signals any processes that are waiting on the service to stop."	| tmp |	stopSignal ifNotNil: 		[tmp := stopSignal.		stopSignal := nil.		tmp do: [ :ea | ea signal]].! !!ApplicationService methodsFor: 'accessing' stamp: 'svp 3/6/2003 17:49'!requiredBindings	"Subclasses may wish to override this method to provide a list of objects 	that the service requires to be registered in its dynamic bindings.  When	attempting to start a service that has required bindings, if any of the 	required bindings are missing, an exception will be signaled and the	service will not start."	^#()! !!ApplicationService methodsFor: 'running' stamp: 'brp 10/14/2004 22:22'!runWhile: aBlock	"subclasses should perform whatever service they provide	in a loop that doesn't return until aBlock evaluates to true"	"In this abstract class, we do nothing except wait on a 	timer.  This is useful during development where we might	want to create some do nothing services for testing purposes."	"The two examples below illustrate the difference in using	the #sleepFor: method and directly using a Delay.  If you 	use the #sleepFor: method, then stopping the service will	happen immediately while the service is sleeping; if you	just use a Delay directly, then graceful shutdown cannot	happen until after the delay completes.  To test this behavior	start a service using Service newNamed: 'sleep test' 	and then use the Star Browser interface to start and stop the service	(note: you can allow graceful termination during any block of 	code using Process class>>terminationOkDuring:)."	[aBlock value] whileTrue: [self sleepFor: 1000]	"[aBlock value] whileTrue: [(Delay forSeconds: 10) wait]"! !!ApplicationService methodsFor: 'utility' stamp: 'svp 4/25/2003 18:09'!sleepFor: milliseconds	"If your service sleeps, use this method as it will indicate that it is	safe to immediately terminate the process while it is sleeping."	Process terminationOkDuring:		[(Delay forMilliseconds: milliseconds) wait].! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'brp 10/2/2004 16:07'!start	self verifyOkToStart ifFalse: [^self].	process := 			[			[self 				runWhile: [stopSignal isNil and: [process == Processor activeProcess]]] 					ensure: [self processTerminated]] 					newProcessWithBindings: self bindings.	process 		name: self name;		priority: self priority;		resume! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'svp 5/6/2003 13:09'!stop	"Gracefully request the service to stop.  This method returns immediately.  If	you wish to wait until the service has stopped, follow this method with #waitForStop	or #waitForStopUntil:."	stopSignal := OrderedCollection new.	process ifNotNil: [process okToTerminate ifTrue: [process terminate]].	process ifNil: [stopSignal := nil].! !!ApplicationService methodsFor: 'private' stamp: 'svp 4/25/2003 17:29'!stopSignal	"<Semaphore | nil> Indicates whether the associated process should 	be in the process of shutting down.  The semaphore will be signaled	for all waiting process when the service thinks it has stopped (note,	you should not rely solely on the semaphore signal to determine that	the service is actually stopped, instead, wait then ask the service	#isStopped)."	^stopSignal! !!ApplicationService methodsFor: 'registration' stamp: 'svp 1/17/2003 16:07'!unregister	self stop.	self class removeService: self! !!ApplicationService methodsFor: 'private' stamp: 'brp 10/2/2004 15:31'!verifyOkToStart	self isRunning ifTrue: [^false].	self isStopping 		ifTrue: 			[self error: 'Service is in the process of stopping'.			^false].	^ self checkRequiredBindings! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'svp 4/26/2003 01:45'!waitForStop	"Wait until the service is stopped"	self isStopped ifTrue: [^self].	self isStopping 		ifFalse: [^self error: 'service is not in the process of stopping'].	[self isStopping] whileTrue: [self addStopSignal wait]! !!ApplicationService methodsFor: 'starting and stopping' stamp: 'svp 4/26/2003 01:46'!waitForStopUntil: deadline 	"Wait until the service is stopped or the deadline is reached"	self isStopped ifTrue: [^self].	self isStopping 		ifFalse: [^self error: 'service is not in the process of stopping'].	[self isStopping and: [Time millisecondClockValue < deadline]] whileTrue:		[self addStopSignal waitTimeoutMSecs: deadline - Time millisecondClockValue]! !!ApplicationService methodsFor: 'utility' stamp: 'svp 5/7/2003 04:55'!withBindingsDo: aBlock	^aBlock valueWithBindings: self bindings! !!TcpService commentStamp: 'svp 3/5/2003 10:18' prior: 0!I am a comanche service that listens for inbound TCP connectinos on a given port.Instance Variables:	portNumber - the TCP port number on which to listen for inbound connectionsUsage:Subclasses should override the #serve: method to process incoming TCP connections (a connected socket is passed as the sole argument to this method).  Starting and stopping instances of this class will start and stop listening on the given port number.!!TcpService class methodsFor: 'class initialization' stamp: 'svp 5/6/2003 14:51'!initialize	"self initialize"	PortAssignments := Dictionary new.! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/21/2003 12:03'!on: portNumber	^self 		on: portNumber		priority: self defaultPriority ! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 16:25'!on: portNumber named: aString	^self 		on: portNumber		named: aString		priority: self defaultPriority ! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 16:26'!on: portNumber named: aString priority: priorityNum	^self new		name: aString;		portNumber: portNumber;		priority: priorityNum;		yourself! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/21/2003 12:03'!on: portNumber priority: priorityNum	^self new		portNumber: portNumber;		priority: priorityNum;		yourself! !!TcpService class methodsFor: 'accessing' stamp: 'gc 7/8/2005 09:45'!serviceOnPort: portNumber	^ self serviceOnPort: portNumber		ifAbsent: [self error: 'No service on that port']! !!TcpService class methodsFor: 'accessing' stamp: 'gc 7/8/2005 09:45'!serviceOnPort: portNumber ifAbsent: aBlock	^ self services		detect: [:service | service portNumber = portNumber]		ifNone: aBlock! !!TcpService class methodsFor: 'accessing' stamp: 'gk 12/6/2005 23:07'!services	"Return all registered TcpServices."	^ super services select: [:service | service isKindOf: TcpService]! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 14:16'!startOn: portNumber	^(self on: portNumber) start; yourself! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 14:20'!startOn: portNumber named: aString	^(self on: portNumber named: aString) start; yourself! !!TcpService class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 14:20'!startOn: portNumber named: aString priority: aPriority	^(self on: portNumber named: aString priority: aPriority) start; yourself! !!TcpService methodsFor: 'running' stamp: 'svp 1/21/2003 14:37'!assignPort	self verifyPortAvailability: self portNumber.	PortAssignments at: self portNumber put: self.! !!TcpService methodsFor: 'initialization' stamp: 'svp 5/6/2003 14:54'!initializeOnPort: portNum priority: priorityLevel	portNumber := portNum.	priority := priorityLevel.! !!TcpService methodsFor: 'accessing' stamp: 'svp 1/17/2003 16:14'!portNumber	^portNumber! !!TcpService methodsFor: 'accessing' stamp: 'svp 5/6/2003 14:53'!portNumber: aNumber	self isRunning 		ifTrue: 			[self verifyPortAvailability: aNumber.			self stop.			portNumber := aNumber.			self start.]		ifFalse: 			[portNumber := aNumber].! !!TcpService methodsFor: 'startup and shutdown' stamp: 'svp 1/17/2003 16:31'!prepareForStartup	"The squeak system just started up"	Socket initializeNetwork.! !!TcpService methodsFor: 'printing' stamp: 'bolot 1/11/2001 15:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' port: ', self portNumber asString! !!TcpService methodsFor: 'running' stamp: 'svp 5/2/2003 23:15'!runWhile: aBlock	[(TcpListener on: self portNumber handler: self)		listenWhile: aBlock] ensure: [self unassignPort]! !!TcpService methodsFor: 'conversation' stamp: 'svp 8/20/2003 00:30'!serve: aSocket	"Subclasses should override this method to provide socket based 	communications services.  Each new socket connection is handed to	this method."	self subclassResponsibility! !!TcpService methodsFor: 'starting and stopping' stamp: 'svp 4/25/2003 16:27'!start	self verifyOkToStart ifFalse: [^self].	self assignPort.	[super start] on: Error do: 		[ :ex | self unassignPort. ex pass]! !!TcpService methodsFor: 'starting and stopping' stamp: 'svp 1/17/2003 16:14'!startOn: portNum	(self portNumber ~= portNum) ifTrue: [self stop].	self portNumber: portNum.	self start.! !!TcpService methodsFor: 'running' stamp: 'svp 1/17/2003 15:26'!unassignPort	PortAssignments at: self portNumber ifPresent: 		[ :srv |		srv == self ifTrue: 			[PortAssignments removeKey: self portNumber]]! !!TcpService methodsFor: 'conversation' stamp: 'gk 12/6/2005 22:57'!value: aSocket	"This method is invoked by the TcpListener"	[self serve: aSocket] newProcessWithClampedBindings		name: (self name, ' connection');		resume! !!TcpService methodsFor: 'running' stamp: 'svp 1/21/2003 14:37'!verifyPortAvailability: aNumber	PortAssignments at: aNumber ifPresent: 		[ :otherService | 		self error: ('a service is already running on port ', self portNumber asString)].! !!TcpListener commentStamp: '<historical>' prior: 0!I listen for TCP connections on a given port number.  Instance variables:	portNumber - the number of the port on which to listen for incoming connections	handler - an object that is sent the #value: message whenever an incoming connection is established; the argument to this message is a connected socket	socketsToDestroy - a list of sockets that need to be destroyed (usually a listening socket that is no longer needed)Usage:In the following example, a TcpListener is established on port 8123.  After evaluating the following example, if you open a transcript window and point a web browser to port 8123 of this machine (ie. http://localhost:8123/), you should see several http requests appear in the transcript.	| count listener |	count _ 0.	listener _ TcpListener		on: 8123		handler: 			[ :socket |			count _ count + 1.			Transcript show: socket getData.			socket closeAndDestroy].	listener forkAndListenWhile: [count < 5].For an additional example of using TcpListener, see HttpService.!!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:44'!acceptTimeout	^#'TcpListener-acceptTimeout' binding ifNil: [10]! !!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:26'!acceptTimeout: seconds	^#'TcpListener-acceptTimeout' binding: seconds! !!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:46'!backlogSize	^#'TcpListener-backlogSize' binding ifNil: [10]! !!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:26'!backlogSize: anInteger	^#'TcpListener-backlogSize' binding: anInteger! !!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:29'!listenerDestroyDelay	^#'TcpListener-listenerDestroyDelay' binding ifNil: [10]! !!TcpListener class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:30'!listenerDestroyDelay: milliseconds	^#'TcpListener-listenerDestroyDelay' binding: milliseconds! !!TcpListener class methodsFor: 'instance creation' stamp: 'svp 1/17/2003 14:26'!on: portNumber handler: aValuable	^self new		initializeOnPort: portNumber		handler: aValuable! !!TcpListener methodsFor: 'accessing' stamp: 'jf 8/18/2003 01:08'!acceptTimeout	^self class acceptTimeout! !!TcpListener methodsFor: 'accessing' stamp: 'svp 5/7/2003 03:28'!backlogSize	^self class backlogSize! !!TcpListener methodsFor: 'initialize-release' stamp: 'svp 5/6/2003 13:58'!destroySockets	socketsToDestroy ~~ nil ifTrue: 		[socketsToDestroy do: [ :ea | ea destroy]].	socketsToDestroy := OrderedCollection new! !!TcpListener methodsFor: 'private' stamp: 'svp 3/4/2003 14:11'!forkAndListenWhile: aBlock	[self listenWhile: aBlock] fork! !!TcpListener methodsFor: 'initialize-release' stamp: 'svp 1/17/2003 14:53'!initializeOnPort: aNumber handler: aValuableObject	portNumber _ aNumber.	handler _ aValuableObject.	socketsToDestroy _ OrderedCollection new! !!TcpListener methodsFor: 'private' stamp: 'svp 1/17/2003 13:45'!listen	"This is the listening loop.  It runs forever accepting	inbound sockect connections."	self listenWhile: [true]! !!TcpListener methodsFor: 'private' stamp: 'svp 4/25/2003 18:08'!listenWhile: aBlock	"This is the listening loop.  It runs while aBlock evaluates	to true.  When the loop terminates or when the process running	the loop is terminated, any listening sockets will be destroyed."	self socketClass initializeNetwork.	[self pvtListenLoop: aBlock] ensure: [self destroySockets]! !!TcpListener methodsFor: 'accessing' stamp: 'svp 5/7/2003 03:29'!listenerDestroyDelay	^self class listenerDestroyDelay! !!TcpListener methodsFor: 'private' stamp: 'svp 4/15/2003 23:25'!newListener: backlogSize	"Create a new socket that listens on our port.  The backlog is how many simultaneous 	connections to accept at the same time"	[^self pvtNewListener: backlogSize] on: Error do: [].	"Try one more time after initializing the network"	Socket initializeNetwork.	^self pvtNewListener: backlogSize.! !!TcpListener methodsFor: 'accessing' stamp: 'svp 1/17/2003 13:39'!portNumber	^portNumber! !!TcpListener methodsFor: 'printing' stamp: 'svp 1/17/2003 11:29'!printOn: aStream	aStream nextPutAll: (self class name asString, ' port: ', self portNumber asString).! !!TcpListener methodsFor: 'private' stamp: 'svp 8/19/2003 23:48'!pvtListenLoop: aBlock	| socket listener |	listener := self newListener: self backlogSize.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	listener isValid ifFalse: [^self pvtOldListenLoop: aBlock].	aBlock whileTrue: 		[Process terminationOkDuring: 			[[socket := listener waitForAcceptFor: self acceptTimeout ifTimedOut: [nil]]				ifCurtailed: [listener destroy]].		socket ifNotNil:			[socket isConnected				ifTrue: [handler value: socket]				ifFalse: [socket destroy].			socket := nil].		listener isValid ifFalse: 			[(Delay forMilliseconds: self listenerDestroyDelay) wait.			listener destroy.			listener := self newListener: self backlogSize]]! !!TcpListener methodsFor: 'private' stamp: 'svp 5/6/2003 14:09'!pvtNewListener: backlogSize	"Create a new socket that listens on our port.  The backlog is how many simultaneous 	connections to accept at the same time"	| listener |	listener := self socketClass newTCP.	self socketsToDestroy add: listener.	listener listenOn: portNumber backlogSize: backlogSize.	^listener! !!TcpListener methodsFor: 'private' stamp: 'svp 4/25/2003 18:07'!pvtOldListenLoop: aBlock	"see comment on ConnectionQueue>>oldStyleListenLoop"	| socket |	socket _ nil.	aBlock whileTrue:		[socket ifNil:			["try to create a new socket for listening"			socket _ Socket createIfFail: [nil]].		socket 			ifNil: [Process terminationOkDuring: [(Delay forMilliseconds: 100) wait]]			ifNotNil:				[socket isUnconnected ifTrue: 					[socket listenOn: portNumber.					self socketsToDestroy add: socket].				Process terminationOkDuring: 					[[socket waitForConnectionUntil: (Socket deadlineSecs: 10)]						ensure: [socket destroy]].				socket isConnected					ifTrue: 						["connection established"						handler value: socket.						socket _ nil]					ifFalse:						[socket isWaitingForConnection							ifFalse: [socket destroy. socket _ nil]]]]! !!TcpListener methodsFor: 'accessing' stamp: 'svp 1/17/2003 11:32'!socketClass	^Socket! !!TcpListener methodsFor: 'accessing' stamp: 'svp 5/6/2003 14:08'!socketsToDestroy	^socketsToDestroy ifNil: 		[socketsToDestroy := OrderedCollection new].! !"KomServices"!"Installed KomServices auto version 4".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: 'ac0c1b3c-9fb3-4737-8b47-9480993d382e' autoVersion: '4' asVersion atSeconds: 3338754697 number: 8]!!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 5/15/2003 10:10'!doPostProcessingFor: request response: response	"The method is to provide compatibility with HttpAdaptor's post processing.	The receiver is expected to accept two arguments."	^self value: request value: response! !!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 5/13/2003 09:53'!processHttp	"<Boolean> The receiver should answer a boolean to indicate whether 	there is an HttpResponse available (accessed by HttpResponse current).	If the receiver takes no arguments, then assume that it answers a Boolean	and uses dyanmic bindings to access the current request/response, otherwise	pass in the current request and set the current response."	| response |	arguments size = 0		ifTrue: [^self value].	arguments size = 1		ifTrue: 			[response := self value: HttpRequest current.			response ifNotNil:				[HttpResponse current: response.				^true].			^false]	! !!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 4/17/2003 09:00'!processHttpRequest: request	"<HttpResponse> The receiver should answer an HttpResponse for sending 	to the client."	arguments size = 1		ifTrue: [^self value: HttpRequest current].	arguments size = 0		ifTrue: [^self value].	! !!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 12:34'!processVisitor: aKomModuleVisitor	^aKomModuleVisitor doMessageSend: self! !!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 23:44'!validateForStack: anArray	"Do nothing, provided to provide compatibility with ComancheModule"! !!MessageSend methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 13:22'!visitWithValuable: aMonadicValuable	aMonadicValuable value: self.! !!String methodsFor: '*KomHttpServer' stamp: 'bolot 2/5/2001 20:01'!asHttpResponseTo: request	^HttpResponse fromString: self! !!String methodsFor: '*KomHttpServer' stamp: 'svp 5/15/2003 12:23'!asIpByteArray	| ip tmp |	ip _ self findTokens: '.'.	(ip size = 4) ifFalse: [ ^self error: 'Invalid IP Address' ].	ip detect: [ :ea | ea isPositiveInteger and: [ (ea asNumber <= 255) and: [ ea asNumber >= 0 ]]]		ifNone: [ ^self error: 'Invalid IP Address' ].	tmp _ ByteArray new: 4.	1 to: 4 do: [ :in | tmp at: in put: (ip at: in) asNumber ].	^tmp! !!String methodsFor: '*KomHttpServer' stamp: 'svp 1/21/2003 21:21'!isPositiveInteger	self isEmpty ifTrue: [^false].	self detect: [ :letter | letter isDigit not] ifNone: [^true].	^false! !!Color methodsFor: '*KomHttpServer' stamp: 'cwp 6/10/2004 21:53'!hex	^ (rgb hex allButFirst: 3) asLowercase! !!TextEmphasis methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:39'!printHtmlCloseTagOn: strm	emphasisCode = 1 ifTrue: [strm nextPutAll: '</B>'].	emphasisCode = 2 ifTrue: [strm nextPutAll: '</I>'].	emphasisCode = 4 ifTrue: [strm nextPutAll: '</U>'].	emphasisCode = 16 ifTrue: [strm nextPutAll: '</S>']! !!TextEmphasis methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:39'!printHtmlOpenTagOn: strm	emphasisCode = 1 ifTrue: [strm nextPutAll: '<B>'].	emphasisCode = 2 ifTrue: [strm nextPutAll: '<I>'].	emphasisCode = 4 ifTrue: [strm nextPutAll: '<U>'].	emphasisCode = 16 ifTrue: [strm nextPutAll: '<S>']! !!TextMorph methodsFor: '*KomHttpServer' stamp: 'bolot 10/16/2001 21:45'!asHttpResponseTo: request	^self asText asHttpResponseTo: request! !!TimeStamp methodsFor: '*KomHttpServer' stamp: 'svp 5/15/2003 12:40'!printCLFFormatOn: aStream	| d t |	d _ self date.	t _ self time.	aStream nextPut: $[.	d printOn: aStream format: #(1 2 3 $/ 2 1 2).	aStream nextPut: $:.	t print24: true on: aStream.	aStream nextPut: $].! !!TimeStamp methodsFor: '*KomHttpServer' stamp: 'brp 10/2/2004 17:07'!printCLFFormatOn: aStream timezoneOffset: zoneOffset 	| d t |	d := self date.	t := self time.	aStream nextPut: $[.	d printOn: aStream format: #(1 2 3 $/ 2 1 2).	aStream nextPut: $:.	t print24: true on: aStream.	aStream nextPut: $ .	zoneOffset  < 0 		ifTrue: [aStream nextPut: $-]		ifFalse: [aStream nextPut: $+].	zoneOffset abs < 10 ifTrue: [aStream nextPut: $0].	zoneOffset abs printOn: aStream.	aStream nextPutAll: '00'.	aStream nextPut: $].! !!TimeStamp methodsFor: '*KomHttpServer' stamp: 'svp 4/22/2003 00:41'!printHttpFormat	^String streamContents: [ :strm | self printHttpFormatOn: strm]! !!TimeStamp methodsFor: '*KomHttpServer' stamp: 'gk 11/4/2004 13:18'!printHttpFormatOn: aStream	"Print receiver's date and time on aStream in HTTP format;	'<day>, DD <mth> YYYY HH:MM:SS GMT' ->	'Thu, 01 Dec 1994 16:00:00 GMT'	"		| d t |	d _ self date.	t _ self time.	aStream nextPutAll: (d weekday copyFrom: 1 to: 3).	aStream nextPutAll: ', '.	d printOn: aStream format: #(1 2 3 $  2 1 2).	aStream nextPut: $ .	t print24: true on: aStream.	aStream nextPutAll: ' GMT'.! !!TranscriptStream methodsFor: '*KomHttpServer' stamp: 'brp 10/2/2004 16:21'!isTranscriptStream	^ true! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 5/15/2003 10:10'!doPostProcessingFor: request response: response	"The method is to provide compatibility with HttpAdaptor's post processing.	The receiver is expected to accept two arguments."	^self value: request value: response! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 5/13/2003 09:53'!processHttp	"<Boolean> The receiver should answer a boolean to indicate whether 	there is an HttpResponse available (accessed by HttpResponse current).	If the receiver takes no arguments, then assume that it answers a Boolean	and uses dyanmic bindings to access the current request/response, otherwise	pass in the current request and set the current response."	| response |	self numArgs = 0		ifTrue: [^self copy fixTemps value].	self numArgs = 1		ifTrue: 			[response := self copy fixTemps value: HttpRequest current.			response ifNotNil:				[HttpResponse current: response.				^true].			^false].! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 4/17/2003 09:00'!processHttpRequest: request	"<HttpResponse> The receiver should answer an HttpResponse for sending 	to the client."	self numArgs = 1		ifTrue: [^self copy fixTemps value: request].	self numArgs = 0		ifTrue: [^self copy fixTemps value].! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 12:34'!processVisitor: aKomModuleVisitor	^aKomModuleVisitor doBlock: self! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 23:44'!validateForStack: anArray	"Do nothing, provided to provide compatibility with ComancheModule"! !!BlockContext methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 13:22'!visitWithValuable: aMonadicValuable	aMonadicValuable value: self.! !!Time class methodsFor: '*KomHttpServer' stamp: 'svp 4/25/2003 17:35'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	"SVP: copied here from Socket because I think it's more appropriate here"	^ self millisecondClockValue + (secs * 1000)! !!KomLogger commentStamp: 'svp 5/16/2003 12:03' prior: 0!I am a very simple http logging facility.  I implement a writable stream interface and expect to recieve arrays containing an HttpRequest (first element) and an HttpResponse (second element).  I then translate the request and response pair into a textual log format and write that onto each stream in my streams instance variable.  Other loggers may choose to write different log formats, or they could simply store the HttpRequest and HttpResponse objects (in an object DB for example).  For convenience, a transcript window can be opened on a logger using #openTranscript.  You Can also use the method #attachTheTranscript to copy the log entries onto the system Transcript.  Use #detachTranscripts to remove all instances of TranscriptStream from the set of streams.Currently I only support the Commog Log Format (CLF), which many log analysis tools can interpret.  For more information on this format, see:  http://www.w3.org/Daemon/User/Config/Logging.html#common-logfile-formatFor examples, see the class comments for ModLog.Enhancement ideas:- support a flexible logging format that uses some type of template string (ala Apache's logging facility) for producing each line in the log file - implement a "multi-streamer" that implements a writable stream interface and will copy the output to multiple output streams- implement a unix like tail tool that implement a writable stream interface and will "follow" everything that's written to it (similar to the Transcript, but designed to only show the most recent N number of lines or characters)!!KomLogger class methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:35'!on: aStream	^self basicNew		streams: (Set new add: aStream; yourself);		yourself! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:47'!addStream: aStream	"Add a new output stream to the logger"	self streams add: aStream.	^aStream! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:47'!attachTheTranscript	^self addStream: Transcript.! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 16:23'!attachTranscript	self detachTheTranscript.	^(self streams detect: [:ea | ea isTranscriptStream] ifNone: [nil]) 		ifNil: [self addStream: TranscriptStream new]! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:49'!detachTheTranscript	self removeStream: Transcript.	^Transcript! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 16:23'!detachTranscripts	(self streams select: [:ea | ea isTranscriptStream]) 		do: [:ea | self removeStream: ea]! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:36'!logEntryFor: request response: response	"This is the Common Log Format (CLF)"	^String streamContents: 		[ :strm |		strm			nextPutAll: request remoteAddress asIpString;			nextPutAll: ' - ';  "We don't bother with the ident string"			nextPutAll: (ModAuth user ifNil: ['-']);			nextPut: $ .		(TimeStamp fromSeconds: request timestamp)			printCLFFormatOn: strm.		strm nextPutAll: ' "'.		request firstLineOn: strm.		strm nextPutAll: '" '.		strm nextPutAll: response statusCode.		strm nextPut: $ .		strm nextPutAll: (response contentLength ifNil: ['-']) asString.		strm nextPut: Character cr].! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 11:57'!next	self shouldNotImplement! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 16:50'!nextPut: anArray 	| logEntry |	logEntry := self logEntryFor: anArray first response: anArray second.	self streams do: 	[:strm | strm nextPutAll: logEntry; endEntry]! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:50'!openTranscript	self attachTranscript openLabel: 'Comanche Logger'! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:49'!removeStream: aStream	"Remove an output stream to the logger"	self streams remove: aStream ifAbsent: [].	^aStream! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:35'!streams	^streams! !!KomLogger methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 11:35'!streams: aStream	streams := aStream! !!KomTracer commentStamp: 'svp 5/15/2003 13:18' prior: 0!I am a KomLogger, but instead of writing a log file format, I write out a detailed trace of the http request and response pairs.  The following example will dump a trace on the transcript.	| ma |	ma _ ModuleAssembly core.	ma logTo: (KomTracer on: Transcript).	ma addPlug: [ :request | HttpResponse fromString: 'Hello World!!'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModule!!KomTracer methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 16:58'!logEntryFor: request response: response	"This is the Common Log Format (CLF) - the stream is a TranscriptStream"	| aStream |	aStream := self streams anyOne.	aStream		nextPutAll: '-----';		nextPut: Character cr.	request writeOn: aStream.	response writeHeadersOn: aStream.	aStream endEntry.! !!Stream methodsFor: '*KomHttpServer' stamp: 'SVP 8/23/1999 19:07'!asHttpResponseTo: request	^HttpResponse fromStream: self! !!Stream methodsFor: '*KomHttpServer' stamp: 'brp 10/2/2004 16:21'!isTranscriptStream	^ false! !!Stream methodsFor: '*KomHttpServer' stamp: 'SVP 8/12/1999 14:25'!mimeType	^MIMEDocument defaultContentType! !!Transcripter methodsFor: '*KomHttpServer' stamp: 'brp 10/2/2004 16:22'!isTranscriptStream	^ true! !!MIMEDocument class methodsFor: '*KomHttpServer' stamp: 'svp 12/16/1999 10:35'!contentTypeGif	^'image/gif'! !!MIMEDocument class methodsFor: '*KomHttpServer' stamp: 'gh 8/30/2002 10:21'!contentTypeTextCSS	^'text/css'! !!MIMEDocument class methodsFor: '*KomHttpServer' stamp: 'bolot 1/11/2001 18:35' prior: 23733952!defaultMIMEdatabase	| d |	(d _ Dictionary new)	at: 'html' put: 'text/html';	at: 'htm' put: 'text/html';	at: 'xml' put: 'text/xml';	at: 'txt' put: 'text/plain';	at: 'c' put: 'text/plain';	at: 'gif' put: 'image/gif';	at: 'jpg' put: 'image/jpeg';	at: 'jpeg' put: 'image/jpeg';	at: 'png' put: 'image/png';	at: 'xbm' put: 'image/x-xbitmap';	at: 'mid' put: 'audio/midi';	at: 'doc' put: 'application/ms-word-document'.	^d! !!MIMEDocument class methodsFor: '*KomHttpServer' stamp: 'svp 5/2/2003 23:00' prior: 23734527!extendedMIMEdatabase	| d |	(d _ self defaultMIMEdatabase)	at: 'sts' put: 'application/x-squeak-source';	at: 'pr' put: 'application/x-squeak-project';	at: 'hqx' put: 'application/mac-binhex40';	at: 'doc' put: 'application/msword';	at: 'xls' put: 'application/x-excel';	at: 'ppt' put: 'application/mspowerpoint';	at: 'ppz' put: 'application/mspowerpoint';	at: 'pot' put: 'application/mspowerpoint';	at: 'pps' put: 'application/mspowerpoint';	at: 'cpt' put: 'application/mac-compactpro';	at: 'pdf' put: 'application/pdf';	at: 'ps' put: 'application/postscript';	at: 'ai' put: 'application/postscript';	at: 'eps' put: 'application/postscript';	at: 'rtf' put: 'text/rtf';	at: 'bin' put: 'application/octet-stream';	at: 'dms' put: 'application/octet-stream';	at: 'lha' put: 'application/octet-stream';	at: 'lzh' put: 'application/octet-stream';	at: 'exe' put: 'application/octet-stream';	at: 'class' put: 'application/octet-stream';	at: 'zip' put: 'application/zip';	at: 'gtar' put: 'application/x-gtar';	at: 'swf' put: 'application/x-shockwave-flash';	at: 'sit' put: 'application/x-stuffit';	at: 'tar' put: 'application/x-tar';	at: 'au' put: 'audio/basic';	at: 'snd' put: 'audio/basic';	at: 'mid' put: 'audio/midi';	at: 'midi' put: 'audio/midi';	at: 'mpga' put: 'audio/mpeg';	at: 'mp2' put: 'audio/mpeg';	at: 'mp3' put: 'audio/mpeg';	at: 'aiff' put: 'audio/x-aiff';	at: 'aif' put: 'audio/x-aiff';	at: 'aifc' put: 'audio/x-aiff';	at: 'rm' put: 'audio/x-pn-realaudio';	at: 'ram' put: 'audio/x-pn-realaudio';	at: 'rpm' put: 'audio/x-pn-realaudio-plugin';	at: 'ra' put: 'audio/x-realaudio';	at: 'wav' put: 'audio/x-wav';	at: 'css' put: 'text/css';	at: 'mpeg' put: 'video/mpeg';	at: 'mpg' put: 'video/mpeg';	at: 'mpe' put: 'video/mpeg';	at: 'qt' put: 'video/quicktime';	at: 'mov' put: 'video/quicktime';	at: 'avi' put: 'video/x-msvideo';	at: 'movie' put: 'video/x-sgi-movie';	at: 'xul' put: 'application/vnd.mozilla.xul+xml'.	^d! !!MIMEDocument class methodsFor: '*KomHttpServer' stamp: 'bolot 12/19/2000 00:53'!initialize	"MIMEDocument initialize"	self resetMIMEdatabase! !!MIMEDocument methodsFor: '*KomHttpServer' stamp: 'svp 12/16/1999 11:55'!mimeType	^self type! !!ComancheModule commentStamp: 'svp 5/15/2003 01:28' prior: 0!Comanche modules response to the message #processHttp and are responsible for examining the http serving environment and possibly altering that environment.  They can act a filters on both the inbound request and the outbound response.  They may also produce content (and even filter content).  Modules for any given server are arranged in a hierarchy that is formed by following the path of subModules.  Any given module may or may not process its subModules.  The method #processHttp answers a boolean to indicate whether or not a response has been made available.  It is up to the parent module to decide whether or not to continue processing other modules if a response is available.  The default behavior is to stop processing and return once a response is made available.!!ComancheModule class methodsFor: 'as yet unclassified' stamp: 'svp 4/16/2003 12:39'!new	^super new initialize! !!ComancheModule class methodsFor: 'accessing' stamp: 'svp 4/22/2003 09:49'!version	"Answer a version string...subclasses that override this method will	have their answers appended to the 'Server' header in HTTP responses."	^''! !!ComancheModule methodsFor: 'accessing' stamp: 'svp 4/15/2003 15:56'!addSubModule: aComancheModule	^self subModules add: aComancheModule! !!ComancheModule methodsFor: 'logging' stamp: 'svp 5/16/2003 13:30'!attachAllLoggersToTheTranscript	self loggers do: [ :ea | ea attachTheTranscript ]! !!ComancheModule methodsFor: 'logging' stamp: 'svp 5/16/2003 13:28'!detachAllLoggersFromTranscripts	self loggers do: [ :ea | ea detachTranscripts]! !!ComancheModule methodsFor: 'error handling' stamp: 'svp 5/2/2003 23:09'!errorResponseStatus: aSymbol description: aString	^HttpService current		errorResponseStatus: aSymbol		description: aString.! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/16/2003 12:47'!isComancheModule	^true! !!ComancheModule methodsFor: 'testing' stamp: 'svp 4/18/2003 11:58'!isCore	^false! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/15/2003 17:27'!isDir	^false! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/15/2003 15:54'!isDoc	^false! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/16/2003 12:10'!isLog	^false! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/15/2003 16:13'!isSession	^false! !!ComancheModule methodsFor: 'testing' stamp: 'svp 5/15/2003 17:24'!isVhost	^false! !!ComancheModule methodsFor: 'logging' stamp: 'svp 5/16/2003 13:23'!loggers	| answer |	answer := OrderedCollection new.	self visitWithValuable: 		[ :mod |		(mod isComancheModule and: [mod isLog]) 			ifTrue: [answer add: mod logger]].	^answer! !!ComancheModule methodsFor: 'validation' stamp: 'svp 5/16/2003 12:57'!modulesOnStack	| tmp answer |	answer := OrderedCollection new.	tmp := thisContext.	[tmp notNil] whileTrue:		[tmp receiver isComancheModule			ifTrue: [answer add: tmp receiver].		tmp := tmp sender].	^answer asArray! !!ComancheModule methodsFor: 'logging' stamp: 'svp 5/16/2003 13:25'!openTranscriptsOnAllLoggers	self loggers do: [ :ea | ea openTranscript]! !!ComancheModule methodsFor: 'accessing' stamp: 'svp 4/23/2003 21:57'!options	^'GET,HEAD,POST,OPTIONS,TRACE'! !!ComancheModule methodsFor: 'processing' stamp: 'svp 4/15/2003 17:57'!processHttp	"<Boolean> Subclasses should override this method to process	the current http request (accessed via HttpRequest current).	Answer true if a response has been made available (via 	HttpResponse current:) and false if no response was generated."	self subclassResponsibility! !!ComancheModule methodsFor: 'processing' stamp: 'svp 4/17/2003 08:45'!processHttpRequest: request	"<HttpResponse>"	self processHttp.	^HttpResponse current! !!ComancheModule methodsFor: 'processing' stamp: 'svp 4/15/2003 15:58'!processSubModules	self subModulesDo: 		[ :module |		module processHttp ifTrue: [^true]].	^false! !!ComancheModule methodsFor: 'visitor' stamp: 'svp 5/16/2003 12:25'!processVisitor: aKomModuleVisitor	^aKomModuleVisitor doComancheModule: self! !!ComancheModule methodsFor: 'accessing' stamp: 'svp 4/15/2003 15:58'!subModules	^subModules ifNil: [subModules _ OrderedCollection new]! !!ComancheModule methodsFor: 'processing' stamp: 'svp 4/15/2003 15:57'!subModulesDo: aBlock	subModules ifNotNil: 		[subModules do: aBlock]! !!ComancheModule methodsFor: 'validation' stamp: 'svp 5/16/2003 12:52'!validate	| validator |	validator := KomModuleValidator new.	self visitModules: validator.	validator problems isEmpty 		ifFalse: [self error: 'validate of the module hierarchy failed']	! !!ComancheModule methodsFor: 'validation' stamp: 'svp 5/16/2003 13:08'!validateContext: problems	"Validation is successful by default, subclass to check the 	context stack for the the presence of required modules and add	to the list of problems"	self validateForStack: self modulesOnStack problems: problems! !!ComancheModule methodsFor: 'validation' stamp: 'svp 5/16/2003 15:41'!validateForStack: anArray	| probs |	probs := OrderedCollection new.	self validateForStack: anArray problems: probs.	probs isEmpty ifFalse: [self error: 'invalid context for module']! !!ComancheModule methodsFor: 'validation' stamp: 'svp 5/16/2003 12:58'!validateForStack: anArray problems: problems	"Subclasses may wish to override this method to check that	prerequisite modules are on the stack above them"! !!ComancheModule methodsFor: 'visitor' stamp: 'svp 5/16/2003 13:21'!visitModules: aKomModuleVisitor	self visitWithValuable: [ :ea | ea processVisitor: aKomModuleVisitor ].! !!ComancheModule methodsFor: 'visitor' stamp: 'svp 5/16/2003 13:21'!visitWithValuable: aMonadicValuable	aMonadicValuable value: self.	self subModules do: [ :ea | ea visitWithValuable: aMonadicValuable]! !!ModAlias commentStamp: 'svp 5/15/2003 01:21' prior: 0!This module will attempt to match a prefix to the URL of a request.  If a match is made, its subModules will be processed.  If not, then its subModules are not processed.  The following is an example:	| ma |	ma _ ModuleAssembly core.	ma alias: '/hello' to: 		[ma addPlug: 			[ :request |			HttpResponse fromString: 'This is the aliased content']].	ma addPlug: 		[ :request |		HttpResponse fromString: 'This is the default content'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleIn this example, the urls http://localhost:8080/hello and http://localhost:8080/hello/some/more/path will show the aliased content while any url where the path does not begin with '/hello' will show the default content.!!ModAlias methodsFor: 'as yet unclassified' stamp: 'svp 4/16/2003 21:22'!pathPrefix	^pathPrefix! !!ModAlias methodsFor: 'as yet unclassified' stamp: 'svp 4/16/2003 21:22'!pathPrefix: aString	pathPrefix _ aString! !!ModAlias methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 17:05'!processHttp	| path |	path _ ModCore path.	"check if our prefix matches"	((path beginsWith: pathPrefix) and: 	[path size = pathPrefix size or: [(path at: (pathPrefix size + 1)) = $/]])		ifTrue: 			[ModCore path: (path copyFrom: pathPrefix size + 1 to: path size).			self processSubModules ifTrue: 				[ModCore path: path.				^true]].	"otherwise, reset the path to it's original setting and indicate 	to the caller that we have no response and ."	ModCore path: path.	^false! !!ModAuth commentStamp: 'svp 5/15/2003 17:40' prior: 0!This module, when present, requires that a request has user authentication info.  It does not authenticate the supplied user id and password.  I send the message #verifyPassword:forUser: to my authDb instance variable to validate user ids and passwords.  You may supply your own user management object.  A very simple authentication database is provided by the KomAuthDb class.  Currently, this module only supports Basic authentication.Here is an example of a simple configuration that authentications users:	| ma authdb |	authdb := KomAuthDb new.	authdb addUser: 'admin' withPassword: 'password'.	ma := ModuleAssembly core.	ma authenticate: authdb realm: 'Demo'.	ma addPlug:		[ :request |		HttpResponse fromString: 'Hello world!!'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModule. Future enhancement ideas:- add support for more types of authentication!!ModAuth class methodsFor: 'bindings' stamp: 'svp 5/15/2003 12:32'!user	^#'ModAuth-user' binding! !!ModAuth class methodsFor: 'bindings' stamp: 'svp 5/15/2003 12:33'!user: userName	^#'ModAuth-user' binding: userName! !!ModAuth methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:37'!authDb	^authDb! !!ModAuth methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:39'!authDb: anAuthDb	authDb := anAuthDb! !!ModAuth methodsFor: 'accessing' stamp: 'svp 5/16/2003 23:08'!authorizationResponse	| answer |	answer _ HttpResponse		status: #unauthorized		contents: 'Authentication Required'.	answer fieldAt: 'WWW-Authenticate' put: 'Basic realm="', self realm,'"'.	^answer! !!ModAuth methodsFor: 'processing' stamp: 'svp 4/18/2003 09:22'!decodeAuthorization: aString	^(Base64MimeConverter mimeDecodeToChars:		(ReadStream on: (aString findTokens: ' ') last))			contents! !!ModAuth methodsFor: 'processing' stamp: 'svp 4/18/2003 09:34'!extractAuthInfo: request andDo: aBlock 	| authHeader user pass |	(authHeader _ self extractAuthorization: request) ifNil: [^self].	user _ self extractUser: authHeader.	pass _ self extractPassword: authHeader.	(user isNil or: [pass isNil]) ifTrue: [^self].	^aBlock value: user value: pass! !!ModAuth methodsFor: 'processing' stamp: 'svp 4/18/2003 10:46'!extractAuthorization: request	^(request headerAt: 'Authorization' ifAbsent: [request headerAt: 'authorization' ifAbsent: []])		ifNotNilDo: [:auth | self decodeAuthorization: auth]! !!ModAuth methodsFor: 'processing' stamp: 'svp 4/18/2003 09:29'!extractPassword: auth	^auth ifNotNil: [auth copyAfter: $:]! !!ModAuth methodsFor: 'processing' stamp: 'svp 4/18/2003 09:28'!extractUser: auth	^auth ifNotNil: [auth copyUpTo: $:]! !!ModAuth methodsFor: 'processing' stamp: 'brp 10/2/2004 15:21'!processHttp	| request |	request := HttpRequest current.	self extractAuthInfo: request		andDo: 			[:user :password | 			(self verifyPassword: password forUser: user) 				ifTrue: 					[self class user: user.					^self processSubModules]].	HttpResponse current: self authorizationResponse.	^true! !!ModAuth methodsFor: 'accessing' stamp: 'svp 5/14/2003 23:08'!realm	^realm ifNil: ['/']! !!ModAuth methodsFor: 'accessing' stamp: 'svp 4/18/2003 09:45'!realm: aString	realm _ aString! !!ModAuth methodsFor: 'as yet unclassified' stamp: 'svp 5/14/2003 17:37'!verifyPassword: aPassword forUser: userName	^self authDb verifyPassword: aPassword forUser: userName! !!ModAutoIndex commentStamp: 'svp 5/15/2003 01:15' prior: 0!This module provides automatically generated listings of directory contents.Required Bindings:	HttpRequest current	ModDir serverDirectoryExported Bindings:	<none>The following is an example:	| ma |	ma := ModuleAssembly core.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: 'index.html index.htm'.	ma serveFiles.	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleThis example just starts a file server on your default directory.  Any directories (that don't have an index file) will be rendered as listings by ModAutoIndex.!!ModAutoIndex class methodsFor: 'as yet unclassified' stamp: 'svp 6/27/2003 16:43'!splitPath: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimiter><localName>, where <dirPath><delimiter> is optional. The <dirPath> part may contain delimiters."	| delimiter i dirName localName tmpName |	fullName last = $/		ifTrue: [tmpName := fullName copyFrom: 1 to: fullName size - 1]		ifFalse: [tmpName := fullName].	delimiter _ $/.	(i _ tmpName findLast: [:c | c = delimiter]) = 0		ifTrue:			[dirName _ String new.			localName _ tmpName]		ifFalse:			[dirName _ tmpName copyFrom: 1 to: (i - 1 max: 1).			localName _ tmpName copyFrom: i + 1 to: tmpName size].	^ pathAndNameBlock value: dirName value: localName! !!ModAutoIndex methodsFor: 'directory listing' stamp: 'svp 4/16/2003 08:38'!dirEntries: entries request: request on: strm padNamesTo: namePad padSizesTo: sizePad	request url ~= '/' ifTrue: [self parentEntry: request on: strm].	entries do: 		[ :entry |		self entry: entry on: strm padNamesTo: namePad padSizesTo: sizePad].! !!ModAutoIndex methodsFor: 'directory listing' stamp: 'svp 5/2/2003 23:09'!directoryListing: request directory: dir	| entries namePad sizePad |	entries _ dir entries.	(request fields includesKey: 'S') ifTrue: 		[entries _ entries sortBy: [ :a :b | a fileSize <= b fileSize ]].	(request fields includesKey: 'M') ifTrue: 		[entries _ entries sortBy: [ :a :b | a modificationTime <= b modificationTime ]].	(request fields includesKey: 'N') ifTrue: 		[entries _ entries sortBy: [ :a :b | a name <= b name ]].	namePad _ (entries inject: 16 into: [ :max :ea | ea name size max: max ]) + 1.	sizePad _ (entries inject: 4 into: [ :max :ea | ea fileSize printString size max: max ]) + 1.	^String streamContents: [ :strm |		strm nextPutAll: '<!!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">'.		strm nextPutAll: '<html><head><title>Index of '.		strm nextPutAll: request url.		strm nextPutAll: '</title></head><body><h1>Index of '.		strm nextPutAll: request url.		strm nextPutAll: '</h1><pre>      <a HREF="?N=A">Name</a>'.		strm nextPutAll: ((String new: (namePad - 4)) atAllPut: $ ; yourself).		strm nextPutAll: '<a HREF="?M=A">Last modified</a>    '.		strm nextPutAll: ((String new: (sizePad - 4)) atAllPut: $ ; yourself).		strm nextPutAll: '<a HREF="?S=A">Size</a><hr><br>'.		self 			dirEntries: entries 			request: request 			on: strm 			padNamesTo: namePad 			padSizesTo: sizePad.		strm nextPutAll: '</pre><hr><address>'.		strm nextPutAll: HttpService current serverDescription.		strm nextPutAll: '</address></body></html>'].! !!ModAutoIndex methodsFor: 'directory listing' stamp: 'svp 6/27/2003 16:39'!entry: entry on: strm padNamesTo: namePad padSizesTo: sizePad	| sizeString |	sizeString _ entry fileSize printString.	entry isDirectory 		ifTrue: [strm nextPutAll: '[DIR]']		ifFalse: [strm nextPutAll: '     '].	strm nextPutAll: ' <a HREF="'.	strm nextPutAll: entry name.	entry isDirectory ifTrue: [strm nextPut: $/].	strm nextPutAll: '">'.	strm nextPutAll: entry name.	strm nextPutAll: '</a>'.	strm nextPutAll: ((String new: (namePad - entry name size)) atAllPut: $ ; yourself).	(Date fromSeconds: (entry modificationTime))		printOn: strm format: #(1 2 3 $- 2 1 2).	strm nextPut: $ .	(Time fromSeconds: (entry modificationTime))		print24: true showSeconds: false on: strm.	strm nextPutAll: ((String new: (sizePad - sizeString size)) atAllPut: $ ; yourself).	strm nextPutAll: sizeString.	strm nextPutAll: String crlf.! !!ModAutoIndex methodsFor: 'directory listing' stamp: 'svp 6/27/2003 16:48'!parentEntry: request on: strm	| tmp parentPath |	tmp _ request url copyFrom: 1 to: (request url size - 1).	parentPath _ self class splitPath: tmp to: [ :path :nm | path].	parentPath last = $/ ifFalse: [parentPath := parentPath, '/'].	strm nextPutAll: '[DIR] <a HREF="'.	strm nextPutAll: parentPath.	strm nextPutAll: '">Parent Directory</a>'.	strm nextPutAll: '<br>'.! !!ModAutoIndex methodsFor: 'processing' stamp: 'brp 10/2/2004 14:44'!processHttp	| dir request |	request := HttpRequest current.	(#(#GET #POST) includes: request method) ifFalse: [^false].	dir := ModDir serverDirectory.	HttpResponse current: (HttpResponse 				fromString: (self directoryListing: request directory: dir)).	^true! !!ModAutoIndex methodsFor: 'validation' stamp: 'svp 5/16/2003 13:01'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :ea | ea isDir ] 		ifNone: [problems add: 'AutoIndex module requires Dir module']! !!ModCore commentStamp: 'svp 5/15/2003 01:13' prior: 0!The is the Core module.  It extracts a few things from a request and can establish a server root directory (which is not required).  It will also process TRACE and OPTIONS requests.!!ModCore class methodsFor: 'bindings' stamp: 'svp 4/16/2003 13:28'!host	^#'ModCore-Host' binding! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/16/2003 13:28'!host: aString	^#'ModCore-Host' binding: aString! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/23/2003 21:39'!method	^#'ModCore-Method' binding! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/23/2003 21:40'!method: methodString	#'ModCore-Method' binding: methodString! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/23/2003 22:22'!options	^#'ModCore-Options' binding! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/23/2003 22:22'!options: methodsString	^#'ModCore-Options' binding: methodsString! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/16/2003 11:28'!path	^#'ModCore-Path' binding! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/16/2003 11:28'!path: aString	^#'ModCore-Path' binding: aString! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/18/2003 11:51'!serverRoot	^#'ModCore-ServerRoot' binding! !!ModCore class methodsFor: 'bindings' stamp: 'svp 4/18/2003 11:51'!serverRoot: aFileDirectory	^#'ModCore-ServerRoot' binding: aFileDirectory! !!ModCore methodsFor: 'as yet unclassified' stamp: 'svp 4/18/2003 11:58'!isCore	^true! !!ModCore methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 15:18'!optionsResponse	| opts |	opts := self class options ifNil: ['GET,HEAD,POST,OPTIONS,TRACE'].	^(HttpResponse fromString: '')		fieldAt: 'Allow' put: opts;		yourself! !!ModCore methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 16:08'!processHttp	| request method |	request := HttpRequest current.	self class		method: (method := request method);		path: request url;		host: request networkHost;		serverRoot: self serverRoot.	method = 'TRACE' 		ifTrue: 			[HttpResponse current: (self traceResponse: request).			^true].	self processSubModules ifTrue: [^true].	method = 'OPTIONS' 		ifTrue: 			[HttpResponse current: self optionsResponse.			^true].	^false! !!ModCore methodsFor: 'as yet unclassified' stamp: 'svp 4/18/2003 11:49'!serverRoot	^serverRoot! !!ModCore methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 14:53'!serverRoot: aDirOrString 	serverRoot := aDirOrString isString 		ifTrue: [FileDirectory on: aDirOrString]		ifFalse: [aDirOrString]! !!ModCore methodsFor: 'as yet unclassified' stamp: 'svp 4/23/2003 22:33'!traceResponse: request	^HttpResponse fromString:		(String streamContents: [ :strm | request writeOn: strm ])! !!ModDir commentStamp: 'svp 5/15/2003 16:40' prior: 0!This module provides basic directory handling (including redirects to handle the trailing slash problem).Required Bindings:	HttpRequest current	ModDoc fullFilePathExported Bindings:	ModDir serverDirectoryThe following is an example:	| ma |	ma := ModuleAssembly core.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: 'index.html index.htm'.	ma serveFiles.	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleThis example just starts a file server on your default directory.  Any directories (that don't have an index file) will be rendered as listings by ModAutoIndex.!!ModDir class methodsFor: 'tests' stamp: 'ab 11/13/2003 12:31'!directoryExists: aFileDirectory	"The Mac implementation of FileDirectory>>exists answers true,	even when the path specified is a file (not a directory) (as of	22 May 2003)...this differs from the Unix and Windows VMs...so 	this is a little hack that should work on all platforms...when the	Mac VM is correct, we should change this code to simply use	FileDirectory>>exists"	"Ordinarily, just do:"	SmalltalkImage current platformName ~= 'Mac OS' ifTrue: [^aFileDirectory exists].	"But!! Because of Mac idiosyncracies, do:"	^aFileDirectory exists and: 		[aFileDirectory containingDirectory directoryNames 			includes: aFileDirectory localName].	! !!ModDir class methodsFor: 'accessing' stamp: 'tbn 11/10/2004 11:38'!fullFilePath	^ModDoc fullFilePath! !!ModDir class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:42'!serverDirectory	^#'ModDir-ServerDirectory' binding! !!ModDir class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:42'!serverDirectory: aFileDirectory	#'ModDir-ServerDirectory' binding: aFileDirectory! !!ModDir methodsFor: 'as yet unclassified' stamp: 'svp 4/15/2003 17:06'!directoryIndex	^directoryIndex ifNil: [directoryIndex _ OrderedCollection new]! !!ModDir methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 14:52'!directoryIndex: aCollectionOrString 	directoryIndex := aCollectionOrString isString 		ifTrue: [aCollectionOrString findTokens: ' ']		ifFalse: [aCollectionOrString]! !!ModDir methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 15:45'!directoryIndexExists: dir 	| fname |		fname := self directoryIndex detect: [:ea | dir fileExists: ea]				ifNone: [^false].	"Our directory exists, set the full file name so that	ModFile will detect and serve the index file (note, if no ModFile	gets processed after this module, then a doc not found will be returned)"		ModDoc relativeFilePath: ModDoc relativeFilePath , fname.	^true! !!ModDir methodsFor: 'testing' stamp: 'svp 5/15/2003 17:27'!isDir	^true! !!ModDir methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 15:30'!processHttp	| filePath dir request |	request := HttpRequest current.	filePath := self class fullFilePath.	(self class directoryExists: (dir := FileDirectory on: filePath)) 		ifFalse: [^false].	"If the url does not end in a slash, then redirect to add the slash"	request url last ~= $/ 		ifTrue: 			[self redirectWithTrailingSlash: request.			^true].	(self directoryIndexExists: dir) ifTrue: [^false].	self class serverDirectory: dir.	^ self processSubModules ! !!ModDir methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 23:09'!redirectWithTrailingSlash: request	| location |	location _ request url, '/'.	HttpResponse current: 		((HttpResponse			status: #tempMoved			contents: 'Temporarily moved to: <A HREF="', location, '">', location, '</A>')		fieldAt: 'Location' put: location;		fieldAt: 'URI' put: location;		yourself)! !!ModDir methodsFor: 'validation' stamp: 'svp 5/16/2003 13:02'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :ea | ea isDoc ] 		ifNone: [problems add: 'Dir module requires a Doc module']! !!ModDoc commentStamp: 'svp 5/15/2003 16:40' prior: 0!The core module for handling traditional web server dutiesRequired Bindings: 	ModCore pathExported Bindings:	ModDoc documentRoot	ModDoc relativeFilePathThe following is an example:	| ma |	ma := ModuleAssembly core.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: 'index.html index.htm'.	ma serveFiles.	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleThis example just starts a file server on your default directory.  Any directories (that don't have an index file) will be rendered as listings by ModAutoIndex.!!ModDoc class methodsFor: 'bindings' stamp: 'svp 4/15/2003 18:02'!documentRoot	"<FileDirectory> The root of the document tree for the current request"	^#'ModCore-DocumentRoot' binding! !!ModDoc class methodsFor: 'bindings' stamp: 'svp 4/15/2003 16:02'!documentRoot: aFileDirectory	#'ModCore-DocumentRoot' binding: aFileDirectory! !!ModDoc class methodsFor: 'bindings' stamp: 'ab 11/13/2003 12:31'!fullFilePath	"<String> The full path name to the file or directory on the server	indicated by the current HttpRequest."	"Ordinarily, just use the following:"	(SmalltalkImage current platformName ~= 'Mac OS')		ifTrue: [^self documentRoot fullNameFor: self relativeFilePath].	"But!! Because of Mac idiosyncracies, we must do:"	^((self relativeFilePath findTokens: FileDirectory pathNameDelimiter asString)		inject: self documentRoot into: 			[ :dir :pathPart |			FileDirectory on: (dir fullNameFor: pathPart)]) fullName			! !!ModDoc class methodsFor: 'initialization' stamp: 'svp 4/15/2003 16:19'!initialize	"self initialize"	DelimiterTranslation _ (0 to: 255) as: ByteArray.	DelimiterTranslation 		at: ($/ asciiValue + 1) 		put: FileDirectory pathNameDelimiter asciiValue.	"Register this class for startUp notification (in case we are started on a	platform with a differen path name delimiter"	Smalltalk addToStartUpList: self.! !!ModDoc class methodsFor: 'bindings' stamp: 'svp 4/16/2003 11:12'!relativeFilePath	"<String> The relative path name to the file or directory on the server	indicated by the current HttpRequest"	^#'ModCore-RelativeFilePath' binding ! !!ModDoc class methodsFor: 'bindings' stamp: 'svp 4/16/2003 11:13'!relativeFilePath: aPathName	^#'ModCore-RelativeFilePath' binding: aPathName! !!ModDoc class methodsFor: 'initialization' stamp: 'svp 4/15/2003 16:19'!startUp	"When we start up, force the rebuilding of the DelimiterTranslation	array (in case we are started on a platform with a different delimiter)."	self initialize! !!ModDoc methodsFor: 'accessing' stamp: 'svp 4/15/2003 16:00'!documentRoot	^documentRoot! !!ModDoc methodsFor: 'accessing' stamp: 'brp 10/2/2004 14:52'!documentRoot: aDirectoryOrString 	documentRoot := aDirectoryOrString isString 		ifTrue: [FileDirectory on: aDirectoryOrString]		ifFalse: [aDirectoryOrString]! !!ModDoc methodsFor: 'testing' stamp: 'svp 5/15/2003 15:54'!isDoc	^true! !!ModDoc methodsFor: 'error handling' stamp: 'svp 4/15/2003 16:32'!notFoundResponseFor: request	^self		errorResponseStatus: #notFound		description: ('The requested URL ', request url, ' was not found on this server').! !!ModDoc methodsFor: 'printing' stamp: 'svp 4/15/2003 16:27'!printOn: strm	super printOn: strm.	strm nextPut: $(.	self documentRoot pathName printOn: strm.	strm nextPut: $).! !!ModDoc methodsFor: 'accessing' stamp: 'brp 10/2/2004 15:21'!processHttp	"Examine the path from ModCore and set the bindings for	document root and relative file path"	| relativeFilePath path |	path := ModCore path.	relativeFilePath := self relativeFilePathFrom: path.	self class		documentRoot: self documentRoot;		relativeFilePath: relativeFilePath.	^ self processSubModules.! !!ModDoc methodsFor: 'accessing' stamp: 'brp 10/2/2004 15:40'!relativeFilePathFrom: path 	^((path notEmpty and: [path first = $/]) 		ifTrue: [path copyFrom: 2 to: path size]		ifFalse: ['']) translateWith: DelimiterTranslation! !!ModDoc methodsFor: 'validation' stamp: 'svp 5/16/2003 13:02'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :module | module isCore ]		ifNone: [problems add: 'Doc module requires a Core module']! !!ModVhostDoc commentStamp: 'svp 5/15/2003 00:20' prior: 0!Used for determining the document root for mass virtual hosting (where the virtual server name is incorporated into the document root).  See the class comments for ModVhost for an example of virtual hosting.!!ModVhostDoc methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:53'!documentRoot	^super documentRoot directoryNamed: ModVhost string! !!ModVhostDoc methodsFor: 'validation' stamp: 'svp 5/16/2003 13:04'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :module | module isVhost ]		ifNone: [self error: 'VhostDoc module requires a Vhost module']! !!ModFile commentStamp: 'svp 5/15/2003 16:40' prior: 0!This module serves a file based on the setting of ModCore fullFilePath.Required Bindings:	ModDoc documentRoot	ModDoc relativeFilePathExported Bindings:	<none>The following is an example:	| ma |	ma := ModuleAssembly core.	ma documentRoot: FileDirectory default fullName.	ma directoryIndex: 'index.html index.htm'.	ma serveFiles.	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleThis example just starts a file server on your default directory.  Any directories (that don't have an index file) will be rendered as listings by ModAutoIndex.!!ModFile methodsFor: 'processing' stamp: 'gk 8/17/2005 23:52'!processHttp	"This method uses StandardFileStream explicitly instead	of relying on FileStream class>>concreteStream, since in this	case we just need to return the file 'as is' binary."	| fullFilePath method |	method := ModCore method.	(#(#GET #POST) includes: method) ifFalse: [^false].	fullFilePath := ModDoc fullFilePath.	(FileStream isAFileNamed: fullFilePath) ifFalse: [^false].	self processSubModules ifTrue: [^true].	HttpResponse current: (HttpResponse 				fromStream: (StandardFileStream readOnlyFileNamed: fullFilePath)).	^true! !!ModFile methodsFor: 'validation' stamp: 'svp 5/16/2003 13:03'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :ea | ea isDoc ] 		ifNone: [problems add: 'File module requires a Doc module']! !!ModLog commentStamp: 'svp 5/16/2003 12:06' prior: 0!Instance Variable:logger <Stream> - a stream for writing out request/response pairs Examples:The following example will log requests to the Transcript:	| ma |	ma _ ModuleAssembly core.	ma logTo: (KomLogger on: Transcript).	ma addPlug: [ :request | HttpResponse fromString: 'Hello World!!'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleIt is possible to segregate logging by inserting #logTo: messages a different places in the module assembly...one example using ModAlias follows:	| ma |	Smalltalk at: #MyHttpLog put: (WriteStream on: '').	ma _ ModuleAssembly core.	ma alias: '/log1' to: [ma logTo: (KomLogger on: Transcript)].	ma alias: '/log2' to: [ma logTo: (KomLogger on: (Smalltalk at: #MyHttpLog))].	ma addPlug: [ :request | HttpResponse fromString: 'Hello World!!'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModuleIn this example, all requests will respond with 'Hello World!!', but requests whose url begins with '/log1' will be logged to the transcript and requests whose url begins with '/log2' will be logged to MyHttpLog.  Other requests will not be logged.In the next example, we illustrate how to start enable logging, and also how to open a transcript window on that log.  Output sent to the logger will be concurrently written to the WriteStream "MyHttpLog" and to the TranscriptStream opened by the #openTranscript message.	| ma logger |	Smalltalk at: #MyHttpLog put: (WriteStream on: '').	ma _ ModuleAssembly core.	ma logTo: (logger := KomLogger on: (Smalltalk at: #MyHttpLog)).	ma addPlug: [ :request | HttpResponse fromString: 'Hello World!!'].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModule.	logger openTranscript.Tip: With the SharedStreams package (on SqueakMap), a number of asynchronous logging configurations can be constructed.!!ModLog methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 10:30'!doPostProcessingFor: request response: response	"This method is called after the response has been written, we need 	to log the request/response pair"	self logger nextPut: (Array with: request with: response)! !!ModLog methodsFor: 'testing' stamp: 'svp 5/16/2003 12:10'!isLog	^true! !!ModLog methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 10:30'!logger	^logger! !!ModLog methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 10:30'!logger: aStream	logger := aStream! !!ModLog methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 10:15'!processHttp	HttpAdaptor current addPostProcessor: self.	^self processSubModules! !!ModMulti commentStamp: 'svp 5/15/2003 17:13' prior: 0!This module simply processes its subModules.  It is handy when you'd like to wrap some modules together a work with them as a unit.Example:In the following example, a ModuleAssembly instantiated with #new will have a ModMulti instance as the root of the module stack.  Adding further modules to the assembly results in those modules being added to the ModMulti instance.  In this example, we create an assembly that could be used as the standard document server in a number of places in our main module assembly.  In this manner, we can reuse module assemblies.  Changes to our standard document server assembly would affect the behavior every where we refer to that assembly (also, direct manipulation of the module instances after construction will affect the behavior everywhere an assembly is refered...this may even eliminate the need to rebuild your module assembly).	| stdDocs ma |	"Create a stdDocs assembly"	stdDocs := ModuleAssembly new.	stdDocs directoryIndex: 'index.html index.htm'.	stdDocs serveFiles.	stdDocs notFound.	"Now create our main assembly"	ma := ModuleAssembly core.	ma alias: '/one' to: 		[ma documentRoot: (FileDirectory default directoryNamed: 'one').		ma addAssembly: stdDocs].	ma alias: '/two' to:		[ma documentRoot: (FileDirectory default directoryNamed: 'two').		ma addAssembly: stdDocs].	ma addPlug: 		[:request | HttpResponse fromString: 			'<a href="one">go to one</a> <a href="two">go to two</a>'].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.!!ModMulti methodsFor: 'processing' stamp: 'svp 4/16/2003 21:10'!processHttp	^self processSubModules! !!ModNotFound commentStamp: 'svp 5/15/2003 17:20' prior: 0!I am a simple module that if reached will generate a not found response.  This is useful if you do not wish to continue processing modules add some point in your module assembly.The following is a simple example using the #notFound message of ModuleAssembly:	| ma |	ma := ModuleAssembly core.	ma alias: '/one' to: 		[ma documentRoot: (FileDirectory default directoryNamed: 'one').		ma directoryIndex: 'index.html index.htm'.		ma serveFiles.		ma notFound].	ma addPlug: 		[:request | HttpResponse fromString: 			('<a href="one">go to one</a> If the path begins with',			' "/one" we should never end up here')].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.By contrast, the following example will end up in our default response if no matching file is found.	| ma |	ma := ModuleAssembly core.	ma alias: '/one' to: 		[ma documentRoot: (FileDirectory default directoryNamed: 'one').		ma directoryIndex: 'index.html index.htm'.		ma serveFiles].	ma addPlug: 		[:request | HttpResponse fromString: '<a href="one">go to one</a>'].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.!!ModNotFound methodsFor: 'as yet unclassified' stamp: 'svp 5/15/2003 17:08'!processHttp	HttpResponse current: 		(HttpAdaptor current notFoundResponseFor: HttpRequest current).	^true! !!ModSession commentStamp: 'svp 5/15/2003 16:15' prior: 0!I add provide a session context to sub modules.  To access the current session, use "KomSession current"...all requests passing through this module will be assigned a session, and responses from its subModules (if any) will be given a cookie to assign the session id.Notes:  This is basically a straight translation of the old Comanche session handling.  Ideas for the future include:- add the ability to use post/query fields instead of cookies- add methods to assist in building Urls with session query parameters added- be able to specify the cookie/field name that is used to store the session- be able to tie sessions to a specific IP address (to minimize risk of man in the middle attacks)Required Bindings:	HttpRequest currentExported Bindings:	KomSession currentExample:In the following example, we enable session tracking, set the session timeout to 30 minutes, and show the session id in the web browser.	| ma |	ma _ ModuleAssembly core.	ma trackSessions.	ma sessionTimeout: 30.  "Sets the session timeout to 30 minutes"	ma addPlug:		[:request | 		HttpResponse fromString: 			('Your session id is: ', KomSession current id)].	(HttpService startOn: 8080 named: 'Example') plug: ma rootModule.!!ModSession methodsFor: 'private' stamp: 'svp 5/14/2003 01:11'!basicExtractSession: aRequest ifAbsent: absentBlock	"PRIVATE: answer the current session based on the 'SessionID' cookie"	aRequest cookies		at: #SessionID		ifPresent: [ :sid | ^sessions at: sid ifAbsent: absentBlock].	^absentBlock value! !!ModSession methodsFor: 'private' stamp: 'svp 5/14/2003 01:18'!checkForCleanup	"PRIVATE: run the cleanup if the last cleanup was more than	1 minute ago"	lastCleanup + 60 < Time totalSeconds		ifTrue: [self cleanup]! !!ModSession methodsFor: 'private' stamp: 'svp 5/14/2003 01:05'!cleanup	"PRIVATE: iterate over all sessions and remove stale ones"	| session cutoff |	lastCleanup := Time totalSeconds.	cutoff := lastCleanup - secondsToLive.	sessions keys do: 		[:key | 		session _ sessions at: key.		(session lastAccess < cutoff) ifTrue: 			[sessions removeKey: key]]! !!ModSession methodsFor: 'private' stamp: 'svp 5/14/2003 01:10'!extractSession: aRequest 	"<KomSession> extract or create a session for aRequest"	| session |	mutex critical: 		[self checkForCleanup.		session _ self 					basicExtractSession: aRequest 					ifAbsent: [self newSession].		session touch].	^ session! !!ModSession methodsFor: 'initialization' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.		sessions := Dictionary new.	mutex := Semaphore forMutualExclusion.	lastCleanup := Time totalSeconds.	"30 minutes"	secondsToLive := 30 * 60! !!ModSession methodsFor: 'testing' stamp: 'svp 5/15/2003 16:05'!isSession	^true! !!ModSession methodsFor: 'private' stamp: 'svp 5/14/2003 01:11'!newSession	"PRIVATE: creates a new Session and stores it"	| session |	session _ KomSession new.	sessions at: session id put: session.	^ session! !!ModSession methodsFor: 'processing' stamp: 'svp 5/14/2003 01:14'!processHttp	| session |	session _ self extractSession: HttpRequest current.	KomSession current: session.	self processSubModules ifFalse: [^false].	HttpResponse current		setCookieName: #SessionID		value: session id		path: '/'.	^ true! !!ModSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 01:12'!secondsToLive: anInteger	secondsToLive := anInteger! !!ModSession methodsFor: 'enumeration' stamp: 'gk 11/6/2003 17:12'!sessionsDo: aBlock	"Iterate over sessions."	^ sessions valuesDo: aBlock! !!ModVhost commentStamp: 'svp 5/15/2003 17:37' prior: 0!This module exports a string that is created based on a template.  Other modules may access and use the resulting string as they see fit (using "ModVhost string").  ModVhostDoc uses the ModVhost string to establish a document root based on the virtual host name.  ModVhostAlias uses the ModVhost string to look for a match when deciding whether or not to process its subModules.  See the examples below for more details.The format of the template string is designed to be compatible with Apache's virtual hosting support.  The following is adapted from the Apache documentation:-----%% inserts a percent%p inserts the socket port number (as it is known to the client)%N.M inserts parts of the fully qualified domain name (FQDN, as it is know to the client)N and M are used to specify substrings of the FQDN. N selects from the dot-separated components of the FQDN, and M selects characters within whatever N has selected. M is optional and defaults to zero if it isn't present; the dot must be present if and only if M  is present. The interpretation is as follows:0 	the whole name1 	the first part2 	the second part-1 	the last part-2 	the penultimate part2+ 	the second and all subsequent parts-2+ 	the penultimate and all preceding parts1+ and -1+ 	the same as 0If N or M is greater than the number of parts available a single underscore is interpolated.-----The following is an example configuration for mass virtual hosting of file based content (it uses ModVhostDoc to interpret the host string produced by ModVhost):	| ma |	ma _ ModuleAssembly core.	ma virtualDocumentRoot: (FileDirectory default fullNameFor: '%0') do:		[ma directoryIndex: 'index.html index.htm'.		ma serveFiles].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.In this example, the document root for the web server will be determined using the entire FQDN as the final element in the document root.Of course, virtual hosting does not need to be restricted to file serving.  Similar to ModAlias, you can use the virtual host name to control which modules get processed.  The following is another example (it uses makes use of ModVhostAlias):	| ma |	ma _ ModuleAssembly core.	ma virtualHost: 'localhost' do:		[ma addPlug: 			[ :request |			HttpResponse fromString: 'You are seeing content for localhost']].	ma addPlug:		[ :request |		HttpResponse fromString: 'You are seeing default content'].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.In this example, you will see different content depending on whether you access the server using http://localhost:8080 or http://127.0.0.1:8080.  Another example might be hosting Seaside (see http://www.beta4.com/seaside2 for information) applications on a separate host name.!!ModVhost class methodsFor: 'instance creation' stamp: 'svp 4/16/2003 21:06'!pathTemplate: aString	^self new 		pathTemplate: aString; 		yourself! !!ModVhost class methodsFor: 'bindings' stamp: 'svp 4/17/2003 16:51'!string	^#'ModVhost-String' binding! !!ModVhost class methodsFor: 'bindings' stamp: 'svp 4/17/2003 16:51'!string: aString	#'ModVhost-String' binding: aString! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:50'!getOffsetAt: pos	| temp end val |	temp _ self template.	end _ pos.	(temp at: end) == $- ifTrue: [end _ end + 1].	[val _ temp at: end.	((val >= $0) and: [val <= $9] and: [temp size > end])] whileTrue: [end _ end + 1].	((val >= $0) and: [val <= $9]) ifTrue: [end _ end + 1].	((end <= temp size) and: [(temp at: end) = $+])		ifTrue: [^temp copyFrom: pos to: end]		ifFalse: [^temp copyFrom: pos to: (end - 1)]! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:50'!getSubstituteAt: percentPosition host: aHost andDo: aBlock	| temp nameIndex nextPos letterIndex sub |	temp _ self template.	temp size <= percentPosition ifTrue: 		[aBlock value: '%'. 		^percentPosition + 1].	(temp at: (percentPosition + 1)) = $% ifTrue: 		[aBlock value: '%'. 		^percentPosition + 2].	(temp at: (percentPosition + 1)) = $p ifTrue: 		[aBlock value: aHost port asString. 		^percentPosition + 2].	nameIndex _ self getOffsetAt: (percentPosition + 1).	nextPos _ percentPosition + 1 + nameIndex size.	((temp size >= nextPos) and: [(temp at: nextPos) = $.])		ifTrue: 			[letterIndex _ self getOffsetAt: (nextPos + 1).			nextPos _ nextPos + letterIndex size + 1]		ifFalse: 			[letterIndex _ '0'].	[sub _ aHost vhostName: nameIndex letter: letterIndex]		on: Error do: [ :ex | aBlock value: '%'. ^percentPosition + 1].	aBlock value: sub.	^nextPos! !!ModVhost methodsFor: 'testing' stamp: 'svp 5/15/2003 17:24'!isVhost	^true! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'brp 10/2/2004 15:17'!processHttp	self class string: (self stringFromHost: ModCore host).	^self processSubModules! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:50'!stringFromHost: aHost	| pos temp done nextPercent |	pos _ 1.	temp _ self template.	done _ false.	^String streamContents: [ :strm |		[done] whileFalse: 			[nextPercent _ temp indexOf: $% startingAt: pos.			nextPercent = 0 				ifTrue:					[strm nextPutAll: (temp copyFrom: pos to: temp size).					done _ true.]				ifFalse: 					[strm nextPutAll: (temp copyFrom: pos to: (nextPercent - 1)).					pos _ self 						getSubstituteAt: nextPercent 						host: aHost						andDo: [ :sub | strm nextPutAll: sub ].					pos > temp size ifTrue: [done _ true]]]].! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:48'!template	^template ifNil: [template _ '%0']! !!ModVhost methodsFor: 'as yet unclassified' stamp: 'svp 4/17/2003 16:49'!template: aString	template _ aString! !!ModVhost methodsFor: 'validation' stamp: 'svp 5/16/2003 13:03'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :module | module isCore ]		ifNone: [problems add: 'Vhost module requires a Core module']! !!ModVhostAlias commentStamp: 'svp 5/15/2003 00:54' prior: 0!See the class comments for ModVhost for using Comanche's virtual hosting features.!!ModVhostAlias methodsFor: 'accessing' stamp: 'svp 5/15/2003 00:44'!host	^host! !!ModVhostAlias methodsFor: 'accessing' stamp: 'svp 5/15/2003 00:44'!host: aString	host := aString! !!ModVhostAlias methodsFor: 'accessing' stamp: 'svp 5/15/2003 00:47'!processHttp	"Get the host string and if we match, then process	our subModules."	| hostString |	hostString := ModVhost string.	host = hostString ifTrue:		[self processSubModules ifTrue: [^true]].	^false! !!ModVhostAlias methodsFor: 'accessing' stamp: 'svp 5/16/2003 13:04'!validateForStack: anArray problems: problems	super validateForStack: anArray problems: problems.	anArray 		detect: [ :module | module isVhost ]		ifNone: [self error: 'VhostAlias module requires a Vhost module']! !!HttpAdaptor commentStamp: 'svp 5/15/2003 10:27' prior: 0!kom/4.12 (Comanche/4.12)HTTPAdaptor (kom/4.8; bolot 4/2/2001 18:48)- logging is removed from kom46 core- so is Process>>contextAt:ifAbsent:- kom48 adds rudimentary persistent connections-- see keepAliveConnection senders (also in Preferences)Comment from kom46:I encapsulate the HTTP protocol from my clients (who must support the HttpPlug interface).  I use an HttpRequest to pick apart a request and I use an HttpResponse to formulate a response.  Mainly, I broker the conversation, turning a request into a message send (to an HttpPlug) and converting the answer to an HttpResponse.  Thus, my clients must simply implement a message based protocol (eliminating the need for them to be concerned with HTTP syntax).Instance Variables:stream <Stream> - A bidirectional stream for reading and writing request (note: previously Comanche separated the readStream and writeStream, if you need to separate the read stream from the write stream you can create a new bidirectional stream class that uses two separate streams for reading and writing)httpService <HttpService> - an instance of an HttpService or a protocol compatible substitute; this object is used as the error handler and the target of http request dispatchingpostProcessors <OrderedCollection | nil> - this is a list of objects that are sent post processing messages (after the response has been written); this enables objects to request that they get called after the HttpAdaptor has actually written the response onto the write stream!!HttpAdaptor class methodsFor: 'timestamp' stamp: 'svp 5/7/2003 03:01'!buildTimeStamp: seconds	^((TimeStamp fromSeconds: seconds) minusSeconds: self timezoneOffset) printHttpFormat! !!HttpAdaptor class methodsFor: 'bindings' stamp: 'svp 5/15/2003 10:15'!current	^#'HttpAdaptor-current' binding! !!HttpAdaptor class methodsFor: 'bindings' stamp: 'svp 5/15/2003 10:15'!current: anInstance	^#'HttpAdaptor-current' binding: anInstance! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:43'!dataTimeout	"The number of seconds to wait for data to be received on a	given socket."	^#'HttpAdaptor-dataTimeout' binding ifNil: [10]! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:42'!dataTimeout: seconds	^#'HttpAdaptor-dataTimeout' binding: seconds! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:42'!keepAlive	^#'HttpAdaptor-keepAlive' binding ifNil: [true]! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:42'!keepAlive: aBoolean	^#'HttpAdaptor-keepAlive' binding: aBoolean! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:43'!maxKeepAliveRequests	"This is the maximum number of requests to allow	during a persistent connection. (zero means unlimited)."	^#'HttpAdaptor-maxKeepAliveRequests' binding ifNil: [100]! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 02:43'!maxKeepAliveRequests: anInteger	^#'HttpAdaptor-maxKeepAliveRequests' binding: anInteger! !!HttpAdaptor class methodsFor: 'instance creation' stamp: 'svp 5/15/2003 10:22'!readAndWriteTo: aStream service: httpService	^self new		initializeOn: aStream httpService: httpService;		beginConversation;		yourself! !!HttpAdaptor class methodsFor: 'instance creation' stamp: 'gk 2/22/2006 17:01'!readAndWriteToSocket: aSocket service: httpService	"Wrap the socket in a suitable SocketStream implementation	using appropriate options for timeout etc and start the conversation."	^self 		readAndWriteTo: 			((self socketStream on: aSocket)				timeout: self dataTimeout;				autoFlush: false;				yourself)		service: httpService! !!HttpAdaptor class methodsFor: 'socketstream' stamp: 'gk 2/23/2006 10:07'!socketStream	"Returns the correct class to use. If FastSocketStream is available we use it,	otherwise we use SocketStream."	^Smalltalk at: #FastSocketStream ifAbsent: [SocketStream] ! !!HttpAdaptor class methodsFor: 'timestamp' stamp: 'svp 5/7/2003 03:00'!timeStamp	| seconds |	seconds _ Time totalSeconds.	^seconds ~= LastTimeStampTime		ifTrue: 			[LastTimeStamp _ self buildTimeStamp: (LastTimeStampTime _ seconds)]		ifFalse: 			[LastTimeStamp]! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:23'!timezoneOffset	"The offset (in seconds) of the server's timezone relative to GMT."	^TimezoneOffset ifNil: [0]! !!HttpAdaptor class methodsFor: 'preferences' stamp: 'svp 5/7/2003 03:23'!timezoneOffset: aNumber	^TimezoneOffset := aNumber! !!HttpAdaptor methodsFor: 'processing' stamp: 'svp 4/23/2003 00:13'!addConnectionHeaders: response request: request count: count	response fieldAt: 'Server' put: self serverType.	response fieldAt: 'Date' put: self timeStamp.	(request isPersistent and: [self keepAlive])		ifTrue: 			[response fieldAt: 'Connection' put: 'Keep-Alive'.			response fieldAt: 'Keep-Alive' put: 				(String streamContents: 					[ :s |					s nextPutAll: 'timeout='.					s nextPutAll: self dataTimeout asString.					s nextPutAll: ', max='.					s nextPutAll: (self maxKeepAliveRequests - count) asString])]		ifFalse: 			[response fieldAt: 'Connection' put: 'close'].! !!HttpAdaptor methodsFor: 'post processing' stamp: 'svp 5/15/2003 10:13'!addPostProcessor: anObject	"Add anObject to my list of postProcessor, anObject must respond to	the message #doPostProcessingFor:response:"	(postProcessors ifNil: [postProcessors := OrderedCollection new])		add: anObject! !!HttpAdaptor methodsFor: 'processing' stamp: 'svp 9/23/2003 03:04'!beginConversation	| response request count limit continue |	"note: there is a lot of effort in this method to ensure that we don't have	and explicit method returns.  For some reason (bugs in exception handling?) we	can get errors if we have explicit returns...this behavior seems to	only happen when Seaside is also loaded (though it doesn't look like Seaside code	is being invoked when the problems happen."	count := 0.	continue := true.	limit := self maxKeepAliveRequests.	[		[request := self readRequest] on: Error do: [ :ex | continue := false].		continue ifTrue:					[[Bindings clamp:				[response := self dispatchRequest: request.				self addConnectionHeaders: response request: request count: count.				(self writeResponse: response for: request) ifFalse: [^self destroy].				self doPostProcessingFor: request response: response].			count := count + 1.			continue := response isPersistent and: [count < limit]]				ifCurtailed: [continue := false]].		continue.	] whileTrue.	self destroy.! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/7/2003 02:55'!dataTimeout	^self class dataTimeout! !!HttpAdaptor methodsFor: 'processing' stamp: 'svp 5/15/2003 17:07'!destroy	[self stream close] 		on: Error do: [ :ex | "ignore" ].! !!HttpAdaptor methodsFor: 'dispatching' stamp: 'brp 10/2/2004 15:18'!dispatchRequest: request 	"<HttpResponse> Dispatches an HttpRequest as a method to the target and	answers an HttpResponse to be transferred to the client"	| response |	response := self errorHandler handleDispatchErrorsIn: 					[self class current: self.					HttpRequest current: request.					self target processHttpRequest: request].	response ifNil: [response := self notFoundResponseFor: request].	response addCookies: request responseCookies.	^response! !!HttpAdaptor methodsFor: 'post processing' stamp: 'svp 5/15/2003 10:14'!doPostProcessingFor: request response: response	"Do the post processing for the given request/response pair and	then reset our list of post processors."	self postProcessorsDo: 		[ :ea |		ea doPostProcessingFor: request response: response].	postProcessors := nil.! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 4/22/2003 10:09'!errorHandler	^self httpService! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 4/22/2003 10:09'!httpService	^httpService! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 4/22/2003 10:04'!httpService: aComancheHttpService	httpService _ aComancheHttpService! !!HttpAdaptor methodsFor: 'initialize-release' stamp: 'svp 5/15/2003 10:21'!initializeOn: aStream httpService: anHttpService 	stream _ aStream.	httpService _ anHttpService.! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/6/2003 17:09'!keepAlive	^self class keepAlive! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/7/2003 02:57'!maxKeepAliveRequests	^self class maxKeepAliveRequests! !!HttpAdaptor methodsFor: 'dispatching' stamp: 'svp 4/22/2003 10:03'!notFoundResponseFor: request	^self httpService		errorResponseStatus: #notFound		description: ('The requested URL ', request url, ' was not found on this server').! !!HttpAdaptor methodsFor: 'post processing' stamp: 'svp 5/15/2003 10:04'!postProcessorsDo: aBlock	postProcessors ifNotNil: [postProcessors do: aBlock]! !!HttpAdaptor methodsFor: 'processing' stamp: 'svp 4/17/2003 08:49'!readRequest	^HttpRequest readFromStream: self readStream.! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/15/2003 10:22'!readStream	^self stream! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 4/22/2003 10:14'!serverType	^self httpService serverType! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/15/2003 10:22'!stream	^stream! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 4/22/2003 10:05'!target	^self httpService! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/7/2003 02:58'!timeStamp	^self class timeStamp! !!HttpAdaptor methodsFor: 'processing' stamp: 'svp 5/12/2003 17:13'!writeResponse: response for: request	"<Boolean> Answer whether or not we succeeded in writing out the	response.  If we did not, the caller may want to shut down this Http	conversation.  We try to handle errors in writing the response by 	getting and writing another response (note: this might not always work	since the error could have occurred after some data has been written	on the response stream).  For debugging, the method #handleResponseWritingError:	can #pass on the exception to allow a walkback to appear."	| errorResponse |	[[request method = 'HEAD'		ifTrue: [response writeHeadersOn: self writeStream]		ifFalse: [response writeOn: self writeStream]]			on: Error			do: 				[ :ex |				errorResponse := self errorHandler handleResponseWritingError: ex.				[errorResponse writeOn: self writeStream] on: Error do: [^false]].	] ensure: [response destroy].	^true! !!HttpAdaptor methodsFor: 'accessing' stamp: 'svp 5/15/2003 10:22'!writeStream	^self stream! !!HttpRequest commentStamp: '<historical>' prior: 0!kom/4.12 (Comanche/4.12)bolot 2/20/2002 13:53- rawUrl = the entire request string- url = rawUrl up to ?- queryString = rawUrl after the first ?- rawUrl == url?queryStringHttpRequest (bolot 4/2/2001 18:51)- HTTP request object wrapper- handles details of HTTP-- headers, formats, etc.- as of kom47, handles multipart posts- in kom49 (or kom50) a minor refactoring will happen!!HttpRequest class methodsFor: 'parsing' stamp: 'svp 5/13/2003 15:30'!addKey: key value: value toForm: dict multipleValues: boolean	boolean		ifTrue: [dict at: key put: value]		ifFalse: [(dict includesKey: key)			ifFalse: [dict at: key put: value]			ifTrue: [dict at: key modify: [:oldValue | oldValue, value]]]! !!HttpRequest class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:06'!current	^#'HttpRequest-Current' binding! !!HttpRequest class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:06'!current: anHttpRequest	#'HttpRequest-Current' binding: anHttpRequest! !!HttpRequest class methodsFor: 'parsing' stamp: 'svp 5/13/2003 15:29'!decodeUrlEncodedForm: string	^self decodeUrlEncodedForm: string multipleValues: false! !!HttpRequest class methodsFor: 'parsing' stamp: 'svp 5/13/2003 15:29'!decodeUrlEncodedForm: string multipleValues: boolean	| dict key value start end eqSignPos more |	dict _ boolean ifTrue: [HttpFormDictionary new] ifFalse: [Dictionary new].	string isEmptyOrNil ifTrue: [^dict].	more _ true.	start _ 1.	[end _ string indexOf: $& startingAt: start.	end == 0		ifTrue: [end _ string size. more _ false]		ifFalse: [end _ end - 1].	eqSignPos _ string indexOf: $= startingAt: start.	(eqSignPos > end or: [eqSignPos == 0])		ifTrue: [key _ (key _ string copyFrom: start to: end) unescapePercents.			value _ '']		ifFalse: [key _ (key _ string copyFrom: start to: eqSignPos-1) unescapePercents.			value _ (value _ string copyFrom: eqSignPos+1 to: end) unescapePercents].	self addKey: key value: value toForm: dict multipleValues: boolean.	start _ end + 2.	more] whileTrue.	^dict! !!HttpRequest class methodsFor: 'defaults' stamp: 'SVP 8/12/1999 11:39'!defaultContentType	^MIMEDocument defaultContentType! !!HttpRequest class methodsFor: 'defaults' stamp: 'SVP 8/11/1999 11:51'!defaultMethod	^'GET'! !!HttpRequest class methodsFor: 'defaults' stamp: 'SVP 8/11/1999 11:50'!defaultProtocol	^'HTTP/1.0'! !!HttpRequest class methodsFor: 'defaults' stamp: 'SVP 8/11/1999 11:51'!defaultUrl	^''! !!HttpRequest class methodsFor: 'accessing' stamp: 'bolot 12/16/2000 03:23'!endOfRequestHeaderMarker	"This marks the end of an HTTP request (two consecutive CR-LFs)"	^EndOfRequestHeaderMarker! !!HttpRequest class methodsFor: 'authentication' stamp: 'bolot 3/11/2002 14:22'!hashPassword: aPassword	^SecureHashAlgorithm new hashMessage:		(aPassword, ':', self secretWord)! !!HttpRequest class methodsFor: 'initialize-release' stamp: 'bolot 12/16/2000 09:35'!initialize	EndOfRequestHeaderMarker _ String crlf, String crlf! !!HttpRequest class methodsFor: 'parsing' stamp: 'gk 12/6/2005 21:08'!parseHttpHeader: string	| dict key value start end more colonPos fieldDelims lastKey keyValueDelim crlf |	dict _ Dictionary new.	crlf _ String crlf.	string isEmptyOrNil ifTrue: [^dict].	fieldDelims _ crlf asCharacterSet.	keyValueDelim _ $:.	more _ true.	start _ end _ 1.	lastKey _ ''.	[end _ string indexOfAnyOf: fieldDelims startingAt: start.	end == 0		ifTrue: [end _ string size. more _ false]		ifFalse: [end _ end - 1].	(end >= start and: [start < string size])		ifTrue: [			(string at: start) isSeparator				ifTrue:					[dict						at: lastKey						modify: [:item | item, (string copyFrom: start to: end)]]				ifFalse:					[colonPos _ string indexOf: keyValueDelim startingAt: start.					(colonPos > end or: [colonPos == 0])						ifTrue:							[key _ (string copyFrom: start to: end) translateToLowercase.							value _ '']						ifFalse:							[key _ (string copyFrom: start to: colonPos-1) translateToLowercase.							value _ (string copyFrom: colonPos+1 to: end) withBlanksTrimmed]].			key isEmpty				ifFalse: [dict at: key put: value.					lastKey _ key.					key _ ''].			start _ string skipDelimiters: crlf startingAt: end+1].	more] whileTrue.	^dict! !!HttpRequest class methodsFor: 'instance creation' stamp: 'bolot 12/16/2000 03:08'!readFromStream: aStream	^self new initializeFromStream: aStream! !!HttpRequest class methodsFor: 'authentication' stamp: 'bolot 3/11/2002 14:21'!secretWord	"a string used in hashing passwords"	^'ab74uihagAS'! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 3/11/2002 17:26'!clearPassword	self setCookieName: #ComanchePassword		value: 'x'		path: '/'! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:03'!contentLength	^self propertyAt: #contentLength ifAbsentPut: [		(header at: 'content-length' ifAbsent: [0]) asNumber	]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 1/4/2000 18:49'!contentType	| i contentType |	^self propertyAt: #contentType ifAbsentPut: [		contentType _ self header at: 'content-type' ifAbsent: [self defaultContentType].		contentType ifNotNil: [i _ contentType indexOf: $;. "get rid of charset field"			i > 0 ifTrue: [contentType _ contentType copyFrom: 1 to: i-1]].		contentType asLowercase]! !!HttpRequest methodsFor: 'accessing' stamp: 'DGD 7/22/2001 23:41'!cookies	"answer a dictionary with the cookies in the request"	^ self		propertyAt: #cookies		ifAbsentPut: [self				parseCookies: (self header						at: 'cookie'						ifAbsent: [''])]! !!HttpRequest methodsFor: 'defaults' stamp: 'SVP 8/12/1999 11:40'!defaultContentType	^self class defaultContentType! !!HttpRequest methodsFor: 'defaults' stamp: 'SVP 8/11/1999 11:52'!defaultMethod	^self class defaultMethod! !!HttpRequest methodsFor: 'defaults' stamp: 'SVP 8/11/1999 11:52'!defaultProtocol	^self class defaultProtocol! !!HttpRequest methodsFor: 'defaults' stamp: 'SVP 8/12/1999 11:40'!defaultUrl	^self class defaultUrl! !!HttpRequest methodsFor: 'initialize-release' stamp: 'bolot 12/16/2000 01:04'!destroy	stream close.	stream _ nil! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:08'!endOfRequestHeaderMarker	^self class endOfRequestHeaderMarker! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 1/17/2003 10:36'!fields	"Answer the fields (post or get) for the given request"	| tmp |	^self propertyAt: #fields ifAbsentPut:		[tmp _ self getFields copy.		self postFields associationsDo: [ :assn | tmp add: assn].		tmp]! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 5/15/2003 12:48'!firstLineOn: strm	strm nextPutAll: self method.	strm nextPut: $ .	strm nextPutAll: self rawUrl.	strm nextPut: $ .	strm nextPutAll: self protocol.! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 5/13/2003 15:31'!getFields	"retrieve fields encoded in the URL: http://aha/ha?a=1&b=2"	| in |	^self propertyAt: #getFields ifAbsentPut: [		((in _ rawUrl indexOf: $?) > 0) ifTrue: [			self class decodeUrlEncodedForm: 				(rawUrl copyFrom: (in + 1) to: rawUrl size)				multipleValues: self multiValueFormFields		] ifFalse: [			self multiValueFormFields				ifTrue: [HttpFormDictionary new]				ifFalse: [Dictionary new].		].	]! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 3/11/2002 14:19'!getUsername	^self cookies at: #ComancheUsername ifAbsent: []! !!HttpRequest methodsFor: 'user authentication' stamp: 'brp 10/2/2004 14:21'!hashPassword: aPassword 	^ self class hashPassword: aPassword! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:13'!header	^header! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 09:18'!header: aDict	header _ aDict! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 4/18/2003 09:27'!headerAt: aKey	^ header at: aKey! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 4/18/2003 09:27'!headerAt: aKey ifAbsent: aBlock	^ header at: aKey ifAbsent: aBlock! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 2/11/2001 01:23'!host	^self propertyAt: #host ifAbsentPut: [self header at: 'host' ifAbsent: []]! !!HttpRequest methodsFor: 'initialize-release' stamp: 'brp 10/2/2004 16:18'!initRemoteAddress	self remoteAddress: stream socket remoteAddress! !!HttpRequest methodsFor: 'initialize-release' stamp: 'gk 11/4/2004 12:44'!initStatusString: aString 	| statusLine |	statusLine := aString findTokens: ' '.	(statusLine size between: 2 and: 3) 		ifTrue: 			[self method: statusLine first.			rawUrl := statusLine second.			url := (rawUrl copyUpTo: $?) unescapePercents.			url size + 1 < rawUrl size 				ifTrue: [self queryString: (rawUrl copyFrom: url size + 2 to: rawUrl size)].			self protocol: statusLine third asUppercase]		ifFalse: [^self error: 'invalid http status line']! !!HttpRequest methodsFor: 'initialize-release' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.	properties := IdentityDictionary new! !!HttpRequest methodsFor: 'initialize-release' stamp: 'svp 3/4/2003 14:38'!initializeFromStream: aStream	stream _ aStream.	self initRemoteAddress.	self timestamp: Time totalSeconds.	self readRequestHeaderFrom: stream.! !!HttpRequest methodsFor: 'testing' stamp: 'SVP 8/25/1999 08:55'!isGetRequest	^self method = 'GET'! !!HttpRequest methodsFor: 'testing' stamp: 'SVP 8/25/1999 08:55'!isHeaderRequest	^self method = 'HEAD'! !!HttpRequest methodsFor: 'testing' stamp: 'svp 4/15/2003 00:51'!isPersistent	| proto answer |	self propertyAt: #persistentConnection ifPresent: [ :x | ^x ].	proto _ self protocol.	"If we can't figure out the protocol, default to non-persistent connections"	answer _ false.	"For HTTP/1.0, the default is non-persistent connections"	proto = 'HTTP/1.0' ifTrue:		[answer _ (self header at: 'connection' ifAbsent: ['']) 			asLowercase = 'keep-alive'].	"For HTTP/1.1, the default is persistent connections"	proto = 'HTTP/1.1' ifTrue:		[answer _ (self header at: 'connection' ifAbsent: ['']) 			asLowercase ~= 'close'].	self propertyAt: #persistentConnection put: answer.	^answer! !!HttpRequest methodsFor: 'testing' stamp: 'gk 11/3/2003 13:14'!isPostMultipart	"Is this request a POST with multipart form data?"	^self isPostRequest and: [self contentType = MIMEDocument contentTypeMultipart]! !!HttpRequest methodsFor: 'testing' stamp: 'SVP 8/25/1999 08:55'!isPostRequest	^self method = 'POST'! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 3/11/2002 17:46'!isUsername: aUsername password: aPassword	| pwHash cookieUsername cookiePassword |	cookieUsername _ self cookies at: #ComancheUsername ifAbsent: [^false].	cookieUsername = aUsername ifFalse: [^false].	cookiePassword _ self cookies at: #ComanchePassword ifAbsent: [^false].	pwHash _ self hashPassword: aPassword.	^cookiePassword = pwHash asString! !!HttpRequest methodsFor: 'accessing' stamp: 'brp 10/2/2004 16:18'!localAddress	"Answer the address of the request originator"	^self propertyAt: #localAddress		ifAbsentPut: 			[stream socket localAddress]! !!HttpRequest methodsFor: 'accessing' stamp: 'brp 10/2/2004 16:18'!localPort	"Answer the address of the request originator"	^self propertyAt: #localPort		ifAbsentPut: 			[stream socket localPort]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:14'!method	^self propertyAt: #method ifAbsent: ['GET']! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/19/2000 00:16'!method: aString	self propertyAt: #method put: aString! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 5/2/2002 17:30'!multiValueFormFields	^self propertyAt: #multiValueFormFields ifAbsent: [false]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 5/2/2002 18:01'!multiValueFormFieldsDisable	"disable use of multi-value form fields"	"thus, if the status changed, need to expunge GET/POST fields if already parsed"	self multiValueFormFields		ifTrue: [self propertyAt: #multiValueFormFields put: false.			self removePropertyAt: #getFields ifAbsent: [].			self removePropertyAt: #postFields ifAbsent: [].						]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 5/2/2002 18:00'!multiValueFormFieldsEnable	"enable use of multi-value form fields"	"thus, if the status changed, need to expunge GET/POST fields if already parsed"	self multiValueFormFields		ifFalse: [self propertyAt: #multiValueFormFields put: true.			self removePropertyAt: #getFields ifAbsent: [].			self removePropertyAt: #postFields ifAbsent: [].						]! !!HttpRequest methodsFor: 'multipart forms' stamp: 'svp 5/13/2003 13:59'!multipartBoundary	| str idx |	"boundary specification in the HTTP header looks like:	Content-Type: multipart/form-data; boundary=BOUNDARY "	^self propertyAt: #multipartBoundary ifAbsentPut:		[(self contentType beginsWith: MIMEDocument contentTypeMultipart)			ifTrue: ["contentType gets lowercased, so access the raw header"				str _ header at: 'content-type' ifAbsent: [ '' ].				idx _ str indexOf: $=.				'--', (str copyFrom: idx + 1 to: str size)]			ifFalse: [ nil ]]! !!HttpRequest methodsFor: 'multipart forms' stamp: 'gk 12/6/2005 21:56'!multipartFormFieldsDo: aBlock	"USAGE:	request multipartFormFieldsDo: 		[:chunk |		chunk saveToStream: aStream]."	"NOTE: if the chunk is not saved, save it after aBlock"	| mChunk aFieldValue |	(self method = 'POST' and: [self contentType = MIMEDocument contentTypeMultipart])		ifFalse: [^nil].	stream peekForAll: self multipartBoundary.	[stream atEnd or: [stream peekForAll: '--']] whileFalse:		[stream next: 2.  "Advance over CRLF"		mChunk := self nextChunkHeader.		aBlock value: mChunk.		mChunk isSaved ifFalse: 			[mChunk fileName isEmptyOrNil			ifFalse: [mChunk saveToStream: (DummyStream on: String new)]			ifTrue:				[aFieldValue := String streamContents: 					[:aStream |					mChunk saveToStream: aStream].				self postFields at: mChunk fieldName put: aFieldValue]]].	stream next: 2 "Advance over CRLF"! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 1/21/2003 21:40'!networkHost	^self propertyAt: #networkHost ifAbsentPut: 		[NetworkHost fromString: self host].! !!HttpRequest methodsFor: 'multipart forms' stamp: 'svp 10/28/2003 12:16'!nextChunkHeader	"Read the next multipart data chunk's header"	| string dict mChunk |	string _ stream upToAll: self endOfRequestHeaderMarker.	dict _ self class parseHttpHeader: string.	mChunk _ MultipartChunk from: dict.	mChunk stream: self stream.	mChunk multipartBoundary: self multipartBoundary.	^mChunk! !!HttpRequest methodsFor: 'private' stamp: 'brp 10/2/2004 15:36'!parseCookies: aString 	"PRIVATE: Parse a string in the format:  	Cookie: NAME1=OPAQUE_STRING1; NAME2=OPAQUE_STRING2 ..."	| dict |	dict := Dictionary new.	(aString findTokens: ';') do: 			[:pairStr | 			| pair |			pair := pairStr findTokens: '='.			pair size = 2 				ifTrue: 					[| key value |					key := pair first withBlanksTrimmed asSymbol.					value := pair second withBlanksTrimmed.					dict at: key put: value]				ifFalse: 					["self log: 'Cookie invalid pair format: ''' , pairStr , ''''"					]].	^dict! !!HttpRequest methodsFor: 'as yet unclassified' stamp: 'svp 2/6/2003 22:38'!pathParts	^self url findTokens: '/'! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 5/13/2003 15:31'!postFields	"Answer the multipart fields for a post request (if in fact this is a	POST request"	^self propertyAt: #postFields ifAbsentPut: [		" parse POST fields in the body of request, if it's standard form data "		(self isPostRequest and: [ 			self contentType = MIMEDocument contentTypeFormData 		]) ifTrue: [			self class				decodeUrlEncodedForm: self rawPostFields				multipleValues: true.		] ifFalse: [			Dictionary new		].	]! !!HttpRequest methodsFor: 'printing' stamp: 'bolot 12/16/2000 02:09'!printOn: printStream	printStream nextPutAll: self class name;		nextPutAll: ' (URL=', self url asString;		nextPutAll: '; protocol=', self protocol asString;		nextPutAll: '; header=', self header asString;		nextPutAll: '; getFields=', self getFields asString;		nextPutAll: '; postFields=', self postFields asString;		nextPutAll: ')'! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!propertyAt: aSymbol	^properties at: aSymbol! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!propertyAt: aSymbol ifAbsent: absentBlock	^properties at: aSymbol ifAbsent: absentBlock! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!propertyAt: aSymbol ifAbsentPut: absentBlock	^properties at: aSymbol ifAbsentPut: absentBlock! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!propertyAt: aSymbol ifPresent: presentBlock	^properties at: aSymbol ifPresent: presentBlock! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!propertyAt: aSymbol put: anObject	properties at: aSymbol put: anObject! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:57'!protocol	^self propertyAt: #protocol ifAbsent: [self defaultProtocol]! !!HttpRequest methodsFor: 'accessing' stamp: 'svp 4/14/2003 22:18'!protocol: aString	^self propertyAt: #protocol put: aString! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 2/20/2002 13:51'!queryString	^self propertyAt: #queryString ifAbsent: [ nil ]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 2/20/2002 13:51'!queryString: aString	^self propertyAt: #queryString put: aString! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 5/2/2002 17:34'!rawPostFields	"save the POST form fields as is, for future processing, see #postFields"	"reasons: 1) lazy form processing;		2) allow the app to specify whether it wants multiple values for fields"	^self propertyAt: #rawPostFields ifAbsentPut: [		(self isPostRequest and: [ 			self contentType = MIMEDocument contentTypeFormData 		]) ifTrue: [			stream next: self contentLength		] ifFalse: [			''		].	]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:58'!rawUrl	^rawUrl! !!HttpRequest methodsFor: 'initialize-release' stamp: 'jf 3/6/2004 20:04'!readRequestHeaderFrom: aStream	| reqHeader |	reqHeader _ ReadStream on: 		(aStream upToAll: self endOfRequestHeaderMarker).	self initStatusString: (self readStatusStringFrom: reqHeader).	self header: (self class parseHttpHeader: reqHeader upToEnd).	self rawPostFields. "force reading/parsing post fields"! !!HttpRequest methodsFor: 'initialize-release' stamp: 'jf 3/6/2004 20:09'!readStatusStringFrom: aStream	"RFC 2068 says in section 4.1 (Message Types) that 'In the interest of	robustness, servers SHOULD ignore any empty line(s) received where	a Request-Line is expected', so we ignore any leading CR/LF's"		| status |	status _ ''.	[status isEmpty and: [aStream atEnd not]]		whileTrue: [status _ aStream upToAll: String crlf].			^ status! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:57'!referer	^self propertyAt: #referer ifAbsentPut: [		header at: 'referer' ifAbsent: [ nil ]	]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:57'!remoteAddress	^self propertyAt: #remoteAddress ifAbsent: [nil]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 09:18'!remoteAddress: aRemoteAddress	self propertyAt: #remoteAddress put: aRemoteAddress! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!removePropertyAt: aSymbol	properties removeKey: aSymbol! !!HttpRequest methodsFor: 'properties' stamp: 'svp 4/15/2003 00:21'!removePropertyAt: aSymbol ifAbsent: aBlock	^properties removeKey: aSymbol ifAbsent: aBlock! !!HttpRequest methodsFor: 'response cookies' stamp: 'bolot 3/11/2002 14:39'!responseCookies	"cookies that need to be set"	^self propertyAt: #responseCookies ifAbsentPut: [OrderedCollection new]! !!HttpRequest methodsFor: 'user authentication' stamp: 'brp 10/2/2004 14:21'!secretWord	^ self class secretWord! !!HttpRequest methodsFor: 'user authentication' stamp: 'brp 10/2/2004 17:02'!session	^ KomSession current! !!HttpRequest methodsFor: 'response cookies' stamp: 'bolot 3/11/2002 14:39'!setCookieName: nameString value: valueString expiresDate: expiresDate expiresTime: expiresTime path: pathString domain: domainString secure: secureBoolean 	"set a cookie in the Response"	| temp |	temp _ String new writeStream.	"NAME=VALUE"	temp nextPutAll: nameString;		 nextPut: $=;		 nextPutAll: valueString.	"; expires=Wdy, DD-Mon-YYYY HH:MM:SS GMT"	(expiresDate notNil and:[ expiresTime notNil])		ifTrue: [temp nextPutAll: '; expires=';				 nextPutAll: expiresDate weekday;				 nextPutAll: ', '.			expiresDate printOn: temp format: #(1 2 3 $- 2 2 2 ).			temp nextPutAll: ' ';				 nextPutAll: expiresTime print24;				 nextPutAll: ' GMT'].	"; path=PATH"	pathString notNil		ifTrue: [temp nextPutAll: '; path=';				 nextPutAll: pathString].	"; domain=DOMAIN"	domainString notNil		ifTrue: [temp nextPutAll: '; domain=';				 nextPutAll: domainString].	"; secure"	(secureBoolean notNil			and: [secureBoolean])		ifTrue: [temp nextPutAll: '; secure'].	""	self responseCookies add: temp contents! !!HttpRequest methodsFor: 'response cookies' stamp: 'bolot 3/11/2002 14:40'!setCookieName: nameString value: valueString path: pathString 	"set a cookie in the Response"	self		setCookieName: nameString		value: valueString		expiresDate: nil		expiresTime: nil		path: pathString		domain: nil		secure: nil! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 3/11/2002 17:35'!setUsername: aUsername	"save the username in a cookie"	"make it expire very far into the future"	self		setCookieName: #ComancheUsername		value: aUsername		expiresDate: (Date today addDays: 1000)		expiresTime: Time now		path: '/'		domain: nil		secure: nil.	self flag: #todo.	"allow for multiple usernames"! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 3/11/2002 17:35'!setUsername: aUsername password: aPassword	"save the username/password in cookies"	| pwHash |	self setUsername: aUsername.	pwHash _ self hashPassword: aPassword.	self		setCookieName: #ComanchePassword		value: pwHash asString		expiresDate: (Date today addDays: 1000)		expiresTime: Time now		path: '/'		domain: nil		secure: nil.	self flag: #todo.	"allow for multiple usernames"! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:59'!stream	^stream! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:00'!timestamp	^self propertyAt: #timestamp ifAbsent: [ nil ]! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:00'!timestamp: aTimestamp	self propertyAt: #timestamp put: aTimestamp! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 12/16/2000 01:58'!url	^url! !!HttpRequest methodsFor: 'accessing' stamp: 'bolot 6/21/2001 04:03'!url: aUrl	url _ aUrl! !!HttpRequest methodsFor: 'accessing' stamp: 'brp 10/2/2004 14:56'!user	"currently, only basic authentication is supported"	| userID i |	userID := self header at: 'authorization' ifAbsent: [^nil].	userID := (userID notNil and: [(i := userID findString: 'Basic ') > 0]) 		ifTrue: [userID copyFrom: i + 6 to: userID size]		ifFalse: [nil].	^userID! !!HttpRequest methodsFor: 'user authentication' stamp: 'bolot 2/18/2002 19:24'!userObject: anObject	^self session ifNotNil: [self session userObject: anObject]! !!HttpRequest methodsFor: 'printing' stamp: 'svp 4/15/2003 18:22'!writeOn: aStream	"this can be used to form a client-side request and send it over network"	aStream nextPutAll: self method, ' ', self url, ' ', self protocol, String crlf.	self header keysAndValuesDo: [:key :value |		aStream nextPutAll: key, ': ', value, String crlf].	aStream nextPutAll: String crlf.	"aStream nextPutAll: self body asString"! !!HttpResponse commentStamp: '<historical>' prior: 0!kom/4.12 (Comanche/4.12)bolot 2/20/2002 13:55- cookies support- defaultChunkSize delegates to Kom5PreferencesHttpResponse (bolot 4/2/2001 18:52)Comment from kom46:I am a response to an HttpRequest.  I can formulate an HTTP response and send it out over a socket.  An HttpAdapter will accept an HttpRequest, dispatch a method call to an HttpPlug (which will result in a stream or an error), and then formulat an instance of me to deliver the response to the client.!!HttpPartialResponse commentStamp: '<historical>' prior: 0!kom/4.12 (Comanche/4.12)HttpPartialResponse (bolot 4/2/2001 18:49)- not a very accurate name- a subclass of HttpResponse-- allows for long-execution modules to write directly to the client!!HttpPartialResponse methodsFor: 'accessing' stamp: 'bolot 1/11/2001 17:49'!producerBlock: aBlock	producerBlock _ aBlock! !!HttpPartialResponse methodsFor: 'responding' stamp: 'bolot 1/11/2001 17:50'!pvtWriteContentLengthOn: aStream	"do nothing, since the length is not known yet"	self flag: #todo. "in HTTP/1.1, can set chunking"! !!HttpPartialResponse methodsFor: 'responding' stamp: 'bolot 1/11/2001 17:49'!pvtWriteContentsOn: aStream	producerBlock value: aStream! !!HttpResponse class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:06'!current	^#'HttpResponse-Current' binding! !!HttpResponse class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:07'!current: anHttpResponse	#'HttpResponse-Current' binding: anHttpResponse! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/12/2003 16:10'!fromFileStream: aStream	^self basicNew		status: #ok;		"fieldAt: 'Expires' put: 'Thu, 15 Apr 2010 20:00:00 GMT';"		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: aStream mimeType;		contents: aStream;		yourself	! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/13/2003 17:09'!fromMIMEDocument: aMIMEDoc	| content |	content := aMIMEDoc content.	content isString ifTrue:		[content _ ReadStream on: content].	^self basicNew		status: #ok;		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: aMIMEDoc mimeType;		contents: content;		yourself	! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/12/2003 16:10'!fromStream: aStream	^self basicNew		status: #ok;		"fieldAt: 'Expires' put: 'Thu, 15 Apr 2010 20:00:00 GMT';"		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: aStream mimeType;		contents: aStream;		yourself	! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/13/2003 17:11'!fromStream: aStream contentType: mimeTypeString	^self basicNew		status: #ok;		"fieldAt: 'Expires' put: 'Thu, 15 Apr 2010 20:00:00 GMT';"		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: mimeTypeString;		contents: aStream;		yourself	! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/12/2003 16:10'!fromString: aString	^self basicNew		status: #ok;		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: MIMEDocument contentTypeHtml;		contents: (ReadStream on: aString);		yourself! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/13/2003 17:13'!fromString: aString contentType: contentTypeString	^self basicNew		status: #ok;		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: contentTypeString;		contents: (ReadStream on: aString);		yourself! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/12/2003 16:10'!fromUrl: aUrl	^self basicNew		status: #tempMoved;		fieldAt: 'Location' put: aUrl asString;		contentType: MIMEDocument contentTypeHtml;		contents: (ReadStream on: '<head><title>Object moved</title></head><body><h1>Object Moved</h1>This object may be found <a HREF="', aUrl asString,'">here</a>.</body>');		yourself! !!HttpResponse class methodsFor: 'initialization' stamp: 'SVP 8/16/1999 16:43'!initialize	"  HttpResponse initialize  "	self initializeStatusCodes.! !!HttpResponse class methodsFor: 'initialization' stamp: 'svp 10/28/2003 13:15'!initializeStatusCodes	"  HttpResponse initializeStatusCodes  "	StatusCodes _ IdentityDictionary new		at: #processing			put: ('102' -> 'Processing'); 				"WebDav RFC: 2518"		at: #ok					put: ('200' -> 'OK');		at: #created				put: ('201' -> 'Created');		at: #accepted			put: ('202' -> 'Accepted');		at: #noContent			put: ('204' -> 'No Content');		at: #multiStatus			put: ('207' -> 'Multi-Status'); 			"WebDav RFC: 2518"		at: #permMoved			put: ('301' -> 'Moved Permanently');		at: #tempMoved			put: ('302' -> 'Moved Temporarily');		at: #notModified			put: ('304' -> 'Not Modified');		at: #badRequest			put: ('400' -> 'Bad Request');		at: #unauthorized		put: ('401' -> 'Unauthorized');		at: #forbidden			put: ('403' -> 'Forbidden');		at: #notFound			put: ('404' -> 'Not Found');		at: #unprocessableEntity	put: ('422' -> 'Unprocessable Entity'); 	"WebDav RFC: 2518"		at: #locked				put: ('423' -> 'Locked'); 					"WebDav RFC: 2518"		at: #failedDependency	put: ('424' -> 'Failed Dependency'); 		"WebDav RFC: 2518"		at: #serverError			put: ('500' -> 'Internal Server Error');		at: #notImplemented		put: ('501' -> 'Not Implemented');		at: #badGateway		put: ('502' -> 'Bad Gateway');		at: #serviceUnavailable	put: ('503' -> 'Service Unavailable');		at: #InsufficientStorage	put: ('507' -> 'Insufficient Storage'); 	"WebDav RFC: 2518" 		yourself.	"Initialize an inverse mapping to lookup a symbol based on the numeric code"	StatusSymbols := Dictionary new.	StatusCodes associationsDo: 		[ :assn |		StatusSymbols at: assn value key asNumber put: assn key].! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/12/2003 16:28'!new	^self basicNew		status: #ok;		"fieldAt: 'Cache-Control' put: 'max-age=86400';"		contentType: MIMEDocument contentTypeHtml;		contents: (ReadStream on: 'This is a simple HttpResponse');		yourself! !!HttpResponse class methodsFor: 'instance creation' stamp: 'gk 10/22/2003 16:10'!redirectTo: url	"Create a redirection response."	^(HttpResponse			status: #tempMoved			contents: 'Temporarily moved to: <A HREF="', url, '">', url, '</A>')		fieldAt: 'Location' put: url;		fieldAt: 'URI' put: url; yourself! !!HttpResponse class methodsFor: 'preferences' stamp: 'svp 5/7/2003 04:13'!responseChunkSize	"This is the maximum number of bytes of the content stream that are written 	to the output stream during each iteration of the writing loop."	^#'HttpResponse-responseChunkSize' binding ifNil: [131072]! !!HttpResponse class methodsFor: 'preferences' stamp: 'svp 5/7/2003 04:10'!responseChunkSize: anInteger	^#'HttpResponse-responseChunkSize' binding: anInteger! !!HttpResponse class methodsFor: 'instance creation' stamp: 'svp 5/16/2003 23:08'!status: aSymbol contents: aString	^self basicNew		status: aSymbol;		contentType: MIMEDocument contentTypeHtml;		contents: (ReadStream on: aString);		yourself! !!HttpResponse class methodsFor: 'accessing' stamp: 'svp 4/15/2003 09:20'!statusCodeFor: aSymbol	^(StatusCodes at: aSymbol) key! !!HttpResponse class methodsFor: 'accessing' stamp: 'svp 4/15/2003 09:21'!statusDescriptionFor: aSymbol	^(StatusCodes at: aSymbol) value! !!HttpResponse class methodsFor: 'accessing' stamp: 'svp 10/28/2003 13:14'!statusSymbolFor: aCode	^StatusSymbols at: aCode asNumber ifAbsent: [#serverError]! !!HttpResponse methodsFor: 'accessing-cookies' stamp: 'svp 4/15/2003 01:08'!addCookies: newCookies		self cookies addAll: newCookies.! !!HttpResponse methodsFor: 'comanche processing' stamp: 'bolot 1/11/2001 17:51'!asHttpPartialResponseBlock: aBlock	^(self as: HttpPartialResponse)		producerBlock: aBlock;		yourself! !!HttpResponse methodsFor: 'comanche processing'!asHttpResponseTo: aRequest	^self! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 5/16/2003 23:54'!contentLength	^contentLength! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/16/1999 11:54'!contentType	^contentType! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/16/1999 11:54'!contentType: aMimeType	contentType _ aMimeType! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/16/1999 11:53'!contents	^contents! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 5/16/2003 23:54'!contents: aStream	contents := aStream.	contentLength := aStream size.! !!HttpResponse methodsFor: 'accessing-cookies' stamp: 'DGD 7/20/2001 00:25'!cookies^ cookies ifNil:[cookies _ OrderedCollection new]! !!HttpResponse methodsFor: 'defaults' stamp: 'SVP 8/12/1999 14:08'!defaultContentType	^MIMEDocument contentTypeHtml! !!HttpResponse methodsFor: 'initialize-release' stamp: 'SVP 8/26/1999 08:06'!destroy	self contents close.! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 11/17/1999 11:08'!fieldAt: aString	^self fields at: aString! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 11/17/1999 11:08'!fieldAt: aString ifAbsent: absBlock	^self fields at: aString ifAbsent: absBlock! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 11/17/1999 11:08'!fieldAt: aString ifAbsentPut: absBlock	^self fields at: aString ifAbsentPut: absBlock! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 11/17/1999 11:07'!fieldAt: aString put: aValue	self fields at: aString put: aValue! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 4/22/2003 00:12'!fields	^fields ifNil: [fields _ Dictionary new]! !!HttpResponse methodsFor: 'authentication' stamp: 'bolot 3/11/2002 14:22'!hashPassword: aPassword	^HttpRequest hashPassword: aPassword! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 12/16/1999 11:33'!httpVersion	^'HTTP/1.1'! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 4/15/2003 01:00'!isPersistent	^(self fieldAt: 'Connection') = 'Keep-Alive'! !!HttpResponse methodsFor: 'responding' stamp: 'svp 5/16/2003 23:56'!pvtWriteContentLengthOn: aStream	self contentLength ifNotNilDo:		[ :length |		aStream			nextPutAll: 'Content-length: ';			nextPutAll: length asString;			nextPutAll: String crlf]! !!HttpResponse methodsFor: 'responding' stamp: 'bolot 12/16/2000 09:27'!pvtWriteContentTypeOn: aStream	aStream		nextPutAll: 'Content-type: ';		nextPutAll: self contentType;		nextPutAll: String crlf! !!HttpResponse methodsFor: 'responding' stamp: 'svp 5/7/2003 04:13'!pvtWriteContentsOn: aStream	| chunkSize cnts |	chunkSize _ self responseChunkSize.	cnts _ self contents.	[cnts atEnd] whileFalse: 		[aStream nextPutAll: (cnts next: chunkSize); flush]! !!HttpResponse methodsFor: 'responding' stamp: 'svp 4/15/2003 01:10'!pvtWriteCookiesOn: aStream 	self cookies		do: [:cookie | aStream nextPutAll: 'Set-Cookie: ';				 nextPutAll: cookie;				 nextPutAll: String crlf]! !!HttpResponse methodsFor: 'responding' stamp: 'svp 4/22/2003 00:19'!pvtWriteFieldsOn: aStream	fields isEmptyOrNil ifTrue: [ ^self ].	fields keysAndValuesDo: [ :k :v |		aStream			nextPutAll: k;			nextPutAll: ': ';			nextPutAll: v;			nextPutAll: String crlf	]! !!HttpResponse methodsFor: 'responding' stamp: 'bolot 12/16/2000 09:29'!pvtWriteStatusOn: aStream	aStream		nextPutAll: self httpVersion;		nextPut: $ ;		nextPutAll: self statusCodeAndReason;		nextPutAll: String crlf! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 5/7/2003 04:13'!responseChunkSize	^self class responseChunkSize! !!HttpResponse methodsFor: 'authentication' stamp: 'bolot 3/11/2002 14:22'!secretWord	^HttpRequest secretWord! !!HttpResponse methodsFor: 'accessing-cookies' stamp: 'DGD 7/20/2001 00:30'!setCookieName: nameString value: valueString expiresDate: expiresDate expiresTime: expiresTime path: pathString domain: domainString secure: secureBoolean 	"set a cookie in the Response"	| temp |	temp _ String new writeStream.	"NAME=VALUE"	temp nextPutAll: nameString;		 nextPut: $=;		 nextPutAll: valueString.	"; expires=Wdy, DD-Mon-YYYY HH:MM:SS GMT"	(expiresDate notNil and:[ expiresTime notNil])		ifTrue: [temp nextPutAll: '; expires=';				 nextPutAll: expiresDate weekday;				 nextPutAll: ', '.			expiresDate printOn: temp format: #(1 2 3 $- 2 2 2 ).			temp nextPutAll: ' ';				 nextPutAll: expiresTime print24;				 nextPutAll: ' GMT'].	"; path=PATH"	pathString notNil		ifTrue: [temp nextPutAll: '; path=';				 nextPutAll: pathString].	"; domain=DOMAIN"	domainString notNil		ifTrue: [temp nextPutAll: '; domain=';				 nextPutAll: domainString].	"; secure"	(secureBoolean notNil			and: [secureBoolean])		ifTrue: [temp nextPutAll: '; secure'].	""	self cookies add: temp contents! !!HttpResponse methodsFor: 'accessing-cookies' stamp: 'DGD 7/20/2001 00:24'!setCookieName: nameString value: valueString path: pathString 	"set a cookie in the Response"	self		setCookieName: nameString		value: valueString		expiresDate: nil		expiresTime: nil		path: pathString		domain: nil		secure: nil! !!HttpResponse methodsFor: 'authentication' stamp: 'bolot 3/11/2002 14:12'!setUsername: aUsername	"save the username in a cookie"	self		setCookieName: #ComancheUsername		value: aUsername		path: '/'.	self flag: #todo.	"allow for multiple usernames"! !!HttpResponse methodsFor: 'authentication' stamp: 'bolot 3/11/2002 17:30'!setUsername: aUsername password: aPassword	"save the username/password in cookies"	| pwHash |	self setUsername: aUsername.	pwHash _ self hashPassword: aPassword.	self		setCookieName: #ComanchePassword		value: pwHash asString		path: '/'.	self flag: #todo.	"allow for multiple usernames"! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/16/1999 11:53'!status	^status! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/16/1999 11:53'!status: aSymbol	status _ aSymbol! !!HttpResponse methodsFor: 'accessing' stamp: 'svp 11/18/1999 13:03'!statusCode	^(StatusCodes at: self status) key.! !!HttpResponse methodsFor: 'accessing' stamp: 'SVP 8/26/1999 10:41'!statusCodeAndReason	| tmp |	tmp _ StatusCodes at: self status.	^tmp key, ' ', tmp value.! !!HttpResponse methodsFor: 'responding' stamp: 'svp 5/15/2003 12:50'!writeHeadersOn: aStream	| tmp |	"Header"	tmp _ WriteStream on: ''.	self pvtWriteStatusOn: tmp.	self pvtWriteFieldsOn: tmp.	self pvtWriteCookiesOn: tmp.	self pvtWriteContentTypeOn: tmp.	self pvtWriteContentLengthOn: tmp.	tmp nextPutAll: String crlf.	aStream nextPutAll: tmp contents; flush.! !!HttpResponse methodsFor: 'responding' stamp: 'svp 4/22/2003 01:13'!writeOn: aStream	self writeHeadersOn: aStream.	self pvtWriteContentsOn: aStream.! !!KomAuthDb commentStamp: 'svp 5/14/2003 22:56' prior: 0!I am a very basic authentication database.  My passwords instvar is a dictionary whose keys are user names and values are hexadecimal encodings of passwords.  Subclasses could override the encode: and decode:using: methods to provide a better "encryption" of the passwords.  That wasn't done in this class because it would add a dependency on the cryptography package.  I am designed to be used with ModAuth, which sends us the message #verifyPassword:forUser: to validate user ids and passwords.!!KomAuthDb class methodsFor: 'instance creation' stamp: 'svp 5/14/2003 17:35'!new	^super new initialize! !!KomAuthDb methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:20'!addUser: aString withPassword: password	self passwords at: aString put: (self encode: password)! !!KomAuthDb methodsFor: 'encode-decode' stamp: 'svp 5/14/2003 17:31'!decode: encodedPassword using: aPassword	^String streamContents: 		[ :strm |		1 to: encodedPassword size by: 2 do: 			[ :in |			strm nextPut: 				(Character value: 					(((('0123456789ABCDEF' indexOf: (encodedPassword at: in)) - 1) * 16) +					(('0123456789ABCDEF' indexOf: (encodedPassword at: (in + 1))) - 1)))]]! !!KomAuthDb methodsFor: 'encode-decode' stamp: 'svp 5/14/2003 17:30'!encode: password	^String streamContents: 		[ :strm |		password do: [ :ea | strm nextPutAll: ea hex]]! !!KomAuthDb methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:36'!includesUser: userName	^self passwords includesKey: userName! !!KomAuthDb methodsFor: 'initialize-release' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.	passwords := Dictionary new! !!KomAuthDb methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:32'!passwords	^passwords! !!KomAuthDb methodsFor: 'accessing' stamp: 'svp 5/14/2003 17:36'!removeUser: userName	^self passwords removeKey: userName! !!KomAuthDb methodsFor: 'password verification' stamp: 'svp 5/14/2003 17:37'!verifyPassword: aPassword forUser: userName	(self includesUser: userName) ifFalse: [^false].	^(self decode: (self passwords at: userName) using: aPassword) = aPassword! !!KomModuleValidator methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 13:10'!doComancheModule: aComancheModule	"This method assumes that module traversal happens in depth first order"	aComancheModule validateContext: self problems! !!KomModuleValidator methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:50'!problems	^problems ifNil: [problems := OrderedCollection new]! !!KomModuleVisitor methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:30'!doBlock: aBlock	aBlock numArgs = 1 ifTrue: [self doMonadicValuable: aBlock].	aBlock numArgs = 1 ifTrue: [self doDyadicValuable: aBlock]! !!KomModuleVisitor methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:31'!doComancheModule: aComancheModule	"For visiting a module hierarchy"! !!KomModuleVisitor methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:32'!doDyadicValuable: aDyadicValuable	"By default, do nothing since these aren't really modules"! !!KomModuleVisitor methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:32'!doMessageSend: aMessageSend	aMessageSend arguments size = 1 ifTrue: [^self doMonadicValuable: aMessageSend].	aMessageSend arguments size = 2 ifTrue: [^self doDyadicValuable: aMessageSend]! !!KomModuleVisitor methodsFor: 'as yet unclassified' stamp: 'svp 5/16/2003 12:28'!doMonadicValuable: aMonadicValuable	"By default, do nothing since these aren't really modules"! !!KomSession commentStamp: 'svp 5/15/2003 16:38' prior: 0!I am a session and am used by ModSession to associate sessions with incoming http requests.  After a period of inactivity, sessions are expired.Notes: This class is a hold over from the old HttpSession class.  This class was renamed because it is not part of the HTTP protocol.  See ModSession for details on how to establish sessions.  You may use the attributes instance variable to hold additional state (such as user object for your application).  Alternatively, other modules may use the session to assign additional dynamic bindings.For examples see the class comments for ModSession.!!KomSession class methodsFor: 'bindings' stamp: 'svp 5/14/2003 00:49'!current	^#'KomSession-current' binding! !!KomSession class methodsFor: 'bindings' stamp: 'svp 5/14/2003 00:49'!current: aKomSession	^#'KomSession-current' binding: aKomSession! !!KomSession class methodsFor: 'class initialization' stamp: 'svp 5/14/2003 00:44'!initialize	LastSessionID := Time totalSeconds.! !!KomSession class methodsFor: 'instance creation' stamp: 'svp 5/14/2003 00:44'!new	^ super new initialize! !!KomSession class methodsFor: 'session id' stamp: 'DGD 7/24/2001 20:59'!nextSessionID	self flag: #TODO.	"more robust unique number"	LastSessionID _ LastSessionID + 1.	^ (65535 atRandom hex allButFirst: 3)		, (LastSessionID hex allButFirst: 3)		, (65535 atRandom hex allButFirst: 3)! !!KomSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 00:44'!attributes	"answer the attributes stored in Session"	^ attributes! !!KomSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 00:44'!id	^id! !!KomSession methodsFor: 'initialization' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.	attributes := Dictionary new.	id := self class nextSessionID! !!KomSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 01:01'!lastAccess	^lastAccess! !!KomSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 01:01'!lastAccess: secondCount	lastAccess := secondCount! !!KomSession methodsFor: 'printing' stamp: 'svp 5/14/2003 01:01'!printOn: aStream 	aStream 		nextPutAll: self class name;		nextPutAll: ' id:';		nextPutAll: id asString;		nextPutAll: ' attributes:';		nextPutAll: attributes asString;		nextPutAll: ' lastAccess:';		nextPutAll: lastAccess asString! !!KomSession methodsFor: 'accessing' stamp: 'svp 5/14/2003 01:00'!touch	lastAccess := Time totalSeconds.! !!ModuleAssembly commentStamp: 'svp 5/15/2003 17:31' prior: 0!I am a module assembly.  I provide a convienient mechanism for assembling modules into a module hierarchy for use by an HttpService.  The following is a very simple example of how to use a ModuleAssembly:	| ma |	ma _ ModuleAssembly core.	ma addPlug:		[ :request |		HttpResponse fromString: 'Hello World!!!!!!'].	(HttpService startOn: 8080 named: 'Example') module: ma rootModule.!!ModuleAssembly class methodsFor: 'as yet unclassified' stamp: 'svp 4/18/2003 10:16'!core	^super new 		initialize;		basicPushModule: ModCore new;		yourself! !!ModuleAssembly class methodsFor: 'as yet unclassified' stamp: 'svp 4/18/2003 10:16'!new	^super new 		initialize;		basicPushModule: ModMulti new;		yourself! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:03'!addAssembly: aModuleAssembly	self addModule: aModuleAssembly rootModule! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/16/2003 15:37'!addModule: aComancheModule	aComancheModule validateForStack: self moduleStack.	self currentModule addSubModule: aComancheModule! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/13/2003 09:59'!addPlug: aBlockOrMessageSend	"Blocks and MessageSends are compatible with the ComancheModule	protocol, so just add it as a module"	self addModule: aBlockOrMessageSend! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:22'!alias: pathPrefix to: aBlock	self 		pushModule: (ModAlias new pathPrefix: pathPrefix; yourself)		andDo: aBlock! !!ModuleAssembly methodsFor: 'construction' stamp: 'brp 10/2/2004 14:35'!authenticate: anAuthDb realm: realmString 	self addModule: ((ModAuth new)				authDb: anAuthDb;				realm: realmString; yourself)! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:16'!basicPushModule: aModule	^self moduleStack addLast: aModule.! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/17/2003 17:12'!currentModule	^self moduleStack last! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/16/2003 15:45'!directoryIndex: indexFileString	self 		pushModule: (ModDir new directoryIndex: indexFileString; yourself)		andDo: [self addModule: ModAutoIndex new].! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:29'!documentRoot: docRoot	self pushModule: (ModDoc new documentRoot: docRoot; yourself).! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:22'!documentRoot: docRoot do: aBlock	self 		pushModule: (ModDoc new documentRoot: docRoot; yourself)		andDo: aBlock! !!ModuleAssembly methodsFor: 'construction' stamp: 'brp 10/2/2004 14:34'!initialize	super initialize.		moduleStack := OrderedCollection new! !!ModuleAssembly methodsFor: 'error handling' stamp: 'svp 4/18/2003 12:00'!invalidContext: message	^self error: ('Invalid Context: ', message)! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 11:41'!logTo: aLogger	self addModule: (ModLog new logger: aLogger; yourself)! !!ModuleAssembly methodsFor: 'private' stamp: 'svp 4/18/2003 11:57'!lookupMod: testBlock ifFound: foundBlock ifNotFound: notFoundBlock	| thisMod |	moduleStack size to: 1 by: -1 do: 		[ :i |		thisMod _ moduleStack at: i.		(testBlock value: thisMod)			ifTrue: [^foundBlock value: thisMod]].	^notFoundBlock value! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/17/2003 17:10'!moduleStack	^moduleStack! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:59'!notFound	self addModule: (ModNotFound new)! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 09:50'!popModule	self moduleStack removeLast! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:16'!pushModule: aModule	self addModule: aModule.	^self basicPushModule: aModule.! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:10'!pushModule: aModule andDo: aBlock	"Push aModule on our stack and evaluate aBlock, note, this directive 	protects against an unbalanced stack because certain directives just	push a new module on the stack without popping it"	| stackSize |	stackSize _ moduleStack size.	self pushModule: aModule.	aBlock value.	moduleStack _ moduleStack copyFrom: 1 to: stackSize.! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:03'!rootModule	^self moduleStack first! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:45'!serveFiles	self addModule: ModFile new! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 15:52'!serverRoot: aDirectoryPath	self lookupMod: [ :mod | mod isCore ]		ifFound: [ :mod | mod serverRoot: aDirectoryPath ]		ifNotFound: [ self invalidContext: 'serverRoot directive requires ModCore' ]! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:07'!sessionTimeout: minutes	self lookupMod: [ :ea | ea isSession ]		ifFound: [ :module | module secondsToLive: (minutes * 60)]		ifNotFound: [ self invalidContext: 'sessionTimeout directive requires ModSession']! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:07'!sessionTimeoutSeconds: seconds	self lookupMod: [ :ea | ea isSession ]		ifFound: [ :module | module secondsToLive: seconds]		ifNotFound: [ self invalidContext: 'sessionTimeout directive requires ModSession']! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:03'!trackSessions	self pushModule: ModSession new! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 16:10'!trackSessions: aBlock	self pushModule: ModSession new andDo: aBlock! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 4/18/2003 10:24'!virtualDocumentRoot: aTemplateString do: aBlock	self pushModule: (ModVhost new template: aTemplateString; yourself) andDo:		[self pushModule: (ModVhostDoc new documentRoot: ''; yourself) andDo: aBlock]! !!ModuleAssembly methodsFor: 'construction' stamp: 'svp 5/15/2003 00:48'!virtualHost: hostString do: aBlock	self pushModule: (ModVhost new template: '%0'; yourself) andDo:		[self pushModule: (ModVhostAlias new host: hostString; yourself) andDo: aBlock]! !!MultipartChunk commentStamp: '<historical>' prior: 0!kom/4.12 (Comanche/4.12)MultipartChunkHeader (kom/4.8; bolot 4/2/2001 18:52)- in kom49 (or kom50) this will be used only for internal purposes-- applications will access multipart form fields through regular fieldAt: techniqueComment from kom46:- this is a hack (bolot 10/25/2000 17:17)- store a part's (from a multipart message) header information:-- header (raw)-- properties (extracted and converted info, such as file-name, content-length, etc.)!!MultipartChunk class methodsFor: 'instance creation' stamp: 'bolot 12/16/2000 02:41'!from: aDictionary	aDictionary isEmptyOrNil		ifTrue: [^nil].	^self new initializeFrom: aDictionary! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:36'!contentType	^properties at: #contentType! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:36'!fieldName	^properties at: #fieldName! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:36'!fileName	^properties at: #fileName! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:36'!fileName: aString	properties at: #fileName put: aString! !!MultipartChunk methodsFor: 'initialize-release' stamp: 'brp 10/2/2004 16:03'!initializeFrom: aDictionary	| header str fileName fieldName idx contentType |	"PRE: all keys in aDictionary are low-case"	header := aDictionary.	properties := Dictionary new.self flag: #todo.	"parse the header, pick out: filename, etc."	str := (header at: 'content-disposition' ifAbsent: ['']).	fileName := fieldName := ''.	idx := str findString: 'filename='.	idx > 0 ifTrue:		[fileName := str copyFrom: idx + 10 to: (str indexOf: $" startingAt: idx+10) - 1].	properties at: #fileName put: fileName.	idx := str findString: 'name='.	idx > 0 ifTrue:		[fieldName := str copyFrom: idx + 6 to: (str indexOf: $" startingAt: idx+6) - 1].	properties at: #fieldName put: fieldName.	contentType := header at: 'content-type' ifAbsent: [MIMEDocument defaultContentType].	properties at: #contentType put: contentType."Transcript show: 'field=', fieldName; cr; show: 'file=', fileName; cr;	show: 'content-type=', contentType; cr."! !!MultipartChunk methodsFor: 'testing' stamp: 'brp 10/2/2004 14:24'!isSaved	^(properties at: #isSaved ifAbsent: [false])! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:38'!multipartBoundary	^multipartBoundary! !!MultipartChunk methodsFor: 'initialize-release' stamp: 'bolot 12/16/2000 02:39'!multipartBoundary: aString	multipartBoundary _ aString! !!MultipartChunk methodsFor: 'accessing' stamp: 'brp 10/2/2004 15:26'!saveToStream: outStream 	"This method is really dumb, it reads the entire body of the 	chunk before writing it onto outStream.  In the future, this will	change to a better streaming mechanism to allow very large amounts	of data to be read without requiring everything to fit into memory."	| body origFileName boundary |	self setSavedFlag.	origFileName := self fileName.	boundary := String crlf , self multipartBoundary.	body := self stream upToAll: boundary.	"IE4 for Mac appends 128 bytes of Mac file system info - must remove"	body size >= 128 		ifTrue: 			[(body first asciiValue = 0 and: 					[body second asciiValue = origFileName size 						and: [(body copyFrom: 3 to: origFileName size + 2) = origFileName]]) 				ifTrue: [body := body copyFrom: 129 to: body size]].	outStream nextPutAll: body! !!MultipartChunk methodsFor: 'accessing' stamp: 'bolot 12/16/2000 02:37'!setSavedFlag	properties at: #isSaved put: true! !!MultipartChunk methodsFor: 'accessing' stamp: 'svp 10/28/2003 12:18'!stream	^stream! !!MultipartChunk methodsFor: 'accessing' stamp: 'svp 10/28/2003 12:19'!stream: aReadableStream	stream := aReadableStream! !!NetworkHost commentStamp: 'svp 3/5/2003 10:25' prior: 0!I am an abstaction of a network host (in DNS parlance) and port number.  I can abstract named or numbered host names (as allowed in a URI for example).	NetworkHost fromString: 'www.yahoo.com:8080'	NetworkHost fromString: '192.168.1.1:80'!!NetworkHost class methodsFor: 'instance creation' stamp: 'svp 9/11/2000 11:28'!fromNamePath: namePath	^self new		initializeFromNamePath: namePath;		yourself! !!NetworkHost class methodsFor: 'instance creation' stamp: 'svp 11/5/1999 13:15'!fromString: aString	^self new		initializeFromString: aString;		yourself! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 11/18/1999 19:59'!domainString	| sz |	^self isNamedHost ifTrue: [		((sz _ self name size) >= 2) ifTrue: [			(self name at: (sz - 1)), '.', self name last.		] ifFalse: [			''		]	] ifFalse: [		self nameString	]! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 4/16/2003 13:50'!fileSystemPath	| delim |	delim _ FileDirectory pathNameDelimiter.	^String streamContents: 		[ :strm |		self isNamedHost			ifTrue: [strm nextPutAll: 'hostname']			ifFalse: [strm nextPutAll: 'ipaddress'].		strm nextPut: delim.		self name reversed 			do:				[ :part | strm nextPutAll: part asString ]			separatedBy: 				[ strm nextPut: delim ]]! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 11/5/1999 13:43'!fullName	^fullName! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 12/9/1999 17:12'!httpReference	^'http://', self fullName! !!NetworkHost methodsFor: 'initialization' stamp: 'svp 11/5/1999 13:32'!initializeFromIPAddress: str	| nums |	((str occurrencesOf: $.) = 3) ifTrue: [		nums _ (str findTokens: '.') collect: [ :ea | 			ea isPositiveInteger ifTrue: [				ea asNumber			] ifFalse: [ ^self ]		].		name _ nums.		type _ #address.	].			! !!NetworkHost methodsFor: 'initialization' stamp: 'svp 9/11/2000 11:28'!initializeFromNamePath: namePath	name _ namePath.	type _ #name.	! !!NetworkHost methodsFor: 'initialization' stamp: 'svp 11/5/1999 13:36'!initializeFromString: aString	^self initializeFromString: aString defaultPort: 80	! !!NetworkHost methodsFor: 'initialization' stamp: 'svp 11/5/1999 13:43'!initializeFromString: aString defaultPort: dPort	| tmp |	fullName _ aString.	tmp _ self initializePortFromString: aString defaultPort: dPort.	self initializeFromIPAddress: tmp.	name ifNil: [		name _ tmp findTokens: '.'.		type _ #name.	].	! !!NetworkHost methodsFor: 'initialization' stamp: 'brp 10/2/2004 14:53'!initializePortFromString: aString defaultPort: dPort 	| in tmp |	^(in := aString indexOf: $:) > 0 		ifTrue: 			[tmp := aString copyFrom: in + 1 to: aString size.			port := tmp isPositiveInteger 				ifTrue: [tmp asNumber]				ifFalse: [dPort].			aString copyFrom: 1 to: in - 1]		ifFalse: 			[port := dPort.			aString]! !!NetworkHost methodsFor: 'testing' stamp: 'svp 11/5/1999 13:37'!isNamedHost	^self type == #name! !!NetworkHost methodsFor: 'accessing' stamp: 'brp 10/2/2004 14:39'!machineName	^(self isNamedHost and: [self name size >= 3]) 		ifTrue: [self name first]		ifFalse: [nil]! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 11/5/1999 13:37'!name	^name! !!NetworkHost methodsFor: 'accessing' stamp: 'CdG 11/4/2005 23:43'!nameString	^ String streamContents: [ :str |			self name do: [:nm | str nextPutAll: nm printString] separatedBy: [str nextPut: $.] ]! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 11/5/1999 13:37'!port	^port! !!NetworkHost methodsFor: 'accessing' stamp: 'svp 11/5/1999 13:37'!type	^type! !!NetworkHost methodsFor: 'accessing' stamp: 'brp 10/2/2004 15:11'!vhostName: nameIndex letter: letterIndex 	"First get the name component"	| ni word nStart nEnd li |	ni := nameIndex asNumber.	word := ni = 0 				ifTrue: [self nameString]				ifFalse: 					[nStart := ni < 0 ifTrue: [name size + 1 + ni] ifFalse: [ni].					nEnd := nStart.					(nameIndex endsWith: '+') ifTrue: [nStart := 1].					(nStart < 1 or: [nStart > name size]) 						ifTrue: ['_']						ifFalse: 							[String streamContents: 									[:strm | 									(nStart to: nEnd) do: [:in | strm nextPutAll: (name at: in)]										separatedBy: [strm nextPut: $.]]]].	"Now get the letters"	li := letterIndex asNumber.	li = 0 		ifTrue: [^word]		ifFalse: 			[li < 0 				ifTrue: 					[nStart := word size + 1 + li.					nEnd := nStart.					(letterIndex endsWith: '+') ifTrue: [nStart := 1]]				ifFalse: 					[nStart := li.					nEnd := (letterIndex endsWith: '+') ifTrue: [word size] ifFalse: [nStart]].			(nStart < 1 or: [nStart > name size]) 				ifTrue: [^'_']				ifFalse: [^word copyFrom: nStart to: nEnd]]! !!Object methodsFor: '*KomHttpServer' stamp: 'SVP 8/23/1999 19:17'!asHtmlDocumentForRequest: aNetworkRequest	self error: 		('The requested object (', 		self asString, 		'), could not be converted into HTML for your browser.')! !!Object methodsFor: '*KomHttpServer' stamp: 'SVP 8/23/1999 19:23'!asHttpResponseTo: anHttpRequest	^(self asHtmlDocumentForRequest: anHttpRequest) 		asHttpResponseTo: anHttpRequest! !!Object methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 12:47'!isComancheModule	^false! !!Object methodsFor: '*KomHttpServer' stamp: 'SVP 8/17/1999 17:51'!mimeType	^MIMEDocument defaultContentType! !!Form methodsFor: '*KomHttpServer' stamp: 'bolot 2/14/2000 15:59'!asHttpResponseTo: request	^HttpResponse fromMIMEDocument: self asWebImage! !!Form methodsFor: '*KomHttpServer' stamp: 'bolot 12/18/2000 22:31'!asWebImage	"return a MIMEDocument"	| aStream |	aStream _ (RWBinaryOrTextStream on: '').	GIFReadWriter putForm: (self asFormOfDepth: 8) onStream: aStream.	aStream reset.	^MIMEDocument contentType: MIMEDocument contentTypeGif content: aStream! !!UndefinedObject methodsFor: '*KomHttpServer' stamp: 'svp 5/16/2003 23:09'!asHttpResponseTo: request	^HttpResponse 		status: #notFound 		contents: 'The object you requested was not found on this server.'! !!HttpFormDictionary commentStamp: '<historical>' prior: 0!kom/4.10 (Comanche beta 4.10)HttpFormDictionarybolot 6/22/2001 12:09- use this instead of plain Dictionary for GET and POST forms- maintains multiple values for the same field-- but is backwards compatible, #at: returns the first value (?)-- so do #booleanAt:, #numberAt:- to access the actual value at key, use #rawAt:-- returns an OrderedCollectionTODO:- file upload support-- idea: first value is file name, second is FileStream?Koubo 3/19/2002 12:25fixed #at: and #at:ifAbsent: returns a String when the value had only one item. however, they returns a copied Collection of the value when it had multiple items.!!HttpFormDictionary methodsFor: 'accessing' stamp: 'brp 10/2/2004 14:53'!at: key ifAbsent: aBlock 	| value valueSize |	value := super at: key ifAbsent: [^aBlock value].	valueSize := value size.	0 = valueSize 		ifTrue: 			["is this not absent?"			value := aBlock value].	value := (1 = valueSize) ifTrue: [value first] ifFalse: [value copy].	^value! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'Koubo 3/17/2002 11:55'!at: key put: value	(self includesKey: key)		ifFalse: [super at: key put: (OrderedCollection new)].	(self rawAt: key) add: value.	^value! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'Koubo 3/17/2002 11:55'!booleanAt: key	^(self rawAt: key) first = 'true'! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'bolot 6/22/2001 12:34'!booleansAt: key	^(self rawAt: key) collect: [:value | value == 'true']! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'Koubo 3/17/2002 11:55'!numberAt: key	^[(self rawAt: key) first asNumber]		ifError: [:err :rcvr | Float nan]! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'bolot 6/22/2001 12:34'!numbersAt: key	^(self rawAt: key) collect: [:value |		[value asNumber] ifError: [:err :rcvr | Float nan]]! !!HttpFormDictionary methodsFor: 'printing' stamp: 'Koubo 3/17/2002 11:55'!printElementsOn: aStream	aStream nextPut: $(.	self keysSortedSafely do:		[:key | aStream print: key; nextPutAll: '->'; print: (self rawAt: key); space].	aStream nextPut: $)! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'Koubo 3/17/2002 11:55'!rawAt: key	^super at: key ifAbsent: [self errorKeyNotFound]! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'bolot 5/2/2002 17:46'!rawAt: key ifAbsent: aBlock	^super at: key ifAbsent: aBlock! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'Koubo 3/17/2002 11:55'!stringAt: key	^(self rawAt: key) first! !!HttpFormDictionary methodsFor: 'accessing' stamp: 'bolot 6/22/2001 12:35'!stringsAt: key	^(self rawAt: key) copy! !!WriteStream methodsFor: '*KomHttpServer' stamp: 'bolot 1/3/2000 17:13'!asHttpResponseTo: request	^HttpResponse fromMIMEDocument: 		(MIMEDocument contentType: self mimeType content: self contents)! !!WriteStream methodsFor: '*KomHttpServer' stamp: 'cmm 11/10/2002 20:35'!endEntry	"No-op for compatibility with TranscriptStream."! !!WriteStream methodsFor: '*KomHttpServer' stamp: 'svp 3/5/2003 09:51'!mimeType	self flag: #svp.	"SVP: We should not be assuming that all write streams contain html content.  This needs to be fixed."	^'text/html'! !!TextAnchor methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:45'!printHtmlOpenTagOn: strm	"do nothing for now"	"save the embedded image in a file to be served by Comanche"! !!TextColor methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:40'!printHtmlCloseTagOn: strm	strm		nextPutAll: '</FONT>'! !!TextColor methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:53'!printHtmlOpenTagOn: strm	strm		nextPutAll: '<FONT COLOR="#';		nextPutAll: self color hex;		nextPutAll: '">'! !!TextURL methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:40'!printHtmlCloseTagOn: strm	strm		nextPutAll: '</A>'! !!TextURL methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:40'!printHtmlOpenTagOn: strm	strm		nextPutAll: '<A HREF="';		nextPutAll: self info;		nextPutAll: '">'! !!StandardFileStream methodsFor: '*KomHttpServer' stamp: 'SVP 8/24/1999 15:47'!mimeType	^MIMEDocument guessTypeFromName: self name.! !!HttpService commentStamp: 'svp 5/7/2003 05:21' prior: 0!I am a comanche service that listens for inbound HTTP connectinos on a given port.Usage:Subclasses should override the #processHttpRequest: method to process incoming HTTP requests (an HttpRequest is passed as the sole argument to this method).  The #processHttpRequest: method should always answer an instance of an HttpResponse.  Starting and stopping instances of this class will start and stop listening on the given port number.  You may also use instances of this class in a pluggable manner rather than subclassing (see examples below).Instance Variables:plug - An object that responds to the message #threadSafeValue: (typically a BlockContext or a MessageSend).  If this variable is not nil, then the default implementation of #processHttpRequest: will send #threadSafeValue: to this object and answer the result.  This enables ComancheHttpService to be used in a pluggable manner.  Pluggable Examples (MessageSend):	(HttpService on: 8080 named: 'Example Http Service')		onRequestDispatch: #processRequest: to: SomeGlobal;		startPluggable Examples (BlockContext):	(HttpService on: 8080 named: 'Example Http Service')		onRequestDo: [ :httpRequest | SomeGlobal processRequest: httpRequest ];		start!!HttpService class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:00'!current	^#'ComancheHttpService-Current' binding! !!HttpService class methodsFor: 'bindings' stamp: 'svp 4/15/2003 15:00'!current: anInstance	#'ComancheHttpService-Current' binding: anInstance! !!HttpService class methodsFor: 'accessing' stamp: 'svp 4/22/2003 09:58'!initialize	self initializeServerType! !!HttpService class methodsFor: 'accessing' stamp: 'svp 5/7/2003 05:40'!initializeServerType	"self initializeServerType"	ServerType _ String streamContents:		[ :s |		s nextPutAll: 'Comanche/'.		s nextPutAll: self version.		s nextPutAll: ' ('.		s nextPutAll: self platform.		s nextPutAll: ') '.		ComancheModule withAllSubclassesDo: 			[ :modClass |			modClass version isEmpty ifFalse:				[s nextPutAll: modClass version.				s nextPut: $ ]]].! !!HttpService class methodsFor: 'accessing' stamp: 'ab 11/13/2003 12:31'!platform	^SmalltalkImage current platformName! !!HttpService class methodsFor: 'accessing' stamp: 'svp 4/22/2003 09:53'!serverType	^ServerType! !!HttpService class methodsFor: 'accessing' stamp: 'svp 9/19/2003 00:56'!version	^'6.2'! !!HttpService methodsFor: 'error handling' stamp: 'brp 10/2/2004 15:51'!detailedErrorResponseStatus: aSymbol exception: anException 	^self errorResponseStatus: aSymbol		description: '<pre><b>' , anException description , '</b><br><br>' 				, anException signalerContext longStack , '</pre>'! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/16/2003 23:08'!errorResponseStatus: aSymbol description: aString	^HttpResponse		status: aSymbol		contents: '<!!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"><html><head><title>', (HttpResponse statusCodeFor: aSymbol), ' ', (HttpResponse statusDescriptionFor: aSymbol), '</title></head><body><h1>', (HttpResponse statusDescriptionFor: aSymbol),'</h1>', aString, '<p><hr><address>', self serverDescription,'</address></body></html>'! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/12/2003 16:27'!handleDispatchErrorsIn: aBlock	"Note: We could break the error handling out into a separate	object to allow more sophisticated error handling scenarios, however	you can achieve the same result by writing a module that traps 	errors and provides special handling.  So, here, we just provide three	simple and common possibilities for handling dispatch errors."	"Debug mode doesn't handle the error (you'll get a walkbalk)"	self isDebugMode ifTrue: [^aBlock value].	"Verbose mode will send a long stack dump to the browser"	self isVerboseMode ifTrue: 		[^aBlock on: Error do: 			[ :ex | 			self				detailedErrorResponseStatus: #serverError				exception: ex]].	"By default, operate in deployment mode (just the exception description is	displayed in the browser)"	^aBlock on: Error do: 		[ :ex | 		self			errorResponseStatus: #serverError			description: ex description]! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/12/2003 16:45'!handleResponseWritingError: anException	"Handle errors that occur when trying to write out a response."	"Debug mode doesn't handle the error (you'll get a walkbalk)"	self isDebugMode ifTrue: [^anException pass].	"Verbose mode will send a long stack dump to the browser"	self isVerboseMode ifTrue: 		[^self			detailedErrorResponseStatus: #serverError			exception: anException].	"By default, operate in deployment mode (just the exception description is	displayed in the browser)"	^self		errorResponseStatus: #serverError		description: anException description! !!HttpService methodsFor: 'initialize-release' stamp: 'svp 5/7/2003 04:18'!initialize	super initialize.	mode := #deployment.! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:18'!isDebugMode	^self mode == #debug! !!HttpService methodsFor: 'error handling' stamp: 'svp 4/15/2003 22:36'!isDeploymentMode	^self isVerboseMode not and: [self isDebugMode not]! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:18'!isVerboseMode	^self mode == #verbose! !!HttpService methodsFor: 'configuration' stamp: 'svp 5/7/2003 04:56'!keepAlive	^self withBindingsDo: [HttpAdaptor keepAlive]! !!HttpService methodsFor: 'configuration' stamp: 'svp 5/7/2003 04:56'!keepAlive: aBool	self withBindingsDo: [HttpAdaptor keepAlive: aBool]! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:21'!mode	"<#deployment | #debug | #verbose > - Answers the debugging	mode of the receiver."	^mode! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:21'!mode: aSymbol	"aSymbol <#deployment | #debug | #verbose > - Sets the debugging	mode of the receiver."	mode _ aSymbol! !!HttpService methodsFor: 'pluggable' stamp: 'svp 5/15/2003 16:49'!module: aComancheModule	"This message is useful if you wish to 	validate your module."	aComancheModule validate.	self plug: aComancheModule! !!HttpService methodsFor: 'pluggable' stamp: 'svp 4/9/2003 00:20'!onRequestDispatch: aSelector to: anObject	self plug: 		(MessageSend 			receiver: anObject 			selector: aSelector 			arguments: #(nil))! !!HttpService methodsFor: 'pluggable' stamp: 'svp 4/9/2003 00:32'!onRequestDo: plugBlock	self plug: plugBlock! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/16/2003 13:46'!perceivedHostName	"Answer the host name as perceived by the client.  If there	is no current HttpRequest, fall back on the name as determined	on the server."	| request |	(request _ HttpRequest current) ifNotNil: 		[^request networkHost nameString].	^self serverHostName! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/16/2003 13:48'!perceivedPortNumber	"Answer the port number as it is perceived by the client (which could	be different from the port we are listening on if for example you are 	using port forwarding rules to reach your server).  If there is no 	current http request, fall back on the real port number that we are 	listening on."	| request |	(request _ HttpRequest current) ifNotNil: 		[^request networkHost port].	^self portNumber! !!HttpService methodsFor: 'pluggable' stamp: 'svp 4/9/2003 00:21'!plug	^plug! !!HttpService methodsFor: 'pluggable' stamp: 'svp 4/9/2003 00:21'!plug: aMonadicValuable	plug _ aMonadicValuable! !!HttpService methodsFor: 'startup and shutdown' stamp: 'svp 4/22/2003 09:59'!prepareForStartup	ServerHostName _ nil.	self class initializeServerType.! !!HttpService methodsFor: 'serving' stamp: 'svp 5/12/2003 17:26'!processHttpRequest: anHttpRequest	"Subclasses can override this method and answer an instance of an 	HttpResponse.  Alternatively, if we have a plug (typically a BlockContext	or a MessageSend), then invoke it."	plug ifNotNil: [^plug processHttpRequest: anHttpRequest].	^self subclassResponsibility! !!HttpService methodsFor: 'serving' stamp: 'brp 10/2/2004 15:17'!serve: aSocket 	self class current: self.	HttpAdaptor readAndWriteToSocket: aSocket service: self! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/15/2003 09:38'!serverDescription	^String streamContents: [ :strm | self serverDescriptionOn: strm]! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/16/2003 13:44'!serverDescriptionOn: strm	strm nextPutAll: self serverType.	strm nextPutAll: ' Server at '.	strm nextPutAll: self perceivedHostName.	strm nextPutAll: ' Port '.	strm nextPutAll: self perceivedPortNumber asString.! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/16/2003 13:45'!serverHostName	"Cache the host name (it can take several milliseconds to make this call	on some platforms.  The cache value will be reset every time the image	is started"	^ServerHostName ifNil:		[ServerHostName _ NetNameResolver 								nameForAddress: NetNameResolver localHostAddress 								timeout: 5]! !!HttpService methodsFor: 'configuration' stamp: 'svp 4/22/2003 09:57'!serverType	^self class serverType! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:18'!setDebugMode	self mode: #debug! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:19'!setDeploymentMode	self mode: #deployment! !!HttpService methodsFor: 'error handling' stamp: 'svp 5/7/2003 04:19'!setVerboseMode	self mode: #verbose! !!HttpService methodsFor: 'starting and stopping' stamp: 'svp 4/22/2003 10:00'!start	self class initializeServerType.	^super start! !!TextFontChange methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:40'!printHtmlCloseTagOn: strm	strm		nextPutAll: '</FONT>'! !!TextFontChange methodsFor: '*KomHttpServer' stamp: 'bolot 3/17/2001 22:40'!printHtmlOpenTagOn: strm	strm		nextPutAll: '<FONT SIZE="';		nextPutAll: (self fontNumber + 2) asString;		nextPutAll: '">'! !!ByteArray methodsFor: '*KomHttpServer' stamp: 'svp 5/15/2003 12:23'!asIpString	^String streamContents: 		[ :strm |		self do: 			[ :ea |			strm nextPutAll: ea asString.			strm nextPut: $.].		strm skip: -1]! !!ReadWriteStream methodsFor: '*KomHttpServer' stamp: 'SVP 8/23/1999 19:07'!asHttpResponseTo: request	^HttpResponse fromStream: self! !!Morph methodsFor: '*KomHttpServer' stamp: 'bolot 10/16/2001 21:33'!asHttpResponseTo: request	^self imageForm asHttpResponseTo: request! !"KomHttpServer"!"Installed KomHttpServer auto version 6".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '0fdb5ffc-cfa1-4d40-96c2-fe325bc8ba5f' autoVersion: '6' asVersion atSeconds: 3338754732 number: 9]!!String methodsFor: '*seaside2' stamp: 'avi 3/16/2004 16:33'!asCapitalizedPhrase	|read words currentWord capitalizedWord|	(self noneSatisfy: [:ea | ea isLowercase] ) ifTrue: [^ self].	words _ WriteStream on: String new.	read _ ReadStream on: self.	[read atEnd] whileFalse:		[currentWord _ WriteStream on: String new.		currentWord nextPut: read next.		[|x| x _ read peek. x isNil or: [x isUppercase]] whileFalse:			[currentWord nextPut: read next].		capitalizedWord _ currentWord contents capitalized.			(#(Of In At A Or To By) includes: capitalizedWord)				ifTrue: [capitalizedWord _ capitalizedWord asLowercase].		words nextPutAll: capitalizedWord.		words nextPutAll: ' '].	words skip: -1.	^ words contents ! !!String methodsFor: '*seaside2' stamp: 'mb 6/2/2006 10:47'!asMIMEDocument 	^self asMIMEDocumentType: 'text/plain'! !!String methodsFor: '*seaside2' stamp: 'mb 6/2/2006 10:54'!asMIMEDocumentType: mimeType	^SeasidePlatformSupport mimeDocumentClass contentType: mimeType content: self! !!String methodsFor: '*seaside2' stamp: 'ab 3/29/2003 00:15'!prettyPrintHtmlOn: aStream indentLevel: aNumber	aStream nextPutAll: self! !!String methodsFor: '*seaside2' stamp: 'ab 1/11/2003 12:46'!printHtmlOn: aStream	aStream nextPutAll: self! !!String methodsFor: '*seaside2' stamp: 'lr 6/13/2006 16:06'!renderOn: aRenderer	aRenderer text: self! !!String methodsFor: '*seaside2' stamp: 'jf 2/18/2004 15:21'!renderOn: html indentLevel: level	html text: self! !!String methodsFor: '*seaside2-squeak' stamp: 'mb 3/23/2006 11:46'!trimBlanks	^self withBlanksTrimmed! !!Color methodsFor: '*seaside2' stamp: 'avi 4/29/2004 13:06' prior: 18875646!asHTMLColor	^ '#', self hex! !!Color methodsFor: '*seaside2' stamp: 'mb 5/13/2006 07:45' prior: 33702476!hex	| aStream |	aStream _ (String new: 6) writeStream. 	aStream nextPutAll: (((self red * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	aStream nextPutAll: (((self green * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	aStream nextPutAll: (((self blue * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	^ aStream contents! !!MessageSend methodsFor: '*seaside2-squeak' stamp: 'ab 7/10/2003 11:40'!evaluateWithArguments: anArray	^ self valueWithArguments: anArray! !!MessageSend methodsFor: '*seaside2' stamp: 'avi 9/19/2006 14:38'!fixCallbackTemps! !!MessageSend methodsFor: '*seaside2' stamp: 'ab 10/10/2002 01:40'!fixTemps! !!MessageSend methodsFor: '*seaside2' stamp: 'ab 3/5/2003 18:30'!numArgs	^ selector numArgs! !!MessageSend methodsFor: '*seaside2' stamp: 'lr 8/4/2006 09:18'!renderOn: html	self value: html! !!MessageSend methodsFor: '*seaside2' stamp: 'ab 7/10/2003 11:40'!value: anObject	^ self evaluateWithArguments: (Array with: anObject)! !!MessageSend methodsFor: '*seaside2-squeak' stamp: 'ab 8/24/2003 16:38' prior: 24276141!valueWithPossibleArgs: anArray 	self numArgs = 0 ifTrue: [^self value].	self numArgs = anArray size ifTrue: [^self valueWithArguments: anArray].	self numArgs > anArray size ifTrue: [		^self valueWithArguments: anArray,				(Array new: (self numArgs - anArray size))	].	^self valueWithArguments: (anArray copyFrom: 1 to: self numArgs)! !!MIMEDocument methodsFor: '*seaside2-squeak' stamp: 'pmm 4/18/2006 20:09'!asMIMEDocument	^self! !!MIMEDocument methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 10:44'!asMIMEDocumentType: mimeType	^self! !!Stream methodsFor: '*seaside2-squeak' stamp: 'avi 8/31/2003 15:48' prior: 31022309!closed	^false! !!BlockContext methodsFor: '*seaside2-squeak' stamp: 'avi 9/19/2006 14:49'!fixCallbackTemps	"Fix the values of the temporary variables used in the block that are 	ordinarily shared with the method in which the block is defined."	| temps |	home _ home copy.	home swapSender: nil.	home isMethodContext ifTrue:		[temps _ self tempVarRefs.		1 to: home size do: [:i | (temps includes: i) ifFalse: [home tempAt: i put: nil]]]! !!BlockContext methodsFor: '*seaside2' stamp: 'ab 2/11/2003 20:09'!handleRequest: aRequest	^ self value: aRequest! !!BlockContext methodsFor: '*seaside2' stamp: 'ac 5/16/2003 16:30'!renderOn: aRenderer	self numArgs = 0 		ifTrue: [self value]		ifFalse: [self value: aRenderer]! !!BlockContext methodsFor: '*seaside2-squeak' stamp: 'avi 9/19/2006 14:49'!tempVarRefs	| method scanner end tempVars byte type offset |	home ifNil: [^false].	tempVars _ Set new.	method _ self method.	"Determine end of block from long jump preceding it"	end _ (method at: startpc-2)\\16-4*256 + (method at: startpc-1) + startpc - 1.	scanner _ InstructionStream new method: method pc: startpc.	[scanner pc <= end] whileTrue:		[byte  _ scanner nextByte.		type _ byte // 16.		offset _ byte \\ 16.		type = 1 ifTrue: [tempVars add: offset + 1].		scanner nextInstruction].	^ tempVars! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 12:20'!pickANumber	^ self pickANumberGreaterThan: 0! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 12:20'!pickANumberGreaterThan: aNumber	^ amb valueOf: [aNumber + 1] or: [self pickANumberGreaterThan: aNumber + 1]! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/13/2002 01:15'!setUp	amb _ Amb new! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:43'!testAllValuesAboveFive	|x results|	results _ amb allValues:				[x _ amb oneOf: (1 to: 10).				amb assert: (x > 5).				x].				self assert: results = #(6 7 8 9 10).! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'avi 4/28/2004 11:31'!testMaybe	|x y z|	x _ amb maybe.	y _ amb maybe.	z _ amb maybe not.	amb deny: x = y.	amb deny: x = z.		self assert: x.	self deny: y.	self deny: z.! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 12:21'!testPickANumber	self assert: self pickANumber = 1.! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 12:21'!testPickANumberAboveFive	|x|	x _ self pickANumber.	amb assert: (x > 5).	self assert: x = 6.! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'avi 4/26/2004 14:45'!testSicpLogicProblem	"Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors. Baker does not live on the top floor. Cooper does not live on the bottom floor. Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper. Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's. Where does everyone live?""This implementation is too slow - uncomment to actually run it."	"	|baker cooper fletcher miller smith|	baker _ amb oneOf: (1 to: 5).	cooper _ amb oneOf: (1 to: 5).	fletcher _ amb oneOf: (1 to: 5).	miller _ amb oneOf: (1 to: 5).	smith _ amb oneOf: (1 to: 5).		amb assert: (Set new add: baker; add: cooper; add: fletcher; add: miller; add: smith; size) = 5.		amb deny: baker = 5.	amb deny: cooper = 1.	amb deny: fletcher = 5.	amb deny: fletcher = 1.	amb assert: miller > cooper.	amb deny: (smith - fletcher) abs = 1.	amb deny: (fletcher - cooper) abs = 1.		self assert: baker = 3.	self assert: cooper = 2.	self assert: fletcher = 4.	self assert: miller = 5.	self assert: smith = 1."	! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'avi 4/26/2004 14:45'!testSicpLogicProblemFaster	"Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors. Baker does not live on the top floor. Cooper does not live on the bottom floor. Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper. Smith does not live on a floor adjacent to Fletcher's. Fletcher does not live on a floor adjacent to Cooper's. Where does everyone live?"		|baker cooper fletcher miller smith|	fletcher _ amb oneOf: (1 to: 5).	amb deny: fletcher = 5.	amb deny: fletcher = 1.	smith _ amb oneOf: (1 to: 5).	amb deny: (smith - fletcher) abs = 1.	cooper _ amb oneOf: (1 to: 5).	amb deny: cooper = 1.	amb deny: (fletcher - cooper) abs = 1.	miller _ amb oneOf: (1 to: 5).	amb assert: miller > cooper.	baker _ amb oneOf: (1 to: 5).	amb deny: baker = 5.		amb assert: (Set new add: baker; add: cooper; add: fletcher; add: miller; add: smith; size) = 5.	self assert: baker = 3.	self assert: cooper = 2.	self assert: fletcher = 4.	self assert: miller = 5.	self assert: smith = 1.! !!AmbTest methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:27'!testSolveAnEquation	|x y|	x _ amb oneOf: (1 to: 10).	y _ amb oneOf: (1 to: 10).	amb assert: (y * x) = 42.	self assert: x = 6.	self assert: y = 7.! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 19:23'!callcc: aBlock	^ Continuation currentDo: aBlock! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:26'!testBlockEscape	|x|	tmp _ 0.	x _ [tmp _ tmp + 1. tmp2 value].	self callcc: [:cc | tmp2 _ cc. x value].	tmp2 _ [].	x value.	self assert: tmp = 2.! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:26'!testBlockTemps	|y|	#(1 2 3) do:		[:i ||x|			x _ i.			tmp ifNil: [tmp2 _ (self callcc: [:cc | tmp _ cc. [:q]])].			tmp2 value: x.			x _ 17].	y _ (self callcc: [:cc | tmp value: cc. 42]).	self assert: y = 1.! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:26'!testBlockVars	|continuation|	tmp _ 0.	tmp _ (self callcc: [:cc | continuation _ cc. 0]) + tmp.	tmp2 		ifNotNil: [tmp2 value]		ifNil:			[#(1 2 3) do:				[:i |				self callcc: [:cc | tmp2 _ cc. continuation value: i]]].	self assert: tmp = 6.! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 2/14/2003 01:17'!testComprehension	"What should this print out?		|yin yang|	yin := [:x | Transcript cr. x] value: Continuation current.	yang := [:x | Transcript nextPut: $*. x] value: Continuation current.	yin value: yang."! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:26'!testMethodTemps	|i continuation|	i _ 0.	i _ i + (self callcc: [:cc | continuation _ cc. 1]).	self assert: i ~= 3.	i = 2 ifFalse: [continuation value: 2].! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:26'!testSimpleCallCC	|x continuation|	x _ self callcc: [:cc | continuation _ cc. false].	x ifFalse: [continuation value: true].	self assert: x.! !!ContinuationTest methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 17:27'!testSimplestCallCC	|x|	x _ self callcc: [:cc | cc value: true].	self assert: x.! !!WAConfigurationTest methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 15:15'!testLinearization	"from http://www.webcom.com/haahr/dylan/linearization-oopsla96.html"	| root boat dayBoat wheelBoat engineLess pedalWheelBoat smallMultihull smallCatamaran pedalo |	root _ WAUserConfiguration new.	boat _ WAUserConfiguration new addAncestor: root; yourself.	dayBoat _ WAUserConfiguration new addAncestor: boat; yourself.	wheelBoat _ WAUserConfiguration new addAncestor: boat; yourself.	engineLess _ WAUserConfiguration new addAncestor: dayBoat; yourself.	pedalWheelBoat _ WAUserConfiguration new addAncestor: engineLess; addAncestor: wheelBoat; yourself.	smallMultihull _ WAUserConfiguration new addAncestor: dayBoat; yourself.	smallCatamaran _ WAUserConfiguration new addAncestor: smallMultihull; yourself.	pedalo _ WAUserConfiguration new addAncestor: pedalWheelBoat; addAncestor: smallCatamaran; yourself.	self assert: pedalWheelBoat allAncestors = (Array with: engineLess with: dayBoat with: wheelBoat with: boat with: root).	self assert: smallCatamaran allAncestors = (Array with: smallMultihull with: dayBoat with: boat with: root).	self assert: pedalo allAncestors = ((Array with: pedalWheelBoat with: engineLess with: smallCatamaran with: smallMultihull), (Array with: dayBoat with: wheelBoat with: boat with: root)).! !!WAProxyTest methodsFor: 'testing' stamp: 'mb 1/5/2006 13:57'!test	| ad p |	ad := WAStoreAddress new.	ad street: 'Parkway'.	p := WAModelProxy on: ad.	self assert: p street = ad street.	self assert: ad city isNil.	self assert: p city = ad city.	p city: 'NYC'.	self assert: p city = 'NYC'.	self assert: ad city isNil.	p commit.	self assert: ad city = 'NYC'.	! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:22'!assertSnapshot: x isIdenticalTo: y	! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 18:16'!setUp	registry _ WAStateRegistry new! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:22'!snapshot: x isIdenticalTo: y	^ ((IdentitySet withAll: x values) includesAllOf: y values).! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:23'!testConsecutiveSnapshots	|a snap1 snap2 snap3 |	a _ ValueHolder new contents: 1.	registry registerObject: a.	snap1 _ registry snapshot.	snap2 _ registry snapshot.	self assert: (self snapshot: snap1 isIdenticalTo: snap2).	a contents: 2.	snap3 _ registry snapshot.	self deny: (self snapshot: snap3 isIdenticalTo: snap2).	! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 21:35'!testGarbageCollection	| a |	a _ ValueHolder new contents: 1.	registry registerObject: a.	registry snapshot.	Smalltalk garbageCollect.	self assert: registry size = 1.	a _ nil.	Smalltalk garbageCollect.	self assert: registry isEmpty.! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:24'!testNoChangeAfterRestore	| a snap1 snap2 snap3 |	a _ ValueHolder new contents: 1.	registry registerObject: a.	snap1 _ registry snapshot.	a contents: 2.	snap2 _ registry snapshot.	self deny: (self snapshot: snap1 isIdenticalTo: snap2).	registry restoreSnapshot: snap1.	self assert: a contents = 1.	snap3 _ registry snapshot.	self assert: (self snapshot: snap1 isIdenticalTo: snap3).! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 18:17'!testRevert	|a snap1|	a _ ValueHolder new contents: 1.	registry registerObject: a.	snap1 _ registry snapshot.	a contents: 2.	self assert: a contents = 2.	registry restoreSnapshot: snap1.	self assert: a contents = 1	! !!WAStateRegistryTest methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 18:22'!testRevertTwice	|a snap1|	a _ ValueHolder new contents: 1.	registry registerObject: a.	snap1 _ registry snapshot.	a contents: 2.	self assert: a contents = 2.	registry restoreSnapshot: snap1.	self assert: a contents = 1.	a contents: 3.	registry restoreSnapshot: snap1.	self assert: a contents = 1.! !!WAValueTest commentStamp: '<historical>' prior: 0!To test the refactorings from Yar Hwee Boon [hboon@motionobj.com]!!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:01'!originalValue: anOriginalValue input: anInputObject expectedOutput: anExpectedOutputObject 	| answer |	(WAHtmlRenderer new		fromStringConverterBlockFor: anOriginalValue		callback: [:v | answer := v])		value: anInputObject.	self assert: answer = anExpectedOutputObject! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:01'!testFloat	self		originalValue: 12.34		input: '92.6'		expectedOutput: 92.6! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:02'!testFractionWithFloat	self		originalValue: 1 / 3		input: '3.4'		expectedOutput: 3.4! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:02'!testFractionWithFraction	self		originalValue: 1 / 3		input: '2/5'		expectedOutput: 2! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:02'!testFractionWithInteger	self		originalValue: 1 / 3		input: '2'		expectedOutput: 2! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:02'!testFractionWithOriginalValue	| value |	"The #deny: check is to ensure value is stringent enough. For example 1/3 is not a suitable value."	value := 1 /33.	self deny: value asFloat asString asNumber = value.	self		originalValue: value		input: value asFloat asString		expectedOutput: value! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:02'!testInteger	self		originalValue: 123		input: '987'		expectedOutput: 987! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:03'!testNilWithEmptyString	self		originalValue: nil		input: ''		expectedOutput: nil! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:03'!testNilWithNonEmptyString	self		originalValue: nil		input: '123'		expectedOutput: '123'! !!WAValueTest methodsFor: 'testing' stamp: 'mb 11/4/2005 14:03'!testObject	self		originalValue: Object new		input: '2.3'		expectedOutput: '2.3'! !!Symbol methodsFor: '*seaside2-squeak' stamp: 'mb 5/29/2006 19:12' prior: 31406091!asMutator	"Needed when using Seaside on older versions of Squeak,	method not exported to vw"	^ (self copyWith: $:) asSymbol.! !!Amb class methodsFor: 'instance creation' stamp: 'lr 5/3/2006 09:24'!new	^ self basicNew initialize! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 19:23'!allValues: aBlock	|kPrev results|	kPrev _ failureContinuation.	results _ OrderedCollection new.	(Continuation currentDo:		[:kRetry |		failureContinuation _ [:v | kRetry value: false].		results add: aBlock value.		kRetry value: true])			ifTrue: [self fail].	failureContinuation _ kPrev.	^ results asArray	 ! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:11'!assert: aBoolean	aBoolean ifFalse: [self fail]! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:12'!deny: aBoolean	self assert: aBoolean not! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:15'!fail	^ failureContinuation value: nil! !!Amb methodsFor: 'initialize-release' stamp: 'avi 4/27/2004 14:28'!initialize	failureContinuation _ [:v | self error: 'Amb tree exhausted'].! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 5/29/2003 22:29'!maybe	^ self oneOf: (Array with: true with: false)! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 12/6/2002 02:09'!oneOf: aCollection	^ self valueOfOneOf: (aCollection collect: [:ea | [ea] fixTemps])! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 5/29/2003 22:30'!valueOf: blockOne or: blockTwo	^ self valueOfOneOf: (Array with: blockOne with: blockTwo)! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 5/29/2003 22:30'!valueOf: blockOne or: blockTwo or: blockThree	^ self valueOfOneOf: (Array with: blockOne with: blockTwo with: blockThree)! !!Amb methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 19:23'!valueOfOneOf: blockCollection	|kPrev|	kPrev _ failureContinuation.	^ Continuation currentDo:		[:kEntry |		blockCollection do:			[:ea |			Continuation currentDo:				[:kNext |				failureContinuation _					[:v | failureContinuation _ kPrev. kNext value: v] fixTemps.				kEntry value: ea value]].		kPrev value: nil]			 ! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!current	^ self fromContext: thisContext sender! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!currentDo: aBlock	^ aBlock value: (self fromContext: thisContext sender)! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!fromContext: aStack	^self new initializeFromContext: aStack! !!Continuation methodsFor: 'private' stamp: 'avi 4/24/2004 12:39'!initializeFromContext: aContext	| valueStream context |	valueStream _ WriteStream on: (Array new: 20).	context _ aContext.	[context notNil] whileTrue:		[valueStream nextPut: context.		1 to: context class instSize do: [:i | valueStream nextPut: (context instVarAt: i)].		1 to: context localSize do: [:i | valueStream nextPut: (context localAt: i)].		context _ context sender].	values _ valueStream contents! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:18'!numArgs	^ 1! !!Continuation methodsFor: 'as yet unclassified' stamp: 'avi 4/24/2004 12:39'!restoreValues	| valueStream context |	valueStream _ values readStream.	[valueStream atEnd] whileFalse:		[context _ valueStream next.		1 to: context class instSize do: [:i | context instVarAt: i put: valueStream next].		1 to: context localSize do: [:i | context localAt: i put: valueStream next]]! !!Continuation methodsFor: 'private' stamp: 'ab 6/15/2003 19:13'!terminate: aContext	| context |	context _ aContext.	[context notNil] whileTrue: [context _ context swapSender: nil]! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:13'!value	self value: nil! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:12'!value: v	self terminate: thisContext.	self restoreValues.	thisContext swapSender: values first.	^v! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:22'!valueWithArguments: v	v size == 1 ifFalse: [^self error: 'continuations can only be resumed with one argument'].	self value: v first! !!Object methodsFor: '*seaside2' stamp: 'mb 3/16/2006 10:32'!asSeasideString	^ self displayString! !!Object methodsFor: '*seaside2' stamp: 'mb 3/23/2006 07:32'!convertSeasideString: aString	^ aString! !!Object methodsFor: '*seaside2-squeak' stamp: 'lr 7/12/2005 17:01'!displayString	^ self asString! !!Object methodsFor: '*seaside2' stamp: 'ab 10/1/2002 13:47'!inspectorFields	|members|	members _ self class allInstVarNames					collect: [:ivar | ivar -> (self instVarNamed: ivar)].							self class isVariable ifTrue:		[members _ members, ((1 to: self size) collect: [:i | i -> (self at: i)])].	^ members! !!Object methodsFor: '*seaside2' stamp: 'avi 9/1/2004 21:20'!isIdenticalToSnapshot: anObject	1 to: self class instSize do:		[:i | (anObject instVarAt: i) == (self instVarAt: i) ifFalse: [^ false]].	self class isVariable ifTrue:		[1 to: self size do: [:i | (anObject at: i) == (self at: i) ifFalse: [^ false]]].	^ true! !!Object methodsFor: '*seaside2' stamp: 'avi 3/14/2005 15:19'!labelForSelector: aSymbol	^ aSymbol asCapitalizedPhrase! !!Object methodsFor: '*seaside2' stamp: 'ab 10/26/2002 20:05'!renderOn: aRenderer	aRenderer text: self! !!Object methodsFor: '*seaside2' stamp: 'avi 9/1/2004 21:19'!restoreFromSnapshot: anObject	1 to: self class instSize do: [:i | self instVarAt: i put: (anObject instVarAt: i)].	self class isVariable ifTrue: [1 to: self size do: [:i | self at: i put: (anObject at: i)]].! !!Object methodsFor: '*seaside2' stamp: 'avi 9/1/2004 21:20'!snapshotCopy	^ self shallowCopy! !!Object methodsFor: '*seaside2' stamp: 'mb 3/23/2006 17:53'!validationError: message	^WAValidationNotification raiseSignal: message! !!SeasidePlatformSupport class methodsFor: 'startup' stamp: 'mb 11/27/2005 10:16'!addToStartUpList: anObject	Smalltalk addToStartUpList: anObject.! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'avi 9/18/2003 16:43'!base64Decode: aString	^ (Base64MimeConverter mimeDecodeToChars: aString readStream) contents		! !!SeasidePlatformSupport class methodsFor: 'email' stamp: 'avi 3/11/2004 13:13'!deliverMailFrom: fromAddress to: recipientList text: messageText	SMTPClient		deliverMailFrom: fromAddress		to: recipientList		text: messageText		usingServer: self smtpServer! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'avi 4/28/2004 11:40'!ensureAuthorInitials: aBlock	Utilities authorInitialsPerSe isEmpty		ifTrue: [Utilities setAuthorInitials: aBlock value].! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'mb 3/24/2006 18:11'!getDocumentWithUrl: url	"((( 		(WAUrl new			hostname: 'www.google.com'; 			addToPath: 'search';			addParameter: 'hl' value: 'fr';			addParameter: 'q' value: 'Seaside';			addParameter: 'lr' value: '';			yourself) getDocument	)))"	^ HTTPSocket httpGetDocument: url urlString args: url parametersForHttpSocket! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'avi 1/1/2005 15:05'!isProxy: anObject	^ (anObject class allSuperclasses includes: Object) not! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 13:04'!mimeDocumentClass	^ MIMEDocument ! !!SeasidePlatformSupport class methodsFor: 'factory' stamp: 'mb 3/24/2006 18:38'!mimeDocumentOfType: type from: aFilename	"(((		WACachedDocument clearCache.		(WACachedDocument fileName: 'SqueakDebug.log') asMIMEDocument.		(WACachedDocument fileName: 'SqueakDebug.log') asMIMEDocument.	)))"	| content mimeType |	mimeType _ type ifNil: 		[self mimeDocumentClass guessTypeFromExtension: (FileDirectory extensionFor: aFilename)].	content _ (StandardFileStream readOnlyFileNamed: aFilename) contentsOfEntireFile.	^self mimeDocumentClass				contentType: mimeType 				content: content.! !!SeasidePlatformSupport class methodsFor: 'exceptions' stamp: 'mb 1/13/2006 09:54'!openDebuggerOn: anError	| process |	process := Processor activeProcess.	WorldState addDeferredUIMessage:		[process 			debug: anError signalerContext			title: anError description			full: true].	process suspend! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 11:18'!profileSendsDuring: aBlock	Processor activeProcess priority: 20.	Smalltalk garbageCollectMost.		^ String streamContents: 			[:stream | 			(MessageTally new)				spyEvery: 1				on: [aBlock value. Smalltalk garbageCollectMost];				report: stream]! !!SeasidePlatformSupport class methodsFor: 'factory' stamp: 'avi 4/27/2004 14:25'!readWriteStream	^ RWBinaryOrTextStream on: String new! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'mb 5/30/2006 12:30'!request: aString	^FillInTheBlank request: aString! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'mb 6/2/2006 11:15'!seasideBanner	"This is a copy of http://www.netstyle.ch/include/seaside/pics/top.jpg"	"(((		| mimeDoc |		mimeDoc _ 'http://www.netstyle.ch/include/seaside/pics/top.jpg' asUrl retrieveContents.		Clipboard clipboardText: 			(Base64MimeConverter mimeEncode: mimeDoc content readStream) contents	)))"	^self base64Decode:'/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCABrAx0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDodEnSDXLcs2EuImhDdMN2rZuLK4t7tr/TGWO7HEsTcJOPf0PvXH2zrcQmF22kkFGHVT2NdhpWpnUYTHPhb6AASr/fH98f1rppPTke6MprqupoQS6Z4mtGSe2Hmp8skUgxJG386xL/AMNXlipe0Zr22A/1LnEij/ZPer13YtLMt3aSfZ9QjGElHRx/df1H8q0tJ1lb9mtrhPs9/FxJAe/uvqKJw0tugjL7zzx7aK53eVkSLw0bDDCs6W3eNiCK9U1XQLLVv3jqYrkD5Z4+GH+Ncbqem3emkjUI98GcC6jHH/Ah2qIuUfg1XYp2e5zBGKStK4087RJGQysMqw5BqmLZ92MVvCvCSvczlBodawmSQDFdTounf2hqkcJGba0xJNxwX/hWsq1hNrD5gTdIxCxJjO5z0Feg6Jpo0vTY4TzM2XlY9S561zc/tJufRbepry8seXuaVcrBJ/aGt31+eY4s2sJ7fKcsf1rZ12+/s/SJ5h/rGXy4x3LNwKzLC1FnYQW/VlUFz6ucbv1rejHqZzfQTVLk2ej3kyn955ZRP95uBXG6k3lRpCDkRqEz9K6TX5R5lha54LNO+PRQNv61x9/KXmP1rOfv1Yx7alLSDZTNFFFdhiFFFFABRRRQAUUUUAApRSCnCgBRSikFKKQDhSikFKKBjhSikFOFIBwpRSCnCkAop4pgp4oAUU4UgpwoAcKcKaKeKBiinCkFOFIBwp4pgp4pAOFPFNFOFIY4U4UgpwpAOFPFNFOFAx4p4pgp4pAOFPFNFPFIY4U4U0U8UAOFPFNFOFIY4U8U0U4UgHinimCnigBwp4pop4pAKKeKaKeKQxRTxTRThSAeKcKaKeKQCiniminCgBwp4pgp4oGOFKKQU4UgHCnCminCgYop4popwpAKKcKQUySVIly7Y9B3NICYUorOe/c8RqFHqeTUBuJmOTI34HFIZtClFRwkmGMnklRk1IKAFpaSloAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPnmKQxsCDWxbztK0c0MnlXcRzG/r7H2rDqWGZo2BBrsq02/ejujGE7aPY9B03U49RjYFPKuY+JYj2PqPapL2wS9VG3tDcxcw3CfeQ/1HtXJ287TPHNDIIruP7j9j7H2rqdO1Bb6Jgy+XcR4EsR6g+o9jRTqqej3QSi1r0Lula07zjT9TRYb4D5WH3Jx6r/hWyyq6lWUFSMEEZBrn7u0hvoPJnU4Byjrw0beoP+RS6fq89lPHp+ruCW4t7scLKPQ+jVM6fVDjLoyK/wDCiqzTaU6wO3LQPzGx/mKwZbS4t5dlzplysmcDyl3q30Ir0SiuecIz+JfoWpOOxy+gaJN9pXUNQj8t0BFvATny/c+9dRRTJJEhiaSRgFUEknsKryQvNnPau/27xBa2Q5htFNxKO27+AVaALMB1JNZuj754ZtQlGJL6TzMHqFGVUflWvaJvuF44HJrrS5YmW7OU1eUvq18/8MCrboe3ABb9cVyk53SE1018jfa9UjOd63TMQfQgYNc1OjK5yK5qLvWlc0mvcRFRRRXaYhRRRQAUUUUAFFFLQAUopKUUAKKcKaKcKQCinCminCkMUU4U0U8UAKKeKYKeKQCinCkFKKAHCniminCgBRTxTRThSGPFOFNFOFADhThTRTxSAcKeKYKeKQx4pwpop4pAOFOFNFPFAxwpwpop4pAOFPFNFOFIY8U8UwU8UAOFPFNFPFIY4U4CminikA4U4UgpwpAOFPFNFOFIY8U4U0U8UAOFOFNFPFIBwpwpopwpAPFOFNFPFACinCminCgY8U4U0U4UgFFPFNFOFIYopwpBQzBVZj0AyaAGTziFeOWPQVnO7OxZjknqTSu5dyx6mp4o0hh+0TfdHIBqG0ldjSvohsVpJIMn5F9TT2+wQ8ST7j3wc/yrOu76S6cgErH2UHr9aq15VbM7O1NfNnZDCXV5M6JNRsgAizAADAypFW45UlXMbq49Qc1yVOikeFw8bFWHpWcM0nf34/cVLCLozrxS1nadqIuwY3GJQMnHQ1o161OpGpHmjsccouLswooorQkKKKKACiiigAooooAKKKKACiiigAooooA+daKKK9M5SaGZo2BBrbtriWRo7m2cLdxDC56OP7prnqtWk5ikGDXNWpv44bo1hL7L2PQ7K7iv7NbmHgE7WU9UbuD/AJ5FPnghuoGt7mMSQt95T/Me9c7o96LLVo5Cf9GvSI5lPQP/AAtXWzWjxsSoLL6jqKuFRSSfcmUWnYzbTUZ9DkS2v3abT2O2G7Iy0Z/uv/jXSgh1BBBBGQRyDWMYTMjRNF5kbjDIVyCKl0fTbjTWkiFwXsiAYYn5aM85GfSoqRW5UWatYviYTzaatjbI5e7kEZdRnYvUmtqisouzuU9UZMdk4Ajjj2RqAFB4AFaMECwJgck9TUtFVKo5aCUUjm9f0Sea6GoWKK820JNCTjzFHofWuRnS3dzHNutpu6TrtI/HpXqVRTW8NwuyaJJF9GXIrJxUnd79ylJrQ8sOlF13RkOD0KnIqFtLlH8Jr0abwvo8xybNUJ7xkrVdvCFhjEdzfRAdAk5wPzzVXmtp/gHuvdHnp0+UfwmozZSDsa9APhIrny9VuRn+8qt/OoX8KXynMepxSj0ktwP5U+eqtmv6+QuWHY4I28i9VqIoV6iu3m8OaqhJ+z2k4HaNyhP55rFu7MRSLFc20tpI3CiUfKx9mq1WqL4l9wnCL2Zg0CrFzbtA5BGCKriumMlJXRk007MUU4U0U4UxAKcKQU4UAAp4popwpDFFOFNFPFACinCminCkA4U4UgpRQA4U8UwU8UAOFOFNFOFIY4U8U0U4UgHCniminCgBwp4popwpDHCniminCkA8U8UwU8UhjhTxTRTxSAUU8U0U8UDHCnCminigBwp4popwpDHinimCnikA4U8U0U4UgHCniminikMUCniminigBwpwpop4pAOFOFNFOFIBwp4popwoGOFOFIKcKAFFPFNFOFIBRThSCnCkMcKrXrkIqDucn6VZFUbw5mA9AP60mMjgj82ZVPTqai1W43zCEcKmCfc1csB87t6ACsadt08jerE89a8zM6jjTUV1OrCxTld9BlFFFeGegFFFFADo5GhkWRD8ynNdVbyieBJR0YZrk6l1az1DVfAWr2OmSeXeywyRwkNtJJHTPbPIz2zXpZZUaqOHRnJioJxUjes9a0vULiW3stSs7meH/WRwzK7J9QDxUt7qFnptu1xfXcFrAOsk8gRR+JrybwVB4Ql13RbY6dd+HPFOmxFTatH5X2v5CGySD5gPJ7H6gVlLrug+IPGms6h4utdQv4rG6e0sLKK0eaCJFOCzBQRuOO/8sY9w4bHttjqVjqkHn6fe293DnHmQSh1/MVLcXMFpA09zNHDEgy0kjhVX6k14jcatoOj+JtK1fwXpWp2cz3KQX9qunyxQS27feJBGAwOCMV0t1pcPj/4m6rp+sM8mkeHkhEdmHISaaVS298dcDj/JyBY9AttZ0u9gkntNSs54Yv8AWSRTqyp9SDxU1xfWlpZtd3FzDDbKNxmkcKgB77jxXmHxH+HGh2vhDU9V0S2Gl3Vras0n2VjGk8QwWR1HBGB+dO8Waddz+FvBV+NKl1fSdPSOW/06FQzSKYgFbZ/Ft549/TJAI9Dk1FL/AEK5vNGvbKdjC5gn80PCHAOCzKegOM+1O0OS+l0Ozk1KW1lvWjBme0JMTN6oT2rznTV8JzeB/GuoeFZpo47qxmNzp7jYts4iccR4yuee5BxgdMDOlv70/DLwH4bsLl7N9dEdtLcx8NHEAN230JyPwyO9AHq6a9o8l+bFNVsWvAcfZxcIZM/7uc1heC/Ed9r9/wCJoLwQhNN1WWzg8tCp2L03c8n8qrD4S+ChpA0/+xYuFx9pyfPz/e39c/p7YriPB15P4L8F/ECWKRri403UZoo5ZOS7ABFZvxwTSGeu3uvaPps6wX+q2NrM33Y57hUY/gSKvI6yIHRgyMMgg8EV4X4dk8Aw6PHLrmjanquq3SCW8urrTZpmaRgN21sdM9CPrmuh+Gd/HbeKtV0TSY9S/wCEeaAXVmt7C6fZ33APGu4dDuBH0+pphY9WooooEfOtFFFemcoUqZ3DFAGavWVm0rjis6lSMItsqMXJ2RZcldLdiSCpVgR1zXqkRZoULDDFQSPSuC0rSjq94sQH+g27AzP2kYfwiu/zXHC6gr9dTaXxaC0U0kAEk4A5JNZUGv211fSQQI8kMYO64H3N390etUot7Cuka9FQxTpMCVPI7HrUuaTVtGAyZ2SGR0TeyqSq5xk1z/8AbusdtEA/7eFwa6Osq5hMMpwPkPINaU1F6MmV+hR/t3Wc5/sRcehuACP8aT+29ax/yBo/Y+eP5VZzRmtuSPYjmZW/tvW88aPED3BuRj86P7a1z/oEw4/6+ACKs5ozRyR7BzMqnWdd/wCgVbg+v2jIP+FL/bOvZ40q2/G4FWgjsMhCQOpxxTZpYLcZubmCHHUSSAGjliO7K39r69/0DLbHY+fz+VQ3t9f3FjOmq6fapZiNjIwm3EcHGPfOKSXxBp6nbarNeydhGm1P++jWLf6jPeFTemNIUOUtozlc+rHvWc5wh6/iUoykZV7n7NBvOX8tck9TwKzas3dwZ5SxOcmq1VQi1HUmbuxaUUgpRWxAopwpBSigYopwpBSikA4U4U0U4UAOFOFIKUUgHCnCminCgBwpwpBThQA4U4U0U8UhiinCkFOFIBwp4pgp4pAOFPFNFPFAxRTxTRTxSGOFOFNFPFIBwp4pgp4pAPFOFNFPFAxwp4popwpAPFOFNFPFAxwpwpoFPFIBwp4pgp4pAPFOFNFPFIY4U4UgpwpAOFOFNFPFIBwpwpop4oAUU4UgpwoGOFOFNFPFACinCkFKKQDhThSCnCkMUVRvRiYH1A/rV4VXvU3Rq4/hOD9KTGMsD87j1ANZF0hjupFIAwxOB0xWhBJ5Uyv2HBp2q2u8C4QZwMNj09a87MaTnS5l0OnDTUZ2fUyKKKK8E9EKKKKACrWo2Gr3Pg27i0O9NlqjjzLeUgEbgRwcgjBAx+NMtLZrqcRjp1Y9MCuoRVVAq4AAxgV6uWUnzOo9tjjxc1ZRPMhaeKvGXiTw/Pq/hxNFi0ef7TNctcJI0zgfcjC87SeTnt3yOZ7zR/E/gvxJqGq+F9Pi1bStTk8+600zCJ45j950Y8c9/wAscA16TRXsnCcJo1x461/X7e71OzXw7o1uCzWiypPNdN2DNj5VHtg9uc5EXiHQvEOj+LH8V+E4ILx7mJYtR06WTy/tG0fK6seAwHH+OSK9AooA8j8UD4jeN/Dt3p8Ph2HRLcxkyRzXqyS3WP8AlmpAwoPqcZ9cZz0GoweLtFsPDl3o9ub2OztVh1HSRIimT5AAyue6kHvzx1rvKKAPMNO8Oa9qMfjXW77S49Ou9bsTa22nrKrNxGyhnYcZJI+nOan/AOEDv9R+Gegac0n9n6/pKRzW0hYMIpk7MVzkH2z2POMH0iigDzhPEfxKaEWDeCrZb7G3+0G1BPs4P9/YPm/DOf5VF4H8E6pBoPinSvFKK7ardyM8yOD5wdcGRcdOckAgEV6ZRQB5fp+ofETwnZx6NJ4ai8QxW6iO2v4LxYS0Y+7vVs8gYHb6nqeo8H23ihYbq98U3sTXN04aKxgVfLtEH8IYDLE55yT04rqKKACiiigD51oAJNAGTV60tt5ycADkk8AV31Kigrs54xbdhbSzMjAkcdcnoBW/pmmPqbGKBjHZqcSzjgv/ALKf41Dp1gdSIBJjsVPJ6NMf8K66KSOCJYolVI1ACqBgCuXlcnzz+41ukrRLttDBZ26QW6KkaDCqOgour63soGnuZVjjUZLE1kahrcNgqjmWd+EiTljWQsct5Ot3qbh5AcxwjlI/8TWkafNqyXK2xbuLm718/PvtNNJ4TpJOPf0FXYljgiWKJFSNRhVAwBVXzx60eePWt0klZGZp2suy4Xng8Gl1PUprK808AIbeeXypCRyCRxWas+GBz0Io8Qnz9GlKn95ERKp91INZziuZXLT0Ok301yrqQwBB7VmW18txaxTA8Oob86l+0+9Y2aKuJeGysYWnuZ/KjHcnrWJJ4gibJtNPnlUfxzP5an+tUNZu/tGsuWIKWsYCA8gO3Oawrm/dmIDE03OfNyRHyxtdnQya5fsPlSxgHodzkf0/pVZ9WvWPz6q4HpDEqf41zhuHbvTDIx71Xs6r3kTzQXQ25btHJM1zdz+0kxx+mKr/AGm0iGI7aIH1K7j+tZRYnvSZo+rt/FJsPaW2Rpy6pIwwGOPaqMk7OeTUVFaQoQhsiZTlLdh1pRSClFakCilFApRQAopRQKUUDFFOFIKUUgHClFIKcKAHCnCminCkAop4popwoAcKcKQU4UAKKeKaKcKQxwp4popwpAOFOFIKcKQDhTxTRThSGPFOFNFPFAxwpwpBThSAcKeKaKcKQDhTxTRTxQMcKeKYKeKQx4pwpop4pAOFPFNFOFADhTxTRTxSAUU8U0U4UhjxThTRTxSAcKcKQU4UgFFPFNFOFADxThTRThQMcKcKaKcKQDhThSClFADhThTRTxSGApSodSp6EYoFOFIDi/FOtnQohBGpa7lUlCR8qj+97/T86zfCHjNbdRp+qy4jOTHO56ezV2ut6Ja67Ym2uVwRykg+8jV5DrOg32h3Jiu4/kJIjlHKv9P85rekoSjyvczm5J3PWrrSxJ++tCpVhkKDwfpWbLDLCSJI2XHHI4rz/RfFeqaIBHBKJYMg+VLllA9vSustvihAU/0rTJFbPWKQMD+eK8yvk8ZO8NDrp41pWkaIVmYAKST6DJq7b6XczkEp5aHu3+FZLfE/TgPksLsn0YqP6msPUfiRqd3GY7OCKzBGC27e/wCBwB+lZ08l1993/D/MqWO7I7HWtdsPCtiVXEl24+SLPLH1b0Fcd4c8czWeoTnVHaSC5cyM4GfLbGOB6cCuRdri9umY+ZPcStk4G5mNaOqeGtU0e1iuby22RyAcg52H0b0NezToU6ceQ4ZVJSfMe3W1zDeW6XFvIskTjKupyCKmrwjSfEGp6LJmyuGVD1ib5kPXt2/Suxtfij0F3phxj70Mmc/gR/Ws5UJLYpVF1PRqK4U/E/TccWF4W99uP51lX3xNvJVZLKxjgJ4Du+8/lgD+dSqM30HzxO91jW7HRLXz7yULnhUHLMfYV5nZ+OL2PxO+oTuTaynY0IHAQZ249x69+a5u6vLrUrsz3UrzTvgbjyT7VozeFtYh0pNRezfyWwSoGXUepX0reNKMVaXUzc29j2TTtTtNWtFubOVZI2Hbgj2I7VdrwHTdVvdIuftFjO0TnAOOQw9CK7Kx+J9wiqt/p6SnvJC+3/x05/nWcqEl8JaqLqemUVwv/Cz9Mx/x43m70+XH86z7z4oSsrLZ6aqEj5Xmkzj/AICB/WoVKfYfPE77UNRtdLs3u7yURQoMknv7AdzXmGp+PL2XXo7uyG22gOEjb/loD1z9cfhXO6lrF/q85mvbl5Tn5VPCr16DpW94X8Fz61surotDY5B6YaQe3+NbRpxgrzIcnJ2R6dourwa5psd7bq6q3BVhyCOorRqG2tobO2S3t41jijG1VA4AqauZ2voarzPnyCPc3PTuTWpaQi7YA5Fqp57GQ/4VnxjcRGDgHlyPStEXKxoAMKijAHYV18t3zMxvZWRvLchFCrgADAA4Aqlc6zIzGC0w0nRnP3UrGe7kuMqrFIzwWHU0qSLGoVBgDsKtQ7ibNG3C27NIWMkzfflbkmrH2k4zngd88ViPehThRvb0HQVBJOX/ANa+4f3Bwoqm7CNl9ViUkIWlYdoxkfnSLqyhgJYXiB4Dlgw/GsIzkDCjA9BxTknzkHkHgg9xUNy3sVZHSi5OQM1de6DoyHkMCCK5e1uCv7otnbypPdaufafem1cSL+kXZjsRATzCzJV03h9a5qKcx3koB4kAYVZ+0n1pOOo0yvdTbprt88tKRn6AVkucsTVqV8mX3kJ/lVQ9aIRtJsUnoFFFFakhRRRQAUUUUAApwpKUUAKKUUgpRSAcKUUgpwoGKKcKaKcKQDhSikFOFIBRTxTRThQAopwpBThQA4U4U0U8UhiiniminCgBwp4pgp4pAPFOFNFOFIY4U8U0U4UgHCniminigY4U8UwU8UgHinCminikMcKcKQU4UAOFPFNFPFIYop4pop4pAOFPFMFPFADxThTRTxSAcKcKaKeKQxwpwpopwpAPFOFNFPFIBwpwpop4oAUU8U0U4UDHCnCminCkA4U4U0U4UDHCnCminCkAopwpBSikA4VHc2sF5A0FzEksTDDKwyDUgpRQBxWqfDexuWaTT7h7VzzsYb0/xrmrn4d69AWMSW9wAePLlAJ/76xXrgpRWirTRLgmeNxeAvEUrYayWIY+88yY/Qmtqw+GNy7K1/fRxrzuSBdx/M4/ka9LFLTdebBU0ZGkeG9L0QE2VviQ9ZHJZj+JrUkjSVCkiKyMMFWGQafRWTberLSscdqvw70q9YyWbPZSEdEG5D/wE/0xXLXPw31qJz5MlrOnYhypP4Ef1r1qirjVmupDgmeMR+BPEbuFNgEB/iaZMD8ia1bL4Z6jKwN7d28CZ5EeXY/yH869SoqnXmxezRz2keDdH0hlkjg864XGJZjuI+g6CugIBBBGRS0Vk23qy0ktjl9V8C6PqZaRIjaztzvh4B/4D0rkbv4aatE/+jXNtcJjqxKN+XI/WvVqKuNWceonBM8XbwL4kDMBp2QDjcJo+f8Ax6tG0+Guryv/AKRcW0CY6hi5/Lj+der0VTrzJ9mjldJ8B6RpjCWVGu5gchpvug+y9P511IAVQAAAOwpaKycnLctJLYKKKKQzwT+wfGsTSbfDG4bsBvtYGf8Ax2mHQPG7nL+FuB0X7YMf+g1773orT2s+5PJE8DOh+Nh08Kkn2ux/8TUbaD46b/mVePQXgH/stfQIop+2n3DkifPn9geOsYHhQAegvB/8TSHw945P/Mqf+Tg/+Jr6Eope1n3DkR89/wDCO+Of+hT/APJwf/E0Dw745H/Mp/8Ak4P/AImvoSij20+4ckT5+XQfHSspPhTGO/2wf/E1Y/sTxv8A9Ct/5OD/AOJr3mgdKPaz7hyI8DfQ/G+9W/4Rbpwf9LH/AMTT/wCxPG//AEK3/k2P/ia95PSij2s+4ciPn59A8cFjjwpnJz/x+D/4mmf8I745/wChT/8AJwf/ABNfQneij20+4ckT56/4R7xz/wBCp/5OD/4mj/hHvHP/AEKn/k4P/ia+haKftp9xckT56/4R7xz/ANCp/wCTg/8AiaP+Ee8c/wDQqf8Ak4P/AImvoWij20+4ckT56/4R7xz/ANCp/wCTg/8AiaP+Ee8c/wDQqf8Ak4P/AImvoWij20+4ckT57/4R3xz/ANCp/wCTo/8AiaP+Ee8c/wDQp/8Ak6P/AImvoSij20+4+SJ8+f8ACP8Ajn/oU/8AydH/AMTS/wBgeOf+hT/8nR/8TX0FRR7afcOSJ8/f2B45/wChS/8AJ0f/ABNL/YXjn/oUv/J0f/E19AUUvaz7hyRPn/8AsLxz/wBCl/5Oj/4ml/sTxz/0KP8A5Oj/AOJr3+ij2s+4ckTwEaL45/6FH/ydH/xFKNG8c/8AQo/+Tw/+Ir32ij2s+4ckTwP+x/HP/Qof+Tw/+IpRpPjn/oUP/J4f/EV73RR7WfcOSJ4L/ZXjn/oT/wDyeH/xFKNL8c/9Cf8A+Tw/+Ir3mij2s+4ciPBxpvjn/oT/APyeH/xFKNO8c/8AQnf+T4/+Ir3eij2s+4ciPChp/jkf8yd/5Pj/AOIoFj45/wChO/8AJ8f/ABFe60UvaS7hyI8MFl45/wChN/8AJ8f/ABFKLTxz/wBCb/5Pj/4ivcqKPaS7hyo8PFr45H/Mmf8Ak+P/AIilFv45H/Mmf+T4/wDiK9voo9pLuHKjxEQeOR/zJf8A5UB/8RSiLxyP+ZL/APKgP/iK9too9pLuHKjxMR+OR/zJX/lQH/xFOC+Of+hK/wDKgP8A4ivaqKPaS7j5UeLD/hOR/wAyT/5UR/8AEU4N45H/ADJP/lQH/wARXs9FHPIOVHjIfxyP+ZJ/8qA/+IpRJ45H/Mkf+VEf/EV7LRS55Byo8cE3jkf8yR/5UR/8RSi48cj/AJkf/wAqI/8AjdexUUc8g5UePi58cf8AQj/+VIf/ABuni68b/wDQj/8AlRH/AMbr12ijnkHKjyQXXjb/AKEj/wAqI/8AjdPF3417+Cv/ACoj/wCN16xRRzsOVHlQu/GffwXj/uID/wCN08XfjLv4Mx/3EB/8RXqVFHMwsjzEXnjDv4O/8nx/8RTxd+Lu/hDH/b+P/iK9Loo5mFkebi78Wd/CWP8At+H/AMRTxd+K+/hPH/b8P/iK9Foo5mFkefC78Ud/CuP+30f/ABFSC78Td/DGP+3wf/EV3tFLmYWRwwu/Enfwzj/t8H/xFPF14i7+HMf9vf8A9jXbUUczCxxgufEHfw9j/t6/+xqQXOvd9Ax/28//AGNdfRRdjscoLnW++h4/7ef/ALGni41nvomP+3j/AOxrqKKLsLHNifV++j4/7bj/AOJp4n1XvpWP+23/ANauhoouFjBE2p99Lx/22/8ArVIJdR76dj/tqP8ACtqii4WMgS3/AHsMf9tf/rU8S3vexx/21/8ArVqUUrgZwku+9pj/ALaf/Wp4e5722P8AgdXqKLgVA8/e3x/wOnBpu8OP+BVZooAhDS94/wDx6nAv/c/WpKKAGgt/d/WlBPpS0UAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//2Q=='! !!SeasidePlatformSupport class methodsFor: 'email' stamp: 'avi 3/11/2004 13:10'!smtpServer	^ MailSender smtpServer! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'mb 10/12/2006 20:14'!versionString	^SeasideVWInfo new versionString! !!SeasidePlatformSupport class methodsFor: 'as yet unclassified' stamp: 'tonyg 1/3/2006 10:40'!vmStatisticsReportString	^ SmalltalkImage current vmStatisticsReportString ! !!SeasidePlatformSupport class methodsFor: 'exceptions' stamp: 'mb 3/23/2006 08:12'!walkbackStringsFor: anError	^(anError signalerContext sender stackOfSize: 20) 		collect: [:ctx | ctx printString].! !!SeasidePlatformSupport class methodsFor: 'factory' stamp: 'ab 7/3/2003 13:02'!weakDictionaryOfSize: aNumber	| dict |	dict _ WeakIdentityKeyDictionary new: aNumber.	WeakArray addWeakDependent: dict.	^ dict! !!WAAbstractHtmlBuilder commentStamp: '<historical>' prior: 0!I am abstract class providing methods to build xhtml.  My most commonly used subclass is WAHtmlRenderer.!!WAAbstractHtmlBuilder class methodsFor: 'encoding' stamp: 'lr 6/14/2006 08:00'!encode: anObject	^ String streamContents: [ :stream | self encode: anObject to: stream ]! !!WAAbstractHtmlBuilder class methodsFor: 'encoding' stamp: 'lr 6/14/2006 08:00'!encode: anObject to: aStream	| charOrString |	anObject displayString do: [:char |		charOrString := HtmlCharacters 			at: char asInteger + 1 			ifAbsent: [ char asCharacter ].		charOrString isString			ifTrue: [ aStream nextPutAll: charOrString ]			ifFalse: [ aStream nextPut: charOrString ] ]! !!WAAbstractHtmlBuilder class methodsFor: 'initialization' stamp: 'avi 6/25/2004 20:46'!initialize	"WAHtmlBuilder initialize"	HtmlCharacters _ Array new: 256.		0 to: 255 do: [:ea | HtmlCharacters at: ea + 1 put: ea asCharacter].		#($" 'quot' $< 'lt' $& 'amp' $> 'gt') pairsDo:		[:c :s | HtmlCharacters at: (c asInteger + 1) put: ('&',s,';') ]	! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 2/19/2004 01:08'!acronym: titleString do: aBlock	self attributes at: 'title' put: titleString.	self tag: 'acronym' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 3/1/2004 20:49'!anchorWithMailto: emailString	self anchorWithUrl: 'mailto:', emailString do: emailString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 3/1/2004 20:50'!anchorWithMailto: emailString subject: subjectString	self anchorWithUrl: 'mailto:', emailString, '?subject=', subjectString do: emailString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:38'!anchorWithName: aString	self attributes at: 'name' put: aString.	self tag: #a! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 5/3/2005 08:50'!anchorWithPopupUrl: urlString extent: aPoint do: anObject	self 		anchorWithPopupUrl: urlString 		name: ''		extent: aPoint 		toggles: #(menubar resizable scrollbars) 		do: anObject! !!WAAbstractHtmlBuilder methodsFor: 'javascript' stamp: 'ac 12/10/2004 17:20'!anchorWithPopupUrl: urlString extent: aPoint text: aString	self 		anchorWithPopupUrl: urlString 		extent: aPoint 		do: aString! !!WAAbstractHtmlBuilder methodsFor: 'javascript' stamp: 'ac 12/23/2004 04:42'!anchorWithPopupUrl: urlString name: nameString extent: aPoint toggles: aCollection do: anObject	self attributes		at: 'onClick' 		put: (self popupStringWithUrl: urlString name: nameString extent: aPoint toggles: aCollection), '; return false'.		self anchorWithUrl: urlString do: anObject. ! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:38'!anchorWithUrl: urlString do: aBlock	self attributes at: 'href' put: urlString.	self tag: 'a' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:37'!anchorWithUrl: urlString title: titleString do: aBlock	self attributes at: 'title' put: titleString.	self anchorWithUrl: urlString do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 4/24/2004 13:05'!attributeAt: aString put: anObject	self attributes at: aString put: anObject! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'ab 5/12/2003 11:27'!attributes	^ attributeBuffer ifNil: [attributeBuffer _ WAHtmlAttributes new]! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'ab 1/11/2003 12:44'!attributes: aCollection	aCollection associationsDo: [:x | self attributeAt: x key put: x value]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:02'!bold: aBlock	self tag: 'b' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:02'!break	self tag: 'br'! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'ab 7/3/2003 14:56'!buttonForUrl: urlString withText: labelString	self buttonForUrl: urlString withText: labelString data: #()! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'mbany 4/14/2005 12:22'!buttonForUrl: urlString withText: labelString data: assocCollection	self formWithMethod: 'GET' action: urlString do:		[assocCollection do: 			[:each | self				inputWithType: 'hidden'				named: each key displayString				value: each value].		self submitButtonWithText: labelString]! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'mb 11/27/2005 10:22'!buttonWithType: typeString named: nameString value: valueString do: aBlock	nameString ifNotNil:		[self attributes			at: 'name' put: nameString;			at: 'id' ifAbsentPut: [nameString]].	valueString ifNotNil: [self attributes value: valueString displayString].			self attributes type: typeString.		self tag: 'button' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 11/20/2003 18:44'!closeTag: aString	self document closeTag: aString ! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ab 2/12/2003 21:04'!cssClass: aString	self attributeAt: 'class' put: aString! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ab 2/12/2003 21:04'!cssId: aString	self attributeAt: 'id' put: aString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!div: aBlock	self tag: 'div' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ab 2/16/2003 00:33'!divClass: aString with: anObject	self cssClass: aString; div: anObject! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ab 2/16/2003 00:33'!divNamed: aString with: anObject	self cssId: aString; div: anObject! !!WAAbstractHtmlBuilder methodsFor: 'accessing' stamp: 'avi 11/20/2003 18:45'!document	self subclassResponsibility ! !!WAAbstractHtmlBuilder methodsFor: 'dnu' stamp: 'ab 5/24/2003 00:41'!doesNotUnderstand: aMessage	| argCount |	argCount _ aMessage arguments size.	argCount = 0 ifTrue: [^ self tag: aMessage selector].	argCount = 1 ifTrue: [^ self tag: aMessage selector allButLast do: aMessage argument].	^ super doesNotUnderstand: aMessage! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'rbb 6/13/2003 00:07'!emphasis: aBlock	self tag: 'em' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'mbany 4/14/2005 12:21'!encodeCharacter: aCharacter	self html: ('&#', aCharacter asInteger displayString, ';').  ! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'jf 2/18/2004 15:02'!encodeText: anObject	"deprecated"	self text: anObject! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'mb 2/9/2006 14:23'!ensureCssClass: aString	self attributes at: 'class' ifAbsentPut: [aString]! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'mb 2/9/2006 14:21'!ensureCssId: aString	self attributes at: 'id' ifAbsentPut: [aString]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 17:39'!fieldset: aBlock	self tag: 'fieldset' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'mb 2/9/2006 17:42'!fieldsetWithLegend: aString do: aBlock	self fieldset: [		self legend: aString.		aBlock value.	]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'jf 1/12/2004 16:16'!formWithAction: actionUrl do: aBlock	self formWithMethod: 'post' action: actionUrl do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:38'!formWithMethod: methodString action: actionUrl do: aBlock	self attributes		 at: 'method' put: methodString;		 at: 'action' put: actionUrl.	self tag: 'form' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!heading: aString	self heading: aString level: 1! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mbany 4/14/2005 12:20'!heading: anObject level: aNumber	self tag: 'h', aNumber displayString do: anObject! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!horizontalRule	self tag: 'hr'! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'jf 2/18/2004 15:01'!html: aString	self document text: aString.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'jf 1/12/2004 16:21'!image: urlString	self image: urlString altText: ''! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 18:02'!image: urlString altText: altString	self attributeAt: 'alt' put: altString.	self attributeAt: 'src' put: urlString.		self tag: #img.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:39'!image: urlString height: height	self attributes at: 'height' put: height.	self image: urlString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:39'!image: urlString height: height altText: altString	self attributes at: 'height' put: height.	self image: urlString altText: altString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:39'!image: urlString width: width	self attributes at: 'width' put: width.	self image: urlString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:39'!image: urlString width: width altText: altString	self attributes at: 'width' put: width.	self image: urlString altText: altString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:40'!image: urlString width: width height: height	self attributes		 at: 'width' put: width;		 at: 'height' put: height.	self image: urlString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'lr 8/3/2006 08:40'!image: urlString width: width height: height altText: altString	self attributes		 at: 'width' put: width;		 at: 'height' put: height.	self image: urlString altText: altString! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'JF 6/2/2003 19:26'!inputWithType: type	self inputWithType: type named: nil! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'JF 6/2/2003 19:25'!inputWithType: type named: name		self inputWithType: type named: name value: nil.! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'lr 5/10/2005 16:15'!inputWithType: type named: name value: value	name ifNotNil: [self attributes at: 'name' put: name].	value ifNotNil: [self attributes value: value displayString].			self attributes type: type; addClass: type.		self tag: 'input'.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'rbb 6/11/2003 17:01'!italic: aBlock	self tag: 'i' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 17:41'!label: aBlock	self tag: 'label' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 17:42'!labelFor: idString do: aBlock	self attributes at: 'for' put: idString.	self label: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'lr 8/3/2006 13:16'!layoutTable: aBlock	self attributes		at: 'border'put: 0;		at: 'cellspacing' put: 0;		at: 'cellpadding' put: 0.	self table: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'lr 8/3/2006 13:15'!layoutTableOfWidth: width do: aBlock	self attributes at: 'width' put: width.	self layoutTable: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 17:41'!legend: aBlock	self tag: 'legend' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!list: aCollection	self list: aCollection do: [:x | self text: x]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 3/15/2004 16:24'!list: aCollection do: aBlock	self unorderedList:		[aCollection do:			[:item |			self listItem: [aBlock value: item]]]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'jf 11/24/2003 11:54'!listItem: aBlock	self tag: #li do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 11/20/2003 18:51'!openTag: aString	self document openTag: aString attributes: self attributes.	attributeBuffer _ nil.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 7/26/2004 12:51'!orderedList: aBlock	self tag: 'ol' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 7/26/2004 12:52'!orderedList: aCollection do: aBlock	self orderedList:		[aCollection do:			[:item |			self listItem: [aBlock value: item]]]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!paragraph	self tag: 'p'! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!paragraph: aBlock	self tag: 'p' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'javascript' stamp: 'mbany 4/14/2005 12:24'!popupStringWithUrl: urlString name: nameString extent: aPoint toggles: aCollection	^ String streamContents:		[:stream |		stream 			nextPutAll: 'window.open(';			nextPut: $';			nextPutAll: urlString;			nextPut: $';			nextPut: $,;			nextPut: $';			nextPutAll: nameString;			nextPut: $';			nextPut:$,;			nextPut: $';			nextPutAll: 'width=';			nextPutAll: aPoint x displayString;			nextPutAll: ',height=';			nextPutAll: aPoint y displayString;			nextPut: $,;			nextPutAll: (self toggleStringFor: aCollection);			nextPut: $';			nextPutAll: ')']! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/16/2003 00:24'!preformatted: anObject	self tag: 'pre' do: anObject! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'ac 5/16/2003 16:11'!render: anObject	anObject renderOn: self! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 7/2/2004 14:21'!script: aString	self tag: 'script' do: [self html: aString]! !!WAAbstractHtmlBuilder methodsFor: 'head' stamp: 'lr 8/3/2006 13:16'!scriptWithUrl: urlString	self attributes		at: 'type' put: 'text/javascript';		at: 'src' put: urlString.	self tag: 'script'! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'jf 2/18/2004 15:04'!space	self html: '&nbsp;'! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 2/19/2004 18:20'!space: aNumber	aNumber timesRepeat: [self space]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 5/30/2003 00:29'!spacerRow	self tableRowWith: [self space]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!span: aBlock	self tag: 'span' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'mb 2/9/2006 14:23'!spanClass: aString with: anObject	self cssClass: aString; span: anObject! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ab 2/16/2003 00:35'!spanNamed: aString with: anObject	self cssId: aString; span: anObject! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'mb 2/9/2006 17:41'!strong: aBlock	self tag: 'strong' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'css' stamp: 'ac 11/26/2004 16:55'!style: aString	self attributeAt: 'style' put: aString! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!submitButton	self inputWithType: 'submit'! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'lr 8/3/2006 13:16'!submitButtonWithText: aString	self attributes at: 'value' put: aString.	self inputWithType: 'submit'! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:04'!table: aBlock	self tag: 'table' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableData: aBlock	self tag: 'td' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'avi 2/19/2004 18:11'!tableData: aBlock span: aNumber	aNumber > 0 ifTrue:		[self attributes at: 'colspan' put: aNumber.		self tableData: aBlock]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableHeading: aBlock	self tag: 'th' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/16/2003 00:26'!tableHeadings: aCollection	self tableRow: [aCollection do: [:ea | self tableHeading: ea]]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableRow: aBlock	self tag: 'tr' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableRowWith: aBlock	self tableRow: [ self tableData: aBlock ]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'avi 2/19/2004 18:10'!tableRowWith: aBlock span: aNumber	self tableRow: [ self tableData: aBlock span: aNumber]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableRowWith: aBlock with: anotherBlock	self tableRow: [ self tableData: aBlock; tableData: anotherBlock]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'ab 2/12/2003 21:05'!tableRowWith: x with: y with: z	self tableRow: [ self tableData: x; tableData: y; tableData: z]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'mb 2/9/2006 14:39'!tableRowWithLabel: anObject column: aBlock	self tableRow:		[self 			cssClass: 'label';			tableData: anObject;			tableData: aBlock]! !!WAAbstractHtmlBuilder methodsFor: 'tables' stamp: 'mb 2/9/2006 14:39'!tableRowWithLabel: anObject column: aBlock column: anotherBlock	self tableRow:		[self 			cssClass: 'label';			tableData: anObject;			tableData: aBlock; 			tableData: anotherBlock]! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 11/20/2003 18:40'!tag: aString	self openTag: aString.	self closeTag: aString.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 11/20/2003 18:40'!tag: aString do: anObject	self openTag: aString.	self render: anObject.	self closeTag: aString.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'avi 4/24/2004 13:03'!text: anObject	self html: (self class encode: anObject)! !!WAAbstractHtmlBuilder methodsFor: 'forms' stamp: 'mb 1/19/2006 18:02'!textAreaNamed: name value: value	name ifNotNil: [self attributes at: 'name' put: name].	self attributes		at: 'rows' ifAbsentPut: [3];		at: 'cols' ifAbsentPut: [25].	self tag: 'textarea' do: value.! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'mb 2/9/2006 17:50'!textWithCRs: anObject	"Replace all CRs with breaks"	| aStream |	aStream _ anObject displayString readStream.	[aStream atEnd] whileFalse:		[self text: (aStream upTo: Character cr).		aStream atEnd ifFalse: [self break]].	! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'mb 3/16/2006 15:51'!textWithLFs: anObject	"Replace all LFs with breaks"	| aStream |	aStream _ anObject displayString readStream.	[aStream atEnd] whileFalse:		[self text: (aStream upTo: Character lf).		aStream atEnd ifFalse: [self break]].	! !!WAAbstractHtmlBuilder methodsFor: 'javascript' stamp: 'pmm 11/2/2005 23:52'!toggleStringFor: aCollection	^ String streamContents:		[:stream |		aCollection 			do: [:ea |				stream					nextPutAll: ea displayString;					nextPutAll: '=yes']			separatedBy: [stream nextPutAll: ',']]! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'ab 2/12/2003 21:03'!underline: aBlock	self tag: 'u' do: aBlock.! !!WAAbstractHtmlBuilder methodsFor: 'html' stamp: 'avi 3/15/2004 16:23'!unorderedList: aBlock	self tag: 'ul' do: aBlock! !!WAAbstractHtmlBuilder methodsFor: 'basic markup' stamp: 'mb 3/16/2006 15:50'!withLineBreaks: aString	| stream |	stream _ aString readStream.	[stream atEnd] whileFalse:		[self text: stream nextLine.		stream atEnd ifFalse: [self break]]! !!WAHtmlBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 2/18/2004 19:46'!on: aDocument	^ self new document: aDocument! !!WAHtmlBuilder methodsFor: 'accessing' stamp: 'avi 2/18/2004 19:46'!document	^ document! !!WAHtmlBuilder methodsFor: 'accessing' stamp: 'avi 2/18/2004 19:46'!document: aDocument	document _ aDocument! !!WAHtmlRenderer commentStamp: '<historical>' prior: 0!I am passed to the method #renderContentOn: of components unless #rendererClass has been redefined. On top of the basic XHTML construction methods inherited from WAAbstractHtmlBuilder, I provide an interface to attach event handlers to anchors and to form-elements.To render any kind of squeak object call the message #render: It will do a double dispatch and call #renderOn: on this object.  For example:	html render: 'Some text'.	html render: 123.					" will print the child "	html render: nil. 					" will do nothing "	html render: #( 'a' 'b' 'c' ).			" will print every element "		html render: businessObject.			" will print the #displayString of your object "	html render: childComponent.		" will render the child component "	This kind of double dispatch can be used with any xhtml-generating method:	html divNamed: 'child' with: childComponent.	html bold: #( 1 'First' ).!!WAHtmlRenderer class methodsFor: 'as yet unclassified' stamp: 'avi 3/22/2004 12:20'!context: aRenderingContext callbacks: aCallbackStore	^ self basicNew initializeWithContext: aRenderingContext callbacks: aCallbackStore! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/8/2006 12:09'!addShortcut: aString	| id |	id _ self ensureId.	shortcutBuffer isNil ifTrue:		[shortcutBuffer _ Dictionary new].	shortcutBuffer at: aString put: id.! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:24'!anchorOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		anchorWithAction: (MessageSend receiver: anObject selector: aSymbol)		text: (self labelForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'pmm 6/7/2005 15:34'!anchorWithAction: actionBlock do: linkBlock		self openAnchorWithAction: actionBlock.	self render: linkBlock.	self closeTag: 'a'.! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ac 3/23/2006 18:15'!anchorWithAction: aBlock fileName: fileName text: doBlock	self 		anchorWithUrl: 			(self actionUrl,  '/', fileName, '?',				(self callbacks registerActionCallback: aBlock))		do: doBlock! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 4/8/2003 14:26'!anchorWithAction: actionBlock form: aForm	self anchorWithAction: actionBlock do: [self imageWithForm: aForm.]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 2/7/2004 02:09'!anchorWithAction: actionBlock image: aForm	self anchorWithAction: actionBlock do: [self imageWithForm: aForm.]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 1/23/2004 01:31'!anchorWithAction: actionBlock text: aString	self anchorWithAction: actionBlock do: aString! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/9/2006 11:11'!anchorWithAction: actionBlock text: aString submitFormNamed: formName	| key |	key _ self context nextKey.	#submitFormTriggeringCallback.	self attributes at: 'onClick'			put: 'submitFormTriggeringCallback('				, formName asString printString 				, ', ' 				, key displayString printString 				, ' , "href" ); return false;'.	self anchorWithAction: actionBlock text: aString	! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'lr 6/8/2005 09:44'!anchorWithCallback: actionBlock do: linkBlock	self anchorWithUrl: (self urlForIdempotentAction: actionBlock) do: linkBlock! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'avi 11/20/2003 18:43'!anchorWithDocument: anObject mimeType: mimeType fileName: fileName text: aString	self openAnchorWithDocument: anObject mimeType: mimeType fileName: fileName.	self text: aString.	self closeTag: 'a'.! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'avi 11/3/2003 12:25'!anchorWithDocument: anObject mimeType: mimeType text: aString	self anchorWithDocument: anObject mimeType: mimeType fileName: nil text: aString! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'ab 1/11/2003 13:28'!anchorWithDocument: anObject text: aString	self anchorWithDocument: anObject mimeType: nil text: aString! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'ac 12/10/2004 17:15'!anchorWithPopupAction: aBlock extent: aPoint do: anObject	self		anchorWithPopupUrl: (self urlForAction: aBlock)		extent: aPoint		do: anObject! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'ac 12/10/2004 17:20'!anchorWithPopupAction: aBlock extent: aPoint text: aString	self		anchorWithPopupAction: aBlock 		extent: aPoint 		do: aString! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'ac 12/10/2004 17:17'!anchorWithPopupAction: aBlock name: nameString extent: aPoint toggles: aCollection do: anObject	self		anchorWithPopupUrl: (self urlForAction: aBlock)		name: nameString 		extent: aPoint		toggles: aCollection		do: anObject! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'avi 6/8/2004 00:40'!anchorWithScript: aString do: linkBlock	self attributes at: 'onClick' put: aString.	self anchorWithUrl: '#' do: linkBlock! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/8/2006 14:19'!autofocus: aBlock	| elementId |	elementId _ self ensureId.	aBlock value.	#setFocus.	self script: 'setFocus(', elementId asString printString, ')'! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/8/2006 14:19'!autofocus: aBlock withCursorAt: cursorPosition	| elementId aStream |	cursorPosition isNil ifTrue: [^self autofocus: aBlock].	elementId _ self ensureId.	aBlock value.	aStream _ (String new: 30) writeStream.	#setCursor.	aStream		nextPutAll: 'setCursor(';		nextPutAll: elementId asString printString.	cursorPosition isNumber ifTrue:		[aStream nextPutAll: ',' , cursorPosition asString].	"Cursor will go at end of field value, if position is not a number"	aStream nextPut: $).	self script: aStream contents! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:24'!booleanMenuOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		booleanMenuWithValue: (anObject perform: aSymbol)		callback: (self callbackForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 2/12/2003 17:21'!booleanMenuWithValue: aBoolean callback: callbackBlock	self booleanMenuWithValue: aBoolean callback: callbackBlock labels: #(Yes No)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 5/6/2003 18:37'!booleanMenuWithValue: aBoolean callback: callbackBlock labels: labelArray	self		selectFromList: (Array with: true with: false)		selected: aBoolean		callback: callbackBlock		labels: [:b | b ifTrue: [labelArray first] ifFalse: [labelArray second]]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'ab 1/11/2003 13:28'!callbackForSelector: aSymbol of: anObject	^ MessageSend receiver: anObject selector: (aSymbol copyWith: $:) asSymbol! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 3/22/2004 12:29'!callbacks	^ callbacks! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 6/7/2004 22:50'!cancelButtonWithAction: aBlock	self attributes value: 'Cancel'.	self inputWithType: 'submit' named: (self callbacks registerCancelActionCallback: aBlock)! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:24'!checkboxOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		checkboxWithValue: (anObject perform: aSymbol)		callback: (self callbackForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 9/30/2006 15:06'!checkboxWithValue: aBoolean callback: callbackBlock   | value originalAttributes originalShortcuts |   value _ ValueHolder new.   originalAttributes _ attributeBuffer.   attributeBuffer _ nil.   originalShortcuts _ shortcutBuffer.   shortcutBuffer _ nil.   self       hiddenInputWithCallback: [:v |  value contents: false].   attributeBuffer _ originalAttributes.   shortcutBuffer _ originalShortcuts.   self attributeAt: 'checked' put: aBoolean.   self       valueInputOfType: 'checkbox'       value: 'true'       callback: [:v |  value contents: true].   callbackBlock fixCallbackTemps.   self       hiddenInputWithCallback: [:v |  callbackBlock value: value contents]! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/9/2006 11:10'!checkboxWithValue: aBoolean callback: callbackBlock submitFormNamed: formName 	#submitForm.	self attributes at: 'onClick'			put: 'submitForm('				, formName asString printString 				, '); return false;'.	self checkboxWithValue: aBoolean callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 7/5/2004 11:57'!close! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/8/2006 12:16'!closeTag: aString	super closeTag: aString.	self installShortcuts.! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 11/20/2003 18:47'!context	^ context! !!WAHtmlRenderer methodsFor: 'compound' stamp: 'mb 9/30/2006 15:06'!dateInputWithValue: aDate callback: aBlock	| values |	aBlock fixCallbackTemps.		values _ Array new: 3.	self		selectFromList: (1 to: 12)		selected: aDate monthIndex 		callback: [ :month | values at: 2 put: month ]		labels: [:ea | Date nameOfMonth: ea].	self space.	self		textInputWithValue: aDate dayOfMonth 		callback: [ :day | values at: 1 put: day ]		maxLength: 2.	self space.	self 		textInputWithValue: aDate year		callback: [ :year | values at: 3 put: year]		maxLength: 4.	self hiddenInputWithCallback:		[aBlock value: (Date				newDay: (values first min: (Date daysInMonth: values second forYear: values third))				monthNumber: values second				year: values third)].! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 3/31/2006 12:26'!defaultAction: actionBlock	self		style: 'position: absolute; top: -100em';		submitButtonWithAction: actionBlock text: 'Default'.	self		style: 'position: absolute; top: -100em';		textInputWithCallback: [:v | ].! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:39'!divWithShow: showLink hide: hideLink do: aBlock	| linkId divId onClick |	divId _ self ensureId.	linkId _ self nextId.	#swapDisplay.	onClick _ 'swapDisplay(', linkId printString, ', ', divId asString printString, '); return false;'.	self attributes id: linkId; style: 'display: block'.	self anchorWithScript: onClick do: showLink.	self attributes id: divId; style: 'display: none'.	self div: [		self anchorWithScript: onClick do: hideLink.		self div: aBlock.	]! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 11/20/2003 18:46'!document	^ context document! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:40'!ensureId	^ (self attributes at: 'id' ifAbsentPut: [self nextId]) value! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 9/30/2006 15:06'!fileUploadWithCallback: aBlock	aBlock fixCallbackTemps.	self		inputWithType: 'file'		named: (self callbacks registerCallback: [:f | aBlock value: (f = '' ifFalse: [f])])! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 6/3/2004 19:23'!form: aBlock	self		formWithMethod: 'post'		action: context actionUrl urlString		do: [			self div: [				context actionUrl parameters keysAndValuesDo:				[:k :v |				self inputWithType: 'hidden' named: k value: v].			aBlock value		]]! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 11/27/2005 18:55'!formWithDefaultAction: defaultBlock do: aBlock	self form:		[self defaultAction: defaultBlock.		aBlock value]! !!WAHtmlRenderer methodsFor: 'private' stamp: 'mb 3/23/2006 07:31'!fromStringConverterBlockFor: anObject callback: aBlock	^ [:v | 	aBlock value: 		( [anObject convertSeasideString: v] on: Error do: [:e | v] )	]! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:41'!getId	"Compatibility"	^ self nextId.! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 12/5/2003 00:51'!hiddenInputWithCallback: callbackBlock	self inputWithType: 'hidden' named: (self callbacks registerCallback: callbackBlock)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 1/11/2003 13:28'!hiddenInputWithValue: anObject callback: callbackBlock	self valueInputOfType: 'hidden'		value: anObject		callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'mb 9/30/2006 15:07'!imageMapWithAction: aBlock form: aForm	| point pointKey url id |	aBlock fixCallbackTemps.	point := ValueHolder new.	pointKey := self callbacks registerCallback:					[:ptString |					point contents: (self parseImageMap: ptString)].	url := self urlForAction: [aBlock value: point contents].	self		attributeAt: 'href'		put: url, '&', pointKey, '='.	id := self attributes at: 'id' ifAbsent: [nil].	self tag: 'a' do: [		id notNil ifTrue: [self cssId: id value , '-image'].		self attributeAt: 'ismap' put: true.		self imageWithForm: aForm.	]! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'mb 2/17/2005 17:57'!imageWithDocument: anObject mimeType: mimeType fileName: fileName	self image: (self context urlForDocument: anObject mimeType: mimeType fileName: fileName).! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'mb 6/12/2006 14:24'!imageWithFileNamed: fileName	self imageWithFileNamed: fileName mimeType: nil! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'mb 6/12/2006 14:27'!imageWithFileNamed: fileName mimeType: mimeType	| document |	document _ WACachedDocument fileName: fileName.	mimeType notNil ifTrue: [document mimeType: mimeType].	self imageWithDocument: document mimeType: document mimeType fileName: fileName.! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'mb 6/12/2006 10:25'!imageWithForm: aForm	self image: (self context urlForDocument: aForm mimeType: aForm mimeType) width: aForm width height: aForm height! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 3/22/2004 12:20'!initializeWithContext: aRenderingContext callbacks: aCallbackStore	context _ aRenderingContext.	callbacks _ aCallbackStore.! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/8/2006 14:19'!installShortcuts	| aStream |	shortcutBuffer notNil ifTrue:		[aStream _ (String new: 30) writeStream.		shortcutBuffer associations do:			[:each |			aStream				nextPutAll: 'addShortcut(';				nextPutAll: each key printString;				nextPut: $,;				nextPutAll: each value asString printString;				nextPut: $)]		separatedBy:			[aStream nextPutAll: '; '].		shortcutBuffer _ nil.		#addShortcut.		self script: aStream contents].		! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 3/31/2006 11:40'!label: aString input: aBlock	| id |	id _ self nextId.	self labelFor: id do:		[self text: aString.		self space.		self cssId: id.		aBlock value]! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 3/31/2006 11:40'!labelAfter: aString input: aBlock 	| id |	id _ self nextId.	self labelFor: id do: 		[self cssId: id.		aBlock value.		self space.		self text: aString]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 18:29'!labelForSelector: aSymbol	^ self labelForSelector: aSymbol of: nil! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/17/2005 10:42'!labelForSelector: aSymbol of: anObject	^ anObject labelForSelector: aSymbol! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 18:37'!labelledRowForCheckboxOn: aSymbol of: anObject	self tableRowWithLabel: (self labelForSelector: aSymbol of: anObject)		on: aSymbol		column: [self checkboxOn: aSymbol of: anObject]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 18:40'!labelledRowForList: aCollection on: aSymbol of: anObject	self labelledRowForList: aCollection on: aSymbol of: anObject size: nil! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 5/6/2006 10:13'!labelledRowForList: aCollection on: aSymbol of: anObject size: sizeIntegerOrNil	self tableRowWithLabel: (self labelForSelector: aSymbol of: anObject)		on: aSymbol		column: 			[sizeIntegerOrNil ifNotNil: [self attributeAt: #size put: sizeIntegerOrNil].			self cssId: aSymbol.			self				selectFromList: aCollection				selected: (anObject perform: aSymbol)				callback: (self callbackForSelector: aSymbol of: anObject)]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 18:40'!labelledRowForTextAreaOn: aSymbol of: anObject	self tableRowWithLabel: (self labelForSelector: aSymbol of: anObject)		on: aSymbol		column: [self textAreaOn: aSymbol of: anObject]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'JF 6/2/2003 13:31'!labelledRowForTextInputOn: aSymbol of: anObject	self labelledRowForTextInputOn: aSymbol of: anObject size: nil! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 18:32'!labelledRowForTextInputOn: aSymbol of: anObject size: sizeIntegerOrNil	self tableRowWithLabel: (self labelForSelector: aSymbol of: anObject)		on: aSymbol		column: 			[sizeIntegerOrNil ifNotNil: [self attributeAt: #size put: sizeIntegerOrNil].			self textInputOn: aSymbol of: anObject]! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:40'!nextId	^ 'id', self context advanceKey	! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 3/21/2004 00:03'!openAnchorWithAction: actionBlock	self		attributeAt: 'href'		put: (self urlForAction: actionBlock).	self openTag: 'a'.! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'avi 5/22/2004 18:03'!openAnchorWithDocument: anObject mimeType: mimeType fileName: fileName	self attributeAt: 'href' put: (self context urlForDocument: anObject mimeType: mimeType fileName: fileName).	self openTag: #a.! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 6/13/2004 23:16'!openSelect	| name |	name _ self callbacks registerDispatchCallback.	self attributes at: 'name' put: name.	self openTag: 'select'.	! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 1/15/2005 00:50'!optionGroupWithLabel: aString do: aBlock	self attributes at: 'label' put: aString.	self tag: 'optgroup' do: aBlock! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 1/15/2005 00:49'!optionWithLabel: aString callback: aBlock	self optionWithLabel: aString selected: false callback: aBlock! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 11/20/2003 18:48'!optionWithLabel: labelString selected: aBoolean callback: callbackBlock	self 		attributeAt: 'selected' put: aBoolean;		attributeAt: 'value' put: (self callbacks registerCallback: callbackBlock).		self tag: 'option' do: labelString.! !!WAHtmlRenderer methodsFor: 'canvas compatibility' stamp: 'avi 3/18/2005 21:56'!painter: aComponent! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'ab 7/11/2003 00:09'!parseImageMap: aString	|s x y|	('?*,*' match: aString) ifFalse: [^ nil].	s _ aString readStream.	s upTo: $?.	x _ s upTo: $,.	y _ s upToEnd.	^ x asNumber @ y asNumber	! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 9/2/2004 13:18'!passwordInputWithCallback: callbackBlock	self passwordInputWithValue: '' callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 9/30/2004 21:50'!passwordInputWithValue: anObject callback: callbackBlock	self		valueInputOfType: 'password'		value: anObject		callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:41'!peekNextId	^ 'id', self context nextKey	! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 11/20/2003 18:49'!radioButtonInGroup: radioGroupKey selected: aBoolean callback: callbackBlock	self attributeAt: 'checked' put: aBoolean.		self inputWithType: 'radio' named: radioGroupKey value: (self callbacks registerCallback: callbackBlock)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 3/22/2004 18:45'!radioButtonInGroup: radioGroupKey withValue: value on: aSelector of: anObject	self		radioButtonInGroup: radioGroupKey		selected: (value = (anObject perform: aSelector))		callback: [anObject perform: aSelector asMutator with: value]! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 11/20/2003 18:48'!radioGroup	^ self callbacks registerDispatchCallback.! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 4/13/2004 19:48'!registry	^ WACurrentSession value application ! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 4/13/2004 21:43'!request	^ self context request! !!WAHtmlRenderer methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:01'!response	^ self context response! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'mbany 4/14/2005 12:30'!selectFromList: aCollection selected: selectedObject callback: callbackBlock	self selectFromList: aCollection selected: selectedObject callback: callbackBlock labels: [:i | i displayString]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'mb 9/30/2006 15:09'!selectFromList: aCollection selected: selectedObject callback: callbackBlock labels: labelsBlock	self openSelect.	callbackBlock fixCallbackTemps.	aCollection do:		[:item |		self			optionWithLabel: (labelsBlock value: item)			selected: (item = selectedObject)			callback: [callbackBlock value: item]] fixCallbackTemps.	self closeTag: 'select'.! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 3/13/2004 14:58'!selectFromList: aCollection selected: selectedObject callback: callbackBlock labels: labelsBlock nilLabel: aString	self selectFromList: (Array with: nil), aCollection asArray		selected: selectedObject		callback: callbackBlock		labels: [:ea | ea ifNil: [aString] ifNotNil: [labelsBlock value: ea]]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 6/25/2003 23:03'!selectInputOn: selectedSymbol of: anObject list: aCollection	self		selectFromList: aCollection		selected: (anObject perform: selectedSymbol)		callback: (self callbackForSelector: selectedSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'javascript' stamp: 'mb 3/31/2006 11:40'!spanWithShow: showLink hide: hideLink do: aBlock	| linkId divId onClick |	divId _ self ensureId.	linkId _ self nextId.	#swapDisplay.	onClick _ 'swapDisplay(', linkId printString, ', ', divId asString printString, '); return false;'.	self attributes id: linkId; style: 'display: block'.	self anchorWithScript: onClick do: showLink.	self attributes id: divId; style: 'display: none'.	self span: [		self anchorWithScript: onClick do: hideLink.		self span: aBlock.	]! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:24'!submitButtonOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		submitButtonWithAction: (MessageSend receiver: anObject selector: aSymbol)		text: (self labelForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 11/20/2003 18:48'!submitButtonWithAction: actionBlock	self inputWithType: 'submit'		named: (self callbacks registerActionCallback: actionBlock)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 2/7/2004 02:07'!submitButtonWithAction: actionBlock do: aBlock	self buttonWithType: 'submit'		named: (self callbacks registerActionCallback: actionBlock)		value: nil		do: aBlock! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 9/21/2006 16:05'!submitButtonWithAction: actionBlock image: aForm	self attributes		at: 'src' put: (self context urlForDocument: aForm);		width: aForm width;		height: aForm height.	self inputWithType: 'image'		named: (self callbacks registerImageCallback: actionBlock)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 1/11/2003 13:28'!submitButtonWithAction: aBlock text: aString	self attributeAt: 'value' put: aString.	self submitButtonWithAction: aBlock! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/10/2006 12:20'!tableRowWithLabel: anObject on: aSymbol column: aBlock	self tableRowWithLabel: [self labelFor: aSymbol do: anObject] column: aBlock! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:25'!textAreaOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		textAreaWithValue: (anObject perform: aSymbol)		callback: (self callbackForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 1/19/2006 18:07'!textAreaWithCallback: callbackBlock	self textAreaWithValue: nil callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 1/19/2006 18:10'!textAreaWithValue: anObject callback: callbackBlock	| callback updateKey |	callback _ self fromStringConverterBlockFor: anObject callback: callbackBlock.	updateKey _ self callbacks registerCallback: callback.	self		textAreaNamed: updateKey		value: anObject asSeasideString.	^updateKey! !!WAHtmlRenderer methodsFor: 'model' stamp: 'mb 2/9/2006 14:25'!textInputOn: aSymbol of: anObject	self		ensureCssId: aSymbol;		textInputWithValue: (anObject perform: aSymbol)		callback: (self callbackForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 6/24/2003 16:15'!textInputWithCallback: callbackBlock	self textInputWithValue: '' callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'ab 1/11/2003 13:28'!textInputWithValue: anObject callback: callbackBlock	self		valueInputOfType: 'text'		value: anObject		callback: callbackBlock! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'mb 9/30/2006 15:07'!textInputWithValue: aString callback: aBlock helpText: helpString	aBlock fixCallbackTemps.	aString ifNil:		[self attributeAt: 'onfocus' put: 'if(''',helpString, ''' == this.value) {this.value=''''}; style.color=''black'''.		self attributeAt: 'style' put: 'color: #aaa'].	self textInputWithValue: (aString ifNil: [helpString]) callback: [:v | aBlock value: (v = helpString ifFalse: [v])]	! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 3/13/2004 14:17'!textInputWithValue: anObject callback: callbackBlock maxLength: aNumber	self attributes		at: 'size' put: aNumber;		at: 'maxlength' put: aNumber.	self textInputWithValue: anObject callback: callbackBlock.! !!WAHtmlRenderer methodsFor: 'compound' stamp: 'mb 9/30/2006 15:07'!timeInputWithValue: aTime callback: aBlock	| values |	aBlock fixCallbackTemps.	values _ Array new: 2.	self		textInputWithValue: aTime hour		callback: [:hour | values at: 1 put: hour]		maxLength: 2.	self space; text: ':'; space.	self		textInputWithValue: aTime minutes asTwoCharacterString		callback: [:minute | values at: 2 put: minute asNumber]		maxLength: 2.	self hiddenInputWithCallback:		[aBlock value:			(Time				hour: values first				minute: (values second min: 59)				second: 0)]				! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'mbany 4/14/2005 12:31'!unorderedList: aCollection selected: anObject callback: aBlock	self unorderedList: aCollection selected: anObject  callback: aBlock labels: [:ea | ea displayString]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'mb 9/30/2006 15:07'!unorderedList: aCollection selected: anObject callback: aBlock labels: labelBlock	aBlock fixCallbackTemps.	self ensureCssClass: 'options'.	self unorderedList: [		aCollection do:			[:ea |			self cssClass: 'option'.			ea = anObject ifTrue: [self cssId: 'option-selected'].			self listItem: [self anchorWithAction: [aBlock value: ea] text: (labelBlock value: ea)]].	]! !!WAHtmlRenderer methodsFor: 'convenience' stamp: 'avi 5/21/2004 18:10'!unorderedListOn: aSymbol of: anObject list: aCollection	self		unorderedList: aCollection		selected: (anObject perform: aSymbol)		callback: (self callbackForSelector: aSymbol of: anObject)! !!WAHtmlRenderer methodsFor: 'core' stamp: 'avi 11/7/2005 13:12'!urlForAction: actionBlock	| url |	url _ context actionUrl withParameter: (self callbacks registerActionCallback: actionBlock).	^ url displayString! !!WAHtmlRenderer methodsFor: 'core' stamp: 'lr 6/8/2005 16:50'!urlForAction: actionBlock andPath: aString	| url |	url _ context actionUrl withParameter:  (self callbacks 		registerActionCallback: actionBlock).	url addToPath: aString.	^ url displayString! !!WAHtmlRenderer methodsFor: 'documents' stamp: 'avi 5/22/2004 18:05'!urlForDocument: anObject	^ self context urlForDocument: anObject! !!WAHtmlRenderer methodsFor: 'core' stamp: 'lr 8/3/2006 13:22'!urlForIdempotentAction: actionBlock	| url |	url := (context actionUrl		withParameter:  (self callbacks registerActionCallback: actionBlock))		withParameter: '_n'.	^ url displayString! !!WAHtmlRenderer methodsFor: 'core' stamp: 'mb 11/27/2005 18:59'!valueInputOfType: typeString value: anObject callback: callbackBlock 	| updateKey callback |	callback _ self fromStringConverterBlockFor: anObject callback: callbackBlock.	updateKey _ self callbacks registerCallback: callback.	self		inputWithType: typeString		named: updateKey		value: anObject asSeasideString.	^ updateKey! !!WABrush class methodsFor: 'instance creation' stamp: 'mb 1/12/2006 18:53'!new	^self basicNew initialize! !!WABrush methodsFor: 'private' stamp: 'avi 6/17/2004 12:18'!close	self isClosed ifFalse: [self with: []]! !!WABrush methodsFor: 'initialize-release' stamp: 'mb 1/12/2006 18:54'!initialize! !!WABrush methodsFor: 'testing' stamp: 'avi 6/17/2004 12:17'!isClosed	^ isClosed ifNil: [false]! !!WABrush methodsFor: 'private' stamp: 'lr 9/14/2005 22:33'!labelForSelector: aSymbol of: anObject	^ anObject labelForSelector: aSymbol.! !!WABrush methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:27'!parent	^ parent! !!WABrush methodsFor: 'convenience' stamp: 'mb 3/23/2006 16:19'!session	^ WACurrentSession value! !!WABrush methodsFor: 'initialize-release' stamp: 'avi 6/13/2004 00:27'!setParent: aBrush canvas: aCanvas	parent _ aBrush.	canvas _ aCanvas! !!WABrush methodsFor: 'public api' stamp: 'avi 6/17/2004 12:17'!with: aBlock	canvas nest: aBlock.	isClosed _ true.! !!WAAcronymTag methodsFor: 'accessing' stamp: 'mb 3/8/2006 17:36'!tag	^ 'acronym'! !!WAAnchorTag commentStamp: 'dc 7/11/2006 07:16' prior: 0!I'm the class responsible for adding anchors (links) to your webpage. There are multiple ways of using me.In the following case, the method #doSomethingOnClick will be sent to self when the user click on the anchor 'Click here to do something':html anchor  callback: [self doSomethingOnClick];  text: 'Click here to do something'.In fact, you are not obliged to render simple text for your anchors, a block can be executed instead:html anchor  callback: [self doSomethingIfUserClickMe];  with: [put here some code to render things for the anchor text].Following code is a shortcut to create an anchor:html anchor  on: #aSelector of: anObjectThe text will be 'a Selector' (this is a special transformation of symbols to make them more readable)The action will be the call of #aSelector on anObject.!!WAAnchorTag methodsFor: 'private' stamp: 'cb 9/6/2006 13:26'!actionUrl	| actionUrl |	^ callbackKey ifNotNil:		[actionUrl := canvas context actionUrl withParameter: callbackKey.		self isNavigation ifTrue: [actionUrl := actionUrl withParameter: '_n'].		extraParameters ifNotNil:			[extraParameters associationsDo: [:assoc | actionUrl addParameter: assoc key value: assoc value]]. 		actionUrl fragment: fragment.		extraPath			ifNil: [actionUrl queryString]			ifNotNil: [actionUrl addToPath: extraPath; asString]]! !!WAAnchorTag methodsFor: 'callbacks' stamp: 'avi 11/27/2005 16:26'!callback: aBlock	callbackKey _ canvas callbacks registerActionCallback: aBlock! !!WAAnchorTag methodsFor: 'javascript' stamp: 'mb 3/8/2006 18:18'!canHaveShortcut	^true! !!WAAnchorTag methodsFor: 'public api' stamp: 'mb 9/8/2006 10:36'!document: aDocument	self document: aDocument mimeType: nil! !!WAAnchorTag methodsFor: 'public api' stamp: 'mb 9/8/2006 10:35'!document: aDocument mimeType: mimeType	self document: aDocument mimeType: mimeType fileName: nil! !!WAAnchorTag methodsFor: 'public api' stamp: 'mb 9/8/2006 10:34'!document: aDocument mimeType: mimeType fileName: fileName	self url: (canvas context urlForDocument: aDocument mimeType: mimeType fileName: fileName)! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 11/27/2005 16:36'!extraParameters: aCollection	extraParameters _ aCollection! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 2/1/2006 13:08'!extraPath: aString	extraPath _ aString! !!WAAnchorTag methodsFor: 'accessing' stamp: 'cb 9/6/2006 13:22'!fragment	^fragment ! !!WAAnchorTag methodsFor: 'accessing' stamp: 'cb 9/6/2006 13:23'!fragment: aString	fragment := aString! !!WAAnchorTag methodsFor: 'private' stamp: 'mb 3/9/2006 10:24'!handlerForForm: formName	#submitFormTriggeringCallback.	^ promptString		ifNil:				['submitFormTriggeringCallback('				, formName asString printString				, ', '				, callbackKey displayString printString				, ', "href" ); return false;']		ifNotNil: 				['if(x = prompt('				, promptString printString				, ')) submitFormTriggeringCallback('				, formName asString printString				, ', '				, callbackKey displayString printString				, ', x); return false;']! !!WAAnchorTag methodsFor: 'initialize-release' stamp: 'pmm 9/12/2006 18:08'!initialize	super initialize.	isNavigation := false! !!WAAnchorTag methodsFor: 'testing' stamp: 'avi 11/27/2005 21:05'!isNavigation	^ isNavigation ifNil: [false]! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 10/30/2005 00:50'!mailto: aString	self url: 'mailto:', aString.	self text: aString! !!WAAnchorTag methodsFor: 'attributes' stamp: 'avi 9/24/2005 20:50'!name: aString	self attributeAt: 'name' put: aString! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 11/27/2005 16:30'!navigation	isNavigation _ true! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 9/4/2005 22:10'!newTarget	self target: '_new'! !!WAAnchorTag methodsFor: 'public api' stamp: 'lr 9/14/2005 23:51'!on: aSymbol of: anObject	self callback: [ anObject perform: aSymbol ].	self with: (self labelForSelector: aSymbol of: anObject).! !!WAAnchorTag methodsFor: 'events' stamp: 'mb 11/27/2005 10:27'!onClick: aString	super onClick: aString.	self attributes at: 'href' ifAbsentPut: ['javascript:void(0)']! !!WAAnchorTag methodsFor: 'events' stamp: 'mb 3/24/2006 14:46'!onMouseOut: aString	super onMouseOut: aString.	self attributes at: 'href' ifAbsentPut: ['javascript:void(0)']! !!WAAnchorTag methodsFor: 'events' stamp: 'lr 3/13/2006 19:52'!onMouseOver: aString 	super onMouseOver: aString.	self attributes at: 'href' ifAbsentPut: [ 'javascript:void(0)' ]! !!WAAnchorTag methodsFor: 'callbacks' stamp: 'avi 3/15/2006 22:24'!prompt: aString callback: aBlock	self prompt: aString default: '' callback: aBlock! !!WAAnchorTag methodsFor: 'callbacks' stamp: 'avi 3/15/2006 22:23'!prompt: aString default: defaultString callback: aBlock	callbackKey _ canvas callbacks registerCallback: aBlock.	promptString _ aString.	promptDefault _ defaultString! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 9/11/2005 14:40'!resourceUrl: aString	self url: (canvas document root absoluteUrlForResource: aString)! !!WAAnchorTag methodsFor: 'attributes' stamp: 'avi 6/22/2005 14:46'!submitFormNamed: aString	self onClick: (self handlerForForm: aString)! !!WAAnchorTag methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:56'!tag	^ 'a'! !!WAAnchorTag methodsFor: 'attributes' stamp: 'avi 9/4/2005 22:10'!target: aString	self attributeAt: 'target' put: aString! !!WAAnchorTag methodsFor: 'public api' stamp: 'ac 3/16/2005 14:28'!text: aString	self with: aString.! !!WAAnchorTag methodsFor: 'unused ?' stamp: 'pmm 11/2/2005 23:52'!toggleStringFor: aCollection	^ String streamContents:		[:stream |		aCollection 			do: [:ea |				stream					nextPutAll: ea displayString;					nextPutAll: '=yes']			separatedBy: [stream nextPutAll: ',']]! !!WAAnchorTag methodsFor: 'public api' stamp: 'avi 11/27/2005 16:26'!url: aString	url _ aString! !!WAAnchorTag methodsFor: 'public api' stamp: 'ac 2/5/2006 11:27'!with: aBlock	| newUrl |	newUrl _ url ifNil: [self actionUrl].	newUrl ifNotNil: [self attributes at: 'href' put: newUrl].	^ super with: aBlock! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'ac 7/8/2005 19:15'!beDependent	dependent _ true! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'ac 9/11/2005 13:08'!beResizable	resizable _ true! !!WAPopupAnchorTag methodsFor: 'accessing' stamp: 'ac 7/3/2005 16:08'!extent: aPoint	extent _ aPoint! !!WAPopupAnchorTag methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:28'!initialize	super initialize.	dependent _ false.! !!WAPopupAnchorTag methodsFor: 'testing' stamp: 'ac 7/8/2005 19:15'!isDependent	^ dependent ifNil: [false]! !!WAPopupAnchorTag methodsFor: 'testing' stamp: 'ac 9/11/2005 13:07'!isResizable	^ resizable ifNil: [resizable _ false]! !!WAPopupAnchorTag methodsFor: 'accessing' stamp: 'ac 7/3/2005 16:07'!name: aString	name _ aString! !!WAPopupAnchorTag methodsFor: 'private' stamp: 'avi 2/2/2006 02:21'!popupString	^ String streamContents:		[:stream |		stream 			nextPutAll: 'window.open(';			nextPut: $';			nextPutAll: (url ifNil: [self actionUrl]);			nextPut: $';			nextPut: $,;			nextPut: $';			nextPutAll: name;			nextPut: $';			nextPut:$,;			nextPut: $';			nextPutAll: 'width=';			nextPutAll: extent x displayString;			nextPutAll: ',height=';			nextPutAll: extent y displayString;			nextPut: $,;			nextPutAll: self toggleString;			nextPut: $';			nextPutAll: ').focus()']! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'avi 3/23/2006 22:56'!shouldShowScrollbars	^ showScrollbars ifNil: [showScrollbars _ false]! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'ac 9/11/2005 13:05'!shouldShowToolbar	^ showToolbar ifNil: [showToolbar _ false]! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'avi 3/23/2006 22:55'!showScrollbars	showScrollbars _ true! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'ac 9/11/2005 13:04'!showToolbar	showToolbar _ true! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'avi 3/23/2006 22:55'!toggleArray	^ Array streamContents:		[:stream |		self isDependent ifTrue: [stream nextPut: #dependent].		self shouldShowToolbar ifTrue: [stream nextPut: #toolbar].		self isResizable ifTrue: [stream nextPut: #resizable].		self shouldShowScrollbars ifTrue: [stream nextPut: #scrollbars]]! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'pmm 11/2/2005 23:53'!toggleString	^ String streamContents:		[:stream | 		self toggleArray 			do: [:ea |				stream					nextPutAll: ea;					nextPutAll: '=yes'] 			separatedBy: [stream nextPutAll: ',']]! !!WAPopupAnchorTag methodsFor: 'public api' stamp: 'ac 2/7/2006 10:50'!with: aBlock	self onClick: self popupString.	self ignoreURL.	^ super with: aBlock.! !!WACanvasTag methodsFor: 'attributes' stamp: 'lr 5/18/2006 08:52'!extent: aPoint	self width: aPoint x; height: aPoint y! !!WACanvasTag methodsFor: 'attributes' stamp: 'lr 5/18/2006 08:51'!height: aNumber	self attributeAt: 'height' put: aNumber displayString! !!WACanvasTag methodsFor: 'accessing' stamp: 'lr 5/18/2006 08:50'!tag	^ 'canvas'! !!WACanvasTag methodsFor: 'attributes' stamp: 'lr 5/18/2006 08:51'!width: aNumber	self attributeAt: 'width' put: aNumber displayString! !!WAImageTag methodsFor: 'attributes' stamp: 'avi 5/10/2005 14:33'!altText: aString	self attributes at: 'alt' put: aString! !!WAImageTag methodsFor: 'attributes' stamp: 'mb 9/12/2006 12:58'!border: aNumber	self attributes border: aNumber! !!WAImageTag methodsFor: 'private' stamp: 'pmm 9/12/2006 18:04'!close	url isNil ifTrue: [		self generateUrlForDocument ].	self attributes at: 'src' put: url.	super close.! !!WAImageTag methodsFor: 'accessing' stamp: 'mb 6/12/2006 08:44'!document: anObject	document _ anObject! !!WAImageTag methodsFor: 'accessing' stamp: 'mb 6/12/2006 08:47'!fileName: aString	fileName _ aString! !!WAImageTag methodsFor: 'public api' stamp: 'mb 6/12/2006 08:50'!form: aForm	self extent: aForm extent.	self document: aForm.! !!WAImageTag methodsFor: 'private' stamp: 'pmm 9/12/2006 18:06'!generateCachedDocumentFromFilename	document := WACachedDocument fileName: fileName.	mimeType isNil ifFalse: [		document mimeType: mimeType ]! !!WAImageTag methodsFor: 'private' stamp: 'pmm 9/12/2006 18:07'!generateUrlForDocument	document isNil ifTrue: [		self generateCachedDocumentFromFilename ].	mimeType isNil ifTrue: [		mimeType := document mimeType ].	url := canvas context		urlForDocument: document		mimeType: mimeType		fileName: fileName! !!WAImageTag methodsFor: 'initialize-release' stamp: 'mb 8/10/2006 08:01'!initialize	super initialize.	self altText: ''.! !!WAImageTag methodsFor: 'accessing' stamp: 'mb 6/12/2006 08:47'!mimeType: aString	mimeType _ aString! !!WAImageTag methodsFor: 'attributes' stamp: 'avi 9/10/2005 18:56'!noBorder	self border: 0! !!WAImageTag methodsFor: 'public api' stamp: 'avi 9/11/2005 14:40'!resourceUrl: aString	self url: (canvas document root absoluteUrlForResource: aString)! !!WAImageTag methodsFor: 'attributes' stamp: 'pmm 9/12/2006 18:01'!src: aString	"deprecated"	self url: aString! !!WAImageTag methodsFor: 'accessing' stamp: 'ac 3/16/2005 12:00'!tag	^ 'img'! !!WAImageTag methodsFor: 'attributes' stamp: 'pmm 9/12/2006 18:01'!url: aString	url := aString! !!WACollectionTag methodsFor: 'adding' stamp: 'lr 9/25/2005 11:31'!add: anObject	^ list add: anObject.! !!WACollectionTag methodsFor: 'adding' stamp: 'lr 9/25/2005 11:32'!addAll: aCollection	^ list addAll: aCollection.! !!WACollectionTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 13:44'!beMultiple	multiple := true.! !!WACollectionTag methodsFor: 'attributes' stamp: 'mb 4/23/2006 15:10'!beSingle	multiple _ false.! !!WACollectionTag methodsFor: 'callbacks' stamp: 'mb 9/30/2006 15:06'!callback: aBlock	callbackBlock := aBlock fixCallbackTemps.! !!WACollectionTag methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:10'!initialize	super initialize.	list _ OrderedCollection new.	labelsBlock _ [ :value | value ].	multiple _ false.! !!WACollectionTag methodsFor: 'testing' stamp: 'pmm 11/2/2005 22:11'!isMultiple	^ multiple.! !!WACollectionTag methodsFor: 'testing' stamp: 'lr 9/26/2005 14:48'!isSelected: anObject	^ self isMultiple		ifTrue: [ selected includes: anObject ]		ifFalse: [ selected = anObject ].! !!WACollectionTag methodsFor: 'private' stamp: 'lr 9/25/2005 11:40'!labelForOption: anObject	^ labelsBlock value: anObject.! !!WACollectionTag methodsFor: 'callbacks' stamp: 'mb 9/30/2006 15:06'!labels: aBlock	labelsBlock := aBlock fixCallbackTemps.! !!WACollectionTag methodsFor: 'accessing' stamp: 'lr 9/25/2005 11:34'!list: aCollection	self addAll: aCollection.! !!WACollectionTag methodsFor: 'attributes' stamp: 'pmm 7/19/2006 20:10'!on: selector of: anObject	"copy pasted from WASelectTag, we need a traitified version of seaside"	self selected: (anObject perform: selector).	self callback: [ :value | anObject perform: selector asMutator with: value ].! !!WACollectionTag methodsFor: 'accessing' stamp: 'mb 4/23/2006 18:31'!selected: anObject	selected _ anObject! !!WAListTag methodsFor: 'actions' stamp: 'lr 9/25/2005 11:37'!beOrdered	tag := 'ol'.! !!WAListTag methodsFor: 'actions' stamp: 'lr 9/25/2005 11:37'!beUnordered	tag := 'ul'.! !!WAListTag methodsFor: 'private' stamp: 'lr 9/26/2005 15:18'!callbackForOption: anObject	self isMultiple 		ifTrue: [ 			selected := (self isSelected: anObject)				ifTrue: [ selected copyWithout: anObject ]				ifFalse: [ selected copyWith: anObject ].			callbackBlock value: selected ]		ifFalse: [ callbackBlock value: anObject ].! !!WAListTag methodsFor: 'accessing' stamp: 'lr 9/25/2005 11:37'!tag	^ tag ifNil: [ 'ul' ].! !!WAListTag methodsFor: 'public' stamp: 'lr 9/26/2005 15:17'!with: aBlock	super with: [		list do: [ :each |			canvas listItem 				class: ((self isSelected: each)					ifFalse: [ 'option' ]					ifTrue: [ 'option-selected' ]);				with: [					callbackBlock isNil						ifTrue: [ canvas render: (self labelForOption: each) ]						ifFalse: [							canvas anchor								callback: [ self callbackForOption: each ];								with: (self labelForOption: each) ] ] ].		aBlock value ].! !!WASelectTag methodsFor: 'attributes' stamp: 'ac 4/13/2005 12:38'!beOptional	isOptional _ true! !!WASelectTag methodsFor: 'attributes' stamp: 'ac 2/1/2006 20:23'!beSubmitOnChange	isSubmitOnChange _ true! !!WASelectTag methodsFor: 'testing' stamp: 'ac 4/13/2005 13:05'!hasOther	^ otherLabel notNil! !!WASelectTag methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:31'!initialize	super initialize.	isOptional _ false.	isSubmitOnChange _ false! !!WASelectTag methodsFor: 'testing' stamp: 'pmm 11/2/2005 22:17'!isOptional	^ isOptional! !!WASelectTag methodsFor: 'testing' stamp: 'pmm 11/2/2005 22:17'!isSubmitOnChange	^ isSubmitOnChange! !!WASelectTag methodsFor: 'accessing' stamp: 'mb 1/13/2006 10:34'!numberOfOptions	| count |	count _ 0.	self isOptional ifTrue: [count _ count + 1].	count _ count + list size.	^ count! !!WASelectTag methodsFor: 'attributes' stamp: 'avi 8/30/2005 13:27'!optionalLabel: aString	optionalLabel _ aString! !!WASelectTag methodsFor: 'private' stamp: 'pmm 4/19/2006 17:48'!optionsOn: html	self isOptional ifTrue: 		[html option 			selected: selected isNil; 			callback: [callbackBlock value: nil];			with: optionalLabel].	list do: 		[:each | 		html option 			selected: (self isSelected: each); 			callback: [ self isMultiple				ifTrue: [ selected add: each ]				ifFalse: [ callbackBlock value: each ] ];			with: (self labelForOption: each)]! !!WASelectTag methodsFor: 'attributes' stamp: 'mb 9/30/2006 15:08'!otherLabel: labelString otherCallback: aBlock promptString: aString	otherLabel _ labelString.	otherCallbackBlock _ aBlock fixCallbackTemps.	promptString _ aString.! !!WASelectTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 09:55'!size: anInteger	self attributes at: 'size' put: anInteger.! !!WASelectTag methodsFor: 'accessing' stamp: 'ac 3/17/2005 16:44'!tag	^ 'select'! !!WASelectTag methodsFor: 'public' stamp: 'mb 4/23/2006 18:32'!with: aBlock	| hidden value other onChange |	onChange _ ''.	self hasOther ifTrue: 		[other _ (canvas context nextKey asNumber + self numberOfOptions + 1) displayString.		hidden _ canvas context nextKey asString.		value _ ValueHolder new.		canvas insert:			[canvas hiddenInput id: hidden; value: nil; callback: [:n | value contents: n]; with: []].		onChange _ 'if(this.value == ', other printString, ') {chooseOther(this, ', hidden printString, ', ', promptString printString, ')};'].	self isSubmitOnChange ifTrue: [onChange := onChange, ' submit();'].	onChange isEmpty ifFalse: [self onChange: onChange].	self isMultiple ifTrue: [		canvas insert: [ 			canvas hiddenInput 				callback: [ selected _ OrderedCollection new ];				with: [ ] ] ].	self attributes 		at: 'name' put: (self isMultiple			ifTrue: [ canvas callbacks registerMultiDispatchCallback ]			ifFalse: [ canvas callbacks registerDispatchCallback ]);		at: 'multiple' put: self isMultiple.	super with: 		[self optionsOn: canvas. 		aBlock value.		self hasOther ifTrue: 			[canvas option 				selected: false; 				callback: [otherCallbackBlock value: value contents];				with: otherLabel]].	self isMultiple ifTrue: [		canvas insert: [ 			canvas hiddenInput 				callback: [ callbackBlock value: selected ];				with: [ ] ] ].! !!WACompound methodsFor: 'callbacks' stamp: 'mb 1/30/2006 18:39'!callback: aBlock	callbackBlock _ aBlock! !!WACompound methodsFor: 'callbacks' stamp: 'pmm 7/19/2006 20:13'!on: selector of: anObject	"copy pasted for the third time, we really need a traitified version of seaside"	self value: (anObject perform: selector).	self callback: [ :date | anObject perform: selector asMutator with: date ].! !!WACompound methodsFor: 'public api' stamp: 'mb 1/30/2006 18:40'!value: aValue	value := aValue! !!WADateInput methodsFor: 'public api' stamp: 'mb 7/12/2006 15:49'!with: aBlock	value isNil ifTrue: [value := Date today].	canvas forgetCurrentBrush.	(canvas select)		id: self id;		list: (1 to: 12);		selected: value monthIndex;		callback: [:m | month _ m];		labels: [:ea | Date nameOfMonth: ea];		close.	canvas space.	(canvas textInput)		id: (self id isNil ifTrue: [nil] ifFalse: [self id , '-day']);		value: value dayOfMonth; 		callback: [:d | day _ [d asNumber] on: Error do: [:e | 1]];		attributeAt: 'size' put: 2;		attributeAt: 'maxlength' put: 2;		close.	canvas forgetCurrentBrush.	canvas space.	(canvas textInput) 		id: (self id isNil ifTrue: [nil] ifFalse: [self id , '-year']);		value: value year;		callback: [:y | year _ [y asNumber] on: Error do: [:e | 1900]];		attributeAt: 'size' put: 4;		attributeAt: 'maxlength' put: 4;		close.	canvas forgetCurrentBrush.	(canvas hiddenInput)		callback:			[value := Date				newDay: (day min: (Date daysInMonth: month forYear: year))				monthNumber: month				year: year.			callbackBlock value: value];		close.	canvas forgetCurrentBrush.! !!WAImageMapTag methodsFor: 'accessing' stamp: 'mb 9/12/2006 11:39'!form: aForm	form := aForm! !!WAImageMapTag methodsFor: 'private' stamp: 'mb 9/12/2006 11:04'!parseImageMap: aString	| aStream x y |	('?*,*' match: aString) ifFalse: [^ nil].	aStream := aString readStream.	aStream upTo: $?.	x := aStream upTo: $,.	y := aStream upToEnd.	^ x asNumber @ y asNumber! !!WAImageMapTag methodsFor: 'private' stamp: 'mb 9/30/2006 15:07'!url	| callbackKey pointKey url |	callbackBlock fixCallbackTemps.	pointKey := canvas callbacks registerCallback:					[:ptString |					value := self parseImageMap: ptString].	callbackKey := canvas callbacks registerActionCallback:					[callbackBlock value: value].	url := canvas context actionUrl withParameter: callbackKey.	^ url queryString, '&', pointKey, '='.! !!WAImageMapTag methodsFor: 'accessing' stamp: 'mb 9/14/2006 09:25'!value: aValue	self shouldNotImplement! !!WAImageMapTag methodsFor: 'private' stamp: 'mb 9/14/2006 11:27'!with: aBlock	canvas forgetCurrentBrush.	canvas anchor		attributes: self attributes;		url: self url;		with:			[canvas image				id: (self id isNil ifTrue: [nil] ifFalse: [self id , '-image']);				attributeAt: 'ismap' put: true;				form: form]! !!WATimeInput methodsFor: 'initialize-release' stamp: 'pmm 9/12/2006 19:18'!initialize	super initialize.	self withoutSeconds! !!WATimeInput methodsFor: 'public api' stamp: 'mb 9/8/2006 10:02'!with: aBlock	value isNil ifTrue: [value := Time now].	canvas forgetCurrentBrush.	(canvas textInput)		id: self id;		value: value hour asTwoCharacterString; 		callback: [:h | hours := [h asNumber] on: Error do: [:e | 0]];		attributeAt: 'size' put: 2;		attributeAt: 'maxlength' put: 2;		close.	canvas forgetCurrentBrush.	canvas space; text: ':'; space.	(canvas textInput)		id: (self id isNil ifTrue: [nil] ifFalse: [self id , '-mins']);		value: value minutes asTwoCharacterString; 		callback:[:m | minutes := [m asNumber] on: Error do: [:e | 0]];		attributeAt: 'size' put: 2;		attributeAt: 'maxlength' put: 2;		attributeAt: 'max' put: 59; 		close.	canvas forgetCurrentBrush.	withSeconds ifTrue:		[canvas space; text: ':'; space.		(canvas textInput)			id: (self id isNil ifTrue: [nil] ifFalse: [self id , '-secs']);			value: value seconds asTwoCharacterString; 			callback:[:s | seconds := [s asNumber] on: Error do: [:e | 0]];			attributeAt: 'size' put: 2;			attributeAt: 'maxlength' put: 2;			attributeAt: 'max' put: 59; 			close.		canvas forgetCurrentBrush]	ifFalse:		[seconds := 0].	(canvas hiddenInput)		callback:			[value := Time				hour: hours				minute: (minutes min: 59)				second: (seconds min: 59).			callbackBlock value: value];		close.	canvas forgetCurrentBrush.! !!WATimeInput methodsFor: 'accessing' stamp: 'mb 2/6/2006 09:55'!withSeconds	withSeconds _ true! !!WATimeInput methodsFor: 'accessing' stamp: 'mb 2/6/2006 09:56'!withoutSeconds	withSeconds _ false! !!WADivTag methodsFor: 'public api' stamp: 'avi 6/3/2005 15:40'!clear	self class: 'clear'.	self with: [canvas space]! !!WADivTag methodsFor: 'accessing' stamp: 'avi 6/3/2005 15:39'!tag	^ 'div'! !!WAFieldSetTag methodsFor: 'private' stamp: 'mb 3/8/2006 18:03'!before	legend ifNotNil: [canvas legend: legend]! !!WAFieldSetTag methodsFor: 'accessing' stamp: 'mb 3/8/2006 17:47'!legend: aString	legend _ aString	! !!WAFieldSetTag methodsFor: 'accessing' stamp: 'mb 3/8/2006 17:44'!tag	^ 'fieldset'! !!WAAbstractTextAreaTag commentStamp: '<historical>' prior: 0!An abstract class to describe the HTML elements that can have a text cursor.The cursorPosition i-var holds the desired cursor position!!WAAbstractTextAreaTag methodsFor: 'callbacks' stamp: 'pmm 9/12/2006 19:16'!callback: aBlock	self name: (canvas callbacks registerCallback:		(self fromStringConverterBlockFor: self value callback: aBlock)).	self value: self value asSeasideString.! !!WAAbstractTextAreaTag methodsFor: 'javascript' stamp: 'mb 10/10/2006 23:24'!exampleText: aString	(self value isNil or: [self value = aString]) ifTrue:		[self			onFocus: 'if(value == ', aString printString, '){value=''''; style.color=''black''}';			style: 'color: #aaa';			value: aString]! !!WAAbstractTextAreaTag methodsFor: 'javascript' stamp: 'mb 3/23/2006 17:25'!setCursorPosition: anInteger	| aStream |	"Insert the javascript for setting the cursor position"	self ensureId.	aStream _ (String new: 30) writeStream.	#setCursor.	aStream		nextPutAll: 'setCursor(';		nextPutAll: self id printString.	anInteger isNumber ifTrue:		[aStream nextPutAll: ',' , anInteger asString].	"Cursor will go at end of field value, if position is not a number"	aStream nextPut: $).	self session addLoadScript: aStream contents! !!WATextAreaTag methodsFor: 'attributes' stamp: 'ac 3/22/2005 17:49'!columns: anInteger	self attributeAt: 'cols' put: anInteger.! !!WATextAreaTag methodsFor: 'attributes' stamp: 'ac 3/22/2005 17:50'!rows: anInteger	self attributeAt: 'rows' put: anInteger.! !!WATextAreaTag methodsFor: 'accessing' stamp: 'ac 4/13/2005 01:51'!tag	^ 'textarea'! !!WATextAreaTag methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:42'!value	^value! !!WATextAreaTag methodsFor: 'accessing' stamp: 'ac 8/30/2005 16:26'!value: aString	value _ aString! !!WATextAreaTag methodsFor: 'public api' stamp: 'ac 8/30/2005 16:29'!with: aBlock	^ value ifNotNil: [super with: value] ifNil: [super with: aBlock]! !!WAPasswordInputTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 17:33'!type	^ 'password'! !!WATextInputTag methodsFor: 'attributes' stamp: 'lr 10/10/2005 20:04'!beRangeInput	self type: 'range'.! !!WATextInputTag methodsFor: 'attributes' stamp: 'lr 10/10/2005 20:04'!beSearchInput	self type: 'search'.! !!WATextInputTag methodsFor: 'attributes' stamp: 'avi 11/7/2005 14:09'!size: aNumber	self attributeAt: 'size' put: aNumber! !!WATextInputTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:50'!type	^ 'text'! !!WACheckboxTag methodsFor: 'private' stamp: 'avi 4/28/2005 14:16'!after	canvas hiddenInput callback:		[callback value: value.		value _ false]! !!WACheckboxTag methodsFor: 'callbacks' stamp: 'mb 9/30/2006 15:05'!callback: aBlock	value _ false.	callback _ aBlock fixCallbackTemps.	super callback: [value _ true]! !!WACheckboxTag methodsFor: 'javascript' stamp: 'mb 3/8/2006 18:20'!canHaveShortcut	^true! !!WACheckboxTag methodsFor: 'attributes' stamp: 'mb 9/30/2006 15:05'!onTrue: trueBlock onFalse: falseBlock	trueBlock fixCallbackTemps. falseBlock fixCallbackTemps.	self callback: [ :v | v ifTrue: [ trueBlock value ] ifFalse: [ falseBlock value ] ].! !!WACheckboxTag methodsFor: 'attributes' stamp: 'pmm 7/19/2006 19:29'!submitFormNamed: formName	self onClick: 'submitForm('				, formName asString printString 				, '); return false;'.! !!WACheckboxTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:44'!type	^ 'checkbox'! !!WACheckboxTag methodsFor: 'attributes' stamp: 'lr 9/23/2005 13:47'!value: aBoolean	self attributeAt: 'checked' put: aBoolean.! !!WAFileUploadTag methodsFor: 'callbacks' stamp: 'mb 9/30/2006 15:06'!callback: aBlock	aBlock fixCallbackTemps.	super callback: [ :file | aBlock value: (file = '' ifFalse: [ file ]) ].! !!WAFileUploadTag methodsFor: 'callbacks' stamp: 'lr 10/19/2005 00:13'!on: selector of: anObject	self callback: [ :value | anObject perform: selector asMutator with: value ].! !!WAFileUploadTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:45'!type	^ 'file'! !!WAFormInputTag methodsFor: 'callbacks' stamp: 'lr 9/26/2005 12:47'!callback: aBlock	self name: (canvas callbacks registerCallback: aBlock).! !!WAFormInputTag methodsFor: 'converting' stamp: 'pmm 9/12/2006 18:24'!fromStringConverterBlockFor: anObject callback: aBlock	^ [ :value |			aBlock value: 			([anObject convertSeasideString: value ]				on: Error				do: [ :error | value ] ) ]! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 9/23/2005 13:41'!name: aString	self attributes at: 'name' put: aString.! !!WAFormInputTag methodsFor: 'callbacks' stamp: 'mb 2/9/2006 14:51'!on: selector of: anObject	self ensureId: selector.	self value: (anObject perform: selector).	self callback: [ :value | anObject perform: selector asMutator with: value ].! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 9/23/2005 17:43'!readonly: aBoolean	self attributes at: 'readonly' put: aBoolean.! !!WAFormInputTag methodsFor: 'javascript' stamp: 'mb 3/23/2006 09:03'!setFocus	self ensureId.	#setFocus.	self session addLoadScript: 'setFocus(', self id printString, ')'! !!WAFormInputTag methodsFor: 'attributes' stamp: 'mb 3/9/2006 10:23'!submitOnClick	#submit.	self onClick: 'submit()'.! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 10/10/2005 19:49'!tabindex: anInteger	self attributes at: 'tabindex' put: anInteger.! !!WAFormInputTag methodsFor: 'accessing' stamp: 'ac 3/16/2005 12:08'!tag	^ 'input'! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 9/23/2005 13:42'!text: aString	self value: aString.! !!WAFormInputTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:43'!type	^ nil! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 10/10/2005 19:49'!type: aString	self attributes at: 'type' put: aString.! !!WAFormInputTag methodsFor: 'attributes' stamp: 'mb 1/30/2006 18:59'!value	^self attributes at: 'value' ! !!WAFormInputTag methodsFor: 'attributes' stamp: 'lr 9/23/2005 13:42'!value: anObject	anObject ifNotNil: [ self attributes at: 'value' put: anObject ].! !!WAFormInputTag methodsFor: 'public' stamp: 'lr 9/23/2005 14:10'!with: aBlock	self type isNil ifFalse: [		self attributes at: 'type' ifAbsentPut: [ self type ].		self class: self type ].	super with: aBlock.! !!WAHiddenInputTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 17:45'!type	^ 'hidden'! !!WARadioButtonTag methodsFor: 'attributes' stamp: 'ac 7/6/2005 10:39'!beChecked	self attributeAt: 'checked' put: true.! !!WARadioButtonTag methodsFor: 'attributes' stamp: 'ac 7/6/2005 10:40'!beUnchecked	self attributeAt: 'checked' put: false.! !!WARadioButtonTag methodsFor: 'callbacks' stamp: 'ac 7/6/2005 11:24'!callback: aBlock	self attributeAt: 'value' put: (canvas callbacks registerCallback: aBlock).! !!WARadioButtonTag methodsFor: 'javascript' stamp: 'mb 3/8/2006 18:20'!canHaveShortcut	^true! !!WARadioButtonTag methodsFor: 'attributes' stamp: 'ac 7/6/2005 11:32'!group: aRadioGroup	self name: aRadioGroup key.! !!WARadioButtonTag methodsFor: 'attributes' stamp: 'ac 7/6/2005 11:01'!selected: aBoolean	self attributeAt: 'checked' put: aBoolean.! !!WARadioButtonTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:46'!type	^ 'radio'! !!WAButtonTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 17:37'!type	^ 'button'! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'mb 6/8/2006 16:08'!callback: aBlock	self attributes at: 'name' ifAbsentPut: [canvas callbacks registerImageCallback: aBlock].! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 22:02'!extent: aPoint	self width: aPoint x; height: aPoint y.! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 22:04'!form: aForm	self extent: aForm extent.	self url: (canvas context urlForDocument: aForm).! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:43'!height: aNumber	self attributes at: 'height' put: aNumber! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 22:03'!resourceUrl: aString	self url: (canvas document root absoluteUrlForResource: aString).! !!WAImageButtonTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:49'!type	^ 'image'! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 22:02'!url: aString	self attributes at: 'src' put: aString.! !!WAImageButtonTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:43'!width: aNumber	self attributes at: 'width' put: aNumber! !!WASubmitButtonTag methodsFor: 'callbacks' stamp: 'mb 1/5/2006 14:08'!callback: aBlock	self attributes at: 'name' ifAbsentPut: [canvas callbacks registerActionCallback: aBlock].	! !!WASubmitButtonTag methodsFor: 'javascript' stamp: 'mb 3/8/2006 18:19'!canHaveShortcut	^true! !!WASubmitButtonTag methodsFor: 'callbacks' stamp: 'jlr 4/13/2006 13:26'!on: aSymbol of: anObject	self value: (self labelForSelector: aSymbol of: anObject).	self callback: [anObject perform: aSymbol ].! !!WASubmitButtonTag methodsFor: 'accessing' stamp: 'lr 9/23/2005 13:49'!type	^ 'submit'! !!WAFormTag methodsFor: 'attributes' stamp: 'lr 7/9/2006 18:56'!action: aString	self attributeAt: 'action' put: aString! !!WAFormTag methodsFor: 'private' stamp: 'lr 7/9/2006 18:56'!after	canvas div: [		canvas context actionUrl parameters keysAndValuesDo: [ :k :v |			canvas hiddenInput name: k; value: v.			canvas text: ' ' ] ]! !!WAFormTag methodsFor: 'private' stamp: 'avi 3/23/2006 23:07'!before	defaultAction ifNotNil: [		canvas submitButton			callback: defaultAction;			value: 'Default';			style: 'position: absolute; top: -100em';			with: nil.		canvas textInput			callback: [:v];			style: 'position: absolute; top: -100em'  ].! !!WAFormTag methodsFor: 'callbacks' stamp: 'ac 4/13/2005 00:02'!defaultAction: aBlock	defaultAction _ aBlock.! !!WAFormTag methodsFor: 'attributes' stamp: 'lr 7/9/2006 18:57'!method: aString	self attributeAt: 'method' put: aString! !!WAFormTag methodsFor: 'attributes' stamp: 'avi 6/8/2005 21:46'!multipart	self attributeAt: 'enctype' put: 'multipart/form-data'! !!WAFormTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 21:37'!multipart: aBoolean	aBoolean ifTrue: [ self multipart ].! !!WAFormTag methodsFor: 'attributes' stamp: 'avi 6/9/2005 16:02'!name: aString	self attributeAt: 'name' put: aString! !!WAFormTag methodsFor: 'attributes' stamp: 'avi 3/21/2006 16:51'!noAutocomplete	self attributeAt: 'autocomplete' put: 'off'! !!WAFormTag methodsFor: 'attributes' stamp: 'lr 7/9/2006 18:57'!post	self method: 'post'! !!WAFormTag methodsFor: 'initialize-release' stamp: 'lr 7/9/2006 18:56'!setParent: aBrush canvas: aCanvas	super setParent: aBrush canvas: aCanvas.	self post; action: ''! !!WAFormTag methodsFor: 'private' stamp: 'avi 6/17/2004 11:29'!tag	^ 'form'! !!WAGenericTag class methodsFor: 'as yet unclassified' stamp: 'avi 6/13/2004 00:53'!tag: aString	^ self basicNew initializeWithTag: aString! !!WAGenericTag methodsFor: 'initialize-release' stamp: 'avi 6/13/2004 00:40'!initializeWithTag: aString	tag _ aString! !!WAGenericTag methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:40'!tag	^ tag! !!WAHeadingTag methodsFor: 'accessing' stamp: 'ac 3/16/2005 14:12'!level	^ level ifNil: [1]! !!WAHeadingTag methodsFor: 'attributes' stamp: 'ac 3/16/2005 14:12'!level1	level _ 1.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'ac 3/16/2005 14:12'!level2	level _ 2.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'ac 3/16/2005 14:12'!level3	level _ 3.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'ac 3/16/2005 14:12'!level4	level _ 4.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'dc 8/16/2006 07:43'!level5	level _ 5.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'dc 8/16/2006 07:43'!level6	level _ 6.! !!WAHeadingTag methodsFor: 'attributes' stamp: 'lr 9/14/2005 21:33'!level: anInteger	level := anInteger! !!WAHeadingTag methodsFor: 'accessing' stamp: 'avi 5/10/2005 14:33'!tag	^ 'h', self level displayString ! !!WAIframeTag methodsFor: 'conveniance' stamp: 'lr 3/10/2006 12:36'!contents: anObject	| key |	key := canvas callbacks registerActionCallback: [ self performRendering: anObject ].	self src: (canvas context actionUrl withParameter: key)! !!WAIframeTag methodsFor: 'conveniance' stamp: 'lr 8/9/2006 08:34'!document: anObject	self document: anObject mimeType: nil! !!WAIframeTag methodsFor: 'conveniance' stamp: 'lr 8/9/2006 08:31'!document: anObject mimeType: aMimeString	self document: anObject mimeType: aMimeString fileName: nil! !!WAIframeTag methodsFor: 'conveniance' stamp: 'lr 8/9/2006 08:31'!document: anObject mimeType: aMimeString fileName: aFileNameString	self src: (canvas context		urlForDocument: anObject 		mimeType: aMimeString 		fileName: aFileNameString)! !!WAIframeTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:42'!height: anInteger	self attributes at: 'height' put: anInteger! !!WAIframeTag methodsFor: 'attributes' stamp: 'lr 3/10/2006 12:18'!name: aString	self attributes at: 'name' put: aString! !!WAIframeTag methodsFor: 'private' stamp: 'mb 8/18/2006 10:26'!performRendering: anObject	| innerContext docRoot session document response renderer  |	innerContext := canvas context copy.	docRoot := WARenderedHtmlRoot context: innerContext.	docRoot 		resourceBaseUrl: innerContext document root resourceBaseUrl;		addHeadElement: ((WAHtmlElement named: 'base')			attributeAt: 'target' put: '_top';			yourself).	session := WACurrentSession value.	document := session outputDocumentClass root: docRoot.	response := WAResponse new.	response headerAt: 'Cache-Control' put: 'No-cache'.	document stream: response stream.	canvas context document: document.	renderer := canvas species context: canvas context callbacks: canvas callbacks.	renderer render: anObject; flush. 	document close.	session returnResponse: response! !!WAIframeTag methodsFor: 'attributes' stamp: 'pmm 8/26/2006 00:07'!src: anUrl	"should be deprecated"	self url: anUrl! !!WAIframeTag methodsFor: 'accessing' stamp: 'lr 3/8/2006 23:25'!tag	^ 'iframe'! !!WAIframeTag methodsFor: 'attributes' stamp: 'pmm 8/26/2006 00:06'!url: aString	self attributeAt: 'src' put: aString! !!WAIframeTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:43'!width: anInteger	self attributes at: 'width' put: anInteger! !!WALabelTag methodsFor: 'attributes' stamp: 'ac 7/9/2005 04:36'!for: aString	self attributeAt: 'for' put: aString.! !!WALabelTag methodsFor: 'accessing' stamp: 'ac 7/9/2005 04:36'!tag	^ 'label'! !!WAOptionTag methodsFor: 'attributes' stamp: 'ac 3/17/2005 17:53'!callback: aBlock	self attributeAt: 'value' put: (canvas callbacks registerCallback: aBlock).! !!WAOptionTag methodsFor: 'attributes' stamp: 'pmm 7/19/2006 20:06'!on: selector of: anObject	"copy pasted from WASelectTag, we need a traitified version of seaside"	self selected: (anObject perform: selector).	self callback: [ :value | anObject perform: selector asMutator with: value ].! !!WAOptionTag methodsFor: 'attributes' stamp: 'ac 3/17/2005 17:13'!selected: aBoolean	self attributeAt: 'selected' put: aBoolean.! !!WAOptionTag methodsFor: 'accessing' stamp: 'ac 3/17/2005 17:13'!tag	^ 'option'! !!WARubyTextTag methodsFor: 'attributes' stamp: 'pmm 9/18/2006 19:01'!span: anInteger	self attributeAt: 'rbspan' put: anInteger! !!WARubyTextTag methodsFor: 'accessing' stamp: 'pmm 9/18/2006 19:00'!tag	^ 'rt'! !!WAScriptTag methodsFor: 'as yet unclassified' stamp: 'cwp 9/11/2006 17:25'!resourceUrl: aString	self url: (canvas document root absoluteUrlForResource: aString)! !!WAScriptTag methodsFor: 'accessing' stamp: 'dwj 6/10/2005 13:10'!tag	^ 'script'! !!WAScriptTag methodsFor: 'attributes' stamp: 'pmm 8/26/2006 00:05'!url: aString	self attributes at: 'src' put: aString! !!WAScriptTag methodsFor: 'public api' stamp: 'mb 3/16/2006 23:51'!with: aBlock	isClosed := true.	self attributes at: 'type' ifAbsentPut: ['text/javascript'].	self openTag.	canvas html: aBlock.	self closeTag.! !!WATableCellTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 12:08'!align: aString	self attributes at: 'align' put: aString.! !!WATableCellTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 12:08'!colSpan: anInteger	self attributes at: 'colspan' put: anInteger.! !!WATableCellTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 12:08'!rowSpan: anInteger	self attributes at: 'rowspan' put: anInteger.! !!WATableCellTag methodsFor: 'attributes' stamp: 'lr 9/26/2005 12:09'!verticalAlign: aString	self attributes at: 'valign' put: aString.! !!WATableDataTag methodsFor: 'accessing' stamp: 'ac 3/17/2005 22:09'!tag	^ 'td'! !!WATableHeadingTag methodsFor: 'accessing' stamp: 'ac 3/17/2005 22:10'!tag	^ 'th'! !!WATableTag methodsFor: 'attributes' stamp: 'al 9/7/2006 15:27'!border: anInteger	self attributes at: 'border' put: anInteger! !!WATableTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:44'!cellpadding: anInteger	self attributes at: 'cellpadding' put: anInteger! !!WATableTag methodsFor: 'attributes' stamp: 'lr 8/3/2006 08:44'!cellspacing: anInteger	self attributes at: 'cellspacing' put: anInteger! !!WATableTag methodsFor: 'attributes' stamp: 'al 9/7/2006 15:28'!layout	self border: 0.	self cellspacing: 0.	self cellpadding: 0! !!WATableTag methodsFor: 'accessing' stamp: 'ac 3/16/2005 15:22'!tag	^ 'table'! !!WATagBrush class methodsFor: 'code generation' stamp: 'mb 3/16/2006 16:01'!tag	"((( WASelectTag tag )))"	"((( WAGenericTag tag )))"	^(self selectors includes: #tag) ifTrue: [self new tag] ifFalse: [nil].! !!WATagBrush methodsFor: 'attributes' stamp: 'ac 3/16/2006 10:57'!accessKey: aString	self attributeAt: 'accesskey' put: aString! !!WATagBrush methodsFor: 'javascript' stamp: 'mb 3/23/2006 08:55'!addShortcut: aString	| aStream |	self canHaveShortcut ifFalse:		[self error: 'May not assign shortcut on items that are not clickable'].	aString notNil ifTrue:		[aStream _ (String new: 30) writeStream.		self ensureId.		#addShortcut.		aStream			nextPutAll: 'addShortcut(';			nextPutAll: aString printString;			nextPut: $,;			nextPutAll: self id printString;			nextPut: $).		self session addLoadScript: aStream contents].		! !!WATagBrush methodsFor: 'attributes' stamp: 'mb 3/8/2006 17:51'!addStyle: aString	self attributes addStyle: aString.! !!WATagBrush methodsFor: 'private' stamp: 'ac 3/17/2005 18:18'!after! !!WATagBrush methodsFor: 'attributes' stamp: 'mb 3/23/2006 17:08'!attributeAt: key	^(self attributes at: key ifAbsent: [key -> nil]) value.! !!WATagBrush methodsFor: 'attributes' stamp: 'avi 6/17/2004 12:40'!attributeAt: key put: value	self attributes at: key put: value! !!WATagBrush methodsFor: 'attributes' stamp: 'avi 6/13/2004 01:03'!attributes	^ attributes ifNil: [attributes _ WAHtmlAttributes new]! !!WATagBrush methodsFor: 'attributes' stamp: 'avi 6/17/2004 14:15'!attributes: anHtmlAttributes	attributes _ anHtmlAttributes! !!WATagBrush methodsFor: 'private' stamp: 'ac 3/17/2005 18:18'!before! !!WATagBrush methodsFor: 'javascript' stamp: 'mb 3/8/2006 18:18'!canHaveShortcut	^false! !!WATagBrush methodsFor: 'attributes' stamp: 'avi 6/22/2005 01:49'!class: aString	self attributes addClass: aString! !!WATagBrush methodsFor: 'private' stamp: 'mb 3/16/2006 23:19'!closeTag	self document closeTag: self tag.! !!WATagBrush methodsFor: 'javascript' stamp: 'avi 3/9/2006 17:41'!confirm: aString	self onClick: 'return confirm("', aString, '")'! !!WATagBrush methodsFor: 'events' stamp: 'mb 10/10/2006 22:49'!disableEnter	self onEnter: ''.! !!WATagBrush methodsFor: 'attributes' stamp: 'ac 10/16/2005 19:55'!disabled	self disabled: true.! !!WATagBrush methodsFor: 'attributes' stamp: 'ac 10/16/2005 19:55'!disabled: aBoolean	self attributes at: 'disabled' put: aBoolean.! !!WATagBrush methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:39'!document	^ canvas document! !!WATagBrush methodsFor: 'public' stamp: 'mb 3/31/2006 11:36'!ensureId	"This verifies whether a value has been previously supplied	for the id= attribute, and, if not, 	a non-nil default value is automatically supplied	Answers the value of the id= attribute"	^self ensureIdUsing: [canvas nextId].! !!WATagBrush methodsFor: 'public' stamp: 'mb 3/23/2006 16:59'!ensureId: aString	"This verifies whether a value has been previously supplied	for the id= attribute, and, if not, 	the argument value is used for the id= attribute	The argument is expected to be non nil	Answers the value of the id= attribute"	^self ensureIdUsing: [aString]! !!WATagBrush methodsFor: 'private' stamp: 'mb 3/27/2006 23:37'!ensureIdUsing: aBlock	"This verifies whether a value has been previously supplied	for the id= attribute, and, if not, 	the non-nil argument value is remembered	Answers the value of the id= attribute"	^self id ifNil: 		[ | idValue |		idValue _ aBlock value.		idValue isNil ifTrue: [self error: 'Ensuring a nil value : does this make sense ?'].		idValue ifNil: [self ensureId] ifNotNil: [self id: idValue. idValue]]! !!WATagBrush methodsFor: 'private' stamp: 'mb 3/31/2006 11:42'!getId	"Compatibility"	^ canvas nextId.! !!WATagBrush methodsFor: 'accessing' stamp: 'mb 3/23/2006 17:09'!id	"Convert to a String in case it was supplied as a Symbol"	| idValue |	idValue _ self attributeAt: 'id'.	^idValue ifNotNil: [idValue asString]! !!WATagBrush methodsFor: 'attributes' stamp: 'mb 3/23/2006 17:00'!id: aString	self attributeAt: 'id' put: aString.! !!WATagBrush methodsFor: 'javascript' stamp: 'ac 10/5/2005 00:16'!ignoreURL	^ self onClick: 'return false'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onBlur: aString	"The onblur event occurs when an element loses focus either by the pointing device or by tabbing navigation."	self attributes at: 'onblur' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onChange: aString	"The onchange event occurs when a control loses the input focus and its value has been modified since gaining focus."	self attributes at: 'onchange' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onClick: aString	"The onclick event occurs when the pointing device button is clicked over an element."	self attributes at: 'onclick' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onDoubleClick: aString	"The ondblclick event occurs when the pointing device button is double clicked over an element."	self attributes at: 'ondblclick' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'mb 10/10/2006 22:48'!onEnter: aString	self onKeyPress: 'if((window.event ? window.event.keyCode : event.which) == 13){', aString displayString, '; return false}; return true'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onError: aString	self attributes at: 'onerror' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onFocus: aString	"The onfocus event occurs when an element receives focus either by the pointing device or by tabbing navigation."	self attributes at: 'onfocus' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onKeyDown: aString	"The onkeydown event occurs when a key is pressed down over an element."	self attributes at: 'onkeydown' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onKeyPress: aString	"The onkeypress event occurs when a key is pressed and released over an element."	self attributes at: 'onkeypress' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onKeyUp: aString	"The onkeyup event occurs when a key is released over an element."	self attributes at: 'onkeyup' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'mb 6/21/2006 18:28'!onLoad: aString	"The onload event occurs when the user agent finishes loading a window."	self attributes at: 'onload' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onMouseDown: aString	"The onmousedown event occurs when the pointing device button is pressed over an element."	self attributes at: 'onmousedown' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onMouseMove: aString	"The onmousemove event occurs when the pointing device is moved while it is over an element."	self attributes at: 'onmousemove' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onMouseOut: aString	"The onmouseout event occurs when the pointing device is moved away from an element."	self attributes at: 'onmouseout' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onMouseOver: aString	"The onmouseover event occurs when the pointing device is moved onto an element."	self attributes at: 'onmouseover' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:48'!onMouseUp: aString	"The onmouseup event occurs when the pointing device button is released over an element."	self attributes at: 'onmouseup' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onReset: aString	"The onreset event occurs when a form is reset."	self attributes at: 'onreset' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onResize: aString	self attributes at: 'onresize' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onScroll: aString	self attributes at: 'onscroll' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onSelect: aString	"The onselect event occurs when a user selects some text in a text field."	self attributes at: 'onselect' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onSubmit: aString	"The onsubmit event occurs when a form is submitted."	self attributes at: 'onsubmit' append: aString separator: ';'! !!WATagBrush methodsFor: 'events' stamp: 'lr 6/7/2006 13:49'!onUnload: aString	"The onunload event occurs when the user agent removes a document from a window."	self attributes at: 'onunload' append: aString separator: ';'! !!WATagBrush methodsFor: 'private' stamp: 'mb 3/16/2006 23:18'!openTag	self document openTag: self tag attributes: attributes.! !!WATagBrush methodsFor: 'public' stamp: 'avi 3/18/2005 22:10'!section: aSymbol	self class: (canvas painter classForSection: aSymbol).	self with: [canvas painter perform: aSymbol with: canvas]! !!WATagBrush methodsFor: 'attributes' stamp: 'mb 2/19/2006 16:26'!style: aString	self attributes addStyle: aString! !!WATagBrush methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:30'!tag	self subclassResponsibility! !!WATagBrush methodsFor: 'attributes' stamp: 'pmm 9/18/2006 19:03'!title: aString	self attributeAt: 'title' put: aString! !!WATagBrush methodsFor: 'public' stamp: 'mb 3/23/2006 08:57'!with: aBlock	self openTag.	super with: [self within: aBlock].	self closeTag.! !!WATagBrush methodsFor: 'convenience' stamp: 'avi 3/16/2006 12:20'!withLineBreaks: aString	self with: [canvas withLineBreaks: aString]! !!WATagBrush methodsFor: 'private' stamp: 'ac 4/13/2005 00:44'!within: aBlock	self before.	aBlock renderOn: canvas.	self after.! !!WACachedDocument commentStamp: '<historical>' prior: 0!This class is for serving smallish files like PNG images etc using WADocumentHandler. Using the Canvas API for HTML generation you simply do this:	html image fileName: 'myimage.png'or:	html image fileName: 'myimage.blurp' mimeType: 'blurp'This will create a request handler in your WAApplication registry that is accessible on a unique URL and does not expire.The actual contents of the file will only be read upon first access, we could augment this class with smarter caching, like checking the modification time on disk.The class has a Cache class var holding a Dictionary of created instances so you can clear and preload files into the image using:	WACachedDocument		clearCache;		fileName: 'myimage.png';		fileName: 'another.gif'; "etc"		preloadCache!!WACachedDocument class methodsFor: 'cache' stamp: 'gk 1/19/2006 08:15'!clearCache	"Clear the cache of instances. This will cause	the files to be lazily reread from disk."	Cache _ Dictionary new! !!WACachedDocument class methodsFor: 'instance-creation' stamp: 'gk 1/12/2006 14:17'!fileName: aFileName	"Check the cache to see if we already have this file loaded.	We only rely on the local filename!!"	^Cache at: aFileName ifAbsentPut: [self fullFileName: aFileName]! !!WACachedDocument class methodsFor: 'instance-creation' stamp: 'gk 1/10/2006 13:22'!fullFileName: fullFileName	^self new fullFileName: fullFileName! !!WACachedDocument class methodsFor: 'initialize-release' stamp: 'gk 1/12/2006 14:05'!initialize	self clearCache! !!WACachedDocument class methodsFor: 'cache' stamp: 'gk 1/19/2006 08:14'!preloadCache	"Load the files into the image for the currently	created instances in the Cache."	Cache valuesDo: [:d | d asMIMEDocument ]! !!WACachedDocument methodsFor: 'comparing' stamp: 'gk 1/10/2006 13:13'!= other	"Currently we do not take file modification time on disk into account."	^other species = self species and: [other fullFileName = fullFileName]! !!WACachedDocument methodsFor: 'public' stamp: 'mb 6/2/2006 10:49'!asMIMEDocument	^self asMIMEDocumentType: mimeType! !!WACachedDocument methodsFor: 'public' stamp: 'mb 6/2/2006 10:49'!asMIMEDocumentType: type	"Lazy caching."	^mimeDocument ifNil: [		mimeType _ type.		mimeDocument _ SeasidePlatformSupport				mimeDocumentOfType: mimeType 				from: fullFileName].	! !!WACachedDocument methodsFor: 'accessing' stamp: 'gk 1/10/2006 11:19'!fullFileName	^fullFileName! !!WACachedDocument methodsFor: 'initialize-release' stamp: 'gk 1/10/2006 11:12'!fullFileName: aFileName	fullFileName _ aFileName	! !!WACachedDocument methodsFor: 'comparing' stamp: 'gk 1/10/2006 13:14'!hash	"Currently we do not take file modification time on disk into account.	Note that mimeType and mimeDocument are set lazily later, so we can't use	the mimeType in the hash."	^fullFileName hash! !!WACachedDocument methodsFor: 'accessing' stamp: 'gk 1/10/2006 11:18'!mimeType	^mimeType! !!WACachedDocument methodsFor: 'accessing' stamp: 'gk 1/10/2006 11:14'!mimeType: anObject	^mimeType := anObject! !!WAActionCallback methodsFor: 'as yet unclassified' stamp: 'mb 9/30/2006 15:05'!block: aZeroArgBlock	block _ aZeroArgBlock fixCallbackTemps.! !!WAActionCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 01:51'!evaluateWithArgument: anObject	block value.	self signalRenderNotification! !!WAActionCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:41'!isFinal	^ true! !!WAActionCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:37'!priority	^ 8! !!WAActionCallback methodsFor: 'as yet unclassified' stamp: 'rjl 4/16/2006 15:56'!signalRenderNotification 	WARenderNotification raiseSignal! !!WACancelActionCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:37'!priority	^ 3! !!WADefaultActionCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:37'!priority	^ 10! !!WAImageCallback methodsFor: 'as yet unclassified' stamp: 'avi 9/2/2004 14:46'!convertKey: aString	^ aString, '.x'! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:38'!<= other	^ self priority < other priority or: [self priority = other priority and: [self key asNumber <= other key asNumber]]! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 21:48'!context	^ context! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 9/2/2004 14:46'!convertKey: aString	^ aString! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 21:49'!evaluateWithArgument: anObject	self subclassResponsibility! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 01:52'!evaluateWithField: anObject 	self evaluateWithArgument: (self valueForField: anObject)! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 9/2/2004 14:46'!key	^ (self convertKey: key)! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 21:48'!owner	^ owner! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:17'!priority	self subclassResponsibility ! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:39'!setContext: aRenderingContext owner: anObject key: aString	context _ aRenderingContext.	owner _ anObject.	key _ aString! !!WACallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 21:51'!valueForField: anObject	^ anObject		ifNil: ['']		ifNotNil:			[(anObject isCollection and: [anObject isString not])					ifTrue: [anObject isEmpty								ifTrue: ['']								ifFalse: [anObject first]]					ifFalse: [anObject]]! !!WADispatchCallback methodsFor: 'as yet unclassified' stamp: 'lr 4/19/2006 08:05'!evaluateWithArgument: anObject	(context callbackAt: anObject) 		ifNotNilDo: [ :callback | callback evaluateWithArgument: nil ]! !!WADispatchCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:42'!priority	^ 5! !!WAMultiDispatchCallback methodsFor: 'as yet unclassified' stamp: 'lr 10/10/2005 19:56'!evaluateWithField: anObject	(anObject isCollection and: [ anObject isString not ]) 		ifFalse: [ ^ super evaluateWithField: anObject ].	anObject do: [ :each | 		self evaluateWithArgument: (self valueForField: each) ].! !!WAValueCallback methodsFor: 'as yet unclassified' stamp: 'mb 9/30/2006 15:08'!block: aOneArgBlock	block _ aOneArgBlock fixCallbackTemps! !!WAValueCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:17'!evaluateWithArgument: anObject	block valueWithPossibleArgs: (Array with: anObject)! !!WAValueCallback methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:41'!priority	^ 5! !!WACallbackRegistry class methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:04'!context: aContext owner: anObject	^ self basicNew initializeWithContext: aContext owner: anObject! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:04'!initializeWithContext: aContext owner: anObject	context _ aContext.	owner _ anObject! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:10'!registerActionCallback: aBlock	^ self storeCallback: (WAActionCallback new block: aBlock)! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:10'!registerCallback: aBlock	^ self storeCallback: (WAValueCallback new block: aBlock)! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:41'!registerCancelActionCallback: aBlock	^ self storeCallback: (WACancelActionCallback new block: aBlock)! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:41'!registerDefaultActionCallback: aBlock	^ self storeCallback: (WADefaultActionCallback new block: aBlock)! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:10'!registerDispatchCallback	^ self storeCallback: WADispatchCallback new! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 9/2/2004 14:42'!registerImageCallback: aBlock	^ self storeCallback: (WAImageCallback new block: aBlock)! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'lr 10/10/2005 20:00'!registerMultiDispatchCallback	^ self storeCallback: WAMultiDispatchCallback new! !!WACallbackRegistry methodsFor: 'as yet unclassified' stamp: 'avi 6/7/2004 22:43'!storeCallback: aCallback	| key |	key _ context storeCallback: aCallback.	aCallback setContext: context owner: owner key: key.	^ key! !!WACallbackStream class methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 01:58'!callbacks: aDictionary request: aRequest	^ self basicNew initializeWithCallbacks: aDictionary request: aRequest! !!WACallbackStream methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 01:59'!atEnd	^ callbacks atEnd! !!WACallbackStream methodsFor: 'as yet unclassified' stamp: 'lr 9/26/2005 14:10'!initializeWithCallbacks: aDictionary request: aRequest	| collection |	collection := SortedCollection new.	aRequest fields keys do:		[:ea |		aDictionary at: ea ifPresent: [:callback | collection add: callback]].	callbacks := ReadStream on: collection asArray.	request := aRequest! !!WACallbackStream methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 01:59'!position	^ callbacks position! !!WACallbackStream methodsFor: 'as yet unclassified' stamp: 'avi 6/12/2004 00:21'!processCallbacksWithOwner: anObject	| callback |	[callbacks atEnd not and: [callbacks peek owner == anObject]] whileTrue:		[callback _ callbacks next.		callback evaluateWithField: (request fields at: callback key)]! !!WACallbackStream methodsFor: 'as yet unclassified' stamp: 'avi 6/12/2004 00:25'!upToEnd	^ callbacks upToEnd! !!WACanvas methodsFor: 'public api' stamp: 'avi 6/17/2004 12:36'!brush: aBrush	self flush.	currentBrush _ aBrush.	aBrush setParent: parentBrush canvas: self.	^ aBrush! !!WACanvas methodsFor: 'private' stamp: 'avi 6/17/2004 12:12'!flush	currentBrush ifNotNil:		[currentBrush close.		currentBrush _ nil]! !!WACanvas methodsFor: 'private' stamp: 'mb 1/30/2006 18:12'!forgetCurrentBrush	currentBrush _ nil.! !!WACanvas methodsFor: 'private' stamp: 'avi 9/21/2005 23:19'!insert: aBlock	| oldBrush |	oldBrush _ currentBrush.	currentBrush _ nil.	aBlock value.	currentBrush _ oldBrush! !!WACanvas methodsFor: 'private' stamp: 'avi 6/17/2004 12:37'!nest: aBlock	parentBrush _ currentBrush.	currentBrush _ nil.	aBlock renderOn: self.	self flush.	parentBrush _ parentBrush parent.! !!WACanvas methodsFor: 'accessing' stamp: 'avi 3/18/2005 21:56'!painter	^ painter! !!WACanvas methodsFor: 'accessing' stamp: 'avi 3/18/2005 21:56'!painter: anObject	painter _ anObject! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'ac 7/9/2005 04:31'!generateBinaryFor: aCollection	(aCollection size = 3 and: [(self includesSelector: aCollection third) not]) ifTrue:		[self 			compile: aCollection third, ' aBlock	self ', aCollection second, ' with: aBlock'			classified: self generatedCategory].! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'mb 3/16/2006 16:04'!generateTags	"((( WAHtmlCanvas generateTags )))"	self tags do:		[:spec |		self generateUnaryFor: spec.		self generateBinaryFor: spec].! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'ac 7/9/2005 04:29'!generateUnaryFor: aCollection	(self includesSelector: aCollection second) ifFalse:		[self 			compile: aCollection second, '	^ self ', (self patternFor: aCollection first)			classified: self generatedCategory]! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'ac 7/9/2005 04:30'!generatedCategory	^ 'html-generated'! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'mb 3/16/2006 16:04'!patternFor: aString	WATagBrush allSubclassesDo:		[:each | each tag = aString			ifTrue: [^ 'brush: ', each name, ' new']].	^ 'tag: ', aString printString! !!WAHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'mb 10/3/2006 08:53'!tags	"	self generateTags	"	^ #(		('a' anchor)		('iframe' iframe)				('p' paragraph paragraph:)		('div' div div:)		('span' span span:)		('blockquote' blockquote blockquote:)		('address' address address:)		('dd' definitionData definitionData:)		('dl' definitionList definitionList:)		('dt' definitionTerm definitionTerm:)		('pre' preformatted preformatted:)		('em' emphasis emphasis:)		('b' bold bold:)		('i' italic italic:)		('u' underline underline:)		('small' small small:)		('big' big big:)		('strong' strong strong:)		('label' label label:)		('legend' legend legend:)		('fieldset' fieldSet fieldSet:)				('abbr' abbreviated abbreviated:)		('acronym' acronym acronym:)		('code' code code:)		('cite' citation citation:)		('dfn' definition definition:)		('samp' sampleOutput sampleOutput:)		('kbd' keyboardInput keyboardInput:)		('q' quote quote:)		('var' variable variable:)								('ul' unorderedList unorderedList:)		('ol' orderedList orderedList:)		('li' listItem listItem:)				('br' break)		('hr' horizontalRule)				('form' form form:)		('img' image image:)				('table' table table:)		('th' tableHeading tableHeading:)		('tr' tableRow tableRow:)		('td' tableData tableData:)		('tbody' tableBody tableBody:)		('thead' tableHead tableHead:)		('tfoot' tableFoot tableFoot:)				('script' script script:)				('ruby' ruby ruby:)		('rbc' rubyBaseContainer rubyBaseContainer:)		('rtc' rubyTextContainer rubyTextContainer:)		('rb' rubyBase rubyBase:)		('rt' rubyText rubyText:)		('rp' rubyParentheses rubyParentheses:)		)! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:07'!abbreviated	"abbreviations like 'M.', 'Inc.', 'et al.', 'etc.'"	^ self tag: 'abbr'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!abbreviated: aBlock	self abbreviated with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:07'!acronym	"acronyms such as 'GmbH', 'NATO', and 'F.B.I.', "	^ self tag: 'acronym'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/24/2006 13:42'!acronym: aBlock	self acronym with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:43'!address	^ self tag: 'address'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:44'!address: aBlock	self address with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'dwj 6/11/2005 06:04'!anchor	^ self brush: WAAnchorTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 2/21/2006 14:36'!big	^ self tag: 'big'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 2/21/2006 14:36'!big: aBlock	self big with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!blockquote	^ self tag: 'blockquote'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!blockquote: aBlock	self blockquote with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!bold	^ self tag: 'b'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!bold: aBlock	self bold with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!break	^ self tag: 'br'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'lr 5/18/2006 08:55'!canvas	^ self brush: WACanvasTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'lr 5/18/2006 08:55'!canvas: aBlock	^ self canvas with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!citation	^ self tag: 'cite'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!citation: aBlock	self citation with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!code	^ self tag: 'code'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!code: aBlock	self code with: aBlock! !!WAHtmlCanvas methodsFor: 'public api' stamp: 'lr 10/3/2006 08:51'!comment: aString	self flush.	self document comment: aString displayString! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!definition	^ self tag: 'dfn'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!definition: aBlock	self definition with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 5/31/2006 20:26'!definitionData	^ self tag: 'dd'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 5/31/2006 20:26'!definitionData: aBlock	self definitionData with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:39'!definitionList	^ self tag: 'dl'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:42'!definitionList: aBlock	self definitionList with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:42'!definitionTerm	^ self tag: 'dt'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 12/24/2005 17:42'!definitionTerm: aBlock	self definitionTerm with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!div	^ self brush: WADivTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!div: aBlock	self div with: aBlock! !!WAHtmlCanvas methodsFor: 'accessing' stamp: 'avi 6/13/2004 00:57'!document	self subclassResponsibility! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 17:14'!emphasis	^ self tag: 'em'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 17:14'!emphasis: aBlock	self emphasis with: aBlock! !!WAHtmlCanvas methodsFor: 'encoding' stamp: 'mb 1/5/2006 18:27'!encode: anObject	"This is needed by the SeasideAsync package"	^WAAbstractHtmlBuilder encode: anObject! !!WAHtmlCanvas methodsFor: 'encoding' stamp: 'mbany 4/14/2005 12:26'!encodeCharacter: aCharacter	self html: ('&#', aCharacter asInteger displayString, ';').  ! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 2/21/2006 17:15'!fieldSet	^ self brush: WAFieldSetTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/24/2006 13:45'!fieldSet: aBlock	self fieldSet with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'avi 1/9/2006 21:56'!form	^ self tag: 'form'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!form: aBlock	self form with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/16/2005 14:14'!heading	^ self brush: WAHeadingTag new! !!WAHtmlCanvas methodsFor: 'html' stamp: 'ac 3/16/2005 14:14'!heading: aBlock	self heading with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'pmm 12/24/2005 17:38'!heading: aBlock level: aNumber	self heading		level: aNumber;		with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!horizontalRule	^ self tag: 'hr'! !!WAHtmlCanvas methodsFor: 'public api' stamp: 'lr 10/3/2006 08:51'!html: aString	self flush.	self document text: aString displayString! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 4/8/2006 10:56'!iframe	^ self brush: WAIframeTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/16/2005 12:01'!image	^ self brush: WAImageTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/24/2006 13:51'!image: aBlock	self image with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'lr 9/14/2005 22:22'!imageForm: aForm	self image form: aForm.! !!WAHtmlCanvas methodsFor: 'html' stamp: 'mb 9/12/2006 10:28'!imageMap	^ self brush: WAImageMapTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!italic	^ self tag: 'i'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!italic: aBlock	self italic with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:15'!keyboardInput	^ self tag: 'kbd'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!keyboardInput: aBlock	self keyboardInput with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 7/9/2005 04:37'!label	^ self brush: WALabelTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!label: aBlock	self label with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 17:59'!legend	^ self tag: 'legend'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 18:00'!legend: aBlock	self legend with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!listItem	^ self tag: 'li'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!listItem: aBlock	self listItem with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'lr 9/25/2005 11:52'!orderedList	^ self brush: WAListTag new beOrdered.! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'lr 9/25/2005 11:52'!orderedList: aBlock	self orderedList with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!paragraph	^ self tag: 'p'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!paragraph: aBlock	self paragraph with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'ac 7/3/2005 15:46'!popupAnchor	^ self brush: WAPopupAnchorTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!preformatted	^ self tag: 'pre'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!preformatted: aBlock	self preformatted with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!quote	^ self tag: 'q'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!quote: aBlock	self quote with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!ruby	^ self tag: 'ruby'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!ruby: aBlock	self ruby with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyBase	^ self tag: 'rb'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyBase: aBlock	self rubyBase with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyBaseContainer	^ self tag: 'rbc'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyBaseContainer: aBlock	self rubyBaseContainer with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyParentheses	^ self tag: 'rp'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyParentheses: aBlock	self rubyParentheses with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyText	^ self brush: WARubyTextTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyText: aBlock	self rubyText with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyTextContainer	^ self tag: 'rtc'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 9/21/2006 16:26'!rubyTextContainer: aBlock	self rubyTextContainer with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!sampleOutput	^ self tag: 'samp'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!sampleOutput: aBlock	self sampleOutput with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/24/2006 13:53'!script	^ self brush: WAScriptTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!script: aBlock	self script with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!small	^ self tag: 'small'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!small: aBlock	self small with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'avi 6/17/2004 15:07'!space	self html: '&nbsp;'! !!WAHtmlCanvas methodsFor: 'html' stamp: 'mb 2/6/2006 10:48'!space: n	n timesRepeat: [self space].! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!span	^ self tag: 'span'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!span: aBlock	self span with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/20/2005 01:24'!strong	^ self tag: 'strong'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/20/2005 01:24'!strong: aBlock	self strong with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'avi 1/9/2006 22:05'!submitButton	^ self brush: WASubmitButtonTag new.! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!table	^ self brush: WATableTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!table: aBlock	self table with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableBody	^ self tag: 'tbody'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableBody: aBlock	self tableBody with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableData	^ self brush: WATableDataTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableData: aBlock	self tableData with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableFoot	^ self tag: 'tfoot'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableFoot: aBlock	self tableFoot with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableHead	^ self tag: 'thead'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableHead: aBlock	self tableHead with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/17/2005 22:10'!tableHeading	^ self brush: WATableHeadingTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'ac 3/16/2005 16:15'!tableHeading: aBlock	self tableHeading with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableRow	^ self tag: 'tr'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!tableRow: aBlock	self tableRow with: aBlock! !!WAHtmlCanvas methodsFor: 'public api' stamp: 'avi 6/17/2004 12:19'!tag: aString	^ self brush: (WAGenericTag tag: aString)! !!WAHtmlCanvas methodsFor: 'public api' stamp: 'lr 6/14/2006 08:05'!text: anObject	self html: (self encode: anObject)! !!WAHtmlCanvas methodsFor: 'html' stamp: 'avi 1/9/2006 22:07'!textInput	^ self brush: WATextInputTag new! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 17:31'!underline	^ self tag: 'u'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'mb 3/8/2006 17:32'!underline: aBlock	self underline with: aBlock! !!WAHtmlCanvas methodsFor: 'html' stamp: 'lr 9/25/2005 11:51'!unorderedList	^ self brush: WAListTag new beUnordered.! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'avi 6/3/2005 15:40'!unorderedList: aBlock	self unorderedList with: aBlock! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!variable	^ self tag: 'var'! !!WAHtmlCanvas methodsFor: 'html-generated' stamp: 'pmm 9/30/2006 20:06'!variable: aBlock	self variable with: aBlock! !!WAHtmlCanvas methodsFor: 'encoding' stamp: 'avi 2/17/2006 20:36'!withLineBreaks: aString	| stream |	stream _ aString readStream.	[stream atEnd] whileFalse:		[self text: stream nextLine.		stream atEnd ifFalse: [self break]]! !!WAHtmlCanvas methodsFor: 'encoding' stamp: 'avi 6/23/2006 10:16'!withLineBreaksAndUrls: aString	| stream |	aString ifNil: [^ self].	stream _ aString readStream.	[stream atEnd] whileFalse:		[self withUrls: stream nextLine.		stream atEnd ifFalse: [self break]]! !!WAHtmlCanvas methodsFor: 'encoding' stamp: 'avi 6/20/2006 15:43'!withUrls: aString	| stream url |	stream _ aString readStream.	[stream atEnd] whileFalse:		[self text: (stream upToAll: 'http://').		stream atEnd ifFalse:			[url _ 'http://', (stream upTo: $ ).			self anchor url: url; text: url.			self text: ' ']]! !!WARenderCanvas class methodsFor: 'as yet unclassified' stamp: 'avi 6/13/2004 00:59'!context: aRenderingContext callbacks: aCallbackStore	^ self basicNew initializeWithContext: aRenderingContext callbacks: aCallbackStore! !!WARenderCanvas methodsFor: 'form-buttons' stamp: 'lr 9/23/2005 18:07'!button	^ self brush: WAButtonTag new.! !!WARenderCanvas methodsFor: 'accessing' stamp: 'avi 6/13/2004 01:01'!callbacks	^ callbacks! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'avi 4/28/2005 14:01'!checkbox	^ self brush: WACheckboxTag new	! !!WARenderCanvas methodsFor: 'private' stamp: 'avi 7/5/2004 11:56'!close	self flush.! !!WARenderCanvas methodsFor: 'accessing' stamp: 'avi 6/13/2004 01:01'!context	^ context! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'mb 2/6/2006 10:09'!dateInput	^ self brush: WADateInput new! !!WARenderCanvas methodsFor: 'accessing' stamp: 'avi 6/13/2004 01:08'!document	^ self context document! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'avi 6/8/2005 21:49'!fileUpload	^ self brush: WAFileUploadTag new	! !!WARenderCanvas methodsFor: 'form-buttons' stamp: 'avi 1/9/2006 21:52'!form	^ self brush: WAFormTag new! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'lr 9/23/2005 18:09'!hiddenInput	^ self brush: WAHiddenInputTag new.! !!WARenderCanvas methodsFor: 'form-buttons' stamp: 'lr 9/14/2005 22:01'!imageButton	^ self brush: WAImageButtonTag new.! !!WARenderCanvas methodsFor: 'initialize-release' stamp: 'avi 6/13/2004 01:01'!initializeWithContext: aRenderingContext callbacks: aCallbackStore	context _ aRenderingContext.	callbacks _ aCallbackStore! !!WARenderCanvas methodsFor: 'public api' stamp: 'lr 3/28/2006 20:16'!nextId	^ 'id' , context advanceKey! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 3/17/2005 17:13'!option	^ self brush: WAOptionTag new.! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 3/17/2005 17:14'!option: aBlock	^ self option with: aBlock! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'lr 9/23/2005 18:09'!passwordInput	^ self brush: WAPasswordInputTag new.! !!WARenderCanvas methodsFor: 'public api' stamp: 'mb 3/31/2006 11:38'!peekNextId	^ 'id' , context nextKey! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 7/6/2005 10:45'!radioButton	^ self brush: WARadioButtonTag new.! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 7/6/2005 10:46'!radioButton: aBlock	^ self radioButton with: aBlock! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 7/6/2005 11:29'!radioGroup	^ WARadioGroup canvas: self! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 7/6/2005 10:44'!radioGroup: aBlock	^ aBlock value: self radioGroup! !!WARenderCanvas methodsFor: 'public api' stamp: 'avi 6/24/2004 14:00'!render: anObject	self flush.	anObject renderOn: self! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 3/17/2005 17:15'!select	^ self brush: WASelectTag new	! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'ac 3/22/2005 17:50'!textArea	^ self brush: WATextAreaTag new! !!WARenderCanvas methodsFor: 'form-elements' stamp: 'mb 2/6/2006 10:10'!timeInput	^ self brush: WATimeInput new! !!WAStaticHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 17:20'!document: aDocument	^ self basicNew initializeWithDocument: aDocument! !!WAStaticHtmlCanvas class methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 17:28'!root: anHtmlRoot	^ self document: (WAHtmlStreamDocument root: anHtmlRoot)! !!WAStaticHtmlCanvas methodsFor: 'accessing' stamp: 'avi 9/10/2005 17:20'!document	^ document! !!WAStaticHtmlCanvas methodsFor: 'accessing' stamp: 'ac 6/9/2006 12:42'!document: aDocument	document _ aDocument! !!WAStaticHtmlCanvas methodsFor: 'initialize-release' stamp: 'avi 9/10/2005 17:20'!initializeWithDocument: aDocument	document _ aDocument! !!WAStaticHtmlCanvas methodsFor: 'form-elements' stamp: 'ac 6/10/2006 18:52'!textArea	^ self brush: WATextAreaTag new! !!WAConditionalComment methodsFor: 'as yet unclassified' stamp: 'avi 11/1/2005 09:05'!end: aString	isStart _ false.	condition _ aString! !!WAConditionalComment methodsFor: 'as yet unclassified' stamp: 'avi 11/1/2005 09:05'!start: aString	isStart _ true.	condition _ aString! !!WAConditionalComment methodsFor: 'as yet unclassified' stamp: 'avi 11/1/2005 09:06'!writeOn: aStream	aStream nextPutAll: '<!!'.	isStart ifTrue: [aStream nextPutAll: '--'].	aStream nextPut: $[; nextPutAll: condition; nextPut: $].	isStart ifFalse: [aStream nextPutAll: '--'].	aStream nextPut: $>! !!WAConfiguration class methodsFor: 'instance creation' stamp: 'avi 1/30/2004 16:39'!new	^ self basicNew initialize! !!WAConfiguration class methodsFor: 'as yet unclassified' stamp: 'jf 2/9/2004 19:46'!readUserConfigurationsFrom: aStream	| ini |	ini _ INIFile readFrom: aStream.	self registeredConfigurationsDo:		[:config |		(ini includesSection: config name) ifTrue:			[config clear.			(ini section: config name) associationsDo:				[:assoc | assoc value ifNotNil:					[(config hasAttributeNamed: assoc key)						ifTrue: [config valueAt: assoc key put: assoc value]]]]]! !!WAConfiguration class methodsFor: 'as yet unclassified' stamp: 'jf 2/9/2004 19:20'!writeUserConfigurationsOn: aStream	| ini |	ini _ INIFile new.	self registry keysAndValuesDo:		[:key :value | (ini section: key) addAll: value localValues].	ini writeOn: aStream! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 2/5/2004 16:27'!addAncestorsTo: tempCollection linearization: linearCollection	(linearCollection includes: self)		ifTrue: [tempCollection do: [:ea | linearCollection add: ea before: self].				tempCollection removeAllSuchThat: [:ea | true]]		ifFalse: [tempCollection add: self.				self ancestors isEmpty					ifTrue: [linearCollection addAll: tempCollection.							tempCollection removeAllSuchThat: [:ea | true]]					ifFalse: [self ancestors do: [:ea | ea addAncestorsTo: tempCollection linearization: linearCollection]]]! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 2/5/2004 17:16'!allAncestors	| temp linear |	temp _ OrderedCollection new.	linear _ OrderedCollection new.	self addAncestorsTo: temp linearization: linear.	^ linear allButFirst asArray! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 2/5/2004 17:16'!allAncestorsDo: aBlock	self allAncestors do: aBlock! !!WAConfiguration methodsFor: 'attributes' stamp: 'avi 2/1/2004 14:53'!allAttributes	^ Array streamContents:		[:s | 		self withAllAncestorsDo: [:ea | s nextPutAll: ea attributes]]! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 3/24/2004 11:59'!allPotentialAncestors	^ #()! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 2/2/2004 14:43'!ancestors	^ #()! !!WAConfiguration methodsFor: 'attributes' stamp: 'avi 2/1/2004 14:54'!attributeNamed: aSymbol	^ self allAttributes		detect: [:ea | ea key = aSymbol]		ifNone: [self error: 'No attribute named ', aSymbol printString]! !!WAConfiguration methodsFor: 'attributes' stamp: 'jf 2/1/2004 17:34'!attributes	^ #()! !!WAConfiguration methodsFor: 'values' stamp: 'avi 1/30/2004 16:32'!attributesAndValuesDo: keyValueBlock	^ self allAttributes do:		[:ea |		keyValueBlock value: ea value: (self valueForAttribute: ea)]! !!WAConfiguration methodsFor: 'attributes' stamp: 'avi 2/5/2004 13:21'!groupedAttributes	| dict sorted |	dict _ Dictionary new.	sorted _ SortedCollection sortBlock: [:a :b | a key <= b key].	self allAttributes do:		[:ea |		(dict at: ea group ifAbsentPut: [SortedCollection sortBlock: [:a :b | a key <= b key]])			add: ea].	dict associationsDo:		[:assoc |		sorted add: assoc].	^ sorted		! !!WAConfiguration methodsFor: 'testing' stamp: 'avi 1/30/2004 16:21'!hasAttributeNamed: aSymbol	^ self allAttributes anySatisfy: [:ea | ea key = aSymbol]! !!WAConfiguration methodsFor: 'testing' stamp: 'kph 9/30/2006 01:45'!hasGroupNamed: aSymbol	^ self allAttributes anySatisfy: [:ea | ea group = aSymbol]! !!WAConfiguration methodsFor: 'testing' stamp: 'avi 2/3/2004 22:59'!hasLocalValueForAttribute: anAttribute	self localValueAt: anAttribute key ifAbsent: [^ false].	^ true! !!WAConfiguration methodsFor: 'testing' stamp: 'avi 3/23/2004 14:53'!hasMutableAncestry	^ false! !!WAConfiguration methodsFor: 'values' stamp: 'avi 3/23/2004 12:40'!inheritedValueAndSourceAt: aSymbol do: aBlock	self allAncestorsDo:		[:ea |		(ea localValueAt: aSymbol ifAbsent: [])			ifNotNilDo: [:val | ^ aBlock value: val value: ea]].	^ nil! !!WAConfiguration methodsFor: 'testing' stamp: 'jf 2/1/2004 18:03'!inheritsFrom: aConfiguration	^ self allAncestors anySatisfy: [:ea | ea = aConfiguration]		! !!WAConfiguration methodsFor: 'initializing' stamp: 'avi 2/2/2004 14:34'!initialize	! !!WAConfiguration methodsFor: 'values' stamp: 'avi 2/3/2004 22:58'!localValueAt: aSymbol ifAbsent: absentBlock	self subclassResponsibility! !!WAConfiguration methodsFor: 'values' stamp: 'avi 3/23/2004 12:40'!lookupValueAt: aSymbol	^ self inheritedValueAndSourceAt: aSymbol do: [:value :source | value]! !!WAConfiguration methodsFor: 'accessing' stamp: 'avi 3/24/2004 11:55'!name	^ self subclassResponsibility! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 3/23/2004 14:47'!potentialAncestors	^ self allPotentialAncestors reject: [:ea | ea = self or: [(self inheritsFrom: ea) or: [ea inheritsFrom: self]]]! !!WAConfiguration methodsFor: 'values' stamp: 'avi 2/3/2004 22:58'!valueAt: aSymbol	^ self localValueAt: aSymbol ifAbsent: [self lookupValueAt: aSymbol]! !!WAConfiguration methodsFor: 'values' stamp: 'avi 2/3/2004 22:59'!valueForAttribute: anAttribute	^ self valueAt: anAttribute key! !!WAConfiguration methodsFor: 'ancestry' stamp: 'avi 2/5/2004 16:28'!withAllAncestorsDo: aBlock	aBlock value: self.	^ self allAncestorsDo: aBlock! !!WAAuthConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:32'!ancestors	^ Array with: (WARenderLoopConfiguration new)! !!WAAuthConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 21:12'!attributes	^ Array		with: (WAStringAttribute key: #login group: #authentication)		with: (WAStringAttribute key: #password group: #authentication)		! !!WAAuthConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 21:07'!mainClass	^ WAAuthMain! !!WAGlobalConfiguration class methodsFor: 'as yet unclassified' stamp: 'avi 3/16/2006 23:39'!initialize	DeploymentMode ifNil: [self setDevelopmentMode]! !!WAGlobalConfiguration class methodsFor: 'as yet unclassified' stamp: 'avi 3/16/2006 23:35'!setDeploymentMode	DeploymentMode _ true! !!WAGlobalConfiguration class methodsFor: 'as yet unclassified' stamp: 'avi 3/16/2006 23:36'!setDevelopmentMode	DeploymentMode _ false! !!WAGlobalConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2005 13:00'!attributes	^ Array 		with: ((WAListAttribute key: #serverProtocol group: #server) options: #(http https))		with: (WAStringAttribute key: #serverHostname group: #server)		with: (WANumberAttribute key: #serverPort group: #server)		with: (WABooleanAttribute key: #deploymentMode)! !!WAGlobalConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/16/2006 23:35'!deploymentMode	^ DeploymentMode! !!WAGlobalConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 15:00'!serverPort	^ 80! !!WAGlobalConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 15:00'!serverProtocol	^ #http! !!WARenderLoopConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:33'!ancestors	^ Array with: (WASessionConfiguration new)! !!WARenderLoopConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 9/11/2005 14:30'!attributes	^ Array		with: ((WAListAttribute key: #rootComponent) options: self rootComponents)		with: (WAStringAttribute key: #resourceBaseUrl group: #server)! !!WARenderLoopConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 17:02'!errorHandler	^ WAWalkbackErrorHandler! !!WARenderLoopConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:24'!mainClass	^ WARenderLoopMain! !!WARenderLoopConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 19:09'!rootComponents	^ (WAComponent allSubclasses select: [:ea | ea canBeRoot]) asSortedCollection: [:a :b | a name <= b name]! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:33'!ancestors	^ Array with: WAGlobalConfiguration new! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/27/2005 17:57'!attributes	^ Array		with: (WANumberAttribute key: #sessionExpirySeconds)		with: ((WAListAttribute key: #sessionClass) options: self sessionClasses)		with: ((WAListAttribute key: #mainClass) options: self mainClasses)		with: ((WAListAttribute key: #errorHandler) options: self errorHandlerClasses)		with: (WABooleanAttribute key: #useSessionCookie)! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:10'!errorHandler	^ WASimpleErrorHandler! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 4/7/2004 13:59'!errorHandlerClasses	^ WAErrorHandler allSubclasses! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 12:20'!mainClasses	^ WAMain allSubclasses! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 15:05'!sessionClass	^ WASession! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 15:04'!sessionClasses	^ WASession withAllSubclasses! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 15:05'!sessionExpirySeconds	^ 600! !!WASessionConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/12/2005 21:42'!useSessionCookie	^ false! !!WASystemConfiguration class methodsFor: 'as yet unclassified' stamp: 'lr 5/3/2006 09:44'!instance	^ instance ifNil: [ instance _ self basicNew initialize ]! !!WASystemConfiguration class methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:33'!new	^ self instance! !!WASystemConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 14:01'!attributes	self subclassResponsibility ! !!WASystemConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 2/3/2004 23:00'!localValueAt: aSymbol ifAbsent: absentBlock	^ (self respondsTo: aSymbol)		ifTrue: [self perform: aSymbol]		ifFalse: [absentBlock value]! !!WASystemConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:31'!name	^ self class name! !!WAUserConfiguration class methodsFor: 'as yet unclassified' stamp: 'avi 11/17/2005 00:27'!initialize	self allInstances do: [:ea | ea instVarNamed: 'ancestors' put: (ea ancestors collect: [:c  | [c instVarNamed: 'parent'] ifError: [c]])] 	! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!addAncestor: aConfiguration	(self inheritsFrom: aConfiguration)		ifFalse: [ancestors add: aConfiguration]! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!allPotentialAncestors	^ WASystemConfiguration allSubclasses collect: [:ea | ea new]! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!ancestors	^ ancestors! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!clear	values _ Dictionary new.! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!clearValueForAttribute: anAttribute	values removeKey: anAttribute key ifAbsent: []! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!hasMutableAncestry	^ true! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!initialize	super initialize.	values _ Dictionary new.	ancestors _ OrderedCollection new.! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!localValueAt: aSymbol ifAbsent: errorBlock	^ values at: aSymbol ifAbsent: errorBlock! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!localValues	| dict |	dict _ Dictionary new.	self allAttributes do:		[:attr | (self localValueAt: attr key ifAbsent: [nil])			ifNotNilDo: [:value | dict at: attr key put: (attr stringForValue: value)]].			^ dict! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!localValues: aDictionary	self allAttributes do:		[:attr | (aDictionary at: attr key ifAbsent: [nil])			ifNotNilDo: [:string | self valueAt: attr key put: (attr valueFromString: string)]]! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!overrideAttribute: anAttribute	self takeValue: (self valueForAttribute: anAttribute) forAttribute: anAttribute! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 11/16/2005 23:39'!removeAncestor: aConfiguration	ancestors remove: aConfiguration ifAbsent: []! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 15:21'!takeValue: anObject forAttribute: anAttribute	^ anObject ifNotNil: [values at: anAttribute key put: anObject]! !!WAUserConfiguration methodsFor: 'as yet unclassified' stamp: 'avi 3/23/2004 14:51'!valueAt: aSymbol put: anObject	^ self takeValue: anObject forAttribute: (self attributeNamed: aSymbol)! !!WABooleanAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 12:11'!accept: aVisitor with: anObject	^ aVisitor visitBooleanAttribute: self with: anObject! !!WABooleanAttribute methodsFor: 'as yet unclassified' stamp: 'avi 4/26/2004 14:42'!valueFromString: aString	^ aString = 'true'		ifTrue: [true]		ifFalse: [aString = 'false'				 ifTrue: [false]				 ifFalse: [self error: 'Invalid value for boolean attribute']]! !!WAConfigurationAttribute class methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 13:15'!key: aSymbol	^ self key: aSymbol group: nil! !!WAConfigurationAttribute class methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 13:14'!key: keySymbol group: groupSymbol	^ self basicNew initializeWithKey: keySymbol group: groupSymbol! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/30/2004 17:12'!accept: aVisitor with: anObject	self subclassResponsibility ! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 13:21'!group	^ group ifNil: [#general]! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 13:14'!initializeWithKey: keySymbol group: groupSymbol	key _ keySymbol.	group _ groupSymbol! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/30/2004 16:40'!key	^ key! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'mbany 4/14/2005 12:28'!stringForValue: anObject	^ anObject displayString! !!WAConfigurationAttribute methodsFor: 'as yet unclassified' stamp: 'jf 2/8/2004 17:07'!valueFromString: aString	self subclassResponsibility ! !!WAListAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 12:13'!accept: aVisitor with: anObject	^ aVisitor visitListAttribute: self with: anObject! !!WAListAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 12:12'!options	^ options! !!WAListAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 12:11'!options: aCollection	options _ aCollection! !!WAListAttribute methodsFor: 'as yet unclassified' stamp: 'mbany 4/14/2005 12:29'!valueFromString: aString	^ self options		detect: [:ea | ea displayString = aString]		ifNone: [self error: 'No matching list option']! !!WANumberAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 12:13'!accept: aVisitor with: anObject	^ aVisitor visitNumberAttribute: self with: anObject! !!WANumberAttribute methodsFor: 'as yet unclassified' stamp: 'jf 2/8/2004 17:10'!valueFromString: aString	^ Number readFrom: aString! !!WAPasswordAttribute methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 21:02'!accept: aVisitor with: anObject	^ aVisitor visitPasswordAttribute: self with: anObject! !!WAStringAttribute methodsFor: 'as yet unclassified' stamp: 'avi 1/30/2004 17:12'!accept: aVisitor with: anObject	^ aVisitor visitStringAttribute: self with: anObject! !!WAStringAttribute methodsFor: 'as yet unclassified' stamp: 'lr 5/3/2006 09:56'!valueFromString: aString	^ aString isEmptyOrNil ifFalse: [ aString ]! !!WACookie class methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 22:59'!key: keyString value: valueString	^ self new		key: keyString;		value: valueString;		yourself! !!WACookie methodsFor: 'comparing' stamp: 'mb 10/10/2006 23:40'!= aCookie	^self class == aCookie class 		and: [self key = aCookie key		and: [self value = aCookie value		and: [self path = aCookie path		and: [self expiry = aCookie expiry]]]]! !!WACookie methodsFor: 'api' stamp: 'avi 5/18/2004 23:13'!expireIn: aDuration	self expiry: DateAndTime now + aDuration! !!WACookie methodsFor: 'accessing' stamp: 'avi 5/18/2004 22:53'!expiry	^ expiry! !!WACookie methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:22'!expiry: aDateTime	expiry := aDateTime asUTC! !!WACookie methodsFor: 'private' stamp: 'mbany 4/14/2005 12:18'!expiryString	^ String streamContents:		[:s |		s			nextPutAll: (expiry dayOfWeekName first: 3);			nextPutAll: ', ';			nextPutAll: expiry dayOfMonth displayString;			nextPut: $-;			nextPutAll: expiry monthName;			nextPut: $-;			nextPutAll: expiry year displayString;			space;			nextPutAll: expiry hour24 displayString;			nextPut: $:;			nextPutAll: expiry minute displayString; 			nextPut: $:;			nextPutAll: expiry second displayString;			nextPutAll: ' GMT']! !!WACookie methodsFor: 'comparing' stamp: 'mb 10/10/2006 23:41'!hash	^self key hash + self value hash + self path hash + self expiry hash! !!WACookie methodsFor: 'accessing' stamp: 'avi 5/18/2004 13:21'!key	^ key! !!WACookie methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:22'!key: aString	key := aString! !!WACookie methodsFor: 'accessing' stamp: 'avi 5/18/2004 22:53'!path	^ path ifNil: ['/']! !!WACookie methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:22'!path: aString	path := aString! !!WACookie methodsFor: 'accessing' stamp: 'avi 5/18/2004 13:21'!value	^ value! !!WACookie methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:22'!value: aString	value := aString! !!WACookie methodsFor: 'api' stamp: 'mb 2/27/2006 08:02'!valueWithExpiry	^ expiry		ifNil: [self value]		ifNotNil: [(self value ifNil: ['']), '; expires=', self expiryString]! !!WADebugErrorHandler methodsFor: 'as yet unclassified' stamp: 'lr 6/7/2006 10:06'!handleError: anError	SeasidePlatformSupport openDebuggerOn: anError! !!WAErrorHandler class methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 21:22'!handleError: anError	^ self new handleError: anError! !!WAErrorHandler class methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 21:23'!handleWarning: aWarning	^ self new handleWarning: aWarning! !!WAErrorHandler methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 16:54'!handleError: anError	anError pass! !!WAErrorHandler methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 16:54'!handleWarning: aWarning	self handleError: aWarning! !!WASimpleErrorHandler methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 16:16'!handleError: anError	WACurrentSession value returnResponse: (WAResponse internalError: anError)! !!WAWalkbackErrorHandler methodsFor: 'as yet unclassified' stamp: 'mb 1/13/2006 09:55'!handleError: anError	WARenderLoop new		call: (WAWalkback new exception: anError) 		withToolFrame: false.	SeasidePlatformSupport openDebuggerOn: anError.! !!WAWalkbackErrorHandler methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 19:07'!handleWarning: aWarning	WARenderLoop new call: (WAFormDialog new addMessage: aWarning messageText).	aWarning resume.! !!WAFile methodsFor: 'accessing' stamp: 'avi 4/28/2004 11:13'!contentType	^ contentType! !!WAFile methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:21'!contentType: aString	contentType := aString! !!WAFile methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:39'!contents	"Answer a ByteArray"	^ contents! !!WAFile methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:37'!contents: aByteArray	contents := aByteArray! !!WAFile methodsFor: 'accessing' stamp: 'ab 10/31/2002 10:39'!fileName	"compensate for windows explorer behavior"	^ ('#:\*' match: fileName)		ifTrue: [fileName copyAfterLast: $\]		ifFalse: [fileName]! !!WAFile methodsFor: 'accessing' stamp: 'mb 9/22/2006 12:21'!fileName: aString	fileName := aString! !!WAHtmlAttributes methodsFor: 'convenience' stamp: 'lr 9/30/2005 19:17'!addClass: aString	aString ifNotNil: [ self at: 'class' append: aString ].! !!WAHtmlAttributes methodsFor: 'private' stamp: 'pmm 9/12/2006 18:25'!addMeasurementStyle: aString withValue: aValue	| styleValue |	"Default measurement is px"	styleValue := aValue isNumber		ifTrue: [ aValue px ]		ifFalse: [ aValue displayString ].	self addStyle: aString , ': ' , styleValue.! !!WAHtmlAttributes methodsFor: 'convenience' stamp: 'lr 8/3/2006 13:20'!addScript: aString	aString ifNotNil: [ self at: 'script' append: aString separator: ';' ].! !!WAHtmlAttributes methodsFor: 'convenience' stamp: 'lr 8/3/2006 13:20'!addStyle: aString	aString ifNotNil: [ self at: 'style' append: aString separator: ';' ].! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:15'!align	"Deprecated in XHTML"	self deprecated.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:15'!align: aValue	"Deprecated in XHTML"	self deprecated.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:13'!alignBottom	"Deprecated in XHTML"	self deprecated.	self at: 'valign' put: 'bottom'! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:22'!alignCenter	"Deprecated in XHTML, substitute a style"	self addStyle: 'text-align: center'! !!WAHtmlAttributes methodsFor: 'private' stamp: 'avi 6/22/2005 01:55'!associations	^ self attributes associations! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'avi 9/10/2005 16:02'!at: keyString	^ (self at: keyString ifAbsent: [keyString -> nil]) value! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'ac 9/25/2005 18:11'!at: keyString append: aString	^ self at: keyString append: aString separator: ' '! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'mb 3/16/2006 23:48'!at: keyString append: aString separator: separatorString	aString ifNil: [^ self at: keyString].	^ self at: keyString put: 		(String streamContents:			[:stream |			self at: keyString ifPresent: 				[:s | stream nextPutAll: s; nextPutAll: separatorString].			stream nextPutAll: aString displayString])! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'ac 3/16/2005 11:49'!at: keyString ifAbsent: aBlock	^ self associations		detect: [:ea | ea key = keyString]		ifNone: aBlock! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'mb 3/16/2006 23:55'!at: keyString ifAbsentPut: errBlock	"What if errBlock evaluates to nil ?"	^ self at: keyString ifAbsent: [self attributes add: keyString -> errBlock value]! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'ac 9/25/2005 17:50'!at: keyString ifPresent: aBlock	^ aBlock value: (self at: keyString ifAbsent: [^ nil]) value! !!WAHtmlAttributes methodsFor: 'accessing' stamp: 'mb 3/16/2006 23:47'!at: keyString put: valueString	valueString ifNotNil: [self attributes at: keyString put: valueString]! !!WAHtmlAttributes methodsFor: 'private' stamp: 'avi 6/22/2005 01:49'!attributes	^ attributes ifNil: [attributes _ Dictionary new]! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:22'!background: aValue	"Deprecated in XHTML, substitute a style"	self addStyle: 'background-image: url(' , aValue displayString , ')'.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:23'!backgroundColor: aValue	"Deprecated in XHTML, substitute a style"	self addStyle: 'background-color: ' , aValue displayString.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:16'!bgcolor	"Deprecated in XHTML"	self deprecated.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:16'!bgcolor: aValue	"Deprecated in XHTML"	self deprecated.! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:26'!border: aValue	"Deprecated in XHTML, substitute a style"	| cssValue |	cssValue _ 'none'.	aValue displayString = '1' ifTrue: [cssValue := 'solid 1px black'].	aValue displayString = '2' ifTrue: [cssValue := 'solid 2px black'].	self addStyle: 'border: ' , cssValue.! !!WAHtmlAttributes methodsFor: 'dnu' stamp: 'ab 5/24/2003 00:42'!doesNotUnderstand: aMessage	| argCount |	argCount _ aMessage arguments size.	argCount = 0 ifTrue: [^ self at: aMessage selector put: true].	argCount = 1 ifTrue: [^ self at: aMessage selector allButLast put: aMessage argument].	^ super doesNotUnderstand: aMessage! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 4/3/2006 15:56'!height: aValue	"Deprecated in XHTML, substitute a style"	self addMeasurementStyle: 'height' withValue: aValue! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 2/9/2006 18:28'!noBorder	"Deprecated in XHTML, substitute a style"	self border: 0.! !!WAHtmlAttributes methodsFor: 'copying' stamp: 'lr 11/8/2005 21:58'!postCopy	super postCopy.	attributes := attributes copy.! !!WAHtmlAttributes methodsFor: 'javascript' stamp: 'avi 3/12/2004 17:25'!submitOnChange	self at: 'onChange' put: 'submit()'! !!WAHtmlAttributes methodsFor: 'javascript' stamp: 'avi 2/7/2004 02:18'!submitOnClick	self at: 'onClick' put: 'submit()'! !!WAHtmlAttributes methodsFor: 'deprecated' stamp: 'mb 4/3/2006 15:56'!width: aValue	"Deprecated in XHTML, substitute a style"	"((( WAHtmlAttributes new width: 12; height: 28; border: 1 )))"	self addMeasurementStyle: 'width' withValue: aValue! !!WAHtmlAttributes methodsFor: 'printing' stamp: 'lr 6/14/2006 07:59'!writeKey: aKey value: aValue on: aStream	aValue = false ifFalse: [		aStream nextPut: $ ; nextPutAll: aKey; nextPutAll: '="'.		aValue = true			ifFalse: [ WAAbstractHtmlBuilder encode: aValue to: aStream ]			ifTrue: [ aStream nextPutAll: aKey ].		aStream nextPut: $" ]! !!WAHtmlAttributes methodsFor: 'printing' stamp: 'lr 6/14/2006 08:17'!writeOn: aStream	attributes ifNil: [ ^ self ].	attributes keysAndValuesDo: [ :key :value |		self 			writeKey: key asLowercase 			value: value on: aStream ]! !!WAHtmlDocument class methodsFor: 'instance creation' stamp: 'mb 3/30/2006 12:32'!new	^ self root: self newRoot! !!WAHtmlDocument class methodsFor: 'instance creation' stamp: 'mb 3/30/2006 12:32'!newRoot	^ self rootClass new! !!WAHtmlDocument class methodsFor: 'instance creation' stamp: 'avi 6/18/2004 18:22'!root: anHtmlRoot	^ self basicNew initializeWithRoot: anHtmlRoot! !!WAHtmlDocument class methodsFor: 'instance creation' stamp: 'mb 3/30/2006 12:27'!rootClass	^ WAHtmlRoot! !!WAHtmlDocument methodsFor: 'public' stamp: 'avi 7/8/2004 00:02'!close! !!WAHtmlDocument methodsFor: 'public' stamp: 'avi 5/18/2004 13:29'!closeTag: aString	self subclassResponsibility! !!WAHtmlDocument methodsFor: 'public' stamp: 'lr 10/3/2006 09:10'!comment: aString	"Display aString as comment in the resulting HTML document, the default implementation doesn't bother rendering comments."! !!WAHtmlDocument methodsFor: 'initialization' stamp: 'avi 6/19/2004 18:04'!initializeWithRoot: aRoot	root := aRoot! !!WAHtmlDocument methodsFor: 'public' stamp: 'avi 5/18/2004 13:28'!openTag: aString attributes: anAttributes	self subclassResponsibility! !!WAHtmlDocument methodsFor: 'accessing' stamp: 'avi 6/18/2004 18:24'!root	^ root! !!WAHtmlDocument methodsFor: 'testing' stamp: 'lr 10/3/2006 08:54'!shouldPrintCloseTagFor: aString	^ (#('hr' 'br' 'input' 'img' 'link') includes: aString asString) not! !!WAHtmlDocument methodsFor: 'public' stamp: 'pmm 4/19/2006 17:44'!text: aString	self subclassResponsibility ! !!WAHtmlStreamDocument methodsFor: 'accessing' stamp: 'avi 7/8/2004 00:40'!bodyStream	state = #head ifTrue:		[state := #body.		root writeOn: stream].	^ stream! !!WAHtmlStreamDocument methodsFor: 'public' stamp: 'avi 7/8/2004 00:41'!close	self bodyStream nextPutAll: '</body></html>'! !!WAHtmlStreamDocument methodsFor: 'public' stamp: 'avi 7/8/2004 00:39'!closeTag: aString	self writeCloseTag: aString on: self bodyStream! !!WAHtmlStreamDocument methodsFor: 'initialization' stamp: 'avi 7/8/2004 00:38'!initializeWithRoot: anHtmlRoot	super initializeWithRoot: anHtmlRoot.	stream := String new writeStream.	state := #head! !!WAHtmlStreamDocument methodsFor: 'public' stamp: 'avi 7/8/2004 00:39'!openTag: aString attributes: anAttributes	self writeOpenTag: aString attributes: anAttributes on: self bodyStream! !!WAHtmlStreamDocument methodsFor: 'accessing' stamp: 'avi 7/8/2004 00:39'!stream	^ stream! !!WAHtmlStreamDocument methodsFor: 'accessing' stamp: 'avi 7/8/2004 00:38'!stream: aStream	stream := aStream! !!WAHtmlStreamDocument methodsFor: 'public' stamp: 'mb 3/13/2006 15:48'!text: aString	self bodyStream nextPutAll: aString displayString! !!WAHtmlStreamDocument methodsFor: 'private' stamp: 'avi 5/18/2004 13:52'!writeCloseTag: aString on: aStream	(self shouldPrintCloseTagFor: aString)		ifTrue: [aStream nextPutAll: '</'; nextPutAll: aString; nextPut: $>]! !!WAHtmlStreamDocument methodsFor: 'private' stamp: 'avi 6/13/2004 01:04'!writeOpenTag: aString attributes: anAttributes on: aStream	aStream		nextPut: $<;		nextPutAll: aString.	anAttributes ifNotNil: [anAttributes writeOn: aStream].	(self shouldPrintCloseTagFor: aString) ifFalse: [aStream nextPutAll: ' /'].	aStream nextPut: $>! !!WAHtmlTreeDocument methodsFor: 'stack operations' stamp: 'ab 2/12/2003 21:46'!addElement: anObject	stack last add: anObject! !!WAHtmlTreeDocument methodsFor: 'accessing' stamp: 'ac 6/9/2006 12:36'!body	^ body! !!WAHtmlTreeDocument methodsFor: 'markup' stamp: 'avi 11/20/2003 18:36'!closeTag: aString	self popElement name = aString ifFalse: [self error: 'Mismatched tags']! !!WAHtmlTreeDocument methodsFor: 'accessing' stamp: 'avi 6/18/2004 18:31'!initializeWithRoot: anHtmlRoot	super initializeWithRoot: anHtmlRoot.	body _ WAHtmlElement named: 'body'.	stack _ OrderedCollection with: body! !!WAHtmlTreeDocument methodsFor: 'markup' stamp: 'avi 5/18/2004 13:51'!openTag: aString attributes: anAttributes	| element |	element _ WAHtmlElement named: aString attributes: anAttributes.	(self shouldPrintCloseTagFor: aString)		ifTrue: [element beClosed]		ifFalse: [element notClosed].	self pushElement: element! !!WAHtmlTreeDocument methodsFor: 'stack operations' stamp: 'avi 11/20/2003 18:36'!popElement	^ stack removeLast! !!WAHtmlTreeDocument methodsFor: 'stack operations' stamp: 'ab 2/12/2003 21:57'!pushElement: anObject	self addElement: anObject.	stack add: anObject.! !!WAHtmlTreeDocument methodsFor: 'markup' stamp: 'avi 11/20/2003 18:50'!text: aString	self addElement: aString! !!WAHtmlTreeDocument methodsFor: 'stack operations' stamp: 'ab 2/12/2003 21:58'!withElement: anElement do: aBlock	self pushElement: anElement.	aBlock value.	self popElement.! !!WAHtmlTreeDocument methodsFor: 'as yet unclassified' stamp: 'avi 6/18/2004 18:35'!writeBodyOn: aStream	body childrenDo: [:ea | ea writeOn: aStream]! !!WAHtmlTreeDocument methodsFor: 'as yet unclassified' stamp: 'avi 7/8/2004 00:37'!writeOn: aStream	root writeOn: aStream.	self writeBodyOn: aStream.	aStream nextPutAll: '</body></html>'! !!WAPrettyPrintedDocument class methodsFor: 'as yet unclassified' stamp: 'avi 5/22/2004 12:40'!renderer: aRenderer	^ self basicNew initializeWithRenderer: aRenderer! !!WAPrettyPrintedDocument methodsFor: 'private' stamp: 'mb 10/3/2006 11:02'!attribute: anAssociation	| attr value |	attr := anAssociation key asLowercase.	value := anAssociation value.		value = false ifFalse:		[html space.		html spanClass: (self cssClassForAttribute: attr) with:			[html text: attr].		html text: '='.		html spanClass: 'attribute-value' with:			[html text: '"'.			attr = 'href'				ifTrue: [value ifNotNil: [html anchorWithUrl: value do: value displayString]]				ifFalse:					[value = true						ifFalse: [html text: value displayString]						ifTrue: [html text: attr]].			html text: '"']]! !!WAPrettyPrintedDocument methodsFor: 'private' stamp: 'avi 6/19/2004 21:07'!attributes: anAttributes	anAttributes ifNotNil: [anAttributes associations do: [:ea | self attribute: ea]]! !!WAPrettyPrintedDocument methodsFor: 'public' stamp: 'mb 10/3/2006 11:04'!closeTag: aString	indentLevel := indentLevel - 1.	indentCloseTags removeLast 		ifTrue: [ self indent ].	(self shouldPrintCloseTagFor: aString) ifTrue:		[html text: '</'.		html spanClass: (self cssClassFor: aString) with: aString.		html text: '>']! !!WAPrettyPrintedDocument methodsFor: 'public' stamp: 'mb 10/3/2006 10:58'!comment: aString	self indent.	html spanClass: 'comment'		with: [ html text: '<!!-- '; text: aString; text: ' -->' ]! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'lr 10/3/2006 08:59'!cssClassFor: aString	^ (self isKnownTag: aString)		ifTrue: [ 'tag-known' ]		ifFalse: [ 'tag-unknown' ]! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'lr 10/3/2006 08:59'!cssClassForAttribute: aString	^ (self isKnownAttribute: aString)		ifTrue: [ 'attribute-known' ]		ifFalse: [ 'attribute-unknown' ]! !!WAPrettyPrintedDocument methodsFor: 'private' stamp: 'lr 10/3/2006 09:11'!indent	html break.	indentLevel timesRepeat: [ html space ]! !!WAPrettyPrintedDocument methodsFor: 'initialization' stamp: 'avi 6/3/2004 19:25'!initializeWithRenderer: aRenderer	html := aRenderer.	indentCloseTags := OrderedCollection with: false.	indentLevel := 0! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'avi 4/2/2005 22:20'!isKnownAttribute: aString	^ self knownAttributes includes: aString asLowercase asSymbol! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'avi 4/2/2005 22:20'!isKnownTag: aString	^ self knownTags includes: aString asSymbol! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'avi 5/22/2004 12:40'!knownAttributes	^ #(abbraccept-charsetacceptaccesskeyactionalignalinkaltarchiveaxisbackgroundbgcolorbgpropertiesbordercellpaddingcellspacingcharcharoffcharsetcheckedciteclassclassidclearcodecodebasecodetypecolorcolscolspancompactcontentcoordsdatadatetimedeclaredeferdirdirectiondisabledencodingenctypefaceforframeframeborderframespacinggutterheadersheighthrefhreflanghspacehttp-equividismaplabellangleftmarginlinklongdesclooplowsrcmarginheightmarginwidthmaxlengthmediamethodmethodsmultiplenamenohrefnoresizenoshadenowrapobjectonabortonbluronchangeonclickondblclickonerroronfocusonkeydownonkeypressonkeyuponloadonmousedownonmousemoveonmouseoutonmouseoveronmouseuponresetonselectonsubmitonunloadpromptPUBLICreadonlyrelrevrowsrowspanrulesschemescopescrollingselectedshapesizespansrcstandbystylesummarytabindextargettexttitletypeurnusemapvalignvaluevaluetypeversionvlinkvspacewidthwrapxml:langxmlns)! !!WAPrettyPrintedDocument methodsFor: 'testing' stamp: 'avi 5/22/2004 12:40'!knownTags	^ #(?xml!!doctype!!dtaabbracronymaddressappletareaattachbbasebasefontbdobigblinkblockquotebodybrbuttoncaptioncentercitecodecolcolgroupcommentcomponentdddeldfndirdivdldtemfieldsetfontformframeframesethh1h2h3h4h5h6headhrhtmliiframeimginputinsisindexkbdlabellegendlilinklistingmapmenumetamulticolnextidnobrnoframesnoscriptobjectoloptgroupoptionpparamplaintextpreqssampscriptselectsmallspanstrikestrongstylesubsuptabletbodytdtextareatextflowtfootththeadtitletrttuulvarwbrxmp)! !!WAPrettyPrintedDocument methodsFor: 'public' stamp: 'mb 10/3/2006 10:58'!openTag: aString attributes: anAttributes	self indent.		html text: '<'.	html spanClass: (self cssClassFor: aString) with: [html text: aString].		self attributes: anAttributes.		(self shouldPrintCloseTagFor: aString)		ifFalse: [html space; text: '/'].	html text: '>'.		indentLevel := indentLevel + 1.	indentCloseTags removeLast; addLast: true; addLast: false.! !!WAPrettyPrintedDocument methodsFor: 'accessing' stamp: 'ac 9/23/2005 22:08'!root	^ html context document root! !!WAPrettyPrintedDocument methodsFor: 'public' stamp: 'lr 10/3/2006 08:55'!text: aString	html text: aString! !!WAStyleCollector methodsFor: 'as yet unclassified' stamp: 'avi 7/2/2004 11:03'!closeTag: aString! !!WAStyleCollector methodsFor: 'as yet unclassified' stamp: 'avi 7/5/2004 11:52'!openTag: aString attributes: anAttributes	anAttributes ifNil: [^ self].	anAttributes associations do:		[:assoc |		assoc key = 'class' ifTrue:			[self styles addAll: ((assoc value findTokens: ' ') collect: [:ea | '.', ea])].		assoc key = 'id' ifTrue: [self styles add: '#', assoc value]]! !!WAStyleCollector methodsFor: 'as yet unclassified' stamp: 'avi 7/2/2004 11:05'!styles	^ styles ifNil: [styles _ Set new]! !!WAStyleCollector methodsFor: 'as yet unclassified' stamp: 'avi 7/2/2004 11:03'!text: aString! !!WAHtmlElement class methodsFor: 'as yet unclassified' stamp: 'ab 5/12/2003 11:17'!named: aString	^ self named: aString attributes: (WAHtmlAttributes new)! !!WAHtmlElement class methodsFor: 'as yet unclassified' stamp: 'ab 5/12/2003 11:17'!named: aString attributes: anAttributes	^ self new initializeWithName: aString attributes: anAttributes! !!WAHtmlElement methodsFor: 'commands' stamp: 'ab 1/11/2003 13:47'!add: anElement	children ifNil: [children _ OrderedCollection new].	children add: anElement.! !!WAHtmlElement methodsFor: 'accessing' stamp: 'rjl 8/4/2006 11:36'!attributeAt: aString    ^attributes at: aString! !!WAHtmlElement methodsFor: 'accessing' stamp: 'ab 5/12/2003 11:14'!attributeAt: aString put: anObject	attributes at: aString put: anObject! !!WAHtmlElement methodsFor: 'accessing' stamp: 'avi 5/18/2004 13:49'!beClosed	isClosed _ true! !!WAHtmlElement methodsFor: 'commands' stamp: 'ab 3/29/2003 00:10'!childrenDo: aBlock	children ifNotNil: [children do: aBlock]! !!WAHtmlElement methodsFor: 'initialize-release' stamp: 'avi 5/18/2004 13:49'!initializeWithName: aString attributes: anAttributes	name _ aString.	attributes _ anAttributes.	isClosed _ true.! !!WAHtmlElement methodsFor: 'accessing' stamp: 'JF 6/11/2003 14:47'!name	^ name asLowercase! !!WAHtmlElement methodsFor: 'accessing' stamp: 'pmm 9/20/2006 20:47'!notClosed	isClosed := false! !!WAHtmlElement methodsFor: 'as yet unclassified' stamp: 'ac 6/9/2006 12:58'!prettyPrintHtmlOn: aStream	self prettyPrintHtmlOn: aStream indentLevel: 0.! !!WAHtmlElement methodsFor: 'as yet unclassified' stamp: 'ac 6/9/2006 13:00'!prettyPrintHtmlOn: aStream indentLevel: anInteger	aStream cr.	anInteger timesRepeat: [aStream tab].	self printOpenTagOn: aStream.	self childrenDo: [:ea | ea prettyPrintHtmlOn: aStream indentLevel: anInteger + 1].	self shouldPrintCloseTag ifTrue: [self printCloseTagOn: aStream].! !!WAHtmlElement methodsFor: 'printing' stamp: 'JF 6/11/2003 14:44'!printCloseTagOn: aStream 	aStream		nextPutAll: '</';		nextPutAll: self name;		nextPut: $>! !!WAHtmlElement methodsFor: 'printing' stamp: 'avi 5/22/2004 15:17'!printHtmlOn: aStream	self printOpenTagOn: aStream.	self childrenDo: [:ea | ea writeOn: aStream].	self shouldPrintCloseTag ifTrue: [self printCloseTagOn: aStream].! !!WAHtmlElement methodsFor: 'printing' stamp: 'avi 6/19/2004 18:07'!printOpenTagOn: aStream 	aStream		nextPut: $<;		nextPutAll: self name.	attributes ifNotNil: [attributes writeOn: aStream].	self shouldPrintCloseTag ifFalse: [aStream nextPutAll: ' /'].	aStream nextPut: $>! !!WAHtmlElement methodsFor: 'accessing' stamp: 'avi 5/18/2004 13:51'!shouldPrintCloseTag	^ isClosed! !!WAHtmlElement methodsFor: 'commands' stamp: 'avi 6/19/2004 18:10'!writeOn: aStream	self printOpenTagOn: aStream.	self childrenDo: [:ea | ea isString ifTrue: [aStream nextPutAll: ea] ifFalse: [ea writeOn: aStream]].	self shouldPrintCloseTag ifTrue: [self printCloseTagOn: aStream].! !!WAHtmlRoot class methodsFor: 'as yet unclassified' stamp: 'avi 6/19/2004 18:05'!new	^ self basicNew initialize! !!WAHtmlRoot methodsFor: 'api' stamp: 'avi 9/11/2005 14:39'!absoluteUrlForResource: aString	(aString beginsWith: 'http') ifTrue: [^ aString].	resourceBaseUrl ifNil: [^ aString].	^ resourceBaseUrl, aString! !!WAHtmlRoot methodsFor: 'api' stamp: 'avi 6/18/2004 17:01'!addHeadElement: anHtmlElement	headElements add: anHtmlElement! !!WAHtmlRoot methodsFor: 'initialize-release' stamp: 'mb 2/9/2006 18:45'!addHtmlNameSpace	htmlAttrs		at: 'xmlns' put: 'http://www.w3.org/1999/xhtml';		at: 'xml:lang' put: 'en';		at: 'lang' put: 'en'.! !!WAHtmlRoot methodsFor: 'initialize-release' stamp: 'mb 6/14/2006 13:03'!addMetaContentType	self addHeadElement:		((WAHtmlElement named: 'meta')				attributeAt: 'http-equiv' put: 'Content-Type';				attributeAt: 'content'  put: self contentType , '; charset=' , self charSet;				notClosed;				yourself).! !!WAHtmlRoot methodsFor: 'javascript' stamp: 'avi 6/18/2004 17:02'!addScript: aString	(scripts includes: aString) ifFalse: [scripts add: aString]! !!WAHtmlRoot methodsFor: 'css' stamp: 'avi 6/18/2004 17:02'!addStyle: aString	(styles includes: aString) ifFalse: [styles add: aString]! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:56'!bodyAttributes	^ bodyAttrs! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'mb 2/9/2006 18:48'!charSet	^'utf-8'! !!WAHtmlRoot methodsFor: 'api' stamp: 'avi 9/11/2005 14:09'!contentBase: urlString	self addHeadElement:		((WAHtmlElement named: 'base')				attributeAt: 'href' put: urlString;				yourself)! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'mb 3/30/2006 12:28'!contentType	^'text/html'! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:53'!docType	^ docType! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'mb 9/21/2006 17:06'!docType: aString	docType := aString! !!WAHtmlRoot methodsFor: 'api' stamp: 'avi 11/1/2005 09:07'!forIE5Do: aBlock	self addHeadElement: (WAConditionalComment new start: 'if gte IE 5').	aBlock value.	self addHeadElement: (WAConditionalComment new end: 'endif').! !!WAHtmlRoot methodsFor: 'api' stamp: 'gk 1/9/2006 17:28'!forIE6Do: aBlock	self addHeadElement: (WAConditionalComment new start: 'if IE 6').	aBlock value.	self addHeadElement: (WAConditionalComment new end: 'endif').! !!WAHtmlRoot methodsFor: 'api' stamp: 'pmm 10/15/2006 12:18'!forIE7Do: aBlock	self addHeadElement: (WAConditionalComment new start: 'if IE 7').	aBlock value.	self addHeadElement: (WAConditionalComment new end: 'endif').! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:57'!headAttributes	^ headAttrs! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:54'!htmlAttributes	^ htmlAttrs! !!WAHtmlRoot methodsFor: 'initialize-release' stamp: 'mb 9/21/2006 17:12'!initialize	htmlAttrs := WAHtmlAttributes new.	headAttrs := WAHtmlAttributes new.	bodyAttrs := WAHtmlAttributes new.	headElements := OrderedCollection new.	scripts := OrderedCollection new.	styles := OrderedCollection new.	docType := '<!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'.	title := 'Seaside'.	self addHtmlNameSpace.	self addMetaContentType.! !!WAHtmlRoot methodsFor: 'javascript' stamp: 'rjl 8/4/2006 11:40'!linkToScript: url 	"only link to script if it's not already been linked too, necessary when lists of child components try to link to dependant scripts, a google map for example"	| fullUrl |	fullUrl := self absoluteUrlForResource: url asString.	headElements 		detect: [:each | each name = 'script' and: [(each attributeAt: #src) = fullUrl]]		ifNone: [self addHeadElement: (self scriptElementWithSrc: fullUrl)]! !!WAHtmlRoot methodsFor: 'css' stamp: 'mb 6/14/2006 13:16'!linkToStyle: url	self addHeadElement:		(self styleElementWithHref: (self absoluteUrlForResource: url asString))! !!WAHtmlRoot methodsFor: 'css' stamp: 'pmm 9/20/2006 21:08'!linkToStyle: url titled: aString	self addHeadElement:		(self			styleElementWithHref: (self absoluteUrlForResource: url asString)			titled: aString)! !!WAHtmlRoot methodsFor: 'css' stamp: 'mb 9/21/2006 17:00'!linkToStyle: url titled: aString media: aMediaString	self addHeadElement:		(self			styleElementWithHref: (self absoluteUrlForResource: url asString)			titled: aString			media: aMediaString)! !!WAHtmlRoot methodsFor: 'api' stamp: 'mb 6/14/2006 12:38'!redirectTo: locationString delay: aNumber	self addHeadElement:		((WAHtmlElement named: 'meta')				attributeAt: 'http-equiv' put: 'refresh';				attributeAt: 'content' put: aNumber displayString , ';URL=' , locationString;				yourself).! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 9/11/2005 14:39'!resourceBaseUrl	^ resourceBaseUrl! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 9/11/2005 14:38'!resourceBaseUrl: aString	resourceBaseUrl _ aString! !!WAHtmlRoot methodsFor: 'javascript' stamp: 'mb 9/21/2006 17:07'!scriptElementWithSrc: aString	^(WAHtmlElement named: 'script')		attributeAt: 'src' put: aString;		attributeAt: 'type' put: 'text/javascript';		yourself! !!WAHtmlRoot methodsFor: 'css' stamp: 'mb 9/21/2006 17:07'!styleElementWithHref: aString	^(WAHtmlElement named: 'link')		attributeAt: 'href' put: aString;		attributeAt: 'rel' put: 'stylesheet';		attributeAt: 'type' put: 'text/css';		notClosed;		yourself! !!WAHtmlRoot methodsFor: 'css' stamp: 'pmm 9/20/2006 20:58'!styleElementWithHref: anUrlString titled: aTitleString	^(self styleElementWithHref: anUrlString)		attributeAt: 'title' put: aTitleString;		yourself! !!WAHtmlRoot methodsFor: 'css' stamp: 'pmm 9/20/2006 20:58'!styleElementWithHref: anUrlString titled: aTitleString media: aMediaString	^(self styleElementWithHref: anUrlString titled: aTitleString)		attributeAt: 'media' put: aMediaString;		yourself! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:53'!title	^ title! !!WAHtmlRoot methodsFor: 'accessing' stamp: 'avi 6/17/2004 15:54'!title: aString	title _ aString! !!WAHtmlRoot methodsFor: 'writing' stamp: 'mb 2/10/2006 11:26'!writeHeadOn: aStream	aStream nextPutAll: '<title>', title, '</title>'.	headElements do: [:ea | ea writeOn: aStream].	styles do: [:ea | self writeStyle: ea on: aStream].	scripts do: [:ea | self writeScript: ea on: aStream].! !!WAHtmlRoot methodsFor: 'writing' stamp: 'avi 7/5/2004 11:45'!writeOn: aStream	aStream nextPutAll: docType.	aStream nextPutAll: '<html'.	htmlAttrs writeOn: aStream.	aStream nextPutAll: '><head'.	headAttrs writeOn: aStream.	aStream nextPutAll: '>'.	self writeHeadOn: aStream. 	aStream nextPutAll: '</head><body'.	bodyAttrs writeOn: aStream.	aStream nextPutAll: '>'.! !!WAHtmlRoot methodsFor: 'writing' stamp: 'avi 1/22/2005 22:00'!writeScript: aString on: aStream	aStream		nextPutAll: '<script type="text/javascript">';		nextPutAll: aString;		nextPutAll: '</script>'! !!WAHtmlRoot methodsFor: 'writing' stamp: 'avi 6/18/2004 18:37'!writeStyle: aString on: aStream	aStream		nextPutAll: '<style>';		nextPutAll: aString;		nextPutAll: '</style>'! !!WARenderedHtmlRoot class methodsFor: 'as yet unclassified' stamp: 'avi 6/24/2004 01:21'!context: aRenderingContext	^ self basicNew initializeWithContext: aRenderingContext! !!WARenderedHtmlRoot methodsFor: 'accessing' stamp: 'avi 3/27/2005 20:29'!context	^ context! !!WARenderedHtmlRoot methodsFor: 'initialize-release' stamp: 'mb 9/21/2006 17:15'!initializeWithContext: aRenderingContext	context := aRenderingContext.	self initialize.! !!WARenderedHtmlRoot methodsFor: 'javascript' stamp: 'mb 6/14/2006 13:29'!linkWithScript: aString	^ self linkToScript: (context urlForDocument: aString mimeType: 'text/javascript')! !!WARenderedHtmlRoot methodsFor: 'css' stamp: 'mb 6/14/2006 13:11'!linkWithStyle: aString	^ self linkToStyle: (context urlForDocument: aString mimeType: 'text/css')! !!WARenderedHtmlRoot methodsFor: 'css' stamp: 'mb 9/21/2006 17:04'!linkWithStyle: aString titled: aTitleString	^ self		linkToStyle: (context urlForDocument: aString mimeType: 'text/css')		titled: aString! !!WARenderedHtmlRoot methodsFor: 'css' stamp: 'mb 9/21/2006 17:03'!linkWithStyle: aString titled: aTitleString media: aMediaString	^ self		linkToStyle: (context urlForDocument: aString mimeType: 'text/css')		titled: aString		media: aMediaString! !!WARenderedHtmlRoot methodsFor: 'writing' stamp: 'mb 6/14/2006 13:20'!writeScript: aString on: aStream	(self scriptElementWithSrc: (context urlForDocument: aString mimeType: 'text/javascript'))		writeOn: aStream! !!WARenderedHtmlRoot methodsFor: 'writing' stamp: 'mb 6/14/2006 13:21'!writeStyle: aString on: aStream	(self styleElementWithHref: (context urlForDocument: aString mimeType: 'text/css'))		writeOn: aStream! !!WAKom commentStamp: 'pmm 10/14/2006 14:34' prior: 0!I provide an adapter between Seaside and the Comanche web server. To start a new server on port 8080, evaluate	WAKom startOn: 8080.	and to stop it, evaluate	WAKom stop.I don't work on Squeak 3.9 for non-ASCII characters.	The state of the service (running or stopped) is automatically restored when quitting and reopening an image.If you want to reset the password of the config application (reachable at /seaside/config) evaluate	WADispatcherEditor initialize.!!WAKom class methodsFor: 'service' stamp: 'avi 4/2/2005 22:18'!createService   Smalltalk at: #HttpService ifPresent:       [:hs |       ^ (hs on: port named: 'seaside') plug: self default].   Smalltalk at: #ComancheNetService ifPresent:       [:cns |       ^ (cns named: 'seaside' onPort: port) module: self default].   self error: 'Comanche is not installed.  Install Comanche fromSqueakMap and try again.'! !!WAKom class methodsFor: 'accessing' stamp: 'avi 1/14/2004 22:44'!default	^ self entryPoint: WADispatcher default! !!WAKom class methodsFor: 'as yet unclassified' stamp: 'avi 11/20/2003 01:13'!entryComponent: aClass path: aString	^ self dispatcher: (aClass applicationWithPath: aString)! !!WAKom class methodsFor: 'as yet unclassified' stamp: 'avi 11/20/2003 01:13'!entryPoint: anEntryPoint	^ self new entryPoint: anEntryPoint! !!WAKom class methodsFor: 'service' stamp: 'ab 10/10/2002 11:42'!initialize		Smalltalk addToStartUpList: self after: AutoStart.		Smalltalk addToShutDownList: self! !!WAKom class methodsFor: 'service' stamp: 'avi 9/26/2003 23:52'!pause	service ifNotNil:		[service unregister.		service := nil]! !!WAKom class methodsFor: 'accessing' stamp: 'avi 10/6/2005 21:26'!port	^ port! !!WAKom class methodsFor: 'service' stamp: 'ac 12/2/2003 12:32'!setDebugMode	service setDebugMode.! !!WAKom class methodsFor: 'service' stamp: 'ac 12/2/2003 12:33'!setDeploymentMode	service setDeploymentMode.! !!WAKom class methodsFor: 'service' stamp: 'ac 12/2/2003 12:32'!setVerboseMode	service setVerboseMode.! !!WAKom class methodsFor: 'service' stamp: 'avi 10/30/2005 16:40'!shutDown	self pause! !!WAKom class methodsFor: 'service' stamp: 'avi 9/26/2003 23:52'!startOn: aPort	self stop.	port := aPort.	service := self createService.	service start.! !!WAKom class methodsFor: 'service' stamp: 'avi 10/7/2005 16:23'!startUp	port := (SmalltalkImage current extractParameters at: 'PORT' ifAbsent: [port]).	port ifNotNil: [self startOn: port asNumber]! !!WAKom class methodsFor: 'service' stamp: 'ab 10/10/2002 11:41'!stop	self pause.	port := nil.! !!WAKom methodsFor: 'private' stamp: 'pmm 10/14/2006 14:28'!contentsOfResponse: aResponse	^aResponse contents! !!WAKom methodsFor: 'converting' stamp: 'pmm 10/14/2006 14:24'!convertRequest: aKomRequest	| request |	self processMultipartFields: aKomRequest.	request := WARequest		method: aKomRequest method		url: aKomRequest url unescapePercents 		headers: aKomRequest header		fields: (self fieldsOf: aKomRequest)		cookies: aKomRequest cookies		nativeRequest: aKomRequest.	aKomRequest method = 'PUT'		ifTrue: [request fields					at: 'PUTData'					put: (aKomRequest stream next: aKomRequest contentLength)].	^ request! !!WAKom methodsFor: 'converting' stamp: 'pmm 10/14/2006 14:30'!convertResponse: aResponse	| komResponse |	aResponse ifNil: [^ HttpResponse fromString: 'Request handling aborted; reload to retry'].	komResponse :=  HttpResponse new.	aResponse cookies do:		[:assoc | komResponse setCookieName: assoc key value: assoc valueWithExpiry path: assoc path].			aResponse headers associationsDo: [:assoc | komResponse fieldAt: assoc key put: assoc value].	(HttpResponse classPool at: #StatusCodes) associationsDo:		[:assoc |		assoc value key = aResponse status ifTrue: [komResponse status: assoc key]].	komResponse contents: (self contentsOfResponse: aResponse).	komResponse contentType: aResponse contentType.	^ komResponse! !!WAKom methodsFor: 'as yet unclassified' stamp: 'avi 11/20/2003 01:13'!entryPoint: anEntryPoint	entryPoint := anEntryPoint! !!WAKom methodsFor: 'private' stamp: 'pmm 10/14/2006 14:23'!fieldsOf: aKomRequest	^aKomRequest method = 'POST'		ifTrue: [ aKomRequest postFields ]		ifFalse: [ aKomRequest getFields ]! !!WAKom methodsFor: 'as yet unclassified' stamp: 'cwp 3/26/2004 23:03'!handleRequest: aRequest	^ (entryPoint handlerForRequest: aRequest) handleRequest: aRequest! !!WAKom methodsFor: 'as yet unclassified' stamp: 'avi 11/20/2003 00:43'!log: aRequest	Transcript cr; show: aRequest url! !!WAKom methodsFor: 'as yet unclassified' stamp: 'avi 11/28/2005 00:22'!process: komRequest	|request response komResponse |	^ WAReadWriteLock global read:		[self log: komRequest.		request := self convertRequest: komRequest.		response := self handleRequest: request.		komResponse := self convertResponse: response.		response release.		komResponse]! !!WAKom methodsFor: 'kom 6.1' stamp: 'ab 5/18/2003 13:53'!processHttp	HttpResponse current: (self process: HttpRequest current).	^ true! !!WAKom methodsFor: 'kom 6.1' stamp: 'ab 5/18/2003 11:24'!processHttpRequest: aRequest	^ self process: aRequest! !!WAKom methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 15:25'!processMultipartFields: aRequest	aRequest multipartFormFieldsDo:		[:chunk |		chunk fileName isEmptyOrNil ifFalse:			[|stream file|			stream := WriteStream on: String new.			chunk saveToStream: stream.			file := WAFile new				fileName: chunk fileName;				contents: stream contents;				contentType: chunk contentType;				yourself.			aRequest postFields at: chunk fieldName put: file]].! !!WAKom methodsFor: 'kom 6.1' stamp: 'ab 5/18/2003 14:11'!validateForStack: anArray! !!WAKomEncoded39 commentStamp: 'pmm 10/14/2006 14:34' prior: 0!I have the same resposibility like WAKomEncoded except that I'm for Squeak 3.9.!!WAKomEncoded commentStamp: 'pmm 10/14/2006 14:11' prior: 0!I provide an adapter between Seaside and the Comanche web server with response/request conversion from UTF-8 to WideString and back in Squeak 3.8.see WAKom!!WAKomEncoded methodsFor: 'private' stamp: 'pmm 10/14/2006 14:36'!fieldsOf: aKomRequest	^(super fieldsOf: aKomRequest) associationsDo: [ :association |		(association value isKindOf: OrderedCollection) ifTrue: [			association value: (association value collect: [ :s |			| multiString |				multiString := (MultiByteBinaryOrTextStream with: s) reset.			multiString converter: UTF8TextConverter new.			multiString contents] ) ] ]! !!WAKomEncoded39 methodsFor: 'private' stamp: 'pmm 10/14/2006 14:30'!contentsOfResponse: aResponse	| responseStream |	responseStream := aResponse.	(aResponse contentType upTo: $/) = 'text' ifTrue: [		responseStream := MultiByteBinaryOrTextStream on: WideString new encoding: #utf8.		responseStream nextPutAll: aResponse contents.		responseStream binary reset ].	^responseStream contents readStream! !!WALRUCache class methodsFor: 'as yet unclassified' stamp: 'pmm 4/18/2006 20:17'!new	^ self basicNew initialize! !!WALRUCache class methodsFor: 'as yet unclassified' stamp: 'ab 7/15/2002 00:10'!new: max	^ self new capacity: max! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 2/15/2003 21:18'!at: key	^ self at: key ifAbsent: [self error: 'No entry for ', key]! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 2/15/2003 21:28'!at: key ifAbsent: errorBlock	|val|	val _ table at: key ifAbsent: [^ errorBlock value].	ageTable at: val put: 0.	^ val.! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 5/24/2003 00:37'!at: key put: val	|removals|	table at: key put: val.	ageTable at: val put: 0.	removals _ OrderedCollection new.	ageTable associationsDo:		[:assoc |		assoc value > max ifTrue: [removals add: assoc key].		assoc value: assoc value + 1].	removals do: [:ea | self remove: ea].	! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 7/15/2002 00:10'!capacity: aNumber	max _ aNumber! !!WALRUCache methodsFor: 'initialize-release' stamp: 'ab 2/18/2003 19:07'!initialize	max _ 20.	table _ Dictionary new.	ageTable _ Dictionary new.! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 17:45'!isEmpty	^ table isEmpty! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'mbany 4/14/2005 12:44'!nextKey	|key|	[table includesKey: (key _ WAExternalID new displayString)] whileTrue.	^ key! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 11:48'!remove: anObject	ageTable removeKey: anObject.	table removeKey: (table keyAtValue: anObject)! !!WALRUCache methodsFor: 'as yet unclassified' stamp: 'ab 2/15/2003 21:23'!store: anObject	|key|	key _ self nextKey.	self at: key put: anObject.	^ key! !!WAListener class methodsFor: 'accessing' stamp: 'lr 6/28/2006 15:19'!default	^ default! !!WAListener class methodsFor: 'accessing' stamp: 'avi 1/6/2006 14:19'!dispatcher	^ WADispatcher default! !!WAListener class methodsFor: 'initialization' stamp: 'lr 6/28/2006 14:37'!initialize	Smalltalk addToStartUpList: self after: AutoStart.	Smalltalk addToShutDownList: self! !!WAListener class methodsFor: 'instance-creation' stamp: 'avi 1/6/2006 14:18'!port: aNumber	^ self basicNew initializeWithPort: aNumber! !!WAListener class methodsFor: 'initialization' stamp: 'lr 6/28/2006 14:39'!shutDown	default ifNotNil: [ default stop ]! !!WAListener class methodsFor: 'public' stamp: 'lr 6/28/2006 14:39'!startOn: aNumber	default ifNotNil: [ default stop ].	default := self port: aNumber.	default dispatcher: self dispatcher.	default start! !!WAListener class methodsFor: 'initialization' stamp: 'lr 6/28/2006 14:39'!startUp	default ifNotNil: [ default start ]! !!WAListener class methodsFor: 'public' stamp: 'lr 6/28/2006 14:39'!stop	default ifNotNil: [ default stop ].	default := nil! !!WAListener methodsFor: 'private' stamp: 'pmm 10/14/2006 14:35'!convertRequest: aKomRequest	| request |	request := WARequest		method: aKomRequest method		url: aKomRequest url unescapePercents 		headers: aKomRequest header		fields: (self fieldsOf: aKomRequest)		cookies: aKomRequest cookies		nativeRequest: aKomRequest.	aKomRequest method = 'PUT'		ifTrue: [request fields					at: 'PUTData'					put: (aKomRequest stream next: aKomRequest contentLength)].	^ request! !!WAListener methodsFor: 'accessing' stamp: 'avi 1/6/2006 14:19'!dispatcher	^dispatcher! !!WAListener methodsFor: 'accessing' stamp: 'avi 1/6/2006 14:19'!dispatcher: anObject	dispatcher := anObject! !!WAListener methodsFor: 'private' stamp: 'pmm 10/14/2006 14:35'!fieldsOf: aKomRequest	^aKomRequest method = 'POST'		ifTrue: [ aKomRequest postFields ]		ifFalse: [ aKomRequest getFields ]! !!WAListener methodsFor: 'initialization' stamp: 'avi 1/6/2006 14:18'!initializeWithPort: aNumber	port := aNumber.! !!WAListener methodsFor: 'private' stamp: 'pmm 10/15/2006 12:15'!listenLoop	| socket |	socket := Socket newTCP.	socket listenOn: port backlogSize: 50.	socket isValid 		ifFalse: [ self error: 'Cannot create socket on port ' , port asString ].	[ [ socket isValid ifFalse: [			"will trigger #ifCurtailed: block and destroy socket"			^self listenLoop ].		self waitForConnectionOn: socket ] repeat ]		ifCurtailed: [			"probably copy pasted from ConnectionQueue >> #listenLoop"			(Delay forMilliseconds: 10) wait.			socket destroy ].! !!WAListener methodsFor: 'private' stamp: 'pmm 10/14/2006 14:17'!outputStreamFor: aSocketStream	^aSocketStream! !!WAListener methodsFor: 'private' stamp: 'pmm 10/14/2006 14:19'!processConnection: aSocket	| stream |	stream := SocketStream on: aSocket.	stream autoFlush: true.	[ [ [ self			writeResponseForRequest: (HttpRequest readFromStream: stream)			on: (self outputStreamFor: stream). ]		ensure: [ stream close ] ]		ifCurtailed: [ aSocket destroy ] ]		forkAt: Processor userBackgroundPriority! !!WAListener methodsFor: 'private' stamp: 'avi 1/6/2006 14:18'!responseForRequest: aRequest	^ HTTPResponse notFound! !!WAListener methodsFor: 'public' stamp: 'lr 6/28/2006 14:16'!start	self stop.	process := [ [ self listenLoop ] repeat ] 		forkAt: Processor highIOPriority! !!WAListener methodsFor: 'public' stamp: 'avi 1/6/2006 14:18'!stop	process ifNotNil: [process terminate. process := nil]! !!WAListener methodsFor: 'private' stamp: 'lr 6/28/2006 14:12'!waitForConnectionOn: aSocket	| connection |	connection := (aSocket waitForAcceptFor: 10)		ifNil: [ ^ self ].	self processConnection: connection! !!WAListener methodsFor: 'private' stamp: 'lr 7/3/2006 16:27'!writeResponseForRequest: aRequest on: aStream	| request response |	request := self convertRequest: aRequest.	request responseStream: aStream.	response := dispatcher handleRequest: request.		response ifNil: [ ^ self ].	response writeOn: aStream.	response release! !!WAListenerEncoded39 commentStamp: 'pmm 10/14/2006 14:15' prior: 0!Like WAListener but with additional response/request conversion from UTF-8 to WideString and back in Squeak 3.9.see WAListener!!WAListenerEncoded commentStamp: 'pmm 10/14/2006 14:15' prior: 0!Like WAListener but with additional response/request conversion from UTF-8 to WideString and back in Squeak 3.8.see WAListener!!WAListenerEncoded class methodsFor: 'class initialization' stamp: 'pmm 10/14/2006 18:33'!initialize	super initialize! !!WAListenerEncoded methodsFor: 'private' stamp: 'pmm 10/14/2006 14:36'!fieldsOf: aKomRequest	^(super fieldsOf: aKomRequest) associationsDo: [ :association |		(association value isKindOf: OrderedCollection) ifTrue: [			association value: (association value collect: [ :s |			| multiString |				multiString := (MultiByteBinaryOrTextStream with: s) reset.			multiString converter: UTF8TextConverter new.			multiString contents] ) ] ]! !!WAListenerEncoded39 class methodsFor: 'class initialization' stamp: 'pmm 10/14/2006 18:33'!initialize	super initialize! !!WAListenerEncoded39 methodsFor: 'private' stamp: 'pmm 10/14/2006 14:18'!outputStreamFor: aSocketStream	^WAUtf8EncodingStream on: aSocketStream! !!WAMain methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:37'!application	^ self session application! !!WAMain methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:31'!session	^ WACurrentSession value! !!WAMain methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 01:25'!start: aRequest	self subclassResponsibility! !!WAAuthMain methodsFor: 'as yet unclassified' stamp: 'avi 5/19/2004 14:16'!createRoot	| root |	root _ super createRoot.	root addDecoration: (WABasicAuthentication new authenticator: self).	^ root! !!WAAuthMain methodsFor: 'as yet unclassified' stamp: 'pmm 9/12/2006 18:10'!verifyPassword: password forUser: username	^self application login = username		and: [ self application password = password ]! !!WARenderLoopMain methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 16:09'!call: aComponent	^ WARenderLoop new call: aComponent! !!WARenderLoopMain methodsFor: 'as yet unclassified' stamp: 'avi 4/22/2004 14:59'!createRoot	^ self rootClass new! !!WARenderLoopMain methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 09:17'!rootClass	^ self application rootComponent! !!WARenderLoopMain methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 11:51'!start: aRequest	| root |	root _ self createRoot.	root visiblePresentersDo: [:ea | ea initialRequest: aRequest].	(WARenderLoop new root: root) run! !!WAModelProxy commentStamp: '<historical>' prior: 0!I am a fake object that can be interposed between the real model object and the client, so that the data can be validated or collected before commiting to the real model.If you have a model instance like	model := WAStoreAddress new.	model street: 'Rathausgasse 34'.create a model proxy by evaluating the following code:	proxy := WAModelProxy on: model.	Then use the accessors of the proxy as you would do with your model:	proxy country: 'Switzerland'.	proxy street -> 'Rathausgasse 34'	...	To propagate the values into your model send #commit :	proxy commit.	model country -> 'Switzerland'!!WAModelProxy class methodsFor: 'as yet unclassified' stamp: 'ab 11/26/2002 17:21'!on: anObject	^ self new setModel: anObject! !!WAModelProxy methodsFor: 'forwarding' stamp: 'ab 12/12/2002 00:18'!commit	cache keysAndValuesDo:		[:key :value |		self performRealWrite: key with: value].	cache _ Dictionary new.! !!WAModelProxy methodsFor: 'forwarding' stamp: 'ab 11/26/2002 17:53'!doesNotUnderstand: aMessage	^ aMessage selector isUnary		ifTrue: [self performRead: aMessage selector]		ifFalse:			[(aMessage selector isKeyword and: [aMessage arguments size = 1])				ifTrue: [self performWrite: aMessage selector allButLast with: aMessage argument]				ifFalse: [super doesNotUnderstand: aMessage]]! !!WAModelProxy methodsFor: 'accessing' stamp: 'ab 11/26/2002 17:22'!model	^ model! !!WAModelProxy methodsFor: 'forwarding' stamp: 'ab 11/26/2002 17:24'!name	^ model name! !!WAModelProxy methodsFor: 'private' stamp: 'mb 1/5/2006 13:46'!performRead: aSymbol	^ cache at: aSymbol asSymbol			ifAbsent: [model perform: aSymbol asSymbol]! !!WAModelProxy methodsFor: 'private' stamp: 'mb 1/5/2006 13:51'!performRealWrite: aSymbol with: anObject	model perform: aSymbol asSymbol asMutator with: anObject! !!WAModelProxy methodsFor: 'private' stamp: 'mb 1/5/2006 13:51'!performWrite: aSymbol with: anObject	cache at: aSymbol asSymbol put: anObject! !!WAModelProxy methodsFor: 'initializing' stamp: 'ab 12/12/2002 00:18'!setModel: anObject	model _ anObject.	cache _ Dictionary new.! !!WAModelProxy methodsFor: 'forwarding' stamp: 'ab 11/26/2002 17:24'!value	^ model value! !!WAPluggableSelectBox class methodsFor: 'as yet unclassified' stamp: 'ab 2/15/2003 18:28'!on: anObject list: listSelector selected: selectedSelector changeSelected: changeSelectedSelector	^ self 		on: anObject		list: listSelector		selected: selectedSelector		changeSelected: changeSelectedSelector		size: 10! !!WAPluggableSelectBox class methodsFor: 'as yet unclassified' stamp: 'pmm 4/19/2006 17:42'!on: anObject list: listSelector selected: selectedSelector changeSelected: changeSelectedSelector size: aNumber	^ self new		model: anObject;		list: listSelector;		selected: selectedSelector;		changeSelected: changeSelectedSelector;		size: aNumber;		yourself! !!WAPluggableSelectBox methodsFor: 'accessing' stamp: 'ab 10/1/2002 14:16'!changeSelected: aSymbol	changeSelected _ aSymbol! !!WAPluggableSelectBox methodsFor: 'accessing' stamp: 'ab 10/1/2002 14:16'!list: aSymbol	list _ aSymbol! !!WAPluggableSelectBox methodsFor: 'accessing' stamp: 'ab 2/15/2003 18:24'!model: anObject	model _ anObject! !!WAPluggableSelectBox methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:30'!renderOn: html	|array|	array := (model perform: list) asArray.	html div		class: 'column-choice';		with: [			html form: [				html select					beSubmitOnChange;					size: size;					list: array;					selected: (array at: (model perform: selected) ifAbsent: []);					callback: [ :item |						model perform: changeSelected with: (array indexOf: item) ] ] ].	! !!WAPluggableSelectBox methodsFor: 'accessing' stamp: 'ab 10/1/2002 14:16'!selected: aSymbol	selected _ aSymbol! !!WAPluggableSelectBox methodsFor: 'accessing' stamp: 'ab 2/15/2003 18:25'!size: aNumber	size _ aNumber! !!WAComponent commentStamp: '<historical>' prior: 0!I am a class representing a graphical element of a seaside application. A component has state (instance variables, that might be backtracked using #registerObjectForBacktracking:), behavior decorations, children and an appearance that is specified in #renderContentOn:. A component might chose to display another component with #call:.Child Components:It is common for a component to display instances of other components while rendering itself.  It does this by passing them into the #render: method of WAHtmlRenderer.  For example, this #renderContentOn: method simply renders a heading and then displays a counter component immediately below it:	renderContentOn: html		html heading: 'My Counter' level: 3.		html render: myCounter.It's important that you use #render:, rather than directly calling the #renderContentOn: method of the subcomponent. The following is *not* correct:	renderContentOn: html		html heading: 'My Counter' level: 3.		myCounter renderContentOn: html.   "DON'T DO THIS".These subcomponents are usually instance variables of the component that is "embedding" them.  They are commonly created as part of the components #initialize method:	initialize		myCounter := WACounter new.They may also be stored in a collection. One fairly common pattern is to keep a lazily initialized dictionary of subcomponents that match a collection of model items. For example, if you wanted a BudgetItemRow subcomponent for each member of budgetItems, you might do something like this:	initialize		budgetRows := Dictionary new.	rowForItem: anItem		^budgetRows at: anItem ifAbsentPut: [ BudgetItemRow item: anItem ].	renderContentOn: html		self budgetItems			do: [ :each | html render: (self rowForItem: each) ]			separatedBy: [ html horizontalLine ].Each parent component *must* implement a #children method that returns a collection of all of the subcomponents that it might display on the next render. For the above two examples, #children might look like this:	children		^Array with: myCounteror this:	children		^self budgetItems collect: [ :each | self rowForItem: each ].		Call/Answer:If a subcomponent makes a #call: to another component, that component will appear in place of the subcomponent.  In the first example, if myCounter made a #call: to DateSelector, that DateSelector would appear in the context of the counter's parent, with the 'My Counter' heading above it.Since a subcomponent has not been #call:'d, in general #answer: is a no-op.  However, the parent may attach an #onAnswer: block to the subcomponent to be notified if it sends #answer:. This allows one component to be used both from #call: and through embedding. For example:	initialize		dateSelector := WADateSelector new 			onAnswer: [ :date | self dateChosen: date ].!!WAAlphabeticBatchedList methodsFor: 'accessing-calculated' stamp: 'avi 12/18/2004 18:26'!allPages	^ $A to: $Z! !!WAAlphabeticBatchedList methodsFor: 'accessing-calculated' stamp: 'mbany 4/14/2005 12:37'!batch	^ items select: [:ea | ea displayString asUppercase first = self currentPage]! !!WAAlphabeticBatchedList methodsFor: 'accessing' stamp: 'avi 12/18/2004 18:20'!currentPage	^ currentPage ifNil: [currentPage _ self validPages first]! !!WAAlphabeticBatchedList methodsFor: 'accessing' stamp: 'avi 12/18/2004 18:16'!currentPage: aCharacter	currentPage _ aCharacter! !!WAAlphabeticBatchedList methodsFor: 'initialization' stamp: 'pmm 11/2/2005 22:49'!initialize	super initialize.	self session registerObjectForBacktracking: self.! !!WAAlphabeticBatchedList methodsFor: 'testing' stamp: 'avi 12/18/2004 18:21'!isOnFirstPage	^ self validPages first = self currentPage! !!WAAlphabeticBatchedList methodsFor: 'testing' stamp: 'avi 12/18/2004 18:21'!isOnLastPage	^ self validPages last = self currentPage! !!WAAlphabeticBatchedList methodsFor: 'accessing' stamp: 'avi 12/18/2004 18:13'!items	^ items! !!WAAlphabeticBatchedList methodsFor: 'accessing' stamp: 'avi 12/18/2004 18:20'!items: aCollection	items _ aCollection! !!WAAlphabeticBatchedList methodsFor: 'actions' stamp: 'avi 12/18/2004 18:19'!nextPage	self isOnLastPage ifFalse: [currentPage _ self validPages after: currentPage]! !!WAAlphabeticBatchedList methodsFor: 'actions' stamp: 'avi 12/18/2004 18:19'!previousPage	self isOnFirstPage ifFalse: [currentPage _ self validPages before: currentPage]! !!WAAlphabeticBatchedList methodsFor: 'rendering' stamp: 'avi 12/18/2004 18:21'!renderContentOn: html	items isEmpty ifFalse: [		html divNamed: 'batch' with: [			self renderPreviousOn: html.			self renderPagesOn: html. 			self renderNextOn: html ] ]! !!WAAlphabeticBatchedList methodsFor: 'rendering' stamp: 'avi 12/18/2004 18:13'!renderNextOn: html	html space.	self isOnLastPage		ifFalse: [ html anchorWithAction: [ self nextPage ] text: '>>' ]		ifTrue: [ html text: '>>' ]		! !!WAAlphabeticBatchedList methodsFor: 'rendering' stamp: 'avi 12/18/2004 18:24'!renderPagesOn: html	self allPages		do: [ :char |			currentPage = char				ifFalse:					[(self validPages includes: char)						ifTrue: [html anchorWithAction: [self currentPage: char] text: char]						ifFalse: [html text: char]]				ifTrue: [html bold: char ] ]		separatedBy: [ html space ]! !!WAAlphabeticBatchedList methodsFor: 'rendering' stamp: 'avi 12/18/2004 18:13'!renderPreviousOn: html	self isOnFirstPage		ifFalse: [ html anchorWithAction: [ self previousPage ] text: '<<' ]		ifTrue: [ html text: '<<' ].	html space.! !!WAAlphabeticBatchedList methodsFor: 'accessing-calculated' stamp: 'mbany 4/14/2005 12:37'!validPages	^ (items collect: [:ea | ea displayString asUppercase first]) asSet asSortedCollection! !!WABatchSelection class methodsFor: 'as yet unclassified' stamp: 'pmm 4/19/2006 17:39'!items: aCollection link: linkSelector text: textSelector	^ self new		items: aCollection;		linkSelector: linkSelector;		textSelector: textSelector;		yourself! !!WABatchSelection methodsFor: 'accessing' stamp: 'rjl 8/4/2006 11:35'!batchSize    ^batcher batchSize! !!WABatchSelection methodsFor: 'accessing' stamp: 'rjl 8/4/2006 11:34'!batchSize: aSize    batcher batchSize: aSize! !!WABatchSelection methodsFor: 'accessing' stamp: 'avi 2/10/2004 20:43'!children	^ Array with: batcher! !!WABatchSelection methodsFor: 'commands' stamp: 'avi 12/9/2003 13:17'!choose: anItem	self answer: anItem! !!WABatchSelection methodsFor: 'accessing' stamp: 'pmm 9/12/2006 18:10'!items: aCollection	batcher := WABatchedList new 		items: aCollection;		batchSize: 8;		yourself! !!WABatchSelection methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:22'!linkSelector: aSymbol	linkSelector _ aSymbol! !!WABatchSelection methodsFor: 'rendering' stamp: 'avi 12/9/2003 13:38'!renderContentOn: html	html list: batcher batch do:		[:ea |		html anchorWithAction: [self choose: ea] text: (ea perform: linkSelector).		html break; text: (ea perform: textSelector).		html paragraph].	html attributes alignCenter.	html div: batcher.! !!WABatchSelection methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:22'!textSelector: aSymbol	textSelector _ aSymbol! !!WABatchTest methodsFor: 'accessing' stamp: 'avi 12/18/2004 18:33'!children	^ Array with: batcher! !!WABatchTest methodsFor: 'initialization' stamp: 'pmm 9/12/2006 18:10'!initialize	super initialize.	batcher := WAAlphabeticBatchedList new items: Collection allSubclasses! !!WABatchTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:16'!renderContentOn: html	html render: batcher.	html unorderedList		list: batcher batch! !!WABatchTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:14'!rendererClass	^ WARenderCanvas ! !!WABatchedList class methodsFor: 'as yet unclassified' stamp: 'avi 12/18/2004 18:13'!example	^self new		items: (1 to: 100);		yourself.		! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'rjl 8/9/2006 14:30'!batch	^ self items copyFrom: self startIndex to: self endIndex! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 23:12'!batchSize	^ batchSize! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 23:09'!batchSize: aNumber	batchSize _ aNumber! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 23:12'!currentPage	^ currentPage! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 23:12'!currentPage: aNumber	currentPage _ aNumber! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'rjl 8/9/2006 14:30'!endIndex	^ self currentPage * self batchSize min: self items size! !!WABatchedList methodsFor: 'initialization' stamp: 'rjl 8/9/2006 14:31'!initialize	super initialize.	self batchSize: 10.	self currentPage: 1.	self session registerObjectForBacktracking: self.! !!WABatchedList methodsFor: 'testing' stamp: 'rjl 8/9/2006 14:32'!isOnFirstPage	^ self currentPage = 1! !!WABatchedList methodsFor: 'testing' stamp: 'rjl 8/9/2006 14:32'!isOnLastPage	^ self currentPage = self maxPages! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 23:12'!items	^ items! !!WABatchedList methodsFor: 'accessing' stamp: 'ab 5/25/2003 22:57'!items: aCollection	items _ aCollection! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'rjl 8/9/2006 14:30'!maxPages	^ (self items size / self batchSize) ceiling! !!WABatchedList methodsFor: 'actions' stamp: 'rjl 8/9/2006 14:31'!nextPage	self isOnLastPage ifFalse: [self currentPage: self currentPage + 1]! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'lr 9/3/2003 10:44'!pageRange	^ self pageRangeStart to: self pageRangeEnd! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'lr 9/3/2003 10:50'!pageRangeEnd	^ self maxPages min: self currentPage + 9! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'lr 9/3/2003 10:51'!pageRangeStart	^ 1 max: self currentPage - 9! !!WABatchedList methodsFor: 'actions' stamp: 'rjl 8/9/2006 14:31'!previousPage	self isOnFirstPage ifFalse: [self currentPage: self currentPage - 1]! !!WABatchedList methodsFor: 'rendering' stamp: 'lr 9/3/2003 10:26'!renderContentOn: html	self maxPages > 0 ifTrue: [		html divNamed: 'batch' with: [			self renderPreviousOn: html.			self renderPagesOn: html. 			self renderNextOn: html ] ]! !!WABatchedList methodsFor: 'rendering' stamp: 'lr 9/3/2003 10:28'!renderNextOn: html	html space.	self isOnLastPage		ifFalse: [ html anchorWithAction: [ self nextPage ] text: '>>' ]		ifTrue: [ html text: '>>' ]		! !!WABatchedList methodsFor: 'rendering' stamp: 'rjl 8/9/2006 14:32'!renderPagesOn: html	self pageRange		do: [ :index |			self currentPage = index				ifFalse: [html anchorWithAction: [self currentPage: index] text: index]				ifTrue: [html bold: index ] ]		separatedBy: [ html space ]! !!WABatchedList methodsFor: 'rendering' stamp: 'lr 9/3/2003 10:28'!renderPreviousOn: html	self isOnFirstPage		ifFalse: [ html anchorWithAction: [ self previousPage ] text: '<<' ]		ifTrue: [ html text: '<<' ].	html space.! !!WABatchedList methodsFor: 'accessing-calculated' stamp: 'rjl 8/9/2006 14:30'!startIndex	^ (self currentPage - 1) * self batchSize + 1! !!WABrowser class methodsFor: 'as yet unclassified' stamp: 'ab 9/28/2002 11:35'!fullOnClass: aClass	^ self new model: (Browser new setClass: aClass selector: nil)! !!WABrowser methodsFor: 'actions' stamp: 'avi 4/28/2004 11:40'!accept	|save|	SeasidePlatformSupport ensureAuthorInitials: [self request: 'Please enter your initials:'].	message _ nil.	save _ contents.	model contents: contents notifying: self.	contents _ save.! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/8/2002 19:41'!columnView: columnName	^WAPluggableSelectBox		on: model		list: (columnName, 'List') asSymbol		selected: (columnName, 'ListIndex') asSymbol		changeSelected: (columnName, 'ListIndex:') asSymbol! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/10/2002 23:50'!contents	^contents! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/10/2002 23:54'!contents: aString	contents _ aString! !!WABrowser methodsFor: 'initialize-release' stamp: 'pmm 11/2/2005 22:48'!initialize	super initialize.	self model: Browser new.! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/8/2002 22:13'!model	^model ! !!WABrowser methodsFor: 'accessing' stamp: 'ab 2/18/2003 19:07'!model: aBrowserModel	model _ aBrowserModel.	model addDependent: self.	self session registerObjectForBacktracking: model.	contents _ model contents.! !!WABrowser methodsFor: 'notifying' stamp: 'ab 10/10/2002 23:36'!notify: aString at: location in: sourceStream	message _ aString allButLast: 3! !!WABrowser methodsFor: 'rendering' stamp: 'ab 11/26/2002 14:08'!renderColumnsOn: html	|cols|	cols _ #(systemCategory class messageCategory message)				collect: [:sel | self columnView: sel].	html table: [		html tableRow: [			cols do: [:ea | html tableData: [html render: ea]].		]	]! !!WABrowser methodsFor: 'rendering' stamp: 'ab 6/15/2003 12:57'!renderContentOn: html	self		renderColumnsOn: html;		renderModeButtonsOn: html;		renderMessageOn: html;		renderContentPaneOn: html	! !!WABrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:32'!renderContentPaneOn: html	html form: [		html textArea			columns: 80;			rows: 12;			on: #contents of: self.		html break.		html submitButton on: #accept of: self ]! !!WABrowser methodsFor: 'rendering' stamp: 'ab 2/16/2003 00:26'!renderMessageOn: html	message ifNotNil: [html bold: message]! !!WABrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:30'!renderModeButtonsOn: html	html form: [		html submitButton callback: [ self showInstance ]; value: 'instance'.		html submitButton callback: [ self showHelp ]; value: 'help'.		html submitButton callback: [ self showClass ]; value: 'class' ]! !!WABrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:58'!rendererClass	^ WARenderCanvas! !!WABrowser methodsFor: 'notifying' stamp: 'ab 10/11/2002 00:00'!select! !!WABrowser methodsFor: 'actions' stamp: 'ab 10/11/2002 00:00'!selectFrom: aPos to: anotherPos! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/10/2002 23:44'!selectionInterval	^ 1 to: 1! !!WABrowser methodsFor: 'actions' stamp: 'LR 9/13/2002 20:38'!showClass	self model indicateClassMessages! !!WABrowser methodsFor: 'actions' stamp: 'LR 9/13/2002 20:42'!showHelp	self model plusButtonHit! !!WABrowser methodsFor: 'actions' stamp: 'LR 9/13/2002 20:39'!showInstance	self model indicateInstanceMessages! !!WABrowser methodsFor: 'rendering' stamp: 'mb 2/17/2005 18:20'!style	^ '	#contents {width: 100%; height: 300px; font-family: serif; font-size: 14pt}	'! !!WABrowser methodsFor: 'accessing' stamp: 'ab 10/10/2002 23:44'!text	^ Text fromString: ''! !!WABrowser methodsFor: 'notifying' stamp: 'ab 10/10/2002 01:45'!update: aSymbol	contents _ model contents! !!WACacheTest methodsFor: 'rendering' stamp: 'avi 10/26/2004 15:41'!renderContentOn: html	Smalltalk garbageCollect.  	html heading: ResponseContinuation allInstances size.	html heading: AnswerContinuation allInstances size.	html heading: EscapeContinuation allInstances size.	html anchorWithAction: [self inform: 'answer'] text: 'call'.	html break.	html anchorWithAction: [self call: self class new] text: 'keep calling'.! !!WACallbackTest methodsFor: 'accessing' stamp: 'mb 2/17/2005 17:50'!children	^ Array with: counter.! !!WACallbackTest methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:09'!initialize	super initialize.	transcript _ String new writeStream.	counter _ WACounter new.! !!WACallbackTest methodsFor: 'rendering' stamp: 'mb 2/17/2005 17:50'!renderContentOn: html	html anchorWithCallback: [] do: 'Idempotent'.	html space.	html anchorWithAction: [] do: 'Side Effect'.		html form: [		html defaultAction: [transcript cr; nextPutAll: 'default action'].		html textInputWithValue: '' callback: [:v | transcript cr; nextPutAll: 'text: ', v printString].		html textInputWithValue: '' callback: [:v | transcript cr; nextPutAll: 'text2: ', v printString].		html break.		html submitButton.		html space.		html submitButtonWithAction: [transcript cr; nextPutAll: 'go'] text: 'Go'.		html space.		html cancelButtonWithAction: [transcript cr; nextPutAll: 'cancel'].	].	html preformatted: transcript contents.	html horizontalRule.	html render: counter.! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:25'!data1	^data1! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:26'!data1: aString	data1 := aString! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:25'!data2	^data2! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:26'!data2: aString	data2 := aString! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:22'!date	^date! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:23'!date: aDate 	date := aDate! !!WACanvasDateTimeTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:48'!initialize	super initialize.	data1 := 'Harry'.	data2 := 'Covert'.	data := String new.	msg := String new.	numericData := 12.! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:26'!numericData	^numericData! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:26'!numericData: aString	numericData := aString! !!WACanvasDateTimeTest methodsFor: 'rendering' stamp: 'mb 2/6/2006 10:44'!renderContentOn: html	self renderSubmitFormOn: html.	self renderDateTimeOn: html.! !!WACanvasDateTimeTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:25'!renderDateTimeOn: html	html heading: 'Form with #dateInput and #timeInput'.	html form		style: 'border: 1px green solid; width: 50%';		id: 'f2';		defaultAction: [msg _ 'Default action: ' , date displayString , ' ' , time displayString];		with: [			html dateInput				id: 'date-input';				on: #date of: self.			html space: 10.			html timeInput				id: 'time-input';				value: time;				withSeconds;				on: #time of: self.			html					break;				text: msg;				break.			html submitButton				callback: [msg _ 'Button action: ' , date displayString , ' ' , time displayString]].! !!WACanvasDateTimeTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:29'!renderSubmitFormOn: html	html heading: 'Form with #submitFormNamed:'.	(html form)		style: 'border: 1px red solid; width: 50%';		id: 'f1';		defaultAction: [data _ 'Default action : '			, data1 printString , ' ' 			, data2 printString , ' ' 			, numericData printString];		with: [			html textInput				on: #data1 of: self.			html textInput				on: #data2 of: self.			html textInput				on: #numericData of: self.			html break.			html text: data.			html break.			html anchor				callback: [data _ 'Anchor action : '					, data1 printString , ' ' 					, data2 printString , ' ' 					, numericData printString];				submitFormNamed: 'f1';				text: 'Click me'].! !!WACanvasDateTimeTest methodsFor: 'rendering' stamp: 'mb 1/30/2006 15:21'!rendererClass	^WARenderCanvas! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:23'!time	^time! !!WACanvasDateTimeTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:23'!time: aTime	time := aTime! !!WACanvasDefaultFormTest methodsFor: 'rendering' stamp: 'mb 4/5/2006 07:12'!renderContentOn: html	html form		defaultAction: [self inform: 'Default: ', value displayString]; with:		[		html submitButton 				callback: [self inform: 'Before: ', value displayString];				text: 'Before'.		html break.		html textInput				value: '';				callback: [:v | value _ v].		html submitButton				callback: [self inform: 'Go: ', value displayString];				text: 'Go'.		html break.		html submitButton				callback: [self inform: 'After: ', value displayString];				text: 'After']! !!WACanvasDefaultFormTest methodsFor: 'rendering' stamp: 'mb 4/3/2006 17:48'!rendererClass	^WARenderCanvas! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:20'!allSelectors	^ (self class selectors asSortedCollection select: [:s | s beginsWith: 'render'])		removeAll: #(renderContentOn: rendererClass);		yourself! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'mb 3/8/2006 14:00'!initialMessage	^'Hello world!!'.! !!WACanvasHtmlTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:49'!initialize	super initialize.	message := self initialMessage.	booleanList := #(a b c d) collect: [:key | key -> ((Array with: true with: false) atRandom)].	number := 10 atRandom.! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:33'!message	^message! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:33'!message: aString	message := aString! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:32'!number	^number! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:32'!number: anInteger	number := anInteger! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:37'!renderCheckboxesOn: html	html text: booleanList.	html paragraph.	html form: [		booleanList do: [:association |			html text: association key; space.			html checkbox				addShortcut: 'Ctrl-' , association key asUppercase;				on: #value of: association.			html break].		html submitButton]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'mb 1/31/2006 11:32'!renderContentOn: html	self allSelectors pairsDo:		[:selA :selB |		(html div)			class: 'row';			with: 				[(html div)					class: 'left';					with: [self perform: selA with: html].				(html div)					class: 'left';					with: [self perform: selB with: html]]		]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:39'!renderRadioButtonsOn: html	html text: booleanList.	html paragraph.	html form: [		booleanList do: [ :association |			| group |			group := html radioGroup.			html text: association key; space.			html radioButton				addShortcut: 'Ctrl-' , association key;				group: group;				selected: association value;				callback: [association value: true].			html radioButton				addShortcut: 'Alt-' , association key;				group: group;				selected: association value not;				callback: [association value: false].			html break].		html submitButton]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:39'!renderSelectsOn: html	html text: number.	html paragraph.	html form: [		html select			list: (1 to: 10);			on: #number of: self.		html submitButton]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:42'!renderSubmitButtonsOn: html	html text: number.	html paragraph.	html form: [		1 to: 10 do: [ :index |			html submitButton				addShortcut: 'F' , index asString;				callback: [number := index];				text: index.			html space]]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:42'!renderTextAreaOn: html	| position |	position := message = self initialMessage 			ifTrue: [6] 			ifFalse: ['End'].	html form: [		html text: message.		html paragraph.		html textArea			setCursorPosition: position;			on: #message of: self.		html break.		html submitButton]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:34'!renderTextInputOn: html	html form: [		html text: message.		html paragraph.		html textInput			on: #message of: self.		html submitButton]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'mb 3/24/2006 13:23'!renderVFieldSetOn: html	(html fieldSet)		legend: 'Various text rendering in a fieldset';		with:			[html				strong: 'Strong';				break;				bold: 'Bold';				break;				italic: 'Italic';				break;				underline: 'Underline';				break.			(html acronym)				title: 'United States of America';				with: 'USA'.			html				break;				emphasis: 'Emphasis';				break.				(html div)				addStyle: 'color: red';				addStyle: 'background-color: lightgreen';				addStyle: 'padding: 1em';				addStyle: 'border: solid 2px black';				addStyle: 'font-weight: bold';				addStyle: 'font-size: 150%';				addStyle: 'height: 3em';				addStyle: 'text-align: center';				with: 'Large bold red in a green div'.			html				break]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'mb 6/12/2006 14:33'!renderZFieldSetOn: html	| url1 |	url1 _ html context				urlForDocument: (ScriptingSystem formAtKey: 'Halo-Debug') 				mimeType: 'image/jpg' 				fileName: 'Debug.jpg'.	(html fieldSet)		legend: 'Various images in a fieldset';		with:			[html image url: url1; altText: 'Halo-Debug'.			html space.			html image form: (ScriptingSystem formAtKey: 'Halo-View'); altText: 'Halo-View'.			html space.			html image					fileName: 'Paint.png'; 					mimeType: 'image/png';					document: (ScriptingSystem formAtKey: 'Halo-Paint'); 					altText: 'Halo-Paint'.			html break.			html image border: 1; url: 'http://www.netstyle.ch/include/seaside/pics/top.jpg'; width: '80%'; altText: 'Seaside'.			html break.			html image border: 2; url: 'http://www.netstyle.ch/include/seaside/pics/top.jpg'; height: '50px'; altText: 'Seaside'.			html break.			html image border: 0; url: 'http://www.netstyle.ch/include/seaside/pics/top.jpg'; width: '250px'; height: '60px'; altText: 'Seaside'.		]! !!WACanvasHtmlTest methodsFor: 'rendering' stamp: 'mb 1/31/2006 11:15'!rendererClass	^ WARenderCanvas! !!WACanvasHtmlTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:18'!style^ '	div.row {clear: both}	div.left {float: left; width: 45%; margin: 1%}'! !!WACanvasImageTest methodsFor: 'rendering' stamp: 'mb 6/8/2006 15:54'!renderContentOn: html	html form: [		html imageButton 			callback: [self inform: 'ok'];			form: (ScriptingSystem formAtKey: 'Halo-Debug')]! !!WACanvasImageTest methodsFor: 'rendering' stamp: 'mb 6/6/2006 10:22'!rendererClass	^ WARenderCanvas! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:21'!address	"Answer the value of address"	^ address! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:21'!address: anObject	"Set the value of address"	address _ anObject! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!emptyString	"Answer the value of emptyString"	^ emptyString! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!emptyString: anObject	"Set the value of emptyString"	emptyString _ anObject! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!fraction	"Answer the value of fraction"	^ fraction! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!fraction: anObject	"Set the value of fraction"	fraction _ anObject! !!WACanvasInputTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:49'!initialize	super initialize.	nilString := nil.	emptyString := ''.	integer := 42.	fraction := 1/3.! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!integer	"Answer the value of integer"	^ integer! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!integer: anObject	"Set the value of integer"	integer _ anObject! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:04'!lastName	"Answer the value of lastName"	^ lastName! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:04'!lastName: anObject	"Set the value of lastName"	lastName _ anObject! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:03'!name: anObject	"Set the value of name"	name _ anObject! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!nilString	"Answer the value of nilString"	^ nilString! !!WACanvasInputTest methodsFor: 'accessing' stamp: 'mb 1/31/2006 11:03'!nilString: anObject	"Set the value of nilString"	nilString _ anObject! !!WACanvasInputTest methodsFor: 'rendering' stamp: 'mb 10/10/2006 23:25'!renderContentOn: html	html form: [		html table: [			html tableRow: [				html tableHeading:  'Name'.				html tableHeading: 'Value'.				html tableHeading: 'PrintString'].			html tableRow: [				html tableData: 'Nil String'.				html tableData: [html textInput on: #nilString of: self].				html tableData: [html text: nilString printString]].			html tableRow: [				html tableData: 'Empty String'.				html tableData: [html textInput on: #emptyString of: self].				html tableData: [html text: emptyString printString]].			html tableRow: [				html tableData: 'Integer'.				html tableData: [html textInput setFocus; on: #integer of: self].				html tableData: [html text: integer printString]].			html tableRow: [				html tableData: 'Fraction'.				html tableData: [html textInput on: #fraction of: self].				html tableData: [html text: fraction printString]].			html tableRow: [				html tableData: 'Text input with example'.				html tableData: [					html textInput						value: self lastName;						exampleText: 'Your name';						callback: [:v | self lastName: v]].				html tableData: ''].			html tableRow: [				html tableData: 'Text area with example'.				html tableData: [					html textArea						value: self address;						exampleText: 'Your address';						callback: [:v | self address: v]].				html tableData: ''].		].		html submitButton.	]! !!WACanvasInputTest methodsFor: 'rendering' stamp: 'mb 1/31/2006 11:09'!rendererClass	^ WARenderCanvas! !!WACanvasLinkSubmitTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:45'!count	^count! !!WACanvasLinkSubmitTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:46'!count: anInteger	count := anInteger! !!WACanvasLinkSubmitTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:46'!initialize	super initialize.	count := 0! !!WACanvasLinkSubmitTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:54'!renderContentOn: html	| formId |	formId := #myform.	html form		id: formId;		with: [			html textInput				on: #count of: self.			html break.			html anchor				id: #decreaseLink;				addShortcut: 'Ctrl-Down';				callback: [count _ count - 1];				submitFormNamed: formId;				text: '--'.			html space.			html anchor				id: #increaseLink;				addShortcut: 'Ctrl-Up';				callback: [count _ count + 1];				submitFormNamed: formId;				text: '++'.			html break; break.			count = 0 ifFalse:				[(html checkbox)					addShortcut: 'Ctrl-Z';					addShortcut: 'Ctrl-z';					value: (count = 0);					callback: [ :value | value ifTrue: [count := 0]];					submitFormNamed: formId.				html space.				html text: 'Reset']].	html emphasis: 'Handy shortcuts : Ctrl-Up, Ctrl-Down and Ctrl-Z'! !!WACanvasLinkSubmitTest methodsFor: 'rendering' stamp: 'mb 1/31/2006 12:04'!rendererClass	^ WARenderCanvas! !!WACanvasModelTest methodsFor: 'actions' stamp: 'mb 2/9/2006 15:25'!logoff	state _ #OFF.	test ifTrue: [self inform: 'Logged off']! !!WACanvasModelTest methodsFor: 'actions' stamp: 'mb 2/9/2006 15:26'!logon	user isEmptyOrNil		ifTrue:			[self inform: 'Nope !!']		ifFalse:			[state _ #ON.			test ifTrue: [self inform: 'Logged on']]! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:04'!pass	"Answer the value of pass"	^ pass! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:04'!pass: anObject	"Set the value of pass"	pass _ anObject! !!WACanvasModelTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:55'!renderContentOn: html	| formId |	formId _ 'myform'.	(html form)		id: formId;		with:			[(html label)				for: #userid; with:					[html text: 'User name'; space.					(html textInput) id: #userid; on: #user of: self].			html break.			(html label)				for: #pass; with:					[html text: 'Password'; space.					(html passwordInput) on: #pass of: self].			html break.			(html label)				for: #test; with:					[html text: 'With feedback'; space.					(html checkbox) on: #test of: self].			html break.			state == #ON				ifFalse:					[(html submitButton)						callback: [self logon];						text: 'Logon']				ifTrue:					[(html submitButton)						callback: [self logoff];						text: 'Logoff']].	! !!WACanvasModelTest methodsFor: 'rendering' stamp: 'mb 2/9/2006 15:03'!rendererClass	^ WARenderCanvas! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:04'!test	"Answer the value of test"	^ test! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:04'!test: anObject	"Set the value of test"	test _ anObject! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:10'!user	"Answer the value of user"	^ user! !!WACanvasModelTest methodsFor: 'accessing' stamp: 'mb 2/9/2006 15:10'!user: anObject	"Set the value of user"	user _ anObject! !!WACanvasTest methodsFor: 'actions' stamp: 'avi 6/13/2004 01:06'!decrease	count _ count - 1! !!WACanvasTest methodsFor: 'actions' stamp: 'avi 6/13/2004 01:06'!increase	count _ count + 1! !!WACanvasTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:49'!initialize	super initialize.	count := 0.	selected := Array new.! !!WACanvasTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 20:08'!renderContentOn: html	html div style: 'background-color: lightblue'; with: [		html text: count; break.		html anchor callback: [self increase]; with: '++'.		html space.		html anchor callback: [self decrease]; with: '--'.	].	html table with: [		html tableRow with: [			html tableData with: [				html form: [					html select						size: 10; 						beMultiple; 						beSubmitOnChange;						list: Collection subclasses;						on: #selected of: self ] ].			html tableData with: [				html unorderedList					beMultiple;					list: Collection subclasses;					on: #selected of: self ] ] ].! !!WACanvasTest methodsFor: 'rendering' stamp: 'lr 9/25/2005 14:10'!rendererClass	^ WARenderCanvas! !!WACanvasTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 19:59'!selected	^selected! !!WACanvasTest methodsFor: 'accessing' stamp: 'pmm 7/19/2006 20:00'!selected: aClass	selected := aClass! !!WACanvasUploadTest methodsFor: 'rendering' stamp: 'mb 9/22/2006 12:30'!renderContentOn: html	html heading: 'Upload File'.	html form		multipart;		with:			[html fileUpload callback: [:f | file := f].			html submitButton text: 'Load'].	file ifNotNil:		[(html anchor)			document: file contents mimeType: file contentType fileName: file fileName;			text: file fileName , ' (' , file contentType , ')'.		html break.		(html anchor)			document: file contents;			text: file fileName.		html preformatted: file contents].! !!WACanvasUploadTest methodsFor: 'rendering' stamp: 'mb 9/8/2006 10:37'!rendererClass	^ WARenderCanvas! !!WAChangePassword methodsFor: 'accessing' stamp: 'avi 2/6/2004 22:37'!authenticator: anAuthenticator	authenticator _ anAuthenticator! !!WAChangePassword methodsFor: 'actions' stamp: 'avi 2/6/2004 23:10'!cancel	self answer: false! !!WAChangePassword methodsFor: 'actions' stamp: 'avi 2/6/2004 23:09'!changePassword	password = confirmation		ifFalse: [^ self inform: 'Sorry, the password and confirmation did not match.'].	authenticator setPassword: password forUser: username.	self answer: true	! !!WAChangePassword methodsFor: 'rendering' stamp: 'avi 2/6/2004 23:10'!renderContentOn: html	html form: [		html table: [			html				tableRowWithLabel: 'Username'				column: username.			html				tableRowWithLabel: 'Password'				column: [html passwordInputWithCallback: [:v | password _ v]].			html				tableRowWithLabel: 'Confirm Password'				column: [html passwordInputWithCallback: [:v | confirmation _ v]].			html spacerRow.			html attributes alignCenter.			html tableRowWith: [				html submitButtonOn: #changePassword of: self.				html space.				html submitButtonOn: #cancel of: self			] span: 2.		]	]! !!WAChangePassword methodsFor: 'accessing' stamp: 'avi 2/6/2004 22:37'!username: aString	username _ aString! !!WAClosureTest methodsFor: 'actions' stamp: 'avi 1/23/2004 19:43'!ensure	[self go] ensure: [self inform: 'ensure']! !!WAClosureTest methodsFor: 'actions' stamp: 'mbany 4/14/2005 12:08'!go	|i|	i _ 1.	#(a b c) do: [:each | self inform: each displayString, ' ', i displayString. i _ i + 1]! !!WAClosureTest methodsFor: 'rendering' stamp: 'avi 1/23/2004 19:47'!renderContentOn: html	html anchorWithAction: [self go] text: 'go'.	html space.	html anchorWithAction: [self ensure] text: 'go with ensure'.! !!WAComponent class methodsFor: 'utilities' stamp: 'avi 11/16/2005 23:33'!applicationWithPath: aString	| app |	app _ WAApplication path: aString.	app configuration addAncestor: WARenderLoopConfiguration new.	app preferenceAt: #rootComponent put: self.	^ app! !!WAComponent class methodsFor: 'testing' stamp: 'lr 11/29/2004 16:16'!canBeRoot	"When returning true, the component can be registered as a standalone application from the config interface."		^ false! !!WAComponent class methodsFor: 'accessing' stamp: 'mb 5/26/2006 12:02'!description	^self name! !!WAComponent class methodsFor: 'testing' stamp: 'mb 5/26/2006 11:01'!isDeployed	"When returning true, the component is to be kept in a deployed system,	otherwise it is disabled"		^ false"	Usage:	1. 	Implement #isDeployed on the class side of		the deployed root components	2.	Evaluate the following		WADispatcher default trimForDeployment"! !!WAComponent class methodsFor: 'instance creation' stamp: 'avi 9/22/2004 13:57'!new	^ self basicNew initializeDecoration initialize! !!WAComponent class methodsFor: 'registration' stamp: 'mb 6/14/2006 15:14'!registerAsApplication: appName	^WADispatcher default		registerEntryPoint: (self applicationWithPath: appName)		path: appName! !!WAComponent class methodsFor: 'registration' stamp: 'mb 5/30/2006 12:28'!registerAsAuthenticatedApplication: appName	| app user password |	app _ self registerAsApplication: appName.	app configuration addAncestor: WAAuthConfiguration new.		[user _ SeasidePlatformSupport		request: ('Please choose an administrator\username for the application ''', appName displayString , '''') withCRs.		" Or can we do this instead ????		request: ('Please choose an administrator\username for the application ', appName printString) withCRs.		"	user = ''] whileTrue.			[password _ SeasidePlatformSupport		request: 'Please enter a password for ', user printString.	password = ''] whileTrue.			app preferenceAt: #login put: user.	app preferenceAt: #password put: password.		^ app	! !!WAComponent class methodsFor: 'utilities' stamp: 'mb 8/18/2006 10:24'!renderSampleInstance: aBlock	|session root context docRoot document|	session := WASession application: WAApplication new.	^ WACurrentSession use: session during:		[root := self new.		aBlock value: root.		context := WARenderingContext new request: WARequest new.		context actionUrl: (WAUrl new addToPath: 'action').		docRoot := session outputDocumentClass newRoot.		root visiblePresentersDo: [:ea | ea updateRoot: docRoot].		document := session outputDocumentClass root: docRoot.		context document: document.		root decorationChainDo: [:ea | ea renderWithContext: context].		document close.		document stream contents]! !!WAComponent methodsFor: 'convenience' stamp: 'avi 5/19/2004 14:18'!activeComponent	self visiblePresentersDo: [:ea | ea isDecoration ifFalse: [^ ea]]! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 6/2/2004 22:16'!addDecoration: newDecoration	| prev dec |	prev _ nil.	dec _ self decoration.	[dec ~~ self and: [self decoration: dec shouldWrap: newDecoration]] whileTrue:		[prev _ dec.		dec _ dec owner].	newDecoration owner: dec.	prev		ifNil: [self decoration: newDecoration]		ifNotNil: [prev owner: newDecoration].	^ newDecoration! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/27/2004 00:53'!addMessage: aString	self addDecoration: (WAMessageDecoration new message: aString)! !!WAComponent methodsFor: 'iterating' stamp: 'avi 10/19/2004 15:55'!allDecorationsDo: aBlock	| ea |	ea _ self decoration.	[ea notNil and: [ea ~~ self]] whileTrue:		[aBlock value: ea.		ea _ ea owner]! !!WAComponent methodsFor: 'call/answer' stamp: 'avi 3/27/2004 00:55'!answer	self answer: self! !!WAComponent methodsFor: 'call/answer' stamp: 'avi 6/8/2004 01:13'!answer: anObject	self decorationChainDo: [:ea | ea handleAnswer: anObject]! !!WAComponent methodsFor: 'convenience' stamp: 'ac 3/22/2006 15:04'!asComponent	^ self! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 00:55'!authenticateWith: anAuthenticator during: aBlock	^ self decorateWith: (WABasicAuthentication new authenticator: anAuthenticator) during: aBlock! !!WAComponent methodsFor: 'call/answer' stamp: 'avi 10/26/2004 15:40'!call: aComponent	^ AnswerContinuation currentDo: [:cc | self show: aComponent onAnswer: cc]! !!WAComponent methodsFor: 'accessing' stamp: 'lr 11/29/2004 16:17'!children	"This method is really important. It should return a collection of all subcomponents of the current component that will be rendered in #renderContentOn:. Components that are displayed using #call: are *not* children."		^ #()! !!WAComponent methodsFor: 'iterating' stamp: 'avi 6/8/2004 00:57'!childrenDo: aBlock	self children do: [:ea | ea ifNotNil: [aBlock value: ea]]! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/29/2004 19:07'!confirm: aString	^ self call: (WAYesOrNoDialog new addMessage: aString)! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 19:53'!decorateWith: aDecoration during: aBlock	| val |	self addDecoration: aDecoration.	val _ aBlock value.	self removeDecoration: aDecoration.	^ val! !!WAComponent methodsFor: 'accessing' stamp: 'avi 4/13/2004 20:36'!decoration	decoration ifNil: [decoration _ WAStateHolder new contents: self].	^ decoration contents! !!WAComponent methodsFor: 'accessing' stamp: 'avi 9/22/2004 13:59'!decoration: aDecoration	decoration contents: aDecoration! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:49'!decoration: oldDecoration shouldWrap: newDecoration	^ (oldDecoration isGlobal and: [newDecoration isGlobal not])		or: [oldDecoration isDelegation and: [newDecoration isLocal]]! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 4/22/2004 14:50'!decorationChainDo: aBlock	aBlock value: self decoration! !!WAComponent methodsFor: 'accessing' stamp: 'avi 10/19/2004 15:57'!delegations	| delegations |	delegations _ OrderedCollection new.	self allDecorationsDo: [:ea | ea isDelegation ifTrue: [delegations add: ea]].	^ delegations! !!WAComponent methodsFor: 'call/answer' stamp: 'avi 6/8/2004 01:13'!handleAnswer: anObject	^ false! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 10/19/2004 15:56'!home	self delegations do: [:ea | self removeDecoration: ea]! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/29/2004 19:07'!inform: aString	self call: (WAFormDialog new addMessage: aString)! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 13:59'!initializeDecoration	decoration _ WAStateHolder new contents: self! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/27/2004 00:56'!isolate: aBlock	|txn val |	txn _ WATransaction new.	val _ self decorateWith: txn during: aBlock.	txn close.	^ val! !!WAComponent methodsFor: 'iterating' stamp: 'avi 6/8/2004 00:59'!nextPresentersDo: aBlock	self childrenDo: [:ea | ea decorationChainDo: aBlock]! !!WAComponent methodsFor: 'call/answer' stamp: 'avi 6/8/2004 01:14'!onAnswer: aBlock	^ self addDecoration: (WAAnswerHandler new block: aBlock)! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'avi 7/6/2004 10:40'!removeDecoration: aDecoration	| dec |	dec _ self decoration.	dec = aDecoration ifTrue:		[self decoration: dec owner.		^ self].		[dec notNil] whileTrue:		[dec owner = aDecoration			ifTrue: [dec owner: aDecoration owner.  ^ self]			ifFalse: [dec _ dec owner]]! !!WAComponent methodsFor: 'as yet unclassified' stamp: 'lr 11/29/2004 16:19'!renderOn: aRenderer	"Do not override this methods on your component, override instead #renderContentOn: and in addition to not invoke directly renderContentOn: on subcomponent in such method but use instead html render: subcomponent."	self decorationChainDo: [ :each | each renderWithContext: aRenderer context ].! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/27/2004 00:56'!request: aString	^ self request: aString default: ''! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/27/2004 00:56'!request: aString default: initialString	^ self request: aString label: nil default: initialString! !!WAComponent methodsFor: 'convenience' stamp: 'avi 3/27/2004 00:56'!request: requestString label: labelString	^ self request: requestString label: labelString default: ''! !!WAComponent methodsFor: 'convenience' stamp: 'pmm 11/2/2005 23:45'!request: requestString label: labelString default: initialString	^ self call:		((WAInputDialog new			label: labelString;			default: initialString;			yourself)				addMessage: requestString)! !!WAComponent methodsFor: 'call/answer' stamp: 'mb 4/23/2006 10:43'!show: aComponent	self 		show: aComponent		onAnswer: [:value | ]! !!WAComponent methodsFor: 'call/answer' stamp: 'lr 4/19/2006 00:36'!show: aComponent onAnswer: aBlock	self 		show: aComponent 		onAnswer: aBlock 		delegation: (WADelegation new 			delegate: aComponent;			yourself)! !!WAComponent methodsFor: 'call/answer' stamp: 'mb 4/23/2006 10:43'!show: aComponent onAnswer: aBlock delegation: aDelegation	| event |	event _ nil.	event _ aComponent onAnswer: [:value |		aDelegation remove. 		event remove. 		aBlock value: value].	self addDecoration: aDelegation.	WARenderNotification raiseSignal! !!WAComponent methodsFor: 'convenience' stamp: 'cds 7/25/2005 10:24'!validateWith: aBlock	^self addDecoration: (WAValidationDecoration new validateWith: aBlock)! !!WAComponent methodsFor: 'iterating' stamp: 'avi 6/8/2004 00:58'!visiblePresentersDo: aBlock	self decorationChainDo: [:ea | ea withNextPresentersDo: aBlock]! !!WAApplicationEditor methodsFor: 'actions' stamp: 'avi 6/24/2004 00:30'!addLibrary	application libraries add: library! !!WAApplicationEditor methodsFor: 'accessing' stamp: 'pmm 4/23/2006 20:54'!allLibraries	^ (WAStyleLibrary subclasses, WAScriptLibrary subclasses)		asSortedCollection: [ :a :b | a name <= b name ]! !!WAApplicationEditor methodsFor: 'accessing' stamp: 'avi 3/23/2004 14:32'!application: anApplication	application _ anApplication.	configuration _ application configuration.! !!WAApplicationEditor methodsFor: 'accessing' stamp: 'avi 6/24/2004 00:23'!libraryOptions	^ self allLibraries difference: application libraries! !!WAApplicationEditor methodsFor: 'rendering' stamp: 'avi 3/23/2004 14:37'!renderContentOn: html	html heading: 'Application: ', application name.	super renderContentOn: html.! !!WAApplicationEditor methodsFor: 'rendering' stamp: 'pmm 6/28/2006 09:45'!renderFormOn: html	html text: 'Base Path: '.	html textInput on: #basePath of: application.		html heading level2 with: 'Libraries'.	self libraryOptions isEmpty ifFalse: [		html text: 'Add Library: '.		html select			list: self libraryOptions;			selected: nil;			callback: [:v | library := v].		html space.		html submitButton callback: [self addLibrary]; text: 'Add'.].	html unorderedList: [		application libraries do: [ :each |			html listItem: [				html text: each.				html space.				html anchor					callback: [application libraries remove: each];					with: '(remove)' ] ] ].		super renderFormOn: html! !!WAConfigurationEditor methodsFor: 'accessing' stamp: 'avi 3/23/2004 14:30'!configuration	^ configuration! !!WAConfigurationEditor methodsFor: 'accessing' stamp: 'avi 1/31/2004 12:02'!configuration: aConfiguration	configuration _ aConfiguration! !!WAConfigurationEditor methodsFor: 'actions' stamp: 'avi 3/23/2004 15:06'!done	self answer! !!WAConfigurationEditor methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:13'!initialize	super initialize.	configuration _ WAConfiguration new! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:01'!renderAncestryListFor: aConfiguration seen: aSet on: html	aConfiguration ancestors isEmpty ifTrue: [^ self].		html unorderedList: [		aConfiguration ancestors do: [ :each |			html listItem: [				self renderParent: each on: html.				(aSet includes: each) ifFalse: [					aSet add: each.					self renderAncestryListFor: each seen: aSet on: html ] ] ] ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:02'!renderAncestryOn: html	html div		style: 'border: 1px solid black; background: lightgrey';		with: [			html table: [				html heading level2; with: 'Configuration Ancestors' .				configuration potentialAncestors isEmpty ifFalse: [					html text: 'Add ancestor: '.					self renderParentSelectorOn: html ].				self renderAncestryListFor: configuration seen: Set new on: html ] ].! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'mb 2/17/2005 10:47'!renderAttribute: anAttribute on: html	html tableRow: [		html tableData: (self labelForSelector: anAttribute key).		html tableData: [			(configuration valueForAttribute: anAttribute)				ifNil: [self renderUnspecifiedAttribute: anAttribute on: html]				ifNotNil: 					[(configuration hasLocalValueForAttribute: anAttribute)						ifTrue: [self renderOverridenAttribute: anAttribute on: html]						ifFalse: [self renderInheritedAttribute: anAttribute on: html]]		].		self renderInheritanceForAttribute: anAttribute on: html]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:11'!renderContentOn: html	html form: [		self renderFormOn: html.				html break.		html submitButton on: #save of: self.		html submitButton on: #done of: self ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:06'!renderFormOn: html	self renderAncestryOn: html.	html break.	html div		style: 'border: 1px solid black';		with: [			html table: [				configuration groupedAttributes do: [ :associaction |						html tableRow: [							html tableData colSpan: 2; with: [ html heading level3; with: (self labelForSelector: associaction key) ] ].						associaction value do: [ :attribute |							self renderAttribute: attribute on: html ] ] ] ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:10'!renderInheritanceForAttribute: anAttribute on: html	configuration inheritedValueAndSourceAt: anAttribute key do: [:value :source |		(configuration hasLocalValueForAttribute: anAttribute)			ifTrue: [				html tableData: [					html anchor callback: [configuration clearValueForAttribute: anAttribute]; with: 'revert'.					html text: ' to: ', value printString].				html tableData: 'overriden from ', source name ]			ifFalse: [				html tableData: [					html anchor callback: [configuration overrideAttribute: anAttribute]; with: 'override'].				html tableData: 'inherited from ', source name ].		^ self ].	(configuration hasLocalValueForAttribute: anAttribute)		ifTrue: [			html tableData: [				html anchor callback: [configuration clearValueForAttribute: anAttribute]; with: 'clear']]		ifFalse: [			html tableData: [				html span					style: 'color: #ff0000';					with: '(unspecified)' ] ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'avi 3/23/2004 12:35'!renderInheritedAttribute: anAttribute on: html	html text: (configuration valueForAttribute: anAttribute) printString! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:11'!renderInheritedValueForAttribute: anAttribute on: html	| inheritedValue |	inheritedValue := (configuration lookupValueAt: anAttribute key).	inheritedValue isNil		ifTrue: [			html span				style: 'color: #ff0000';				with: '(unspecified)' ]		ifFalse: [ html text: inheritedValue printString ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:12'!renderLinkToAncestor: aConfiguration on: html	"html anchor callback: [self call: (WAConfigurationEditor new configuration: aConfiguration)]; with: aConfiguration"	html text: aConfiguration! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:12'!renderOverrideForAttribute: anAttribute on: html	html anchor callback: [configuration overrideAttribute: anAttribute]; with: 'edit'! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'avi 3/23/2004 12:34'!renderOverridenAttribute: anAttribute on: html	anAttribute accept: self with: html! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:15'!renderParent: aConfiguration on: html	html text: aConfiguration name.	html space.	(configuration hasMutableAncestry and: [configuration ancestors includes: aConfiguration]) ifTrue: [		html anchor			callback: [configuration removeAncestor: aConfiguration];			with: '(remove)' ]! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:13'!renderParentSelectorOn: html	|selectedAncestor|	selectedAncestor := ValueHolder new.	html select		list: configuration potentialAncestors;		selected: nil;		callback: [:v | selectedAncestor contents: v];		labels: [:ea | ea name].	html space.	html submitButton		callback: [configuration addAncestor: selectedAncestor contents];		text: 'Add'. ! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 20:15'!renderRevertForAttribute: anAttribute on: html	html anchor callback: [configuration clearValueForAttribute: anAttribute]; with: 'clear'! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'avi 3/23/2004 12:35'!renderUnspecifiedAttribute: anAttribute on: html	anAttribute accept: self with: html! !!WAConfigurationEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 19:59'!rendererClass	^ WARenderCanvas! !!WAConfigurationEditor methodsFor: 'actions' stamp: 'avi 3/23/2004 14:36'!save! !!WAConfigurationEditor methodsFor: 'actions' stamp: 'avi 3/23/2004 14:34'!select: aConfiguration	self call: (WAConfigurationEditor new configuration: aConfiguration)! !!WAConfigurationEditor methodsFor: 'accessing' stamp: 'avi 3/23/2004 14:40'!trailName	^ configuration name! !!WAConfigurationEditor methodsFor: 'rendering-visitors' stamp: 'pmm 4/23/2006 20:18'!visitBooleanAttribute: anAttribute with: html	html select		list: (Array with: true with: false);		selected: (configuration valueForAttribute: anAttribute);		callback: [:v | configuration takeValue: v forAttribute: anAttribute];		labels: [ :b | b ifTrue: [ 'true' ] ifFalse: [ 'false' ] ]! !!WAConfigurationEditor methodsFor: 'rendering-visitors' stamp: 'pmm 4/23/2006 20:19'!visitListAttribute: anAttribute with: html	html select		list: (Array with: nil), anAttribute options asArray;		selected: (configuration valueForAttribute: anAttribute);		callback: [ :value | (configuration takeValue: value forAttribute: anAttribute ) ];		labels: [ :each | each ifNil: ['None'] ifNotNil: [ each displayString] ]! !!WAConfigurationEditor methodsFor: 'rendering-visitors' stamp: 'pmm 4/23/2006 20:20'!visitNumberAttribute: anAttribute with: html	html textInput		size: 5;		callback: [ :value | configuration takeValue: value asNumber forAttribute: anAttribute ];		value: (configuration valueForAttribute: anAttribute)! !!WAConfigurationEditor methodsFor: 'rendering-visitors' stamp: 'lr 5/3/2006 09:57'!visitPasswordAttribute: anAttribute with: html	html passwordInput 		callback: [ :value | configuration takeValue: (anAttribute valueFromString: value) forAttribute: anAttribute ]! !!WAConfigurationEditor methodsFor: 'rendering-visitors' stamp: 'lr 5/3/2006 09:58'!visitStringAttribute: anAttribute with: html	html textInput		callback: [ :value | configuration takeValue: (anAttribute valueFromString: value) forAttribute: anAttribute ];		value: (configuration valueForAttribute: anAttribute)! !!WACounter class methodsFor: 'testing' stamp: 'avi 2/5/2004 12:58'!canBeRoot	^ true! !!WACounter class methodsFor: 'accessing' stamp: 'mb 5/26/2006 12:26'!description	^'A very simple Seaside application'! !!WACounter class methodsFor: 'examples' stamp: 'ab 6/14/2003 19:02'!example	^ self new! !!WACounter class methodsFor: 'class initialization' stamp: 'ab 1/15/2003 01:07'!initialize	(self registerAsApplication: 'counter')! !!WACounter methodsFor: 'accessing' stamp: 'avi 2/3/2004 00:59'!count	^ count! !!WACounter methodsFor: 'actions' stamp: 'pmm 7/19/2006 18:49'!decrease	count := count - 1! !!WACounter methodsFor: 'actions' stamp: 'pmm 7/19/2006 18:49'!increase	count := count + 1! !!WACounter methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:16'!initialize	super initialize.	self session registerObjectForBacktracking: self.	count := 0! !!WACounter methodsFor: 'rendering' stamp: 'pmm 7/19/2006 18:50'!renderContentOn: html	html heading: count.	html anchor callback: [self increase]; text: '++'.	html space.	html anchor callback: [self decrease]; text: '--'! !!WACounter methodsFor: 'rendering' stamp: 'pmm 7/19/2006 18:48'!rendererClass	^WARenderCanvas! !!WADateSelector methodsFor: 'accessing' stamp: 'cds 2/22/2005 14:22'!date	(self privateIsValidDay: day monthNumber: month year: year)		ifFalse: [self error: 'Invalid date'].	^ Date newDay: day monthNumber: month year: year! !!WADateSelector methodsFor: 'accessing' stamp: 'ab 2/17/2003 13:52'!date: aDate	day _ aDate dayOfMonth.	month _ aDate monthIndex.	year _ aDate year.! !!WADateSelector methodsFor: 'testing' stamp: 'ab 2/17/2003 13:53'!dateIsValid	[self date] on: Error do: [:e | ^ false].	^ true! !!WADateSelector methodsFor: 'accessing' stamp: 'ac 11/25/2003 12:06'!days	^ 1 to: 31! !!WADateSelector methodsFor: 'accessing' stamp: 'JF 8/14/2003 14:44'!endYear	^ endYear! !!WADateSelector methodsFor: 'accessing' stamp: 'JF 8/14/2003 14:41'!endYear: anInteger	endYear _ anInteger! !!WADateSelector methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:16'!initialize	super initialize.	startYear _ Date today year - 1.	endYear _ Date today year + 5.	self date: Date today.! !!WADateSelector methodsFor: 'accessing' stamp: 'ac 11/25/2003 12:34'!labelForDay: aNumber	^ aNumber! !!WADateSelector methodsFor: 'accessing' stamp: 'ac 11/25/2003 12:33'!labelForMonth: aNumber	^ Date nameOfMonth: aNumber! !!WADateSelector methodsFor: 'accessing' stamp: 'ac 11/25/2003 12:34'!labelForYear: aNumber	^ aNumber! !!WADateSelector methodsFor: 'accessing' stamp: 'ac 11/25/2003 12:06'!months	^ 1 to: 12! !!WADateSelector methodsFor: 'private' stamp: 'avi 7/11/2005 12:44'!privateIsValidDay: theDay monthNumber: theMonth year: theYear	| maxDay |	theMonth > 0 & (theMonth <= 12) ifFalse: [^false].	maxDay := Month daysInMonth: theMonth forYear: theYear.	^theDay > 0 & (theDay <= maxDay)! !!WADateSelector methodsFor: 'rendering' stamp: 'ac 11/25/2003 12:33'!renderContentOn: html	html selectFromList: self months selected: month callback: [:i | month _ i] labels: [:ea | self labelForMonth: ea].	html selectFromList: self days selected: day callback: [:i | day _ i] labels: [:ea | self labelForDay: ea].	html selectFromList: self yearRange selected: year callback: [:i | year _ i] labels: [:ea | self labelForYear: ea].		self dateIsValid ifFalse: [self renderValidationErrorOn: html].! !!WADateSelector methodsFor: 'rendering' stamp: 'ab 5/25/2003 16:32'!renderValidationErrorOn: html	html spanClass: 'error' with: 'invalid date'! !!WADateSelector methodsFor: 'accessing' stamp: 'JF 8/14/2003 14:44'!startYear	^ startYear! !!WADateSelector methodsFor: 'accessing' stamp: 'JF 8/14/2003 14:40'!startYear: anInteger	startYear _ anInteger! !!WADateSelector methodsFor: 'accessing' stamp: 'JF 8/14/2003 14:43'!yearRange	^ self startYear to: self endYear! !!WADateSelectorTest class methodsFor: 'examples' stamp: 'mb 2/10/2006 13:18'!example	^self new.! !!WADateSelectorTest class methodsFor: 'class initialization' stamp: 'lr 6/13/2006 16:10'!initialize	self registerAsApplication: 'tests/dateselector'! !!WADateSelectorTest methodsFor: 'accessing' stamp: 'mb 4/21/2006 17:13'!children	^(OrderedCollection new)		add: beginDate;		add: endDate;		add: beginTime;		add: endTime;		add: beginDAT;		add: endDAT;		yourself.! !!WADateSelectorTest methodsFor: 'initialization' stamp: 'pmm 7/19/2006 19:51'!initialize	super initialize.	beginDate := WADateSelector new.	endDate := WADateSelector new.	endDate date: (Date today addDays: 1).	beginTime := WATimeSelector new.	beginTime time: Time now.	endTime := WATimeSelector new.	endTime time: (beginTime time addSeconds: 3600).	beginDAT := WADateTimeSelector new.	endDAT := WADateTimeSelector new.	endDAT dateAndTime: beginDAT dateAndTime + 1 day + 1 hour! !!WADateSelectorTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:11'!renderContentOn: html	self renderDateSelectorsOn: html.	html horizontalRule.	self renderTimeSelectorsOn: html.	html horizontalRule.	self renderDateTimeSelectorsOn: html.! !!WADateSelectorTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:04'!renderDateSelectorsOn: html	html heading: 'Dates' level: 3.	html form:		[html table:			[html tableRow: [html tableData: 'From'; tableData: beginDate].			html tableRow: [html tableData: 'To'; tableData: endDate]].		html submitButton			callback: [self inform: (endDate date - beginDate date) days printString , ' day(s)'];			text: 'Compute duration'].! !!WADateSelectorTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:08'!renderDateTimeSelectorsOn: html	html heading: 'Dates and Times' level: 3.	html form:		[html table:			[html tableRow: [html tableData: 'From'; tableData: beginDAT].			html tableRow: [html tableData: 'To'; tableData: endDAT]].		html submitButton			callback: [| dateDiff |				dateDiff _ (endDAT dateAndTime asDate - beginDAT dateAndTime asDate) days.				dateDiff isZero 					ifFalse: [self inform: dateDiff printString , ' day(s)']					ifTrue:						[self inform: (endDAT dateAndTime asTime										subtractTime: beginDAT dateAndTime asTime) asSeconds printString ,										' second(s)']];			text: 'Compute duration'].! !!WADateSelectorTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 21:11'!renderTimeSelectorsOn: html	html heading: 'Times' level: 3.	html form:		[html table:			[html tableRow: [html tableData: 'From'; tableData: beginTime].			html tableRow: [html tableData: 'To'; tableData: endTime]].		html submitButton			callback: [self inform: (endTime time subtractTime: beginTime time) asSeconds printString , ' seconds(s)'];			text: 'Compute duration'].! !!WADateSelectorTest methodsFor: 'rendering' stamp: 'dc 7/21/2006 20:58'!rendererClass	^ WARenderCanvas ! !!WADateTable methodsFor: 'enumerating' stamp: 'ab 2/18/2003 14:52'!datesDo: aBlock separatedBy: monthlyBlock	| month|	month _ datesCache first monthIndex.	datesCache do:		[:date |		date monthIndex = month ifFalse: [month _ date monthIndex. monthlyBlock value].		aBlock value: date].	monthlyBlock value.! !!WADateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 20:56'!endDate: aDate	endDate _ aDate.	self updateDatesCache.! !!WADateTable methodsFor: 'enumerating' stamp: 'ab 2/17/2003 16:19'!monthsAndLengthsDo: aBlock	|count last|	count _ 0.	self		datesDo: [:ea | count _ count + 1. last _ ea]		separatedBy: [aBlock value: last month value: count.						count _ 0]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 16:59'!renderCellForDate: aDate row: anObject index: aNumber on: html	html tableData: [html space]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 5/28/2003 15:12'!renderContentOn: html	html attributes border: 1.	html cssClass: 'DateTable'; table: [		html tableRow: [self renderMonthHeadingsOn: html].		html tableRow: [self renderDayHeadingsOn: html].		rows withIndexDo:			[:ea :i|			html tableRow: [self renderRow: ea index: i on: html]].	]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 16:20'!renderDayHeadingsOn: html	self renderHeadingSpacerOn: html.	self		datesDo: [:date | html cssClass: 'DayHeading'; tableHeading: [html text: date dayOfMonth]]		separatedBy: [self renderHeadingSpacerOn: html]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 14:50'!renderHeadingForRow: anObject on: html	html cssClass: 'RowHeading'; tableHeading: [html text: anObject]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 16:22'!renderHeadingSpacerOn: html	html tableData: []! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 16:14'!renderMonthHeadingsOn: html	self monthsAndLengthsDo:		[:month :length |		self renderHeadingSpacerOn: html.		html			cssClass: 'MonthHeading';			attributeAt: 'colspan' put: length;			tableHeading: [html text: month name; space; text: month year]]! !!WADateTable methodsFor: 'rendering' stamp: 'ab 2/18/2003 14:51'!renderRow: anObject index: aNumber on: html	self renderHeadingForRow: anObject on: html.	self		datesDo: [:date | self renderCellForDate: date row: anObject index: aNumber on: html]			separatedBy: [	self renderHeadingSpacerOn: html ]! !!WADateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 14:11'!rows: aCollection	rows _ aCollection! !!WADateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 20:56'!startDate: aDate	startDate _ aDate.	self updateDatesCache.! !!WADateTable methodsFor: 'actions' stamp: 'ab 2/17/2003 20:58'!updateDatesCache	| date |	(startDate isNil or: [endDate isNil]) ifTrue: [^ self].		datesCache _ OrderedCollection new.	date _ startDate.	[date > endDate] whileFalse:		[datesCache add: date.		date _ date next]! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:23'!clearSelection	dateSelectionStart _ dateSelectionEnd _ rowSelectionStart _ rowSelectionEnd _ nil! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:19'!colorForDate: aDate rowIndex: aNumber	^ (self hasSelection		and: [self selectionContainsDate: aDate rowIndex: aNumber])			ifTrue: ['lightgrey']			ifFalse: ['white']! !!WASelectionDateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 19:56'!endDate: aDate	self clearSelection.	super endDate: aDate! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:22'!endDateSelection	^ dateSelectionStart ifNotNil: [dateSelectionStart max: dateSelectionEnd]! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 19:40'!endRow	^ rowSelectionStart max: rowSelectionEnd! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:27'!endRowSelection	^ rowSelectionStart ifNotNil: [rows at: (rowSelectionStart max: rowSelectionEnd)]! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:02'!hasSelection	^ dateSelectionStart notNil! !!WASelectionDateTable methodsFor: 'rendering' stamp: 'mb 2/9/2006 18:53'!renderCellForDate: aDate row: anObject index: aNumber on: html	| text |	html attributes		backgroundColor: (self colorForDate: aDate rowIndex: aNumber);		alignCenter.	html tableData: [		text _ cellBlock value: anObject value: aDate.		html anchorWithAction: [self selectDate: aDate rowIndex: aNumber] text: text.	]! !!WASelectionDateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 19:56'!rows: aCollection	self clearSelection.	super rows: aCollection! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 16:48'!rowsAndDatesDisplay: aBlock	cellBlock _ aBlock! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 20:04'!selectAll	dateSelectionStart _ startDate.	dateSelectionEnd _ endDate.	rowSelectionStart _ 1.	rowSelectionEnd _ rows size.! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:05'!selectDate: aDate rowIndex: rowIndex	self hasSelection		ifFalse: [dateSelectionStart _ dateSelectionEnd _ aDate. rowSelectionStart _ rowSelectionEnd _ rowIndex]		ifTrue: [dateSelectionEnd _ aDate. rowSelectionEnd _ rowIndex]! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 19:40'!selectedRows	^ rows copyFrom: self startRow to: self endRow! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:18'!selectionContainsDate: aDate rowIndex: aNumber	^ ((aDate between: dateSelectionStart and: dateSelectionEnd) or: [aDate between: dateSelectionEnd and: dateSelectionStart])		and: [(aNumber between: rowSelectionStart and: rowSelectionEnd) or: [aNumber between: rowSelectionEnd and: rowSelectionStart]]! !!WASelectionDateTable methodsFor: 'accessing' stamp: 'ab 2/17/2003 19:56'!startDate: aDate	self clearSelection.	super startDate: aDate! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:22'!startDateSelection	^ dateSelectionStart ifNotNil: [dateSelectionStart min: dateSelectionEnd]! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 19:40'!startRow	^ rowSelectionStart min: rowSelectionEnd! !!WASelectionDateTable methodsFor: 'as yet unclassified' stamp: 'ab 2/17/2003 17:27'!startRowSelection	^ rowSelectionStart ifNotNil: [rows at: (rowSelectionStart min: rowSelectionEnd)]! !!WASelectionDateTable methodsFor: 'rendering' stamp: 'ab 2/17/2003 22:43'!style	^ 'td a {text-decoration: none}'! !!WADateTimeSelector methodsFor: 'accessing' stamp: 'jlr 4/5/2006 00:19'!children	^ Array with: dateSelector with: timeSelector! !!WADateTimeSelector methodsFor: 'accessing' stamp: 'jlr 4/5/2006 00:22'!dateAndTime	^ DateAndTime date: dateSelector date time: timeSelector time! !!WADateTimeSelector methodsFor: 'accessing' stamp: 'mb 4/21/2006 17:22'!dateAndTime: anObject	dateSelector date: anObject asDate.	timeSelector time: anObject asTime.! !!WADateTimeSelector methodsFor: 'initialize-release' stamp: 'mb 5/6/2006 16:07'!initialize	super initialize.	dateSelector _ WADateSelector new.	timeSelector _ WATimeSelector new.! !!WADateTimeSelector methodsFor: 'rendering' stamp: 'mb 4/22/2006 21:12'!renderContentOn: html	html span: [html render: dateSelector].	html span: [html bold: ' : '].	html span: [html render: timeSelector].! !!WADefaultFormTest methodsFor: 'rendering' stamp: 'mb 4/5/2006 07:21'!renderContentOn: html	html formWithDefaultAction: [self inform: 'Default: ', value displayString] do: 		[		html submitButtonWithAction: [self inform: 'Before: ', value displayString] text: 'Before'.		html break.		html textInputWithValue: '' callback: [:v | value _ v].		html submitButtonWithAction: [self inform: 'Go: ' , value displayString] text: 'Go'.		html break.		html submitButtonWithAction: [self inform: 'After: ', value displayString] text: 'After']! !!WADelayTest methodsFor: 'actions' stamp: 'avi 3/27/2005 20:39'!go	self call: (WAComponent new				addMessage: '3 seconds';				addDecoration: (WADelayedAnswerDecoration new delay: 3);				yourself)! !!WADelayTest methodsFor: 'rendering' stamp: 'avi 3/27/2005 20:35'!renderContentOn: html	html anchorWithAction: [self go] text: 'go'! !!WADispatcherEditor class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:34'!actionsFor: anEntryPoint inEditor: anEditor	| actions |	"Answer an OrderedCollectionn of associations"	actions _ OrderedCollection new.	self plugins do:		[:each | actions addAll: (each editorActionsFor: anEntryPoint inEditor: anEditor)].	^actions.! !!WADispatcherEditor class methodsFor: 'plugins' stamp: 'mb 6/18/2006 22:12'!addPlugin: aClass	(self plugins includes: aClass) ifFalse:		[self plugins add: aClass]! !!WADispatcherEditor class methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 12:56'!canBeRoot 	^ true! !!WADispatcherEditor class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 12:27'!description	^'Seaside configuration tool (Requires authentication)'! !!WADispatcherEditor class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:41'!editorActionsFor: anEntryPoint inEditor: anEditor	^OrderedCollection new		add: ((Dictionary new)				at: #label put: 'configure';				at: #action put: [anEditor configure: anEntryPoint];				yourself);		add: ((Dictionary new)				at: #label put: 'remove';				at: #action put: [anEditor remove: anEntryPoint];				yourself);		yourself! !!WADispatcherEditor class methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 21:08'!initialize	self registerAsAuthenticatedApplication: 'config'! !!WADispatcherEditor class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 09:23'!isDeployed	^ true! !!WADispatcherEditor class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:16'!plugins	^plugins ifNil: [plugins _ self standardPlugins].! !!WADispatcherEditor class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:20'!standardPlugins	^OrderedCollection with: self! !!WADispatcherEditor methodsFor: 'actions' stamp: 'mb 6/16/2006 18:28'!actionsFor: anEntryPoint	^self class actionsFor: anEntryPoint inEditor: self! !!WADispatcherEditor methodsFor: 'actions' stamp: 'mb 6/14/2006 15:19'!addEntryPoint	| entryPoint |	path isEmpty ifTrue: [^ self inform: 'You must enter a path.'].	entryPoint _ type new.	dispatcher registerEntryPoint: entryPoint path: path.	self configure: entryPoint! !!WADispatcherEditor methodsFor: 'actions' stamp: 'JF 9/22/2003 20:15'!clearCaches	WARegistry clearAllHandlers.	Smalltalk garbageCollect! !!WADispatcherEditor methodsFor: 'actions' stamp: 'avi 3/24/2004 12:17'!configure: anEntryPoint	anEntryPoint configurationComponent ifNotNilDo: [:c | self call: c]! !!WADispatcherEditor methodsFor: 'accessing' stamp: 'ab 8/26/2003 21:13'!dispatcher: aDispatcher	dispatcher _ aDispatcher! !!WADispatcherEditor methodsFor: 'accessing' stamp: 'ab 8/26/2003 21:52'!entryPointClasses	^ WAEntryPoint concreteSubclasses! !!WADispatcherEditor methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:16'!initialize	super initialize.	dispatcher _ WADispatcher default.	type _ WAApplication.	path _ ''.! !!WADispatcherEditor methodsFor: 'actions' stamp: 'ab 8/26/2003 21:34'!remove: anEntryPoint	dispatcher removeEntryPoint: anEntryPoint! !!WADispatcherEditor methodsFor: 'rendering' stamp: 'mb 10/12/2006 20:20'!renderContentOn: html	self renderTopOn: html.	html heading: 'Seaside'.	html div		style: 'font-size: 75%; margin-top: -2em; margin-bottom: 2em';		with: SeasidePlatformSupport versionString.		html bold: dispatcher basePath.	dispatcher isRoot ifFalse:		[html break; break.		html text: '['.		html anchor callback: [self answer]; text: [html bold: '..'].		html text: '] Up folder'].	html break; break.	html table: [			dispatcher genuineEntryPoints keysSortedSafely do:					[:name |					self						renderRowForEntryPoint: (dispatcher entryPointAt: name)						named: name						on: html].		].	html paragraph.	html form: [		html bold: 'default entry point: '.		html select			list: dispatcher entryPoints keysSortedSafely;			on: #defaultPath of: dispatcher;			beOptional;			labels: [ :v | v isNil ifFalse: [ v ] ifTrue: [ '(none)' ] ].		html space.		html submitButton].	html paragraph.		html bold: 'add entry point: '.	html form: [		html table: [			html tableRow: [				html tableData class: 'label:'; with: 'Path:'.				html tableData: [ 					html textInput value: ''; callback: [ :n | path := n]				]			].			html tableRow: [				html tableData class: 'label'; with: 'Type:'.				html tableData: [					html select 						list: self entryPointClasses;						on: #type of: self;						labels: [:ea | ea description].				html space.				html submitButton callback: [self addEntryPoint]; text: 'Add']			].		]	].	html preformatted: SeasidePlatformSupport vmStatisticsReportString.	html anchor callback: [self clearCaches]; with: 'Clear Caches'.	! !!WADispatcherEditor methodsFor: 'rendering' stamp: 'mb 6/16/2006 18:42'!renderRowForEntryPoint: anEntryPoint named: aString on: html	html tableRow: [		html tableData: [			anEntryPoint isApplication ifTrue:					[html anchor url: anEntryPoint basePath; with: aString]			ifFalse:				[html text: '['.				html anchor callback: [self configure: anEntryPoint]; text: aString.				html text: ']'].		].		html tableData: [			(self actionsFor: anEntryPoint) do:				[:each |				html anchor callback: (each at: #action); with: (each at: #label)]			separatedBy: [html space].		].	]! !!WADispatcherEditor methodsFor: 'rendering' stamp: 'mb 6/12/2006 14:31'!renderTopOn: html	html image		fileName: 'seaside-top.jpg';		mimeType: 'image/jpeg';		document: SeasidePlatformSupport seasideBanner! !!WADispatcherEditor methodsFor: 'rendering' stamp: 'pmm 4/23/2006 19:43'!rendererClass	^ WARenderCanvas! !!WADispatcherEditor methodsFor: 'accessing' stamp: 'pmm 4/23/2006 19:53'!type	^type! !!WADispatcherEditor methodsFor: 'accessing' stamp: 'pmm 4/23/2006 19:53'!type: aClass 	type := aClass! !!WADispatcherEditor methodsFor: 'actions' stamp: 'avi 3/16/2004 12:29'!verifyPassword: pass forUser: user	^ user = 'fooz' and: [pass = 'bar']! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:34'!canBeRoot	^true! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'kph 10/11/2006 02:38'!editorActionsFor: anEntryPoint inEditor: anEditor	(anEntryPoint isApplication and: 		[ anEntryPoint hasPreferenceGroup: self showForAppWithGroup]) ifFalse: [ ^ #() ]. 	^(OrderedCollection new) 		add: ((Dictionary new)				at: #label put: self label;				at: #action put: [ anEditor call: (self launch: anEntryPoint) ];				yourself);		yourself.! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:35'!initialize 	self registerAsDispatcherEditorPlugin. ! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:35'!label	^ ''! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:35'!launch: anEntryPoint	| plugin |	plugin := self new application: anEntryPoint.	plugin addDecoration: (WAWindowDecoration new title: plugin title; yourself).	^plugin! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:35'!registerAsDispatcherEditorPlugin	 ^ self label notEmpty ifTrue: [ WADispatcherEditor addPlugin: self ]! !!WADispatcherEditorPlugin class methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:35'!showForAppWithGroup	" e.g. for all apps return #general "	^ self label! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:30'!application 	^application! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:30'!application: app	application := app! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:34'!psuedoAppSession	^psuedoAppSession ifNil: [ 		psuedoAppSession := application sessionClass application: application ]! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:33'!renderContentOn: html	"customize"	html bold: 'Dispatcher Editor Plugin: ', self class label, ' on application ', application name! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:33'!rendererClass	^ WARenderCanvas ! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:33'!title	^ self class name, ' - ', application name, ' (', application basePath, ')'! !!WADispatcherEditorPlugin methodsFor: 'as yet unclassified' stamp: 'mb 10/7/2006 11:38'!usingAppSession: aBlock	WACurrentSession use: self psuedoAppSession during: aBlock! !!WADispatcherNavigator class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 11:53'!canBeRoot 	^ true! !!WADispatcherNavigator class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 11:54'!initialize	self registerAsApplication: 'browse'! !!WADispatcherNavigator class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 11:54'!isDeployed	^ true! !!WADispatcherNavigator methodsFor: 'actions' stamp: 'mb 5/26/2006 12:07'!browse: anEntryPoint	self call: (WADispatcherNavigator new dispatcher: anEntryPoint)! !!WADispatcherNavigator methodsFor: 'initialization' stamp: 'mb 5/26/2006 12:08'!dispatcher: aDispatcher	dispatcher _ aDispatcher! !!WADispatcherNavigator methodsFor: 'initialization' stamp: 'mb 5/26/2006 12:03'!initialize	super initialize.	dispatcher _ WADispatcher default.	path _ ''.! !!WADispatcherNavigator methodsFor: 'rendering' stamp: 'mb 10/17/2006 11:21'!renderContentOn: html	| entryPoints |	self renderTopOn: html.	html heading: 'Seaside'.	html div		style: 'font-size: 75%; margin-top: -2em; margin-bottom: 2em';		with: SeasidePlatformSupport versionString.		html bold: dispatcher basePath.	dispatcher isRoot ifFalse:		[html break; break.		html text: '['.		html anchor callback: [self answer]; text: [html bold: '..'].		html text: '] Up folder'].	html break; break.	entryPoints := dispatcher genuineEntryPoints reject: [:each | each isFileHandler].	html table:		[entryPoints keysSortedSafely do:			[:name |			| entryPoint |			entryPoint := dispatcher entryPointAt: name.			(entryPoint isDispatcher or: [entryPoint rootComponent ~~ self class]) ifTrue:				[self					renderRowForEntryPoint: entryPoint					named: name					on: html]]].! !!WADispatcherNavigator methodsFor: 'rendering' stamp: 'mb 5/26/2006 12:37'!renderRowForEntryPoint: anEntryPoint named: aString on: html	html tableRow:		[html tableData			with:				[anEntryPoint isApplication ifTrue:						[html anchor url: anEntryPoint basePath; newTarget; with: aString]				ifFalse:					[html text: '['.					html anchor callback: [self browse: anEntryPoint]; text: aString.					html text: ']']].		html tableData			addStyle: 'padding-left: 1em';			with: anEntryPoint description]! !!WADispatcherNavigator methodsFor: 'rendering' stamp: 'mb 6/12/2006 14:32'!renderTopOn: html	html image		fileName: 'seaside-top.jpg';		mimeType: 'image/jpeg';		document: SeasidePlatformSupport seasideBanner! !!WADispatcherNavigator methodsFor: 'rendering' stamp: 'mb 5/26/2006 11:56'!rendererClass	^ WARenderCanvas! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:40'!body: aString	body _ aString! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:40'!from: fromString	from _ fromString! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:40'!notice: aString	notice _ aString! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:41'!renderContentOn: html	| url |	url _ html urlForAction: [self answer].	self sendMessageWithUrl: url.	html divClass: 'notice' with: notice! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'lr 3/27/2006 09:04'!sendMessageWithUrl: urlString	SeasidePlatformSupport		deliverMailFrom: from		to: (Array with: to)		text: ('Subject: ' , subject , '' , urlString , '		' , body)! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:40'!subject: aString	subject _ aString! !!WAEmailConfirmation methodsFor: 'as yet unclassified' stamp: 'avi 3/10/2004 15:40'!to: toString	to _ toString! !!WAEncodingTest methodsFor: 'rendering' stamp: 'jf 2/18/2004 15:15'!renderContentOn: html	| w allChars r |	w := WriteStream on: String new.	32 to: 255 do: [ :c |  w nextPut: c asCharacter ].	allChars := w contents.	html code: [ 		html text: 'Start'; break.		r := ReadStream on: allChars.		[ r atEnd ] whileFalse: [ 			html text: (r next: 14);			break.		].		html text: 'End'; 			  break.	].	html text: 'Characters Encoded: '.	'Hello World' do: [ :c | html encodeCharacter: c ]. 	html break.! !!WAErrorTest methodsFor: 'rendering' stamp: 'avi 3/28/2004 21:24'!renderContentOn: html	html anchorWithAction: [1/0] text: 'Raise error'.	html break.	html anchorWithAction: [self notify: 'Really?'. self inform: 'Ok!!'] text: 'Raise warning'.! !!WAExampleBrowser commentStamp: '<historical>' prior: 0!I browse all the examples available in the system ie all the results of class methods beginning with #example... point your browser to localhost:xxx/seaside/examplesIf you want to see these examples/seaside/config app:- add a new application named "examples"- choose WAExampleBrowser as the root component!!WAExampleBrowser class methodsFor: 'testing' stamp: 'avi 2/5/2004 12:58'!canBeRoot	^ true! !!WAExampleBrowser class methodsFor: 'accessing' stamp: 'mb 5/26/2006 12:29'!description	^'Browse through Seaside examples'! !!WAExampleBrowser class methodsFor: 'class initialization' stamp: 'mb 6/13/2006 17:02'!initialize	self registerAsApplication: 'examples/examplebrowser'.! !!WAExampleBrowser methodsFor: 'helper' stamp: 'ab 6/14/2003 19:01'!allClasses	^ (WAComponent allSubclasses select: [:ea | ea class selectors anySatisfy: [:s | s beginsWith: self selectorPrefix]])		asSortedCollection: [:a :b | a name < b name]! !!WAExampleBrowser methodsFor: 'helper' stamp: 'ab 6/14/2003 19:01'!allSelectors	^ (class class selectors select: [:s | s beginsWith: self selectorPrefix])		asSortedCollection! !!WAExampleBrowser methodsFor: 'accessing' stamp: 'lr 11/29/2004 16:21'!children	^ Array with: component! !!WAExampleBrowser methodsFor: 'accessing' stamp: 'pmm 6/23/2005 08:52'!class: aClass	class := aClass.	self selector: self allSelectors first! !!WAExampleBrowser methodsFor: 'accessing' stamp: 'ab 6/15/2003 12:33'!component: aComponent	component _ aComponent.	hasAnswer _ false.	answer _ nil.	component onAnswer: [:v | hasAnswer _ true. answer _ v].! !!WAExampleBrowser methodsFor: 'initialize' stamp: 'pmm 11/2/2005 22:35'!initialize	super initialize.	self class: self allClasses first! !!WAExampleBrowser methodsFor: 'rendering' stamp: 'pmm 6/23/2005 08:52'!renderContentOn: html	html cssId: 'test-forms'; table: [		html tableRowWith: [			html form: [				html selectFromList: self allClasses selected: class callback: [:c | self class: c].				html submitButtonWithText: 'OK'.			].		] with: [			html form: [				html selectFromList: self allSelectors selected: selector callback: [:s | self selector: s].			 	html submitButtonWithText: 'OK'.			]		].	].	html horizontalRule.	html render: component.	hasAnswer ifTrue:		[html horizontalRule.		html bold: 'Answer '; text: answer printString]! !!WAExampleBrowser methodsFor: 'accessing' stamp: 'ab 6/14/2003 19:04'!selector: aSymbol	selector _ aSymbol.	self component: (class perform: selector)! !!WAExampleBrowser methodsFor: 'helper' stamp: 'ab 6/14/2003 19:02'!selectorPrefix	^ 'example'! !!WAExpiryTest class methodsFor: 'as yet unclassified' stamp: 'mb 6/13/2006 17:03'!install	(self registerAsApplication: 'tests/expiry')		 preferenceAt: #sessionClass put: WAExpirySession! !!WAExpiryTest methodsFor: 'rendering' stamp: 'mb 5/26/2006 09:15'!renderContentOn: html	html table: [		html tableRowWithLabel: 'Live session instances' column: WAExpirySession allInstances size.		html tableRowWithLabel: 'Live component instances' column: self class allInstances size.		html tableRowWithLabel: 'Sessions created' column: WAExpirySession created.		html tableRowWithLabel: 'Sessions unregistered' column: WAExpirySession unregistered.	].	html anchorWithUrl: self session newSessionUrl do: 'New Session'.	html break.	html anchorWithAction: [self session expire] text: 'Expire'.	html break.	html anchorWithAction: [WAExpirySession resetCounters] text: 'Reset Counters'.	html break.	html anchorWithAction: [Smalltalk garbageCollect] text: 'Garbage Collect'.	html break.	html anchorWithAction: [self session application clearHandlers. Smalltalk garbageCollect] text: 'Clear Handlers'.	html break.	html anchorWithAction: [self session application clearHandlers. WAExpirySession resetCounters. 	Smalltalk garbageCollect.] text: 'Reset All'.	html form: [		html text: 'Expiry seconds:'.		html			textInputWithValue: self session application sessionExpirySeconds			callback: [:v | self session application preferenceAt: #sessionExpirySeconds put: v].		html space.		html submitButton]	! !!WAChoiceDialog class methodsFor: 'as yet unclassified' stamp: 'avi 3/21/2004 00:59'!options: aCollection	^ self new options: aCollection! !!WAChoiceDialog methodsFor: 'accessing' stamp: 'avi 3/21/2004 01:00'!buttons	^ #(ok cancel)! !!WAChoiceDialog methodsFor: 'actions' stamp: 'avi 3/21/2004 01:00'!cancel	self answer: nil! !!WAChoiceDialog methodsFor: 'actions' stamp: 'avi 3/21/2004 01:00'!ok	self answer: selection! !!WAChoiceDialog methodsFor: 'accessing' stamp: 'avi 3/21/2004 00:59'!options	^ options! !!WAChoiceDialog methodsFor: 'accessing' stamp: 'avi 3/21/2004 00:59'!options: aCollection	options _ aCollection! !!WAChoiceDialog methodsFor: 'rendering' stamp: 'avi 3/21/2004 01:00'!renderContentOn: html	html selectFromList: options selected: nil  callback: [:v | selection _ v]! !!WAFormDialog methodsFor: 'actions' stamp: 'avi 3/16/2004 13:45'!addForm	form _ WAFormDecoration new buttons: self buttons.	self addDecoration: form! !!WAFormDialog methodsFor: 'testing' stamp: 'avi 3/16/2004 14:05'!addFormByDefault	^ true! !!WAFormDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 16:37'!buttons	^ #(ok)! !!WAFormDialog methodsFor: 'accessing' stamp: 'mb 4/4/2006 13:41'!defaultButton	^self buttons first! !!WAFormDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 20:41'!divClass	^ self class name! !!WAFormDialog methodsFor: 'initialization' stamp: 'pmm 11/2/2005 22:51'!initialize	super initialize.	self addFormByDefault ifTrue: [self addForm]! !!WAFormDialog methodsFor: 'testing' stamp: 'avi 3/12/2004 16:35'!isValid	^ validationError isNil! !!WAFormDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 16:35'!model	^ self! !!WAFormDialog methodsFor: 'actions' stamp: 'avi 3/12/2004 16:37'!ok	self answer! !!WAFormDialog methodsFor: 'actions' stamp: 'avi 3/27/2004 16:59'!removeForm	form ifNotNil: [self removeDecoration: form]! !!WAFormDialog methodsFor: 'rendering' stamp: 'avi 3/16/2004 13:35'!renderContentOn: html	html hiddenInputWithCallback: [validationError _ nil].	validationError ifNotNil:		[self renderValidationError: validationError on: html].	html divClass: self divClass with: [self renderDialogOn: html].! !!WAFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 20:37'!renderDialogOn: html! !!WAFormDialog methodsFor: 'rendering' stamp: 'avi 3/13/2004 21:20'!renderSpacerRowOn: html	html divClass: 'dialog-spacer' with: [html space]! !!WAFormDialog methodsFor: 'rendering' stamp: 'avi 3/13/2004 21:28'!renderValidationError: aString on: html	html spanClass: 'dialog-validation' with: aString! !!WAFormDialog methodsFor: 'validation' stamp: 'avi 3/12/2004 16:35'!validationError: aString	validationError _ aString! !!WAGridDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 16:47'!columns	^ #()! !!WAGridDialog methodsFor: 'accessing' stamp: 'avi 3/17/2004 15:05'!cssClassForItem: anObject	^ 'dialog-row'! !!WAGridDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 16:47'!items	^ #()! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 16:59'!renderColumn: aSymbol for: anObject on: html	| renderSelector |	renderSelector _ self renderingSelectorFor: aSymbol.	(self respondsTo: renderSelector)		ifTrue: [self perform: renderSelector with: anObject with: html]		ifFalse: [self renderDefaultColumn: aSymbol for: anObject on: html]! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 17:00'!renderDefaultColumn: aSymbol for: anObject on: html	html text: (anObject perform: aSymbol)! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 21:02'!renderDialogOn: html	html table: [		self renderHeadingsOn: html.		self items do:			[:ea | 			self renderRowForItem: ea on: html].	]! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 16:51'!renderHeadingForSelector: aSymbol on: html	html text: (self labelForSelector: aSymbol)! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 16:51'!renderHeadingsOn: html	self columns do: [:ea |		html cssClass: ea.		html tableHeading: [self renderHeadingForSelector: ea on: html]]! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/17/2004 15:04'!renderRowForItem: anObject on: html	html cssClass: (self cssClassForItem: anObject).	html tableRow: [		self columns do:			[:ea |			html cssClass: ea.			html tableData: [self renderColumn: ea for: anObject on: html]]	]! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 16:59'!renderingSelectorFor: aSymbol	^ ('render', aSymbol capitalized, 'For:on:') asSymbol! !!WAGridDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 21:03'!style	^ '	.dialog-buttons {text-align: center}	'! !!WAEditDialog class methodsFor: 'instance creation' stamp: 'avi 3/13/2004 14:21'!model: anObject	^ self new model: anObject! !!WAEditDialog methodsFor: 'accessing' stamp: 'avi 3/13/2004 14:10'!buttons	^ #(save cancel)! !!WAEditDialog methodsFor: 'actions' stamp: 'avi 3/12/2004 17:46'!cancel	self rollback.	self answer: false! !!WAEditDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 17:49'!model	^ model! !!WAEditDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 17:46'!model: anObject	model _ anObject.	self snapshot.! !!WAEditDialog methodsFor: 'actions' stamp: 'avi 3/12/2004 17:49'!rollback	model copyFrom: snapshot! !!WAEditDialog methodsFor: 'actions' stamp: 'avi 3/12/2004 17:46'!save	self validate.	self isValid ifTrue: [self answer: true]! !!WAEditDialog methodsFor: 'actions' stamp: 'avi 3/12/2004 17:49'!snapshot	snapshot _ model clone! !!WAEditDialog methodsFor: 'actions' stamp: 'avi 3/13/2004 14:10'!validate	! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 21:07'!renderDefaultFieldForSelector: aSymbol on: html	html textInputOn: aSymbol of: self model! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 20:37'!renderDialogOn: html	self rows do:		[:ea |		ea = #-			ifTrue: [self renderSpacerRowOn: html]			ifFalse: [self renderRowForSelector: ea on: html]].! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 21:06'!renderFieldForSelector: aSymbol on: html	| renderSelector |	renderSelector _ self renderingSelectorFor: aSymbol.	(self respondsTo: renderSelector)		ifTrue: [self perform: renderSelector with: html]		ifFalse: [self renderDefaultFieldForSelector: aSymbol on: html]! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 20:41'!renderLabelForSelector: aSymbol on: html	html text: (self labelForSelector: aSymbol)! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'mb 2/9/2006 18:52'!renderRowForSelector: aSymbol on: html	html cssClass: 'dialog-row'.	html divNamed: 'dialog-row-' , aSymbol with: 		[html spanClass: 'dialog-form-label' with: [self renderLabelForSelector: aSymbol on: html].		html spanClass: 'dialog-form-field' with: [self renderFieldForSelector: aSymbol on: html]].! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/12/2004 16:39'!renderTableRowsOn: html	self rows do:		[:ea |		ea = #-			ifTrue: [self renderSpacerRowOn: html]			ifFalse: [self renderRowForSelector: ea on: html]].! !!WALabelledFormDialog methodsFor: 'accessing' stamp: 'avi 3/12/2004 20:37'!renderingSelectorFor: aSymbol	^ ('render', aSymbol capitalized, 'On:') asSymbol! !!WALabelledFormDialog methodsFor: 'accessing' stamp: 'avi 3/10/2004 18:00'!rows	^ #()! !!WALabelledFormDialog methodsFor: 'rendering' stamp: 'avi 3/16/2004 16:29'!style	^ '.dialog-row {	clear: both;	/*set position: relative to handle the ie disappearing text bug*/	position: relative;	margin-top: 3px;}.dialog-form-label {	width: 100px;	float: left;	text-align: right;	padding: 2px 6px;	margin-right: 4px;	margin-top: 2px;}.dialog-form-field {	text-align: left;	padding: 2px;	margin-top: 2px;	float: left;}.dialog-buttons {	clear: both;	padding: 10px;	text-align: center}.dialog-spacer {	clear: both;	height: 10px;}	'! !!WAStoreAddressEditor commentStamp: 'avi 1/1/2004 09:56' prior: 0!A component for editing WAStoreAddress instances.  When called, it will create a new address instance, present a form for the user to modify it, and then answer the instance on submit.  Used by WAStoreTask>>getBillingAddress and getShippingAddress.!!WAStoreAddressEditor methodsFor: 'accessing' stamp: 'avi 12/8/2003 13:55'!countries	^ #(Canada USA)! !!WAStoreAddressEditor methodsFor: 'initialize-release' stamp: 'mb 5/6/2006 16:09'!initialize	super initialize.	address _ WAStoreAddress new! !!WAStoreAddressEditor methodsFor: 'accessing' stamp: 'mb 2/17/2005 11:14'!labelForSelector: aSymbol	aSymbol == #name ifTrue: [^'Your name'].	aSymbol == #street ifTrue: [^'The street'].	aSymbol == #city ifTrue: [^'The city'].	aSymbol == #ok ifTrue: [^'Continue'].	^ super labelForSelector: aSymbol! !!WAStoreAddressEditor methodsFor: 'accessing' stamp: 'avi 5/1/2004 14:38'!model	^ address! !!WAStoreAddressEditor methodsFor: 'actions' stamp: 'avi 12/10/2003 13:04'!ok	self answer: address! !!WAStoreAddressEditor methodsFor: 'rendering' stamp: 'avi 5/1/2004 14:40'!renderCountryOn: html	html		selectFromList: self countries		selected: address country		callback: [:v | address country: v]! !!WAStoreAddressEditor methodsFor: 'accessing' stamp: 'avi 5/1/2004 14:11'!rows	^ #(name street city country)! !!WAStoreAddressEditor methodsFor: 'path' stamp: 'mb 2/10/2006 12:05'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Sushi Store : Your address'.! !!WAStorePaymentEditor commentStamp: 'avi 1/1/2004 09:58' prior: 0!A component for editing WAStoreCreditCard instances.  When called, it presents a form for the user to choose credit card type, and enter name, number, and expiry date.  On submit, it will create and answer an instance of the appropiate credit card subclass.  Note the difference with WAStoreAddressEditor, where the form modifies the address instance directly.  Used by WAStoreTask>>getPaymentInfo.!!WAStorePaymentEditor methodsFor: 'accessing' stamp: 'avi 12/10/2003 14:06'!cardTypes	^ WAStoreCreditCard subclasses! !!WAStorePaymentEditor methodsFor: 'accessing' stamp: 'mb 2/10/2006 12:29'!labelForSelector: aSymbol	aSymbol == #ok ifTrue: [^'OK to pay'].	^ super labelForSelector: aSymbol! !!WAStorePaymentEditor methodsFor: 'accessing' stamp: 'avi 12/10/2003 13:59'!months	^ (1 to: 12)! !!WAStorePaymentEditor methodsFor: 'actions' stamp: 'pmm 11/2/2005 23:42'!ok	self answer:		(cardType new			name: name;			number: cardNumber;			expiry: (Date newDay: 1 monthNumber: month year: year);			yourself)! !!WAStorePaymentEditor methodsFor: 'rendering' stamp: 'avi 5/1/2004 14:15'!renderCardNumberOn: html	html textInputWithValue: cardNumber callback: [:v | cardNumber _ v]! !!WAStorePaymentEditor methodsFor: 'rendering' stamp: 'avi 5/1/2004 14:14'!renderCardTypeOn: html	html		selectFromList: self cardTypes		selected: cardType		callback: [:v | cardType _ v]		labels: [:ea | ea abbreviation]! !!WAStorePaymentEditor methodsFor: 'rendering' stamp: 'avi 5/1/2004 14:15'!renderExpirationDateOn: html 	html selectFromList: self months selected: month callback: [:m | month _ m].	html selectFromList: self years selected: year callback: [:y | year _ y]! !!WAStorePaymentEditor methodsFor: 'rendering' stamp: 'avi 5/1/2004 14:14'!renderNameOn: html	html textInputWithValue: name callback: [:v | name _ v]! !!WAStorePaymentEditor methodsFor: 'accessing' stamp: 'avi 5/1/2004 14:14'!rows	^ #(cardType name cardNumber expirationDate)! !!WAStorePaymentEditor methodsFor: 'path' stamp: 'mb 2/10/2006 12:08'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Sushi Store : Payment'.! !!WAStorePaymentEditor methodsFor: 'accessing' stamp: 'avi 12/10/2003 13:45'!years	^ (Date today year to: Date today year + 5)! !!WAViewer class methodsFor: 'as yet unclassified' stamp: 'avi 3/13/2004 01:13'!on: aPresenter	^ self new presenter: aPresenter! !!WAViewer methodsFor: 'accessing' stamp: 'avi 3/13/2004 01:14'!buttons	^ #(save)! !!WAViewer methodsFor: 'accessing' stamp: 'avi 3/13/2004 01:14'!model	^ presenter! !!WAViewer methodsFor: 'accessing' stamp: 'avi 3/13/2004 01:13'!presenter: aPresenter	presenter _ aPresenter! !!WAViewer methodsFor: 'rendering' stamp: 'mbany 4/14/2005 12:12'!renderContentOn: html	html heading: presenter displayString level: 3.	super renderContentOn: html! !!WAViewer methodsFor: 'rendering' stamp: 'avi 3/13/2004 01:17'!renderCssOn: html	html attributes rows: 20; cols: 80.	html textAreaWithValue: presenter style callback:		[:css |		presenter class compile: 'style ^ ', css printString]! !!WAViewer methodsFor: 'accessing' stamp: 'avi 3/13/2004 01:14'!rows	^ #(css)! !!WAViewer methodsFor: 'actions' stamp: 'avi 3/13/2004 01:23'!save	! !!WAViewer methodsFor: 'accessing' stamp: 'avi 3/13/2004 01:22'!script	^ 'self.opener.location=self.opener.location'! !!WANoteDialog methodsFor: 'accessing' stamp: 'avi 3/16/2004 16:48'!buttons	^ #(ok cancel)! !!WANoteDialog methodsFor: 'actions' stamp: 'avi 3/16/2004 16:48'!cancel	self answer: nil! !!WANoteDialog methodsFor: 'actions' stamp: 'avi 3/16/2004 16:46'!ok	self answer: note! !!WANoteDialog methodsFor: 'rendering' stamp: 'avi 3/16/2004 16:45'!renderDialogOn: html	html cssId: 'dialog-note'.	html textAreaWithValue: note callback: [:v | note _ v].! !!WANoteDialog methodsFor: 'accessing' stamp: 'avi 3/16/2004 16:50'!style	^ ' 	#dialog-note {width: 80%; height: 200px}	'! !!WAYesOrNoDialog methodsFor: 'accessing' stamp: 'avi 3/13/2004 21:40'!buttons	^ #(yes no)! !!WAYesOrNoDialog methodsFor: 'accessing' stamp: 'avi 3/13/2004 21:40'!no	self answer: false! !!WAYesOrNoDialog methodsFor: 'accessing' stamp: 'avi 3/13/2004 21:40'!yes	self answer: true! !!WAAllCanvasTests class methodsFor: 'testing' stamp: 'mb 1/31/2006 11:07'!canBeRoot	^ true! !!WAAllCanvasTests class methodsFor: 'class initialization' stamp: 'lr 6/13/2006 16:09'!initialize	self registerAsApplication: 'tests/allcanvastests'.! !!WAAllCanvasTests methodsFor: 'initialization' stamp: 'pmm 9/30/2006 20:23'!initialize	super initialize.	self contents:	 (WASimpleNavigation new		add: WACanvasInputTest new label: 'Input';		add: WACanvasHtmlTest new label: 'Html';		add: WACanvasTest new label: 'Canvas';		add: WACanvasLinkSubmitTest new label: 'Submit';		add: WACanvasDateTimeTest new label: 'More tests';		add: WACanvasModelTest new label: 'Model';		add: WACanvasUploadTest new label: 'Upload';		add: WACanvasDefaultFormTest new label: 'Default Form';		add: WACanvasImageTest new label: 'Image';		add: WAIframeTest new label: 'Iframe';		add: WARubyTest new label: 'Ruby';		add: WAPhraseElementsTest new label: 'Phrase';		yourself)! !!WAAllCanvasTests methodsFor: 'rendering' stamp: 'mb 1/31/2006 11:07'!renderContentOn: html	html heading: 'Test Canvas Components'.	html render: contents! !!WAAllCanvasTests methodsFor: 'path' stamp: 'mb 6/21/2006 13:28'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Canvas Tests: ', contents selection displayString."	anHtmlRoot linkToStyle: 'http://www.netstyle.ch/include/seaside/include/style.css'."	anHtmlRoot linkWithStyle: 'h1 {color: #efb321} body {font-family: tahoma, arial, helvetica; font-size: 80%}'."	anHtmlRoot linkToScript: 'http://www.xxxx.yyy/scripts.js'."	anHtmlRoot linkWithScript: 'var example = "abc";'.! !!WAAllTests commentStamp: 'sd 11/28/2004 14:42' prior: 0!If you want to see these examples:/seaside/config app:- add a new application named "tests"- choose WAAllTests as the root component!!WAAllTests class methodsFor: 'testing' stamp: 'avi 2/5/2004 12:58'!canBeRoot	^ true! !!WAAllTests class methodsFor: 'initialize' stamp: 'lr 6/13/2006 16:09'!initialize	self registerAsApplication: 'tests/alltests'.! !!WAAllTests methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 10:54'!initialize	super initialize.	self contents:	 (WASimpleNavigation new		add: WAInputTest new label: 'Input';		add: WAHtmlTest new label: 'Html';		add: WAEncodingTest new label: 'Encoding';		add: WAErrorTest new label: 'Error';		add: WAExceptionTest new label: 'Exception';		add: WAClosureTest new label: 'Closure';		add: WATransactionTest new label: 'Transaction';		add: WAUploadTest new label: 'Upload';		add: (WAParentTest new parent: self) label: 'Parent';		add:  WAPathTest new label: 'Path';		add: WATaskTest new label: 'Task';		add: WACookieTest new label: 'Cookies';		add: WACallbackTest new label: 'Callbacks';		add: WAImageTest new label: 'Images';		add: WAHomeTest new label: 'Home';		add: WACacheTest new label: 'Cache';		add: WADefaultFormTest new label: 'Default Form';		add: WALinkSubmitTest new label: 'Submit';		add: WAJavascriptTest new label: 'Javascript';		yourself)! !!WAAllTests methodsFor: 'rendering' stamp: 'avi 5/8/2004 13:38'!renderContentOn: html	html heading: 'Test Components'.	html render: contents! !!WAAllTests methodsFor: 'updating' stamp: 'mb 6/21/2006 13:11'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Tests: ', contents selection displayString."	anHtmlRoot linkToStyle: 'http://www.netstyle.ch/include/seaside/include/style.css'."	anHtmlRoot linkWithStyle: 'h1 {color: #efb321} body {font-family: tahoma, arial, helvetica; font-size: 80%}'."	anHtmlRoot linkToScript: 'http://www.xxxx.yyy/scripts.js'."	anHtmlRoot linkWithScript: 'var example = "abc";'.! !!WAFrameComponent class methodsFor: 'instance creation' stamp: 'avi 2/2/2004 20:01'!on: aComponent	^ self new contents: aComponent! !!WAFrameComponent methodsFor: 'accessing' stamp: 'avi 2/2/2004 19:58'!children	^ Array with: contents! !!WAFrameComponent methodsFor: 'accessing' stamp: 'avi 2/2/2004 19:58'!contents	^ contents! !!WAFrameComponent methodsFor: 'accessing' stamp: 'avi 4/14/2004 23:56'!contents: aComponent	contents _ aComponent! !!WAFrameComponent methodsFor: 'rendering' stamp: 'avi 2/2/2004 19:58'!renderContentOn: html	html render: contents! !!WAPathTest methodsFor: 'initialization' stamp: 'pmm 11/2/2005 22:53'!initialize	super initialize.	self contents: WACounter new! !!WAPathTest methodsFor: 'rendering' stamp: 'avi 4/15/2004 12:06'!renderContentOn: html	html anchorWithName: contents count.	html render: contents.! !!WAPathTest methodsFor: 'path' stamp: 'mbany 4/14/2005 11:58'!updateUrl: aUrl	aUrl addToPath: contents count displayString.	aUrl fragment: contents count displayString.! !!WAProfiler methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 16:14'!renderContentOn: html	| data |	data _ SeasidePlatformSupport profileSendsDuring: [html render: contents].	html horizontalRule.	html preformatted: data.! !!WAToolFrame methodsFor: 'accessing' stamp: 'jf 5/8/2004 13:23'!actions	^ #(configure toggleHalos)! !!WAToolFrame methodsFor: 'rendering' stamp: 'ab 3/29/2003 00:20'!configure	self call: (WAApplicationEditor new application: self session application)! !!WAToolFrame methodsFor: 'initialization' stamp: 'mb 4/23/2006 18:35'!initialize	super initialize.	showHalos _ WAStateHolder new contents: false! !!WAToolFrame methodsFor: 'rendering' stamp: 'avi 6/13/2004 01:13'!openTool: aToolClass	self call: (aToolClass new				root: contents;				addDecoration: (WAWindowDecoration new title: aToolClass title);				yourself)! !!WAToolFrame methodsFor: 'request processing' stamp: 'avi 5/5/2005 12:30'!processCallbackStream: aCallbackStream	processTime _ Time millisecondClockValue.	super processCallbackStream: aCallbackStream! !!WAToolFrame methodsFor: 'rendering' stamp: 'avi 5/5/2005 12:33'!renderChildOn: html	showHalos contents ifTrue: [html context debugMode].	processTime _ processTime ifNil: [0] ifNotNil: [Time millisecondClockValue - processTime].	renderTime _ Time millisecondsToRun: [html render: contents].	html context clearMode.! !!WAToolFrame methodsFor: 'rendering' stamp: 'mb 8/10/2006 07:58'!renderContentOn: html 	html div		id: 'frameContent';		with: [self renderChildOn: html].	html div: [html space]. "Compensate for Mozilla: bottom of contents hidden by toolbar"	self renderToolbarOn: html.! !!WAToolFrame methodsFor: 'rendering' stamp: 'mb 8/18/2006 10:16'!renderToolbarOn: html	html paragraph.	(html div)		id: 'toolbar';		with:			[(html anchor)				callback: [self session expire; redirectTo: self session newSessionUrl];				text: 'New Session'.			html space.			self actions				do: [:ea | html anchor on: ea of: self. html space].			self tools 				do: [:ea | (html anchor) callback: [self openTool: ea]; text: ea linkText. html space].			(html anchor)				url: (html context actionUrl withParameter: 'terminate' value: '1');				text: 'Terminate'.			html space.			(html anchor)				url: 'http://validator.w3.org/check/referer';				text: 'XHTML'.			html space.			html text: renderTime displayString, '/', processTime displayString, ' ms'		].	processTime := nil.! !!WAToolFrame methodsFor: 'rendering' stamp: 'dc 7/22/2006 10:12'!rendererClass	^ WARenderCanvas ! !!WAToolFrame methodsFor: 'rendering' stamp: 'pmm 12/23/2005 16:23'!style^'	#toolbar {position: fixed; bottom: 0; left: 0; right: 0; margin-top: 40px; padding: 3px; clear: both; background: #d3d3d3; font-size: 10pt; z-index: 20}	#toolbar-profile {margin-top: 40px; padding: 3px; clear: both; background: #d3d3d3; font-size: 10pt}	.halo {border-style: solid; border-width: 1px; margin: 4px; border-color: #aaaaaa}	.halo-header {font-size: 10pt; background-color: #cccccc; margin-bottom: 4px}	.halo-mode {float: right}	.halo-icons {float: left}	.halo-contents {clear: both} '! !!WAToolFrame methodsFor: 'actions' stamp: 'avi 9/30/2004 16:55'!toggleHalos	WAHalo initialize.	showHalos contents: showHalos contents not.! !!WAToolFrame methodsFor: 'accessing' stamp: 'ab 7/3/2003 12:52'!tools	^ WATool allSubclasses! !!WAHalo class methodsFor: 'plugins' stamp: 'mb 6/18/2006 22:12'!addPlugin: aClass	(self plugins includes: aClass) ifFalse:		[self plugins add: aClass]! !!WAHalo class methodsFor: 'instance-creation' stamp: 'avi 9/30/2004 16:46'!for: aComponent	^ Halos at: aComponent ifAbsentPut: [self new target: aComponent]! !!WAHalo class methodsFor: 'plugins' stamp: 'cds 6/20/2006 10:06'!haloElementsFor: aTarget inHalo: aHalo	^OrderedCollection new		add: ((Dictionary new)				at: #image put: 'Halo-Debug';				at: #action put: [WABrowser fullOnClass: aTarget class];				at: #title put: 'System Browser';				yourself);		add: ((Dictionary new)				at: #image put: 'Halo-View';				at: #action put: [WAInspector on: aTarget];				at: #title put: 'Inspector';				yourself);		add: ((Dictionary new)				at: #image put: 'Halo-Paint';				at: #action put: [WAViewer on: aTarget];				at: #title put: 'Style Editor';				yourself);		yourself! !!WAHalo class methodsFor: 'plugins' stamp: 'mb 6/16/2006 19:13'!haloImageLinksFor: aTarget inHalo: aHalo	| actions |	"Answer an OrderedCollection of dictionaries"	actions _ OrderedCollection new.	self plugins do:		[:each | actions addAll: (each haloElementsFor: aTarget inHalo: aHalo)].	^actions.! !!WAHalo class methodsFor: 'class initialization' stamp: 'avi 9/30/2004 16:46'!initialize	Halos _ SeasidePlatformSupport weakDictionaryOfSize: 20.! !!WAHalo class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:38'!plugins	^plugins ifNil: [plugins _ self standardPlugins].! !!WAHalo class methodsFor: 'plugins' stamp: 'mb 6/16/2006 18:51'!standardPlugins	^OrderedCollection with: self! !!WAHalo methodsFor: 'plugins' stamp: 'mb 6/16/2006 19:12'!haloImageLinksFor: aTarget	^self class haloImageLinksFor: aTarget inHalo: self.! !!WAHalo methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:23'!initialize	super initialize.	mode _ WAStateHolder new contents: #render:! !!WAHalo methodsFor: 'private' stamp: 'avi 9/30/2004 16:48'!render: html	self target renderContentOn: html! !!WAHalo methodsFor: 'rendering' stamp: 'mjr 9/4/2006 17:21'!renderContentOn: html	| haloHtml |	haloHtml := self rendererClass 					context: html context 					callbacks: html callbacks. 	haloHtml divClass: 'halo' with: [		haloHtml divClass: 'halo-header' with: [			haloHtml divClass: 'halo-icons' with: [				haloHtml text: self target class name.				haloHtml space.				(self haloImageLinksFor: self target) do:					[:each |					self						renderHalo: (each at: #image)						withWindow: (each at: #action)						titled: (each at: #title)						on: haloHtml]].			haloHtml divClass: 'halo-mode' with: [				haloHtml text: '['.				haloHtml anchorWithAction: [self renderMode] text: 'R'.				haloHtml text: ' | '.				haloHtml anchorWithAction: [self sourceMode] text: 'S'.				haloHtml text: ']'].			haloHtml divClass: 'halo-contents' with:''	 "Use clear:both to give header box a height."					].		haloHtml with: [self perform: mode contents with: html].	].	haloHtml close.	html close.! !!WAHalo methodsFor: 'rendering' stamp: 'mb 6/21/2006 12:40'!renderHalo: iconKey withAction: aBlock on: html	html		anchorWithAction: aBlock		text: 			[html attributes noBorder.			html imageWithForm: (ScriptingSystem formAtKey: iconKey)].! !!WAHalo methodsFor: 'rendering' stamp: 'mb 2/17/2005 17:56'!renderHalo: iconKey withWindow: componentBlock titled: aString on: html	html attributes at: 'title' put: aString.	html attributes at: 'label' put: aString.	self		renderHalo: iconKey		withAction: [WARenderLoop new call: (componentBlock value												addDecoration: (WAWindowDecoration new title: aString);												yourself)]		on: html! !!WAHalo methodsFor: 'actions' stamp: 'avi 4/16/2004 17:33'!renderMode	mode contents: #render:! !!WAHalo methodsFor: 'private' stamp: 'lr 3/27/2006 10:42'!source: html	| context haloHtml | 	haloHtml := self rendererClass					context: html context					callbacks: html callbacks. 	context := haloHtml context copy.		context clearMode.	context document: (WAPrettyPrintedDocument renderer: haloHtml).	haloHtml divClass: 'halo-source' with: [self target renderWithContext: context]. 	haloHtml close. 	html context count: context count! !!WAHalo methodsFor: 'actions' stamp: 'avi 3/16/2004 18:07'!sourceMode	mode contents: #source:! !!WAHalo methodsFor: 'accessing' stamp: 'avi 9/30/2004 16:54'!target	^ target! !!WAHalo methodsFor: 'accessing' stamp: 'avi 9/30/2004 16:54'!target: aComponent	target _ aComponent! !!WAHomeTest methodsFor: 'accessing' stamp: 'avi 10/19/2004 15:53'!children	^ Array with: main! !!WAHomeTest methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:23'!initialize	super initialize.	main _ WATaskTest new.	! !!WAHomeTest methodsFor: 'rendering' stamp: 'avi 10/19/2004 15:53'!renderContentOn: html	html anchorWithAction: [main home] text: 'Home'.	html div: main! !!WAHtmlTest methodsFor: 'private' stamp: 'ab 12/6/2002 00:42'!allSelectors	^ (self class selectors asSortedCollection select: [:s | s beginsWith: 'render'])		remove: #renderContentOn:;		yourself! !!WAHtmlTest methodsFor: 'accessing' stamp: 'cds 6/24/2004 00:41'!booleanList	^booleanList! !!WAHtmlTest methodsFor: 'initialize' stamp: 'mb 3/8/2006 14:10'!initialMessage	^'Hello world!!'.! !!WAHtmlTest methodsFor: 'initialize' stamp: 'pmm 7/19/2006 19:52'!initialize	super initialize.	message := self initialMessage.	booleanList := #(a b c d) collect: [:key | key -> ((Array with: true with: false) atRandom)].	number := 10 atRandom.! !!WAHtmlTest methodsFor: 'accessing' stamp: 'cds 6/25/2004 17:18'!message	^message! !!WAHtmlTest methodsFor: 'accessing' stamp: 'cds 6/25/2004 16:54'!number	^number! !!WAHtmlTest methodsFor: 'rendering' stamp: 'cds 6/24/2004 10:30'!renderCheckboxesOn: html 	html text: booleanList.	html paragraph.	html cssId: 'checkbox-form'.	html		form: [booleanList				do: [:assoc | 					html text: assoc key;						 space.					html cssId: 'cb-' , assoc key asString.					html						checkboxWithValue: assoc value						callback: [:b | assoc value: b].					html break].			html submitButton]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 2/9/2006 17:55'!renderContentOn: html	self allSelectors pairsDo:		[:selA :selB |		html divClass: 'row' with: [			html divClass: 'left' with: [self perform: selA with: html].			html divClass: 'right' with: [self perform: selB with: html]		]]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 6/21/2006 13:00'!renderRadioButtonsOn: html 	html text: booleanList.	html paragraph.	html cssId: 'radio-form'.	html		form: [booleanList				do: [:assoc | 					| group | 					group _ html radioGroup.					html text: assoc key;						 space.					html cssId: assoc key asString , '-on'.					html addShortcut: 'Ctrl-' , assoc key.					html						radioButtonInGroup: group						selected: assoc value						callback: [assoc value: true].					html cssId: assoc key asString , '-off'.					html addShortcut: 'Alt-' , assoc key.					html						radioButtonInGroup: group						selected: assoc value not						callback: [assoc value: false].					html break].			html submitButton]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'cds 6/25/2004 16:45'!renderSelectsOn: html 	html text: number.	html paragraph.	html cssId: 'select-form'.	html		form: [html cssId: 'select-list'.			html				selectFromList: (1 to: 10)				selected: number				callback: [:i | number _ i].			html submitButton]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'pmm 7/19/2006 19:41'!renderSubmitButtonsOn: html 	html text: number.	html paragraph.	html cssId: 'button-form'.	html form: [		1 to: 10 do: [ :index | 			html addShortcut:  'F' , index asString.			html addShortcut:  'Ctrl-' , index asString.			html				submitButtonWithAction: [ number := index ]				text: index.			html space]].	html attributes addStyle: 'font-size: 60%'.	html attributes addStyle: 'font-style: italic'.	html span: 'Handy shortcuts : F1..F10, Ctrl-1..Ctrl-9'.! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 6/21/2006 12:55'!renderTextAreaOn: html 	html cssId: 'textarea-form'.	html		form: [html cssId: 'textarea-banner'.			html span: message.			html paragraph.			html cssId: 'textarea-message'.			html				textAreaWithValue: message				callback: [:v | message _ v].			html break; submitButton]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 6/21/2006 12:54'!renderTextInputOn: html 	html cssId: 'textInput-form'.	html		form: [html cssId: 'textInput-banner'.			html span: message.			html paragraph.			html cssId: 'text-message'.			html				textInputWithValue: message				callback: [:v | message _ v].			html submitButton]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 11:15'!renderVFieldSetOn: html	html fieldsetWithLegend: 'Various text rendering in a fieldset' do:		[html			strong: 'Strong';			break;			bold: 'Bold';			break;			italic: 'Italic';			break;			underline: 'Underline';			break;			acronym: 'United States of America' do: 'USA';			break;			emphasis: 'Emphasis';			break.		html attributes			addStyle: 'color: red';			backgroundColor: 'lightgreen';			addStyle: 'padding: 1em';			border: 2;			addStyle: 'font-weight: bold';			addStyle: 'font-size: 150%';			height: '3em';			alignCenter.		html			div: 'Large bold red in a green div';			break]! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 6/12/2006 14:38'!renderZFieldSetOn: html	| url1 |	url1 _ html context				urlForDocument: (ScriptingSystem formAtKey: 'Halo-Debug') 				mimeType: 'image/jpg' 				fileName: 'Debug.jpg'.	html fieldsetWithLegend: 'Various images in a fieldset' do:		[html image: url1 altText: 'Halo-Debug'.		html space.		html attributeAt: 'alt' put: 'Halo-View'.		html imageWithForm: (ScriptingSystem formAtKey: 'Halo-View').		html space.		html attributeAt: 'alt' put: 'Halo-Paint'.		html			imageWithDocument: (ScriptingSystem formAtKey: 'Halo-Paint')			mimeType: 'image/png'			fileName: 'Paint.png'.				html break.		html attributes border: 1.		html image: 'http://www.netstyle.ch/include/seaside/pics/top.jpg' width: '80%' altText: 'Seaside'.		html break.		html attributes border: 2.		html image: 'http://www.netstyle.ch/include/seaside/pics/top.jpg' height: '50px' altText: 'Seaside'.		html break.		html attributes noBorder.		html image: 'http://www.netstyle.ch/include/seaside/pics/top.jpg' width: '250px' height: '60px' altText: 'Seaside']! !!WAHtmlTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 10:52'!style^ '	div.row {clear: both}	div.left {float: left; width: 45%; margin: 1%}	div.right {float: left; width: 45%; margin: 1%}'! !!WAIframeTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 13:31'!children	^ Array with: counter! !!WAIframeTest methodsFor: 'initialization' stamp: 'lr 3/9/2006 13:31'!initialize	super initialize.	counter := WACounter new! !!WAIframeTest methodsFor: 'rendering' stamp: 'lr 8/9/2006 08:38'!renderContentOn: html	html iframe 		contents: counter.	html break; break.	html iframe 		src: (WADispatcher default entryPointAt: WAStore entryPointName) basePath.	html break; break.	html iframe 		document: SeasidePlatformSupport seasideBanner		mimeType: 'image/jpeg'! !!WAIframeTest methodsFor: 'as yet unclassified' stamp: 'lr 3/9/2006 11:57'!rendererClass	^ WARenderCanvas ! !!WAIframeTest methodsFor: 'rendering' stamp: 'lr 8/9/2006 08:38'!style	^ 'iframe { 	border: 1px solid gray;	width: 100%;}'! !!WAImageTest methodsFor: 'rendering' stamp: 'avi 9/2/2004 14:38'!renderContentOn: html	html form: [		html submitButtonWithAction: [self inform: 'ok'] image: (ScriptingSystem formAtKey: 'Halo-Debug')]! !!WAInputDialog methodsFor: 'accessing' stamp: 'pmm 9/12/2006 18:32'!default: aString	value := aString! !!WAInputDialog methodsFor: 'accessing' stamp: 'pmm 9/12/2006 18:34'!label	^label ifNil: [ label := 'OK' ]! !!WAInputDialog methodsFor: 'accessing' stamp: 'pmm 9/12/2006 18:32'!label: aString	label := aString! !!WAInputDialog methodsFor: 'accessing' stamp: 'mb 4/5/2006 07:13'!renderContentOn: html	html form: [		html defaultAction: [self answer: value].		html textInputWithValue: value callback: [:v | value _ v].		html space.		html submitButtonWithAction: [self answer: value] text: self label.	]! !!WAInputTest class methodsFor: 'example' stamp: 'sd 11/28/2004 15:43'!example	^ self new! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!emptyString	^emptyString! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!emptyString: anObject	emptyString := anObject! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!fraction	^fraction! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!fraction: anObject	fraction := anObject! !!WAInputTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:52'!initialize	super initialize.	nilString := nil.	emptyString := ''.	integer := 42.	fraction := 1/3.! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!integer	^integer! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!integer: anObject	integer := anObject! !!WAInputTest methodsFor: 'accessing' stamp: 'mb 2/10/2006 12:49'!labelForSelector: aSymbol	aSymbol == #nilString ifTrue: [^'Nil string,  ' , self nilString printString].	aSymbol == #emptyString ifTrue: [^'Empty string, ' , self emptyString printString].	aSymbol == #integer ifTrue: [^'Integer, ' , self integer printString].	aSymbol == #fraction ifTrue: [^'Fraction, ' , self fraction printString].	^ super labelForSelector: aSymbol! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!nilString	^nilString! !!WAInputTest methodsFor: 'accessing' stamp: 'ab 10/28/2002 23:01'!nilString: anObject	nilString := anObject! !!WAInputTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 12:39'!renderContentOn: html	self renderFormOneOn: html.	self renderFormTwoOn: html.! !!WAInputTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 12:34'!renderFormOneOn: html	html form: [		html table: [			html					tableHeadings: #(Name Value PrintString);				tableRowWithLabel: 'Nil String'					column: [html textInputOn: #nilString of: self]					column: [html text: nilString printString];				tableRowWithLabel: 'Empty String'					column: [html textInputOn: #emptyString of: self]					column: [html text: emptyString printString];				tableRowWithLabel: 'Integer'					column: [html textInputOn: #integer of: self]					column: [html text: integer printString];				tableRowWithLabel: 'Fraction'					column: [html textInputOn: #fraction of: self]					column: [html text: fraction printString].		].		html submitButton.	]! !!WAInputTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 12:42'!renderFormTwoOn: html	html form: [		html table: [			html					tableHeadings: #(Name Value);				labelledRowForTextInputOn: #nilString of: self size: 4;				labelledRowForTextInputOn: #emptyString of: self size: 8;				labelledRowForTextInputOn: #integer of: self size: 12;				labelledRowForTextInputOn: #fraction of: self size: 16.		].		html submitButton.	]! !!WAInputTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 12:52'!style	^'form {	float: left;	margin: 0 150px 0 0;}'! !!WAInspector class methodsFor: 'as yet unclassified' stamp: 'ab 2/15/2003 00:21'!on: anObject	^ self new object: anObject! !!WAInspector methodsFor: 'testing' stamp: 'pmm 9/12/2006 18:35'!canInspect: anObject	^[ anObject isNumber		or: [ (Array with: nil with: true with: false) includes: anObject ]	] on: Error do: [ :ex | false ]! !!WAInspector methodsFor: 'accessing' stamp: 'avi 2/10/2004 16:34'!children	^ Array with: path! !!WAInspector methodsFor: 'actions' stamp: 'ab 5/31/2003 15:13'!chooseObject: anObject named: aString	path pushSegment: anObject name: aString! !!WAInspector methodsFor: 'actions' stamp: 'pmm 7/4/2005 15:37'!evaluate: aString	^self object class evaluatorClass new		evaluate: aString		in: nil		to: self object.! !!WAInspector methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:24'!initialize	super initialize.	path _ WAPath new! !!WAInspector methodsFor: 'state variables' stamp: 'ab 5/31/2003 15:12'!object	^ path currentSegment! !!WAInspector methodsFor: 'state variables' stamp: 'ab 5/31/2003 15:11'!object: anObject 	path pushSegment: anObject name: anObject printString! !!WAInspector methodsFor: 'rendering' stamp: 'pmm 7/4/2005 15:38'!renderContentOn: html 	html render: path.	html heading: (self object printStringLimitedTo: 50).	html text: 'Identity Hash: ', self object identityHash displayString; break; break.	self renderMembersOn: html.	self renderEditAreaOn: html.! !!WAInspector methodsFor: 'rendering' stamp: 'pmm 11/2/2005 22:04'!renderEditAreaOn: html	| input |	input := ValueHolder new.	html break.	html form: [		html attributeAt: 'rows' put: 6.		html attributeAt: 'cols' put: 60.		html			textAreaWithValue: ''			callback: [ :value |				input contents: value].		html break.		html			submitButtonWithAction: [				self evaluate: input contents ]			text: 'do it'.		html			submitButtonWithAction: [				self inform: (self evaluate: input contents) ]			text: 'print it'.		html			submitButtonWithAction: [				WARenderLoop new call:					((self class on: (self evaluate: input contents))					addDecoration: (WAWindowDecoration new title: 'Inspector');					yourself) ]			text: 'inspect it'. ].! !!WAInspector methodsFor: 'rendering' stamp: 'ab 2/16/2003 00:28'!renderMembersOn: html 	| members |	members := self object inspectorFields.	members isEmpty ifTrue: [^self].	html bold: 'Members: '.	html attributeAt: 'border' put: 1.	html table: 			[members associationsDo: 					[:assoc | 					self 						renderRowForObject: assoc value						named: assoc key						on: html]]! !!WAInspector methodsFor: 'rendering' stamp: 'pmm 7/4/2005 16:03'!renderRowForObject: anObject named: aString on: html	html tableRow: [		html tableData: [ 			(self canInspect: anObject)				ifTrue: [html text: aString]				ifFalse: [html anchorWithAction: [self chooseObject: anObject named: aString] text: aString ]		].		html tableData: [			html attributeAt: 'style' put: 'margin-bottom: 0pt'.			html form: [				html attributeAt: 'rows' put: 1.				html attributeAt: 'cols' put: 30.				html					textAreaWithValue: (anObject printStringLimitedTo: 100)					callback: [ :value |						self object							instVarNamed: aString							put: (self evaluate: value) ].				html submitButtonWithAction: [] text: 'accept' ] ] ]! !!WAJavascriptTest methodsFor: 'rendering' stamp: 'mb 2/28/2006 09:05'!renderContentOn: html	html form:		[		html cssId: 'F0'.		html textInputWithValue: value callback: [:v | value := v].		html cssId: #F1.		html autofocus: [html textInputWithValue: value callback: [:v | value := v]].		html submitButton].	html cssId: #D1.	html divWithShow: 'Show' hide: 'Hide' do: 'DIV'.	html cssId: #S1.	html spanWithShow: 'Show' hide: 'Hide' do: 'SPAN'! !!WALibraryBrowser methodsFor: 'actions' stamp: 'avi 7/2/2004 00:50'!find: aString	| inst |	self libraries do:		[:ea |		inst _ ea new.		ea selectors do: 			[:sel |			((inst perform: sel) includesSubString: aString)				ifTrue: [(hits at: (Array with: ea with: sel) ifAbsentPut: [SortedCollection new]) add: aString]]]! !!WALibraryBrowser methodsFor: 'actions' stamp: 'avi 7/2/2004 00:49'!findAll: aString	hits _ Dictionary new.	(aString findTokens: ' ') do: [:ea | self find: ea].	hits isEmpty ifFalse: [self goto: self orderedHits first]! !!WALibraryBrowser methodsFor: 'actions' stamp: 'avi 7/2/2004 00:51'!goto: anArray	library _ anArray first.	selector _ anArray second! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'mb 5/6/2006 16:08'!hits	^ hits ifNil: [ hits _ Dictionary new ]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 00:28'!libraries	^ (WAStyleLibrary subclasses, WAScriptLibrary subclasses) asSortedCollection: [:a :b | a name <= b name]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 00:28'!library	^ library! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 00:28'!library: aLibraryClass	library _ aLibraryClass.	selector _ nil.! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'lr 5/3/2006 10:05'!orderedHits	^ self hits keys asSortedCollection: [:a :b | (hits at: a) size >= (hits at: b) size]! !!WALibraryBrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:23'!renderColumnsOn: html	html select		beSubmitOnChange;		size: 10;		list: self libraries;		on: #library of: self.	html		select		beSubmitOnChange;		size: 10;		list: self selectors;		on: #selector of: self.! !!WALibraryBrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:17'!renderContentOn: html	html div		class: 'stylebrowser-columns';		with: [			html form: [ self renderColumnsOn: html ] ].	html div		class: 'stylebrowser-search';		with: [			html form: [				html textInput value: search; callback: [:v | search := v].				html space.				html submitButton callback: [self findAll: search]; text: 'Search' ].		html unorderedList: [			self orderedHits do: [:pair |				html listItem: [					self renderHit: pair on: html ] ] ] ].	html div		class: 'stylebrowser-editor';		with: [			html form: [				self renderEditorOn: html.				html paragraph.				html submitButton callback: [self save]; text: 'Save' ] ]! !!WALibraryBrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:18'!renderEditorOn: html	html textArea		rows: 20;		columns: 80;		on: #string of: self.! !!WALibraryBrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:19'!renderHit: anArray on: html	| text |	text := String streamContents: [ :stream |		stream nextPutAll: anArray first name.		stream nextPutAll: '>>'.		stream nextPutAll: anArray second.		stream space.		stream nextPutAll: '('.		(hits at: anArray)			do: [:each | stream nextPutAll: each ]			separatedBy: [ stream nextPutAll: ', '].		stream nextPutAll: ')'].	html anchor callback: [self goto: anArray]; with: text.	! !!WALibraryBrowser methodsFor: 'rendering' stamp: 'pmm 4/23/2006 21:14'!rendererClass	^ WARenderCanvas! !!WALibraryBrowser methodsFor: 'actions' stamp: 'avi 5/24/2004 14:55'!save! !!WALibraryBrowser methodsFor: 'actions' stamp: 'avi 7/2/2004 11:08'!search: aString	search _ aString.	self findAll: search! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 5/24/2004 14:46'!selector	^ selector! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 00:32'!selector: aSymbol	(library selectors includes: aSymbol) ifTrue: [selector _ aSymbol]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 00:28'!selectors	^ library ifNil: [#()] ifNotNil: [library selectors]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 10:58'!string	^ self selector ifNotNilDo: [:s | library new perform: s]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'avi 7/2/2004 10:58'!string: aString	self selector ifNotNilDo:		[:sel |		library compile: (sel, '	^ ', aString printString)]! !!WALibraryBrowser methodsFor: 'accessing' stamp: 'mb 2/17/2005 18:32'!style	^ '	.stylebrowser-search {float: left}	.stylebrowser-columns {float: left}	.stylebrowser-columns select {width: 250px}	.stylebrowser-editor {clear: both}	'! !!WALinkSubmitTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:52'!initialize	super initialize.	count := 0! !!WALinkSubmitTest methodsFor: 'rendering' stamp: 'lr 8/3/2006 08:43'!renderContentOn: html	html attributes at: 'name' put: #myform.	html form:		[html textInputWithValue: count callback: [:v | count _ v].		html break.		html addShortcut: 'Ctrl-Down'.		html anchorWithAction: [count _ count - 1] text: '--' submitFormNamed: 'myform'.		html space.		html addShortcut: 'Ctrl-Up'.		html anchorWithAction: [count _ count + 1] text: '++' submitFormNamed: #myform.		html break; break.		html addShortcut: 'Ctrl-Z'.		html addShortcut: 'Ctrl-z'.		html checkboxWithValue: (count = 0) callback: [:v | v ifTrue: [count := 0] ] submitFormNamed: 'myform'.		html space.		html text: 'Reset'		].	html emphasis: 'Handy shortcuts : Ctrl-Up, Ctrl-Down and Ctrl-Z'! !!WALoginDialog methodsFor: 'as yet unclassified' stamp: 'avi 2/6/2004 16:55'!authenticator: anAuthenticator	authenticator _ anAuthenticator! !!WALoginDialog methodsFor: 'as yet unclassified' stamp: 'avi 2/6/2004 16:56'!cancel	self answer: nil! !!WALoginDialog methodsFor: 'as yet unclassified' stamp: 'avi 2/6/2004 16:56'!login	(authenticator verifyPassword: password forUser: username) ifTrue: [self answer: username]! !!WALoginDialog methodsFor: 'as yet unclassified' stamp: 'avi 10/25/2003 14:24'!renderContentOn: html	html form: [		html table: [			html tableRowWithLabel: 'Username:' column: [html textInputWithValue: username callback: [:v | username _ v]].			html tableRowWithLabel: 'Password:' column: [html passwordInputWithCallback: [:v | password _ v]].			html attributes alignCenter.			html tableRowWith: [				html submitButtonOn: #login of: self.				html space.				html submitButtonOn: #cancel of: self] span: 2.		]	]! !!WALotsaLinks methodsFor: 'rendering' stamp: 'avi 5/3/2005 21:27'!renderContentOn: html	html list: (1 to: 5000) do:		[:ea |		html anchorWithAction: [self inform: ea] text: ea]! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'pmm 4/19/2006 17:42'!buildTable	^ WATableReport new			rowPeriod: 1;			rowColors: #('lightgrey' 'white');			rows: sizes keys asSortedCollection;			columns: 				(Array with: (WAReportColumn selector: #yourself title: 'Class')				with: ( WAReportColumn new					title: 'Instances';					valueBlock: [:ea | instances at: ea];					yourself)				with:				 (WAReportColumn new					title: 'Total Size';					valueBlock: [:ea | sizes at: ea];					yourself));			yourself! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'avi 2/10/2004 16:15'!children	^ Array with: table! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'avi 5/10/2005 14:33'!renderContentOn: html	html bold: self totalInstances displayString, ' instances in ', self totalSizeString.	html render: table.! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'ac 9/23/2005 13:29'!root: anObject	|segment results|	segment _ ImageSegment new copyFromRoots: (Array with: anObject) sizeHint: 100000.	results _ segment doSpaceAnalysis.	instances _ results first.	sizes _ results second.	table _ self buildTable.! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:42'!totalInstances	^ instances detectSum: [:ea | ea]! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:41'!totalSize	^ sizes detectSum: [:ea | ea]! !!WAMemoryUse methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 20:58'!totalSizeString	|size unit|	size _ self totalSize.	unit _ 'bytes'.	size > 1024 ifTrue:		[size _ size / 1024.		unit _ 'kB'.		size > 1024 ifTrue:			[size _ size / 1024.			unit _ 'MB']].	^ (size printShowingDecimalPlaces: 1), ' ', unit! !!WAMiniCalendar class methodsFor: 'as yet unclassified' stamp: 'dc 12/28/2005 14:20'!canBeRoot	^ true! !!WAMiniCalendar class methodsFor: 'as yet unclassified' stamp: 'lr 11/29/2004 16:37'!example	^self new! !!WAMiniCalendar methodsFor: 'testing' stamp: 'avi 10/24/2003 14:38'!canSelect: aDate	^ canSelectBlock notNil and: [canSelectBlock value: aDate]! !!WAMiniCalendar methodsFor: 'accessing' stamp: 'avi 10/23/2003 15:16'!canSelectBlock: aBlock	canSelectBlock _ aBlock! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'avi 10/23/2003 15:25'!date	^ date contents! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'avi 12/12/2004 13:39'!date: aDate	date contents: aDate.	month contents: aDate month! !!WAMiniCalendar methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:26'!initialize	super initialize.	month _ WAStateHolder new contents: Date today month.	date _ WAStateHolder new.! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'avi 10/23/2003 22:56'!month	^ month contents! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'avi 10/23/2003 22:56'!month: aMonth	^ month contents: aMonth! !!WAMiniCalendar methodsFor: 'private' stamp: 'mbany 4/14/2005 12:44'!monthHeading	^ self month name, ' ', self month year displayString! !!WAMiniCalendar methodsFor: 'private' stamp: 'dc 12/29/2005 11:41'!months	^ (1 to: 12) collect: [:i | Month month: i year: self year]! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'avi 10/25/2003 13:14'!renderCellForDate: aDate on: html	html tableData: [		aDate month = self month ifTrue:			[html cssClass: (self date = aDate ifTrue: ['calendarArchiveDate']).			html span: [			(self canSelect: aDate)				ifTrue: [html anchorWithAction: [self select: aDate] text: aDate dayOfMonth]				ifFalse: [html text: aDate dayOfMonth]			]]	]! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'dc 12/29/2005 11:58'!renderContentOn: html	html divClass: 'calendar' with: [	html spanClass: 'calendarCaption' with:  [self renderMonthHeadingOn: html].	html table: [		html cssClass: 'calendarTitle'; tableRow: [			self weekDays do: [:ea | html tableData: ea].		].		self month weeksDo: [:week | self renderRowForWeek: week on: html].	].	self renderMonthNavigationOn: html.	html space; space.	self renderYearNavigationOn: html.	]! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'dc 12/29/2005 12:01'!renderMonthHeadingOn: html	html form: [		html selectFromList: self months selected: self month callback: [:selectedMonth | self month: selectedMonth] labels: [:eachMonth | eachMonth name].		html textInputWithValue: self year callback: [:choosedYear | self  year: choosedYear] maxLength: 4.		html submitButtonWithText: 'Refresh'].! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'avi 10/25/2003 13:14'!renderMonthNavigationOn: html	html spanClass: 'calendarPrevious' with: [		html			anchorWithAction: [self month: self month previous]			text: (self month previous name first: 3).	].	html space.	html spanClass: 'calendarNext' with: [		html			anchorWithAction: [self month: self month next]			text: (self month next name first: 3).	]	! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'pmm 9/11/2006 23:28'!renderRowForWeek: aWeek on: html	html tableRow: [		aWeek datesDo: [ :each | self renderCellForDate: each on: html ] ]! !!WAMiniCalendar methodsFor: 'rendering' stamp: 'dc 12/29/2005 11:51'!renderYearNavigationOn: html	html spanClass: 'calendarPrevious' with: [		html			anchorWithAction: [self year: self year - 1]			text: (self year - 1) ].	html space.	html spanClass: 'calendarNext' with: [		html			anchorWithAction: [self year: self year + 1]			text: (self year + 1) ].	! !!WAMiniCalendar methodsFor: 'action' stamp: 'avi 10/23/2003 17:40'!select: aDate	self date: aDate.	selectBlock ifNotNil: [selectBlock value: aDate]! !!WAMiniCalendar methodsFor: 'accessing' stamp: 'avi 10/23/2003 17:39'!selectBlock: aBlock	selectBlock _ aBlock! !!WAMiniCalendar methodsFor: 'private' stamp: 'avi 10/23/2003 14:25'!weekDays	^ (1 to: 7) collect: [:i | (Date nameOfDay: i) first: 3]! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'dc 12/29/2005 11:44'!year	^ self month year! !!WAMiniCalendar methodsFor: 'accessing-delegated' stamp: 'dc 12/29/2005 11:51'!year: anInteger	self month: (Month month: self month monthIndex year: anInteger)! !!WAMultiCounter class methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 12:58'!canBeRoot	^true! !!WAMultiCounter class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 12:30'!description	^'Multiple Seaside components on one page'! !!WAMultiCounter class methodsFor: 'as yet unclassified' stamp: 'mb 6/13/2006 17:03'!initialize	self registerAsApplication: 'examples/multi'! !!WAMultiCounter methodsFor: 'accessing' stamp: 'avi 4/15/2004 21:50'!children	^ counters! !!WAMultiCounter methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:26'!initialize	super initialize.	counters _ (1 to: 5) collect: [:i | WACounter new]! !!WAMultiCounter methodsFor: 'rendering' stamp: 'avi 9/4/2003 17:07'!renderContentOn: html	counters 		do: [:ea | html render: ea]		separatedBy: [html horizontalRule]! !!WANavigation methodsFor: 'initialize' stamp: 'mb 4/23/2006 15:27'!initialize	super initialize.	selection _ WAStateHolder new! !!WANavigation methodsFor: 'query' stamp: 'mbany 4/14/2005 12:12'!labelForOption: anObject	^ anObject displayString! !!WANavigation methodsFor: 'initialize' stamp: 'avi 3/15/2004 16:27'!options	^ #()! !!WANavigation methodsFor: 'rendering' stamp: 'dc 7/25/2006 16:28'!renderContentOn: html	html div		class: 'kalsey';		with: [			html div				class: 'navigation-options';				with: [self renderOptionsOn: html].			html div				class: 'navigation-content';				with: [self renderSelectionOn: html]]! !!WANavigation methodsFor: 'rendering' stamp: 'dc 7/25/2006 16:29'!renderOptionsOn: html	html unorderedList		list: self options;		selected: self selection;		callback: [:v | self select: v];		labels: [:ea | self labelForOption: ea]! !!WANavigation methodsFor: 'rendering' stamp: 'avi 3/15/2004 16:13'!renderSelectionOn: html! !!WANavigation methodsFor: 'rendering' stamp: 'dc 7/25/2006 16:27'!rendererClass	^ WARenderCanvas ! !!WANavigation methodsFor: 'selection' stamp: 'avi 3/15/2004 16:28'!select: anObject	selection contents: anObject.	self selectionChanged! !!WANavigation methodsFor: 'selection' stamp: 'avi 3/15/2004 16:28'!selection	^ selection contents! !!WANavigation methodsFor: 'selection' stamp: 'avi 3/15/2004 16:28'!selectionChanged	! !!WASimpleNavigation commentStamp: 'lr 11/29/2004 16:30' prior: 0!I'm a simple tab panel, that can be styled with stylesheets. New tabs can be added using #add:label:!!WASimpleNavigation class methodsFor: 'example' stamp: 'lr 11/29/2004 16:32'!example	^self new		add: WACounter example label: 'Counter'; 		add: WAPath example label: 'Path';		select: 'Counter';		yourself.! !!WASimpleNavigation methodsFor: 'behavior' stamp: 'avi 3/15/2004 19:24'!add: aComponent label: aString	components add: aString -> aComponent! !!WASimpleNavigation methodsFor: 'accessing' stamp: 'lr 11/29/2004 16:27'!children	^Array with: self selectedComponent.! !!WASimpleNavigation methodsFor: 'initialize' stamp: 'avi 3/15/2004 19:25'!initialize	super initialize.	components _ OrderedCollection new! !!WASimpleNavigation methodsFor: 'accessing' stamp: 'lr 11/29/2004 16:28'!labels	"Return the tabs labels"	^ self options! !!WASimpleNavigation methodsFor: 'accessing' stamp: 'avi 3/16/2004 19:34'!options	^ components collect: [:ea | ea key]! !!WASimpleNavigation methodsFor: 'rendering' stamp: 'sd 11/28/2004 21:15'!renderSelectionOn: html	html render: self selectedComponent! !!WASimpleNavigation methodsFor: 'accessing' stamp: 'avi 3/15/2004 19:25'!selectedComponent	^ (components detect: [:ea | ea key = self selection] ifNone: [^ nil]) value! !!WANavigationBar methodsFor: 'accessing' stamp: 'ab 5/30/2003 00:15'!actions	^ self target perform: actionsSelector! !!WANavigationBar methodsFor: 'accessing' stamp: 'ab 5/30/2003 00:15'!actionsSelector: aSymbol	actionsSelector _ aSymbol! !!WANavigationBar methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 15:27'!initialize	super initialize.	actionsSelector _ #actions! !!WANavigationBar methodsFor: 'accessing' stamp: 'avi 3/12/2004 23:33'!owner: anObject	mOwner _ anObject! !!WANavigationBar methodsFor: 'rendering' stamp: 'ab 8/15/2003 16:43'!renderContentOn: html	self actions do:		[:symbol |		symbol numArgs = 0			ifTrue: [self renderLink: symbol on: html]			ifFalse: [self renderInput: symbol on: html]]! !!WANavigationBar methodsFor: 'rendering' stamp: 'ab 8/15/2003 16:45'!renderInput: aSymbol on: html	html form: [		html bold: aSymbol capitalized.		html space.		html textInputWithValue: '' callback: [:v | self target perform: aSymbol with: v].	]! !!WANavigationBar methodsFor: 'rendering' stamp: 'ab 8/15/2003 16:44'!renderLink: aSymbol on: html	html anchorOn: aSymbol of: self target.	html break! !!WANavigationBar methodsFor: 'accessing' stamp: 'avi 3/12/2004 23:33'!target	^ mOwner activeComponent! !!WAParentTest methodsFor: 'processing' stamp: 'ab 5/12/2003 22:13'!go	parent inform: 'foo'! !!WAParentTest methodsFor: 'accessing' stamp: 'ab 5/12/2003 22:13'!parent: aComponent	parent _ aComponent! !!WAParentTest methodsFor: 'rendering' stamp: 'ab 5/12/2003 22:14'!renderContentOn: html	html anchorWithAction: [self go] text: 'swap parent' ! !!WAPath commentStamp: '<historical>' prior: 0!I represent a path navigation such as the one that is displayed on the top of the web inspector when you toggle on the halos.Here is an example of path:	xxx >> yyy >> zzzUseful methods are 	- #currentSegment returns zzz	- pushSegment: anObject name: 'lulu'!!WAPath class methodsFor: 'example' stamp: 'lr 11/29/2004 16:24'!example	^self new 		pushSegment: 123 name: 'xxx'; 		pushSegment: 456 name: 'yyy';		pushSegment: 789 name: 'zzz';		yourself.! !!WAPath methodsFor: 'behavior' stamp: 'lr 11/29/2004 16:26'!choose: anAssociation	"Install a new stack of navigation from the old one and the specified association."		| newStack |	newStack := Array new writeStream.	stack do:		[:ea |		newStack nextPut: ea.		ea == anAssociation			ifTrue: [stack := newStack contents. ^ self]]! !!WAPath methodsFor: 'accessing' stamp: 'ab 5/31/2003 15:06'!currentSegment	^ stack isEmpty		ifTrue: [nil]		ifFalse: [stack last value]! !!WAPath methodsFor: 'initialize' stamp: 'mb 4/23/2006 15:27'!initialize	super initialize.	stack _ #().	self session registerObjectForBacktracking: self.! !!WAPath methodsFor: 'behavior' stamp: 'ab 5/31/2003 15:06'!pushSegment: anObject name: aString	stack _ stack, (Array with: aString -> anObject)! !!WAPath methodsFor: 'rendering' stamp: 'dc 7/22/2006 10:01'!renderContentOn: html	stack isEmpty ifTrue: [^ self].				html div		id: 'path';		with: [		stack allButLast do:			[:assoc |			html anchor callback: [self choose: assoc]; text: assoc key.			html text: ' >> '].				html bold: stack last key].! !!WAPath methodsFor: 'rendering' stamp: 'dc 7/22/2006 09:59'!rendererClass	^ WARenderCanvas ! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:24'!renderAbbreviatedOn: html	html heading level2; with: '<abbr>'.	html abbreviated		title: 'World Wide Web';		with: 'WWW'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:28'!renderAcronymOn: html	html heading level2; with: '<acronym>'.	html acronym		title: 'Federal Bureau of Investigation';		with: 'F.B.I.'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 10/2/2006 21:26'!renderAddressOn: html	html heading level2; with: '<address>'.	html address: [		#(			'Newsletter editor'			'J.R. Brown'			'JimquickPost News, Jimquick, CT 01234'			'Tel (123) 456 7890')			do: [ :each | html text: each ]			separatedBy: [ html break ] ]! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:25'!renderCodeOn: html	html heading level2; with: '<code>'.	html text: 'Expressions like '.	html code: 'a[i++] + b[i++]'.	html text: ' should not be used, since they cause undefined behavior'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 10/2/2006 21:29'!renderContentOn: html	self renderHarryOn: html.	self renderAbbreviatedOn: html.	self renderAcronymOn: html.	self renderKeyboardInputOn: html.	self renderVariableOn: html.	self renderCodeOn: html.	self renderDefinitionOn: html.	self renderSampleOn: html.	self renderAddressOn: html! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:25'!renderDefinitionOn: html	html heading level2; with: '<dfn>'.	html definition: 'Ichthyology'.	html text: ' is the branch of natural science whichstudies fish.'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:36'!renderHarryOn: html	html heading level2; with: '<cite>, <q>, <strong>'.	html text: 'As '.	html citation: 'Harry S. Truman'.	html text: ' said, '.	html quote: 'The buck stops here.'.		html break.		html text: 'More information can be found in '.	html citation: '[ISO-0000]'.	html text: '.'.		html break.		html text: 'Please refer to the following reference number in future correspondence: '.	html strong: '1-234-55'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:25'!renderKeyboardInputOn: html	html heading level2; with: '<kbd>'.	html text: 'Finally, type '.	html keyboardInput: 'logout'.	html text: ' and press the return key.'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 10/2/2006 21:28'!renderSampleOn: html	html heading level2; with: '<samp>'.	html text: 'If you select the ''champion'' option, you will receive the message '.	html sampleOutput: 'The monkey is not a caterpillar'.	html text: '.'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'pmm 9/30/2006 20:25'!renderVariableOn: html	html heading level2; with: '<var>'.	html text: 'In the simplest case, the command for deleting a file in Unix is'.	html break.	html keyboardInput: 'rm'.	html space.	html variable: 'filename'! !!WAPhraseElementsTest methodsFor: 'rendering' stamp: 'mb 10/3/2006 11:11'!rendererClass	^ WARenderCanvas! !!WAPopupTest methodsFor: 'initialize-release' stamp: 'pmm 7/19/2006 19:52'!initialize	super initialize.	url := 'http://www.seaside.st'! !!WAPopupTest methodsFor: 'rendering' stamp: 'mjr 8/17/2005 17:45'!renderContentOn: html	html form: [		html text: 'URL:'.		html space.		html textInputWithValue: url callback: [:v | url _ v].		html submitButtonWithText: 'Update'	].	html anchorWithPopupUrl: url		extent: 400@400		text: 'popup'.	html space.	html text: '(', url, ')'! !!WAReport methodsFor: 'initialize' stamp: 'mb 4/23/2006 15:29'!initialize	super initialize.	rows _ #().! !!WAReport methodsFor: 'accessing' stamp: 'ab 10/26/2002 22:03'!rows: anArray	rows _ anArray! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/24/2006 10:52'!renderColumn: aColumn row: aRow on: html	| text |	aColumn canRender ifTrue: [		^html tableData: [aColumn renderValue: aRow on: html]].	text := aColumn textForRow: aRow.	text isEmpty ifTrue: [ text := ' ' ].	html tableData: [		aColumn canChoose			ifFalse: [ html text: text ]			ifTrue: [				html anchor					callback: [ self chooseRow: aRow column: aColumn ];					text: text ] ]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 13:57'!renderContentOn: html	html table		cellspacing: 0;		cellpadding: 5;		with: [			self renderTableHeaderOn: html.			self renderRowsOn: html.			self renderTableFooterOn: html]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 13:56'!renderFooterForColumn: aColumn on: html	html tableHeading: (aColumn totalForRows: rows)! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 13:57'!renderHeaderForColumn: aColumn on: html	html tableHeading:  [		aColumn canSort			ifTrue: [				html anchor					callback: [self sortColumn: aColumn];					text: aColumn title]			ifFalse: [ html text: aColumn title ] ]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 13:58'!renderRowNumber: index item: row on: html	html tableRow		style: 'background-color: ' , (self colorForRowNumber: index);		with: [			columns do: [ :each |				self renderColumn: each row: row on: html ] ]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 14:00'!renderTableFooterOn: html	html tableRow:[		columns do: [ :each |			self renderFooterForColumn: each on: html ] ]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'pmm 7/23/2006 14:00'!renderTableHeaderOn: html	html tableRow: [		columns do: [ :each |			self renderHeaderForColumn: each on: html ] ]! !!WACanvasTableReport methodsFor: 'rendering' stamp: 'mb 2/19/2006 14:40'!rendererClass	^WARenderCanvas! !!WATableReport methodsFor: 'as yet unclassified' stamp: 'ab 11/11/2002 19:04'!chooseRow: aRow column: aColumn		aColumn chooseRow: aRow! !!WATableReport methodsFor: 'as yet unclassified' stamp: 'ab 10/26/2002 22:01'!colorForRowNumber: aNumber	^ rowColors at: ((aNumber-1 // rowPeriod) \\ rowColors size) + 1 ifAbsent: ['white']! !!WATableReport methodsFor: 'accessing' stamp: 'ab 10/26/2002 22:29'!columns: anArray	columns _ anArray! !!WATableReport methodsFor: 'accessing' stamp: 'ab 2/18/2003 19:06'!initialize	super initialize.	isReversed := false.	columns := #().	sortColumn := WAStateHolder new.	rowColors := #('white' 'lightyellow').	rowPeriod := 3! !!WATableReport methodsFor: 'testing' stamp: 'AC 1/31/2003 11:24'!isReversed	^ isReversed! !!WATableReport methodsFor: 'rendering' stamp: 'mb 5/30/2006 11:52'!renderColumn: aColumn row: aRow on: html	| text |	aColumn canRender ifTrue:		[^html tableData: [aColumn renderValue: aRow on: html]].	text _ aColumn textForRow: aRow.	text isEmpty ifTrue: [text _ ' '].	html tableData: [		aColumn canChoose			ifFalse: [html text: text]			ifTrue: [html anchorWithAction: [self chooseRow: aRow column: aColumn] text: text]	]! !!WATableReport methodsFor: 'rendering' stamp: 'ab 5/6/2003 18:31'!renderContentOn: html	html attributeAt: 'cellspacing' put: 0; attributeAt: 'cellpadding' put: 5.	html table: [		self renderTableHeaderOn: html.		self renderRowsOn: html.		self renderTableFooterOn: html.	]! !!WATableReport methodsFor: 'rendering' stamp: 'ab 11/12/2002 14:32'!renderFooterForColumn: aColumn on: html	html tableHeading: [ html text: (aColumn totalForRows: rows)]! !!WATableReport methodsFor: 'rendering' stamp: 'JF 2/3/2003 00:01'!renderHeaderForColumn: aColumn on: html	html tableHeading: [		aColumn canSort			ifTrue: [				html anchorWithAction: [self sortColumn: aColumn] text: aColumn title]			ifFalse: [				html text: aColumn title]	]! !!WATableReport methodsFor: 'rendering' stamp: 'mb 2/9/2006 19:11'!renderRowNumber: index item: row on: html	html attributes backgroundColor: (self colorForRowNumber: index).	html tableRow: [ columns do: [:ea | self renderColumn: ea row: row on: html] ]! !!WATableReport methodsFor: 'rendering' stamp: 'AC 1/31/2003 11:26'!renderRowsOn: html	self rows withIndexDo: [:row :i | self renderRowNumber: i item: row on: html ]! !!WATableReport methodsFor: 'rendering' stamp: 'ab 12/6/2002 00:45'!renderTableFooterOn: html	html tableRow: [ columns do: [ :ea | self renderFooterForColumn: ea on: html] ]! !!WATableReport methodsFor: 'rendering' stamp: 'ab 12/6/2002 00:45'!renderTableHeaderOn: html	html tableRow: [ columns do: [ :ea | self renderHeaderForColumn: ea on: html] ]! !!WATableReport methodsFor: 'accessing' stamp: 'ab 10/26/2002 22:04'!rowColors: colorArray	rowColors _ colorArray! !!WATableReport methodsFor: 'accessing' stamp: 'ab 10/26/2002 22:04'!rowPeriod: aNumber	rowPeriod _ aNumber! !!WATableReport methodsFor: 'accessing' stamp: 'AC 1/31/2003 11:46'!rows	| r |	self sortColumn ifNil: [^ rows].	r _ self sortColumn sortRows: rows.	^ self isReversed ifTrue: [r reversed] ifFalse: [r]! !!WATableReport methodsFor: 'state variables' stamp: 'ab 1/16/2003 17:47'!sortColumn	^ sortColumn contents! !!WATableReport methodsFor: 'state variables' stamp: 'mb 4/23/2006 18:35'!sortColumn: anObject 	isReversed _ anObject = self sortColumn and: [isReversed not ].	sortColumn contents: anObject! !!WARubyTest commentStamp: 'pmm 9/18/2006 19:11' prior: 0!Examples taken directly from spec:http://www.w3.org/TR/2001/REC-ruby-20010531/!!WARubyTest methodsFor: 'rendering' stamp: 'pmm 9/18/2006 22:07'!renderComplexOn: html	html heading level2; with: 'Complex ruby markup'.	html ruby: [		html rubyBaseContainer: [			html rubyBase: 10.			html rubyBase: 31.			html rubyBase: 2002 ].		html rubyTextContainer: [			html rubyText: 'Month'.			html rubyText: 'Day'.			html rubyText: 'Year' ].		html rubyTextContainer: [			html rubyText				span: 3;				with: 'Expiration Date' ] ]! !!WARubyTest methodsFor: 'rendering' stamp: 'pmm 9/18/2006 22:06'!renderContentOn: html	self renderSimpleOn: html.	self renderSimpleParenthesesOn: html.	self renderComplexOn: html! !!WARubyTest methodsFor: 'rendering' stamp: 'pmm 9/18/2006 22:07'!renderSimpleOn: html	html heading level2; with: 'Simple ruby markup'.	html ruby: [		html rubyBase: 'WWW'.		html rubyText: 'World Wide Web' ]! !!WARubyTest methodsFor: 'rendering' stamp: 'pmm 9/18/2006 22:08'!renderSimpleParenthesesOn: html	html heading level2; with: 'Simple ruby markup with parentheses'.	html ruby: [		html rubyBase: 'WWW'.		html rubyParentheses: '('.		html rubyText: 'World Wide Web'.		html rubyParentheses: ')' ]! !!WARubyTest methodsFor: 'rendering' stamp: 'mb 9/21/2006 16:29'!rendererClass	^WARenderCanvas! !!WACanvasScreenshot methodsFor: 'rendering' stamp: 'mb 9/14/2006 11:20'!renderContentOn: html	| group |	html table: [html tableRow: [		html tableData: [			html form: [				html table: [html tableRow: [					html tableData: 'Button: '.					group _ html radioGroup.					#(red yellow blue) do:						[:ea |						(html tableData)							style: 'background-color: ' , ea;							with: 								[(html radioButton)									group: group;									selected: (button = ea);									callback: [button _ ea]]].					html tableData: [html submitButton text: 'Set'].					]].				].			].		html tableData:			[html anchor callback: [self toggleZoom]; text: self toggleZoomText].		html tableData: 			[html anchor callback: [self toggleUIProcess]; text: self toggleUIText]	]].	(html imageMap)		callback: [:pt | self click: pt + self offset];		title: 'Click here';		id: #pictureMap;		form: self form.	html horizontalRule.	! !!WACanvasScreenshot methodsFor: 'rendering' stamp: 'mb 9/12/2006 10:31'!rendererClass	^WARenderCanvas! !!WAScreenshot class methodsFor: 'testing' stamp: 'avi 2/5/2004 12:57'!canBeRoot	^ true! !!WAScreenshot methodsFor: 'accessing' stamp: 'pmm 9/20/2006 17:48'!buttonCode	^ button = #red		ifTrue: [ 4 ]		ifFalse: [			button = #blue				ifTrue: [ 2 ]				ifFalse: [ 1 ] ]! !!WAScreenshot methodsFor: 'actions' stamp: 'pmm 9/20/2006 17:45'!click: aPoint	| event |	event := Sensor createMouseEvent.	event at: 3 put: aPoint x.	event at: 4 put: aPoint y.	event at: 5 put: self buttonCode.	Sensor processEvent: event.		event at: 5 put: 0.	Sensor processEvent: event.	button := #red.! !!WAScreenshot methodsFor: 'accessing' stamp: 'pmm 9/20/2006 17:48'!form	^ zoom		ifFalse: [ Display copy ]		ifTrue: [ self topWindow imageForm ]! !!WAScreenshot methodsFor: 'initialize-release' stamp: 'pmm 9/20/2006 17:45'!initialize	super initialize.	button := #red.	zoom := false! !!WAScreenshot methodsFor: 'accessing' stamp: 'pmm 9/20/2006 17:49'!offset	^ zoom		ifTrue: [ self topWindow position ]		ifFalse: [ 0@0 ]! !!WAScreenshot methodsFor: 'rendering' stamp: 'pmm 9/20/2006 17:59'!renderContentOn: html	html table: [		html tableRow: [			html tableData: [ self renderMouseButtonOn: html ].			html tableData: [ self renderToggleZoomOn: html ].			html tableData: [ self renderToggleUIProcessOn: html ] ] ].	self renderMouseClickOn: html.	html horizontalRule.	! !!WAScreenshot methodsFor: 'rendering' stamp: 'pmm 9/20/2006 17:59'!renderMouseButtonOn: html	| group |	html form: [		html table: [			html tableRow: [				html tableData: 'Button: '.				group := html radioGroup.				#(red yellow blue) do: [ :each |					html tableData						style: 'background-color: ' , each;						with: [							html radioButton								group: group;								selected: button = each;								callback: [ button := each] ] ].				html tableData: [					html submitButton text: 'Set'] ] ] ]! !!WAScreenshot methodsFor: 'rendering' stamp: 'pmm 9/20/2006 17:57'!renderMouseClickOn: html	html imageMap		callback: [ :point | self click: point + self offset];		title: 'Click here';		id: #pictureMap;		form: self form! !!WAScreenshot methodsFor: 'rendering' stamp: 'pmm 9/20/2006 17:56'!renderToggleUIProcessOn: html	html anchor callback: [self toggleUIProcess]; text: self toggleUIText! !!WAScreenshot methodsFor: 'rendering' stamp: 'pmm 9/20/2006 17:55'!renderToggleZoomOn: html	html anchor callback: [self toggleZoom]; text: self toggleZoomText! !!WAScreenshot methodsFor: 'actions' stamp: 'avi 1/21/2004 02:01'!toggleUIProcess	Project uiProcess isSuspended		ifTrue: [Project uiProcess resume]		ifFalse: [Project uiProcess suspend]! !!WAScreenshot methodsFor: 'accessing' stamp: 'avi 1/21/2004 02:01'!toggleUIText	^ Project uiProcess isSuspended		ifFalse: ['Suspend UI Process']		ifTrue: ['Resume UI Process']! !!WAScreenshot methodsFor: 'actions' stamp: 'pmm 9/20/2006 17:47'!toggleZoom	zoom := zoom not! !!WAScreenshot methodsFor: 'accessing' stamp: 'pmm 9/20/2006 17:47'!toggleZoomText	^ zoom		ifTrue: ['Zoom out']		ifFalse: ['Zoom in']! !!WAScreenshot methodsFor: 'accessing' stamp: 'avi 2/5/2004 14:18'!topWindow	^ SystemWindow classPool at: #TopWindow! !!WASelection methodsFor: 'initialization' stamp: 'mb 4/23/2006 15:31'!initialize	super initialize.	items _ #().	labelBlock _ [:ea | ea displayString].! !!WASelection methodsFor: 'accessing' stamp: 'avi 7/5/2004 20:24'!items: aCollection	items _ aCollection! !!WASelection methodsFor: 'accessing' stamp: 'avi 7/5/2004 20:24'!labelBlock: aBlock	labelBlock _ aBlock! !!WASelection methodsFor: 'rendering' stamp: 'avi 7/5/2004 20:25'!renderContentOn: html	html list: items do:		[:ea |		html anchorWithAction: [self answer: ea] text: (labelBlock value: ea)]! !!WASpotProfileReport methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 13:06'!renderContentOn: html	html table:		[html tableHeadings: #('Selector' 'Total Time' 'Time/Req' 'Readings/Req' 'Time/Reading' '').		WASpotProfiler profilers keysAndValuesDo:			[:sel :prof |			html tableHeading: sel.			prof allReadings isEmpty ifFalse:				[html tableData: prof totalTime.				html tableData: prof averageRequestTime.				html tableData: prof averageReadingsPerRequest.				html tableData: prof averageReadingTime.				html tableData: [html anchorWithAction: [prof reset] text: 'reset']]]]! !!WAStore commentStamp: 'avi 1/1/2004 10:06' prior: 0!This component is the entry point for the store example.  It provides the main stylesheet in its #style method, renders a simple banner at the top, and then embeds an instance of WAStoreTask, which is where the real action happens.!!WAStore class methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 12:58'!canBeRoot	^ true! !!WAStore class methodsFor: 'as yet unclassified' stamp: 'mb 5/26/2006 12:25'!description	^'sushiNet - Fresh, raw fish delivered to your door'! !!WAStore class methodsFor: 'as yet unclassified' stamp: 'mb 6/14/2006 14:13'!entryPointName	^'examples/store'! !!WAStore class methodsFor: 'class initialization' stamp: 'mb 6/14/2006 14:13'!initialize	self registerAsApplication: self entryPointName! !!WAStore methodsFor: 'accessing' stamp: 'avi 2/10/2004 20:42'!children	^ Array with: task! !!WAStore methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 18:33'!initialize	super initialize.	task _ WAStoreTask new.! !!WAStore methodsFor: 'rendering' stamp: 'pmm 4/19/2006 22:40'!renderContentOn: html	html table		id: 'banner';		with: [			html tableRow: [				html tableData: [					html div id: 'title'; with: self title.					html div id: 'subtitle'; with: self subtitle ] ] ].	html div id: 'body'; with: task! !!WAStore methodsFor: 'rendering' stamp: 'pmm 4/19/2006 18:24'!rendererClass	^ WARenderCanvas! !!WAStore methodsFor: 'accessing' stamp: 'mb 1/5/2006 14:35'!style	^ 'body {	margin: 0px; 	font-family: sans-serif}#banner {	width: 100%}	#banner tr {	background-color: lightblue;	text-align: right;	padding: 10px;	vertical-align: bottom}#title {	font-size: 18pt;	font-weight: bold}#subtitle {	font-size: 9pt;	font-style: italic}#body {	padding: 5px}.validation-error {	color: red;	font-size: 15pt; 	padding: 5px}'! !!WAStore methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:58'!subtitle	^ 'fresh, raw fish delivered to your door'! !!WAStore methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:58'!title	^ 'sushiNet'! !!WAStoreCartConfirmation commentStamp: 'avi 1/1/2004 09:58' prior: 0!A component for confirming the contents of a WAStoreCart.  The caller must provide a cart instance with #cart: .  When called, it will display a summary of the items in the cart, along with two buttons: "Proceed with checkout" and "Modify cart".  Answers true if the user presses the first button, false if the user presses the seecond.  Used by WAStoreTask>>confirmContentsOfCart.!!WAStoreCartConfirmation methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:35'!cart: aCart	cart _ aCart! !!WAStoreCartConfirmation methodsFor: 'rendering' stamp: 'mb 4/23/2006 20:30'!renderContentOn: html	| table |	table _ html table.	table attributes border: 1.	table id: 'invoice'; with: [		html tableHead:			[#(Item Price Count Total) do:				[:ea | html tableHeading: ea]].		cart countsAndItems do:			[:assoc | |count item|			count _ assoc key.			item _ assoc value.			html tableRow: [				html tableData class: 'item-title'; with: item title.				html tableData class: 'item-price'; with: item price printStringAsCents.				html tableData class: 'item-count'; with: count displayString.				html tableData class: 'item-total'; with: (item price * count) printStringAsCents			]		].		html tableRow: [			html tableData: nil.			html tableData: nil.			html tableData: nil.			html tableData class: 'cart-total'; with:cart totalPrice printStringAsCents		].	].	html paragraph.	html form: [		html submitButton callback: [ self answer: true ]; text: 'Proceed with checkout'.		html break.		html submitButton callback: [self answer: false]; text: 'Modify my order'.	]! !!WAStoreCartConfirmation methodsFor: 'rendering' stamp: 'pmm 4/19/2006 18:27'!rendererClass	^ WARenderCanvas! !!WAStoreCartConfirmation methodsFor: 'accessing' stamp: 'mb 2/9/2006 19:09'!style	^'.item-title {	text-align: left;	width: 15em;}.item-count {	text-align: right;	width: 5em;}.item-price {	text-align: right;	width: 5em;}.item-total {	text-align: right;	width: 5em;}.cart-total {	text-align: right;	font-weight: bold; }#invoice table {	border-collapse: collapse;}#invoice td {	padding: 0.3em;	border: 1px lightblue dotted;}#invoice tr {	background-color: lightyellow;}'! !!WAStoreCartConfirmation methodsFor: 'as yet unclassified' stamp: 'mb 2/10/2006 12:04'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Sushi Store : Verify your cart'.! !!WAStoreCartView commentStamp: 'avi 1/1/2004 09:57' prior: 0!A component for displaying and modifying a WAStoreCart.  Intended to be embedded rather than called.  The parent must provide a cart instance with #cart:.  Displays a list of items in the cart, and allows individual items to be removed.  Used by WAStoreFillCart.!!WAStoreCartView methodsFor: 'accessing' stamp: 'ab 8/15/2003 17:18'!cart: aCart	cart _ aCart! !!WAStoreCartView methodsFor: 'rendering' stamp: 'pmm 4/19/2006 18:38'!renderContentOn: html	cart hasItems ifFalse: [^ self].	html div		id: 'cart';		with: [			html small: [ html bold: 'Your cart:' ].			html table: [				cart countsAndItems do:					[:assoc | self renderRowForCount: assoc key of: assoc value on: html ].				html tableRow: [ html space].				html tableRow: [					html tableData: ''.					html tableData: ''.					html tableData: [html bold: cart totalPrice printStringAsCents] ] ] ]! !!WAStoreCartView methodsFor: 'rendering' stamp: 'mb 4/23/2006 20:33'!renderRowForCount: aNumber of: anItem on: html 	| countString |	countString _ (aNumber = 1) ifTrue: [''] ifFalse: ['(', aNumber displayString, ') '].	html tableRow: [		html tableData: [ html anchor callback: [ cart remove: anItem ]; text: '-'].		html tableData: countString, anItem title.		html tableData: (aNumber * anItem price) printStringAsCents ]! !!WAStoreCartView methodsFor: 'rendering' stamp: 'pmm 4/19/2006 18:34'!rendererClass	^ WARenderCanvas! !!WAStoreFillCart commentStamp: 'avi 1/1/2004 10:10' prior: 0!This component provides the main UI for browsing the store inventory and filling the cart.  The caller must provide a shopping cart instance with #cart:.  The component presents a navigation bar with options to browse and search on the left, and embeds a WACartView showing the cart contents on the right.  In the middle is initially embedded a WAStoreInfo.  Browsing and searching will replace this with a stock WABatchSelection component for listing items (see #displatItems:), or a WAStoreItemView for displaying individual items.  This answers back to the caller when the user chooses "checkout" from the nav bar.!!WAStoreFillCart methodsFor: 'actions' stamp: 'avi 12/9/2003 13:13'!browse	self displayItems: self inventory allItems! !!WAStoreFillCart methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:10'!cart: aCart	cart _ aCart.	cartView cart: aCart.! !!WAStoreFillCart methodsFor: 'actions' stamp: 'ab 8/15/2003 17:11'!checkout	self answer.! !!WAStoreFillCart methodsFor: 'accessing' stamp: 'avi 2/10/2004 20:42'!children	^ Array with: cartView with: main! !!WAStoreFillCart methodsFor: 'actions' stamp: 'pmm 11/2/2005 23:44'!displayItem: anItem	main call: (WAStoreItemView new item: anItem; cart: cart; yourself)! !!WAStoreFillCart methodsFor: 'actions' stamp: 'avi 12/9/2003 13:25'!displayItems: aCollection	| list |	aCollection size = 1 ifTrue: [^ self displayItem: aCollection first].	list _ WABatchSelection			 items: aCollection			 link: #title			 text: #subtitle.	[self displayItem: (main call: list)] repeat	! !!WAStoreFillCart methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 18:33'!initialize	super initialize.	main _ WAStoreInfo new.	cartView _ WAStoreCartView new! !!WAStoreFillCart methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:13'!inventory	^ WAStoreInventory default! !!WAStoreFillCart methodsFor: 'rendering' stamp: 'pmm 4/19/2006 20:06'!renderContentOn: html	html table: ["		html tableRow: [ html tableData colSpan: 3; with: trail ]."		html tableRow: [			html tableData id: 'nav'; with: [ self renderNavBarOn: html ].			html tableData id: 'main'; with: main.			html tableData id: 'side'; with: cartView ] ]! !!WAStoreFillCart methodsFor: 'rendering' stamp: 'pmm 4/19/2006 20:08'!renderNavBarOn: html	html form: [		html bold: 'Search:'.		html space.		html textInput callback: [:v | self search: v]; value: '' ].	html anchor callback: [self browse]; text: 'Browse'.	cart hasItems ifTrue:  [		html break.		html anchor callback: [self checkout]; text: 'Checkout']! !!WAStoreFillCart methodsFor: 'rendering' stamp: 'pmm 4/19/2006 20:03'!rendererClass	^ WARenderCanvas! !!WAStoreFillCart methodsFor: 'actions' stamp: 'avi 12/9/2003 13:13'!search: aString	| results |	results _ self inventory findItem: aString.	results isEmpty		ifTrue: [main inform: 'No items match ', aString printString]		ifFalse: [self displayItems: results].! !!WAStoreFillCart methodsFor: 'accessing' stamp: 'avi 12/9/2003 15:33'!style^ '	#search {vertical-align: bottom}	#main {width: 50%; padding: 10px}	#side {vertical-align: top; }	#cart {border-style: dashed; border-width: 1; padding: 5px}	#nav {background-color: lightgrey; vertical-align: top; padding: 5px; border-width: 1; width: 15%; font-size: 12pt}	#batch {font-size: 10pt}'! !!WAStoreFillCart methodsFor: 'as yet unclassified' stamp: 'mb 2/10/2006 12:03'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot title: 'Seaside Sushi Store : Fill your cart'.! !!WAStoreInfo commentStamp: 'avi 1/1/2004 09:57' prior: 0!A component that displays simple informative text about this example.  Used by WAStoreFillCart.!!WAStoreInfo methodsFor: 'rendering' stamp: 'mb 4/23/2006 20:25'!renderContentOn: html	html withLineBreaks: self text! !!WAStoreInfo methodsFor: 'rendering' stamp: 'pmm 4/19/2006 20:08'!rendererClass	^ WARenderCanvas! !!WAStoreInfo methodsFor: 'as yet unclassified' stamp: 'mb 2/9/2006 19:10'!text	^'Welcome to the sushiNet online store.This is a sample Seaside application.Use the search box at the top left to find some results.Good searches to try might be "tuna", "saba", or "fish".'! !!WAStoreItemView commentStamp: 'avi 1/1/2004 09:58' prior: 0!A component for viewing an individual WAStoreItem.  The caller must provide #item: and also the current #cart:.  Shows the description and price info for the item, and presents two buttons: "Add to Cart", which will add the item to the cart, once, and "Done", which will answer back to the caller.  Used by WAStoreFillCart>>displayItem: and displayItems:.!!WAStoreItemView methodsFor: 'actions' stamp: 'avi 12/9/2003 13:11'!addToCart	cart add: item! !!WAStoreItemView methodsFor: 'accessing' stamp: 'avi 12/9/2003 13:11'!cart: aCart	cart _ aCart! !!WAStoreItemView methodsFor: 'accessing' stamp: 'ab 5/25/2003 14:47'!item: anItem	item _ anItem! !!WAStoreItemView methodsFor: 'rendering' stamp: 'pmm 4/19/2006 22:12'!renderContentOn: html	html heading: item title.	html heading level3; with: item subtitle.	html paragraph: item description.	html italic: item price printStringAsCents.	html form: [		html submitButton callback: [self addToCart]; text: 'Add To Cart'.		html space.		html submitButton callback: [self answer]; text: 'Done' ]! !!WAStoreItemView methodsFor: 'rendering' stamp: 'pmm 4/19/2006 20:11'!rendererClass	^ WARenderCanvas! !!WAStoreItemView methodsFor: 'updating' stamp: 'mb 11/27/2005 19:31'!updateUrl: aUrl	aUrl addToPath: item title! !!WACanvasTableReportTest class methodsFor: 'examples' stamp: 'mb 2/19/2006 14:43'!example	^ self new! !!WACanvasTableReportTest methodsFor: 'private' stamp: 'mb 2/19/2006 14:42'!widgetClass	^WACanvasTableReport! !!WATableReportTest class methodsFor: 'as yet unclassified' stamp: 'mb 2/10/2006 13:11'!example	^ self new! !!WATableReportTest methodsFor: 'accessing' stamp: 'mb 2/10/2006 13:08'!children	^Array with: widget.! !!WATableReportTest methodsFor: 'initialize-release' stamp: 'mb 5/30/2006 12:14'!initialize	| cols rows |	cols _ OrderedCollection new		add: (WAReportColumn				selector: #title				title: 'Title'				onClick: [:v | self inform: v description]);		add: (WAReportColumn				selector: #subtitle				title: 'Subtitle');		add: (WAReportColumn				selector: #price				title: 'Price');		add: (WAReportColumn				renderBlock: [:obj :html | html emphasis: obj description]				title: 'Description');		yourself.	rows _ WAStoreInventory default allItems.	widget _ self widgetClass new				columns: cols;				rows: rows;				rowPeriod: 1;				rowColors: #(lightblue lightyellow);				yourself.! !!WATableReportTest methodsFor: 'rendering' stamp: 'mb 2/10/2006 13:07'!renderContentOn: html	html render: widget.! !!WATableReportTest methodsFor: 'private' stamp: 'mb 2/19/2006 14:41'!widgetClass	^WATableReport! !!WATask commentStamp: '<historical>' prior: 0!I am a subclass of WAComponent, specialized for defining workflow.  The difference between a task and a component is the following:Both of them are reusable, embeddable, callable pieces of user interface. A component has state (instance variables), behavior (it may change its state, and it may also choose to display other components with #call:), and appearance (it renders HTML). A Task has only the first two - it doesn't render any HTML directly, but only through the components it calls. This is useful when what you want to encapsulate/embed/call is purely a process (show this component, then this one, then this one).The key method for WATask is #go - as soon as a task is displayed, this method will get invoked, and will presumably #call: other components.In terms of implementation, you can think of a WATask in the following way: it is a component which renders two things:- a link whose callback invokes the #go method- a header that immediately redirects to the URL of that link!!WACookieTest methodsFor: 'actions' stamp: 'mb 2/27/2006 08:34'!go	[self session checkForCookies]		whileFalse: [self inform: 'You must have cookies enabled to proceed.'].	self session redirectWithCookies: (Array with:		"Should get back empty cookie ?"		(WACookie new			key: 'nullCookie';			expireIn: (Duration seconds: 60);			yourself)	with:			(WACookie new			key: 'cookietest';			value: 1000 atRandom displayString;			expireIn: (Duration seconds: 60);			yourself)	with:			"Should get back multiple (i.e. a collection of) cookies with same key ?"		(WACookie new			key: 'cookietest';			value: 1000 atRandom displayString;			expireIn: (Duration seconds: 60);			yourself)).	self inform: self session currentRequest cookies displayString.! !!WAExceptionTest methodsFor: 'processing' stamp: 'mbany 4/14/2005 12:14'!go	[(self confirm: 'Raise an exception?')		ifTrue: [self error: 'foo']]			on: Error			do: [:e | self inform: 'Caught: ', e displayString]! !!WAStoreTask commentStamp: 'avi 1/1/2004 10:19' prior: 0!This task models the main application flow of the store example.  Most of the other components in the example are called from here.  The flow is defined by the #go method.  After creating a WAStoreCart instance, this calls WAStoreFillCart to allow the user to add items to it.  It then calls WAStoreCartConfirmation, WAStoreAddressEditor, and WAStorePaymentEditor in succession for the checkout process.  Many of the components it calls are wrapped with informative messages (#withMessage:) and validation (#validateWith:).  It also makes use of WASession>>isolate: to ensure that once the checkout process starts, backtracking to modify the cart is forbidden.  Used by WAStore.!!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 3/13/2004 21:37'!confirmContentsOfCart	^ self call:		((WAStoreCartConfirmation new cart: cart)			addMessage: 'Please verify your order:')! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 13:28'!displayConfirmation	self inform: 'Your fish is on its way.'! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 1/14/2004 22:51'!fillCart	self call: (WAStoreFillCart new cart: cart)! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 16:35'!getAddressWithMessage: aString	^ self call:		(WAStoreAddressEditor new			validateWith: [:a | a validate];			addMessage: aString;			yourself)				! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 13:43'!getBillingAddress	^ self getAddressWithMessage: 'Please enter your billing address:'.! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 18:55'!getPaymentInfo	^ self call:		(WAStorePaymentEditor new			validateWith: [:p | p validate];			addMessage: 'Please enter your payment information:';			yourself)! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 11/6/2005 00:38'!getShippingAddress	^ self getAddressWithMessage: 'Please enter your shipping address:'.! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 21:58'!go	| shipping billing creditCard |	cart _ WAStoreCart new.	self isolate:		[[self fillCart.		self confirmContentsOfCart]			whileFalse].	self isolate:		[shipping _ self getShippingAddress.		billing _ (self useAsBillingAddress: shipping)					ifFalse: [self getBillingAddress]					ifTrue: [shipping].		creditCard _ self getPaymentInfo.		self shipTo: shipping billTo: billing payWith: creditCard].	self displayConfirmation.! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:04'!shipTo: shippingAddress billTo: billingAddress payWith: aCreditCard	"no-op"! !!WAStoreTask methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 13:44'!useAsBillingAddress: anAddress	^ self confirm: 'Do you wish to use ', anAddress street printString, ' as your billing address?'! !!WATask methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:50'!decoration: oldDecoration shouldWrap: newDecoration	^ (oldDecoration isGlobal and: [newDecoration isGlobal not])		or: [oldDecoration isLocal and: [newDecoration isDelegation]]! !!WATask methodsFor: 'processing' stamp: 'jf 11/10/2003 16:13'!go	self subclassResponsibility! !!WATask methodsFor: 'rendering' stamp: 'avi 6/2/2004 21:02'!renderContentOn: html	self session redirectTo: (html urlForAction: [[self answer: self go] repeat])! !!WAMemoryUseTool class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:54'!linkText	^ 'Memory Use'! !!WAMemoryUseTool class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:54'!title	^ 'Memory Use'! !!WAMemoryUseTool methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:44'!go	self call: (WAMemoryUse new root: self session)! !!WAProfilerTool class methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 14:10'!linkText	^ 'Profile'! !!WAProfilerTool class methodsFor: 'as yet unclassified' stamp: 'ab 7/10/2003 14:10'!title	^ 'Profiler'! !!WAProfilerTool methodsFor: 'processing' stamp: 'avi 2/10/2004 16:13'!go	self call: (WAProfiler new contents: root)! !!WASpotProfilerTool class methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 13:00'!linkText	^ 'Spot'! !!WASpotProfilerTool class methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 13:00'!title	^ 'Spot Profiler'! !!WASpotProfilerTool methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 13:00'!go	self call: (WASpotProfileReport new)! !!WATool class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:43'!linkText	^ self name! !!WATool class methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:43'!title	^ self name! !!WATool methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:42'!root: aComponent	root _ aComponent! !!WATransactionTest methodsFor: 'processing' stamp: 'avi 3/22/2004 15:16'!go	self inform: 'Before parent txn'.	self isolate: 			[self inform: 'Inside parent txn'.			self isolate: [self inform: 'Inside child txn'].			self inform: 'Outside child txn'].	self inform: 'Outside parent txn'! !!WATaskTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 14:05'!renderContentOn: html	html anchorWithAction: [self call: WAExceptionTest new] text: 'go'.! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:38'!date: aDate 	second := aDate dayOfMonth.	hour := aDate monthIndex.	minute := aDate year! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:37'!days	^ 1 to: 31! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:48'!endHour	^endHour! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:48'!endHour: anInteger 	endHour := anInteger! !!WATimeSelector methodsFor: 'initialize-release' stamp: 'mb 5/6/2006 16:10'!initialize	super initialize.	startHour _ 0.	endHour _ 23.	self time: Time midnight! !!WATimeSelector methodsFor: 'private' stamp: 'pmm 10/2/2006 21:13'!privateIsValidSecond: theSecond hourNumber: theHour minuteNumber: theMinute	^ (theHour between: 0 and: 23)		and: [ theMinute between: 0 and: 59 ]		and: [ theSecond between: 0 and: 59 ]! !!WATimeSelector methodsFor: 'rendering' stamp: 'mb 4/22/2006 21:15'!renderContentOn: html 	html 		selectFromList: (0 to: 23)		selected: hour		callback: [:i | hour := i]		labels: [:ea | ea].	html 		selectFromList: (0 to: 59)		selected: minute		callback: [:i | minute := i]		labels: [:ea | ea].	html 		selectFromList: (0 to: 59)		selected: second		callback: [:i | second := i]		labels: [:ea | ea].	self timeIsValid ifFalse: [self renderValidationErrorOn: html]! !!WATimeSelector methodsFor: 'rendering' stamp: 'jlr 4/4/2006 23:52'!renderValidationErrorOn: html	html spanClass: 'error' with: 'invalid time'! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:48'!startHour	^startHour! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:48'!startHour: anInteger 	startHour := anInteger! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:45'!time	(self 		privateIsValidSecond: second		hourNumber: hour		minuteNumber: minute) ifFalse: [self error: 'Invalid time'].	^Time 		hour: hour		minute: minute		second: second! !!WATimeSelector methodsFor: 'accessing' stamp: 'jlr 4/4/2006 23:47'!time: aTime 	second := aTime second.	hour := aTime hour.	minute := aTime minute! !!WATimeSelector methodsFor: 'testing' stamp: 'jlr 4/4/2006 23:46'!timeIsValid	[self time] on: Error do: [:e | ^ false].	^ true! !!WATrail class methodsFor: 'as yet unclassified' stamp: 'ab 8/26/2003 15:27'!on: anObject	^ self new root: anObject! !!WATrail methodsFor: 'rendering' stamp: 'avi 4/13/2004 22:15'!renderContentOn: html	|last selected|	html cssClass: 'trail'.	html unorderedList: [		root visiblePresentersDo: 			[:ea |			(ea isDecoration and: [ea isDelegation]) ifTrue:				[(ea component respondsTo: #trailName) ifTrue:					[last _ ea.					html listItem: [						html anchorWithAction: [ea remove] text: ea component trailName.					]]]].		selected _ last ifNil: [root] ifNotNil: [last delegate].		(selected respondsTo: #trailName) ifTrue:			[html listItem: selected trailName].	]! !!WATrail methodsFor: 'accessing' stamp: 'ab 8/26/2003 15:27'!root: anObject	root := anObject! !!WATrail methodsFor: 'rendering' stamp: 'avi 4/13/2004 22:16'!style^'	ul.trail {		margin-left: 0;		padding-left: 0;		display: inline;		border: none;	}	ul.trail li {        	margin-left: 0;        	padding-left: 2px;        	border: none;        	list-style: none;        	display: inline;	}		ul.trail  li:before {        content: "\0020 \0020 \0020 \00BB \0020";        }        	ul.trail li.first:before {        content: " ";        }'! !!WATree class methodsFor: 'examples' stamp: 'lr 3/27/2006 11:13'!exampleCollectionClasses	^ self new		root: Collection;		labelBlock: [ :class | class name ];		childrenBlock: [ :class | class subclasses ];		yourself! !!WATree class methodsFor: 'examples' stamp: 'lr 3/27/2006 11:24'!exampleObjectExplorer	^ self new		root: 'dispatcher' -> WADispatcher default;		labelBlock: [ :assoc | assoc ];		childrenBlock: [ :assoc | assoc value inspectorFields ];		yourself! !!WATree class methodsFor: 'instance-creation' stamp: 'lr 3/27/2006 11:08'!root: anObject	^ self new		root: anObject;		yourself! !!WATree class methodsFor: 'instance-creation' stamp: 'lr 3/27/2006 11:09'!root: anObject path: anArray	^ (self root: anObject)		expandAll: anArray;		selected: anArray last;		yourself! !!WATree methodsFor: 'testing' stamp: 'lr 3/7/2005 17:39'!canSelect: aNode	^self selectBlock notNil		and: [ self canSelectBlock isNil			or: [ self canSelectBlock value: aNode ] ].! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 12:11'!canSelectBlock	^canSelectBlock! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 3/7/2005 17:40'!canSelectBlock: aBlock	canSelectBlock := aBlock! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:19'!childrenBlock	^childrenBlock! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:20'!childrenBlock: aBlock	childrenBlock := aBlock! !!WATree methodsFor: 'accessing-nodes' stamp: 'lr 3/27/2006 09:12'!childrenOf: aNode	| children |	children := self childrenBlock value: aNode.	^ children ifNil: [ Array new ]! !!WATree methodsFor: 'actions' stamp: 'lr 2/19/2005 16:03'!collapse: aNode	expanded remove: aNode.! !!WATree methodsFor: 'actions' stamp: 'lr 2/19/2005 11:20'!expand: aNode	expanded add: aNode.! !!WATree methodsFor: 'actions' stamp: 'lr 3/28/2005 21:15'!expandAll: aCollection	expanded addAll: aCollection.! !!WATree methodsFor: 'testing' stamp: 'lr 2/19/2005 16:25'!hasChildren: aNode	^(self childrenOf: aNode) 		isEmpty not.! !!WATree methodsFor: 'initialization' stamp: 'lr 3/27/2006 11:25'!initialize	super initialize.	self session registerObjectForBacktracking: (expanded := IdentitySet new).	self selectBlock: [ :node | self answer: node ].	self childrenBlock: [ :node | Array new ].	self labelBlock: [ :node | node displayString ]! !!WATree methodsFor: 'testing' stamp: 'lr 2/19/2005 11:18'!isExpanded: aNode	^expanded includes: aNode.! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:19'!labelBlock	^labelBlock! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:20'!labelBlock: aBlock	labelBlock := aBlock! !!WATree methodsFor: 'accessing-nodes' stamp: 'lr 2/19/2005 12:06'!labelOf: aNode	^self labelBlock value: aNode.! !!WATree methodsFor: 'rendering' stamp: 'lr 2/19/2005 11:41'!renderContentOn: html	self renderTreeOn: html.! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 2/19/2005 11:27'!renderNode: aNode on: html	html listItem: [		self renderNodeButton: aNode on: html.		self renderNodeLabel: aNode on: html.		self renderNodeChildren: aNode on: html ].! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 3/19/2005 19:46'!renderNodeButton: aNode on: html	| isExpanded |	html spanClass: 'button' with: [		(self hasChildren: aNode) ifTrue: [			isExpanded := self isExpanded: aNode.			self 				renderNodeButtonLink: aNode 				action: (MessageSend 					receiver: self 					selector: (isExpanded						ifTrue: [ #collapse: ]						ifFalse: [ #expand: ])					argument: aNode)				text: (isExpanded					ifTrue: [ '-' ]					ifFalse: [ '+' ])				on: html ] ].! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 2/19/2005 16:11'!renderNodeButtonLink: aNode action: aBlock text: aString on: html	html anchorWithAction: aBlock text: aString.! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 2/19/2005 16:07'!renderNodeChildren: aNode on: html	| children |	children := self childrenOf: aNode.	children isEmpty ifFalse: [		(self isExpanded: aNode) ifTrue: [			html unorderedList: [				children do: [ :each |					self renderNode: each on: html ] ] ] ].! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 3/27/2006 11:26'!renderNodeLabel: aNode on: html	| label |	self selected == aNode		ifTrue: [ html cssClass: 'active' ].	html spanClass: 'label' with: [		label := self labelOf: aNode.		(self canSelect: aNode)			ifFalse: [ html render: label ]			ifTrue: [				self renderNodeLabelLink: aNode				action: (MessageSend					receiver: self 					selector: #select:					argument: aNode)				text: label on: html ] ].! !!WATree methodsFor: 'rendering-nodes' stamp: 'lr 2/19/2005 16:12'!renderNodeLabelLink: aNode action: aBlock text: aString on: html	html anchorWithAction: aBlock text: aString.! !!WATree methodsFor: 'rendering' stamp: 'lr 3/7/2005 16:30'!renderTreeOn: html	html unorderedList: [ self renderNode: self root on: html ].! !!WATree methodsFor: 'accessing' stamp: 'lr 2/19/2005 11:18'!root	^root! !!WATree methodsFor: 'accessing' stamp: 'lr 2/19/2005 11:18'!root: aNode	root := aNode! !!WATree methodsFor: 'actions' stamp: 'lr 3/28/2005 21:13'!select: aNode	(self canSelect: aNode) ifTrue: [		self selected: aNode.		self selectBlock isNil			ifFalse: [ self selectBlock value: aNode ] ].! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:21'!selectBlock	^selectBlock! !!WATree methodsFor: 'accessing-configuration' stamp: 'lr 2/19/2005 11:21'!selectBlock: aBlock	selectBlock := aBlock! !!WATree methodsFor: 'accessing' stamp: 'lr 2/19/2005 11:19'!selected	^selected! !!WATree methodsFor: 'accessing' stamp: 'lr 2/19/2005 11:19'!selected: aNode	selected := aNode! !!WAUploadTest methodsFor: 'rendering' stamp: 'mb 9/22/2006 12:18'!renderContentOn: html	html heading: 'Upload File'.		html attributeAt: 'enctype' put: 'multipart/form-data'.	html form: [		html fileUploadWithCallback: [:f | file _ f].		html submitButton.	].	file ifNotNil:		[html 			anchorWithDocument: file contents 			mimeType: file contentType			fileName: file fileName			text: file fileName , ' (' , file contentType , ')'. 		html break. 		html anchorWithDocument: file contents text: file fileName.		html preformatted: file contents].! !!WAVNCController class methodsFor: 'class initialization' stamp: 'avi 10/20/2005 23:52'!initialize	(Smalltalk hasClassNamed: 'RFBServer') ifTrue: [self registerAsApplication: 'vnc']! !!WAVNCController methodsFor: 'accessing' stamp: 'avi 10/20/2005 23:48'!currentDisplay	^ RFBServer server displayNumber asString! !!WAVNCController methodsFor: 'rendering' stamp: 'avi 10/20/2005 23:06'!renderContentOn: html	html heading: 'VNC Server'.	RFBServer server		ifNil: [self renderStartOn: html]		ifNotNil: [self renderStopOn: html].	html heading: 'UI Process'.	Project uiProcess isSuspended		ifFalse: [self renderSuspendOn: html]		ifTrue: [self renderResumeOn: html]! !!WAVNCController methodsFor: 'rendering' stamp: 'avi 10/20/2005 23:51'!renderResumeOn: html	html form:		[html text: 'UI Process is suspended.  '.		html submitButtonWithAction: [self resume] text: 'Resume']! !!WAVNCController methodsFor: 'rendering' stamp: 'avi 10/20/2005 23:33'!renderStartOn: html	html form:		[html text: 'Start VNC on display: '.		html textInputWithValue: 0 callback: [:v | self startOn: v].		html submitButtonWithText: 'Start']! !!WAVNCController methodsFor: 'rendering' stamp: 'avi 10/20/2005 23:46'!renderStopOn: html	html form:		[html text: 'Stop VNC (running on ', self currentDisplay, ') '.		html submitButtonWithAction: [self stop] text: 'Stop']! !!WAVNCController methodsFor: 'rendering' stamp: 'avi 10/20/2005 23:51'!renderSuspendOn: html	html form:		[html text: 'UI Process is running.  '.		html submitButtonWithAction: [self suspend] text: 'Suspend']! !!WAVNCController methodsFor: 'actions' stamp: 'avi 10/20/2005 23:51'!resume	Project uiProcess resume! !!WAVNCController methodsFor: 'actions' stamp: 'avi 10/20/2005 23:49'!startOn: aNumber	self resume.	RFBServer start: aNumber! !!WAVNCController methodsFor: 'actions' stamp: 'avi 10/20/2005 23:49'!stop	RFBServer stop! !!WAVNCController methodsFor: 'actions' stamp: 'avi 10/20/2005 23:53'!suspend	Project uiProcess suspend.	self stop! !!WAVersionUploader class methodsFor: 'testing' stamp: 'avi 2/5/2004 12:57'!canBeRoot	^ true! !!WAVersionUploader methodsFor: 'actions' stamp: 'avi 1/21/2004 18:58'!loadFile	| reader version |	reader _ MCVersionReader readerClassForFileNamed: file fileName.	reader ifNil: [self inform: file fileName, ' is not in a known format'].	version _ reader versionFromStream: file contents asByteArray readStream.	version load.! !!WAVersionUploader methodsFor: 'actions' stamp: 'avi 1/21/2004 18:58'!loadURL	| stream version |	stream _ url asUrl retrieveContents content asByteArray readStream .	version _ (MCVersionReader readerClassForFileNamed: url) versionFromStream: stream.	version load.! !!WAVersionUploader methodsFor: 'rendering' stamp: 'avi 5/10/2005 14:34'!newVersion: aWorkingCopy	| version s |	version _ [aWorkingCopy newVersion]				on: MCVersionNameAndMessageRequest 				do: [:n | n resume: (Array with: n suggestedName with: '')].	s _ RWBinaryOrTextStream on: String new.	version fileOutOn: s.	self session respond:		[:u |		u addToPath: version fileName.		WAResponse redirectTo: u displayString].	self session returnResponse: (WAResponse new									contentType: 'application/octet-stream';									nextPutAll: s contents;									yourself)! !!WAVersionUploader methodsFor: 'rendering' stamp: 'dc 7/22/2006 11:07'!renderContentOn: html	html bold: 'Loaded versions:'.	html unorderedList 		with: [MCWorkingCopy allManagers				do: [:ea | 					html listItem: [						html anchor callback: [self newVersion: ea]; text: 'Save'.						html space.						html text: ea description]]].		html form		multipart;		with: [			html bold: 'Load version from file: '.			html break.			html fileUpload callback: [:f | file _ f].			html space.			html submitButton callback: [self loadFile]; text: 'Load'.	].	html form		with: [			html bold: 'Load version from URL: '.			html break.			html textInput size: 60; value: 'http://'; callback: [:u | url _ u].			html space.			html submitButton callback: [self loadURL]; text: 'Load'.	].	html anchor callback: [self saveImage]; text: 'Save Image'. ! !!WAVersionUploader methodsFor: 'rendering' stamp: 'dc 7/22/2006 11:01'!rendererClass	^ WARenderCanvas ! !!WAVersionUploader methodsFor: 'actions' stamp: 'ab 8/30/2003 20:55'!saveImage	Smalltalk snapshot: true andQuit: false! !!WAWalkback methodsFor: 'actions' stamp: 'avi 11/10/2003 01:54'!debug	self answer! !!WAWalkback methodsFor: 'accessing' stamp: 'avi 10/26/2004 14:05'!exception: anException	exception _ anException! !!WAWalkback methodsFor: 'actions' stamp: 'lr 3/28/2005 17:52'!fullstack	fullstack _ true	! !!WAWalkback methodsFor: 'initialization' stamp: 'lr 3/28/2005 17:55'!initialize	super initialize.	fullstack _ false.! !!WAWalkback methodsFor: 'rendering' stamp: 'lr 3/28/2005 17:53'!renderContentOn: html	html anchorWithAction: [self debug] text: 'Debug'; space.	html anchorWithAction: [self fullstack] text: 'Full Stack'.	self renderWalkbackOn: html.! !!WAWalkback methodsFor: 'rendering' stamp: 'lr 3/30/2005 23:29'!renderObject: anObject labelled: aString on: html	| objectString |	[objectString := (SeasidePlatformSupport isProxy: anObject)					ifTrue: [anObject printString]					ifFalse: [anObject printStringLimitedTo: 100]]		on: Error		do: [:err | objectString := '<font color="FF0000">&lt;error in printStringLimitedTo:&gt;</font>'].	html tableRowWithLabel: aString column: [		html html: objectString ].! !!WAWalkback methodsFor: 'rendering' stamp: 'mb 11/27/2005 19:38'!renderStackFrame: aContext on: html	| receiver |	html listItem: [		html text: aContext fullPrintString.		html blockquote: [ html table: [			receiver := aContext receiver.			self renderObject: receiver labelled: 'self' on: html.			html tableRowWith: [html bold: 'temps'] span: 2.			aContext tempNames withIndexDo:			[:name :index |			self renderObject: (aContext tempAt: index) labelled: name on: html].			receiver == nil ifFalse: [				((SeasidePlatformSupport isProxy: receiver) not and: [receiver class instSize > 0]) ifTrue:					[html tableRowWith: [html bold: 'inst vars'] span: 2.					receiver class allInstVarNames withIndexDo:					[:name :index |					self renderObject: (receiver instVarAt: index) labelled: name on: html]]].		]]	]! !!WAWalkback methodsFor: 'rendering' stamp: 'lr 3/28/2005 17:56'!renderWalkbackOn: html	| context count |	html heading: exception description.	html unorderedList: [		context _ thisContext. count _ 0.		[context receiver isKindOf: Exception] whileFalse: [context _ context sender].		[context receiver isKindOf: Exception] whileTrue: [context _ context sender].		[context notNil and: [ fullstack or: [ count < 5 ] ] ] whileTrue: [			self renderStackFrame: context on: html.			context _ context sender.			count _ count + 1].	]! !!WADecoration commentStamp: '<historical>' prior: 0!I am an abstract decoration around instances of WAComponent. I can be added to aComponent by calling #addDecoration: and I change the basic behaviour or look of a component. There are several methods that can be overriden to archive this:- #renderContentOn: to emit xhtml around the decorated component. Call #renderOwnerOn: to let the owner emit its output.- #processChildCallbacks: to intercept the callback processing of the owner.- #handleAnswer: to intercept the answer processing.!!WAAnswerHandler methodsFor: 'as yet unclassified' stamp: 'avi 6/2/2004 21:59'!block: aBlock	block _ aBlock! !!WAAnswerHandler methodsFor: 'as yet unclassified' stamp: 'avi 6/22/2004 11:03'!handleAnswer: anObject continueWith: aBlock	block value: anObject! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 2/2/2004 13:03'!authenticator: anAuthenticator	authenticator _ anAuthenticator! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:51'!isGlobal	^ true! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 00:56'!processChildCallbacks: aStream	(self verifyRequest: self session currentRequest)		ifTrue: [super processChildCallbacks: aStream]		ifFalse: [self respondWithChallenge]! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 3/22/2004 00:04'!realm	^ realm ifNil: [self session application basePath]! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 13:52'!realm: aString	realm _ aString! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'jf 5/8/2004 13:03'!renderContentOn: html	(self verifyRequest: html request)		ifTrue: [self renderOwnerOn: html]		ifFalse: [self respondWithChallenge]! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 5/19/2004 14:16'!respondWithChallenge	self session returnResponse: (WAResponse basicAuthWithRealm: self realm)! !!WABasicAuthentication methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 21:42'!verifyRequest: aRequest	^ authenticator verifyPassword: aRequest password  forUser: aRequest user! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'ac 3/22/2006 15:04'!asComponent 	^ self component! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 22:13'!component	^ self owner isDecoration		ifTrue: [self owner component]		ifFalse: [self owner]! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 6/22/2004 11:02'!handleAnswer: anObject	(self owner handleAnswer: anObject) ifFalse:		[self handleAnswer: anObject continueWith: [^ false]].	^ true! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 6/22/2004 11:03'!handleAnswer: anObject continueWith: aBlock	aBlock value! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 19:55'!isDecoration	^ true! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 22:23'!isDelegation	^ false! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:48'!isGlobal	^ false! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:49'!isLocal	^ (self isGlobal or: [self isDelegation]) not! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 12:43'!nextPresentersDo: aBlock	aBlock value: self owner! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:20'!owner	^ next ifNotNil: [next contents]! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:20'!owner: aPresenter	next ifNil: [next _ WAStateHolder new].	next contents: aPresenter! !!WADecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 16:10'!remove	self component removeDecoration: self! !!WADecoration methodsFor: 'rendering' stamp: 'avi 3/27/2004 21:07'!renderOwnerOn: html	self owner ifNotNilDo: [:owner | owner renderWithContext: html context]! !!WADelayedAnswerDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2005 20:34'!delay	^ delay ifNil: [1]! !!WADelayedAnswerDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2005 20:34'!delay: aNumber	delay _ aNumber! !!WADelayedAnswerDecoration methodsFor: 'as yet unclassified' stamp: 'mb 6/14/2006 12:36'!updateRoot: aRoot	| callbacks url |	callbacks _ WACallbackRegistry context: aRoot context owner: self.	url _ aRoot context actionUrl withParameter: (callbacks registerActionCallback: [self component answer]).	aRoot addHeadElement:		((WAHtmlElement named: 'meta')				attributeAt: 'http-equiv' put: 'refresh';				attributeAt: 'content' put: self delay displayString , ';URL=' , url asString;				yourself).  ! !!WADelegation methodsFor: 'as yet unclassified' stamp: 'avi 3/12/2004 20:18'!delegate	^ delegate! !!WADelegation methodsFor: 'as yet unclassified' stamp: 'avi 3/12/2004 20:18'!delegate: aComponent	delegate _ aComponent! !!WADelegation methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 22:26'!isDelegation	^ true! !!WADelegation methodsFor: 'as yet unclassified' stamp: 'avi 4/22/2004 14:51'!nextPresentersDo: aBlock	delegate decorationChainDo: aBlock! !!WAFormDecoration methodsFor: 'accessing' stamp: 'avi 3/16/2004 13:36'!buttons	^ buttons! !!WAFormDecoration methodsFor: 'accessing' stamp: 'avi 3/16/2004 13:34'!buttons: selectorArray	buttons _ selectorArray! !!WAFormDecoration methodsFor: 'actions' stamp: 'mb 4/4/2006 13:42'!defaultAction	MessageSend receiver: self owner selector: self owner defaultButton! !!WAFormDecoration methodsFor: 'rendering' stamp: 'mb 4/4/2006 13:42'!renderButtonForSelector: aSymbol on: html	aSymbol == self owner defaultButton ifTrue:		[html autofocus:			[html submitButtonOn: aSymbol of: self owner]]	ifFalse:		[html submitButtonOn: aSymbol of: self owner]! !!WAFormDecoration methodsFor: 'rendering' stamp: 'mb 2/10/2006 13:49'!renderButtonsOn: html	html divClass: 'dialog-buttons' with: [		self buttons do:			[:ea |			"Avoid duplicate cssId, if component used many times in the page"			html 				spanClass: 'dialog-button-' , ea				with: [self renderButtonForSelector: ea on: html]]	]! !!WAFormDecoration methodsFor: 'rendering' stamp: 'mb 4/4/2006 13:32'!renderContentOn: html	html form: [		html defaultAction: [self defaultAction].		self renderOwnerOn: html.		self renderButtonsOn: html.	]! !!WAMessageDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/12/2004 00:43'!message: aString	message _ aString! !!WAMessageDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/12/2004 00:49'!renderContentOn: html	html heading: message level: 3.	self renderOwnerOn: html.! !!WASessionProtector methodsFor: 'testing' stamp: 'lr 8/31/2004 18:49'!isGlobal	^true! !!WASessionProtector methodsFor: 'forwarding' stamp: 'lr 8/31/2004 19:36'!processChildCallbacks: aStream	(self verifyRequest: self session currentRequest)		ifTrue: [ super processChildCallbacks: aStream ]		ifFalse: [ self respondNotVerified ]! !!WASessionProtector methodsFor: 'accessing' stamp: 'lr 8/31/2004 19:32'!remoteAddressFromRequest: aRequest	^aRequest 		headerAt: 'x-forwarded-for'		ifAbsent: [ aRequest nativeRequest remoteAddress ]! !!WASessionProtector methodsFor: 'forwarding' stamp: 'lr 8/31/2004 19:36'!renderContentOn: html	(self verifyRequest: html request)		ifTrue: [ self renderOwnerOn: html ]		ifFalse: [ self respondNotVerified ]! !!WASessionProtector methodsFor: 'forwarding' stamp: 'lr 8/31/2004 19:37'!respondNotVerified	self session redirectTo: self session application basePath.! !!WASessionProtector methodsFor: 'accessing' stamp: 'lr 8/31/2004 19:38'!storedRemoteAddress	remoteAddress isNil		ifTrue: [ remoteAddress _ self remoteAddressFromRequest: self session currentRequest ].	^remoteAddress! !!WASessionProtector methodsFor: 'testing' stamp: 'lr 8/31/2004 19:31'!verifyRequest: aRequest	^(self remoteAddressFromRequest: aRequest) = self storedRemoteAddress! !!WATransaction methodsFor: 'as yet unclassified' stamp: 'ab 1/15/2003 21:55'!close	active _ false! !!WATransaction methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 18:36'!initialize	super initialize.	active _ true! !!WATransaction methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:51'!isGlobal	^ true! !!WATransaction methodsFor: 'as yet unclassified' stamp: 'avi 6/8/2004 00:56'!processChildCallbacks: aStream	^ active		ifTrue: [super processChildCallbacks: aStream]		ifFalse: [self session pageExpired].	! !!WATransaction methodsFor: 'as yet unclassified' stamp: 'avi 9/8/2004 12:18'!renderContentOn: html	active		ifTrue: [ self renderOwnerOn: html ]		ifFalse: [ self session pageExpired ]! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'cds 6/3/2006 22:40'!exceptionClass	^exceptionClass ifNil: [exceptionClass := WAValidationNotification]! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'cds 7/25/2005 10:19'!exceptionClass: aClass	exceptionClass _ aClass! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'pmm 11/2/2005 23:04'!handleAnswer: anObject	^(super handleAnswer: anObject)		or: [(self validate: anObject) not]! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'avi 6/22/2004 11:03'!handleAnswer: anObject continueWith: aBlock	(self validate: anObject) ifTrue: [aBlock value]! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 18:37'!initialize	super initialize.	message _ WAStateHolder new! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 22:05'!renderContentOn: html	message contents ifNotNilDo:		[:msg |		html divClass: 'validation-error' with: msg].	self renderOwnerOn: html.! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'cds 6/3/2006 22:37'!validate: anObject	[validationBlock value: anObject.	message contents: nil.	^ true]		on: self exceptionClass		do: [:e | message contents: e messageText].	^ false! !!WAValidationDecoration methodsFor: 'as yet unclassified' stamp: 'avi 12/10/2003 12:49'!validateWith: aBlock	validationBlock _ aBlock! !!WAWindowDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 20:52'!isGlobal	^ true! !!WAWindowDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/27/2004 22:12'!renderCloseButtonOn: html	html anchorWithAction: [self component answer] text: 'close'! !!WAWindowDecoration methodsFor: 'as yet unclassified' stamp: 'avi 6/21/2004 20:57'!renderContentOn: html	html divClass: 'window-titlebar' with: [		html spanClass: 'window-close' with: [self renderCloseButtonOn: html].				html spanClass: 'window-title' with: title.	].	html divClass: 'window-content' with: [self renderOwnerOn: html].! !!WAWindowDecoration methodsFor: 'as yet unclassified' stamp: 'avi 3/28/2004 21:04'!style	^ '.window-titlebar {background-color: #aaaaaa; padding: 5px; margin-bottom: 5px}	    .window-close {float: right}	   .window-title {}	    .window-content {clear: both}	'! !!WAWindowDecoration methodsFor: 'as yet unclassified' stamp: 'ab 6/15/2003 12:51'!title: aString	title _ aString! !!WAPresenter class methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:14'!new	^ self basicNew initialize! !!WAPresenter methodsFor: 'convenience' stamp: 'dc 7/16/2006 16:41'!application	^ self session application! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/18/2005 22:36'!classForSection: aSymbol	^ (aSymbol copyFrom: 7 to: (aSymbol size - 1)) withFirstCharacterDownshifted ! !!WAPresenter methodsFor: 'call/answer' stamp: 'pmm 11/2/2005 23:50'!handleAnswer: anObject	self subclassResponsibility ! !!WAPresenter methodsFor: 'request processing' stamp: 'avi 11/7/2005 11:53'!initialRequest: aRequest! !!WAPresenter methodsFor: 'initialization' stamp: 'ab 2/13/2003 01:10'!initialize! !!WAPresenter methodsFor: 'decoration' stamp: 'avi 3/27/2004 19:55'!isDecoration	^ false! !!WAPresenter methodsFor: 'tree' stamp: 'avi 6/8/2004 00:58'!nextPresentersDo: aBlock	self subclassResponsibility ! !!WAPresenter methodsFor: 'convenience' stamp: 'dc 7/16/2006 16:48'!preferenceAt: aSymbol	^ self application preferenceAt: aSymbol! !!WAPresenter methodsFor: 'convenience' stamp: 'dc 7/16/2006 16:53'!preferenceAt: aSymbol put: anObject	^ self application preferenceAt: aSymbol put: anObject! !!WAPresenter methodsFor: 'request processing' stamp: 'avi 6/8/2004 02:00'!processCallbackStream: aCallbackStream	aCallbackStream processCallbacksWithOwner: self.	self processChildCallbacks: aCallbackStream.	aCallbackStream processCallbacksWithOwner: self.! !!WAPresenter methodsFor: 'request processing' stamp: 'avi 6/8/2004 00:54'!processChildCallbacks: aStream	self nextPresentersDo: [:ea | ea processCallbackStream: aStream]! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/27/2004 20:59'!renderContentOn: aRenderer	self nextPresentersDo: [:ea | ea renderWithContext: aRenderer context]! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/18/2005 22:11'!renderWithContext: aRenderingContext	| html callbacks |	callbacks _ aRenderingContext callbacksFor: self.	html _ (self rendererClass context: aRenderingContext callbacks: callbacks)				painter: self.	(self showHalo and: [aRenderingContext isDebugMode])		ifTrue: [(WAHalo for: self) renderContentOn: html]		ifFalse: [self renderContentOn: html].	html close.! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/27/2004 17:25'!rendererClass	^ WAHtmlRenderer! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 6/21/2004 16:05'!script	^ nil! !!WAPresenter methodsFor: 'convenience' stamp: 'avi 4/13/2004 19:48'!session	^ WACurrentSession value! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/27/2004 17:27'!showHalo	^ true! !!WAPresenter methodsFor: 'rendering' stamp: 'avi 3/28/2004 20:57'!style	^ nil! !!WAPresenter methodsFor: 'path' stamp: 'avi 6/21/2004 16:04'!updateRoot: anHtmlRoot	self script ifNotNilDo: [:script | anHtmlRoot addScript: script].	self style ifNotNilDo: [:style | anHtmlRoot addStyle: style].	! !!WAPresenter methodsFor: 'path' stamp: 'avi 3/22/2004 01:00'!updateUrl: aUrl! !!WAPresenter methodsFor: 'tree' stamp: 'avi 3/27/2004 20:59'!withNextPresentersDo: aBlock	aBlock value: self.	self nextPresentersDo: [:ea | ea withNextPresentersDo: aBlock]! !!WAProcessMonitor class methodsFor: 'as yet unclassified' stamp: 'pmm 4/18/2006 20:17'!new	^ self basicNew initialize! !!WAProcessMonitor methodsFor: 'as yet unclassified' stamp: 'avi 1/16/2005 00:38'!critical: aBlock ifError: errorBlock	|value|	mutex critical:		[responseSem _ Semaphore new.		process _ [[value _ aBlock on: Error do: errorBlock]			ensure: [responseSem signal]] fork.		responseSem wait].	process _ nil.	^ value! !!WAProcessMonitor methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 21:39'!initialize	mutex _ Semaphore forMutualExclusion! !!WAProcessMonitor methodsFor: 'as yet unclassified' stamp: 'avi 1/16/2005 00:38'!terminate	process ifNotNil: [process terminate]! !!WARadioGroup class methodsFor: 'as yet unclassified' stamp: 'ac 7/6/2005 11:30'!canvas: aRenderCanvas	^ self basicNew initializeWithCanvas: aRenderCanvas! !!WARadioGroup methodsFor: 'initialize-release' stamp: 'ac 7/6/2005 11:31'!initializeWithCanvas: aRenderCanvas	canvas _ aRenderCanvas.	key _ aRenderCanvas callbacks registerDispatchCallback.! !!WARadioGroup methodsFor: 'accessing' stamp: 'ac 7/6/2005 11:32'!key	^ key! !!WARadioGroup methodsFor: 'public api' stamp: 'ac 7/6/2005 11:31'!radioButton	^ canvas radioButton group: self! !!WAReadWriteLock class methodsFor: 'instance creation' stamp: 'avi 11/3/2005 00:38'!global	^ Global ifNil: [Global _ self new]! !!WAReadWriteLock class methodsFor: 'instance creation' stamp: 'lr 5/3/2006 09:30'!new	^ self basicNew initialize! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:37'!initialize	sem _ Semaphore forMutualExclusion.	mutex _ Semaphore forMutualExclusion.	readers _ 0! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:33'!lockForReading	mutex critical:		[readers = 0 ifTrue: [sem wait].		readers _ readers + 1]! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:34'!lockForWriting	sem wait! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:35'!read: aBlock	self lockForReading.	^ aBlock ensure: [self unlockForReading]! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:39'!readers	^ readers! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:33'!unlockForReading	mutex critical:		[readers _ readers - 1.		readers = 0 ifTrue: [sem signal]]! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:34'!unlockForWriting	sem signal! !!WAReadWriteLock methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2005 00:35'!write: aBlock	self lockForWriting.	^ aBlock ensure: [self unlockForWriting]! !!WARender methodsFor: 'as yet unclassified' stamp: 'avi 11/27/2005 17:29'!application	^ self session application! !!WARender methodsFor: 'rendering' stamp: 'mb 6/28/2006 16:07'!buildDocRoot	|docRoot|	docRoot _ WARenderedHtmlRoot context: context.	docRoot resourceBaseUrl: self application resourceBaseUrl.	#onLoad.	docRoot bodyAttributes at: 'onLoad' put: 'onLoad()'.  	self session updateRoot: docRoot.	root visiblePresentersDo: [:each | each updateRoot: docRoot].	^ docRoot! !!WARender methodsFor: 'rendering' stamp: 'mb 8/18/2006 10:28'!buildResponse	| response document |	self updateUrl: url.	context actionUrl: url. 	response := self newResponse.	response headerAt: 'Cache-Control' put: 'No-cache'.	document := self session outputDocumentClass root: self buildDocRoot.	document stream: response stream.	context document: document.	root decorationChainDo: [:ea | ea renderWithContext: context].			self writeOnLoadOn: document.	document close.	^ response! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:31'!go	self withPageExpiredHandler:		[self withRenderNowHandler: [self render].		self shouldRedirect ifTrue: [self redirect]]! !!WARender methodsFor: 'rendering' stamp: 'avi 1/6/2006 14:02'!newResponse	| s |	s _ self session currentRequest ifNotNilDo: [:r | r responseStream].	^ s		ifNil: [WAResponse new]		ifNotNil: [WAStreamResponse new stream: s]! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:48'!processCallbacks	| lastPosition callbackStream |	callbackStream _ context callbackStreamForRequest: request.	lastPosition _ nil.	[callbackStream position = lastPosition] whileFalse:		[lastPosition _ callbackStream position.		root decorationChainDo: [:ea | ea processCallbackStream: callbackStream]].	callbackStream atEnd		ifTrue: [WARenderNotification raiseSignal]		ifFalse: [self unprocessedCallbacks: callbackStream upToEnd].! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:37'!redirect		self session respond:		[:u |		self updateUrl: u.		WAResponse redirectTo: u displayString]! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:34'!render	self session clearJumpTo.	context _ WARenderingContext new request: self session currentRequest.	request _ self session respond: [:u | url _ u.  self buildResponse].	self processCallbacks! !!WARender methodsFor: 'as yet unclassified' stamp: 'avi 11/27/2005 17:30'!root: aComponent	root _ aComponent! !!WARender methodsFor: 'as yet unclassified' stamp: 'avi 11/27/2005 17:29'!session	^ WACurrentSession value! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:38'!shouldRedirect	^ request isGet not or: [(request fields includesKey: '_n') not]! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:29'!unprocessedCallbacks: aCollection	| owners |	owners _ (aCollection collect: [:ea | ea owner]) asSet asArray.	self error: 'Components not found while processing callbacks: ', owners displayString! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:29'!updateUrl: aUrl	root visiblePresentersDo: [:c | c updateUrl: aUrl]! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:29'!withPageExpiredHandler: aBlock	^ aBlock on: WAPageExpired do: [:n |]! !!WARender methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:29'!withRenderNowHandler: aBlock	^ aBlock on: WARenderNotification do: [:n | n]! !!WARender methodsFor: 'rendering' stamp: 'ac 12/20/2005 12:35'!writeOnLoadOn: anHtmlDocument	| attributes |	attributes _ WAHtmlAttributes new.	attributes at: 'type' put: 'text/javascript'.	anHtmlDocument openTag: 'script' attributes: attributes.	anHtmlDocument text: 'function onLoad() {'.	self session onLoadScripts		do: [:ea | anHtmlDocument text: ea]		separatedBy: [anHtmlDocument text: ';'].	anHtmlDocument text: '}'.	anHtmlDocument closeTag: 'script'.	self session clearLoadScripts! !!WARenderLoop methodsFor: 'as yet unclassified' stamp: 'avi 2/5/2004 12:39'!application	^ self session application! !!WARenderLoop methodsFor: 'as yet unclassified' stamp: 'avi 5/8/2004 13:58'!basicRoot: aComponent	root _ aComponent! !!WARenderLoop methodsFor: 'call' stamp: 'avi 5/8/2004 14:00'!call: aComponent	^ self call: aComponent withToolFrame: true! !!WARenderLoop methodsFor: 'call' stamp: 'avi 5/8/2004 13:59'!call: aComponent withToolFrame: aBoolean	aBoolean ifTrue: [self root: aComponent] ifFalse: [self basicRoot: aComponent].	aComponent onAnswer: [:v | ^ v].	self run! !!WARenderLoop methodsFor: 'as yet unclassified' stamp: 'pmm 9/12/2006 18:38'!root: aComponent	self basicRoot: (self application deploymentMode		ifFalse: [ WAToolFrame on: aComponent ]		ifTrue: [ aComponent ])! !!WARenderLoop methodsFor: 'rendering' stamp: 'avi 11/27/2005 17:37'!run	[(WARender new root: root) go] repeat! !!WARenderLoop methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 20:28'!session	^ WACurrentSession value! !!WARenderingContext class methodsFor: 'instance creation' stamp: 'avi 3/25/2004 02:21'!new	^ self basicNew initialize! !!WARenderingContext methodsFor: 'accessing' stamp: 'ab 2/13/2003 01:25'!actionUrl	"Answer the value of actionUrl"	^ actionUrl! !!WARenderingContext methodsFor: 'accessing' stamp: 'avi 11/7/2005 13:13'!actionUrl: anObject	actionUrl _ anObject! !!WARenderingContext methodsFor: 'callbacks' stamp: 'avi 6/8/2004 00:42'!advanceKey	| key |	key _ self nextKey.	self increaseKey.	^ key! !!WARenderingContext methodsFor: 'callbacks' stamp: 'lr 4/19/2006 08:05'!callbackAt: aString	^ callbacks at: aString ifAbsent: [ ]! !!WARenderingContext methodsFor: 'callbacks' stamp: 'avi 6/8/2004 02:01'!callbackStreamForRequest: aRequest	^ WACallbackStream callbacks: callbacks request: aRequest! !!WARenderingContext methodsFor: 'callbacks' stamp: 'avi 6/7/2004 22:17'!callbacksFor: anObject	^ WACallbackRegistry context: self owner: anObject! !!WARenderingContext methodsFor: 'modes' stamp: 'avi 3/13/2004 22:19'!clearMode	mode _ nil! !!WARenderingContext methodsFor: 'accessing' stamp: 'lr 3/27/2006 10:42'!count	^ count! !!WARenderingContext methodsFor: 'accessing' stamp: 'lr 3/27/2006 10:42'!count: anInteger	count := anInteger! !!WARenderingContext methodsFor: 'modes' stamp: 'avi 3/13/2004 22:19'!debugMode	mode _ #debug! !!WARenderingContext methodsFor: 'accessing' stamp: 'ab 2/13/2003 01:25'!document	"Answer the value of document"	^ document! !!WARenderingContext methodsFor: 'accessing' stamp: 'ab 2/13/2003 01:25'!document: anObject	"Set the value of document"	document _ anObject! !!WARenderingContext methodsFor: 'callbacks' stamp: 'mb 11/27/2005 19:22'!increaseKey	count contents: count contents + 1! !!WARenderingContext methodsFor: 'initialize-release' stamp: 'mb 11/27/2005 19:22'!initialize	count _ ValueHolder new contents: 1.	callbacks _ Dictionary new! !!WARenderingContext methodsFor: 'modes' stamp: 'avi 3/13/2004 22:20'!isDebugMode	^ mode = #debug! !!WARenderingContext methodsFor: 'callbacks' stamp: 'mb 3/9/2006 18:07'!nextKey	"See discussion on VWNC	Some VW users have overriden #displayString to answer a Text object.	#asString works fine here since the count held by the ValueHolder is a Number"	^ count contents asString! !!WARenderingContext methodsFor: 'accessing' stamp: 'ac 2/18/2006 17:33'!properties	^ properties ifNil: [properties _ Dictionary new]! !!WARenderingContext methodsFor: 'accessing' stamp: 'ac 2/18/2006 17:33'!propertyAt: key ifAbsent: aBlock	^ self properties at: key ifAbsent: aBlock! !!WARenderingContext methodsFor: 'accessing' stamp: 'ac 2/18/2006 17:33'!propertyAt: key put: value	^ self properties at: key put: value! !!WARenderingContext methodsFor: 'documents' stamp: 'avi 5/22/2004 18:52'!registry	^ WACurrentSession value application! !!WARenderingContext methodsFor: 'accessing' stamp: 'avi 4/13/2004 21:43'!request	^ request! !!WARenderingContext methodsFor: 'accessing' stamp: 'avi 4/13/2004 21:43'!request: aRequest	request _ aRequest! !!WARenderingContext methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:00'!response	^ response! !!WARenderingContext methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:00'!response: aResponse	response _ aResponse! !!WARenderingContext methodsFor: 'callbacks' stamp: 'avi 9/2/2004 14:46'!storeCallback: aCallback		| key |	key _ self advanceKey.	callbacks at: (aCallback convertKey: key) put: aCallback.	^ key! !!WARenderingContext methodsFor: 'documents' stamp: 'avi 5/22/2004 18:04'!urlForDocument: anObject	^ self urlForDocument: anObject mimeType: nil! !!WARenderingContext methodsFor: 'documents' stamp: 'avi 5/22/2004 18:02'!urlForDocument: anObject mimeType: mimeString	^ self urlForDocument: anObject mimeType: mimeString fileName: nil! !!WARenderingContext methodsFor: 'documents' stamp: 'mbany 4/14/2005 12:14'!urlForDocument: anObject mimeType: mimeType fileName: fileName	^ (self registry urlForRequestHandler:		(WADocumentHandler			document: anObject			mimeType: mimeType			fileName: fileName)) displayString! !!WAReportColumn class methodsFor: 'instance creation' stamp: 'pmm 4/18/2006 20:17'!new	^ self basicNew initialize! !!WAReportColumn class methodsFor: 'instance creation' stamp: 'mb 5/30/2006 12:13'!renderBlock: aBlock title: aString	^ self new		title: aString;		valueBlock: aBlock;		yourself! !!WAReportColumn class methodsFor: 'instance creation' stamp: 'ab 10/26/2002 22:26'!selector: aSymbol	^ self selector: aSymbol title: aSymbol capitalized! !!WAReportColumn class methodsFor: 'instance creation' stamp: 'ab 10/26/2002 22:26'!selector: aSymbol title: aString	^ self selector: aSymbol title: aString onClick: nil! !!WAReportColumn class methodsFor: 'instance creation' stamp: 'pmm 4/19/2006 17:42'!selector: aSymbol title: aString onClick: aBlock	^ self new		title: aString;		selector: aSymbol;		clickBlock: aBlock;		yourself! !!WAReportColumn methodsFor: 'public' stamp: 'ab 10/27/2002 00:05'!canChoose	^ clickBlock notNil! !!WAReportColumn methodsFor: 'rendering' stamp: 'mb 5/30/2006 11:49'!canRender	^valueBlock numArgs > 1! !!WAReportColumn methodsFor: 'public' stamp: 'mb 5/30/2006 12:08'!canSort	^self canRender not and: [sortBlock notNil].! !!WAReportColumn methodsFor: 'public' stamp: 'ab 1/16/2003 16:06'!chooseRow: row	^ clickBlock value: row! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/28/2002 14:02'!clickBlock: aBlock	clickBlock _ aBlock! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 11/12/2002 14:03'!columnClickBlock: aBlock	self clickBlock: [:r | aBlock value: (self valueForRow: r)]! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:50'!formatBlock: anObject	formatBlock := anObject! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 11/12/2002 14:29'!hasTotal: aBoolean	hasTotal _ aBoolean ! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:52'!index: aNumber	valueBlock _ [:row | row at: aNumber]! !!WAReportColumn methodsFor: 'initialize-release' stamp: 'mbany 4/14/2005 12:15'!initialize	formatBlock _ [:x | x displayString].	sortBlock _ [:a :b | a <= b].	valueBlock _ [:row | nil].	clickBlock _ nil.	title _ 'Untitled'.	hasTotal _ false.! !!WAReportColumn methodsFor: 'rendering' stamp: 'mb 5/30/2006 11:47'!renderValue: anObject on: html	valueBlock value: anObject value: html! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:52'!selector: aSymbol	valueBlock _ [:row | row perform: aSymbol]! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:50'!sortBlock: anObject	sortBlock := anObject! !!WAReportColumn methodsFor: 'public' stamp: 'avi 9/18/2003 16:43'!sortRows: anArray	|assocs|	assocs _ anArray collect: [:ea | ea -> (self valueForRow: ea)].	assocs _ assocs asSortedCollection: [:a :b | sortBlock value: a value value: b value].	^ assocs collect: [:ea | ea key]! !!WAReportColumn methodsFor: 'public' stamp: 'ab 10/26/2002 21:51'!textForRow: row	^ formatBlock value: (self valueForRow: row)! !!WAReportColumn methodsFor: 'public' stamp: 'ab 10/26/2002 21:50'!title	^title! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:50'!title: aString	title _ aString! !!WAReportColumn methodsFor: 'public' stamp: 'ab 11/12/2002 14:31'!totalForRows: aCollection	^ hasTotal		ifFalse: ['']		ifTrue: [formatBlock value: (aCollection detectSum: [:r | self valueForRow: r])]! !!WAReportColumn methodsFor: 'accessing' stamp: 'ab 10/26/2002 21:50'!valueBlock: aBlock	valueBlock _ aBlock! !!WAReportColumn methodsFor: 'public' stamp: 'ab 10/26/2002 21:51'!valueForRow: row	^ valueBlock value: row! !!WARequest class methodsFor: 'as yet unclassified' stamp: 'avi 8/29/2005 21:19'!blankRequest	^ self			method: 'GET'			url: ''			headers: Dictionary new			fields: Dictionary new			cookies: Dictionary new! !!WARequest class methodsFor: 'as yet unclassified' stamp: 'ab 8/26/2003 19:34'!method: methodString url: urlString headers: headDict fields: fieldDict cookies: cookieDict	^ self new setMethod: methodString url: urlString headers: headDict fields: fieldDict cookies: cookieDict! !!WARequest class methodsFor: 'as yet unclassified' stamp: 'avi 4/28/2004 10:57'!method: methodString url: urlString headers: headDict fields: fieldDict cookies: cookieDict nativeRequest: anObject	^ (self method: methodString url: urlString headers: headDict fields: fieldDict cookies: cookieDict)		nativeRequest: anObject;		yourself! !!WARequest methodsFor: 'accessing' stamp: 'ab 7/3/2002 13:37'!at: key	^ fields at: key! !!WARequest methodsFor: 'accessing' stamp: 'JF 5/16/2003 09:40'!at: key ifAbsent: aBlock	^ fields at: key ifAbsent: aBlock! !!WARequest methodsFor: 'accessing' stamp: 'ac 11/12/2005 00:46'!at: key ifPresent: aBlock	^ fields at: key ifPresent: aBlock! !!WARequest methodsFor: 'private' stamp: 'ab 1/13/2003 22:40'!authorization	^ (self headerAt: 'Authorization' ifAbsent: [self headerAt: 'authorization'])		ifNotNilDo: [:auth | self decodeAuthorization: auth]! !!WARequest methodsFor: 'accessing' stamp: 'avi 1/6/2006 13:15'!cookies	^ cookies ifNil: [cookies _ Dictionary new]! !!WARequest methodsFor: 'private' stamp: 'avi 9/21/2003 18:28'!decodeAuthorization: aString	^ SeasidePlatformSupport base64Decode: (aString findTokens: ' ') last! !!WARequest methodsFor: 'accessing' stamp: 'ab 7/3/2002 12:51'!fields	^ fields! !!WARequest methodsFor: 'accessing' stamp: 'JF 11/18/2002 16:18'!headerAt: aKey	^ self headerAt: aKey ifAbsent: []! !!WARequest methodsFor: 'accessing' stamp: 'JF 11/18/2002 16:18'!headerAt: aKey ifAbsent: aBlock	^ headers at: aKey ifAbsent: aBlock! !!WARequest methodsFor: 'accessing' stamp: 'JF 11/18/2002 16:16'!headers	^ headers! !!WARequest methodsFor: 'testing' stamp: 'mb 3/31/2006 09:41'!includesKey: key	^ fields includesKey: key! !!WARequest methodsFor: 'testing' stamp: 'pmm 9/12/2006 18:42'!isFromIE	"this is extremely unreliable"	| tokens |	tokens := (headers at: 'user-agent') findTokens: ' '.	^(tokens includes: 'MSIE') and: [ (tokens includes: 'Opera') not ]! !!WARequest methodsFor: 'testing' stamp: 'avi 3/22/2004 12:58'!isGet	^ self method asUppercase = 'GET'! !!WARequest methodsFor: 'testing' stamp: 'avi 5/9/2005 13:13'!isPrefetch	^ (self headerAt: 'HTTP_X_MOZ') = 'prefetch'! !!WARequest methodsFor: 'testing' stamp: 'lr 7/3/2006 09:25'!isXmlHttpRequest	^ (self headerAt: 'x-requested-with') = 'XMLHttpRequest'! !!WARequest methodsFor: 'accessing' stamp: 'ab 8/26/2003 19:33'!method	^ method! !!WARequest methodsFor: 'accessing' stamp: 'avi 4/28/2004 13:43'!nativeRequest	^ nativeRequest! !!WARequest methodsFor: 'accessing' stamp: 'avi 4/28/2004 13:43'!nativeRequest: aRequest	nativeRequest _ aRequest! !!WARequest methodsFor: 'accessing' stamp: 'ab 12/30/2002 17:42'!password	^ self authorization ifNotNilDo: [:auth | auth copyAfter: $:]! !!WARequest methodsFor: 'accessing' stamp: 'ac 6/17/2006 16:28'!referer	^ self headerAt: 'referer'! !!WARequest methodsFor: 'accessing' stamp: 'avi 1/6/2006 13:23'!responseStream	^ responseStream! !!WARequest methodsFor: 'accessing' stamp: 'avi 1/6/2006 13:23'!responseStream: aStream	responseStream _ aStream! !!WARequest methodsFor: 'private' stamp: 'avi 3/19/2004 13:52'!setMethod: methodString url: urlString headers: headDict fields: fieldDict cookies: cookieDict	method _ methodString.	url _ urlString.	headers _ headDict.	fields _ fieldDict.	cookies _ cookieDict! !!WARequest methodsFor: 'accessing' stamp: 'ab 5/26/2003 00:54'!url	^ url! !!WARequest methodsFor: 'accessing' stamp: 'ab 12/30/2002 17:42'!user	^ self authorization ifNotNilDo: [:auth | auth copyUpTo: $:]! !!WADocumentHandler class methodsFor: 'as yet unclassified' stamp: 'avi 11/3/2003 12:23'!document: anObject mimeType: mimeString fileName: fileString	^ self basicNew initializeWithDocument: anObject mimeType: mimeString fileName: fileString! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'lr 3/27/2006 09:01'!= other	^ other species = self species		and: [other document = self document		and: [other mimeType = self mimeType]]! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'ab 2/12/2003 13:41'!document	^ document! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 12:43'!handleRequest: aRequest	^ self response! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 12:42'!hash	^ self document hash bitXor: self mimeType hash! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'avi 4/14/2004 23:52'!initializeWithDocument: anObject mimeType: mimeString fileName: fileString	document _ anObject.	mimeType _ mimeString.	fileName _ fileString.! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'mb 6/1/2006 09:05'!mimeDocument	^ mimeDocument ifNil: [mimeDocument _ document asMIMEDocumentType: mimeType ]! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'ab 8/24/2003 18:48'!mimeType	^ mimeType! !!WADocumentHandler methodsFor: 'as yet unclassified' stamp: 'lr 5/17/2005 08:38'!response	| response |	response _ WAResponse new.	response contents: self mimeDocument contentStream text.	response contentType: (mimeType ifNil: [self mimeDocument contentType]).	response headerAt: 'Expires' put: 'Thu, 01 Jan 2095 12:00:00 GMT'.	fileName ifNotNil: 		[response headerAt: 'Content-Disposition' put: 'attachment; filename="' , fileName , '"'].	^ response! !!WADispatcher class methodsFor: 'as yet unclassified' stamp: 'JF 9/15/2003 14:40'!default	default ifNil: [default _ self new].	default basePath ifNil: [default basePath: '/seaside'].		^ default! !!WADispatcher class methodsFor: 'as yet unclassified' stamp: 'ab 8/27/2003 00:47'!description	^ 'Subdirectory'! !!WADispatcher methodsFor: 'public' stamp: 'avi 7/5/2004 11:44'!basePath: newPath	| base |	basePath _ newPath.	base _ (newPath isEmpty or: [newPath last ~= $/])				ifTrue: [newPath, '/']				ifFalse: [newPath].	entryPoints keysAndValuesDo: [:key :component | component basePath: base, key]! !!WADispatcher methodsFor: 'public' stamp: 'ab 8/26/2003 21:53'!configurationComponent	^ WADispatcherEditor new dispatcher: self! !!WADispatcher methodsFor: 'public' stamp: 'avi 11/12/2005 12:25'!defaultPath	^ default! !!WADispatcher methodsFor: 'public' stamp: 'avi 11/12/2005 12:25'!defaultPath: aString	default _ aString! !!WADispatcher methodsFor: 'public' stamp: 'mb 6/14/2006 14:23'!entryPointAt: aString	"((( WADispatcher default entryPointAt: 'examples/store' )))"	| dispatcher |	dispatcher _ self.	(aString findTokens: '/') do:		[:token |		dispatcher _ dispatcher entryPoints at: token].	^dispatcher.! !!WADispatcher methodsFor: 'public' stamp: 'ab 8/26/2003 21:35'!entryPoints	^ entryPoints! !!WADispatcher methodsFor: 'public' stamp: 'pmm 9/12/2006 18:16'!genuineEntryPoints	"In case some of our entry points	are non-standard RequestHandler objects"	^self entryPoints select: [ :each | each isEntryPoint ]! !!WADispatcher methodsFor: 'public' stamp: 'avi 5/9/2005 13:15'!handleRequest: aRequest	aRequest isPrefetch ifTrue: [^ WAResponse forbidden: aRequest url].	^ (self handlerForRequest: aRequest) handleRequest: aRequest! !!WADispatcher methodsFor: 'private' stamp: 'mb 2/17/2005 17:55'!handlerForRequest: aRequest	^ self handlerForRequest: aRequest relativeTo: basePath! !!WADispatcher methodsFor: 'private' stamp: 'lr 3/27/2006 12:17'!handlerForRequest: aRequest relativeTo: base	| path name relativePath |	path := aRequest url.	(base isEmpty or: [path beginsWith: base]) ifTrue:		[relativePath := path allButFirst: base size.		(relativePath notEmpty and: [relativePath first = $/]) ifTrue:			[name := (relativePath findTokens: '/') at: 1 ifAbsent: [default].              ^ entryPoints at: name ifAbsent: [				entryPoints at: default ifAbsent: [					WANotFoundHandler new ] ] ] ].       ^ WANotFoundHandler new! !!WADispatcher methodsFor: 'private' stamp: 'mb 4/23/2006 15:17'!initialize	super initialize.	entryPoints _ Dictionary new! !!WADispatcher methodsFor: 'testing' stamp: 'mb 9/20/2006 17:52'!isDeployed	"((( self assert: WADispatcher default isDeployed )))"	^self entryPoints anySatisfy: [:each | each isDeployed].! !!WADispatcher methodsFor: 'testing' stamp: 'mb 5/26/2006 08:51'!isDispatcher	^ true! !!WADispatcher methodsFor: 'testing' stamp: 'mb 4/5/2006 20:55'!isRoot	^self == self class default.! !!WADispatcher methodsFor: 'public' stamp: 'mb 6/14/2006 15:10'!registerEntryPoint: entryPoint at: aString	| path |	entryPoints at: aString displayString put: entryPoint.	path _ (basePath isEmpty or: [basePath last ~= $/])		ifTrue: [basePath, '/', aString]		ifFalse: [basePath, aString].	entryPoint basePath: path.	^ entryPoint! !!WADispatcher methodsFor: 'public' stamp: 'pmm 9/12/2006 18:18'!registerEntryPoint: aDispatcherOrApplication path: pathString	| tokens dispatcher dispatcherEntryPoints  |	tokens := pathString findTokens: '/'.	dispatcher := self.	tokens allButLast do: [ :each |		dispatcherEntryPoints := dispatcher entryPoints.		dispatcher := dispatcherEntryPoints			at: each			ifAbsent: [ dispatcher registerEntryPoint: WADispatcher new at: each ] ].		dispatcher registerEntryPoint: aDispatcherOrApplication at: tokens last.	^ aDispatcherOrApplication! !!WADispatcher methodsFor: 'public' stamp: 'dc 7/15/2006 13:33'!removeEntryPoint: entryPoint	entryPoints removeKey: (entryPoints keyAtValue: entryPoint).	entryPoint unregistered! !!WADispatcher methodsFor: 'public' stamp: 'dc 7/15/2006 13:32'!removeEntryPointAt: aString	| entryPoint |	entryPoint := self entryPointAt: aString.	self removeEntryPoint: entryPoint.! !!WADispatcher methodsFor: 'public' stamp: 'mb 9/20/2006 17:54'!trimForDeployment	"((( WADispatcher default trimForDeployment )))"	(self entryPoints reject: [:each | each isDeployed])		do: [:each | self removeEntryPoint: each].	(self entryPoints select: [:each | each isDispatcher])		do: [:each | each trimForDeployment].! !!WAEntryPoint class methodsFor: 'as yet unclassified' stamp: 'ab 8/26/2003 21:51'!concreteSubclasses	^ self allSubclasses reject: [:ea | ea isAbstract]! !!WAEntryPoint class methodsFor: 'as yet unclassified' stamp: 'ab 8/27/2003 00:14'!description	^ nil! !!WAEntryPoint class methodsFor: 'as yet unclassified' stamp: 'ab 8/27/2003 00:14'!isAbstract	^ self description isNil! !!WAEntryPoint methodsFor: 'accessing' stamp: 'ab 8/26/2003 21:08'!basePath	^ basePath! !!WAEntryPoint methodsFor: 'accessing' stamp: 'ab 8/26/2003 21:08'!basePath: aString	basePath _ aString! !!WAEntryPoint methodsFor: 'public' stamp: 'avi 3/22/2004 00:48'!baseUrl	^ WAUrl new		addToPath: basePath;		yourself! !!WAEntryPoint methodsFor: 'public' stamp: 'ab 8/26/2003 21:48'!configurationComponent	^ nil! !!WAEntryPoint methodsFor: 'testing' stamp: 'mb 5/26/2006 08:50'!isEntryPoint	^ true! !!WAEntryPoint methodsFor: 'printing' stamp: 'JF 9/22/2003 20:06'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self basePath, ')'! !!WAApplication class methodsFor: 'as yet unclassified' stamp: 'ab 8/27/2003 00:47'!description	^ 'Seaside Application'! !!WAApplication class methodsFor: 'as yet unclassified' stamp: 'ab 8/26/2003 21:45'!path: pathString	^ self new basePath: pathString! !!WAApplication methodsFor: 'adding' stamp: 'pmm 10/2/2006 21:21'!addLibrary: aClass	^self libraries add: aClass! !!WAApplication methodsFor: 'accessing' stamp: 'mb 5/26/2006 09:12'!baseUrl	^ super baseUrl		port: self serverPort;		hostname: self serverHostname;		scheme: self serverProtocol;		yourself! !!WAApplication methodsFor: 'preferences' stamp: 'avi 11/16/2005 23:45'!configuration	^ configuration ifNil: [configuration _ WAUserConfiguration new addAncestor: self defaultAncestor] ! !!WAApplication methodsFor: 'accessing' stamp: 'ab 8/26/2003 21:34'!configurationComponent	^ WAApplicationEditor new application: self! !!WAApplication methodsFor: 'preferences' stamp: 'avi 11/16/2005 23:32'!defaultAncestor	"yes, breaking layering"	^ WARenderLoopConfiguration new! !!WAApplication methodsFor: 'accessing' stamp: 'avi 6/24/2004 00:30'!defaultLibraries	^ Array with: WAStandardScripts with: WAStandardStyles! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:16'!deploymentMode	^self preferenceAt: #deploymentMode! !!WAApplication methodsFor: 'accessing' stamp: 'mb 5/26/2006 12:01'!description	^self rootComponent description! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:18'!errorHandler	^self preferenceAt: #errorHandler! !!WAApplication methodsFor: 'request handling' stamp: 'lr 2/22/2006 08:41'!expiryPathFor: aRequest	^ self basePath! !!WAApplication methodsFor: 'request handling' stamp: 'avi 3/22/2004 13:06'!handleDefaultRequest: aRequest	|session|	session _ self sessionClass application: self.	^ session handleRequest: aRequest! !!WAApplication methodsFor: 'request handling' stamp: 'pmm 9/12/2006 18:10'!handleExpiredRequest: aRequest	| response |	response := super handleExpiredRequest: aRequest.	self useSessionCookie ifTrue: [		response deleteCookieAt: self name ].	^ response! !!WAApplication methodsFor: 'request handling' stamp: 'pmm 9/12/2006 18:09'!handleRequest: aRequest	self useSessionCookie ifTrue: [		aRequest cookies at: self name ifPresent: [ :value |			aRequest fields at: self handlerField ifAbsentPut: [ value ] ] ].	^ super handleRequest: aRequest! !!WAApplication methodsFor: 'preferences' stamp: 'kph 9/30/2006 01:47'!hasPreferenceGroup: aSymbol	^ self configuration hasGroupNamed: aSymbol! !!WAApplication methodsFor: 'testing' stamp: 'mb 4/5/2006 20:26'!isApplication	^true! !!WAApplication methodsFor: 'testing' stamp: 'mb 5/26/2006 09:23'!isDeployed	^self rootComponent isDeployed! !!WAApplication methodsFor: 'accessing' stamp: 'avi 6/24/2004 00:29'!libraries	^ libraries ifNil: [libraries _ OrderedCollection withAll: self defaultLibraries]! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:13'!login	^self preferenceAt: #login! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:19'!mainClass	^self preferenceAt: #mainClass! !!WAApplication methodsFor: 'accessing' stamp: 'avi 7/26/2004 12:49'!name	| segments |	segments _ basePath findTokens: '/'.	^ segments isEmpty		ifTrue: ['']		ifFalse: [segments last ]! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:13'!password	^self preferenceAt: #password! !!WAApplication methodsFor: 'preferences' stamp: 'avi 1/31/2004 12:34'!preferenceAt: aSymbol	^ self configuration valueAt: aSymbol! !!WAApplication methodsFor: 'preferences' stamp: 'avi 1/31/2004 12:34'!preferenceAt: aSymbol put: anObject	^ self configuration valueAt: aSymbol put: anObject! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:15'!resourceBaseUrl	^self preferenceAt: #resourceBaseUrl! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:17'!rootComponent	^self preferenceAt: #rootComponent! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:10'!serverHostname	^self preferenceAt: #serverHostname! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:10'!serverPort	^self preferenceAt: #serverPort! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:11'!serverProtocol	^self preferenceAt: #serverProtocol! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:11'!sessionClass	^self preferenceAt: #sessionClass! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:15'!sessionExpirySeconds	^self preferenceAt: #sessionExpirySeconds! !!WAApplication methodsFor: 'request handling' stamp: 'avi 6/24/2004 00:34'!updateRoot: anHtmlRoot	anHtmlRoot title = '' ifTrue: [anHtmlRoot title: self basePath].	self libraries do: [:ea | ea updateRoot: anHtmlRoot]! !!WAApplication methodsFor: 'basic configuration' stamp: 'mb 5/26/2006 09:12'!useSessionCookie	^self preferenceAt: #useSessionCookie! !!WARegistry class methodsFor: 'as yet unclassified' stamp: 'JF 9/22/2003 20:15'!clearAllHandlers	self allSubInstances do: [:ea | ea clearHandlers]! !!WARegistry methodsFor: 'private' stamp: 'avi 6/7/2005 23:17'!clearHandlers	self mutex critical:		[handlersByKey ifNotNil:			[handlersByKey do: [:ea | [ea unregistered] fixTemps fork]].		handlersByKey _ Dictionary new.		keysByHandler _ Dictionary new].! !!WARegistry methodsFor: 'public' stamp: 'avi 11/12/2005 21:22'!ensureKeyForHandler: anObject	^ (self keyOrNilForHandler: anObject) ifNil: [self registerRequestHandler: anObject]! !!WARegistry methodsFor: 'private' stamp: 'lr 2/22/2006 08:41'!expiryPathFor: aRequest	^ aRequest url! !!WARegistry methodsFor: 'private' stamp: 'ab 5/18/2003 12:29'!handleDefaultRequest: aRequest	self subclassResponsibility! !!WARegistry methodsFor: 'private' stamp: 'lr 7/3/2006 09:25'!handleExpiredRequest: aRequest	| url |	aRequest isXmlHttpRequest		ifTrue: [ ^ WAResponse new forbidden ].	url := WAUrl new.	url addToPath: (self expiryPathFor: aRequest).	url takeServerParametersFromRequest: aRequest.	aRequest isGet ifTrue:		[aRequest fields keysAndValuesDo:			[:k :v |			(url isSeasideField: k) ifFalse: [url addParameter: k value: v]]]. 	^ WAResponse redirectTo: url displayString! !!WARegistry methodsFor: 'private' stamp: 'mb 1/27/2006 15:52'!handleKeyRequest: aRequest	| key handler keyString |	"Under some circumstances, HTTP fields are collections of values"	key _	[keyString _ aRequest at: self handlerField.			(keyString isKindOf: OrderedCollection) ifTrue: [keyString _ keyString first].			WAExternalID fromString: keyString] on: Error do: [:e | nil].	handler _ handlersByKey at: key ifAbsent: [nil].	^ (handler notNil and: [handler isActive])		ifTrue: [handler handleRequest: aRequest]		ifFalse: [self handleExpiredRequest: aRequest]! !!WARegistry methodsFor: 'public' stamp: 'avi 3/19/2004 13:52'!handleRequest: aRequest	^ (aRequest fields includesKey: self handlerField)		ifTrue: [self handleKeyRequest: aRequest]		ifFalse: [self handleDefaultRequest: aRequest]! !!WARegistry methodsFor: 'private' stamp: 'avi 3/22/2004 13:04'!handlerField	^ '_s'! !!WARegistry methodsFor: 'private' stamp: 'pmm 11/2/2005 22:39'!initialize	super initialize.	self clearHandlers.! !!WARegistry methodsFor: 'private' stamp: 'avi 3/22/2004 13:04'!isSeasideField: aString	^ aString first  = $_! !!WARegistry methodsFor: 'private' stamp: 'jf 3/4/2004 19:06'!keyOrNilForHandler: anObject	^ self mutex critical: [keysByHandler at: anObject ifAbsent: [nil]]! !!WARegistry methodsFor: 'private' stamp: 'jf 3/4/2004 14:48'!mutex	^ mutex ifNil: [mutex _ Semaphore forMutualExclusion]! !!WARegistry methodsFor: 'private' stamp: 'jf 3/4/2004 14:59'!registerRequestHandler: anObject	|key|	key _ WAExternalID new: 16.	self shouldCollectHandlers ifTrue: [self unregisterExpiredHandlers].	self mutex critical:		[handlersByKey at: key put: anObject.		keysByHandler at: anObject put: key].	^ key! !!WARegistry methodsFor: 'private' stamp: 'ab 5/18/2003 12:26'!shouldCollectHandlers	^ 10 atRandom = 1! !!WARegistry methodsFor: 'private' stamp: 'avi 3/14/2005 14:56'!unregisterExpiredHandlers	"This method is a little ugly, but using #associationsDo: to build a new	dictionary is 200 times faster than iterating over them with #removeKey:	or even using #keysAndValuesRemove:"	| expired newHandlersByKey newKeysByHandler |	self mutex critical:		[expired _ OrderedCollection new.		newHandlersByKey _ Dictionary new.		handlersByKey associationsDo:			[:assoc |			assoc value isActive				ifTrue: [newHandlersByKey add: assoc]				ifFalse: [expired add: assoc value]].		newKeysByHandler _ Dictionary new.		keysByHandler associationsDo:                       [:assoc |                       (newHandlersByKey includesKey: assoc value) ifTrue:						[newKeysByHandler add: assoc]].		handlersByKey _ newHandlersByKey.		keysByHandler _ newKeysByHandler].		expired do: [:ea | [ea unregistered] fixTemps fork]! !!WARegistry methodsFor: 'private' stamp: 'avi 6/7/2005 23:43'!unregistered	self clearHandlers ! !!WARegistry methodsFor: 'public' stamp: 'avi 11/12/2005 21:22'!urlForRequestHandler: anObject	|key url |	key _ self ensureKeyForHandler: anObject.	url _ self baseUrl.	url addParameter: self handlerField value: key displayString.	^ url! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:20'!defaultTimeoutSeconds	^ 600! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:18'!expire	expired _ true! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:18'!expired	^ expired ifNil: [false]! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 14:08'!handleRequest: aRequest	lastAccess _ Time totalSeconds.	^ self incomingRequest: aRequest! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 14:08'!incomingRequest: aRequest	self subclassResponsibility ! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 18:39'!initialize	super initialize.	expired _ false! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:18'!isActive	^ self expired not and: [self secondsSinceLastAccess < self timeoutSeconds]! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:19'!lastAccess	^ lastAccess ifNil: [lastAccess _ Time totalSeconds]! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:19'!secondsSinceLastAccess	^ Time totalSeconds - self lastAccess! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:20'!timeoutSeconds	^ timeout ifNil: [self defaultTimeoutSeconds]! !!WAExpiringHandler methodsFor: 'as yet unclassified' stamp: 'avi 1/23/2004 12:20'!timeoutSeconds: aNumber	timeout _ aNumber! !!WASession commentStamp: '<historical>' prior: 0!I am a Seaside session. A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.If the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system. To manually expire a session call #expire.!!WAExpirySession class methodsFor: 'accessing' stamp: 'avi 9/30/2004 16:30'!created	^ Created! !!WAExpirySession class methodsFor: 'class initialization' stamp: 'avi 9/30/2004 16:24'!initialize	self resetCounters! !!WAExpirySession class methodsFor: 'actions' stamp: 'avi 9/30/2004 16:24'!resetCounters	Unregistered _ 0.	Created _ 0.! !!WAExpirySession class methodsFor: 'accessing' stamp: 'avi 9/30/2004 16:30'!unregistered	^ Unregistered! !!WAExpirySession methodsFor: 'initialize-release' stamp: 'avi 9/30/2004 16:24'!initialize	super initialize.	Created _ Created + 1! !!WAExpirySession methodsFor: 'subclass responsibilities' stamp: 'avi 9/30/2004 16:24'!unregistered	Unregistered _ Unregistered + 1! !!WASession class methodsFor: 'as yet unclassified' stamp: 'avi 7/2/2004 17:32'!application: anApplication	^ self basicNew initializeWithApplication: anApplication! !!WASession methodsFor: 'request handling' stamp: 'avi 3/22/2004 13:04'!actionField	^ '_k'! !!WASession methodsFor: 'responding' stamp: 'avi 2/3/2004 00:43'!actionUrlForContinuation: aContinuation	^ self actionUrlForKey: (continuations store: aContinuation)! !!WASession methodsFor: 'responding' stamp: 'avi 11/27/2005 14:56'!actionUrlForKey: aString	| url |	url _ self useSessionCookie			ifTrue: [application baseUrl]			ifFalse: [application urlForRequestHandler: self].	url takeServerParametersFromRequest: currentRequest.	url addParameter: self actionField value: aString.	jumpTo ifNotNil: [url fragment: jumpTo].	^ url! !!WASession methodsFor: 'scripts' stamp: 'avi 9/24/2005 18:42'!addLoadScript: aString	^ (scripts ifNil: [scripts _ OrderedCollection new]) add: aString! !!WASession methodsFor: 'accessing' stamp: 'ab 3/20/2003 11:43'!application	^ application! !!WASession methodsFor: 'cookies' stamp: 'mbany 4/14/2005 11:56'!checkForCookies	| check |	check _ WAExternalID new displayString.	self redirectWithCookie: 		(WACookie new			key: check;			value: 'yes';			expireIn: (Duration seconds: 2);			yourself).	^ currentRequest cookies includesKey: check! !!WASession methodsFor: 'scripts' stamp: 'avi 9/24/2005 21:09'!clearJumpTo	jumpTo _ nil! !!WASession methodsFor: 'scripts' stamp: 'avi 9/24/2005 20:00'!clearLoadScripts	scripts _ nil! !!WASession methodsFor: 'responding' stamp: 'ac 12/23/2004 04:09'!closePopup	^ self respond:		[:url |		WAResponse new			nextPutAll: '<html><script>';			nextPutAll: 'self.close();';			nextPutAll: 'self.opener.location=self.opener.location';			nextPutAll: '</script></html>';			yourself]! !!WASession methodsFor: 'responding' stamp: 'mbany 4/14/2005 11:55'!closePopupAndContinue	^ self respond:		[:url |		WAResponse new			nextPutAll: '<html><script>';			nextPutAll: 'self.close();';			nextPutAll: 'self.opener.location=',url displayString printString;			nextPutAll: '</script></html>';			yourself]! !!WASession methodsFor: 'responding' stamp: 'ac 9/27/2005 19:40'!closePopupWithoutReloadingOpener	^ self respond:		[:url |		WAResponse new			nextPutAll: '<html><script>';			nextPutAll: 'self.close();';			nextPutAll: '</script></html>';			yourself]! !!WASession methodsFor: 'http' stamp: 'mb 1/12/2006 10:15'!contentType	^WAResponse defaultValueForContentType. "text/html; charset=utf-8"! !!WASession methodsFor: 'request handling' stamp: 'avi 4/13/2004 21:47'!currentRequest	^ currentRequest! !!WASession methodsFor: 'expiring' stamp: 'mb 5/26/2006 09:18'!defaultTimeoutSeconds	^self application sessionExpirySeconds ifNil: [super defaultTimeoutSeconds]! !!WASession methodsFor: 'request handling' stamp: 'mb 5/26/2006 09:18'!errorHandler	^ application errorHandler! !!WASession methodsFor: 'responding' stamp: 'pmm 9/12/2006 19:05'!hasSessionCookie	^currentRequest cookies includesKey: self sessionCookieName	! !!WASession methodsFor: 'request handling' stamp: 'pmm 9/12/2006 19:06'!incomingRequest: aRequest	((aRequest fields includesKey: 'terminate')		and: [self application deploymentMode not])			ifTrue: [				monitor terminate.				^ WAResponse new nextPutAll: 'Process terminated'].				^ monitor		critical: [self responseForRequest: aRequest]		ifError: [ :error | WAResponse internalError: error ]! !!WASession methodsFor: 'initializing' stamp: 'avi 4/13/2004 20:29'!initializeWithApplication: anApplication	application _ anApplication.	continuations _ WALRUCache new.	monitor _ WAProcessMonitor new.	state _ WAStateRegistry new.	self initialize.! !!WASession methodsFor: 'scripts' stamp: 'avi 9/24/2005 21:08'!jumpToAnchor: aString	jumpTo _ aString! !!WASession methodsFor: 'accessing' stamp: 'mb 5/26/2006 09:19'!mainClass	^ application mainClass! !!WASession methodsFor: 'responding' stamp: 'avi 11/29/2005 11:20'!newSessionUrl	| url |	url _ self application baseUrl.	url takeServerParametersFromRequest: currentRequest.	^ url asString! !!WASession methodsFor: 'scripts' stamp: 'avi 9/24/2005 20:00'!onLoadScripts	^ scripts ifNil: [#()]! !!WASession methodsFor: 'responding' stamp: 'mb 8/18/2006 10:23'!outputDocumentClass	"To be subclassed as needed"	^WAHtmlStreamDocument! !!WASession methodsFor: 'expiring' stamp: 'avi 9/2/2004 16:28'!pageExpired	state restoreLastSnapshot.	self redirectWithMessage: 'That page has expired.' delay: 3.	WAPageExpired raiseSignal.! !!WASession methodsFor: 'responding' stamp: 'avi 5/18/2004 16:16'!pageIntentionallyLeftBlank	self returnResponse: WAResponse new! !!WASession methodsFor: 'request handling' stamp: 'mb 6/8/2006 16:01'!performRequest: aRequest	| key continuation |	key _ aRequest fields at: self actionField ifAbsent: [^ self start: aRequest].	"Under some circumstances, HTTP fields are collections of values"	(key isKindOf: OrderedCollection) ifTrue: [key _ key first].	continuation _ continuations at: key ifAbsent: [^ self unknownRequest: aRequest].	continuation value: aRequest! !!WASession methodsFor: 'printing' stamp: 'mbany 4/14/2005 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', (application urlForRequestHandler: self) displayString, ')'! !!WASession methodsFor: 'responding' stamp: 'mbany 4/14/2005 11:55'!redirect	^ self respond: [:url | WAResponse redirectTo: url displayString]! !!WASession methodsFor: 'responding' stamp: 'avi 5/18/2004 16:16'!redirectTo: urlString	self returnResponse: (WAResponse redirectTo: urlString)! !!WASession methodsFor: 'cookies' stamp: 'avi 5/18/2004 22:57'!redirectWithCookie: aCookie	self redirectWithCookies: (Array with: aCookie)! !!WASession methodsFor: 'cookies' stamp: 'mbany 4/14/2005 11:57'!redirectWithCookies: aCollection	| response |	self respond:		[:url |		response _ WAResponse redirectTo: url displayString.		aCollection do: [:ea | response addCookie: ea].		response]! !!WASession methodsFor: 'responding' stamp: 'mbany 4/14/2005 11:56'!redirectWithMessage: aString delay: aNumber	self respond:		[:url |		WAResponse			refreshWithMessage: aString			location: url displayString			delay: aNumber].! !!WASession methodsFor: 'state' stamp: 'ab 2/18/2003 18:51'!registerObjectForBacktracking: anObject	state registerObject: anObject! !!WASession methodsFor: 'responding' stamp: 'mb 2/27/2006 13:08'!respond: responseBlock	|request snapshotHolder response oldEscape |	snapshotHolder _ ValueHolder new.	oldEscape _ escapeContinuation.	escapeContinuation _		[:v |		snapshotHolder contents: state snapshot.		oldEscape value: v].	request _ 	ResponseContinuation currentDo:		[:cc ||url|		url _ self actionUrlForContinuation: cc.		response _ responseBlock value: url.		self useSessionCookie			ifTrue: 				[response addCookie: self sessionCookie]			ifFalse:				[self hasSessionCookie ifTrue:					[response deleteCookieAt: self sessionCookieName]].		self returnResponse: response].	state restoreSnapshot: snapshotHolder contents.	^ request 	! !!WASession methodsFor: 'request handling' stamp: 'pmm 9/12/2006 19:06'!responseForRequest: aRequest	currentRequest := aRequest.	^ self withEscapeContinuation: [		WACurrentSession			use: self			during: [				self withErrorHandler: [					self performRequest: aRequest ] ] ]! !!WASession methodsFor: 'responding' stamp: 'ab 6/15/2003 19:25'!returnResponse: aResponse	escapeContinuation value: aResponse! !!WASession methodsFor: 'responding' stamp: 'avi 3/13/2004 01:21'!script: aString	self redirectWithMessage: '<script>', aString, '</script>' delay: 0! !!WASession methodsFor: 'responding' stamp: 'mb 2/27/2006 13:00'!sessionCookie	^WACookie		key: self sessionCookieName		value: (self application ensureKeyForHandler: self) displayString! !!WASession methodsFor: 'responding' stamp: 'mb 2/27/2006 13:00'!sessionCookieName	^self application name! !!WASession methodsFor: 'request handling' stamp: 'avi 11/12/2005 21:37'!start: aRequest	self useSessionCookie ifTrue: [self redirectWithCookie: self sessionCookie].	self mainClass new start: aRequest! !!WASession methodsFor: 'request handling' stamp: 'avi 1/20/2006 01:41'!unknownRequest: aRequest	self start: aRequest! !!WASession methodsFor: 'responding' stamp: 'avi 9/24/2005 19:56'!updateRoot: anHtmlRoot	self application updateRoot: anHtmlRoot! !!WASession methodsFor: 'cookies' stamp: 'mb 2/9/2006 09:34'!useSessionCookie	^ self application useSessionCookie! !!WASession methodsFor: 'request handling' stamp: 'avi 4/27/2004 14:25'!withErrorHandler: aBlock	^ [aBlock		on: Error		do: [:e | self errorHandler handleError: e. WAPageExpired raiseSignal]]		on: Warning		do: [:w | self errorHandler handleWarning: w. WAPageExpired raiseSignal]! !!WASession methodsFor: 'request handling' stamp: 'avi 10/26/2004 15:40'!withEscapeContinuation: aBlock	^ EscapeContinuation currentDo:			[:cc |			escapeContinuation := cc.			aBlock value.			self pageIntentionallyLeftBlank]! !!WANotFoundHandler methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 16:16'!handleRequest: aRequest	^ WAResponse notFound: aRequest url! !!WARequestHandler class methodsFor: 'instance creation' stamp: 'pmm 4/19/2006 18:00'!new	^ self basicNew initialize! !!WARequestHandler methodsFor: 'subclass responsibilities' stamp: 'mb 5/26/2006 12:00'!description	^String new.! !!WARequestHandler methodsFor: 'subclass responsibilities' stamp: 'ab 5/18/2003 12:33'!handleRequest: aRequest	self subclassResponsibility! !!WARequestHandler methodsFor: 'initialize-release' stamp: 'pmm 11/2/2005 23:17'!initialize! !!WARequestHandler methodsFor: 'testing' stamp: 'avi 7/23/2004 15:11'!isActive	^ true! !!WARequestHandler methodsFor: 'testing' stamp: 'mb 5/26/2006 08:49'!isApplication	^ false! !!WARequestHandler methodsFor: 'testing' stamp: 'mb 5/26/2006 08:49'!isDispatcher	^ false! !!WARequestHandler methodsFor: 'testing' stamp: 'mb 5/26/2006 08:48'!isEntryPoint	^ false! !!WARequestHandler methodsFor: 'testing' stamp: 'mb 10/17/2006 11:19'!isFileHandler	^ false! !!WARequestHandler methodsFor: 'subclass responsibilities' stamp: 'avi 6/16/2004 22:55'!unregistered! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 16:14'!basicAuthWithRealm: aString	^ self new basicAuthenticationRealm: aString! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'mb 1/12/2006 10:13'!defaultValueForContentType	^'text/html; charset=utf-8'! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'mb 6/1/2006 09:05'!document: anObject mimeType: mimeType	|doc|	doc _ anObject asMIMEDocumentType: mimeType.	^ self new		contentType: (mimeType ifNil: [doc contentType]);		headerAt: 'Expires' put: 'Thu, 01 Jan 2095 12:00:00 GMT';		nextPutAll: doc content;		yourself! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 21:02'!document: anObject mimeType: mimeString fileName: fileString	^ (self document: anObject mimeType: mimeString)		attachmentWithFileName: fileString;		yourself! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 5/9/2005 13:14'!forbidden: locationString	^ self new		forbidden;		nextPutAll: '<h1> Error: you are forbidden to access "', locationString, '". </h1>';		yourself! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'mb 3/23/2006 08:12'!internalError: anError	| response |	response _ self new internalError.	response		nextPutAll: '<h1> Internal Error</h1>';		nextPutAll: '<h2>';		nextPutAll: anError displayString;		nextPutAll: '</h2>'.	(SeasidePlatformSupport walkbackStringsFor: anError) do:		[:eachLine | 		response 			nextPutAll: '<br>'; 			nextPutAll: eachLine].	^ response! !!WAResponse class methodsFor: 'instance creation' stamp: 'avi 5/18/2004 16:14'!new	^ self basicNew initialize! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 16:15'!notFound: locationString	^ self new		notFound;		nextPutAll: '<h1> Error: "', locationString, '" not found. </h1>';		yourself! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 5/18/2004 16:15'!redirectTo: locationString	^ self new redirectTo: locationString! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'mbany 4/14/2005 12:50'!refreshWithMessage: aString location: locationString delay: aNumber	^ self new nextPutAll:		 ('<html>			<head>			<meta http-equiv="refresh" content="',aNumber displayString,';URL=',locationString,'">			<title>',aString,'</title>			</head>			<body>			<h1>',aString,'</h1>			You are being redirected to <a href="',locationString,'">',locationString,'</a>			</body>		</html>');		yourself	! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 17:31'!root: anHtmlRoot render: renderBlock	| canvas |	canvas _ WAStaticHtmlCanvas root: anHtmlRoot.	renderBlock value: canvas.	^ self new nextPutAll: canvas document stream contents! !!WAResponse class methodsFor: 'as yet unclassified' stamp: 'avi 9/10/2005 17:32'!updateRoot: rootBlock render: renderBlock	| root |	root _ WAHtmlRoot new.	rootBlock value: root.	^ self root: root render: renderBlock! !!WAResponse methodsFor: 'accessing' stamp: 'mb 10/10/2006 23:39'!addCookie: aCookie	cookies ifNil: [cookies := OrderedCollection new].	(cookies includes: aCookie) ifFalse: [cookies add: aCookie]! !!WAResponse methodsFor: 'convenience' stamp: 'pmm 4/19/2006 09:30'!attachmentWithFileName: aString	self headerAt: 'Content-Disposition' put: 'attachment; filename="', aString, '"'! !!WAResponse methodsFor: 'status' stamp: 'avi 5/18/2004 14:25'!authenticationFailed	self status: 401! !!WAResponse methodsFor: 'convenience' stamp: 'avi 5/18/2004 14:25'!basicAuthenticationRealm: aString	self headerAt: 'WWW-Authenticate' put: ('Basic realm="',aString,'"').	self authenticationFailed! !!WAResponse methodsFor: 'convenience' stamp: 'mb 1/19/2006 19:30'!beXML	contentType := contentType copyReplaceAll: '/html' with: '/xml'.! !!WAResponse methodsFor: 'accessing' stamp: 'ab 7/3/2002 21:58'!contentType	^ contentType! !!WAResponse methodsFor: 'accessing' stamp: 'ab 7/3/2002 21:58'!contentType: mimeTypeString	contentType _ mimeTypeString! !!WAResponse methodsFor: 'accessing' stamp: 'avi 4/13/2004 21:21'!contents	^ stream reset! !!WAResponse methodsFor: 'accessing' stamp: 'avi 4/13/2004 21:21'!contents: aStream	stream _ aStream! !!WAResponse methodsFor: 'accessing' stamp: 'avi 5/18/2004 13:23'!cookieAt: key put: value	self addCookie: (WACookie key: key value: value)! !!WAResponse methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:28'!cookies	^ cookies ifNil: [#()]! !!WAResponse methodsFor: 'accessing' stamp: 'mb 2/9/2006 09:29'!deleteCookieAt: key	"Delete the cookie in the browser"	self addCookie: ((WACookie key: key value: '') 						expireIn: (Duration days: -10000); 						yourself)! !!WAResponse methodsFor: 'convenience' stamp: 'ac 9/11/2005 12:46'!doNotCache	self headerAt: 'Cache-Control' put: 'no-cache'.! !!WAResponse methodsFor: 'status' stamp: 'avi 5/9/2005 13:14'!forbidden	self status: 403! !!WAResponse methodsFor: 'accessing' stamp: 'mb 2/17/2005 18:13'!headerAt: key put: value	headers ifNil: [headers := OrderedCollection new].	headers add: (Association key: key value: value).! !!WAResponse methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:28'!headers	^ headers ifNil: [#()]! !!WAResponse methodsFor: 'initialize-release' stamp: 'mb 4/23/2006 10:53'!initialize	| session |	stream _ SeasidePlatformSupport readWriteStream.	status _ '200'.	session _ WACurrentSession value.	contentType _ session isNil 				ifFalse: [session contentType]				ifTrue: [self class defaultValueForContentType]! !!WAResponse methodsFor: 'status' stamp: 'avi 5/18/2004 15:57'!internalError	self status: 500! !!WAResponse methodsFor: 'accessing' stamp: 'ab 7/7/2003 11:12'!nextPut: aCharacter	stream nextPut: aCharacter asCharacter! !!WAResponse methodsFor: 'accessing' stamp: 'ab 7/7/2003 11:12'!nextPutAll: aString	aString do: [:ea | self nextPut: ea]! !!WAResponse methodsFor: 'status' stamp: 'avi 5/18/2004 14:25'!notFound	self status: 404! !!WAResponse methodsFor: 'status' stamp: 'avi 5/18/2004 14:26'!redirect	self status: 302! !!WAResponse methodsFor: 'convenience' stamp: 'avi 11/27/2005 15:19'!redirectTo: aString	self headerAt: 'Location' put: aString.	self redirect.! !!WAResponse methodsFor: 'accessing' stamp: 'tbn 7/20/2006 17:31'!release	stream := cookies := headers := nil.	super release! !!WAResponse methodsFor: 'accessing' stamp: 'ac 3/22/2006 12:06'!space	stream space.! !!WAResponse methodsFor: 'accessing' stamp: 'ab 7/3/2002 21:50'!status	^ status! !!WAResponse methodsFor: 'accessing' stamp: 'mbany 4/14/2005 12:51'!status: statusString	status _ statusString displayString! !!WAResponse methodsFor: 'accessing' stamp: 'avi 2/6/2004 15:28'!stream	^ stream! !!WAResponse methodsFor: 'accessing' stamp: 'avi 5/18/2004 14:28'!stream: aStream	stream _ aStream! !!WAResponse methodsFor: 'writing' stamp: 'avi 1/6/2006 12:53'!writeHeadersOn: aStream	self headers associationsDo:		[:assoc |		aStream nextPutAll: assoc key; nextPutAll: ': '; nextPutAll: assoc value asString.		aStream crlf].	aStream nextPutAll: 'Content-Type: ', self contentType.	aStream crlf! !!WAResponse methodsFor: 'writing' stamp: 'avi 1/6/2006 12:52'!writeOn: aStream	self writeStatusOn: aStream.	self writeHeadersOn: aStream.	aStream crlf.	aStream nextPutAll: stream contents! !!WAResponse methodsFor: 'writing' stamp: 'avi 1/6/2006 12:51'!writeStatusOn: aStream	aStream nextPutAll: 'HTTP/1.0 ', self status asString.	aStream crlf! !!WAStreamResponse methodsFor: 'accessing' stamp: 'pmm 4/19/2006 17:32'!hasWrittenHeaders	^ writtenHeaders! !!WAStreamResponse methodsFor: 'initialize-release' stamp: 'mb 9/22/2006 12:26'!initialize	super initialize.	writtenHeaders := false! !!WAStreamResponse methodsFor: 'accessing' stamp: 'avi 1/6/2006 13:31'!stream	self writeOn: stream.	^ stream! !!WAStreamResponse methodsFor: 'private' stamp: 'avi 1/6/2006 14:11'!writeOn: aStream	self hasWrittenHeaders ifFalse:		[self writeStatusOn: aStream.		self writeHeadersOn: aStream.		aStream crlf.		writtenHeaders _ true]! !!WASpotProfiler class methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 13:01'!initialize	Profilers _ Dictionary new! !!WASpotProfiler class methodsFor: 'as yet unclassified' stamp: 'lr 5/3/2006 09:38'!new	^ self basicNew initialize! !!WASpotProfiler class methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:51'!profile: aBlock	| profiler |	profiler _ Profilers at: thisContext sender selector ifAbsentPut: [self new].	^ profiler profile: aBlock! !!WASpotProfiler class methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:59'!profilers	^ Profilers! !!WASpotProfiler methodsFor: 'private' stamp: 'avi 11/7/2005 12:56'!allReadings	^ readings gather: [:ea | ea]! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:54'!averageReadingTime	^ self allReadings average! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:55'!averageReadingsPerRequest	^ (readings collect: [:ea | ea size]) average! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:53'!averageRequestTime	^ self requestTimes average! !!WASpotProfiler methodsFor: 'private' stamp: 'avi 11/7/2005 12:51'!initialize	self reset! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:50'!profile: aBlock	| time value |	time _ Time millisecondsToRun: [value _ aBlock value].	(readings at: Processor activeProcess ifAbsentPut: [OrderedCollection new]) add: time.	^ value! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:54'!readingCount	^ self allReadings size! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:54'!requestCount	^ self requestTimes size! !!WASpotProfiler methodsFor: 'private' stamp: 'avi 11/7/2005 12:53'!requestTimes	^ readings collect: [:ea | ea sum]! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:52'!reset	readings _ Dictionary new! !!WASpotProfiler methodsFor: 'as yet unclassified' stamp: 'avi 11/7/2005 12:54'!totalTime	^ self requestTimes sum! !!WAStateHolder commentStamp: '<historical>' prior: 0!I am a ValueHolder whose contents will properly track the user's use of the back button.  Use me to wrap any values that you wish to backtrack when the back button is used.Sometimes it might be more convenient to register your business object directly:	WACurrentSession value registerObjectForBacktracking: businessObject.or even to register a component for backtracking, as seen in WACounter:	WACounter>>initialize		self session registerObjectForBacktracking: self.!!WAStateHolder class methodsFor: 'as yet unclassified' stamp: 'avi 4/13/2004 19:48'!new	|inst|	inst _ super new.	WACurrentSession value registerObjectForBacktracking: inst.	^ inst! !!WAStateHolder methodsFor: 'as yet unclassified' stamp: 'ab 2/20/2003 01:04'!contents	^ contents! !!WAStateHolder methodsFor: 'as yet unclassified' stamp: 'ab 2/20/2003 01:04'!contents: anObject	contents _ anObject! !!WAStateHolder methodsFor: 'as yet unclassified' stamp: 'mb 4/23/2006 21:38'!hash	^ hash ifNil: [ hash _ SmallInteger maxVal atRandom ].! !!WAStateHolder methodsFor: 'as yet unclassified' stamp: 'ab 2/20/2003 01:05'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	contents printOn: aStream.	aStream nextPut: $).! !!WAStateRegistry class methodsFor: 'as yet unclassified' stamp: 'pmm 4/18/2006 20:17'!new	^ self basicNew initialize! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'ab 2/18/2003 18:55'!calculateFootprint	^ (objects detectSum: [:ea | 2 + ea class instSize + (ea class isVariable ifTrue: [ea size + 1] ifFalse: [0])]) * 4! !!WAStateRegistry methodsFor: 'initialize-release' stamp: 'mb 5/6/2006 16:09'!initialize	objects _ SeasidePlatformSupport weakDictionaryOfSize: 10.! !!WAStateRegistry methodsFor: 'testing' stamp: 'pmm 4/21/2006 23:26'!isEmpty	^self size = 0! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'avi 9/1/2004 21:17'!registerObject: anObject	objects at: anObject put: anObject snapshotCopy! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'avi 1/31/2004 17:28'!restoreLastSnapshot	lastSnapshot ifNotNil: [self restoreSnapshot: lastSnapshot]! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'avi 9/1/2004 21:18'!restoreObject: object fromSnapshot: copy	object restoreFromSnapshot: copy.	objects at: object put: copy.! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'ab 7/3/2003 12:03'!restoreSnapshot: aDictionary	aDictionary keysAndValuesDo:		[:k :v |		self restoreObject: k fromSnapshot: v]! !!WAStateRegistry methodsFor: 'accessing' stamp: 'ab 7/3/2003 12:03'!size	^ objects size! !!WAStateRegistry methodsFor: 'as yet unclassified' stamp: 'avi 9/1/2004 21:21'!snapshot	lastSnapshot := SeasidePlatformSupport weakDictionaryOfSize: objects size.	objects keysAndValuesDo:		[:obj :copy|		(obj isIdenticalToSnapshot: copy)			ifTrue: [lastSnapshot at: obj put: copy]			ifFalse: [lastSnapshot at: obj put: obj snapshotCopy]].	^ lastSnapshot! !!WAStoreAddress commentStamp: 'avi 1/1/2004 07:36' prior: 0!A simple model of a billing or shipping address.  Stores strings for a person's name, street, city, and country.  Apart from accessors for these, the only behavior this provides is a #validate method which will throw errors if street, city, or country is nil.!!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:53'!city	^ city! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:52'!city: aString	city _ aString! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:53'!country	^ country! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:53'!country: aString	country _ aString! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:53'!name	^ name! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:52'!name: aString	name _ aString! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:53'!street	^ street! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 13:52'!street: aString	street _ aString! !!WAStoreAddress methodsFor: 'as yet unclassified' stamp: 'cds 7/25/2005 10:20'!validate	street ifNil: [self validationError: 'You must provide a street address.'].	city ifNil: [self validationError: 'You must provide a city.'].	country ifNil: [self validationError: 'You must provide a country.'].! !!WAStoreCart commentStamp: 'avi 1/1/2004 07:44' prior: 0!A shopping cart.  This is essentially a specialized Bag: you can #add: or #remove: WAStoreItems to it, and calculate their #totalPrice.  You can also use #countsAndItems to get a collection of associations between the items and the number of times they appear in the cart, useful for summary displays.!!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:36'!add: anObject	items ifNil: [items _ Bag new].	items add: anObject! !!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:40'!countsAndItems	^ items sortedCounts! !!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 14:01'!hasItems	^ items notNil and: [items isEmpty not]! !!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:21'!items	^ items! !!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:40'!remove: anObject	items remove: anObject ifAbsent: []! !!WAStoreCart methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:41'!totalPrice	^ items detectSum: [:ea | ea price]! !!WAStoreCreditCard commentStamp: 'avi 1/1/2004 07:47' prior: 0!Models credit card information - it has accessors for #name and #number (both strings), and #expiry date.  #validate throws an error if anything is missing, or if the expiry date is in the past.This is intended to be an abstract class - the subclasses WAStoreMasterCard and WAStoreVisaCard provide further validation.!!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:02'!expiry	! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:03'!expiry: aDate	expiry _ aDate! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:02'!name	^ name! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:01'!name: aString	name _ aString! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:02'!number	^ number! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 14:02'!number: aString	number _ aString! !!WAStoreCreditCard methodsFor: 'as yet unclassified' stamp: 'cds 7/25/2005 10:20'!validate	name ifNil: [self validationError: 'You must provide the name of the credit card owner.'].	number ifNil: [self validationError: 'You must provide a credit card number.'].	expiry ifNil: [self validationError: 'You must provide an expiry date.'].	expiry < Date today ifTrue: [self validationError: 'The expiry date must not be in the past'].	! !!WAStoreMasterCard commentStamp: 'avi 1/1/2004 09:35' prior: 0!Adds MasterCard-specific validation to WAStoreCreditCard.!!WAStoreMasterCard class methodsFor: 'as yet unclassified' stamp: 'avi 12/10/2003 14:04'!abbreviation	^ 'MC'! !!WAStoreMasterCard methodsFor: 'as yet unclassified' stamp: 'cds 7/25/2005 10:20'!validate	super validate.	number first = $5 ifFalse: [self validationError: 'Mastercard numbers must start with "5"'].! !!WAStoreVisaCard commentStamp: 'avi 1/1/2004 09:35' prior: 0!Adds VISA-specific validation to WAStoreCreditCard.!!WAStoreVisaCard class methodsFor: 'as yet unclassified' stamp: 'avi 12/10/2003 14:04'!abbreviation	^ 'VISA'! !!WAStoreVisaCard methodsFor: 'as yet unclassified' stamp: 'cds 7/25/2005 10:20'!validate	super validate.	number first = $4 ifFalse: [self validationError: 'Visa card numbers must start with "4"'].! !!WAStoreInventory commentStamp: 'avi 1/1/2004 09:33' prior: 0!The list of inventory items.  In a real application, this would probably have to deal with persistence, maintaining inventory counts, etc.  In this example, it just builds a collection of WAStoreItems from a hardcoded data set, and provides #allItems and #findItem: for accessing these.!!WAStoreInventory class methodsFor: 'as yet unclassified' stamp: 'avi 12/8/2003 14:26'!default	^ default ifNil: [default _ self new]! !!WAStoreInventory class methodsFor: 'instance creation' stamp: 'avi 12/8/2003 14:17'!new	^ self basicNew initialize! !!WAStoreInventory methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:19'!allItems	^ items! !!WAStoreInventory methodsFor: 'as yet unclassified' stamp: 'ab 8/15/2003 17:19'!findItem: searchString	^ items select: [:ea | ea matches: searchString]! !!WAStoreInventory methodsFor: 'initialize-release' stamp: 'ab 8/15/2003 17:19'!initialize	items _ OrderedCollection new.	self itemSpecs do:		[:row |		items add: (self itemFromSpec: row)]! !!WAStoreInventory methodsFor: 'as yet unclassified' stamp: 'pmm 11/2/2005 23:45'!itemFromSpec: anArray	^ WAStoreItem new		title: anArray first;		subtitle: anArray second;		description: anArray third;		price: anArray fourth;		yourself! !!WAStoreInventory methodsFor: 'as yet unclassified' stamp: 'avi 9/18/2003 16:43'!itemSpecs"adapted from http://www.thaddeus.com/ftp/database/sushi.zip"	^ #(#('Akami Maguro' 'Red Tuna' 'The lean meat near the spine of the tuna fish.  It comes in various shades of red--with the lighter, shinier varieties being the best.  For dieters, however, the redder the better.  Easy on the palatte.  The least expensive of the three types of maguro.' 150)#('Chutoro Maguro' 'Fatty Tuna' 'The moderately fatty part of the tuna belly.  It''s pink, but not the faint pink of ohtoro.  Soft, butter-like texture.  Moderately expensive.' 275)#('Geso Ika' 'Cuttlefish Tentacles' 'White in color, geso is boiled and brushed with thick teriyaki sauce before serving as sushi.  Its texture is chewy, and its mild flavor is complemented by the sweet-salty teriyaki.' 200)#('Himo Akagai' 'Ark Shell Filaments' 'This is the thread-like edges which connect the flesh to the shell.  A delicious, soft texture and mild taste.' 200)#('Hotategai' 'Scallop' 'The part of the scallop that is eaten is the edible adductor muscle that opens the animal''s shell.  It''s pale beige-yellow in color with a brown, crusty edging.  The taste is delicate, and melts in your mouth. ' 250)#('Iwashi' 'Sardine' 'Shiny, slippery, and ''fishy,'' the taste of sardine sushi is slightly oily.  Sardine must be eaten shortly after it has been caught if it''s to be used in Sushi.  Often eaten with soy sauce mixed with ginger and onion.' 175)#('Kazunoko' 'Herring Roe' 'An expensive delicacy which is also known as ''yellow diamonds'' (because of the color and expense).  Revered in Japan, it''s usually eaten on special occasions.  An acquired taste for Westerners.' 475)#('Kisu' 'Sillago' 'A fresh Sillago has bright-gold skin. The taste is mild and delicate.' 225)#('Ohtoro Maguro' 'Fattiest Tuna' 'Fattiest part of the fatty tuna belly.  It is light pink in color and melts in your mouth.  Mild with a rich texture.  This is the most expensive of the three types of Maguro sushi.' 325)#('Shima-Aji' 'Yellow Jack' 'A slice of white silvery shima-aji eaten with beef-steak plant and fresh ginger is delicious.  The flavor is delicate and the texture of good, fresh yellow jack is smooth and slides down easily.' 180)#('Aji' 'Horse Mackerel' 'This fish is pink-grey and shiny.  When it''s fresh, the flesh is almost transparent.  The texture is slippery and easy on the tongue--it should melt in your mouth.  Aji is often eaten with soy sauce containing onion, ginger and garlic.' 250)#('Inarizushi' 'Stuffed Bean Curd Rolls' '' 200)#('Kappa Maki' 'Cucumber Rolls' '' 150)#('Sakura Denbu' 'Shredded Cod Fish' 'Seasoned shredded cod fish.' 200)#('California Roll' '' 'Rice, cucumber, crab meat, & avacado.' 250)#('Futo-Maki' 'Fat Rolls' 'Kampyo gourd, oboro or denbu pink powder, tamago omelet, and shiitake mushrooms. May also include bamboo shoots, cucumbers, cooked eel, cooked carrots, and cooked spinach or other greens.' 275)#('Tekkamaki' 'Tuna Roll' 'Tuna wrapped in rice and nori.' 225)#('Chakinzushi' 'Omelet-wrapped Sushi' 'Sushi rice in a thin omelet wrapper shaped and tied like a lady''s drawstring purse.  Sometimes a single pea or small shrimp decorates the ruffled part of the wrapper.' 300)#('Shiro Maguro' 'Albacore Tuna' '' 300)#('Hamachi' 'Yellowtail' '' 325)#('Kohada' 'Gizzard Shad' 'This Japanese shad is a member of the herring family, and is a small silver-grey fish, with a black spotted back.  Marinated in vinegar and cross- hatched before serving.  The taste is strong, and a favorite for herring fans.' 275)#('Katsuo' 'Bonito' '' 275)#('Saba' 'Mackerel' '' 200)#('Sake' 'Salmon' '' 250)#('Tai' 'Red Snapper' '' 250)#('Hirame' 'Flounder' 'Good hirame is a sushi gourmet''s delight.  Since it''s cut from such a small part of the fish, it''s scarce and expensive.  In appearance, it''s pale pink and smooth, with no markings.  The taste is delicate and buttery.' 350)#('Suzuki' 'Sea Bass' '' 300)#('Unagi' 'Freshwater Eel' '' 300)#('Ika' 'Cuttlefish' 'When fresh, cuttlefish is almost transparent.  It''s butter-like and melts in your mouth.  The texture is sticky.  Cuttlefish is smoky white and glistens. Also popular grilled and mixed with ginger soy sauce.  Also good with lemon for Western palettes.' 325)#('Awabi' 'Abalone' 'Abalone or ''sea snail'' is another sushi favorite.  The color ranges from beige-grey to pinkish yellow.  Fresh abalone is not too rubbery, and is very subtle in flavor.' 300)#('Mirugai' 'Horse Clam' 'Also known as Geoduck.  This is a large, hard-shelled clam which is yellowish-white in color.  It has a slight ''shellfish'' taste and an elastic type texture. The part used in sushi is the long muscular siphon which projects from the shell.' 350)#('Akagai' 'Ark Shell Clam' 'The softest texture of any shellfish. Akagai has an attractive pink-orange color.  The taste is delicate and slightly sweet.' 300)#('Kobashira' 'Trough Shell (Small) Scallop' 'The edible adductor muscle that opens the shell of the aoyagi.  More prized than the aoyagi itself.' 500)#('Kani' 'Crab' '' 250)#('Ebi' 'Cooked Prawn' '' 225)#('Ikura' 'Salmon Roe' 'Appealing to the eye with its bright red color.  Very appetizing with a delicate taste.' 325)#('Tobiko ' 'Flying-Fish Roe' '' 350)#('Masago ' 'Capelin Roe' '' 350)#('Anago' 'Conger Eel' 'Anago is one of the few pre-cooked sushi.  It is grilled and basted with a thick teriyaki sauce.  The soft, slighty warm eel, the sweet soy sauce, and the vinegared rice make a particularly delicious sushi.' 300)#('Uni' 'Sea Urchin Roe' 'A prized delicacy with its oily, rich texture.  Mustard color, paste-like topping is held in place by a band of nori seaweed.' 400)) asSortedCollection: [:a :b | a first <= b first]! !!WAStoreItem commentStamp: 'avi 1/1/2004 09:34' prior: 0!Models a single item of inventory - stores a title, subtitle, fill description, and price.  The only real behavior is #matches:, which is used for search.!!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:27'!description	^ description! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:27'!description: aString	description _ aString! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:30'!matches: aString	^ (title includesSubstring: aString caseSensitive: false)		or: [description includesSubstring: aString caseSensitive: false]! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:28'!price	^ price! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:28'!price: cents	price _ cents! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'avi 12/9/2003 13:17'!printString	^ self title! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/31/2003 23:17'!subtitle	^ subtitle! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'avi 8/29/2004 14:12'!subtitle: aString	subtitle _ aString! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:27'!title	^ title! !!WAStoreItem methodsFor: 'as yet unclassified' stamp: 'ab 5/25/2003 13:27'!title: aString	title _ aString! !!WAScriptLibrary class methodsFor: 'as yet unclassified' stamp: 'mb 3/9/2006 10:46'!generateXref	"((( WAStandardScripts generateXref )))"	| aStream sel |	self new do:		[:script |		aStream _ script readStream.		[aStream atEnd] whileFalse:			[aStream upToAll: 'function'.			sel _ (aStream upTo: $() trimBlanks.			sel notEmpty ifTrue:				[self compile: sel classified: 'for x-ref']]]! !!WAScriptLibrary class methodsFor: 'processing' stamp: 'avi 6/24/2004 00:34'!updateRoot: anHtmlRoot	self new do: [:ea | anHtmlRoot addScript: ea]! !!WAStandardScripts class methodsFor: 'processing' stamp: 'mb 6/28/2006 16:09'!updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	#onKeyDown.	anHtmlRoot bodyAttributes at: 'onKeyDown' put: 'onKeyDown(event)'! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!addShortcut! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!chooseOther! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!enableChoice! !!WAStandardScripts methodsFor: 'scripts' stamp: 'mb 3/8/2006 15:55'!misc	^ '	function swapDisplay(a, b) {		var tmp = document.getElementById(a).style.display;		document.getElementById(a).style.display = document.getElementById(b).style.display;		document.getElementById(b).style.display = tmp;	}	function submitFormTriggeringCallback(formName, callbackKey, value) {		if (value)			{				var ele = document.createElement("input");				ele.type = "hidden";				ele.name = callbackKey;				ele.value = value;				document.forms[formName].appendChild(ele)			}		submitForm(formName)	}	function submitForm(formName) {		document.forms[formName].submit();	}		function chooseOther(select, hiddenId, p) {		value = prompt(p);		document.getElementById(hiddenId).value = value;		select.options[select.options.length-1].text = value;	}		function enableChoice(enableID, disableID) {		document.getElementById(enableID).disabled = false;		document.getElementById(disableID).disabled = true;	}	function setFocus(elementId) {		document.getElementById(elementId).focus();	}	function setCursor(elementId, pos) {		var input = document.getElementById(elementId);		input.focus();		/* When pos parameter not supplied, place cursor at end of input field */		if (!!pos) pos = input.value.length;		if (typeof document.selection !!= "undefined") {	    		/* Place cursor in MS-IE */	    		var range = document.selection.createRange();	     	range.moveStart("character", pos);	 		range.select();	  	} else if (typeof input.selectionStart !!= "undefined") {		  	/* Place cursor in Gecko browsers */	    		input.selectionStart = pos;	    		input.selectionEnd = pos;	  	} else {	  		/* Other browsers, please feel free to implement */			alert("unknown browser");		}	}'! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!onKeyDown! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!resetShortcuts! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!setCursor! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!setFocus! !!WAStandardScripts methodsFor: 'scripts' stamp: 'mb 9/30/2006 14:36'!shortcuts	^ '	var shortcutKeys = [];	var shortcutElements = [];		function resetShortcuts() {		shortcutKeys = [];		shortcutElements = [];		}	function addShortcut(shortcut, elementID) {		var elem = document.getElementById(elementID);		if ((elem.tagName == "INPUT" & (elem.type == "submit" || elem.type == "image" || elem.type == "checkbox" || elem.type == "radio")) || elem.tagName == "A")			{			shortcutKeys[shortcutKeys.length] = shortcut;			shortcutElements[shortcutElements.length] = elem;			}		else alert("Attempt to assign a shortcut (" + shortcut + ") to something that is not clickable");	}	function onKeyDown(event) {		var keyname = "";		var element;		var nav;		if (navigator.userAgent.indexOf("Safari") > 0)			nav = "Safari";		else if (navigator.product == "Gecko")			nav = "Gecko";		else			nav = "IE";		// cope with MS-IE		if (event == null) event = window.event;		if (event) {			if (event.ctrlKey) keyname = keyname + "Ctrl-";			if (event.altKey) keyname = keyname + "Alt-";			if (event.metaKey) keyname = keyname + "Meta-";			// cope with Netscape			var keyCode = event.which;			if (keyCode == null) keyCode = event.keyCode;			if (keyCode == null) keyCode = event.charCode;			if (keyCode !!= 0) {				var character = String.fromCharCode(keyCode);				character = character.toLowerCase();				if (event.shiftKey) character = character.toUpperCase();				// cope with special keys, designated with some logical names				if (keyCode == 27) character = "Esc";				if (keyCode == 8) character = "Backspace";				if (keyCode == 9) character = "Tab";				if (keyCode == 13) character = "Return";				if (keyCode == 37) character = "Left";				if (keyCode == 38) character = "Up";				if (keyCode == 39) character = "Right";				if (keyCode == 40) character = "Down";				// cope with func-keys (some keys not intercepted for MS-IE)				if ((keyCode >= 112) & (keyCode <= 123)) character = "F" + (keyCode - 112 + 1);				for ( var x = 1 ; x <= shortcutKeys.length ; x++ ) {					if (shortcutKeys[x-1] == keyname+character) {						// alert("key=" + keyCode + " " + keyname + character);						element = shortcutElements[x-1];						if (element.tagName == "A" & nav !!= "IE") {							if (element.onclick) 								element.onclick.call();							else								/* This does not work for anchor in IE */								location.href = element.href;						} else  {							element.click();						}					}				}				return false;			}		}	}'! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!submitForm! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!submitFormTriggeringCallback! !!WAStandardScripts methodsFor: 'for x-ref' stamp: 'mb 3/9/2006 10:46'!swapDisplay! !!WAStringLibrary methodsFor: 'printing' stamp: 'avi 6/24/2004 00:28'!asString	^ self class name! !!WAStringLibrary methodsFor: 'accessing' stamp: 'avi 6/24/2004 00:13'!at: aSymbol	^ self perform: aSymbol! !!WAStringLibrary methodsFor: 'accessing' stamp: 'avi 6/24/2004 00:13'!at: aSymbol put: aString	self class compile: aSymbol, '	^ ', aString printString! !!WAStringLibrary methodsFor: 'printing' stamp: 'mbany 4/14/2005 13:01'!displayString	^ self class name! !!WAStringLibrary methodsFor: 'enumerating' stamp: 'mb 2/9/2006 16:02'!do: aBlock	self keys do: 		[:each |		| object |		object _ self at: each.		object isString ifTrue: [aBlock value: object]].! !!WAStringLibrary methodsFor: 'accessing' stamp: 'avi 9/21/2005 21:52'!keys	^ (self class selectors select: [:ea | ea isUnary]) asSortedCollection! !!WAStandardStyles methodsFor: 'styles' stamp: 'lr 9/26/2005 15:15'!basics	^ 'div.clearer {clear: both}.option-selected {font-weight: bold}'! !!WAStandardStyles methodsFor: 'styles' stamp: 'avi 12/12/2004 13:41'!kalseyTabs	"this is from http://kalsey.com/tools/csstabs/ - would also be nice to do http://www.alistapart.com/articles/slidingdoors/"	^ '.kalsey .navigation-options {	border-bottom : 1px solid #ccc;	margin : 0;	padding-bottom : 19px;	padding-left : 10px;}.kalsey .navigation-options ul, .kalsey .navigation-options li	{	display : inline;	list-style-type : none;	margin : 0;	padding : 0;}	.kalsey .navigation-options a:link, .kalsey .navigation-options a:visited	{	background : #E8EBF0;	border : 1px solid #ccc;	color : #666;	float : left;	font-size : small;	font-weight : normal;	line-height : 14px;	margin-right : 8px;	padding : 2px 10px 2px 10px;	text-decoration : none;}.kalsey .navigation-options a:link.active, .kalsey .navigation-options a:visited.active	{	background : #fff;	border-bottom : 1px solid #fff;	color : #000;}.kalsey .navigation-options ul a:hover	{	color : #f00;}.kalsey .navigation-options #option-selected a {	background : #fff;	border-bottom : 1px solid #fff;	color : #000;}.kalsey .navigation-content {	background : #fff;	border : 1px solid #ccc;	border-top : none;	clear : both;	margin : 0px;	padding : 15px;	line-height: 1.1;  /* IE6 CSS workaround - http://www.dracos.co.uk/web/css/ie6floatbug/ */}'! !!WAStandardStyles methodsFor: 'styles' stamp: 'lr 10/3/2006 09:27'!sourceStyle	^'.halo .halo-source .tag-known {	font-weight: bold;	color: navy;}.halo .halo-source .attribute-known {	color: navy;}.halo .halo-source .attribute-value {	color: purple;}.halo-source .comment {	font-style: italic;	color: green;}'! !!WAStyleLibrary class methodsFor: 'processing' stamp: 'avi 6/24/2004 00:34'!updateRoot: anHtmlRoot	self new do: [:ea | anHtmlRoot addStyle: ea]! !!WAUrl class methodsFor: 'instance creation' stamp: 'avi 3/18/2004 16:07'!new	^ self basicNew initialize! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:45'!addParameter: aString	self addParameter: aString value: nil! !!WAUrl methodsFor: 'accessing' stamp: 'avi 11/7/2005 13:09'!addParameter: keyString value: valueString	params at: keyString put: valueString.	parameterString _ nil! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:45'!addToPath: aString	path addAll: (aString findTokens: '/')! !!WAUrl methodsFor: 'printing' stamp: 'avi 3/22/2004 00:42'!asString	^ self urlWithQueryString! !!WAUrl methodsFor: 'copying' stamp: 'avi 4/15/2004 11:35'!copy	| copy |	copy _ self class new.	copy hostname: host; port: port; scheme: scheme; fragment: fragment.	copy addToPath: self pathString.	params keysAndValuesDo: [:k :v | copy addParameter: k value: v].	^ copy! !!WAUrl methodsFor: 'private' stamp: 'avi 3/22/2004 00:47'!defaultPortForScheme: aSymbol	^ aSymbol = #http		ifTrue: [80]		ifFalse: [aSymbol = #https					ifTrue: [443]]! !!WAUrl methodsFor: 'printing' stamp: 'mbany 4/14/2005 13:02'!displayString	^ self urlWithQueryString! !!WAUrl methodsFor: 'accessing' stamp: 'avi 4/15/2004 11:35'!fragment	^ fragment! !!WAUrl methodsFor: 'accessing' stamp: 'avi 4/15/2004 11:35'!fragment: aString	fragment _ aString! !!WAUrl methodsFor: 'printing' stamp: 'avi 4/15/2004 11:35'!fragmentString	^ fragment ifNil: [''] ifNotNil: ['#', fragment]! !!WAUrl methodsFor: 'requesting' stamp: 'mb 3/24/2006 18:03'!getDocument	^ SeasidePlatformSupport getDocumentWithUrl: self! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/19/2004 14:37'!hostname	^ host! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/19/2004 14:37'!hostname: aString	host _ aString! !!WAUrl methodsFor: 'initialize-release' stamp: 'avi 3/22/2004 00:48'!initialize	path _ OrderedCollection new.	params _ Dictionary new.	scheme _ #http! !!WAUrl methodsFor: 'printing' stamp: 'avi 11/7/2005 12:25'!isSeasideField: aString	^ aString first  = $_ or: [aString allSatisfy: [:ea | ea isDigit]]! !!WAUrl methodsFor: 'private' stamp: 'avi 11/7/2005 12:26'!orderedParameterKeys 	| keys |	keys _ OrderedCollection new.	params keys do: [:ea | (self isSeasideField: ea) ifTrue: [keys addLast: ea] ifFalse: [keys addFirst: ea]].	^ keys! !!WAUrl methodsFor: 'printing' stamp: 'avi 11/7/2005 13:08'!parameterString	| v |	^ parameterString ifNil: [parameterString _ String streamContents:		[:s |		params isEmpty ifFalse:			[s nextPut: $?.			self orderedParameterKeys do:				[:k |				v _ params at: k.				s nextPutAll: k encodeForHTTP.				v ifNotNil: [s nextPut: $=; nextPutAll: v encodeForHTTP].				s nextPut: $&].			s skip: -1]]]! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/19/2004 13:11'!parameters	^ params! !!WAUrl methodsFor: 'accessing' stamp: 'mb 3/24/2006 15:29'!parametersForHttpSocket	| dict |	dict _ Dictionary new.	self parameters keysAndValuesDo: 		[:k :v | dict at: k put: (Array with: v)].	^ dict! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:46'!path	^ path! !!WAUrl methodsFor: 'accessing' stamp: 'lr 5/3/2005 08:51'!pathString	^ String streamContents: [ :stream | 		stream nextPut: $/.		path 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: $/ ] ]! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:47'!port	^ port ifNil: [self defaultPortForScheme: scheme]! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/18/2004 16:07'!port: aNumber	port _ aNumber! !!WAUrl methodsFor: 'printing' stamp: 'avi 11/7/2005 12:31'!queryString	^ self parameterString, self fragmentString! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:47'!scheme	^ scheme! !!WAUrl methodsFor: 'accessing' stamp: 'avi 3/22/2004 00:47'!scheme: aSymbol	scheme _ aSymbol! !!WAUrl methodsFor: 'printing' stamp: 'avi 11/28/2005 16:07'!serverString	host ifNil: [^ ''].		^ String streamContents:		[:stream |		stream nextPutAll: scheme.		stream nextPutAll: '://'.		stream nextPutAll: host.				((self defaultPortForScheme: scheme) = self port)			ifFalse: [stream nextPutAll: ':', port displayString]]! !!WAUrl methodsFor: 'private' stamp: 'avi 11/7/2005 13:07'!setParameterString: aString	parameterString _ aString! !!WAUrl methodsFor: 'accessing' stamp: 'avi 11/27/2005 15:17'!takeServerParametersFromRequest: aRequest	| httpHost |	host ifNil:		[httpHost _ aRequest headerAt: 'host' ifAbsent: [^ self]. 		host _ httpHost copyUpTo: $:.		(httpHost includes: $:) ifTrue:			[port _ (httpHost copyAfter: $:) asNumber]]! !!WAUrl methodsFor: 'printing' stamp: 'avi 4/15/2004 11:36'!urlString	^ self serverString, self pathString, self fragmentString! !!WAUrl methodsFor: 'printing' stamp: 'avi 10/6/2005 10:00'!urlWithQueryString	^ String streamContents:		[:s |		s nextPutAll: self serverString.		s nextPutAll: self pathString.		s nextPutAll: self queryString]! !!WAUrl methodsFor: 'copying' stamp: 'avi 3/22/2004 00:52'!with: pathString	^ self copy		addToPath: pathString;		yourself! !!WAUrl methodsFor: 'copying' stamp: 'avi 11/7/2005 13:08'!withParameter: aString	^ self copy		addParameter: aString;		setParameterString: (self parameterString, '&', aString);		yourself! !!WAUrl methodsFor: 'copying' stamp: 'avi 3/22/2004 00:51'!withParameter: aString value: valueString	^ self copy		addParameter: aString value: valueString;		yourself! !!WAUtf8EncodingStream commentStamp: 'pmm 10/14/2006 14:37' prior: 0!I wrap a SocketStream and encode the input to utf-8.Unfortunately such hacks are needed because of the Squeak Stream hierarchy.!!WAUtf8EncodingStream class methodsFor: 'instance creation' stamp: 'pmm 10/14/2006 04:03'!on: aStream	^self new		setStream: aStream;		yourself! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 11:12'!basicNextPut: aCharacter	stream nextPut: aCharacter! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 04:09'!crlf	stream crlf! !!WAUtf8EncodingStream methodsFor: 'initialize-release' stamp: 'pmm 10/14/2006 14:15'!initialize	super initialize.	encoder := TextConverter newForEncoding: 'utf8'! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 11:14'!isBinary	^false! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 11:13'!nextPut: aCharacter	encoder nextPut: aCharacter toStream: self ! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 04:02'!nextPutAll: aColllection	aColllection do: [ :each |		self nextPut: each ]! !!WAUtf8EncodingStream methodsFor: 'initialize-release' stamp: 'pmm 10/14/2006 04:02'!setStream: aStream	stream := aStream! !!WAUtf8EncodingStream methodsFor: 'accessing' stamp: 'pmm 10/14/2006 11:16'!socket	^stream socket! !!Form methodsFor: '*seaside2-squeak' stamp: 'mb 6/12/2006 14:01'!asMIMEDocument 	^self asMIMEDocumentType: self defaultMimeType.! !!Form methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 11:05'!asMIMEDocumentType: mimeType	| aStream |	aStream _ (RWBinaryOrTextStream on: '').	(self writerForMimeType: mimeType)		putForm: (self asFormOfDepth: 32) onStream: aStream.	^MIMEDocument contentType: mimeType content: aStream contents! !!Form methodsFor: '*seaside2-squeak' stamp: 'mb 6/12/2006 14:00'!defaultMimeType	^'image/gif'! !!Form methodsFor: '*seaside2-squeak' stamp: 'mb 6/12/2006 14:01'!mimeType	^ self defaultMimeType! !!Form methodsFor: '*seaside2-squeak' stamp: 'mb 6/12/2006 14:02'!writerForMimeType: mimeTypeString	| mimeType tokens type |	mimeType _ mimeTypeString isString		ifTrue: [mimeTypeString]		ifFalse: [self mimeType].	[tokens _ mimeType findTokens: '/'.	tokens size < 2] whileTrue: [mimeType _ self defaultMimeType].	"First token is assumed to be 'image'"	type _ tokens second.	type = 'jpg' ifTrue: [^JPEGReadWriter2].	type = 'jpeg' ifTrue: [^JPEGReadWriter2].	type = 'png' ifTrue: [^PNGReadWriter].	type = 'pcx' ifTrue: [^PCXReadWriter].	type = 'bmp' ifTrue: [^BMPReadWriter].	type = 'gif' ifTrue: [^GIFReadWriter].	^nil! !!True methodsFor: '*seaside2' stamp: 'ac 3/22/2005 20:23'!yesNoString	^ 'Yes'! !!Date class methodsFor: '*seaside2-squeak' stamp: 'ab 7/10/2003 11:29'!newDay: dayNumber monthNumber: monthNumber year: yearNumber	^ self newDay: dayNumber month: monthNumber year: yearNumber! !!Number methodsFor: '*seaside2' stamp: 'mb 3/23/2006 07:34'!convertSeasideString: aString	^ aString asNumber! !!Number methodsFor: '*seaside2' stamp: 'mb 5/20/2006 10:01'!em	^ self printString , 'em'! !!Number methodsFor: '*seaside2' stamp: 'mb 5/20/2006 10:01'!px	^ self printString , 'px'! !!Dictionary methodsFor: '*seaside2' stamp: 'ab 10/1/2002 13:48'!inspectorFields	^ self! !!Seaside2Info class methodsFor: 'as yet unclassified' stamp: 'avi 3/24/2004 12:19'!initialize	[self new register] on: MessageNotUnderstood do: ["must be an old version of PackageInfo"]! !!Seaside2Info methodsFor: 'as yet unclassified' stamp: 'ab 10/26/2002 15:41'!packageName	^ 'Seaside2'! !!Seaside2Info methodsFor: 'as yet unclassified' stamp: 'cwp 4/25/2004 18:40'!systemCategoryPrefix	^ 'Seaside'! !!SeasideAddonVWInfo class methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:30'!addonName	self subclassResponsibility! !!SeasideAddonVWInfo class methodsFor: 'actions' stamp: 'mb 10/6/2006 19:30'!fileOutVW5	(Smalltalk classNamed: #VW5PackageExporter)		ifNotNilDo: [ :class | 			class 				fileOutPackage: self default 				on: (FileStream forceNewFileNamed: self addonName , 'VW5.st') ]! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:31'!addonName	^self class addonName! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:31'!externalName	^ self addonName! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:31'!ignoredCategories	^ #('Platform')! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:32'!includesSystemCategory: aString	^ (aString beginsWith: self addonName , '-') 		and: [(self ignoredCategories includes: (aString copyAfter: $-)) not]! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:32'!isYourClassExtension: aString	^ (self category: aString asLowercase matches: '*' , self addonName asLowercase)		and: [(aString endsWith: 'squeak') not]! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:33'!name	^ self addonName! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:33'!namespace	^ 'Seaside'! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:33'!needsNamespace	^false! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:33'!packageName	^ self addonName , 'VW'! !!SeasideAddonVWInfo methodsFor: 'accessing' stamp: 'mb 10/6/2006 19:34'!versionString	| ancestor |	ancestor := (MCPackage named: self name) workingCopy ancestry ancestors first.	^ancestor name , '.mcz      ' , ancestor date printString, ' ', ancestor time printString ! !!SeasideVWInfo class methodsFor: 'as yet unclassified' stamp: 'ab 5/31/2003 17:00'!fileOutVW3	VW3PackageExporter fileOutPackage: self default on: (FileStream forceNewFileNamed: 'SeasideVW3.st')! !!SeasideVWInfo class methodsFor: 'as yet unclassified' stamp: 'ab 5/31/2003 17:00'!fileOutVW5	VW5PackageExporter fileOutPackage: self default on: (FileStream forceNewFileNamed: 'SeasideVW5.st')! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'ab 6/14/2003 17:46'!externalName	^ 'Seaside'! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'mb 3/21/2006 17:40'!ignoredCategories	^ #('Platform' 'Base-Connections' 'Rendering-Buttons' 'Components-Tools-Squeak' 'Utilities-Squeak')! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'avi 3/20/2004 17:55'!includesSystemCategory: aString	^ (aString beginsWith: 'Seaside-') and: [(self ignoredCategories includes: (aString copyAfter: $-)) not]! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'ab 5/28/2003 23:13'!isYourClassExtension: aString	^ (self category: aString asLowercase matches: '*seaside2')		and: [(aString endsWith: 'squeak') not]! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'mb 5/30/2006 13:52'!name	^ 'Seaside2'! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'mb 11/27/2005 10:17'!needsNamespace	^true! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'mb 5/30/2006 13:52'!packageName	^ 'SeasideVW'! !!SeasideVWInfo methodsFor: 'as yet unclassified' stamp: 'mb 5/30/2006 13:59'!versionString	| ancestor |	ancestor _ (MCPackage named: self name) workingCopy ancestry ancestors first.	^ancestor name , '.mcz      ' , ancestor date printString, ' ', ancestor time printString ! !!Fraction methodsFor: '*seaside2' stamp: 'mb 11/27/2005 10:11'!asSeasideString	^ self asFloat displayString! !!Fraction methodsFor: '*seaside2' stamp: 'mb 3/23/2006 07:37'!convertSeasideString: aString	^ aString = self asSeasideString ifTrue: [self] ifFalse:[ aString asNumber]! !!WADynamicVariable class methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 14:12'!defaultValue	^ nil! !!WADynamicVariable class methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 14:13'!use: anObject during: aBlock	^ aBlock		on: self		do: [:n | n resume: anObject]! !!WADynamicVariable class methodsFor: 'as yet unclassified' stamp: 'avi 4/27/2004 14:25'!value	^ self raiseSignal! !!WADynamicVariable methodsFor: 'as yet unclassified' stamp: 'avi 3/29/2004 14:12'!defaultAction	self resume: self class defaultValue! !!WAValidationNotification commentStamp: 'cds 7/25/2005 10:17' prior: 0!I am signaled to indicate that a validation has occurred.  See: Object>>validationError:, WAComponent>>validateWith: and WAValidationDecoration.!!JPEGReadWriter2 methodsFor: '*seaside2-squeak' stamp: 'mb 6/12/2006 13:58' prior: 22478899!nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag	"Encode the given Form on my stream with the given settings. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	buffer _ ByteArray new: sourceForm width * sourceForm height + 1024.	byteCount _ self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: progressiveFlag		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	stream next: byteCount putAll: buffer startingAt: 1.	self close.! !!PositionableStream methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 10:47'!asMIMEDocument	^self asMIMEDocumentType: 'text/plain'! !!PositionableStream methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 10:54'!asMIMEDocumentType: mimeType	^MIMELocalFileDocument contentType: mimeType contentStream:  self! !!PositionableStream methodsFor: '*seaside2-squeak' stamp: 'ab 7/11/2003 00:10'!upToAndSkipThroughAll: aCollection	^ self upToAll: aCollection! !!Integer methodsFor: '*seaside2' stamp: 'mbany 4/14/2005 12:09'!printStringAsCents	^ '$', (self // 100) displayString, '.', (self \\ 100) asTwoCharacterString! !!ContextPart methodsFor: '*seaside2-squeak' stamp: 'avi 5/22/2004 12:57'!homeReceiver	^ self home receiver! !!ContextPart methodsFor: '*seaside2-squeak' stamp: 'avi 4/24/2004 12:27'!localAt: aNumber	^ self at: aNumber! !!ContextPart methodsFor: '*seaside2-squeak' stamp: 'avi 4/24/2004 12:27'!localAt: aNumber put: anObject	^ self at: aNumber put: anObject! !!ContextPart methodsFor: '*seaside2-squeak' stamp: 'avi 4/24/2004 12:27'!localSize	^ self size! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:45'!entryPoint	^ WADispatcher default! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:45'!handleRequest: aRequest	^ (self entryPoint handlerForRequest: aRequest) handleRequest: aRequest! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:38'!parseFields: aString	| dict key value start end eqSignPos more |	dict _ Dictionary new.	aString isEmptyOrNil ifTrue: [^dict].	more _ true.	start _ 1.	[end _ aString indexOf: $& startingAt: start.	end == 0		ifTrue: [end _ aString size. more _ false]		ifFalse: [end _ end - 1].	eqSignPos _ aString indexOf: $= startingAt: start.	(eqSignPos > end or: [eqSignPos == 0])		ifTrue: [key _ (key _ aString copyFrom: start to: end) unescapePercents.			value _ '']		ifFalse: [key _ (key _ aString copyFrom: start to: eqSignPos-1) unescapePercents.			value _ (value _ aString copyFrom: eqSignPos+1 to: end) unescapePercents].	dict at: key put: value.	start _ end + 2.	more] whileTrue.	^dict! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:04'!readHeadersFrom: aStream	| headers key |	headers _ Dictionary new.	[(key _ (aStream upTo: Character lf)) = 'end'] whileFalse:		[headers at: key put: (aStream upTo: Character lf)].	^ headers! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:25'!serve: aSocket	| stream |	stream _ SocketStream on: aSocket.	[aSocket isConnected] whileTrue: [self serveOn: stream]! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'pmm 10/2/2006 21:10'!serveOn: aStream	| headers request response content method url query fields |	headers := self readHeadersFrom: aStream.		headers at: 'Content-Length' ifPresent:		[:cl |		content := aStream next: cl asInteger].		method := headers at: 'method'.	url := (headers at: 'url') copyUpTo: $?.	query := (headers at: 'url') copyAfter: $?.		fields := method asLowercase = 'get'		ifTrue: [ self parseFields: query ]		ifFalse: [ self parseFields: content ].			request := WARequest				method: method				url: url				headers: headers				fields: fields				cookies: Dictionary new.	response := self handleRequest: request.	self writeResponse: response on: aStream.	aStream flush! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/10/2005 14:33'!writeKey: keyString value: valueString on: aStream	aStream nextPutAll: keyString displayString; nextPut: Character lf.	aStream nextPutAll: valueString displayString; nextPut: Character lf! !!WAModLisp methodsFor: 'as yet unclassified' stamp: 'avi 5/5/2005 13:30'!writeResponse: aResponse on: aStream	self writeKey: 'Status' value: aResponse status on: aStream.	self writeKey: 'Content-Type' value: aResponse contentType on: aStream.	aResponse headers keysAndValuesDo:		[:k :v |		self writeKey: k value: v on: aStream].	self writeKey: 'Content-Length' value: aResponse contents size on: aStream.	self writeKey: 'Keep-Socket' value: 1 on: aStream.	aStream nextPutAll: 'end'; nextPut: Character lf.	aStream nextPutAll: aResponse contents contents! !!UndefinedObject methodsFor: '*seaside2' stamp: 'mb 11/27/2005 10:20'!asSeasideString	^ ''! !!UndefinedObject methodsFor: '*seaside2' stamp: 'mb 3/23/2006 07:36'!convertSeasideString: aString	^ aString = '' ifTrue: [nil] ifFalse: [aString]! !!UndefinedObject methodsFor: '*seaside2' stamp: 'ab 11/11/2002 12:06'!renderOn: html! !!Collection methodsFor: '*seaside2' stamp: 'ab 10/1/2002 13:47'!inspectorFields	|i|	i _ 0.	^ self asArray collect: [:each | i _ i + 1. i -> each]! !!Collection methodsFor: '*seaside2' stamp: 'lr 3/8/2006 08:43'!renderOn: html	self do: [ :each | each renderOn: html ]! !!False methodsFor: '*seaside2' stamp: 'ac 3/22/2005 20:23'!yesNoString	^ 'No'! !!HttpRequest methodsFor: '*seaside2-squeak' stamp: 'mb 2/27/2006 08:31' prior: 33786662!parseCookies: aString 	"PRIVATE: Parse a string in the format:  	Cookie: NAME1=OPAQUE_STRING1; NAME2=OPAQUE_STRING2 ..."	| dict |	dict := Dictionary new.	(aString findTokens: ';') do: 			[:pairStr | 			| pair |			pair := pairStr findTokens: '='.			pair size > 0 				ifTrue: 					[| key value |					key := pair first withBlanksTrimmed asSymbol.					value := pair size > 1 						ifTrue:							[pair second withBlanksTrimmed]						ifFalse:							[nil].					(dict includesKey: key) ifTrue: [self halt].					dict at: key put: value]				ifFalse: 					["self log: 'Cookie invalid pair format: ''' , pairStr , ''''"					]].	^dict! !!Parser methodsFor: '*seaside2-override-squeak' stamp: 'mb 10/18/2006 16:21' prior: 26560862!interactive	"This is to disable pop-up dialogs when an unknown variable is defined in a method"	^ (requestor == nil		or: [requestor isKindOf: SyntaxError]			or: [requestor isKindOf: WABrowser]) not! !!Exception class methodsFor: '*seaside2-squeak' stamp: 'ab 7/10/2003 11:42'!raiseSignal	^ self signal! !!Exception class methodsFor: '*seaside2-squeak' stamp: 'mb 3/23/2006 17:53'!raiseSignal: aString	^ self signal: aString! !!Exception methodsFor: '*seaside2-squeak' stamp: 'ab 3/28/2003 17:36'!reactivateHandler   handlerContext ifNotNil: [handlerContext tempAt: 3 put: true].! !!ByteArray methodsFor: '*seaside2' stamp: 'mb 6/2/2006 10:46'!asMIMEDocument	^self asMIMEDocumentType: 'application/octet-stream'! !!ByteArray methodsFor: '*seaside2' stamp: 'mb 6/2/2006 10:53'!asMIMEDocumentType: mimeType	^SeasidePlatformSupport mimeDocumentClass contentType: mimeType content: self! !!ByteArray methodsFor: '*seaside2' stamp: 'mb 9/22/2006 12:17'!renderOn: aRenderer	aRenderer text: self! !!WAExternalID class methodsFor: 'as yet unclassified' stamp: 'ab 5/28/2003 23:34'!defaultSize	^ 8! !!WAExternalID class methodsFor: 'as yet unclassified' stamp: 'pmm 10/2/2006 21:31'!fromString: aString	| id |	id := self new: aString size.	aString withIndexDo: [ :each :index |		id at: index put: each asInteger].	^ id! !!WAExternalID class methodsFor: 'class initialization' stamp: 'mb 11/27/2005 17:19'!initialize	"WAExternalID initialize"	GeneratorMutex _ Semaphore forMutualExclusion.	SeasidePlatformSupport addToStartUpList: self.	self startUp.! !!WAExternalID class methodsFor: 'as yet unclassified' stamp: 'ab 5/28/2003 23:53'!new	^ self new: self defaultSize! !!WAExternalID class methodsFor: 'as yet unclassified' stamp: 'pmm 11/2/2005 23:19'!new: aNumber	^ (self basicNew: aNumber) initialize! !!WAExternalID class methodsFor: 'class initialization' stamp: 'al 6/29/2005 09:08'!startUp	Generator _ Random new.! !!WAExternalID methodsFor: 'private' stamp: 'lr 5/3/2006 09:40'!initialize	GeneratorMutex critical:		[1 to: self size do: [:i | self at: i put: ((($a to: $z), ($A to: $Z)) atRandom: Generator) asInteger]]! !!WAExternalID methodsFor: 'private' stamp: 'ab 5/29/2003 00:00'!printOn: stream	self do: [:i | stream nextPut: (Character value: i)]! !!Morph methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 10:47'!asMIMEDocument	^self imageForm asMIMEDocument! !!Morph methodsFor: '*seaside2-squeak' stamp: 'mb 6/2/2006 10:53'!asMIMEDocumentType: mimeType	^self imageForm asMIMEDocumentType: mimeType! !"Seaside2"!!Color methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:43'!javascriptOn: aStream	aStream nextPut: $'; nextPut: $#.	aStream nextPutAll: (((self red * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	aStream nextPutAll: (((self green * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	aStream nextPutAll: (((self blue * 255) asInteger printStringBase: 16)		padded: #left to: 2 with: $0).	aStream nextPut: $'! !!SUDocument class methodsFor: 'instance-creation' stamp: 'lr 4/20/2006 16:02'!new	^ self basicNew initialize! !!SUDocument methodsFor: 'actions' stamp: 'lr 6/6/2006 10:53'!close	| session attributes |	session := WACurrentSession value.	(session isNil or: [ session onLoadScripts isEmpty ])		ifTrue: [ ^ self ].	attributes := WAHtmlAttributes new.	attributes at: 'type' put: 'text/javascript'.	self openTag: 'script' attributes: attributes.	session onLoadScripts		do: [ :each | self text: each displayString ]		separatedBy: [ self text: ';' ].	self closeTag: 'script'.	session clearLoadScripts! !!SUDocument methodsFor: 'initialization' stamp: 'lr 4/1/2006 11:43'!initialize	state := #body! !!Timespan methodsFor: '*scriptaculous' stamp: 'lr 4/19/2006 09:48'!javascriptOn: aStream	Dictionary new		at: #start put: self start;		at: #end put: self end;		javascriptOn: aStream! !!Point methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:48'!javascriptOn: aStream	aStream nextPut: $[; javascript: self x; nextPut: $,; javascript: self y; nextPut: $]! !!WAUrl methodsFor: '*scriptaculous' stamp: 'lr 6/6/2006 14:14'!javascriptOn: aStream	aStream print: self urlWithQueryString ! !!BlockContext methodsFor: '*scriptaculous' stamp: 'lr 5/12/2006 16:20'!asFunction	^ SUFunction on: nil block: self arguments: (Array new: self numArgs withAll: SUReference)! !!Stream methodsFor: '*scriptaculous' stamp: 'lr 5/10/2006 20:31'!arguments: aCollection	self nextPut: $(.	aCollection		do: [ :each | self javascript: each ]		separatedBy: [ self nextPut: $, ].	self nextPut: $)! !!Stream methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:45'!javascript: anObject	anObject javascriptOn: self! !!WARenderCanvas methodsFor: '*scriptaculous-controls' stamp: 'lr 5/15/2006 11:01'!autocompleter	^ SUAutocompleter on: self! !!WARenderCanvas methodsFor: '*scriptaculous-dragging' stamp: 'lr 5/10/2006 19:16'!draggable	^ SUDraggable on: self! !!WARenderCanvas methodsFor: '*scriptaculous-dragging' stamp: 'lr 5/10/2006 19:16'!droppable	^ SUDroppable on: self! !!WARenderCanvas methodsFor: '*scriptaculous' stamp: 'lr 5/10/2006 19:16'!effect	^ SUEffect on: self! !!WARenderCanvas methodsFor: '*scriptaculous' stamp: 'lr 5/10/2006 19:16'!element	^ SUElement on: self! !!WARenderCanvas methodsFor: '*scriptaculous-ajax' stamp: 'lr 4/20/2006 16:04'!evaluator	^ SUEvaluator on: self! !!WARenderCanvas methodsFor: '*scriptaculous-controls' stamp: 'lr 8/6/2006 13:43'!inPlaceEditor	^ SUInPlaceEditor on: self! !!WARenderCanvas methodsFor: '*scriptaculous' stamp: 'lr 5/3/2006 20:14'!javascript	^ SUScript on: self! !!WARenderCanvas methodsFor: '*scriptaculous-ajax' stamp: 'lr 4/20/2006 15:37'!periodical	^ SUPeriodical on: self! !!WARenderCanvas methodsFor: '*scriptaculous-ajax' stamp: 'lr 4/20/2006 15:37'!request	^ SURequest on: self! !!WARenderCanvas methodsFor: '*scriptaculous' stamp: 'lr 5/10/2006 19:16'!selector	^ SUSelector on: self! !!WARenderCanvas methodsFor: '*scriptaculous-controls' stamp: 'lr 5/15/2006 13:38'!slider	^ SUSlider on: self! !!WARenderCanvas methodsFor: '*scriptaculous-dragging' stamp: 'lr 5/10/2006 19:16'!sortable	^ SUSortable on: self! !!WARenderCanvas methodsFor: '*scriptaculous-ajax' stamp: 'lr 4/20/2006 15:37'!updater	^ SUUpdater on: self! !!String methodsFor: '*scriptaculous' stamp: 'lr 4/21/2006 02:43'!javascriptOn: aStream	SUStream encode: self to: aStream! !!DateAndTime methodsFor: '*scriptaculous' stamp: 'lr 4/19/2006 10:06'!javascriptOn: aStream	aStream nextPutAll: 'new Date('.	#( year monthIndex dayOfMonth hour minute second )		do: [ :each | aStream print: (self perform: each) ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $)! !!SUObjectTest methodsFor: 'utilties' stamp: 'lr 6/30/2006 19:52'!assert: anObject equals: aString	self 		assert: anObject asJavascript = aString		description: anObject printString , ' expected to be ' , aString printString		resumable: true! !!SUObjectTest methodsFor: 'accessing' stamp: 'lr 5/15/2006 14:50'!function	^ SUFunction on: self! !!SUObjectTest methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:53'!mock	^ SUObjectMock on: self! !!SUObjectTest methodsFor: 'accessing' stamp: 'lr 5/2/2006 12:03'!script	^ SUScript on: self! !!SUObjectTest methodsFor: 'accessing' stamp: 'lr 4/21/2006 02:44'!stream	^ SUStream new! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:03'!testArray	self assert: #(1 2 3) equals: '[1,2,3]'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:04'!testAssociation	self assert: ('a' -> 'b') equals: '''a=b'''.	self assert: ('a' -> 1) equals: '''a=''+1'.	self assert: ('a' -> nil) equals: '''a'''! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 7/12/2006 12:13'!testCharacter	self assert: (Character value: 0) equals: '''\0'''.	self assert: Character lf equals: '''\n'''.	self assert: $a equals: '''a'''! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:04'!testColor	self assert: Color red equals: '''#FF0000'''! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:04'!testDateAndTime	self assert: (DateAndTime year: 1980 month: 6 day: 11 hour: 12 minute: 45 second: 23) equals: 'new Date(1980,6,11,12,45,23)'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:00'!testDecorationAccess	| mock |	mock := self mock access: 'foo'.	self assert: mock equals: 'mock.foo'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationAfter	| mock |	mock := self mock after: (self stream nextPutAll: 'after').	self assert: mock equals: 'mock;after'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:18'!testDecorationAlias	| mock |	mock := self mock.	mock alias: 'foo'.	self assert: mock equals: 'foo'.	mock alias: 'bar'; call: 'zork'.	self assert: mock equals: 'bar.zork()'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationApply	| mock |	mock := self mock apply: #().	self assert: mock equals: 'mock()'.	mock := self mock apply: #(1).	self assert: mock equals: 'mock(1)'.	mock := self mock apply: #(1 true).	self assert: mock equals: 'mock(1,true)'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 7/6/2006 16:31'!testDecorationAssignLocalTo	| mock |	mock := self mock assignLocalTo: 'x'.	self assert: mock equals: 'var x=mock'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 7/6/2006 16:31'!testDecorationAssignTo	| mock |	mock := self mock assignTo: 'x'.	self assert: mock equals: 'x=mock'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationBefore	| mock |	mock := self mock before: (self stream nextPutAll: 'before').	self assert: mock equals: 'before;mock'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationCall	| mock |	mock := self mock call: 'foo'.	self assert: mock equals: 'mock.foo()'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationCallArgument	| mock |	mock := self mock call: 'foo' argument: 1.	self assert: mock equals: 'mock.foo(1)'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:01'!testDecorationCallArguments	| mock |	mock := self mock call: 'foo' arguments: #( 'bar' 1 ).	self assert: mock equals: 'mock.foo(''bar'',1)'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:02'!testDecorationCondition	| mock |	mock := self mock condition: true.	self assert: mock equals: 'if(true){mock}'.	mock := self mock condition: false.	self assert: mock equals: 'if(false){mock}'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:02'!testDecorationConfirm	| mock |	mock := self mock confirm: 'Sure?'.	self assert: mock equals: 'if(confirm(''Sure?'')){mock}'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:02'!testDecorationCreate	| mock |	mock := self mock create.	self assert: mock equals: 'new mock'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 8/23/2006 14:56'!testDecorationEvery	| mock |	mock := self mock.	mock every: 123.	self assert: mock equals: 'PeriodicalExecuter(function(){mock},123)'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:02'!testDecorationOrder	| mock |	mock := self mock before: 1; after: 2.	self assert: mock equals: '1;mock;2'.	mock := self mock after: 2; before: 1.	self assert: mock equals: '1;mock;2'.	mock := self mock after: 1; condition: true.	self assert: mock equals: 'if(true){mock;1}'.	mock := self mock condition: false; after: 1. 	self assert: mock equals: 'if(false){mock};1'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:02'!testDecorationProperty	| mock |	mock := self mock property: 'foo'.	self assert: mock equals: 'mock[''foo'']'.	mock := self mock property: 123.	self assert: mock equals: 'mock[123]'! !!SUObjectTest methodsFor: 'testing-decoration' stamp: 'lr 5/18/2006 09:03'!testDecorationReturn	| mock |	mock := self mock return: 1.	self assert: mock equals: 'mock;return 1'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 4/21/2006 02:51'!testDictionary	self assert: (#('{1:2,3:4}' '{3:4,1:2}') includes: (Dictionary new at: 1 put: 2; at: 3 put: 4; yourself) asJavascript)! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:04'!testDuration	self assert: (Duration seconds: 123) equals: '123'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/18/2006 09:16'!testEffect	self 		assert: SUEffect new 		equals: 'Effect.toggle(this)'.	self 		assert: (SUEffect new id: 'foo'; fps: 24) 		equals: 'Effect.toggle(''foo'',{fps:24})'.	self		assert: (SUEffect new id: 'bar'; duration: 2; shake)		equals: 'new Effect.Shake(''bar'',{duration:2})'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/18/2006 09:14'!testEffectMove	self 		assert: (SUEffect new move: 1 @ 2)		equals: 'new Effect.Move(this,1,2)'.	self 		assert: (SUEffect new id: 'foo'; duration: 1; move: 3 @ 5)		equals: 'new Effect.Move(''foo'',3,5,{duration:1})'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/12/2006 15:50'!testEffectOpacitiy	self		assert: (SUEffect new opacity)		equals: 'new Effect.Opacity(this)'.	self		assert: (SUEffect new opacity; id: 'foo'; duration: 1)		equals: 'new Effect.Opacity(''foo'',{duration:1})'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/12/2006 15:49'!testEffectParallel	self 		assert: (SUEffect new parallel: (Array with: SUEffect new fade with: SUEffect new slideUp))		equals: 'new Effect.Parallel([new Effect.Fade(this),new Effect.SlideUp(this)])'.	self 		assert: (SUEffect new fps: 12; parallel: (Array with: SUEffect new fade with: SUEffect new slideUp))		equals: 'new Effect.Parallel([new Effect.Fade(this),new Effect.SlideUp(this)],{fps:12})'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/12/2006 15:49'!testEffectScale	self 		assert: (SUEffect new scale: 50)		equals: 'new Effect.Scale(this,50)'.	self 		assert: (SUEffect new id: 'foo'; duration: 1; scale: 25)		equals: 'new Effect.Scale(''foo'',25,{duration:1})'! !!SUObjectTest methodsFor: 'testing-effect' stamp: 'lr 5/18/2006 09:14'!testEffectToggle	self 		assert: SUEffect new toggleAppear 		equals: 'Effect.toggle(this,''Appear'')'.	self 		assert: (SUEffect new id: 'foo'; toggleSlide)		equals: 'Effect.toggle(''foo'',''Slide'')'.	self		assert: (SUEffect new fps: 15; toggleBlind)		equals: 'Effect.toggle(this,''Blind'',{fps:15})'! !!SUObjectTest methodsFor: 'testing-element' stamp: 'lr 5/18/2006 09:25'!testElementDisplaying	| element |	element := SUElement new hide.	self assert: element equals: 'Element.hide(this)'.	element := SUElement new id: 'foo'; show.	self assert: element equals: 'Element.show(''foo'')'.		element := SUElement new toggle.	self assert: element equals: 'Element.toggle(this)'.		element := SUElement new id: 'bar'; visible.	self assert: element equals: 'Element.visible(''bar'')'! !!SUObjectTest methodsFor: 'testing-element' stamp: 'lr 5/18/2006 09:25'!testElementModifying	| element |	element := SUElement new remove.	self assert: element equals: 'Element.remove(this)'.	element := SUElement new id: 'foo'; update: 'bar'.	self assert: element equals: 'Element.update(''foo'',''bar'')'.		element := SUElement new replace: 'zork'.	self assert: element equals: 'Element.replace(this,''zork'')'! !!SUObjectTest methodsFor: 'testing-element' stamp: 'lr 5/18/2006 09:25'!testElementStyling	| element |	element := SUElement new id: 'foo'; addClassName: 'bar'.	self assert: element equals: 'Element.addClassName(''foo'',''bar'')'.	element := SUElement new classNames.	self assert: element equals: 'Element.classNames(this)'.	element := SUElement new id: 'foo'; hasClassName: 'bar'.	self assert: element equals: 'Element.hasClassName(''foo'',''bar'')'.	element := SUElement new removeClassName: 'bar'.	self assert: element equals: 'Element.removeClassName(this,''bar'')'! !!SUObjectTest methodsFor: 'testing-event' stamp: 'lr 5/16/2006 08:09'!testEventActions	| event |	event := SUEvent new stop.	self assert: event equals: 'Event.stop(event)'.	event := SUEvent new event: 'foo'; on: 'click' do: SUElement new toggle.	self assert: event equals: 'Event.observe(''foo'',''click'',function(){Element.toggle(this)})'! !!SUObjectTest methodsFor: 'testing-event' stamp: 'lr 5/18/2006 09:16'!testEventQuerying	| event |	event := SUEvent new element.	self assert: event equals: 'Event.element(event)'.	event := SUEvent new event: 'bar'; x.	self assert: event equals: 'Event.pointerX(''bar'')'.	event := SUEvent new y.	self assert: event equals: 'Event.pointerY(event)'! !!SUObjectTest methodsFor: 'testing-element' stamp: 'lr 5/18/2006 09:26'!testForm	| element |	element := SUForm new id: 'foo'; enable.	self assert: element equals: 'Form.enable(''foo'')'.		element := SUForm new disable.	self assert: element equals: 'Form.disable(this)'.		element := SUForm new focus.	self assert: element equals: 'Form.focusFirstElement(this)'.		element := SUForm new reset.	self assert: element equals: 'Form.reset(this)'.		element := SUForm new serialize.	self assert: element equals: 'Form.serialize(this)'! !!SUObjectTest methodsFor: 'testing-insertion' stamp: 'lr 5/16/2006 08:10'!testInsertion	| element |	element := SUInsertion top.	self assert: element equals: 'Insertion.Top'.		element := SUInsertion bottom.	self assert: element equals: 'Insertion.Bottom'.		element := SUInsertion before.	self assert: element equals: 'Insertion.Before'.		element := SUInsertion after.	self assert: element equals: 'Insertion.After'! !!SUObjectTest methodsFor: 'testing-insertion' stamp: 'lr 5/18/2006 09:16'!testInsertionBasic	| element |	element := SUInsertion new top; with: 'foo'.	self assert: element equals: 'new Insertion.Top(this,''foo'')'.		element := SUInsertion new bottom; id: 'bar'; with: 'foo'.	self assert: element equals: 'new Insertion.Bottom(''bar'',''foo'')'.		element := SUInsertion new before; with: 'foo'.	self assert: element equals: 'new Insertion.Before(this,''foo'')'.		element := SUInsertion new after; id: 'bar'; with: 'foo'.	self assert: element equals: 'new Insertion.After(''bar'',''foo'')'! !!SUObjectTest methodsFor: 'testing-insertion' stamp: 'lr 5/18/2006 09:17'!testInsertionShort	| element |	element := SUInsertion new top: 'foo'.	self assert: element equals: 'new Insertion.Top(this,''foo'')'.		element := SUInsertion new id: 'bar'; bottom: 'foo'.	self assert: element equals: 'new Insertion.Bottom(''bar'',''foo'')'.		element := SUInsertion new before: 'foo'.	self assert: element equals: 'new Insertion.Before(this,''foo'')'.		element := SUInsertion new id: 'bar'; after: 'foo'.	self assert: element equals: 'new Insertion.After(''bar'',''foo'')'! !!SUObjectTest methodsFor: 'testing-element' stamp: 'lr 5/18/2006 09:26'!testInsertionWith	| element |	element := SUInsertion new id: 'foo'; top: 'bar'.	self assert: element equals: 'new Insertion.Top(''foo'',''bar'')'.		element := SUInsertion new bottom: 'bar'.	self assert: element equals: 'new Insertion.Bottom(this,''bar'')'.		element := SUInsertion new id: 'foo'; before: 'bar'.	self assert: element equals: 'new Insertion.Before(''foo'',''bar'')'.		element := SUInsertion new after: 'bar'.	self assert: element equals: 'new Insertion.After(this,''bar'')'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:04'!testInterval	self assert: (1 to: 2) equals: '$R(1,2)'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testJoin	self assert: (SUJoin join: #( 'a' 'b' ) with: '&') equals: '[''a'',''b''].join(''&'')'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testLiteral	self assert: true equals: 'true'.	self assert: false equals: 'false'.	self assert: nil equals: 'null'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testNumber	self assert: 123 equals: '123'.	self assert: 12.3 equals: '12.3'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 7/12/2006 12:13'!testPoint	self assert: 1 @ 2 equals: '[1,2]'! !!SUObjectTest methodsFor: 'testing-script' stamp: 'lr 8/4/2006 08:48'!testScriptAdd	| script |	script := self script 		add: (self stream nextPutAll: 'foo');		yourself.	self assert: script equals: 'foo'.	script := self script 		add: (self stream nextPutAll: 'foo');		add: (self stream nextPutAll: 'bar');		yourself.	self assert: script equals: 'foo;bar'! !!SUObjectTest methodsFor: 'testing-script' stamp: 'lr 8/29/2006 08:49'!testScriptConcatenate	| script |	script := SUElement new.	self assert: script equals: 'Element.toggle(this)'.		script := script , (self stream nextPutAll: 'foo').	self assert: script equals: 'Element.toggle(this);foo'.		script := script , (self stream nextPutAll: 'bar').	self assert: script equals: 'Element.toggle(this);foo;bar'.	 	script := script , (self script , (self stream nextPutAll: 'zork')).	self assert: script equals: 'Element.toggle(this);foo;bar;zork'! !!SUObjectTest methodsFor: 'testing-script' stamp: 'lr 6/30/2006 19:49'!testScriptEmpty	self assert: self script equals: ''! !!SUObjectTest methodsFor: 'testing-script' stamp: 'lr 5/15/2006 14:55'!testScriptReturn	| function |	function := self function.	function add: (self stream nextPutAll: 'foo').	function add: (self stream nextPutAll: 'bar').	function add: (self stream nextPutAll: 'baz').	self assert: function equals: 'function(){foo;bar;baz}'.	function := self function return: true.	function add: (self stream nextPutAll: 'foo').	function add: (self stream nextPutAll: 'bar').	function add: (self stream nextPutAll: 'baz').	self assert: function equals: 'function(){foo;bar;return baz}'! !!SUObjectTest methodsFor: 'testing-selector' stamp: 'lr 5/18/2006 09:26'!testSelector	| selector |	selector := SUSelector new name: '*'.	self assert: selector equals: '$$(''*'')'.	selector := SUSelector new name: 'foo'; name: 'bar'.	self assert: selector equals: '$$(''foo'',''bar'')'! !!SUObjectTest methodsFor: 'testing-selector' stamp: 'lr 6/30/2006 20:10'!testSelectorCollect	| selector |	selector := SUSelector new		name: 'div.foo';		collect: [ :each | each element visible ].	self assert: selector equals: '$$(''div.foo'').collect(function(){return Element.visible(arguments[0])})'! !!SUObjectTest methodsFor: 'testing-selector' stamp: 'lr 6/30/2006 20:10'!testSelectorDo	| selector |	selector := SUSelector new		name: 'div.foo';		do: [ :each | each element show ].	self assert: selector equals: '$$(''div.foo'').each(function(){Element.show(arguments[0])})'! !!SUObjectTest methodsFor: 'testing-selector' stamp: 'lr 6/30/2006 20:09'!testSelectorInvoke	| selector |	selector := SUSelector new		name: 'div.foo';		invoke: 'addClassName' arguments: #( 'bar' ).	self assert: selector equals: '$$(''div.foo'').invoke(''addClassName'',''bar'')'! !!SUObjectTest methodsFor: 'testing-selector' stamp: 'lr 6/30/2006 20:09'!testSelectorPluck	| selector |	selector := SUSelector new		name: 'div.foo';		pluck: 'id'.	self assert: selector equals: '$$(''div.foo'').pluck(''id'')'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamArgument	| stream |	stream := self stream argument: 1.	self assert: stream contents = '(1)'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamArguments	| stream |	stream := self stream arguments: #(1 2 3).	self assert: stream contents = '(1,2,3)'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamCopy	| stream1 stream2 |	stream1 := self stream nextPutAll: 'foo'.	stream2 := stream1 copy nextPutAll: 'bar'.	stream1 nextPutAll: 'zork'.	self assert: stream1 contents = 'foozork'.	self assert: stream2 contents = 'foobar'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamJavascript	| stream |	stream := self stream javascript: #(1 2).	self assert: stream contents = '[1,2]'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamNew	self assert: self stream contents = ''! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamNextPut	| stream |	stream := self stream nextPut: $f.	self assert: stream contents = 'f'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 4/21/2006 02:44'!testStreamNextPutAll	| stream |	stream := self stream nextPutAll: 'foo'.	self assert: stream contents = 'foo'! !!SUObjectTest methodsFor: 'testing-stream' stamp: 'lr 5/18/2006 09:26'!testStreamOn	self assert: (SUStream on: 'foo') equals: 'foo'! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testStringBasic	self assert: 'abc' equals: '''abc'''.	self assert: '123' equals: '''123'''! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testStringEscaping	self assert: '''' equals: '''\'''''.	self assert: '"' equals: '''"'''.	self assert: '\' equals: '''\\'''! !!SUObjectTest methodsFor: 'testing-convertion' stamp: 'lr 5/18/2006 09:05'!testStringSpecial	self assert: (String with: Character cr) equals: '''\r'''.	self assert: (String with: Character lf) equals: '''\n'''.	self assert: (String with: Character tab) equals: '''\t'''! !!SUAllTests class methodsFor: 'initialization' stamp: 'rjl 6/9/2006 01:25'!canBeRoot	^true! !!SUAllTests class methodsFor: 'initialization' stamp: 'lr 5/10/2006 19:50'!initialize	(self registerAsApplication: 'scriptaculous')		libraries add: SULibrary! !!SUAllTests methodsFor: 'accessing' stamp: 'lr 3/12/2006 15:29'!children	^ selected collect: [ :each | each value ]! !!SUAllTests methodsFor: 'initialization' stamp: 'lr 8/6/2006 13:44'!initialize	super initialize.	tabs := OrderedCollection new		add: 'Welcome' -> (Array			with: 'Welcome' -> SUWelcomeTest new			with: 'Counter' -> SUCounterTest new);		add: 'Ajax' -> (Array			with: 'Updater' -> SUUpdaterTest new			with: 'Periodical' -> SUPeriodicalTest new			with: 'Evaluator' -> SUEvaluatorTest new);		add: 'Form' -> (Array			with: 'Elements' -> SUFormTest new);		add: 'Controls' -> (Array			with: 'Autocompleter' -> SUAutocompleterTest new			with: 'In Place Editor' -> SUInPlaceEditorTest new			with: 'Slider' -> SUSliderTest new);		add: 'Drag & Drop' -> (Array			with: 'Drag & Drop' -> SUDragDropTest new			with: 'Sortable' -> SUSortableTest new			with: 'Tree' -> SUTreeTest new);		add: 'Effects' -> (Array			with: 'Effects' -> SUEffectsTest new			with: 'Toggles' -> SUTogglesTest new);		yourself.	selected := tabs first value! !!SUAllTests methodsFor: 'rendering' stamp: 'lr 4/19/2006 00:06'!renderChildrenOn: html	html div id: 'content'; with: [		selected do: [ :each |			html heading: each key.			html paragraph; render: each value.			each value showSource ifTrue: [				html paragraph: [					html anchor						callback: [ self lightbox: (SUClassBrowser new setClass: each value class) ];						with: 'View Source' ] ].			html paragraph ] ]! !!SUAllTests methodsFor: 'rendering' stamp: 'lr 3/12/2006 16:03'!renderContentOn: html	self renderHeaderOn: html.	self renderMenuOn: html.	self renderChildrenOn: html! !!SUAllTests methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderHeaderOn: html	html div id: 'header'; with: [		html image			id: 'logo';			url: (self resources addToPath: 'logo.gif');			altText: self title ]! !!SUAllTests methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderMenuOn: html	html unorderedList id: 'menu'; with: [		tabs do: [ :each |			html listItem: [				html anchor					class: (selected = each value						ifTrue: [ 'active' ]);					callback: [ selected := each value ];					with: each key ] ] ]! !!SUAllTests methodsFor: 'accessing' stamp: 'lr 3/13/2006 20:59'!title	^ 'Seaside - script.aculo.us'! !!SUAllTests methodsFor: 'updating' stamp: 'lr 3/30/2006 22:10'!updateRoot: aHtmlRoot	super updateRoot: aHtmlRoot.	aHtmlRoot		title: self title;		linkToStyle: (self resources addToPath: 'style.css')! !!SUClassBrowser methodsFor: 'accessing' stamp: 'lr 3/12/2006 14:12'!categories	^ class organization categories asSortedCollection! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 8/7/2006 09:50'!renderCategoriesOn: html	html select		size: 5;		id: 'categoryList';		selected: category;		list: self categories;		callback: [ :value | self setCategory: value ];		onChange: (html updater			id: 'selectors';			evalScripts: true;			triggerFormElement: 'categoryList';			on: #renderSelectorsOn: of: self;			onSuccess: (html updater				id: 'source';				on: #renderSourceOn: of: self))! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 4/19/2006 08:16'!renderCloseOn: html	html form: [		html submitButton 			callback: [ self answer ];			text: 'close' ]! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 4/19/2006 08:16'!renderContentOn: html	html div id: 'categories'; with: [ self renderCategoriesOn: html ].	html div id: 'selectors'; with: [ self renderSelectorsOn: html ].	html div class: 'clear'.	html div id: 'source'; with: [ self renderSourceOn: html ].	html div class: 'clear'.	html div id: 'close'; with: [ self renderCloseOn: html ]! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 8/7/2006 09:47'!renderSelectorsOn: html	html select		size: 5;		id: 'selectorList';		selected: selector;		list: self selectors;		callback: [ :value | self setSelector: value ];		onChange: (html updater			id: 'source';			triggerFormElement: 'selectorList';			on: #renderSourceOn: of: self)! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 4/19/2006 07:54'!renderSourceOn: html	| source |	source := (class sourceCodeAt: selector ifAbsent: [ ^ self ])		asString readStream.	html strong: class name , '>>' , source nextLine; break.	[ source atEnd ] whileFalse: [		[ source peek = Character tab ]			whileTrue: [ html space; space; space. source next ].		html render: source nextLine; break ]! !!SUClassBrowser methodsFor: 'accessing' stamp: 'lr 3/12/2006 14:12'!selectors	^ (category isNil		ifTrue: [ class selectors ]		ifFalse: [ class organization listAtCategoryNamed: category ])			asSortedCollection! !!SUClassBrowser methodsFor: 'initialization' stamp: 'lr 3/12/2006 14:20'!setCategory: aSymbol	category := aSymbol.	self setSelector: (self selectors isEmpty		ifFalse: [ self selectors first ])! !!SUClassBrowser methodsFor: 'initialization' stamp: 'lr 3/13/2006 22:15'!setClass: aClass	class := aClass.	self setCategory: #rendering.	self setSelector: #renderContentOn:! !!SUClassBrowser methodsFor: 'initialization' stamp: 'lr 3/12/2006 14:07'!setSelector: aSymbol	selector := aSymbol! !!SUClassBrowser methodsFor: 'rendering' stamp: 'lr 4/19/2006 20:23'!style	^ 'div#lightbox {	background: url(http://scriptaculous.seasidehosting.st/resources/demo.gif) repeat white;	border: 1px solid #e8a400;	padding: 1em;	width: 640px;}div#categories, div#selectors {	float: left;	width: 50%;}div.clear {	clear: both;	height: 1em;}div#categories select, div#selectors select {	width: 100%;}div#source {	padding: 1em;	border: 1px solid #dddddd;	background-color: #f5f5f5;	font: 12px Lucida Sans Typewriter, Courier, monospace;}div#close {	text-align: center;}'! !!SUComponent methodsFor: 'accessing' stamp: 'lr 3/30/2006 22:10'!rendererClass	^ WARenderCanvas! !!SUComponent methodsFor: 'accessing-url' stamp: 'lr 3/13/2006 20:59'!resources	^ WAUrl new hostname: 'scriptaculous.seasidehosting.st'; addToPath: 'resources'! !!SUComponent methodsFor: 'accessing-url' stamp: 'lr 3/12/2006 13:04'!scriptaculous	^ WAUrl new hostname: 'script.aculo.us'! !!SUComponent methodsFor: 'accessing-url' stamp: 'lr 3/12/2006 13:04'!seaside	^ WAUrl new hostname: 'seaside.st'! !!SUAutocompleterTest methodsFor: 'rendering' stamp: 'lr 5/15/2006 11:35'!renderContentOn: html	html paragraph: 'Start to type a Smalltalk class-name:'.	html paragraph: [		html textInput			id: 'text';			value: text;			callback: [ :value | text := value ].		html div			class: 'autocomplete';			script: (html autocompleter				element: 'text';				onSelected: (html request					triggerFormElement: 'text');				on: #renderListOn: of: self) ]! !!SUAutocompleterTest methodsFor: 'rendering' stamp: 'pmm 9/21/2006 18:11'!renderListOn: html	| items |	items := Smalltalk allClasses select: [ :each | each name includesSubstring: text caseSensitive: false ].	html unorderedList list: (items first: (items size min: 10))! !!SUAutocompleterTest methodsFor: 'rendering' stamp: 'lr 4/9/2006 00:19'!style	^ 'input#text {	width: 250px;}div.autocomplete {	position: absolute;	background-color: white;	border: 1px solid #888;	margin: 0px;	padding: 0px;	z-index: 1000;}div.autocomplete ul, div.autocomplete ul li {	list-style-type: none;	line-height: 1.7;	margin: 0px;	padding: 0px;}div.autocomplete ul li.selected {	background-color: #ffb;}'! !!SUCounterTest methodsFor: 'actions' stamp: 'lr 3/12/2006 13:23'!decrease	count := count - 1! !!SUCounterTest methodsFor: 'actions' stamp: 'lr 3/12/2006 13:23'!increase	count := count + 1! !!SUCounterTest methodsFor: 'initialization' stamp: 'lr 3/12/2006 13:23'!initialize	super initialize.	count := 0! !!SUCounterTest methodsFor: 'rendering' stamp: 'lr 6/28/2006 11:45'!renderContentOn: html	| id |	id := html nextId.	html paragraph: [		html span			id: 'counter_' , id;			with: count.		html space.		html anchor			onClick: (html updater				id: 'counter_' , id;				callback: [ :render | self increase; renderCountOn: render ]);			with: '++'.		html space.		html anchor			onClick: (html updater				id: 'counter_' , id;				callback: [ :render | self decrease; renderCountOn: render ]);			with: '--' ]! !!SUCounterTest methodsFor: 'rendering' stamp: 'lr 3/12/2006 13:26'!renderCountOn: html	html render: count! !!SUDragDropTest methodsFor: 'accessing' stamp: 'lr 3/7/2006 16:52'!cart	^ cart ifNil: [ cart := WAStoreCart new ]! !!SUDragDropTest methodsFor: 'accessing' stamp: 'lr 3/7/2006 16:52'!inventory	^ WAStoreInventory default! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderCartItemsOn: html	self cart hasItems		ifFalse: [ ^ html text: 'Drop items here to add them to your cart.' ].	self cart countsAndItems do: [ :assoc |		html div			class: 'cart-item';			passenger: assoc value;			script: (html draggable revert: true);			with: [				html render: assoc value.				assoc key > 1					ifTrue: [ html text: ' ('; render: assoc key; text: ')' ] ] ]! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 10:52'!renderCartOn: html	html div		id: 'cart';		script: (html droppable			accept: 'inventory-item';			hoverclass: 'hover';			onDrop: (html updater				id: 'cart';				evalScripts: true;				triggerPassenger: [ :value | self cart add: value ];				callback: [ :renderer | self renderCartItemsOn: renderer ]));		with: [ self renderCartItemsOn: html ]! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderContentOn: html	self		renderInventoryOn: html;		renderCartOn: html;		renderTrashOn: html! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderInventoryOn: html	html div id: 'inventory'; with: [		self inventory allItems			do: [ :each |				html span					passenger: each;					class: 'inventory-item';					script: (html draggable revert: true);					with: each ]			separatedBy: [ html text: ', ' ] ]! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 5/15/2006 15:25'!renderTrashOn: html	html div		id: 'trash';		script: (html droppable			accept: 'cart-item';			hoverclass: 'hover';			onDrop: (html updater				id: 'cart';				evalScripts: true;				triggerPassenger: [ :value | self cart remove: value ];				callback: [ :renderer | self renderCartItemsOn: renderer ];				onSuccess: (html effect id: 'cart'; shake)));		with: 'Drop items here to remove them from the cart.'! !!SUDragDropTest methodsFor: 'rendering' stamp: 'lr 3/13/2006 23:38'!style	^ 'div#inventory {	margin: 1em;	cursor: move;}div#cart {	margin: 1em;	padding: 1em;	border: 1px dashed #e8a400;	cursor: move;}div#trash {	margin: 1em;	padding: 1em;	border: 1px dashed #c5dea1;	cursor: move;}.hover {	background-color: #eeeeee;}'! !!SUEffectsTest methodsFor: 'accessing' stamp: 'lr 3/28/2006 23:07'!effects	^ #( appear fade puff blindDown blindUp switchOff slideDown slideUp dropOut shake pulsate squish fold grow shrink highlight )! !!SUEffectsTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 13:59'!renderContentOn: html	html paragraph: [		self effects do: [ :each |			html anchor				onClick: (html effect					id: 'effect';					perform: each);				text: (self labelForSelector: each) ]			separatedBy: [ html text: ', ' ] ].	self renderBox: 'effect' on: html! !!SUEvaluatorTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 08:52'!renderContentOn: html	html paragraph: 'CSS Selector:'.	html paragraph: [		html form: [			html textInput				id: 'selector';				value: (selector ifNil: [ 'h1' ]);				callback: [ :value | selector := value ].			html submitButton				onClick: (html evaluator					triggerFormElement: 'selector';					on: #renderEvaluatorOn: of: self;					return: false);				text: 'highlight' ] ]! !!SUEvaluatorTest methodsFor: 'rendering' stamp: 'lr 5/17/2006 11:13'!renderEvaluatorOn: aScript	aScript selector		name: selector;		do: [ :each | each effect highlight ]! !!SUFormTest methodsFor: 'initialization' stamp: 'lr 3/28/2006 22:19'!initialize	super initialize.	textInput := 'Text Input'.	textArea := 'Text Area'.	checkBox := false.	radioButton := 1.	selectList := 1.	mutliSelectList := 1 to: 2! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 5/2/2006 10:14'!renderCheckBoxOn: html	self		renderLabel: 'Check-Box'		control: [ :fid :mid |			html checkbox				value: checkBox;				callback: [ :value | checkBox := value ];				onClick: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: checkBox ]) ]		model: checkBox		on: html! !!SUFormTest methodsFor: 'rendering' stamp: 'lr 3/28/2006 22:19'!renderContentOn: html	self renderTextInputOn: html.	self renderTextAreaOn: html.	self renderCheckBoxOn: html.	self renderRadioButtonOn: html.	self renderSelectListOn: html.	self renderMultiSelectListOn: html! !!SUFormTest methodsFor: 'rendering-utilities' stamp: 'lr 6/6/2006 10:53'!renderLabel: aString control: aBlock model: anObject on: html	| fid mid |	fid := mid := nil.	html div class: 'row'; with: [		html div class: 'label'; with: aString.		html div class: 'control'; with: [			html form				id: (fid := html nextId);				with: [ aBlock value: fid value: (mid := html nextId) ] ].		html div class: 'model'; id: mid; with: anObject.		html div class: 'clear' ]! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 5/2/2006 10:15'!renderMultiSelectListOn: html	self		renderLabel: 'Multi-Select-List'		control: [ :fid :mid |			html select				size: 3;				beMultiple;				list: (1 to: 9);				selected: mutliSelectList;				callback: [ :value | mutliSelectList := value ];				onChange: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: mutliSelectList ]) ]		model: mutliSelectList		on: html! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 5/2/2006 10:14'!renderRadioButtonOn: html	self		renderLabel: 'Radio-Button'		control: [ :fid :mid |			html radioGroup: [ :group |				1 to: 3 do: [ :each |					html label: [						html radioButton							group: group;							selected: radioButton = each;							callback: [ radioButton := each ];							onClick: (html updater								id: mid;								triggerForm: fid;								callback: [ :r | r render: radioButton ]).					 		html text: each ].					html break ] ] ]		model: radioButton		on: html! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 5/2/2006 10:15'!renderSelectListOn: html	self		renderLabel: 'Select-List'		control: [ :fid :mid |			html select				list: (1 to: 9);				selected: selectList;				callback: [ :value | selectList := value ];				onChange: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: selectList ]) ]		model: selectList		on: html! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 9/6/2006 13:52'!renderTextAreaOn: html	self		renderLabel: 'Text-Area'		control: [ :fid :mid |			html textArea				value: textArea;				callback: [ :value | textArea := value ].			html space.			html submitButton				onClick: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: textArea ];					return: false);				text: 'Submit' ]		model: textArea		on: html! !!SUFormTest methodsFor: 'rendering-elements' stamp: 'lr 9/6/2006 13:51'!renderTextInputOn: html	self		renderLabel: 'Text-Input'		control: [ :fid :mid |			html textInput				value: textInput;				callback: [ :value | textInput := value ].			html space.			html submitButton				onClick: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: textInput ];					return: false);				text: 'Submit' ]		model: textInput		on: html! !!SUFormTest methodsFor: 'rendering' stamp: 'lr 3/28/2006 22:38'!style	^ 'div.row { margin: 5px; }div.label { float: left; width: 20%; font-weight: bold; }div.control { float: left; width: 50% }div.model { float: left; width: 30%; }div.clear { clear: both; }select { width: 100px; }'! !!SUFunctionalTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderBox: aString on: html	html div id: aString; class: 'box'; with: [		html div class: 'header'.		html div			class: 'content';			with: 'Smalltalk Enterprise Aubergines' ]! !!SUFunctionalTest methodsFor: 'testing' stamp: 'lr 3/12/2006 15:36'!showSource	^ true! !!SUInPlaceEditorTest methodsFor: 'initialization' stamp: 'lr 8/7/2006 09:04'!initialize	super initialize.	text := 'Click me, edit me.'! !!SUInPlaceEditorTest methodsFor: 'rendering' stamp: 'lr 8/7/2006 09:04'!renderContentOn: html	html paragraph		script: (html inPlaceEditor			cancelLink: false;			triggerInPlaceEditor: [ :value | text := value ];			callback: [ :r | r render: text ]);		with: text! !!SUPeriodicalTest methodsFor: 'rendering' stamp: 'lr 5/15/2006 11:09'!renderContentOn: html	html paragraph		script: (html periodical 			frequency: 5 seconds;			on: #renderTimeOn: of: self);		with: [ self renderTimeOn: html ]! !!SUPeriodicalTest methodsFor: 'rendering' stamp: 'lr 3/12/2006 16:00'!renderTimeOn: html	html render: Time now! !!SUSliderTest methodsFor: 'initialization' stamp: 'lr 3/20/2006 19:49'!initialize	super initialize.	position := 50! !!SUSliderTest methodsFor: 'rendering' stamp: 'lr 8/7/2006 09:30'!renderContentOn: html	html div id: 'track'; with: [ html div id: 'handle' ].	html paragraph id: 'position'; with: position.	html script: (html slider		handleId: 'handle';		trackId: 'track';		value: position;		range: (0 to: 100);		onChange: (html updater			id: 'position';			triggerSliderCallback: [ :value | position := value asInteger ];			callback: [ :renderer | renderer render: position ]))! !!SUSliderTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 20:20'!style	^ 'div#track {	width: 200px; height: 5px;	background-color: #eee;}div#handle {	width: 5px; height: 10px;	background-color: #e8a400;	cursor: move;}'! !!SUSortableTest methodsFor: 'private' stamp: 'lr 4/2/2006 12:30'!classForObject: anObject	^ anObject species = SmallInteger		ifFalse: [ 'orange' ]		ifTrue: [ 'green' ]! !!SUSortableTest methodsFor: 'private' stamp: 'lr 3/12/2006 17:04'!labelForObject: anObject	^ anObject class name , ': ' , anObject displayString! !!SUSortableTest methodsFor: 'accessing' stamp: 'lr 5/2/2006 11:26'!left	^ left ifNil: [ left := $a to: $b ]! !!SUSortableTest methodsFor: 'accessing' stamp: 'lr 3/17/2006 13:50'!left: aCollection	left := aCollection! !!SUSortableTest methodsFor: 'rendering' stamp: 'lr 4/7/2006 14:22'!renderContentOn: html	html div		style: 'float: left;';		with: [ self renderList: #left titled: 'Left List' on: html ].	html div		style: 'float: left;';		with: [ self renderList: #right titled: 'Right List' on: html ].	html div		style: 'clear: both'! !!SUSortableTest methodsFor: 'rendering' stamp: 'lr 3/17/2006 14:00'!renderList: aSelector titled: aString on: html	html heading: aString level: 3.	html paragraph		id: aSelector , 'status';		with: [ self renderListModel: aSelector on: html ].	self renderListItems: aSelector on: html! !!SUSortableTest methodsFor: 'rendering' stamp: 'lr 5/15/2006 15:39'!renderListItems: aSelector on: html	html unorderedList		id: aSelector asString;		style: 'width: 200px; min-height: 50px;';		script: (html sortable			constraint: false;			dropOnEmpty: true;			containment: #( left right );			onUpdate: (html updater				id: aSelector , 'status';				triggerSortable: aSelector asString					callback: [ :values | self perform: aSelector asMutator with: values ];				callback: [ :renderer | self renderListModel: aSelector on: renderer ]));		with: [			(self perform: aSelector) do: [ :each |				html listItem					passenger: each;					class: (self classForObject: each);					with: (self labelForObject: each) ] ]! !!SUSortableTest methodsFor: 'rendering' stamp: 'lr 3/30/2006 22:10'!renderListModel: aSelector on: html	html text: 'Model: '.	(self perform: aSelector)		do: [ :each | html render: each ]		separatedBy: [ html text: ', ' ]! !!SUSortableTest methodsFor: 'accessing' stamp: 'lr 5/2/2006 11:26'!right	^ right ifNil: [ right := 1 to: 2 ]! !!SUSortableTest methodsFor: 'accessing' stamp: 'lr 3/17/2006 13:50'!right: aCollection	right := aCollection! !!SUSortableTest methodsFor: 'rendering' stamp: 'lr 4/2/2006 12:31'!style	^ 'li.green, li.orange {	margin: 4px;	padding: 2px;  	cursor: move;}li.green {	background-color: #ecf3e1;  	border: 1px solid #c5dea1;}li.orange {	background-color: #fff4d8;  	border: 1px solid #e8a400;}'! !!SUTogglesTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 13:59'!renderContentOn: html	html paragraph: [		self toggles do: [ :each |			html anchor				onClick: (html effect					id: 'toggle';					perform: each);				text: (self labelForSelector: each) ]			separatedBy: [ html text: ', ' ] ].	self renderBox: 'toggle' on: html! !!SUTogglesTest methodsFor: 'accessing' stamp: 'lr 5/2/2006 13:59'!toggles	^ #( toggleAppear toggleBlind toggleSlide )! !!SUTreeTest methodsFor: 'private' stamp: 'lr 5/2/2006 11:38'!childrenOf: anObject	^ Array streamContents: [ :stream |		tree do: [ :each |			each key = anObject				ifTrue: [ stream nextPut: each value ] ] ]! !!SUTreeTest methodsFor: 'initialization' stamp: 'lr 5/2/2006 11:49'!initialize	super initialize.	tree := OrderedCollection new		add: nil -> 'Eukaryota';			add: 'Eukaryota' -> 'Opisthokonts';				add: 'Opisthokonts' -> 'Animalia';				add: 'Opisthokonts' -> 'Choanoflagellates';				add: 'Opisthokonts' -> 'Nucleariids';				add: 'Opisthokonts' -> 'Fungi';			add: 'Eukaryota' -> 'Amoebozoa';				add: 'Amoebozoa' -> 'Plantae';				add: 'Amoebozoa' -> 'Red algae';				add: 'Amoebozoa' -> 'Glaucophytes';			add: 'Eukaryota' -> 'Plants';				add: 'Plants' -> 'Cercozoa';				add: 'Plants' -> 'Foraminifera';				add: 'Plants' -> 'Polycystinea';				add: 'Plants' -> 'Acantharea';				add: 'Plants' -> 'Sticholonche';			add: 'Eukaryota' -> 'Rhizaria';		yourself! !!SUTreeTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 11:39'!renderChildren: aCollection on: html	aCollection do: [ :each |		html listItem			passenger: each;			with: [ self renderNode: each on: html ] ]! !!SUTreeTest methodsFor: 'rendering' stamp: 'lr 5/10/2006 22:45'!renderContentOn: html	html unorderedList		id: 'evolution';		script: (html sortable			create;			tree: true;			onUpdate: (html request				triggerTree: 'evolution'				callback: [ :values | tree := values ]));		with: [ self renderChildren: (self childrenOf: nil) on: html ]! !!SUTreeTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 11:39'!renderNode: anObject on: html	| children |	html text: anObject.	(children := self childrenOf: anObject) isEmpty ifFalse: [		html unorderedList: [ 			self renderChildren: children on: html ] ]! !!SUTreeTest methodsFor: 'rendering' stamp: 'lr 4/7/2006 01:08'!style	^ 'ul#evolution li {	list-style: none;	cursor: move;}'! !!SUUpdaterTest methodsFor: 'accessing' stamp: 'lr 5/2/2006 10:43'!insertions	^ Array with: SUInsertion before with: SUInsertion top with: SUInsertion bottom with: SUInsertion after! !!SUUpdaterTest methodsFor: 'rendering' stamp: 'lr 5/2/2006 10:40'!renderContentOn: html	html paragraph: [		self insertions do: [ :each |			html anchor				onClick: (html updater					id: 'element';					insertion: each;					on: #renderElementOn: of: self);				text: each.			html break ] ].	html paragraph: [		html div id: 'element'; with: 'Target Element' ]! !!SUUpdaterTest methodsFor: 'rendering' stamp: 'lr 4/3/2006 11:36'!renderElementOn: html	html div: Time now! !!SUUpdaterTest methodsFor: 'accessing' stamp: 'lr 4/3/2006 11:34'!style	^ '#element { background-color: #fff4d8; }'! !!SUWelcomeTest methodsFor: 'rendering' stamp: 'lr 4/19/2006 08:19'!renderContentOn: html	 html paragraph: [		html anchor url: self seaside; with: 'Seaside'.		html text: ' provides a complete integration of '.		html anchor url: self scriptaculous; with: 'script.aculo.us'.		html text: ', allowing the use of the library without having to write a single line of JavaScript code. Everything can be configured and plugged together using Smalltalk objects. Try by yourself, by clicking trough this functional test suite and by browsing the source-code.' ].	html heading: 'Seaside' level: 2.	html paragraph: [		html anchor url: self seaside; with: 'Seaside'.		html text: ' is a framework for developing sophisticated web applications in Smalltalk. It provides a layered set of abstractions over HTTP and HTML that let you build highly interactive web applications quickly, reusably and maintainably.' ].	html heading: 'script.aculo.us' level: 2.	html paragraph: [		html anchor url: self scriptaculous; with: 'script.aculo.us'.		html text: ' provides you with easy-to-use, compatible and, ultimately, totally cool JavaScript libraries to make your web sites and web applications fly, Web 2.0 style.' ]! !!SUWelcomeTest methodsFor: 'testing' stamp: 'lr 3/12/2006 15:36'!showSource	^ false! !!SULightboxTest class methodsFor: 'as yet unclassified' stamp: 'lr 6/13/2006 16:13'!initialize	(self registerAsApplication: 'tests/lightbox-dialog') libraries add: SULibrary! !!SULightboxTest methodsFor: 'as yet unclassified' stamp: 'mb 6/6/2006 14:52'!inform: aString	self lightbox: (WAFormDialog new addMessage: aString)! !!SULightboxTest methodsFor: 'as yet unclassified' stamp: 'mb 6/6/2006 16:02'!renderContentOn: html	html form		style: 'text-align: center';		with:			[html text: 'What is your favorite transportation system ?'.			3 timesRepeat:[html break].				html select				list:    #(Automobile Airplane Truck Boat Bicycle Horse Walking Swimming);				selected: value;				callback: [:v | value _ v].			3 timesRepeat:[html break].				html submitButton callback: [self inform: value]].! !!SULightboxTest methodsFor: 'as yet unclassified' stamp: 'mb 6/6/2006 14:49'!rendererClass	^WARenderCanvas! !!SULightboxTest methodsFor: 'as yet unclassified' stamp: 'mb 6/6/2006 15:01'!style	^'div#lightbox {	background: white;	border: 1px solid #0000e8;	padding: 2em;	width: 10em;	text-align: center;}div#overlay {	background-color: black;	filter: alpha(opacity=30);	-moz-opacity: 0.3;	opacity: 0.3;}'! !!SUAccordion class methodsFor: 'examples' stamp: 'lr 8/6/2006 14:58'!example	^ self new		maxVisible: 2;		add: SUCounterTest new label: 'Counter 1';		add: SUCounterTest new label: 'Counter 2';		add: SUCounterTest new label: 'Counter 3';		yourself! !!SUAccordion methodsFor: 'accessing' stamp: 'lr 6/28/2006 11:47'!children	^ visible! !!SUAccordion methodsFor: 'accessing' stamp: 'lr 6/28/2006 10:27'!cssClass	^ 'accordion'! !!SUAccordion methodsFor: 'actions' stamp: 'lr 6/28/2006 11:46'!hide: aComponent	self visible remove: aComponent ifAbsent: [ ^ self ]! !!SUAccordion methodsFor: 'initialization' stamp: 'lr 6/28/2006 11:46'!initialize	super initialize.	visible := OrderedCollection new! !!SUAccordion methodsFor: 'accessing' stamp: 'lr 6/28/2006 09:56'!maxVisible	^ maxVisible! !!SUAccordion methodsFor: 'accessing' stamp: 'lr 6/28/2006 09:57'!maxVisible: anInteger	maxVisible := anInteger! !!SUAccordion methodsFor: 'rendering' stamp: 'lr 8/4/2006 09:31'!renderNavigationOn: html	| active |	elements withIndexDo: [ :assoc :index |		active := self visible includes: assoc value.		html div			class: 'head'; 			id: (self uid: 'head' at: index);			class: (active ifTrue: [ 'active' ]);			with: [				html anchor					onClick: (html evaluator 						callback: [ :script | self scriptToggle: assoc value on: script ];						return: false);					callback: [ self toggle: assoc value ];					with: assoc key ].		html div			id: (self uid: 'body' at: index);			class: 'body'; class: (active ifTrue: [ 'active' ]);			with: (active ifTrue: [ assoc value ]) ]! !!SUAccordion methodsFor: 'scripting' stamp: 'lr 6/28/2006 11:43'!scriptHide: aComponent  on: aScript	| index |	index := self findIndex: aComponent ifAbsent: [ ^ self ].	aScript element		id: (self uid: 'body' at: index);		update: String new.	aScript element		id: (self uid: 'body' at: index);		removeClassName: 'active'.	aScript element		id: (self uid: 'head' at: index);		removeClassName: 'active'! !!SUAccordion methodsFor: 'scripting' stamp: 'lr 8/7/2006 09:28'!scriptShow: aComponent on: aScript	| index |	index := self findIndex: aComponent ifAbsent: [ ^ self ].	aScript element		id: (self uid: 'body' at: index);		render: (elements at: index) value.	aScript element		id: (self uid: 'body' at: index);		addClassName: 'active'.	aScript element		id: (self uid: 'head' at: index);		addClassName: 'active'! !!SUAccordion methodsFor: 'scripting' stamp: 'lr 6/28/2006 11:48'!scriptToggle: aComponent on: aScript	self visible copy in: [ :previous |		self toggle: aComponent.		(previous difference: self visible)			do: [ :each | self scriptHide: each on: aScript ].		(self visible difference: previous)			do: [ :each | self scriptShow: each on: aScript ] ]! !!SUAccordion methodsFor: 'actions' stamp: 'lr 6/28/2006 11:46'!show: aComponent	self visible addLast: aComponent.	self maxVisible isNil ifFalse: [		[ self maxVisible < self visible size ]			whileTrue: [ self hide: self visible first ] ]! !!SUAccordion methodsFor: 'actions' stamp: 'lr 6/28/2006 11:46'!toggle: aComponent	(self visible includes: aComponent)		ifTrue: [ self hide: aComponent ]		ifFalse: [ self show: aComponent ]! !!SUAccordion methodsFor: 'accessing' stamp: 'lr 6/28/2006 11:46'!visible	^ visible! !!SUNavigation class methodsFor: 'class initialization' stamp: 'lr 8/6/2006 14:56'!initialize	(WAExampleBrowser registerAsApplication: 'examples/examplebrowser')		libraries add: SULibrary! !!SUNavigation methodsFor: 'public' stamp: 'lr 6/28/2006 09:14'!add: aComponent label: aString	elements add: aString -> aComponent! !!SUNavigation methodsFor: 'accessing' stamp: 'lr 6/28/2006 09:15'!cssClass	^ self subclassResponsability! !!SUNavigation methodsFor: 'private' stamp: 'lr 6/28/2006 11:57'!findIndex: aComponent ifAbsent: aBlock	| index |	index := elements findFirst: [ :each | each value = aComponent ].	index isZero ifTrue: [ aBlock value ].	^ index! !!SUNavigation methodsFor: 'initialization' stamp: 'lr 6/28/2006 12:14'!initialize	super initialize.	elements := OrderedCollection new! !!SUNavigation methodsFor: 'rendering' stamp: 'lr 6/28/2006 09:19'!renderContentOn: html	uid := html nextId.	html div 		class: self cssClass; 		with: [ self renderNavigationOn: html ]! !!SUNavigation methodsFor: 'rendering' stamp: 'lr 6/28/2006 09:19'!renderNavigationOn: html	self subclassResponsability! !!SUNavigation methodsFor: 'accessing' stamp: 'lr 6/15/2006 18:25'!rendererClass 	^ WARenderCanvas! !!SUNavigation methodsFor: 'private' stamp: 'lr 6/28/2006 09:20'!uid: aString at: anInteger	^ uid , '_' , aString , '_' , anInteger asString! !!SUTabPanel class methodsFor: 'examples' stamp: 'lr 8/6/2006 14:55'!example	^ self new		add: SUCounterTest new label: 'Counter 1';		add: SUCounterTest new label: 'Counter 2';		add: SUCounterTest new label: 'Counter 3';		yourself! !!SUTabPanel methodsFor: 'accessing' stamp: 'lr 6/28/2006 11:49'!children	^ Array with: self selected! !!SUTabPanel methodsFor: 'accessing' stamp: 'lr 6/28/2006 11:49'!cssClass	^ 'tabpanel'! !!SUTabPanel methodsFor: 'rendering' stamp: 'lr 6/28/2006 11:51'!renderNavigationOn: html	self renderTabsOn: html.	self renderPanelOn: html! !!SUTabPanel methodsFor: 'rendering' stamp: 'lr 6/28/2006 12:12'!renderPanelOn: html	html div 		id: (self uid: 'body' at: 0); 		class: 'body'; 		with: self selected! !!SUTabPanel methodsFor: 'rendering' stamp: 'lr 6/28/2006 12:02'!renderTabsOn: html	| active |	html unorderedList class: 'head'; with: [		elements withIndexDo: [ :assoc :index |			active := self selected = assoc value.			html listItem				id: (self uid: 'head' at: index);				class: (active ifTrue: [ 'active' ]);				with: [					html anchor						onClick: (html evaluator 							callback: [ :script | self scriptSelected: assoc value on: script ];							return: false);						callback: [ self selected: assoc value ];						with: assoc key ] ] ]! !!SUTabPanel methodsFor: 'scripting' stamp: 'lr 8/7/2006 09:29'!scriptSelected: aComponent on: aScript	aScript element		id: (self uid: 'head' at: (self 			findIndex: self selected 			ifAbsent: [ ]));		removeClassName: 'active'.	self selected: aComponent.	aScript element		id: (self uid: 'head' at: (self 			findIndex: self selected 			ifAbsent: [ ^ self ]));		addClassName: 'active'.	aScript element		id: (self uid: 'body' at: 0);		render: self selected! !!SUTabPanel methodsFor: 'accessing' stamp: 'lr 6/28/2006 11:49'!selected	^ selected ifNil: [ selected := elements first value ]! !!SUTabPanel methodsFor: 'accessing' stamp: 'lr 6/28/2006 12:07'!selected: aComponent	selected := aComponent! !!WAComponent methodsFor: '*scriptaculous' stamp: 'lr 4/19/2006 00:38'!lightbox: aComponent	^ AnswerContinuation currentDo: [ :cc | 		self 			show: aComponent 			onAnswer: cc			delegation: (SULightbox new				delegate: aComponent;				yourself) ]! !!WATagBrush methodsFor: '*scriptaculous' stamp: 'lr 4/7/2006 13:57'!passenger: anObject	self id: SUSortable passengerPrefix , (canvas context storePassenger: anObject)! !!WATagBrush methodsFor: '*scriptaculous' stamp: 'lr 6/29/2006 10:48'!script: aPrototype	aPrototype isNil 		ifTrue: [ ^ self ].	(aPrototype respondsTo: #id:)		ifTrue: [ aPrototype id: self ensureId ].	aPrototype session addLoadScript: aPrototype! !!UndefinedObject methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:44'!javascriptOn: aStream	aStream nextPutAll: 'null'! !!Dictionary methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:52'!javascriptOn: aStream	aStream nextPut: ${.	self associations 		do: [ :each | aStream nextPutAll: each key asString; nextPut: $:; javascript: each value ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $}! !!ScriptaculousVWInfo class methodsFor: 'actions' stamp: 'al 6/1/2006 16:41'!fileOutVW5	(Smalltalk classNamed: #VW5PackageExporter)		ifNotNilDo: [ :class | class fileOutPackage: self default on: (FileStream forceNewFileNamed: 'ScriptaculousVW5.st') ]! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:40'!externalName	^ 'Scriptaculous'! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:40'!ignoredCategories	^ #('Platform')! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:41'!includesSystemCategory: aString	^ (aString beginsWith: 'Scriptaculous-') and: [(self ignoredCategories includes: (aString copyAfter: $-)) not]! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:42'!isYourClassExtension: aString	^ (self category: aString asLowercase matches: '*scriptaculous')		and: [(aString endsWith: 'squeak') not]! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 5/30/2006 17:34'!name	^ 'Scriptaculous'! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:45'!namespace	^ 'Seaside'! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:42'!needsNamespace	^false! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 3/13/2006 13:42'!packageName	^ 'ScriptaculousVW'! !!ScriptaculousVWInfo methodsFor: 'accessing' stamp: 'mb 5/30/2006 17:33'!versionString	| ancestor |	ancestor _ (MCPackage named: self name) workingCopy ancestry ancestors first.	^ancestor name , '.mcz      ' , ancestor date printString, ' ', ancestor time printString ! !!Object methodsFor: '*scriptaculous' stamp: 'lr 5/15/2006 11:29'!asFunction	^ SUFunction new add: self; yourself! !!Object methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:49'!asJavascript	^ String streamContents: [ :stream | self javascriptOn: stream ]! !!Object methodsFor: '*scriptaculous-printing' stamp: 'lr 4/20/2006 21:10'!javascriptOn: aStream	self printOn: aStream! !!SUApply methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:49'!arguments	^ arguments! !!SUApply methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:49'!arguments: aCollection	arguments := aCollection! !!SUApply methodsFor: 'printing' stamp: 'lr 5/10/2006 21:23'!printContentOn: aStream	super printContentOn: aStream.	aStream arguments: self arguments! !!SUCreate methodsFor: 'printing' stamp: 'lr 5/10/2006 08:39'!printContentOn: aStream	aStream nextPutAll: 'new '.	super printContentOn: aStream! !!SUDecoration methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:09'!owner	^ owner! !!SUDecoration methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:09'!owner: anObject	owner := anObject! !!SUDecoration methodsFor: 'printing' stamp: 'lr 5/9/2006 20:34'!printContentOn: aStream	self owner printContentOn: aStream! !!SUExecuter commentStamp: 'lr 8/23/2006 14:44' prior: 0!SUElement new every: 1!!SUExecuter methodsFor: 'accessing' stamp: 'lr 8/23/2006 14:51'!callback	^ callback ifNil: [ callback := self defaultCallback ]! !!SUExecuter methodsFor: 'accessing' stamp: 'lr 8/23/2006 14:51'!callback: anObject	callback := anObject! !!SUExecuter methodsFor: 'private' stamp: 'lr 8/23/2006 14:57'!defaultArguments	^ Array with: self callback with: self frequency! !!SUExecuter methodsFor: 'private' stamp: 'lr 8/23/2006 14:52'!defaultCallback	| stream |	stream := SUStream new.	self owner printContentOn: stream.	^ stream asFunction! !!SUExecuter methodsFor: 'private' stamp: 'lr 8/23/2006 14:51'!defaultFrequency	^ 1 second! !!SUExecuter methodsFor: 'accessing' stamp: 'lr 8/23/2006 14:51'!frequency	^ frequency ifNil: [ frequency := self defaultFrequency ]! !!SUExecuter methodsFor: 'accessing' stamp: 'lr 8/23/2006 14:39'!frequency: anInteger	frequency := anInteger! !!SUExecuter methodsFor: 'printing' stamp: 'lr 8/23/2006 14:57'!printContentOn: aStream	aStream nextPutAll: 'PeriodicalExecuter'; arguments: self defaultArguments! !!SUAccess methodsFor: 'printing' stamp: 'lr 5/9/2006 20:48'!printContentOn: aStream	super printContentOn: aStream.	aStream nextPut: $.; nextPutAll: self name! !!SUAlias methodsFor: 'printing' stamp: 'lr 5/18/2006 08:22'!printContentOn: aStream	aStream nextPutAll: self name! !!SUAssign methodsFor: 'printing' stamp: 'lr 7/6/2006 16:27'!printContentOn: aStream	aStream nextPutAll: self name; nextPut: $=.	super printContentOn: aStream! !!SUAssignLocal methodsFor: 'printing' stamp: 'lr 7/6/2006 16:28'!printContentOn: aStream	aStream nextPutAll: 'var '.	super printContentOn: aStream! !!SUMember methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:46'!name	^ name! !!SUMember methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:46'!name: aString	name := aString! !!SUProperty methodsFor: 'printing' stamp: 'lr 5/9/2006 20:48'!printContentOn: aStream	super printContentOn: aStream.	aStream nextPut: $[; javascript: self name; nextPut: $]! !!SUAfter methodsFor: 'printing' stamp: 'lr 5/9/2006 20:29'!printContentOn: aStream	super printContentOn: aStream.	aStream nextPut: $;; javascript: self statement! !!SUBefore methodsFor: 'printing' stamp: 'lr 5/9/2006 20:29'!printContentOn: aStream	aStream javascript: self statement; nextPut: $;.	super printContentOn: aStream! !!SUCondition methodsFor: 'printing' stamp: 'lr 5/9/2006 20:29'!printContentOn: aStream	aStream nextPutAll: 'if('; javascript: self statement; nextPutAll: '){'.	super printContentOn: aStream.	aStream nextPut: $}! !!SUStatement class methodsFor: 'instance-creation' stamp: 'lr 5/9/2006 20:19'!on: anObject	^ self new statement: anObject! !!SUStatement methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:14'!statement	^ statement! !!SUStatement methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:14'!statement: anObject	statement := anObject! !!SUJoin class methodsFor: 'instance-creation' stamp: 'avi 9/27/2005 23:29'!join: aCollection with: aString	^ self new		collection: aCollection;		joiner: aString;		yourself! !!SUJoin methodsFor: 'adding' stamp: 'lr 3/30/2006 14:46'!add: anExpression	self collection add: anExpression! !!SUJoin methodsFor: 'accessing' stamp: 'avi 9/27/2005 23:40'!collection	^ collection! !!SUJoin methodsFor: 'accessing' stamp: 'lr 6/30/2006 19:33'!collection: aCollection	collection := aCollection! !!SUJoin methodsFor: 'accessing' stamp: 'avi 9/27/2005 23:40'!joiner	^ joiner! !!SUJoin methodsFor: 'accessing' stamp: 'lr 6/30/2006 19:33'!joiner: aString	joiner := aString! !!SUJoin methodsFor: 'printing' stamp: 'lr 4/21/2006 14:41'!printOn: aStream	aStream javascript: self collection; nextPutAll: '.join('; javascript: self joiner; nextPut: $)! !!SUObject class methodsFor: 'instance-creation' stamp: 'lr 5/10/2006 19:15'!new	^ self basicNew initialize! !!SUObject class methodsFor: 'instance-creation' stamp: 'lr 5/10/2006 19:15'!on: aCanvas	^ self new setCanvas: aCanvas! !!SUObject methodsFor: 'conveniance' stamp: 'lr 8/29/2006 08:47'!, anObject	^  (SUScript on: self canvas)		add: self;		add: anObject;		yourself! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 21:47'!access: aString	"Access the member aString."	self addDecoration: (SUAccess new name: aString)! !!SUObject methodsFor: 'adding' stamp: 'lr 5/10/2006 08:37'!addDecoration: aDecoration	aDecoration owner: decoration.	decoration := aDecoration! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 08:37'!after: anObject	"Call anObject directly after the receiver is evaluated."	self addDecoration: (SUAfter on: anObject)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/18/2006 09:18'!alias: aString	"Uses aString as an alias for the receiver."	self addDecoration: (SUAlias new name: aString)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 21:49'!apply: aCollection	"Apply aCollection of arguments."	self addDecoration: (SUApply new arguments: aCollection)! !!SUObject methodsFor: 'decorations' stamp: 'lr 7/6/2006 16:30'!assignLocalTo: aString	"Assign the receiver to a local variable aString."	self addDecoration: (SUAssignLocal new name: aString)! !!SUObject methodsFor: 'decorations' stamp: 'lr 7/6/2006 16:29'!assignTo: aString	"Assign the receiver to a global variable aString."	self addDecoration: (SUAssign new name: aString)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 08:37'!before: anObject	"Call anObject directly before the receiver is evaluated."	self addDecoration: (SUBefore on: anObject)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 08:37'!call: aString	"Call the method aString."	self call: aString arguments: #()! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 08:37'!call: aString argument: anObject	"Call the method aString with anObject as its argument."	self call: aString arguments: (Array with: anObject)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 21:46'!call: aString arguments: aCollection	"Call the method aString with aCollection as its arguments."	self access: aString; apply: aCollection! !!SUObject methodsFor: 'accessing' stamp: 'lr 5/10/2006 19:14'!canvas	^ canvas! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 08:43'!condition: anObject	"Treat anObject as a condition to the execution of the receiver."	self addDecoration: (SUCondition on: anObject)! !!SUObject methodsFor: 'conveniance' stamp: 'lr 5/10/2006 08:37'!confirm: anObject	self condition: (SUStream new nextPutAll: 'confirm'; argument: anObject)! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 22:05'!create	"Instantiate the receiver."	self addDecoration: SUCreate new! !!SUObject methodsFor: 'accessing' stamp: 'lr 5/10/2006 08:26'!decoration	^ decoration! !!SUObject methodsFor: 'decorations' stamp: 'lr 8/23/2006 14:43'!every: aDuration	"Execute the receiver every aDuration."	self addDecoration: (SUExecuter new frequency: aDuration)! !!SUObject methodsFor: 'initialization' stamp: 'lr 5/10/2006 19:08'!initialize	decoration := self! !!SUObject methodsFor: 'printing' stamp: 'lr 5/9/2006 20:34'!printContentOn: aStream	self subclassResponsibility! !!SUObject methodsFor: 'printing' stamp: 'lr 5/10/2006 08:26'!printOn: aStream	self decoration printContentOn: aStream! !!SUObject methodsFor: 'decorations' stamp: 'lr 5/10/2006 19:42'!property: aString	"Treat anObject as a condition to the execution of the receiver."	self addDecoration: (SUProperty new name: aString)! !!SUObject methodsFor: 'utilities' stamp: 'lr 8/4/2006 08:59'!render: aBlock on: aStream	| previous document html |	previous := canvas context document.	document := SUDocument new 		stream: aStream.	canvas context document: document.	html := canvas species		context: canvas context		callbacks: canvas callbacks.	html render: aBlock; flush.	document close.	canvas context document: previous! !!SUObject methodsFor: 'conveniance' stamp: 'lr 5/10/2006 19:35'!return: anObject	self after: (SUStream new nextPutAll: 'return '; javascript: anObject)! !!SUObject methodsFor: 'accessing' stamp: 'lr 5/10/2006 08:26'!session	^ WACurrentSession value! !!SUObject methodsFor: 'initialization' stamp: 'lr 5/10/2006 19:14'!setCanvas: aCanvas	canvas := aCanvas! !!SUObjectMock methodsFor: 'printing' stamp: 'lr 5/10/2006 19:25'!printContentOn: aStream	aStream nextPutAll: 'mock'! !!SUAjax methodsFor: 'parameters' stamp: 'lr 4/20/2006 15:02'!addParameter: anObject	self parameters add: anObject! !!SUAjax methodsFor: 'parameters' stamp: 'lr 4/20/2006 15:02'!addParameters: aCollection	self parameters addAll: aCollection associations! !!SUAjax methodsFor: 'options' stamp: 'lr 4/20/2006 15:43'!asynchronous: aBoolean	self optionAt: 'asynchronous' put: aBoolean! !!SUAjax methodsFor: 'callbacks' stamp: 'lr 5/15/2006 11:37'!callback: aBlock	"Register aBlock as a primary callback of the receiver. It only makes sense to have a single primary callback registered per instance. Depending on the actual evaluation strategy, see #handle:on:, aBlock will be evaluated with a renderer as its first argument."	callback := aBlock fixTemps! !!SUAjax methodsFor: 'callbacks' stamp: 'lr 5/8/2006 08:36'!callback: aBlock value: anObject	"Register aBlock as a secondary callback. anObject is interpreted as JavaScript on the client-side, the result will be sent back to the server and passed into aBlock as its first element. There is no limit in the number of secondary callbacks to be defined with one receiver."	self addParameter: (self canvas callbacks registerCallback: aBlock) -> anObject! !!SUAjax methodsFor: 'options' stamp: 'lr 4/20/2006 15:43'!contentType: aString	self optionAt: 'contentType' put: aString! !!SUAjax methodsFor: 'private' stamp: 'lr 5/10/2006 21:33'!defaultArguments	^ (Array with: self url) , super defaultArguments! !!SUAjax methodsFor: 'private' stamp: 'lr 5/10/2006 21:25'!defaultResponse	^ WAResponse new doNotCache! !!SUAjax methodsFor: 'initialization' stamp: 'lr 5/10/2006 22:06'!initialize	super initialize.	self create! !!SUAjax methodsFor: 'options' stamp: 'lr 4/20/2006 15:43'!method: aString	self optionAt: 'method' put: aString! !!SUAjax methodsFor: 'callbacks' stamp: 'lr 4/20/2006 15:47'!on: aSelector of: anObject	self callback: (MessageSend receiver: anObject selector: aSelector)! !!SUAjax methodsFor: 'callbacks' stamp: 'lr 4/20/2006 15:33'!on: aSelector of: anObject value: anotherObject	self callback: (MessageSend receiver: anObject selector: aSelector) value: anotherObject! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:29'!onComplete: anObject	"Called when the XMLHttpRequest is complete (fires after success/failure, if they are present)."	self optionAt: 'onComplete' put: anObject asFunction! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:28'!onFailure: anObject	"Called when the XMLHttpRequest is completed, and the HTTP status code is not in the 2XX range."	self optionAt: 'onFailure' put: anObject asFunction! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:29'!onInteractive: anObject	"Called when the user can interact with the remote document, even though it has not finished loading."	self optionAt: 'onInteractive' put: anObject asFunction! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:29'!onLoaded: anObject	"Called when the browser has finished loading the remote document."	self optionAt: 'onLoaded' put: anObject asFunction! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:29'!onLoading: anObject	"Called when the remote document is being loaded with data by the browser."	self optionAt: 'onLoading' put: anObject asFunction! !!SUAjax methodsFor: 'events' stamp: 'lr 4/29/2006 18:29'!onSuccess: anObject	"Called when the XMLHttpRequest is completed, and the HTTP status code is in the 2XX range."	self optionAt: 'onSuccess' put: anObject asFunction! !!SUAjax methodsFor: 'parameters' stamp: 'lr 4/20/2006 15:21'!parameters	^ (self options at: 'parameters' ifAbsentPut: [ SUJoin join: OrderedCollection new with: '&' ])		collection! !!SUAjax methodsFor: 'processing' stamp: 'lr 5/15/2006 11:38'!process	| response |	response := self defaultResponse.	self processOn: response stream.	self session returnResponse: response! !!SUAjax methodsFor: 'processing' stamp: 'lr 5/15/2006 11:39'!processOn: aStream	self subclassResponsibility! !!SUAjax methodsFor: 'initialization' stamp: 'lr 5/15/2006 11:39'!setCanvas: aCanvas	super setCanvas: aCanvas.	self url: aCanvas context actionUrl urlString.	self addParameters: aCanvas context actionUrl parameters.	self addParameter: (aCanvas callbacks registerActionCallback: [ self process ])! !!SUAjax methodsFor: 'triggers' stamp: 'lr 5/15/2006 11:47'!triggerForm: aString	"When triggering a form we don't want seaside related keys in the URL, as they are already present as hidden-fields within all the forms."	self parameters copy do: [ :each |		(each isVariableBinding and: [ each key beginsWith: '_' ])			ifTrue: [ self parameters remove: each ] ].	self addParameter: (SUForm new		id: aString;		serialize)! !!SUAjax methodsFor: 'triggers' stamp: 'lr 4/20/2006 15:02'!triggerFormElement: aString	"Serializing form elements does not always work as one would expect, since Seaside sometimes depends on extra hidden-fields to be triggered to be able to perform your callback-block. When encountering a problem (check-boxes, multi-select lists) try using #triggerForm: instead."	self addParameter: (SUFormElement new		id: aString;		serialize)! !!SUAjax methodsFor: 'triggers' stamp: 'lr 5/10/2006 22:44'!triggerPassenger: aBlock	self		callback: [ :value |			aBlock value: (canvas context callbacks				at: value ifAbsent: [ nil ]) ]		value: (SUStream new			nextPutAll: 'arguments[0].id.match';			argument: SUSortable passengerRegexp;			nextPutAll: '[1]')! !!SUAjax methodsFor: 'triggers' stamp: 'lr 4/22/2006 19:28'!triggerSliderCallback: aBlock	self		callback: [ :value | aBlock value: value asNumber ]		value: (SUStream on: 'arguments[0]')! !!SUAjax methodsFor: 'triggers' stamp: 'lr 6/7/2006 09:42'!triggerSortable: aString callback: aBlock	self		callback: [ :value |			aBlock value: ((value findTokens: $,) collect: [ :each |				canvas context callbacks at: each ifAbsent: [ nil ] ]) ]		value: (SUSortable new id: aString; sequence)! !!SUAjax methodsFor: 'triggers' stamp: 'lr 5/2/2006 11:45'!triggerTree: aString callback: aBlock	self		callback: [ :values |			aBlock value: (Array streamContents: [ :stream |				(values findTokens: ',') do: [ :token |					| pair |					pair := (token findTokens: ':')						collect: [ :each | canvas context callbacks at: each ifAbsent: [ nil ] ].					pair size = 2						ifTrue: [ stream nextPut: pair first -> pair second ] ] ]) ]		value: (SUSortable new id: aString; tree)! !!SUAjax methodsFor: 'accessing' stamp: 'lr 4/20/2006 15:03'!url	^ url! !!SUAjax methodsFor: 'accessing' stamp: 'lr 4/20/2006 15:06'!url: aString	url := aString! !!SUEvaluator methodsFor: 'private' stamp: 'lr 5/12/2006 15:22'!defaultResponse	^ super defaultResponse contentType: 'text/javascript'! !!SUEvaluator methodsFor: 'processing' stamp: 'lr 6/7/2006 09:22'!processOn: aStream	| script |	script := SUScript on: canvas.	callback ifNotNil: [ callback value: script ].	self session onLoadScripts		do: [ :each | script add: each ].	self session clearLoadScripts.	aStream javascript: script! !!SURequest methodsFor: 'private' stamp: 'lr 5/10/2006 21:25'!defaultPrototype	^ 'Ajax.Request'! !!SURequest methodsFor: 'processing' stamp: 'lr 6/7/2006 09:17'!process	[ super process ] on: Error do: [ :err | err defaultAction ]! !!SURequest methodsFor: 'processing' stamp: 'lr 6/7/2006 09:21'!processOn: aStream	callback ifNotNil: [ callback value ]! !!SUAutocompleter methodsFor: 'options' stamp: 'lr 9/5/2006 17:24'!autoSelect: aBoolean	self optionAt: 'autoSelect' put: aBoolean! !!SUAutocompleter methodsFor: 'private' stamp: 'lr 5/15/2006 11:17'!defaultArguments	^ (Array with: self element) , super defaultArguments! !!SUAutocompleter methodsFor: 'private' stamp: 'lr 5/15/2006 10:49'!defaultPrototype	^ 'Ajax.Autocompleter'! !!SUAutocompleter methodsFor: 'accessing' stamp: 'lr 5/15/2006 10:59'!element	^ element! !!SUAutocompleter methodsFor: 'accessing' stamp: 'lr 5/15/2006 11:00'!element: aString	element := aString! !!SUAutocompleter methodsFor: 'options' stamp: 'lr 3/12/2006 16:21'!frequency: aNumber	self optionAt: 'frequency' put: aNumber! !!SUAutocompleter methodsFor: 'options' stamp: 'lr 5/15/2006 10:50'!indicator: aString	"When sending the Ajax request Autocompleter shows this element with Element.show. When the request has been completed it will be hidden with Element.hide."	self optionAt: 'indicator' put: aString! !!SUAutocompleter methodsFor: 'options' stamp: 'lr 3/12/2006 16:21'!minChars: aNumber	self optionAt: 'minChars' put: aNumber! !!SUAutocompleter methodsFor: 'events' stamp: 'lr 4/6/2006 20:34'!onHide: anObject	self optionAt: 'onHide' put: anObject asFunction! !!SUAutocompleter methodsFor: 'events' stamp: 'lr 5/15/2006 11:24'!onSelected: anObject	"Hook for a custom function called after the element has been updated. This function is called after the built-in function that adds the list item text to the input field. The function receives two parameters, the autocompletion input field and the selected item."	self optionAt: 'afterUpdateElement' put: anObject asFunction! !!SUAutocompleter methodsFor: 'events' stamp: 'lr 4/6/2006 20:34'!onShow: anObject	self optionAt: 'onShow' put: anObject asFunction! !!SUAutocompleter methodsFor: 'events' stamp: 'lr 5/15/2006 11:23'!onUpdate: anObject	"Hook for a custom function called after the element has been updated. This function is called instead of the built-in function that adds the list item text to the input field. The function receives one parameter only, the selected item."	self optionAt: 'updateElement' put: anObject asFunction! !!SUAutocompleter methodsFor: 'options' stamp: 'lr 3/12/2006 16:21'!tokens: anArray	self optionAt: 'tokens' put: anArray! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:40'!cancelLink: aBoolean	"If a cancel link is shown in edit mode."	self optionAt: 'cancelLink' put: aBoolean! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:40'!cancelText: aString	"The text of the link that cancels editing."	self optionAt: 'cancelText' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:42'!clickToEditText: aString	"The text shown during mouseover the editable text."	self optionAt: 'clickToEditText' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:46'!cols: anInteger	"The number of columns the text area should span (works for both single line or multi line)."	self optionAt: 'cols' put: anInteger! !!SUInPlaceEditor methodsFor: 'private' stamp: 'lr 8/6/2006 13:46'!defaultPrototype	^ 'Ajax.InPlaceEditor'! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 4/2/2006 12:40'!externalControl: aString	"Id of an element that acts as an external control used to enter edit mode. The external control will be hidden when entering edit mode and shown again when leaving edit mode."	self optionAt: 'externalControl' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 4/2/2006 13:23'!formClass: aString	"CSS class used for the in place edit form."	self optionAt: 'formClassName' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:41'!formId: aString	"Id of the element to edit."	self optionAt: 'formId' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:50'!highlightColor: aColor	"The highlight color."	self optionAt: 'highlightcolor' put: aColor! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:50'!highlightEndColor: aColor	"The color which the highlight fades to."	self optionAt: 'highlightendcolor' put: aColor! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:39'!okButton: aBoolean	"If a submit button is shown in edit mode."	self optionAt: 'okButton' put: aBoolean! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:39'!okText: aString	"The text of the submit button that submits the changed value to the server."	self optionAt: 'okText' put: aString! !!SUInPlaceEditor methodsFor: 'events' stamp: 'lr 8/7/2006 08:46'!onComplete: anObject	"Code run if update successful with server."	self optionAt: 'onComplete' put: anObject asFunction! !!SUInPlaceEditor methodsFor: 'events' stamp: 'lr 8/7/2006 08:46'!onFailure: anObject	"Code run if update failed with server."	self optionAt: 'onFailure' put: anObject asFunction! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:44'!rows: anInteger	"The row height of the input field, anything greater than 1 uses a multiline textarea for input."	self optionAt: 'rows' put: anInteger! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 4/2/2006 13:22'!savingClass: aString	"CSS class added to the element while displaying 'Saving' (removed when server responds)."	self optionAt: 'savingClassName' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:40'!savingText: aString	"The text shown while the text is sent to the server."	self optionAt: 'savingText' put: aString! !!SUInPlaceEditor methodsFor: 'options' stamp: 'lr 8/7/2006 08:49'!submitOnBlur: aBoolean	self optionAt: 'submitOnBlur' put: aBoolean! !!SUInPlaceEditor methodsFor: 'triggers' stamp: 'lr 8/6/2006 14:50'!triggerInPlaceEditor: aBlock	self callback: aBlock value: (SUStream on: 'encodeURIComponent(arguments[1])').	self optionAt: 'callback' put: (SUFunction new		add: (self options removeKey: 'parameters');		return: true;		yourself)! !!SUPeriodical methodsFor: 'options' stamp: 'lr 4/20/2006 16:13'!decay: aNumber	"Determines the progressive slowdown in the refresh rate when the received response is the same as the last one. For example, if you use 2, after one of the refreshes produces the same result as the previous one, the object will wait twice as much time for the next refresh. If it repeats again, the object will wait four times as much, and so on. Leave it undefined or use 1 to avoid the slowdown."	self options at: 'decay' put: aNumber! !!SUPeriodical methodsFor: 'private' stamp: 'lr 5/10/2006 21:26'!defaultPrototype	^ 'Ajax.PeriodicalUpdater'! !!SUPeriodical methodsFor: 'options' stamp: 'lr 4/20/2006 16:13'!frequency: aDuration	"Interval between refreshes, in seconds. This number will be multiplied by the current decay."	self options at: 'frequency' put: aDuration! !!SUUpdater methodsFor: 'private' stamp: 'lr 5/10/2006 21:33'!defaultArguments	^ (Array with: self id) , super defaultArguments! !!SUUpdater methodsFor: 'private' stamp: 'lr 5/10/2006 21:34'!defaultId	^ SUStream on: 'this'! !!SUUpdater methodsFor: 'private' stamp: 'lr 5/10/2006 21:26'!defaultPrototype	^ 'Ajax.Updater'! !!SUUpdater methodsFor: 'options' stamp: 'lr 4/20/2006 16:39'!evalScripts: aBoolean	"Evaluate javascript-code within responses."	self options at: 'evalScripts' put: aBoolean! !!SUUpdater methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:33'!id	^ id ifNil: [ self defaultId ]! !!SUUpdater methodsFor: 'accessing' stamp: 'lr 4/20/2006 15:09'!id: aString	id := aString! !!SUUpdater methodsFor: 'options' stamp: 'lr 5/2/2006 10:38'!insertion: anInsertion	"Option to be used to inject the returned text into an element."	self options at: 'insertion' put: anInsertion! !!SUUpdater methodsFor: 'processing' stamp: 'lr 8/4/2006 08:39'!processOn: aStream	callback ifNotNil: [ self render: callback on: aStream ]! !!SUEvent methodsFor: 'private' stamp: 'lr 5/17/2006 11:29'!defaultArguments	^ nil! !!SUEvent methodsFor: 'private' stamp: 'lr 5/10/2006 21:14'!defaultEvent	^ SUStream on: 'event'! !!SUEvent methodsFor: 'private' stamp: 'lr 5/10/2006 21:20'!defaultPrototype	^ 'Event'! !!SUEvent methodsFor: 'querying' stamp: 'lr 5/12/2006 15:08'!element	"Returns the element which fired the event."	self call: 'element' argument: self event! !!SUEvent methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:13'!event	^ event ifNil: [ self defaultEvent ]! !!SUEvent methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:14'!event: anObject	event := anObject! !!SUEvent methodsFor: 'actions' stamp: 'lr 5/16/2006 08:07'!on: anEventString do: anObject	"Define event handler anObject for anEventString."	self call: 'observe' arguments: (Array with: self event with: anEventString with: anObject asFunction)! !!SUEvent methodsFor: 'actions' stamp: 'lr 5/10/2006 21:14'!stop	"Stop events from bubbeling."	self call: 'stop' argument: self event! !!SUEvent methodsFor: 'querying' stamp: 'lr 5/10/2006 21:13'!x	self call: 'pointerX' argument: self event! !!SUEvent methodsFor: 'querying' stamp: 'lr 5/10/2006 21:13'!y	self call: 'pointerY' argument: self event! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:48'!constraint: aSymbol	"If set to #horizontal or #vertical the drag will be constrained to take place only horizontally or vertically."	self optionAt: 'constraint' put: aSymbol! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:48'!constraintHorizontal	self constraint: #horizontal! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:48'!constraintVertical	self constraint: #vertical! !!SUDraggable methodsFor: 'private' stamp: 'lr 6/30/2006 19:48'!defaultPrototype	^ 'Draggable'! !!SUDraggable methodsFor: 'options' stamp: 'lr 9/5/2006 17:23'!delay: aDuration	self optionAt: 'delay' put: aDuration! !!SUDraggable methodsFor: 'effects' stamp: 'lr 9/5/2006 17:28'!endEffect: anObject	self optionAt: 'endeffect' put: anObject asFunction! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:44'!ghosting: aBoolean	"Clones the element and drags the clone, leaving the original in place until the clone is dropped."	self optionAt: 'ghosting' put: aBoolean! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:45'!handle: aString	"Sets whether the element should only be draggable by an embedded handle. The value must be an element reference or element id."	self optionAt: 'handle' put: aString! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:54'!hoverclass: aString	"Gives the created Droppables a hoverclass."	self optionAt: 'hoverclass' put: aString! !!SUDraggable methodsFor: 'initialization' stamp: 'lr 6/30/2006 19:48'!initialize	super initialize.	self create! !!SUDraggable methodsFor: 'events' stamp: 'lr 9/5/2006 17:26'!onDrag: anObject	self optionAt: 'onDrag' put: anObject asFunction! !!SUDraggable methodsFor: 'events' stamp: 'lr 9/5/2006 17:26'!onEnd: anObject	self optionAt: 'onEnd' put: anObject asFunction! !!SUDraggable methodsFor: 'events' stamp: 'lr 9/5/2006 17:26'!onStart: anObject	self optionAt: 'onStart' put: anObject asFunction! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:45'!revert: aBoolean	"If set to true, the element returns to its original position when the drags ends."	self optionAt: 'revert' put: aBoolean! !!SUDraggable methodsFor: 'effects' stamp: 'lr 9/5/2006 17:29'!revertEffect: anObject	self optionAt: 'reverteffect' put: anObject asFunction! !!SUDraggable methodsFor: 'options' stamp: 'lr 4/7/2006 13:48'!scroll: aBoolean	self optionAt: 'scroll' put: aBoolean! !!SUDraggable methodsFor: 'options' stamp: 'lr 4/7/2006 13:48'!scrollSensitivity: anInteger	self optionAt: 'scrollSensitivity' put: anInteger! !!SUDraggable methodsFor: 'options' stamp: 'lr 4/7/2006 13:48'!scrollSpeed: anInteger	self optionAt: 'scrollSpeed' put: anInteger! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:45'!snap: aBooleanOrPoint	"If set to false no snapping occurs. Otherwise takes the forms [x,y]."	self optionAt: 'snap' put: aBooleanOrPoint! !!SUDraggable methodsFor: 'options' stamp: 'lr 3/7/2006 13:45'!zindex: anInteger	"The css zindex of the draggable item."	self optionAt: 'zindex' put: anInteger! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!accept: aStringOrArray	"Set accept to a string or an array of strings describing CSS classes. The Droppable will only accept Draggables that have one or more of these CSS classes."	self optionAt: 'accept' put: aStringOrArray! !!SUDroppable methodsFor: 'actions' stamp: 'lr 5/12/2006 14:15'!add	"To make an element react when a Draggable is dropped onto it."		self method: 'add'! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!containment: aStringOrArray	"The droppable will only accept the Draggable if the Draggable is contained in the given elements (or element ids). Can be a single element or an array of elements."	self optionAt: 'containment' put: aStringOrArray! !!SUDroppable methodsFor: 'private' stamp: 'lr 5/12/2006 14:15'!defaultMethod	^ 'add'! !!SUDroppable methodsFor: 'private' stamp: 'lr 5/12/2006 15:32'!defaultPrototype	^ 'Droppables'! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!greedy: aBoolean	"If true stops processing hovering (don't look for other Droppables that are under the Draggable)."	self optionAt: 'greedy' put: aBoolean! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!hoverclass: aString	"If set, the Droppable will have this additional CSS class when an accepted Draggable is hovered over it."	self optionAt: 'hoverclass' put: aString! !!SUDroppable methodsFor: 'events' stamp: 'lr 4/1/2006 11:17'!onDrop: anObject	"Called whenever a Draggable is released over the Droppable and the Droppable is accepts it."	self optionAt: 'onDrop' put: anObject asFunction! !!SUDroppable methodsFor: 'events' stamp: 'lr 4/1/2006 11:17'!onHover: anObject	"Called whenever a Draggable is moved over the Droppable and the Droppable is affected (would accept it). The callback gets 2 parameters, the passenger of the draggable and the percentage of overlapping as defined by the overlap option."	self optionAt: 'onHover' put: anObject asFunction! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!overlap: aString	"If set to 'horizontal' or 'vertical' the droppable will only react to a Draggable if its overlapping by more than 50% in the given direction."	self optionAt: 'overlap' put: aString! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!overlapHorizontal	self overlap: 'horizontal'! !!SUDroppable methodsFor: 'options' stamp: 'lr 3/12/2006 16:26'!overlapVertical	self overlap: 'vertical'! !!SUDroppable methodsFor: 'actions' stamp: 'lr 5/12/2006 14:15'!remove	"Remove any droppable capabilities from element."		self method: 'remove'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:34'!appear	"Make an element appear. If the element was previously set to display:none; inside the style attribute of the element, the effect will automatically show the element. This means that it must be places under the style attribute of an object, and not in the CSS in the head of the document or a linked file."	self create; method: 'Appear'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:38'!blindDown	"Simulate a window blind, where the contents of the affected elements stay in place."	self create; method: 'BlindDown'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:38'!blindUp	"Simulate a window blind, where the contents of the affected elements stay in place."	self create; method: 'BlindUp'! !!SUEffect methodsFor: 'private' stamp: 'lr 5/12/2006 14:42'!defaultMethod	^ 'toggle'! !!SUEffect methodsFor: 'private' stamp: 'lr 5/12/2006 14:16'!defaultPrototype	^ 'Effect'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/12/2006 14:20'!direction: aString	"Set the direction of the transition. Values can be either 'top-left', 'top-right', 'bottom-left', 'bottom-right' or 'center' (default). Applicable only on Grow and Shrink effects."	self optionAt: 'direction' put: aString! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:36'!dropOut	"Make the element drop and fade out at the same time."	self create; method: 'DropOut'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:50'!duration: aNumber	"Duration of the effect in seconds, given as a float. Defaults to 1.0."	self optionAt: 'duration' put: aNumber! !!SUEffect methodsFor: 'options-highlight' stamp: 'lr 5/2/2006 13:50'!endColor: aColor	"Sets the color of the last frame of the highlight. This is best set to the background color of the highlighted element."	self optionAt: 'endcolor' put: aColor! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:35'!fade	"Make an element fade away and takes it out of the document flow at the end of the effect by setting the CSS display property to none."	self create; method: 'Fade'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:41'!fold	"Reduce the element to its top then to left to make it disappear."	self create; method: 'Fold'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:50'!fps: aNumber	"Target this many frames per second. Default to 25. Can't be higher than 100."	self optionAt: 'fps' put: aNumber! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:50'!from: aNumber	"Sets the starting point of the transition, a float between 0.0 and 1.0. Defaults to 0.0."	self optionAt: 'from' put: aNumber! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:41'!grow	"See a demo."	self create; method: 'Grow'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:37'!highlight	"This effect Flashes a color as the background of an element. It is mostly used to draw attention to a part of the page that has been updated via javascript or AJAX, when the update would not otherwise be obvious."	self create; method: 'Highlight'! !!SUEffect methodsFor: 'effects' stamp: 'lr 5/12/2006 14:58'!move: aPoint	"This effect moves an element by a given x/y pair of pixels."	self create; method: 'Move'; arguments: self arguments , (Array with: aPoint x with: aPoint y)! !!SUEffect methodsFor: 'options-scroll' stamp: 'lr 8/29/2006 13:47'!offset: anInteger	"Negative or positive number of pixels as offset to the top of view."		self optionAt: 'offset' put: anInteger! !!SUEffect methodsFor: 'events' stamp: 'lr 4/22/2006 20:24'!onAfterFinish: anObject	"Called after the last redraw of the effect was made."	self options at: 'afterFinish' put: anObject asFunction! !!SUEffect methodsFor: 'events' stamp: 'lr 4/22/2006 20:24'!onAfterUpdate: anObject	"Called on each iteration of the effects rendering loop, after the redraw takes places."	self options at: 'afterUpdate' put: anObject asFunction! !!SUEffect methodsFor: 'events' stamp: 'lr 4/22/2006 20:24'!onBeforeStart: anObject	"Called before the main effects rendering loop is started."	self options at: 'beforeStart' put: anObject asFunction! !!SUEffect methodsFor: 'events' stamp: 'lr 4/22/2006 20:24'!onBeforeUpdate: anObject	"Called on each iteration of the effects rendering loop, before the redraw takes places."	self options at: 'beforeUpdate' put: anObject asFunction! !!SUEffect methodsFor: 'effects' stamp: 'mb 5/29/2006 13:00'!opacity	"This effect changes an element's opacity"	self create; method: 'Opacity'! !!SUEffect methodsFor: 'effects' stamp: 'lr 5/12/2006 14:56'!parallel: aCollection	"This is a special effect to allow to combine more than one core effect into a parallel effect."	self create; method: 'Parallel'; arguments: (Array with: aCollection)! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:36'!puff	"Give the illusion of the element puffing away (like a in a cloud of smoke)."	self create; method: 'Puff'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:39'!pulsate	"Pulsate the element, loops over five times over fading out and in."	self create; method: 'Pulsate'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:50'!queue: aString	"Sets queuing options. When used with a string, can be 'front' or 'end' to queue the effect in the global effects queue at the beginning or end, or a queue parameter object that can have {position: 'front/end', scope: 'scope', limit:1}. For more info on this, see Effect.Queues."	self optionAt: 'queue' put: aString! !!SUEffect methodsFor: 'options-highlight' stamp: 'lr 5/2/2006 13:50'!restoreColor: aColor	"Sets the background color of the element after the highlight has finished."	self optionAt: 'restorecolor' put: aColor! !!SUEffect methodsFor: 'effects' stamp: 'lr 5/12/2006 14:59'!scale: aNumber	"This effect changes an elements width and height dimensions and the base for em units. This allows for smooth, automatic relative scaling of elements contained within the scaled element."	self create; method: 'Scale'; arguments: self arguments , (Array with: aNumber)! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:26'!scaleContent: aBoolean	"Set whether content scaling should be enabled, defaults to true."	self optionAt: 'scaleContent' put: aBoolean! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:27'!scaleFrom: aNumber	"Set the starting percentage for scaling, defaults to 100.0."	self optionAt: 'scaleFrom' put: aNumber! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:26'!scaleFromCenter: aBoolean	"If true, scale the element in a way that the center of the element stays on the same position on the screen, defaults to false."	self optionAt: 'scaleFromCenter' put: aBoolean! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:27'!scaleMode: anObject	"Either 'box' (default, scales the visible area of the element) or 'contents' (scales the complete element, that is parts normally only visible byscrolling are taken into account). You can also precisely control the size the element will become by assigning the originalHeight and originalWidth variables to scaleMode."	self optionAt: 'scaleMode' put: anObject! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:25'!scaleX: aBoolean	"Set whether the element should be scaled horizontally, defaults to true."	self optionAt: 'scaleX' put: aBoolean! !!SUEffect methodsFor: 'options-scale' stamp: 'lr 5/12/2006 14:25'!scaleY: aBoolean	"Set whether the element should be scaled vertically, defaults to true."	self optionAt: 'scaleY' put: aBoolean! !!SUEffect methodsFor: 'effects' stamp: 'lr 8/29/2006 13:46'!scroll	"Scroll page view to element."	self create; method: 'ScrollTo'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:36'!shake	"Move the element slightly to the left, then to the right, repeatedly."	self create; method: 'Shake'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:41'!shrink	"Reduce the element to its top-left corner."	self create; method: 'Shrink'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:39'!slideDown	"Simulate a window blind, where the contents of the affected elements scroll up and down accordingly."	self create; method: 'SlideDown'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:39'!slideUp	"Simulate a window blind, where the contents of the affected elements scroll up and down accordingly."	self create; method: 'SlideUp'! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:40'!squish	"Reduce the element to its top-left corner."	self create; method: 'Squish'! !!SUEffect methodsFor: 'options-highlight' stamp: 'lr 5/2/2006 13:50'!startColor: aColor	"Sets the color of first frame of the highlight the highlight."	self optionAt: 'startcolor' put: aColor! !!SUEffect methodsFor: 'effects-combination' stamp: 'lr 5/12/2006 14:37'!switchOff	"Give the illusion of a TV-style switch off."	self create; method: 'SwitchOff'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:50'!sync: aBoolean	"Sets whether the effect should render new frames automatically (which it does by default). If true, you can render frames manually by calling the render() instance method of an effect. This is used by Effect.Parallel()."	self optionAt: 'sync' put: aBoolean! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:51'!to: aNumber	"Sets the end point of the transition, a float between 0.0 and 1.0. Defaults to 1.0."	self optionAt: 'to' put: aNumber! !!SUEffect methodsFor: 'effects-toggles' stamp: 'lr 5/12/2006 15:00'!toggle: aString	"Allow for easily toggling elements with an animation."	self method: 'toggle'; arguments: self arguments , (Array with: aString)! !!SUEffect methodsFor: 'effects-toggles' stamp: 'lr 5/2/2006 13:58'!toggleAppear	self toggle: 'Appear'! !!SUEffect methodsFor: 'effects-toggles' stamp: 'lr 5/2/2006 13:58'!toggleBlind	self toggle: 'Blind'! !!SUEffect methodsFor: 'effects-toggles' stamp: 'lr 5/2/2006 13:58'!toggleSlide	self toggle: 'Slide'! !!SUEffect methodsFor: 'options' stamp: 'lr 5/2/2006 13:51'!transition: anObject	"Sets a function that modifies the current point of the animation, which is between 0 and 1. Following transitions are supplied: Effect.Transitions.sinoidal (default), Effect.Transitions.linear, Effect.Transitions.reverse, Effect.Transitions.wobble and Effect.Transitions.flicker."	self optionAt: 'transition' put: anObject asFunction! !!SUElement methodsFor: 'styling' stamp: 'lr 5/12/2006 15:02'!addClassName: aString	"Add a class name aString to element."		self method: 'addClassName'; arguments: self arguments , (Array with: aString)! !!SUElement methodsFor: 'styling' stamp: 'lr 5/12/2006 15:03'!classNames	"Return the name of the class associated with element. Returns an empty string if there is no class associated with element."		self method: 'classNames'! !!SUElement methodsFor: 'private' stamp: 'lr 5/12/2006 15:00'!defaultMethod	^ 'toggle'! !!SUElement methodsFor: 'private' stamp: 'lr 5/10/2006 21:19'!defaultPrototype	^ 'Element'! !!SUElement methodsFor: 'styling' stamp: 'lr 5/12/2006 15:03'!hasClassName: aString	"Return true if element has a class name corresponding to aString and false otherwise."		self method: 'hasClassName'; arguments: self arguments , (Array with: aString)! !!SUElement methodsFor: 'displaying' stamp: 'lr 5/12/2006 15:01'!hide	"Set an element's display property to invisible. Using this you can hide an element from view (and effectively remove it from the flow of the page)."		self method: 'hide'! !!SUElement methodsFor: 'modifying' stamp: 'lr 5/12/2006 15:01'!remove	"Remove the element from the DOM tree."		self method: 'remove'! !!SUElement methodsFor: 'styling' stamp: 'lr 5/12/2006 15:03'!removeClassName: aString	"Remove class name (className) from element."		self method: 'removeClassName'; arguments: self arguments , (Array with: aString)! !!SUElement methodsFor: 'modifying' stamp: 'lr 8/7/2006 09:11'!render: aBlock	"Conveniance function to update the receiver with a render block."		self update: (String streamContents: [ :stream | self render: aBlock on: stream ])! !!SUElement methodsFor: 'modifying' stamp: 'lr 5/12/2006 15:02'!replace: anObject	"Replace the element with anObject."		self method: 'replace'; arguments: self arguments , (Array with: anObject)! !!SUElement methodsFor: 'displaying' stamp: 'lr 8/29/2006 13:45'!scroll	"Move the scroll-bar to where the target object is positioned."		self method: 'scrollTo'! !!SUElement methodsFor: 'displaying' stamp: 'lr 5/12/2006 15:01'!show	"Set an element's display property to visible. Using this you can show an element that has been hidden from the page using Element.hide."		self method: 'show'! !!SUElement methodsFor: 'displaying' stamp: 'lr 5/12/2006 15:01'!toggle	"Toggle the display property of an element. Using this you can show or hide an element (removing it from the flow of the page)."		self method: 'toggle'! !!SUElement methodsFor: 'modifying' stamp: 'lr 5/12/2006 15:02'!update: anObject	"Updates the content of element with anObject."		self method: 'update'; arguments: self arguments , (Array with: anObject)! !!SUElement methodsFor: 'displaying' stamp: 'lr 5/12/2006 15:01'!visible	"Return false if display is set to none, true otherwise."		self method: 'visible'! !!SUForm methodsFor: 'private' stamp: 'lr 5/12/2006 15:08'!defaultMethod	^ 'serialize'! !!SUForm methodsFor: 'private' stamp: 'lr 5/12/2006 15:09'!defaultPrototype	^ 'Form'! !!SUForm methodsFor: 'actions' stamp: 'lr 5/12/2006 15:10'!disable	"Disable all elements in a form."		self method: 'disable'! !!SUForm methodsFor: 'actions' stamp: 'lr 5/12/2006 15:10'!enable	"Enable all elements in a form."		self method: 'enable'! !!SUForm methodsFor: 'actions' stamp: 'lr 5/12/2006 15:10'!focus	"Set focus on first element of specified form."		self method: 'focusFirstElement'! !!SUForm methodsFor: 'actions' stamp: 'lr 5/12/2006 15:10'!reset	"Set all the elements of the form with specified id to blank."		self method: 'reset'! !!SUForm methodsFor: 'actions' stamp: 'lr 5/12/2006 15:10'!serialize	"Turn a form''s elements into a query string with each query component separated by an &-character. This makes it very useful for contructing a GET query from a form."		self method: 'serialize'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 9/6/2006 13:51'!activate	self method: 'activate'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 9/6/2006 13:53'!clear	self method: 'clear'! !!SUFormElement methodsFor: 'private' stamp: 'lr 5/12/2006 15:11'!defaultMessage	^ 'serialize'! !!SUFormElement methodsFor: 'private' stamp: 'lr 5/12/2006 15:10'!defaultPrototype	^ 'Form.Element'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 9/6/2006 13:51'!disable	self method: 'disable'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 9/6/2006 13:51'!enable	self method: 'enable'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 5/12/2006 15:11'!serialize	self method: 'serialize'! !!SUFormElement methodsFor: 'actions' stamp: 'lr 5/12/2006 15:11'!value	self method: 'getValue'! !!SUInsertion class methodsFor: 'instance-creation' stamp: 'lr 5/2/2006 10:36'!after	^ self new after! !!SUInsertion class methodsFor: 'instance-creation' stamp: 'lr 5/2/2006 10:36'!before	^ self new before! !!SUInsertion class methodsFor: 'instance-creation' stamp: 'lr 5/2/2006 10:36'!bottom	^ self new bottom! !!SUInsertion class methodsFor: 'instance-creation' stamp: 'lr 5/2/2006 10:36'!top	^ self new top! !!SUInsertion methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:50'!after	"Insert content after an element."		self access: 'After'! !!SUInsertion methodsFor: 'actions' stamp: 'lr 5/2/2006 10:24'!after: aString	self after; with: aString! !!SUInsertion methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:50'!before	"Insert content before an element."		self access: 'Before'! !!SUInsertion methodsFor: 'actions' stamp: 'lr 5/2/2006 10:24'!before: aString	self before; with: aString! !!SUInsertion methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:51'!bottom	"Insert content as the last child under an element, right before the element's closing tag."		self access: 'Bottom'! !!SUInsertion methodsFor: 'actions' stamp: 'lr 5/2/2006 10:24'!bottom: aString	self bottom; with: aString! !!SUInsertion methodsFor: 'private' stamp: 'lr 5/17/2006 11:31'!defaultArguments	^ nil! !!SUInsertion methodsFor: 'private' stamp: 'lr 5/10/2006 21:45'!defaultPrototype	^ 'Insertion'! !!SUInsertion methodsFor: 'accessing' stamp: 'lr 5/10/2006 21:51'!top	"Insert the content as the first child under an element, right after the opening tag of the element."		self access: 'Top'! !!SUInsertion methodsFor: 'actions' stamp: 'lr 5/2/2006 10:24'!top: aString	self top; with: aString! !!SUInsertion methodsFor: 'public' stamp: 'lr 5/10/2006 22:06'!with: aString	self create; apply: (Array with: self id with: aString)! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/12/2006 14:58'!arguments	^ arguments ifNil: [ Array with: self id ]! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/12/2006 14:11'!arguments: aCollection	arguments := aCollection! !!SUNamed methodsFor: 'private' stamp: 'lr 5/12/2006 14:58'!defaultArguments	^ self arguments , super defaultArguments! !!SUNamed methodsFor: 'private' stamp: 'lr 5/2/2006 16:17'!defaultId	^ SUStream on: 'this'! !!SUNamed methodsFor: 'private' stamp: 'lr 5/12/2006 14:12'!defaultMethod	^ nil! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/10/2006 20:38'!id	^ id ifNil: [ self defaultId ]! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/12/2006 14:58'!id: aString	id := aString! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/12/2006 14:11'!method	^ method ifNil: [ self defaultMethod ]! !!SUNamed methodsFor: 'accessing' stamp: 'lr 5/12/2006 14:12'!method: aString	method := aString! !!SUNamed methodsFor: 'printing' stamp: 'lr 5/16/2006 08:04'!printContentOn: aStream	self printPrototypeOn: aStream.	self method		ifNotNil: [ self printMethodOn: aStream ].	self printArgumentsOn: aStream! !!SUNamed methodsFor: 'printing' stamp: 'lr 5/15/2006 13:45'!printMethodOn: aStream	aStream nextPut: $.; nextPutAll: self method! !!SUSortable class methodsFor: 'private' stamp: 'lr 5/3/2006 21:04'!passengerPrefix	^ '_p'! !!SUSortable class methodsFor: 'private' stamp: 'lr 4/22/2006 19:25'!passengerRegexp	^ SUStream new 		nextPutAll: '/^';		nextPutAll: self passengerPrefix;		nextPutAll: '([0-9]+)$/'! !!SUSortable methodsFor: 'options' stamp: 'lr 4/1/2006 11:53'!constraint: aString	"If set to #horizontal or #vertical the drag will be constrained to take place only horizontally or vertically."	self optionAt: 'constraint' put: aString! !!SUSortable methodsFor: 'options' stamp: 'lr 4/1/2006 11:53'!constraintHorizontal	self constraint: #horizontal! !!SUSortable methodsFor: 'options' stamp: 'lr 4/1/2006 11:53'!constraintVertical	self constraint: #vertical! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:54'!containment: aStringOrArray	"Enables dragging and dropping between Sortables. Takes an array of elements or element-ids (of the containers)."	self optionAt: 'containment' put: aStringOrArray! !!SUSortable methodsFor: 'actions' stamp: 'lr 5/12/2006 15:12'!create	self method: 'create'! !!SUSortable methodsFor: 'private' stamp: 'lr 5/12/2006 15:12'!defaultMethod	^ 'create'! !!SUSortable methodsFor: 'private' stamp: 'lr 5/10/2006 22:39'!defaultPrototype	^ 'Sortable'! !!SUSortable methodsFor: 'options' stamp: 'lr 9/5/2006 17:23'!delay: aDuration	self optionAt: 'delay' put: aDuration! !!SUSortable methodsFor: 'actions' stamp: 'lr 5/12/2006 15:13'!destory	self method: 'destory'! !!SUSortable methodsFor: 'options' stamp: 'lr 4/11/2006 14:53'!dropOnEmpty: aBoolean	"If set to true, the Sortable container will be made into a Droppable, that can receive a Draggable (as according to the containment rules) as a child element when there are no more elements inside."	self optionAt: 'dropOnEmpty' put: aBoolean! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:55'!ghosting: aBoolean	"If set to true, dragged elements of the Sortable will e cloned and appear as 'ghost', i.e. a representation of their original element, instead of directly dragging the original element."	self optionAt: 'ghosting' put: aBoolean! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 16:50'!handle: aString	"Further restricts the selection of child elements to only encompass elements with the given CSS class (or, if you provide an array of strings, on any of the classes)."	self optionAt: 'handle' put: aString! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:54'!hoverclass: aString	"Gives the created Droppables a hoverclass."	self optionAt: 'hoverclass' put: aString! !!SUSortable methodsFor: 'initialization' stamp: 'lr 4/29/2006 18:46'!initialize	super initialize.	self optionAt: 'format' put: self class passengerRegexp! !!SUSortable methodsFor: 'events' stamp: 'lr 4/1/2006 11:19'!onChange: anObject	"Called whenever the sort order changes while dragging. When dragging from one Sortable to another, the callback is called once on each Sortable."	self optionAt: 'onChange' put: anObject asFunction! !!SUSortable methodsFor: 'events' stamp: 'lr 4/1/2006 11:19'!onUpdate: anObject	"Called when the drag ends and the Sortable's order is changed in any way. When dragging from one Sortable to another, the callback is called once on each Sortable."	self optionAt: 'onUpdate' put: anObject asFunction! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:44'!only: aString	"Further restricts the selection of child elements to only encompass elements with the given CSS class (or, if you provide an array of strings, on any of the classes)."	self optionAt: 'only' put: aString! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:48'!overlap: aSymbol	"Either #vertical or #horizontal. For floating sortables or horizontal lists, choose #horizontal. Vertical lists should use #vertical."	self optionAt: 'overlap' put: aSymbol! !!SUSortable methodsFor: 'options' stamp: 'lr 4/1/2006 11:53'!overlapHorizontal	self overlap: #horizontal! !!SUSortable methodsFor: 'options' stamp: 'lr 3/8/2006 09:39'!overlapVertical	self overlap: #vertical! !!SUSortable methodsFor: 'options' stamp: 'lr 4/6/2006 23:37'!scroll: aBoolean	self optionAt: 'scroll' put: aBoolean! !!SUSortable methodsFor: 'options' stamp: 'lr 4/6/2006 23:38'!scrollSensitivity: aNumber	self optionAt: 'scrollSensitivity' put: aNumber! !!SUSortable methodsFor: 'options' stamp: 'lr 4/6/2006 23:38'!scrollSpeed: aNumber	self optionAt: 'scrollSpeed' put: aNumber! !!SUSortable methodsFor: 'actions' stamp: 'lr 5/12/2006 15:13'!sequence	self method: 'sequence'! !!SUSortable methodsFor: 'actions' stamp: 'lr 5/12/2006 15:13'!serialize	self method: 'serialize'! !!SUSortable methodsFor: 'options' stamp: 'lr 3/7/2006 13:44'!tag: aString	"Sets the kind of tag (of the child elements of the container) that will be made sortable. For UL and OL containers, this is 'LI', you have to provide the tag kind for other sorts of child tags."	self optionAt: 'tag' put: aString! !!SUSortable methodsFor: 'actions' stamp: 'lr 5/12/2006 15:13'!tree	self method: 'tree_sequence'! !!SUSortable methodsFor: 'options' stamp: 'lr 4/6/2006 23:37'!tree: aBoolean	self optionAt: 'tree' put: aBoolean! !!SUSortable methodsFor: 'options' stamp: 'lr 4/6/2006 23:37'!treeTag: aString	self optionAt: 'treeTag' put: aString! !!SUPrototype methodsFor: 'private' stamp: 'lr 5/15/2006 13:43'!defaultArguments	^ options ifNil: [ Array new ] ifNotNil: [ Array with: options ]! !!SUPrototype methodsFor: 'private' stamp: 'lr 5/9/2006 21:07'!defaultOptions	^ Dictionary new! !!SUPrototype methodsFor: 'private' stamp: 'lr 5/10/2006 21:18'!defaultPrototype	self subclassResponsibility! !!SUPrototype methodsFor: 'accessing' stamp: 'lr 5/9/2006 21:07'!optionAt: aKey put: anObject	self options at: aKey put: anObject! !!SUPrototype methodsFor: 'accessing' stamp: 'lr 5/9/2006 21:07'!options	^ options ifNil: [ options := self defaultOptions ]! !!SUPrototype methodsFor: 'printing' stamp: 'lr 5/17/2006 11:29'!printArgumentsOn: aStream	self defaultArguments ifNotNilDo: [ :args | aStream arguments: args ]! !!SUPrototype methodsFor: 'printing' stamp: 'lr 5/15/2006 13:44'!printContentOn: aStream	self printPrototypeOn: aStream.	self printArgumentsOn: aStream! !!SUPrototype methodsFor: 'printing' stamp: 'mb 5/29/2006 13:02'!printPrototypeOn: aStream	aStream nextPutAll: self defaultPrototype! !!SUSelector methodsFor: 'enumerating' stamp: 'lr 5/15/2006 13:55'!collect: aBlock	self call: 'collect' argument: ((SUFunction on: self canvas block: aBlock arguments: (Array with: SUElementReference)) return: true)! !!SUSelector methodsFor: 'private' stamp: 'lr 5/17/2006 11:31'!defaultArguments	^ self selectors! !!SUSelector methodsFor: 'private' stamp: 'lr 5/10/2006 22:12'!defaultPrototype	^ '$$'! !!SUSelector methodsFor: 'enumerating' stamp: 'lr 5/12/2006 16:16'!do: aBlock	self call: 'each' argument: (SUFunction on: self canvas block: aBlock arguments: (Array with: SUElementReference))! !!SUSelector methodsFor: 'initialization' stamp: 'lr 5/15/2006 13:48'!initialize	super initialize.	selectors := OrderedCollection new! !!SUSelector methodsFor: 'enumerating' stamp: 'lr 6/30/2006 19:59'!invoke: aString arguments: anArray	self call: 'invoke' arguments: (Array with: aString) , anArray! !!SUSelector methodsFor: 'options' stamp: 'lr 5/15/2006 13:50'!name: aString	self selectors add: aString! !!SUSelector methodsFor: 'enumerating' stamp: 'lr 5/9/2006 22:04'!pluck: aString	self call: 'pluck' argument: aString! !!SUSelector methodsFor: 'accessing' stamp: 'lr 5/15/2006 13:49'!selectors	^ selectors! !!SUSelector methodsFor: 'accessing' stamp: 'lr 5/15/2006 13:49'!selectors: aCollection	selectors := aCollection! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:16'!alignX: anNumber	"This will move the starting point on the x-axis for the handle in relation to the track. It is often used to move the 'point' of the handle to where 0 should be. It can also be used to set a different starting point on the track."	self optionAt: 'alignX' put: anNumber! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:17'!alignY: anNumber	"This will move the starting point on the y-axis for the handle in relation to the track. It is often used to move the 'point' of the handle to where 0 should be. It can also be used to set a different starting point on the track."	self optionAt: 'alignY' put: anNumber! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:13'!axis: aSymbol	"Sets the direction that the slider will move in. It should either be horizontal or vertical."	self optionAt: 'axis' put: aSymbol! !!SUSlider methodsFor: 'private' stamp: 'lr 5/15/2006 13:40'!defaultArguments	^ (Array with: self handleId with: self trackId) , super defaultArguments! !!SUSlider methodsFor: 'private' stamp: 'lr 5/15/2006 13:41'!defaultPrototype	^ 'Control.Slider'! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:17'!disabled: aBoolean	"This will lock the slider so that it will not move and thus is disabled."	self optionAt: 'disabled' put: aBoolean! !!SUSlider methodsFor: 'accessing' stamp: 'lr 3/30/2006 20:18'!handleId	^ handleId! !!SUSlider methodsFor: 'accessing' stamp: 'lr 3/30/2006 20:18'!handleId: aString	^ handleId := aString! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:14'!increment: aNumber	"Defines the relationship of value to pixels. Setting this to 1 will mean each movement of 1 pixel equates to 1 value."	self optionAt: 'increment' put: aNumber! !!SUSlider methodsFor: 'initialization' stamp: 'lr 5/15/2006 13:41'!initialize	super initialize.	self create! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:14'!maximum: aNumber	"The maximum value that the slider will move to. For horizontal this is to the right while vertical it is down."	self optionAt: 'maximum' put: aNumber! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:14'!minimum: aNumber	"The minimum value that the slider can move to. For horizontal this is to the left while vertical it is up."	self optionAt: 'minimum' put: aNumber! !!SUSlider methodsFor: 'events' stamp: 'lr 4/1/2006 11:19'!onChange: anObject	"Called whenever the Slider has finished moving or has had its value changed. The called function gets the slider value as its parameter."	self optionAt: 'onChange' put: anObject asFunction! !!SUSlider methodsFor: 'events' stamp: 'lr 4/1/2006 11:19'!onSlide: anObject	"Called whenever the Slider is moved by dragging. The called function gets the slider value as its parameter."	self optionAt: 'onSlide' put: anObject asFunction! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:15'!range: anInterval	self optionAt: 'range' put: anInterval! !!SUSlider methodsFor: 'accessing' stamp: 'lr 3/30/2006 20:16'!trackId	^ trackId! !!SUSlider methodsFor: 'accessing' stamp: 'lr 3/30/2006 20:16'!trackId: aString	trackId := aString! !!SUSlider methodsFor: 'options' stamp: 'lr 3/20/2006 19:39'!value: aNumber	"Will set the initial slider value. The handle will be set to this value, assuming it is within the minimum and maxium values."	self optionAt: 'sliderValue' put: aNumber! !!SUSlider methodsFor: 'options' stamp: 'lr 3/13/2006 20:18'!values: anArray	"Accepts an array of integers. If set these will be the only legal values for the slider to be at. Thus you can set specific slider values that the user can move the slider to."	self optionAt: 'values' put: anArray! !!SUFunction class methodsFor: 'instance-creation' stamp: 'lr 5/12/2006 16:16'!on: aCanvas block: aBlock arguments: anArray	^ (self on: aCanvas) initializeWithBlock: aBlock arguments: anArray! !!SUFunction methodsFor: 'converting' stamp: 'lr 5/17/2006 11:27'!asFunction	^ self! !!SUFunction methodsFor: 'initialization' stamp: 'lr 6/30/2006 19:35'!initializeWithBlock: aBlock arguments: anArray	aBlock valueWithPossibleArgs: (anArray withIndexCollect: [ :each :index | each script: self argument: index ])! !!SUFunction methodsFor: 'printing' stamp: 'lr 5/15/2006 11:05'!printContentOn: aStream	aStream nextPutAll: 'function(){'.	statements isEmpty ifFalse: [		statements allButLast			do: [ :each | aStream javascript: each; nextPut: $; ].		self return 			ifTrue: [ aStream nextPutAll: 'return ' ].		aStream javascript: statements last ].	aStream nextPut: $}! !!SUFunction methodsFor: 'accessing' stamp: 'lr 5/15/2006 11:04'!return	^ return ifNil: [ false ]! !!SUFunction methodsFor: 'accessing' stamp: 'lr 5/15/2006 11:04'!return: aBoolean	return := aBoolean! !!SUScript methodsFor: 'adding' stamp: 'lr 8/29/2006 08:36'!, anObject	self add: anObject! !!SUScript methodsFor: 'adding' stamp: 'lr 8/4/2006 08:59'!add: anObject	^ statements add: anObject! !!SUScript methodsFor: 'conveniance' stamp: 'lr 6/8/2006 13:16'!alert: anObject	self add: (SUStream new 		nextPutAll: 'alert';		argument: anObject;		yourself)! !!SUScript methodsFor: 'conveniance' stamp: 'lr 6/6/2006 14:30'!callback: aBlock	self goto: (canvas context actionUrl 		withParameter: (canvas callbacks 			registerActionCallback: aBlock))! !!SUScript methodsFor: 'adding' stamp: 'lr 8/4/2006 08:48'!effect	^ self add: (SUEffect on: canvas)! !!SUScript methodsFor: 'adding' stamp: 'lr 8/4/2006 08:48'!element	^ self add: (SUElement on: canvas)! !!SUScript methodsFor: 'conveniance' stamp: 'lr 6/6/2006 14:25'!goto: anUrl	self add: (SUStream new nextPutAll: 'window.location='; javascript: anUrl)! !!SUScript methodsFor: 'initialization' stamp: 'lr 5/10/2006 19:47'!initialize	super initialize.	statements := OrderedCollection new! !!SUScript methodsFor: 'printing' stamp: 'lr 5/10/2006 08:44'!printContentOn: aStream	statements 		do: [ :each | aStream javascript: each ]		separatedBy: [ aStream nextPut: $; ]! !!SUScript methodsFor: 'conveniance' stamp: 'lr 6/6/2006 14:25'!refresh	self goto: canvas context actionUrl! !!SUScript methodsFor: 'adding' stamp: 'lr 8/4/2006 09:28'!selector	^ self add: (SUSelector on: canvas)! !!SUElementReference methodsFor: 'accessing' stamp: 'lr 7/3/2006 09:07'!effect	^ self add: (SUEffect new id: self object)! !!SUElementReference methodsFor: 'accessing' stamp: 'lr 7/3/2006 09:07'!element	^ self add: (SUElement new id: self object)! !!SUReference class methodsFor: 'instance-creation' stamp: 'lr 5/12/2006 16:14'!script: aScript argument: anInteger	^ self script: aScript object: (SUStream new 		nextPutAll: 'arguments['; 		javascript: anInteger - 1;		nextPut: $])! !!SUReference class methodsFor: 'instance-creation' stamp: 'lr 5/12/2006 16:12'!script: aScript object: anObject	^ self basicNew initializeWithScript: aScript object: anObject! !!SUReference methodsFor: 'private' stamp: 'lr 7/3/2006 09:07'!add: anObject	self script isNil		ifFalse: [ self script add: anObject ].	^ anObject! !!SUReference methodsFor: 'initialization' stamp: 'lr 5/12/2006 16:09'!initializeWithScript: aScript object: anObject	script := aScript.	object := anObject! !!SUReference methodsFor: 'accessing' stamp: 'lr 5/12/2006 16:09'!object	^ object! !!SUReference methodsFor: 'printing' stamp: 'lr 5/12/2006 16:09'!printOn: aStream	self object javascriptOn: aStream! !!SUReference methodsFor: 'accessing' stamp: 'lr 5/12/2006 16:04'!script	^ script! !!SUStream class methodsFor: 'string-encoding' stamp: 'lr 5/10/2006 20:23'!encode: aString to: aStream	| charOrString |	aStream nextPut: $'.	aString do: [ :char |		charOrString := JavascriptCharacters			at: char asInteger + 1			ifAbsent: [ '\u' , ((char asInteger printStringBase: 16) padded: #left to: 4 with: $0) ].		charOrString isString			ifTrue: [ aStream nextPutAll: charOrString ]			ifFalse: [ aStream nextPut: charOrString ] ].	aStream nextPut: $'! !!SUStream class methodsFor: 'string-encoding' stamp: 'lr 4/21/2006 02:42'!initialize	JavascriptCharacters := Array new: 127.	0 to: 31 do: [ :each |		JavascriptCharacters			at: each + 1			put: '\x' , ((each printStringBase: 16)				padded: #left to: 2 with: $0) ].	32 to: 126 do: [ :each |		JavascriptCharacters			at: each + 1			put: each asCharacter ].	#( 0 '\0' 7 '\a' 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 39 '\''' 92 '\\' )		pairsDo: [ :index :string | JavascriptCharacters at: index + 1 put: string ]! !!SUStream class methodsFor: 'instance-creation' stamp: 'lr 5/10/2006 20:36'!new	^ self basicNew initialize! !!SUStream class methodsFor: 'instance-creation' stamp: 'lr 5/10/2006 20:36'!on: aString	^ self new nextPutAll: aString! !!SUStream methodsFor: 'streaming' stamp: 'lr 8/4/2006 08:37'!argument: anObject	self arguments: (Array with: anObject)! !!SUStream methodsFor: 'streaming' stamp: 'lr 5/10/2006 20:32'!arguments: aCollection	self stream arguments: aCollection! !!SUStream methodsFor: 'accessing' stamp: 'lr 5/1/2006 17:06'!contents	^ self stream contents! !!SUStream methodsFor: 'copying' stamp: 'lr 5/10/2006 20:36'!copy	^ self class on: self contents! !!SUStream methodsFor: 'initialization' stamp: 'lr 5/10/2006 20:36'!initialize	stream := String new writeStream! !!SUStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!javascript: anObject	self stream javascript: anObject! !!SUStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!nextPut: aCharacter	self stream nextPut: aCharacter! !!SUStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!nextPutAll: aString	self stream nextPutAll: aString! !!SUStream methodsFor: 'printing' stamp: 'lr 5/1/2006 17:05'!printOn: aStream	aStream nextPutAll: self contents! !!SUStream methodsFor: 'accessing' stamp: 'lr 5/1/2006 17:06'!stream	^ stream! !!Interval methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:47'!javascriptOn: aStream	aStream nextPutAll: '$R('; javascript: self first; nextPut: $,; javascript: self last; nextPut: $)! !!WARenderingContext methodsFor: '*scriptaculous' stamp: 'lr 2/14/2006 20:55'!callbacks	^ callbacks! !!WARenderingContext methodsFor: '*scriptaculous' stamp: 'lr 4/7/2006 13:40'!storePassenger: anObject	| key |	callbacks at: (key := self advanceKey) put: anObject.	^ key! !!Association methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:46'!javascriptOn: aStream	aStream nextPut: $'; nextPutAll: self key asString.	self value isNil		ifTrue: [ aStream nextPut: $' ]		ifFalse: [ 			aStream nextPut: $=.			self value isString				ifTrue: [ aStream nextPutAll: self value; nextPut: $' ]				ifFalse: [ aStream nextPut: $'; nextPut: $+; javascript: self value ] ]! !!Collection methodsFor: '*scriptaculous' stamp: 'lr 4/11/2006 19:47'!javascriptOn: aStream	aStream nextPut: $[.	self 		do: [ :each | aStream javascript: each ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $]! !!BlockClosure methodsFor: '*scriptaculous' stamp: 'lr 5/12/2006 16:20'!asFunction	^ SUFunction on: nil block: self arguments: (Array new: self numArgs withAll: SUReference)! !!SULightbox methodsFor: 'accessing' stamp: 'lr 7/9/2006 18:43'!lighter	^ 'updateLightbox();window.onresize=function(){updateLightbox();};'! !!SULightbox methodsFor: 'processing' stamp: 'lr 4/19/2006 00:30'!nextPresentersDo: aBlock	super nextPresentersDo: aBlock.	aBlock value: self owner! !!SULightbox methodsFor: 'rendering' stamp: 'lr 4/19/2006 20:28'!renderContentOn: html	self renderOwnerOn: html.	html div id: 'overlay'.	html div id: 'lightbox'; with: self delegate.	html script: self lighter! !!SULightbox methodsFor: 'accessing' stamp: 'lr 4/19/2006 00:12'!rendererClass	^ WARenderCanvas ! !!SULightbox methodsFor: 'accessing' stamp: 'lr 7/9/2006 18:49'!script	^ 'Object.extend(Position, {	windowBounds: function() {		var x = window.innerWidth 			|| document.documentElement.clientWidth			|| document.body.clientWidth			|| 0;		var y = window.innerHeight			|| document.documentElement.clientHeight			|| document.body.clientHeight			|| 0;		return [x, y]; 	}});Object.extend(Element, {	fullscreen: function(element) {		element = $(element);		var bounds = Position.windowBounds();		element.style.position = "absolute";		element.style.left = element.style.top = 0;		element.style.width = bounds[0] + "px";		element.style.height = bounds[1] + "px";	},	center: function(element) {		element = $(element);		var extent = Element.getDimensions(element);		var bounds = Position.windowBounds();		var x = (bounds[0] - extent.width) / 2;		var y = (bounds[1] - extent.height) / 2;		x = x < 0 ? 0 : x; y = y < 0 ? 0 : y;		element.style.position = "absolute";		element.style.left = x + "px";		element.style.top = y + "px";	}});function updateLightbox() {	Element.fullscreen("overlay");	Element.center("lightbox");};'! !!SULightbox methodsFor: 'accessing' stamp: 'lr 4/19/2006 20:30'!style	^ 'html { overflow: hidden; }body { overflow: hidden; }div#overlay {	z-index: 9998;	background-color: black;	filter: alpha(opacity=60);	-moz-opacity: 0.6;	opacity: 0.6;}div#overlay[id] { position: fixed; }div#lightbox { z-index: 9999; }'! !!WASession methodsFor: '*scriptaculous' stamp: 'avi 9/24/2005 19:43'!effect	^ self addLoadScript: SUEffect new! !!Duration methodsFor: '*scriptaculous' stamp: 'lr 4/19/2006 09:45'!javascriptOn: aStream	aStream javascript: self asSeconds! !!WAIframeTag methodsFor: '*scriptaculous' stamp: 'lr 3/10/2006 12:18'!callback: aBlock	self name: (canvas callbacks registerCallback: aBlock)! !!Character methodsFor: '*scriptaculous' stamp: 'lr 7/12/2006 12:09'!javascriptOn: aStream	(String with: self) javascriptOn: aStream! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:40'!aPrototype	^ '/*  Prototype JavaScript framework, version 1.5.0_rc1 *  (c) 2005 Sam Stephenson <sam@conio.net> * *  Prototype is freely distributable under the terms of an MIT-style license. *  For details, see the Prototype web site: http://prototype.conio.net/ */*--------------------------------------------------------------------------*/var Prototype = {  Version: ''1.5.0_rc1'',  ScriptFragment: ''(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)'',  emptyFunction: function() {},  K: function(x) {return x}}var Class = {  create: function() {    return function() {      this.initialize.apply(this, arguments);    }  }}var Abstract = new Object();Object.extend = function(destination, source) {  for (var property in source) {    destination[property] = source[property];  }  return destination;}Object.extend(Object, {  inspect: function(object) {    try {      if (object == undefined) return ''undefined'';      if (object == null) return ''null'';      return object.inspect ? object.inspect() : object.toString();    } catch (e) {      if (e instanceof RangeError) return ''...'';      throw e;    }  },  keys: function(object) {    var keys = [];    for (var property in object)      keys.push(property);    return keys;  },  values: function(object) {    var values = [];    for (var property in object)      values.push(object[property]);    return values;  },  clone: function(object) {    return Object.extend({}, object);  }});Function.prototype.bind = function() {  var __method = this, args = $A(arguments), object = args.shift();  return function() {    return __method.apply(object, args.concat($A(arguments)));  }}Function.prototype.bindAsEventListener = function(object) {  var __method = this, args = $A(arguments), object = args.shift();  return function(event) {    return __method.apply(object, [( event || window.event)].concat(args).concat($A(arguments)));  }}Object.extend(Number.prototype, {  toColorPart: function() {    var digits = this.toString(16);    if (this < 16) return ''0'' + digits;    return digits;  },  succ: function() {    return this + 1;  },  times: function(iterator) {    $R(0, this, true).each(iterator);    return this;  }});var Try = {  these: function() {    var returnValue;    for (var i = 0; i < arguments.length; i++) {      var lambda = arguments[i];      try {        returnValue = lambda();        break;      } catch (e) {}    }    return returnValue;  }}/*--------------------------------------------------------------------------*/var PeriodicalExecuter = Class.create();PeriodicalExecuter.prototype = {  initialize: function(callback, frequency) {    this.callback = callback;    this.frequency = frequency;    this.currentlyExecuting = false;    this.registerCallback();  },  registerCallback: function() {    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);  },  stop: function() {    if (!!this.timer) return;    clearInterval(this.timer);    this.timer = null;  },  onTimerEvent: function() {    if (!!this.currentlyExecuting) {      try {        this.currentlyExecuting = true;        this.callback(this);      } finally {        this.currentlyExecuting = false;      }    }  }}Object.extend(String.prototype, {  gsub: function(pattern, replacement) {    var result = '''', source = this, match;    replacement = arguments.callee.prepareReplacement(replacement);    while (source.length > 0) {      if (match = source.match(pattern)) {        result += source.slice(0, match.index);        result += (replacement(match) || '''').toString();        source  = source.slice(match.index + match[0].length);      } else {        result += source, source = '''';      }    }    return result;  },  sub: function(pattern, replacement, count) {    replacement = this.gsub.prepareReplacement(replacement);    count = count === undefined ? 1 : count;    return this.gsub(pattern, function(match) {      if (--count < 0) return match[0];      return replacement(match);    });  },  scan: function(pattern, iterator) {    this.gsub(pattern, iterator);    return this;  },  truncate: function(length, truncation) {    length = length || 30;    truncation = truncation === undefined ? ''...'' : truncation;    return this.length > length ?      this.slice(0, length - truncation.length) + truncation : this;  },  strip: function() {    return this.replace(/^\s+/, '''').replace(/\s+$/, '''');  },  stripTags: function() {    return this.replace(/<\/?[^>]+>/gi, '''');  },  stripScripts: function() {    return this.replace(new RegExp(Prototype.ScriptFragment, ''img''), '''');  },  extractScripts: function() {    var matchAll = new RegExp(Prototype.ScriptFragment, ''img'');    var matchOne = new RegExp(Prototype.ScriptFragment, ''im'');    return (this.match(matchAll) || []).map(function(scriptTag) {      return (scriptTag.match(matchOne) || ['''', ''''])[1];    });  },  evalScripts: function() {    return this.extractScripts().map(function(script) { return eval(script) });  },  escapeHTML: function() {    var div = document.createElement(''div'');    var text = document.createTextNode(this);    div.appendChild(text);    return div.innerHTML;  },  unescapeHTML: function() {    var div = document.createElement(''div'');    div.innerHTML = this.stripTags();    return div.childNodes[0] ? div.childNodes[0].nodeValue : '''';  },  toQueryParams: function() {    var pairs = this.match(/^\??(.*)$/)[1].split(''&'');    return pairs.inject({}, function(params, pairString) {      var pair  = pairString.split(''='');      var value = pair[1] ? decodeURIComponent(pair[1]) : undefined;      params[decodeURIComponent(pair[0])] = value;      return params;    });  },  toArray: function() {    return this.split('''');  },  camelize: function() {    var oStringList = this.split(''-'');    if (oStringList.length == 1) return oStringList[0];    var camelizedString = this.indexOf(''-'') == 0      ? oStringList[0].charAt(0).toUpperCase() + oStringList[0].substring(1)      : oStringList[0];    for (var i = 1, len = oStringList.length; i < len; i++) {      var s = oStringList[i];      camelizedString += s.charAt(0).toUpperCase() + s.substring(1);    }    return camelizedString;  },  inspect: function(useDoubleQuotes) {    var escapedString = this.replace(/\\/g, ''\\\\'');    if (useDoubleQuotes)      return ''"'' + escapedString.replace(/"/g, ''\\"'') + ''"'';    else      return "''" + escapedString.replace(/''/g, ''\\\'''') + "''";  }});String.prototype.gsub.prepareReplacement = function(replacement) {  if (typeof replacement == ''function'') return replacement;  var template = new Template(replacement);  return function(match) { return template.evaluate(match) };}String.prototype.parseQuery = String.prototype.toQueryParams;var Template = Class.create();Template.Pattern = /(^|.|\r|\n)(#\{(.*?)\})/;Template.prototype = {  initialize: function(template, pattern) {    this.template = template.toString();    this.pattern  = pattern || Template.Pattern;  },  evaluate: function(object) {    return this.template.gsub(this.pattern, function(match) {      var before = match[1];      if (before == ''\\'') return match[2];      return before + (object[match[3]] || '''').toString();    });  }}var $break    = new Object();var $continue = new Object();var Enumerable = {  each: function(iterator) {    var index = 0;    try {      this._each(function(value) {        try {          iterator(value, index++);        } catch (e) {          if (e !!= $continue) throw e;        }      });    } catch (e) {      if (e !!= $break) throw e;    }  },  all: function(iterator) {    var result = true;    this.each(function(value, index) {      result = result && !!!!(iterator || Prototype.K)(value, index);      if (!!result) throw $break;    });    return result;  },  any: function(iterator) {    var result = false;    this.each(function(value, index) {      if (result = !!!!(iterator || Prototype.K)(value, index))        throw $break;    });    return result;  },  collect: function(iterator) {    var results = [];    this.each(function(value, index) {      results.push(iterator(value, index));    });    return results;  },  detect: function (iterator) {    var result;    this.each(function(value, index) {      if (iterator(value, index)) {        result = value;        throw $break;      }    });    return result;  },  findAll: function(iterator) {    var results = [];    this.each(function(value, index) {      if (iterator(value, index))        results.push(value);    });    return results;  },  grep: function(pattern, iterator) {    var results = [];    this.each(function(value, index) {      var stringValue = value.toString();      if (stringValue.match(pattern))        results.push((iterator || Prototype.K)(value, index));    })    return results;  },  include: function(object) {    var found = false;    this.each(function(value) {      if (value == object) {        found = true;        throw $break;      }    });    return found;  },  inject: function(memo, iterator) {    this.each(function(value, index) {      memo = iterator(memo, value, index);    });    return memo;  },  invoke: function(method) {    var args = $A(arguments).slice(1);    return this.collect(function(value) {      return value[method].apply(value, args);    });  },  max: function(iterator) {    var result;    this.each(function(value, index) {      value = (iterator || Prototype.K)(value, index);      if (result == undefined || value >= result)        result = value;    });    return result;  },  min: function(iterator) {    var result;    this.each(function(value, index) {      value = (iterator || Prototype.K)(value, index);      if (result == undefined || value < result)        result = value;    });    return result;  },  partition: function(iterator) {    var trues = [], falses = [];    this.each(function(value, index) {      ((iterator || Prototype.K)(value, index) ?        trues : falses).push(value);    });    return [trues, falses];  },  pluck: function(property) {    var results = [];    this.each(function(value, index) {      results.push(value[property]);    });    return results;  },  reject: function(iterator) {    var results = [];    this.each(function(value, index) {      if (!!iterator(value, index))        results.push(value);    });    return results;  },  sortBy: function(iterator) {    return this.collect(function(value, index) {      return {value: value, criteria: iterator(value, index)};    }).sort(function(left, right) {      var a = left.criteria, b = right.criteria;      return a < b ? -1 : a > b ? 1 : 0;    }).pluck(''value'');  },  toArray: function() {    return this.collect(Prototype.K);  },  zip: function() {    var iterator = Prototype.K, args = $A(arguments);    if (typeof args.last() == ''function'')      iterator = args.pop();    var collections = [this].concat(args).map($A);    return this.map(function(value, index) {      return iterator(collections.pluck(index));    });  },  inspect: function() {    return ''#<Enumerable:'' + this.toArray().inspect() + ''>'';  }}Object.extend(Enumerable, {  map:     Enumerable.collect,  find:    Enumerable.detect,  select:  Enumerable.findAll,  member:  Enumerable.include,  entries: Enumerable.toArray});var $A = Array.from = function(iterable) {  if (!!iterable) return [];  if (iterable.toArray) {    return iterable.toArray();  } else {    var results = [];    for (var i = 0; i < iterable.length; i++)      results.push(iterable[i]);    return results;  }}Object.extend(Array.prototype, Enumerable);if (!!Array.prototype._reverse)  Array.prototype._reverse = Array.prototype.reverse;Object.extend(Array.prototype, {  _each: function(iterator) {    for (var i = 0; i < this.length; i++)      iterator(this[i]);  },  clear: function() {    this.length = 0;    return this;  },  first: function() {    return this[0];  },  last: function() {    return this[this.length - 1];  },  compact: function() {    return this.select(function(value) {      return value !!= undefined || value !!= null;    });  },  flatten: function() {    return this.inject([], function(array, value) {      return array.concat(value && value.constructor == Array ?        value.flatten() : [value]);    });  },  without: function() {    var values = $A(arguments);    return this.select(function(value) {      return !!values.include(value);    });  },  indexOf: function(object) {    for (var i = 0; i < this.length; i++)      if (this[i] == object) return i;    return -1;  },  reverse: function(inline) {    return (inline !!== false ? this : this.toArray())._reverse();  },  reduce: function() {    return this.length > 1 ? this : this[0];  },  uniq: function() {    return this.inject([], function(array, value) {      return array.include(value) ? array : array.concat([value]);    });  },  inspect: function() {    return ''['' + this.map(Object.inspect).join('', '') + '']'';  }});var Hash = {  _each: function(iterator) {    for (var key in this) {      var value = this[key];      if (typeof value == ''function'') continue;      var pair = [key, value];      pair.key = key;      pair.value = value;      iterator(pair);    }  },  keys: function() {    return this.pluck(''key'');  },  values: function() {    return this.pluck(''value'');  },  merge: function(hash) {    return $H(hash).inject($H(this), function(mergedHash, pair) {      mergedHash[pair.key] = pair.value;      return mergedHash;    });  },  toQueryString: function() {    return this.map(function(pair) {      return pair.map(encodeURIComponent).join(''='');    }).join(''&'');  },  inspect: function() {    return ''#<Hash:{'' + this.map(function(pair) {      return pair.map(Object.inspect).join('': '');    }).join('', '') + ''}>'';  }}function $H(object) {  var hash = Object.extend({}, object || {});  Object.extend(hash, Enumerable);  Object.extend(hash, Hash);  return hash;}ObjectRange = Class.create();Object.extend(ObjectRange.prototype, Enumerable);Object.extend(ObjectRange.prototype, {  initialize: function(start, end, exclusive) {    this.start = start;    this.end = end;    this.exclusive = exclusive;  },  _each: function(iterator) {    var value = this.start;    while (this.include(value)) {      iterator(value);      value = value.succ();    }  },  include: function(value) {    if (value < this.start)      return false;    if (this.exclusive)      return value < this.end;    return value <= this.end;  }});var $R = function(start, end, exclusive) {  return new ObjectRange(start, end, exclusive);}var Ajax = {  getTransport: function() {    return Try.these(      function() {return new XMLHttpRequest()},      function() {return new ActiveXObject(''Msxml2.XMLHTTP'')},      function() {return new ActiveXObject(''Microsoft.XMLHTTP'')}    ) || false;  },  activeRequestCount: 0}Ajax.Responders = {  responders: [],  _each: function(iterator) {    this.responders._each(iterator);  },  register: function(responderToAdd) {    if (!!this.include(responderToAdd))      this.responders.push(responderToAdd);  },  unregister: function(responderToRemove) {    this.responders = this.responders.without(responderToRemove);  },  dispatch: function(callback, request, transport, json) {    this.each(function(responder) {      if (responder[callback] && typeof responder[callback] == ''function'') {        try {          responder[callback].apply(responder, [request, transport, json]);        } catch (e) {}      }    });  }};Object.extend(Ajax.Responders, Enumerable);Ajax.Responders.register({  onCreate: function() {    Ajax.activeRequestCount++;  },  onComplete: function() {    Ajax.activeRequestCount--;  }});Ajax.Base = function() {};Ajax.Base.prototype = {  setOptions: function(options) {    this.options = {      method:       ''post'',      asynchronous: true,      contentType:  ''application/x-www-form-urlencoded'',      parameters:   ''''    }    Object.extend(this.options, options || {});  },  responseIsSuccess: function() {    return this.transport.status == undefined        || this.transport.status == 0        || (this.transport.status >= 200 && this.transport.status < 300);  },  responseIsFailure: function() {    return !!this.responseIsSuccess();  }}Ajax.Request = Class.create();Ajax.Request.Events =  [''Uninitialized'', ''Loading'', ''Loaded'', ''Interactive'', ''Complete''];Ajax.Request.prototype = Object.extend(new Ajax.Base(), {  initialize: function(url, options) {    this.transport = Ajax.getTransport();    this.setOptions(options);    this.request(url);  },  request: function(url) {    var parameters = this.options.parameters || '''';    if (parameters.length > 0) parameters += ''&_='';    /* Simulate other verbs over post */    if (this.options.method !!= ''get'' && this.options.method !!= ''post'') {      parameters += (parameters.length > 0 ? ''&'' : '''') + ''_method='' + this.options.method;      this.options.method = ''post'';    }    try {      this.url = url;      if (this.options.method == ''get'' && parameters.length > 0)        this.url += (this.url.match(/\?/) ? ''&'' : ''?'') + parameters;      Ajax.Responders.dispatch(''onCreate'', this, this.transport);      this.transport.open(this.options.method, this.url,        this.options.asynchronous);      if (this.options.asynchronous)        setTimeout(function() { this.respondToReadyState(1) }.bind(this), 10);      this.transport.onreadystatechange = this.onStateChange.bind(this);      this.setRequestHeaders();      var body = this.options.postBody ? this.options.postBody : parameters;      this.transport.send(this.options.method == ''post'' ? body : null);      /* Force Firefox to handle ready state 4 for synchronous requests */      if (!!this.options.asynchronous && this.transport.overrideMimeType)        this.onStateChange();    } catch (e) {      this.dispatchException(e);    }  },  setRequestHeaders: function() {    var requestHeaders =      [''X-Requested-With'', ''XMLHttpRequest'',       ''X-Prototype-Version'', Prototype.Version,       ''Accept'', ''text/javascript, text/html, application/xml, text/xml, */*''];    if (this.options.method == ''post'') {      requestHeaders.push(''Content-type'', this.options.contentType);      /* Force "Connection: close" for Mozilla browsers to work around       * a bug where XMLHttpReqeuest sends an incorrect Content-length       * header. See Mozilla Bugzilla #246651.       */      if (this.transport.overrideMimeType)        requestHeaders.push(''Connection'', ''close'');    }    if (this.options.requestHeaders)      requestHeaders.push.apply(requestHeaders, this.options.requestHeaders);    for (var i = 0; i < requestHeaders.length; i += 2)      this.transport.setRequestHeader(requestHeaders[i], requestHeaders[i+1]);  },  onStateChange: function() {    var readyState = this.transport.readyState;    if (readyState !!= 1)      this.respondToReadyState(this.transport.readyState);  },  header: function(name) {    try {      return this.transport.getResponseHeader(name);    } catch (e) {}  },  evalJSON: function() {    try {      return eval(''('' + this.header(''X-JSON'') + '')'');    } catch (e) {}  },  evalResponse: function() {    try {      return eval(this.transport.responseText);    } catch (e) {      this.dispatchException(e);    }  },  respondToReadyState: function(readyState) {    var event = Ajax.Request.Events[readyState];    var transport = this.transport, json = this.evalJSON();    if (event == ''Complete'') {      try {        (this.options[''on'' + this.transport.status]         || this.options[''on'' + (this.responseIsSuccess() ? ''Success'' : ''Failure'')]         || Prototype.emptyFunction)(transport, json);      } catch (e) {        this.dispatchException(e);      }      if ((this.header(''Content-type'') || '''').match(/^text\/javascript/i))        this.evalResponse();    }    try {      (this.options[''on'' + event] || Prototype.emptyFunction)(transport, json);      Ajax.Responders.dispatch(''on'' + event, this, transport, json);    } catch (e) {      this.dispatchException(e);    }    /* Avoid memory leak in MSIE: clean up the oncomplete event handler */    if (event == ''Complete'')      this.transport.onreadystatechange = Prototype.emptyFunction;  },  dispatchException: function(exception) {    (this.options.onException || Prototype.emptyFunction)(this, exception);    Ajax.Responders.dispatch(''onException'', this, exception);  }});Ajax.Updater = Class.create();Object.extend(Object.extend(Ajax.Updater.prototype, Ajax.Request.prototype), {  initialize: function(container, url, options) {    this.containers = {      success: container.success ? $(container.success) : $(container),      failure: container.failure ? $(container.failure) :        (container.success ? null : $(container))    }    this.transport = Ajax.getTransport();    this.setOptions(options);    var onComplete = this.options.onComplete || Prototype.emptyFunction;    this.options.onComplete = (function(transport, object) {      this.updateContent();      onComplete(transport, object);    }).bind(this);    this.request(url);  },  updateContent: function() {    var receiver = this.responseIsSuccess() ?      this.containers.success : this.containers.failure;    var response = this.transport.responseText;    if (!!this.options.evalScripts)      response = response.stripScripts();    if (receiver) {      if (this.options.insertion) {        new this.options.insertion(receiver, response);      } else {        Element.update(receiver, response);      }    }    if (this.responseIsSuccess()) {      if (this.onComplete)        setTimeout(this.onComplete.bind(this), 10);    }  }});Ajax.PeriodicalUpdater = Class.create();Ajax.PeriodicalUpdater.prototype = Object.extend(new Ajax.Base(), {  initialize: function(container, url, options) {    this.setOptions(options);    this.onComplete = this.options.onComplete;    this.frequency = (this.options.frequency || 2);    this.decay = (this.options.decay || 1);    this.updater = {};    this.container = container;    this.url = url;    this.start();  },  start: function() {    this.options.onComplete = this.updateComplete.bind(this);    this.onTimerEvent();  },  stop: function() {    this.updater.options.onComplete = undefined;    clearTimeout(this.timer);    (this.onComplete || Prototype.emptyFunction).apply(this, arguments);  },  updateComplete: function(request) {    if (this.options.decay) {      this.decay = (request.responseText == this.lastText ?        this.decay * this.options.decay : 1);      this.lastText = request.responseText;    }    this.timer = setTimeout(this.onTimerEvent.bind(this),      this.decay * this.frequency * 1000);  },  onTimerEvent: function() {    this.updater = new Ajax.Updater(this.container, this.url, this.options);  }});function $() {  var results = [], element;  for (var i = 0; i < arguments.length; i++) {    element = arguments[i];    if (typeof element == ''string'')      element = document.getElementById(element);    results.push(Element.extend(element));  }  return results.reduce();}document.getElementsByClassName = function(className, parentElement) {  var children = ($(parentElement) || document.body).getElementsByTagName(''*'');  return $A(children).inject([], function(elements, child) {    if (child.className.match(new RegExp("(^|\\s)" + className + "(\\s|$)")))      elements.push(Element.extend(child));    return elements;  });}/*--------------------------------------------------------------------------*/if (!!window.Element)  var Element = new Object();Element.extend = function(element) {  if (!!element) return;  if (_nativeExtensions || element.nodeType == 3) return element;  if (!!element._extended && element.tagName && element !!= window) {    var methods = Object.clone(Element.Methods), cache = Element.extend.cache;    if (element.tagName == ''FORM'')      Object.extend(methods, Form.Methods);    if ([''INPUT'', ''TEXTAREA'', ''SELECT''].include(element.tagName))      Object.extend(methods, Form.Element.Methods);    for (var property in methods) {      var value = methods[property];      if (typeof value == ''function'')        element[property] = cache.findOrStore(value);    }  }  element._extended = true;  return element;}Element.extend.cache = {  findOrStore: function(value) {    return this[value] = this[value] || function() {      return value.apply(null, [this].concat($A(arguments)));    }  }}Element.Methods = {  visible: function(element) {    return $(element).style.display !!= ''none'';  },  toggle: function(element) {    element = $(element);    Element[Element.visible(element) ? ''hide'' : ''show''](element);    return element;  },  hide: function(element) {    $(element).style.display = ''none'';    return element;  },  show: function(element) {    $(element).style.display = '''';    return element;  },  remove: function(element) {    element = $(element);    element.parentNode.removeChild(element);    return element;  },  update: function(element, html) {    $(element).innerHTML = html.stripScripts();    setTimeout(function() {html.evalScripts()}, 10);    return element;  },  replace: function(element, html) {    element = $(element);    if (element.outerHTML) {      element.outerHTML = html.stripScripts();    } else {      var range = element.ownerDocument.createRange();      range.selectNodeContents(element);      element.parentNode.replaceChild(        range.createContextualFragment(html.stripScripts()), element);    }    setTimeout(function() {html.evalScripts()}, 10);    return element;  },  inspect: function(element) {    element = $(element);    var result = ''<'' + element.tagName.toLowerCase();    $H({''id'': ''id'', ''className'': ''class''}).each(function(pair) {      var property = pair.first(), attribute = pair.last();      var value = (element[property] || '''').toString();      if (value) result += '' '' + attribute + ''='' + value.inspect(true);    });    return result + ''>'';  },  recursivelyCollect: function(element, property) {    element = $(element);    var elements = [];    while (element = element[property])      if (element.nodeType == 1)        elements.push(Element.extend(element));    return elements;  },  ancestors: function(element) {    return $(element).recursivelyCollect(''parentNode'');  },  descendants: function(element) {    element = $(element);    return $A(element.getElementsByTagName(''*''));  },  previousSiblings: function(element) {    return $(element).recursivelyCollect(''previousSibling'');  },  nextSiblings: function(element) {    return $(element).recursivelyCollect(''nextSibling'');  },  siblings: function(element) {    element = $(element);    return element.previousSiblings().reverse().concat(element.nextSiblings());  },  match: function(element, selector) {    element = $(element);    if (typeof selector == ''string'')      selector = new Selector(selector);    return selector.match(element);  },  up: function(element, expression, index) {    return Selector.findElement($(element).ancestors(), expression, index);  },  down: function(element, expression, index) {    return Selector.findElement($(element).descendants(), expression, index);  },  previous: function(element, expression, index) {    return Selector.findElement($(element).previousSiblings(), expression, index);  },  next: function(element, expression, index) {    return Selector.findElement($(element).nextSiblings(), expression, index);  },  getElementsBySelector: function() {    var args = $A(arguments), element = $(args.shift());    return Selector.findChildElements(element, args);  },  getElementsByClassName: function(element, className) {    element = $(element);    return document.getElementsByClassName(className, element);  },  getHeight: function(element) {    element = $(element);    return element.offsetHeight;  },  classNames: function(element) {    return new Element.ClassNames(element);  },  hasClassName: function(element, className) {    if (!!(element = $(element))) return;    return Element.classNames(element).include(className);  },  addClassName: function(element, className) {    if (!!(element = $(element))) return;    Element.classNames(element).add(className);    return element;  },  removeClassName: function(element, className) {    if (!!(element = $(element))) return;    Element.classNames(element).remove(className);    return element;  },  observe: function() {    Event.observe.apply(Event, arguments);    return $A(arguments).first();  },  stopObserving: function() {    Event.stopObserving.apply(Event, arguments);    return $A(arguments).first();  },  // removes whitespace-only text node children  cleanWhitespace: function(element) {    element = $(element);    var node = element.firstChild;    while (node) {      var nextNode = node.nextSibling;      if (node.nodeType == 3 && !!/\S/.test(node.nodeValue))        element.removeChild(node);      node = nextNode;    }    return element;  },  empty: function(element) {    return $(element).innerHTML.match(/^\s*$/);  },  childOf: function(element, ancestor) {    element = $(element), ancestor = $(ancestor);    while (element = element.parentNode)      if (element == ancestor) return true;    return false;  },  scrollTo: function(element) {    element = $(element);    var x = element.x ? element.x : element.offsetLeft,        y = element.y ? element.y : element.offsetTop;    window.scrollTo(x, y);    return element;  },  getStyle: function(element, style) {    element = $(element);    var value = element.style[style.camelize()];    if (!!value) {      if (document.defaultView && document.defaultView.getComputedStyle) {        var css = document.defaultView.getComputedStyle(element, null);        value = css ? css.getPropertyValue(style) : null;      } else if (element.currentStyle) {        value = element.currentStyle[style.camelize()];      }    }    if (window.opera && [''left'', ''top'', ''right'', ''bottom''].include(style))      if (Element.getStyle(element, ''position'') == ''static'') value = ''auto'';    return value == ''auto'' ? null : value;  },  setStyle: function(element, style) {    element = $(element);    for (var name in style)      element.style[name.camelize()] = style[name];    return element;  },  getDimensions: function(element) {    element = $(element);    if (Element.getStyle(element, ''display'') !!= ''none'')      return {width: element.offsetWidth, height: element.offsetHeight};    // All *Width and *Height properties give 0 on elements with display none,    // so enable the element temporarily    var els = element.style;    var originalVisibility = els.visibility;    var originalPosition = els.position;    els.visibility = ''hidden'';    els.position = ''absolute'';    els.display = '''';    var originalWidth = element.clientWidth;    var originalHeight = element.clientHeight;    els.display = ''none'';    els.position = originalPosition;    els.visibility = originalVisibility;    return {width: originalWidth, height: originalHeight};  },  makePositioned: function(element) {    element = $(element);    var pos = Element.getStyle(element, ''position'');    if (pos == ''static'' || !!pos) {      element._madePositioned = true;      element.style.position = ''relative'';      // Opera returns the offset relative to the positioning context, when an      // element is position relative but top and left have not been defined      if (window.opera) {        element.style.top = 0;        element.style.left = 0;      }    }    return element;  },  undoPositioned: function(element) {    element = $(element);    if (element._madePositioned) {      element._madePositioned = undefined;      element.style.position =        element.style.top =        element.style.left =        element.style.bottom =        element.style.right = '''';    }    return element;  },  makeClipping: function(element) {    element = $(element);    if (element._overflow) return;    element._overflow = element.style.overflow || ''auto'';    if ((Element.getStyle(element, ''overflow'') || ''visible'') !!= ''hidden'')      element.style.overflow = ''hidden'';    return element;  },  undoClipping: function(element) {    element = $(element);    if (!!element._overflow) return;    element.style.overflow = element._overflow == ''auto'' ? '''' : element._overflow;    element._overflow = null;    return element;  }}// IE is missing .innerHTML support for TABLE-related elementsif(document.all){  Element.Methods.update = function(element, html) {    element = $(element);    var tagName = element.tagName.toUpperCase();    if ([''THEAD'',''TBODY'',''TR'',''TD''].indexOf(tagName) > -1) {      var div = document.createElement(''div'');      switch (tagName) {        case ''THEAD'':        case ''TBODY'':          div.innerHTML = ''<table><tbody>'' +  html.stripScripts() + ''</tbody></table>'';          depth = 2;          break;        case ''TR'':          div.innerHTML = ''<table><tbody><tr>'' +  html.stripScripts() + ''</tr></tbody></table>'';          depth = 3;          break;        case ''TD'':          div.innerHTML = ''<table><tbody><tr><td>'' +  html.stripScripts() + ''</td></tr></tbody></table>'';          depth = 4;      }      $A(element.childNodes).each(function(node){        element.removeChild(node)      });      depth.times(function(){ div = div.firstChild });      $A(div.childNodes).each(        function(node){ element.appendChild(node) });    } else {      element.innerHTML = html.stripScripts();    }    setTimeout(function() {html.evalScripts()}, 10);    return element;  }}Object.extend(Element, Element.Methods);var _nativeExtensions = false;if (!!window.HTMLElement && /Konqueror|Safari|KHTML/.test(navigator.userAgent)) {  /* Emulate HTMLElement, HTMLFormElement, HTMLInputElement, HTMLTextAreaElement,     and HTMLSelectElement in Safari */  ['''', ''Form'', ''Input'', ''TextArea'', ''Select''].each(function(tag) {    var klass = window[''HTML'' + tag + ''Element''] = {};    klass.prototype = document.createElement(tag ? tag.toLowerCase() : ''div'').__proto__;  });}Element.addMethods = function(methods) {  Object.extend(Element.Methods, methods || {});  function copy(methods, destination) {    var cache = Element.extend.cache;    for (var property in methods) {      var value = methods[property];      destination[property] = cache.findOrStore(value);    }  }  if (typeof HTMLElement !!= ''undefined'') {    copy(Element.Methods, HTMLElement.prototype);    copy(Form.Methods, HTMLFormElement.prototype);    [HTMLInputElement, HTMLTextAreaElement, HTMLSelectElement].each(function(klass) {      copy(Form.Element.Methods, klass.prototype);    });    _nativeExtensions = true;  }}var Toggle = new Object();Toggle.display = Element.toggle;/*--------------------------------------------------------------------------*/Abstract.Insertion = function(adjacency) {  this.adjacency = adjacency;}Abstract.Insertion.prototype = {  initialize: function(element, content) {    this.element = $(element);    this.content = content.stripScripts();    if (this.adjacency && this.element.insertAdjacentHTML) {      try {        this.element.insertAdjacentHTML(this.adjacency, this.content);      } catch (e) {        var tagName = this.element.tagName.toLowerCase();        if (tagName == ''tbody'' || tagName == ''tr'') {          this.insertContent(this.contentFromAnonymousTable());        } else {          throw e;        }      }    } else {      this.range = this.element.ownerDocument.createRange();      if (this.initializeRange) this.initializeRange();      this.insertContent([this.range.createContextualFragment(this.content)]);    }    setTimeout(function() {content.evalScripts()}, 10);  },  contentFromAnonymousTable: function() {    var div = document.createElement(''div'');    div.innerHTML = ''<table><tbody>'' + this.content + ''</tbody></table>'';    return $A(div.childNodes[0].childNodes[0].childNodes);  }}var Insertion = new Object();Insertion.Before = Class.create();Insertion.Before.prototype = Object.extend(new Abstract.Insertion(''beforeBegin''), {  initializeRange: function() {    this.range.setStartBefore(this.element);  },  insertContent: function(fragments) {    fragments.each((function(fragment) {      this.element.parentNode.insertBefore(fragment, this.element);    }).bind(this));  }});Insertion.Top = Class.create();Insertion.Top.prototype = Object.extend(new Abstract.Insertion(''afterBegin''), {  initializeRange: function() {    this.range.selectNodeContents(this.element);    this.range.collapse(true);  },  insertContent: function(fragments) {    fragments.reverse(false).each((function(fragment) {      this.element.insertBefore(fragment, this.element.firstChild);    }).bind(this));  }});Insertion.Bottom = Class.create();Insertion.Bottom.prototype = Object.extend(new Abstract.Insertion(''beforeEnd''), {  initializeRange: function() {    this.range.selectNodeContents(this.element);    this.range.collapse(this.element);  },  insertContent: function(fragments) {    fragments.each((function(fragment) {      this.element.appendChild(fragment);    }).bind(this));  }});Insertion.After = Class.create();Insertion.After.prototype = Object.extend(new Abstract.Insertion(''afterEnd''), {  initializeRange: function() {    this.range.setStartAfter(this.element);  },  insertContent: function(fragments) {    fragments.each((function(fragment) {      this.element.parentNode.insertBefore(fragment,        this.element.nextSibling);    }).bind(this));  }});/*--------------------------------------------------------------------------*/Element.ClassNames = Class.create();Element.ClassNames.prototype = {  initialize: function(element) {    this.element = $(element);  },  _each: function(iterator) {    this.element.className.split(/\s+/).select(function(name) {      return name.length > 0;    })._each(iterator);  },  set: function(className) {    this.element.className = className;  },  add: function(classNameToAdd) {    if (this.include(classNameToAdd)) return;    this.set(this.toArray().concat(classNameToAdd).join('' ''));  },  remove: function(classNameToRemove) {    if (!!this.include(classNameToRemove)) return;    this.set(this.select(function(className) {      return className !!= classNameToRemove;    }).join('' ''));  },  toString: function() {    return this.toArray().join('' '');  }}Object.extend(Element.ClassNames.prototype, Enumerable);var Selector = Class.create();Selector.prototype = {  initialize: function(expression) {    this.params = {classNames: []};    this.expression = expression.toString().strip();    this.parseExpression();    this.compileMatcher();  },  parseExpression: function() {    function abort(message) { throw ''Parse error in selector: '' + message; }    if (this.expression == '''')  abort(''empty expression'');    var params = this.params, expr = this.expression, match, modifier, clause, rest;    while (match = expr.match(/^(.*)\[([a-z0-9_:-]+?)(?:([~\|!!]?=)(?:"([^"]*)"|([^\]\s]*)))?\]$/i)) {      params.attributes = params.attributes || [];      params.attributes.push({name: match[2], operator: match[3], value: match[4] || match[5] || ''''});      expr = match[1];    }    if (expr == ''*'') return this.params.wildcard = true;    while (match = expr.match(/^([^a-z0-9_-])?([a-z0-9_-]+)(.*)/i)) {      modifier = match[1], clause = match[2], rest = match[3];      switch (modifier) {        case ''#'':       params.id = clause; break;        case ''.'':       params.classNames.push(clause); break;        case '''':        case undefined: params.tagName = clause.toUpperCase(); break;        default:        abort(expr.inspect());      }      expr = rest;    }    if (expr.length > 0) abort(expr.inspect());  },  buildMatchExpression: function() {    var params = this.params, conditions = [], clause;    if (params.wildcard)      conditions.push(''true'');    if (clause = params.id)      conditions.push(''element.id == '' + clause.inspect());    if (clause = params.tagName)      conditions.push(''element.tagName.toUpperCase() == '' + clause.inspect());    if ((clause = params.classNames).length > 0)      for (var i = 0; i < clause.length; i++)        conditions.push(''Element.hasClassName(element, '' + clause[i].inspect() + '')'');    if (clause = params.attributes) {      clause.each(function(attribute) {        var value = ''element.getAttribute('' + attribute.name.inspect() + '')'';        var splitValueBy = function(delimiter) {          return value + '' && '' + value + ''.split('' + delimiter.inspect() + '')'';        }        switch (attribute.operator) {          case ''='':       conditions.push(value + '' == '' + attribute.value.inspect()); break;          case ''~='':      conditions.push(splitValueBy('' '') + ''.include('' + attribute.value.inspect() + '')''); break;          case ''|='':      conditions.push(                            splitValueBy(''-'') + ''.first().toUpperCase() == '' + attribute.value.toUpperCase().inspect()                          ); break;          case ''!!='':      conditions.push(value + '' !!= '' + attribute.value.inspect()); break;          case '''':          case undefined: conditions.push(value + '' !!= null''); break;          default:        throw ''Unknown operator '' + attribute.operator + '' in selector'';        }      });    }    return conditions.join('' && '');  },  compileMatcher: function() {    this.match = new Function(''element'', ''if (!!element.tagName) return false; \      return '' + this.buildMatchExpression());  },  findElements: function(scope) {    var element;    if (element = $(this.params.id))      if (this.match(element))        if (!!scope || Element.childOf(element, scope))          return [element];    scope = (scope || document).getElementsByTagName(this.params.tagName || ''*'');    var results = [];    for (var i = 0; i < scope.length; i++)      if (this.match(element = scope[i]))        results.push(Element.extend(element));    return results;  },  toString: function() {    return this.expression;  }}Object.extend(Selector, {  matchElements: function(elements, expression) {    var selector = new Selector(expression);    return elements.select(selector.match.bind(selector));  },  findElement: function(elements, expression, index) {    if (typeof expression == ''number'') index = expression, expression = false;    return Selector.matchElements(elements, expression || ''*'')[index || 0];  },  findChildElements: function(element, expressions) {    return expressions.map(function(expression) {      return expression.strip().split(/\s+/).inject([null], function(results, expr) {        var selector = new Selector(expr);        return results.inject([], function(elements, result) {          return elements.concat(selector.findElements(result || element));        });      });    }).flatten();  }});function $$() {  return Selector.findChildElements(document, $A(arguments));}var Form = {  reset: function(form) {    $(form).reset();    return form;  }};Form.Methods = {  serialize: function(form) {    var elements = Form.getElements($(form));    var queryComponents = new Array();    for (var i = 0; i < elements.length; i++) {      var queryComponent = Form.Element.serialize(elements[i]);      if (queryComponent)        queryComponents.push(queryComponent);    }    return queryComponents.join(''&'');  },  getElements: function(form) {    form = $(form);    var elements = new Array();    for (var tagName in Form.Element.Serializers) {      var tagElements = form.getElementsByTagName(tagName);      for (var j = 0; j < tagElements.length; j++)        elements.push(tagElements[j]);    }    return elements;  },  getInputs: function(form, typeName, name) {    form = $(form);    var inputs = form.getElementsByTagName(''input'');    if (!!typeName && !!name)      return inputs;    var matchingInputs = new Array();    for (var i = 0; i < inputs.length; i++) {      var input = inputs[i];      if ((typeName && input.type !!= typeName) ||          (name && input.name !!= name))        continue;      matchingInputs.push(input);    }    return matchingInputs;  },  disable: function(form) {    form = $(form);    var elements = Form.getElements(form);    for (var i = 0; i < elements.length; i++) {      var element = elements[i];      element.blur();      element.disabled = ''true'';    }    return form;  },  enable: function(form) {    form = $(form);    var elements = Form.getElements(form);    for (var i = 0; i < elements.length; i++) {      var element = elements[i];      element.disabled = '''';    }    return form;  },  findFirstElement: function(form) {    return Form.getElements(form).find(function(element) {      return element.type !!= ''hidden'' && !!element.disabled &&        [''input'', ''select'', ''textarea''].include(element.tagName.toLowerCase());    });  },  focusFirstElement: function(form) {    form = $(form);    Field.activate(Form.findFirstElement(form));    return form;  }}Object.extend(Form, Form.Methods);/*--------------------------------------------------------------------------*/Form.Element = {  focus: function(element) {    $(element).focus();    return element;  },  select: function(element) {    $(element).select();    return element;  }}Form.Element.Methods = {  serialize: function(element) {    element = $(element);    var method = element.tagName.toLowerCase();    var parameter = Form.Element.Serializers[method](element);    if (parameter) {      var key = encodeURIComponent(parameter[0]);      if (key.length == 0) return;      if (parameter[1].constructor !!= Array)        parameter[1] = [parameter[1]];      return parameter[1].map(function(value) {        return key + ''='' + encodeURIComponent(value);      }).join(''&'');    }  },  getValue: function(element) {    element = $(element);    var method = element.tagName.toLowerCase();    var parameter = Form.Element.Serializers[method](element);    if (parameter)      return parameter[1];  },  clear: function(element) {    $(element).value = '''';    return element;  },  present: function(element) {    return $(element).value !!= '''';  },  activate: function(element) {    element = $(element);    element.focus();    if (element.select)      element.select();    return element;  },  disable: function(element) {    element = $(element);    element.disabled = '''';    return element;  },  enable: function(element) {    element = $(element);    element.blur();    element.disabled = ''true'';    return element;  }}Object.extend(Form.Element, Form.Element.Methods);var Field = Form.Element;/*--------------------------------------------------------------------------*/Form.Element.Serializers = {  input: function(element) {    switch (element.type.toLowerCase()) {      case ''checkbox'':      case ''radio'':        return Form.Element.Serializers.inputSelector(element);      default:        return Form.Element.Serializers.textarea(element);    }    return false;  },  inputSelector: function(element) {    if (element.checked)      return [element.name, element.value];  },  textarea: function(element) {    return [element.name, element.value];  },  select: function(element) {    return Form.Element.Serializers[element.type == ''select-one'' ?      ''selectOne'' : ''selectMany''](element);  },  selectOne: function(element) {    var value = '''', opt, index = element.selectedIndex;    if (index >= 0) {      opt = element.options[index];      value = opt.value || opt.text;    }    return [element.name, value];  },  selectMany: function(element) {    var value = [];    for (var i = 0; i < element.length; i++) {      var opt = element.options[i];      if (opt.selected)        value.push(opt.value || opt.text);    }    return [element.name, value];  }}/*--------------------------------------------------------------------------*/var $F = Form.Element.getValue;/*--------------------------------------------------------------------------*/Abstract.TimedObserver = function() {}Abstract.TimedObserver.prototype = {  initialize: function(element, frequency, callback) {    this.frequency = frequency;    this.element   = $(element);    this.callback  = callback;    this.lastValue = this.getValue();    this.registerCallback();  },  registerCallback: function() {    setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);  },  onTimerEvent: function() {    var value = this.getValue();    if (this.lastValue !!= value) {      this.callback(this.element, value);      this.lastValue = value;    }  }}Form.Element.Observer = Class.create();Form.Element.Observer.prototype = Object.extend(new Abstract.TimedObserver(), {  getValue: function() {    return Form.Element.getValue(this.element);  }});Form.Observer = Class.create();Form.Observer.prototype = Object.extend(new Abstract.TimedObserver(), {  getValue: function() {    return Form.serialize(this.element);  }});/*--------------------------------------------------------------------------*/Abstract.EventObserver = function() {}Abstract.EventObserver.prototype = {  initialize: function(element, callback) {    this.element  = $(element);    this.callback = callback;    this.lastValue = this.getValue();    if (this.element.tagName.toLowerCase() == ''form'')      this.registerFormCallbacks();    else      this.registerCallback(this.element);  },  onElementEvent: function() {    var value = this.getValue();    if (this.lastValue !!= value) {      this.callback(this.element, value);      this.lastValue = value;    }  },  registerFormCallbacks: function() {    var elements = Form.getElements(this.element);    for (var i = 0; i < elements.length; i++)      this.registerCallback(elements[i]);  },  registerCallback: function(element) {    if (element.type) {      switch (element.type.toLowerCase()) {        case ''checkbox'':        case ''radio'':          Event.observe(element, ''click'', this.onElementEvent.bind(this));          break;        default:          Event.observe(element, ''change'', this.onElementEvent.bind(this));          break;      }    }  }}Form.Element.EventObserver = Class.create();Form.Element.EventObserver.prototype = Object.extend(new Abstract.EventObserver(), {  getValue: function() {    return Form.Element.getValue(this.element);  }});Form.EventObserver = Class.create();Form.EventObserver.prototype = Object.extend(new Abstract.EventObserver(), {  getValue: function() {    return Form.serialize(this.element);  }});if (!!window.Event) {  var Event = new Object();}Object.extend(Event, {  KEY_BACKSPACE: 8,  KEY_TAB:       9,  KEY_RETURN:   13,  KEY_ESC:      27,  KEY_LEFT:     37,  KEY_UP:       38,  KEY_RIGHT:    39,  KEY_DOWN:     40,  KEY_DELETE:   46,  KEY_HOME:     36,  KEY_END:      35,  KEY_PAGEUP:   33,  KEY_PAGEDOWN: 34,  element: function(event) {    return event.target || event.srcElement;  },  isLeftClick: function(event) {    return (((event.which) && (event.which == 1)) ||            ((event.button) && (event.button == 1)));  },  pointerX: function(event) {    return event.pageX || (event.clientX +      (document.documentElement.scrollLeft || document.body.scrollLeft));  },  pointerY: function(event) {    return event.pageY || (event.clientY +      (document.documentElement.scrollTop || document.body.scrollTop));  },  stop: function(event) {    if (event.preventDefault) {      event.preventDefault();      event.stopPropagation();    } else {      event.returnValue = false;      event.cancelBubble = true;    }  },  // find the first node with the given tagName, starting from the  // node the event was triggered on; traverses the DOM upwards  findElement: function(event, tagName) {    var element = Event.element(event);    while (element.parentNode && (!!element.tagName ||        (element.tagName.toUpperCase() !!= tagName.toUpperCase())))      element = element.parentNode;    return element;  },  observers: false,  _observeAndCache: function(element, name, observer, useCapture) {    if (!!this.observers) this.observers = [];    if (element.addEventListener) {      this.observers.push([element, name, observer, useCapture]);      element.addEventListener(name, observer, useCapture);    } else if (element.attachEvent) {      this.observers.push([element, name, observer, useCapture]);      element.attachEvent(''on'' + name, observer);    }  },  unloadCache: function() {    if (!!Event.observers) return;    for (var i = 0; i < Event.observers.length; i++) {      Event.stopObserving.apply(this, Event.observers[i]);      Event.observers[i][0] = null;    }    Event.observers = false;  },  observe: function(element, name, observer, useCapture) {    element = $(element);    useCapture = useCapture || false;    if (name == ''keypress'' &&        (navigator.appVersion.match(/Konqueror|Safari|KHTML/)        || element.attachEvent))      name = ''keydown'';    Event._observeAndCache(element, name, observer, useCapture);  },  stopObserving: function(element, name, observer, useCapture) {    element = $(element);    useCapture = useCapture || false;    if (name == ''keypress'' &&        (navigator.appVersion.match(/Konqueror|Safari|KHTML/)        || element.detachEvent))      name = ''keydown'';    if (element.removeEventListener) {      element.removeEventListener(name, observer, useCapture);    } else if (element.detachEvent) {      try {        element.detachEvent(''on'' + name, observer);      } catch (e) {}    }  }});/* prevent memory leaks in IE */if (navigator.appVersion.match(/\bMSIE\b/))  Event.observe(window, ''unload'', Event.unloadCache, false);var Position = {  // set to true if needed, warning: firefox performance problems  // NOT neeeded for page scrolling, only if draggable contained in  // scrollable elements  includeScrollOffsets: false,  // must be called before calling withinIncludingScrolloffset, every time the  // page is scrolled  prepare: function() {    this.deltaX =  window.pageXOffset                || document.documentElement.scrollLeft                || document.body.scrollLeft                || 0;    this.deltaY =  window.pageYOffset                || document.documentElement.scrollTop                || document.body.scrollTop                || 0;  },  realOffset: function(element) {    var valueT = 0, valueL = 0;    do {      valueT += element.scrollTop  || 0;      valueL += element.scrollLeft || 0;      element = element.parentNode;    } while (element);    return [valueL, valueT];  },  cumulativeOffset: function(element) {    var valueT = 0, valueL = 0;    do {      valueT += element.offsetTop  || 0;      valueL += element.offsetLeft || 0;      element = element.offsetParent;    } while (element);    return [valueL, valueT];  },  positionedOffset: function(element) {    var valueT = 0, valueL = 0;    do {      valueT += element.offsetTop  || 0;      valueL += element.offsetLeft || 0;      element = element.offsetParent;      if (element) {        p = Element.getStyle(element, ''position'');        if (p == ''relative'' || p == ''absolute'') break;      }    } while (element);    return [valueL, valueT];  },  offsetParent: function(element) {    if (element.offsetParent) return element.offsetParent;    if (element == document.body) return element;    while ((element = element.parentNode) && element !!= document.body)      if (Element.getStyle(element, ''position'') !!= ''static'')        return element;    return document.body;  },  // caches x/y coordinate pair to use with overlap  within: function(element, x, y) {    if (this.includeScrollOffsets)      return this.withinIncludingScrolloffsets(element, x, y);    this.xcomp = x;    this.ycomp = y;    this.offset = this.cumulativeOffset(element);    return (y >= this.offset[1] &&            y <  this.offset[1] + element.offsetHeight &&            x >= this.offset[0] &&            x <  this.offset[0] + element.offsetWidth);  },  withinIncludingScrolloffsets: function(element, x, y) {    var offsetcache = this.realOffset(element);    this.xcomp = x + offsetcache[0] - this.deltaX;    this.ycomp = y + offsetcache[1] - this.deltaY;    this.offset = this.cumulativeOffset(element);    return (this.ycomp >= this.offset[1] &&            this.ycomp <  this.offset[1] + element.offsetHeight &&            this.xcomp >= this.offset[0] &&            this.xcomp <  this.offset[0] + element.offsetWidth);  },  // within must be called directly before  overlap: function(mode, element) {    if (!!mode) return 0;    if (mode == ''vertical'')      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /        element.offsetHeight;    if (mode == ''horizontal'')      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /        element.offsetWidth;  },  page: function(forElement) {    var valueT = 0, valueL = 0;    var element = forElement;    do {      valueT += element.offsetTop  || 0;      valueL += element.offsetLeft || 0;      // Safari fix      if (element.offsetParent==document.body)        if (Element.getStyle(element,''position'')==''absolute'') break;    } while (element = element.offsetParent);    element = forElement;    do {      if (!!window.opera || element.tagName==''BODY'') {        valueT -= element.scrollTop  || 0;        valueL -= element.scrollLeft || 0;      }    } while (element = element.parentNode);    return [valueL, valueT];  },  clone: function(source, target) {    var options = Object.extend({      setLeft:    true,      setTop:     true,      setWidth:   true,      setHeight:  true,      offsetTop:  0,      offsetLeft: 0    }, arguments[2] || {})    // find page position of source    source = $(source);    var p = Position.page(source);    // find coordinate system to use    target = $(target);    var delta = [0, 0];    var parent = null;    // delta [0,0] will do fine with position: fixed elements,    // position:absolute needs offsetParent deltas    if (Element.getStyle(target,''position'') == ''absolute'') {      parent = Position.offsetParent(target);      delta = Position.page(parent);    }    // correct by body offsets (fixes Safari)    if (parent == document.body) {      delta[0] -= document.body.offsetLeft;      delta[1] -= document.body.offsetTop;    }    // set position    if(options.setLeft)   target.style.left  = (p[0] - delta[0] + options.offsetLeft) + ''px'';    if(options.setTop)    target.style.top   = (p[1] - delta[1] + options.offsetTop) + ''px'';    if(options.setWidth)  target.style.width = source.offsetWidth + ''px'';    if(options.setHeight) target.style.height = source.offsetHeight + ''px'';  },  absolutize: function(element) {    element = $(element);    if (element.style.position == ''absolute'') return;    Position.prepare();    var offsets = Position.positionedOffset(element);    var top     = offsets[1];    var left    = offsets[0];    var width   = element.clientWidth;    var height  = element.clientHeight;    element._originalLeft   = left - parseFloat(element.style.left  || 0);    element._originalTop    = top  - parseFloat(element.style.top || 0);    element._originalWidth  = element.style.width;    element._originalHeight = element.style.height;    element.style.position = ''absolute'';    element.style.top    = top + ''px'';;    element.style.left   = left + ''px'';;    element.style.width  = width + ''px'';;    element.style.height = height + ''px'';;  },  relativize: function(element) {    element = $(element);    if (element.style.position == ''relative'') return;    Position.prepare();    element.style.position = ''relative'';    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);    element.style.top    = top + ''px'';    element.style.left   = left + ''px'';    element.style.height = element._originalHeight;    element.style.width  = element._originalWidth;  }}// Safari returns margins on body which is incorrect if the child is absolutely// positioned.  For performance reasons, redefine Position.cumulativeOffset for// KHTML/WebKit only.if (/Konqueror|Safari|KHTML/.test(navigator.userAgent)) {  Position.cumulativeOffset = function(element) {    var valueT = 0, valueL = 0;    do {      valueT += element.offsetTop  || 0;      valueL += element.offsetLeft || 0;      if (element.offsetParent == document.body)        if (Element.getStyle(element, ''position'') == ''absolute'') break;      element = element.offsetParent;    } while (element);    return [valueL, valueT];  }}Element.addMethods();'! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:40'!bBuilder	^ '// script.aculo.us builder.js v1.6.4, Wed Sep 06 11:30:58 CEST 2006// Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//// See scriptaculous.js for full license.var Builder = {  NODEMAP: {    AREA: ''map'',    CAPTION: ''table'',    COL: ''table'',    COLGROUP: ''table'',    LEGEND: ''fieldset'',    OPTGROUP: ''select'',    OPTION: ''select'',    PARAM: ''object'',    TBODY: ''table'',    TD: ''table'',    TFOOT: ''table'',    TH: ''table'',    THEAD: ''table'',    TR: ''table''  },  // note: For Firefox < 1.5, OPTION and OPTGROUP tags are currently broken,  //       due to a Firefox bug  node: function(elementName) {    elementName = elementName.toUpperCase();        // try innerHTML approach    var parentTag = this.NODEMAP[elementName] || ''div'';    var parentElement = document.createElement(parentTag);    try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707      parentElement.innerHTML = "<" + elementName + "></" + elementName + ">";    } catch(e) {}    var element = parentElement.firstChild || null;          // see if browser added wrapping tags    if(element && (element.tagName !!= elementName))      element = element.getElementsByTagName(elementName)[0];        // fallback to createElement approach    if(!!element) element = document.createElement(elementName);        // abort if nothing could be created    if(!!element) return;    // attributes (or text)    if(arguments[1])      if(this._isStringOrNumber(arguments[1]) ||        (arguments[1] instanceof Array)) {          this._children(element, arguments[1]);        } else {          var attrs = this._attributes(arguments[1]);          if(attrs.length) {            try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707              parentElement.innerHTML = "<" +elementName + " " +                attrs + "></" + elementName + ">";            } catch(e) {}            element = parentElement.firstChild || null;            // workaround firefox 1.0.X bug            if(!!element) {              element = document.createElement(elementName);              for(attr in arguments[1])                 element[attr == ''class'' ? ''className'' : attr] = arguments[1][attr];            }            if(element.tagName !!= elementName)              element = parentElement.getElementsByTagName(elementName)[0];            }        }     // text, or array of children    if(arguments[2])      this._children(element, arguments[2]);     return element;  },  _text: function(text) {     return document.createTextNode(text);  },  _attributes: function(attributes) {    var attrs = [];    for(attribute in attributes)      attrs.push((attribute==''className'' ? ''class'' : attribute) +          ''="'' + attributes[attribute].toString().escapeHTML() + ''"'');    return attrs.join(" ");  },  _children: function(element, children) {    if(typeof children==''object'') { // array can hold nodes and text      children.flatten().each( function(e) {        if(typeof e==''object'')          element.appendChild(e)        else          if(Builder._isStringOrNumber(e))            element.appendChild(Builder._text(e));      });    } else      if(Builder._isStringOrNumber(children))          element.appendChild(Builder._text(children));  },  _isStringOrNumber: function(param) {    return(typeof param==''string'' || typeof param==''number'');  },  dump: function(scope) {     if(typeof scope !!= ''object'' && typeof scope !!= ''function'') scope = window; //global scope       var tags = ("A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY " +      "BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET " +      "FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX "+      "KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P "+      "PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD "+      "TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR").split(/\s+/);      tags.each( function(tag){       scope[tag] = function() {         return Builder.node.apply(Builder, [tag].concat($A(arguments)));        }     });  }}'! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:41'!cEffects	^ '// script.aculo.us effects.js v1.6.4, Wed Sep 06 11:30:58 CEST 2006// Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)// Contributors://  Justin Palmer (http://encytemedia.com/)//  Mark Pilgrim (http://diveintomark.org/)//  Martin Bialasinki// // See scriptaculous.js for full license.  // converts rgb() and #xxx to #xxxxxx format,  // returns self (or first argument) if not convertable  String.prototype.parseColor = function() {    var color = ''#'';    if(this.slice(0,4) == ''rgb('') {      var cols = this.slice(4,this.length-1).split('','');      var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i<3);    } else {      if(this.slice(0,1) == ''#'') {        if(this.length==4) for(var i=1;i<4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();        if(this.length==7) color = this.toLowerCase();      }    }    return(color.length==7 ? color : (arguments[0] || this));  }/*--------------------------------------------------------------------------*/Element.collectTextNodes = function(element) {    return $A($(element).childNodes).collect( function(node) {    return (node.nodeType==3 ? node.nodeValue :       (node.hasChildNodes() ? Element.collectTextNodes(node) : ''''));  }).flatten().join('''');}Element.collectTextNodesIgnoreClass = function(element, className) {    return $A($(element).childNodes).collect( function(node) {    return (node.nodeType==3 ? node.nodeValue :       ((node.hasChildNodes() && !!Element.hasClassName(node,className)) ?         Element.collectTextNodesIgnoreClass(node, className) : ''''));  }).flatten().join('''');}Element.setContentZoom = function(element, percent) {  element = $(element);    Element.setStyle(element, {fontSize: (percent/100) + ''em''});     if(navigator.appVersion.indexOf(''AppleWebKit'')>0) window.scrollBy(0,0);}Element.getOpacity = function(element){    var opacity;  if (opacity = Element.getStyle(element, ''opacity''))      return parseFloat(opacity);    if (opacity = (Element.getStyle(element, ''filter'') || '''').match(/alpha\(opacity=(.*)\)/))      if(opacity[1]) return parseFloat(opacity[1]) / 100;    return 1.0;  }Element.setOpacity = function(element, value){    element= $(element);    if (value == 1){    Element.setStyle(element, { opacity:       (/Gecko/.test(navigator.userAgent) && !!/Konqueror|Safari|KHTML/.test(navigator.userAgent)) ?       0.999999 : 1.0 });    if(/MSIE/.test(navigator.userAgent) && !!window.opera)        Element.setStyle(element, {filter: Element.getStyle(element,''filter'').replace(/alpha\([^\)]*\)/gi,'''')});    } else {      if(value < 0.00001) value = 0;      Element.setStyle(element, {opacity: value});    if(/MSIE/.test(navigator.userAgent) && !!window.opera)       Element.setStyle(element,        { filter: Element.getStyle(element,''filter'').replace(/alpha\([^\)]*\)/gi,'''') +                 ''alpha(opacity=''+value*100+'')'' });    }}   Element.getInlineOpacity = function(element){    return $(element).style.opacity || '''';}  Element.childrenWithClassName = function(element, className, findFirst) {  var classNameRegExp = new RegExp("(^|\\s)" + className + "(\\s|$)");  var results = $A($(element).getElementsByTagName(''*''))[findFirst ? ''detect'' : ''select'']( function(c) {     return (c.className && c.className.match(classNameRegExp));  });  if(!!results) results = [];  return results;}Element.forceRerendering = function(element) {  try {    element = $(element);    var n = document.createTextNode('' '');    element.appendChild(n);    element.removeChild(n);  } catch(e) { }};/*--------------------------------------------------------------------------*/Array.prototype.call = function() {  var args = arguments;  this.each(function(f){ f.apply(this, args) });}/*--------------------------------------------------------------------------*/var Effect = {  _elementDoesNotExistError: {    name: ''ElementDoesNotExistError'',    message: ''The specified DOM element does not exist, but is required for this effect to operate''  },  tagifyText: function(element) {    if(typeof Builder == ''undefined'')      throw("Effect.tagifyText requires including script.aculo.us'' builder.js library");          var tagifyStyle = ''position:relative'';    if(/MSIE/.test(navigator.userAgent) && !!window.opera) tagifyStyle += '';zoom:1'';    element = $(element);    $A(element.childNodes).each( function(child) {      if(child.nodeType==3) {        child.nodeValue.toArray().each( function(character) {          element.insertBefore(            Builder.node(''span'',{style: tagifyStyle},              character == '' '' ? String.fromCharCode(160) : character),               child);        });        Element.remove(child);      }    });  },  multiple: function(element, effect) {    var elements;    if(((typeof element == ''object'') ||         (typeof element == ''function'')) &&        (element.length))      elements = element;    else      elements = $(element).childNodes;          var options = Object.extend({      speed: 0.1,      delay: 0.0    }, arguments[2] || {});    var masterDelay = options.delay;    $A(elements).each( function(element, index) {      new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));    });  },  PAIRS: {    ''slide'':  [''SlideDown'',''SlideUp''],    ''blind'':  [''BlindDown'',''BlindUp''],    ''appear'': [''Appear'',''Fade'']  },  toggle: function(element, effect) {    element = $(element);    effect = (effect || ''appear'').toLowerCase();    var options = Object.extend({      queue: { position:''end'', scope:(element.id || ''global''), limit: 1 }    }, arguments[2] || {});    Effect[element.visible() ?       Effect.PAIRS[effect][1] : Effect.PAIRS[effect][0]](element, options);  }};var Effect2 = Effect; // deprecated/* ------------- transitions ------------- */Effect.Transitions = {}Effect.Transitions.linear = Prototype.K;Effect.Transitions.sinoidal = function(pos) {  return (-Math.cos(pos*Math.PI)/2) + 0.5;}Effect.Transitions.reverse  = function(pos) {  return 1-pos;}Effect.Transitions.flicker = function(pos) {  return ((-Math.cos(pos*Math.PI)/4) + 0.75) + Math.random()/4;}Effect.Transitions.wobble = function(pos) {  return (-Math.cos(pos*Math.PI*(9*pos))/2) + 0.5;}Effect.Transitions.pulse = function(pos) {  return (Math.floor(pos*10) % 2 == 0 ?     (pos*10-Math.floor(pos*10)) : 1-(pos*10-Math.floor(pos*10)));}Effect.Transitions.none = function(pos) {  return 0;}Effect.Transitions.full = function(pos) {  return 1;}/* ------------- core effects ------------- */Effect.ScopedQueue = Class.create();Object.extend(Object.extend(Effect.ScopedQueue.prototype, Enumerable), {  initialize: function() {    this.effects  = [];    this.interval = null;  },  _each: function(iterator) {    this.effects._each(iterator);  },  add: function(effect) {    var timestamp = new Date().getTime();        var position = (typeof effect.options.queue == ''string'') ?       effect.options.queue : effect.options.queue.position;        switch(position) {      case ''front'':        // move unstarted effects after this effect          this.effects.findAll(function(e){ return e.state==''idle'' }).each( function(e) {            e.startOn  += effect.finishOn;            e.finishOn += effect.finishOn;          });        break;      case ''end'':        // start effect after last queued effect has finished        timestamp = this.effects.pluck(''finishOn'').max() || timestamp;        break;    }        effect.startOn  += timestamp;    effect.finishOn += timestamp;    if(!!effect.options.queue.limit || (this.effects.length < effect.options.queue.limit))      this.effects.push(effect);        if(!!this.interval)       this.interval = setInterval(this.loop.bind(this), 40);  },  remove: function(effect) {    this.effects = this.effects.reject(function(e) { return e==effect });    if(this.effects.length == 0) {      clearInterval(this.interval);      this.interval = null;    }  },  loop: function() {    var timePos = new Date().getTime();    this.effects.invoke(''loop'', timePos);  }});Effect.Queues = {  instances: $H(),  get: function(queueName) {    if(typeof queueName !!= ''string'') return queueName;        if(!!this.instances[queueName])      this.instances[queueName] = new Effect.ScopedQueue();          return this.instances[queueName];  }}Effect.Queue = Effect.Queues.get(''global'');Effect.DefaultOptions = {  transition: Effect.Transitions.sinoidal,  duration:   1.0,   // seconds  fps:        25.0,  // max. 25fps due to Effect.Queue implementation  sync:       false, // true for combining  from:       0.0,  to:         1.0,  delay:      0.0,  queue:      ''parallel''}Effect.Base = function() {};Effect.Base.prototype = {  position: null,  start: function(options) {    this.options      = Object.extend(Object.extend({},Effect.DefaultOptions), options || {});    this.currentFrame = 0;    this.state        = ''idle'';    this.startOn      = this.options.delay*1000;    this.finishOn     = this.startOn + (this.options.duration*1000);    this.event(''beforeStart'');    if(!!this.options.sync)      Effect.Queues.get(typeof this.options.queue == ''string'' ?         ''global'' : this.options.queue.scope).add(this);  },  loop: function(timePos) {    if(timePos >= this.startOn) {      if(timePos >= this.finishOn) {        this.render(1.0);        this.cancel();        this.event(''beforeFinish'');        if(this.finish) this.finish();         this.event(''afterFinish'');        return;        }      var pos   = (timePos - this.startOn) / (this.finishOn - this.startOn);      var frame = Math.round(pos * this.options.fps * this.options.duration);      if(frame > this.currentFrame) {        this.render(pos);        this.currentFrame = frame;      }    }  },  render: function(pos) {    if(this.state == ''idle'') {      this.state = ''running'';      this.event(''beforeSetup'');      if(this.setup) this.setup();      this.event(''afterSetup'');    }    if(this.state == ''running'') {      if(this.options.transition) pos = this.options.transition(pos);      pos *= (this.options.to-this.options.from);      pos += this.options.from;      this.position = pos;      this.event(''beforeUpdate'');      if(this.update) this.update(pos);      this.event(''afterUpdate'');    }  },  cancel: function() {    if(!!this.options.sync)      Effect.Queues.get(typeof this.options.queue == ''string'' ?         ''global'' : this.options.queue.scope).remove(this);    this.state = ''finished'';  },  event: function(eventName) {    if(this.options[eventName + ''Internal'']) this.options[eventName + ''Internal''](this);    if(this.options[eventName]) this.options[eventName](this);  },  inspect: function() {    return ''#<Effect:'' + $H(this).inspect() + '',options:'' + $H(this.options).inspect() + ''>'';  }}Effect.Parallel = Class.create();Object.extend(Object.extend(Effect.Parallel.prototype, Effect.Base.prototype), {  initialize: function(effects) {    this.effects = effects || [];    this.start(arguments[1]);  },  update: function(position) {    this.effects.invoke(''render'', position);  },  finish: function(position) {    this.effects.each( function(effect) {      effect.render(1.0);      effect.cancel();      effect.event(''beforeFinish'');      if(effect.finish) effect.finish(position);      effect.event(''afterFinish'');    });  }});Effect.Opacity = Class.create();Object.extend(Object.extend(Effect.Opacity.prototype, Effect.Base.prototype), {  initialize: function(element) {    this.element = $(element);    if(!!this.element) throw(Effect._elementDoesNotExistError);    // make this work on IE on elements without ''layout''    if(/MSIE/.test(navigator.userAgent) && !!window.opera && (!!this.element.currentStyle.hasLayout))      this.element.setStyle({zoom: 1});    var options = Object.extend({      from: this.element.getOpacity() || 0.0,      to:   1.0    }, arguments[1] || {});    this.start(options);  },  update: function(position) {    this.element.setOpacity(position);  }});Effect.Move = Class.create();Object.extend(Object.extend(Effect.Move.prototype, Effect.Base.prototype), {  initialize: function(element) {    this.element = $(element);    if(!!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({      x:    0,      y:    0,      mode: ''relative''    }, arguments[1] || {});    this.start(options);  },  setup: function() {    // Bug in Opera: Opera returns the "real" position of a static element or    // relative element that does not have top/left explicitly set.    // ==> Always set top and left for position relative elements in your stylesheets     // (to 0 if you do not need them)     this.element.makePositioned();    this.originalLeft = parseFloat(this.element.getStyle(''left'') || ''0'');    this.originalTop  = parseFloat(this.element.getStyle(''top'')  || ''0'');    if(this.options.mode == ''absolute'') {      // absolute movement, so we need to calc deltaX and deltaY      this.options.x = this.options.x - this.originalLeft;      this.options.y = this.options.y - this.originalTop;    }  },  update: function(position) {    this.element.setStyle({      left: Math.round(this.options.x  * position + this.originalLeft) + ''px'',      top:  Math.round(this.options.y  * position + this.originalTop)  + ''px''    });  }});// for backwards compatibilityEffect.MoveBy = function(element, toTop, toLeft) {  return new Effect.Move(element,     Object.extend({ x: toLeft, y: toTop }, arguments[3] || {}));};Effect.Scale = Class.create();Object.extend(Object.extend(Effect.Scale.prototype, Effect.Base.prototype), {  initialize: function(element, percent) {    this.element = $(element);    if(!!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({      scaleX: true,      scaleY: true,      scaleContent: true,      scaleFromCenter: false,      scaleMode: ''box'',        // ''box'' or ''contents'' or {} with provided values      scaleFrom: 100.0,      scaleTo:   percent    }, arguments[2] || {});    this.start(options);  },  setup: function() {    this.restoreAfterFinish = this.options.restoreAfterFinish || false;    this.elementPositioning = this.element.getStyle(''position'');        this.originalStyle = {};    [''top'',''left'',''width'',''height'',''fontSize''].each( function(k) {      this.originalStyle[k] = this.element.style[k];    }.bind(this));          this.originalTop  = this.element.offsetTop;    this.originalLeft = this.element.offsetLeft;        var fontSize = this.element.getStyle(''font-size'') || ''100%'';    [''em'',''px'',''%'',''pt''].each( function(fontSizeType) {      if(fontSize.indexOf(fontSizeType)>0) {        this.fontSize     = parseFloat(fontSize);        this.fontSizeType = fontSizeType;      }    }.bind(this));        this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;        this.dims = null;    if(this.options.scaleMode==''box'')      this.dims = [this.element.offsetHeight, this.element.offsetWidth];    if(/^content/.test(this.options.scaleMode))      this.dims = [this.element.scrollHeight, this.element.scrollWidth];    if(!!this.dims)      this.dims = [this.options.scaleMode.originalHeight,                   this.options.scaleMode.originalWidth];  },  update: function(position) {    var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);    if(this.options.scaleContent && this.fontSize)      this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);  },  finish: function(position) {    if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);  },  setDimensions: function(height, width) {    var d = {};    if(this.options.scaleX) d.width = Math.round(width) + ''px'';    if(this.options.scaleY) d.height = Math.round(height) + ''px'';    if(this.options.scaleFromCenter) {      var topd  = (height - this.dims[0])/2;      var leftd = (width  - this.dims[1])/2;      if(this.elementPositioning == ''absolute'') {        if(this.options.scaleY) d.top = this.originalTop-topd + ''px'';        if(this.options.scaleX) d.left = this.originalLeft-leftd + ''px'';      } else {        if(this.options.scaleY) d.top = -topd + ''px'';        if(this.options.scaleX) d.left = -leftd + ''px'';      }    }    this.element.setStyle(d);  }});Effect.Highlight = Class.create();Object.extend(Object.extend(Effect.Highlight.prototype, Effect.Base.prototype), {  initialize: function(element) {    this.element = $(element);    if(!!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({ startcolor: ''#ffff99'' }, arguments[1] || {});    this.start(options);  },  setup: function() {    // Prevent executing on elements not in the layout flow    if(this.element.getStyle(''display'')==''none'') { this.cancel(); return; }    // Disable background image during the effect    this.oldStyle = {      backgroundImage: this.element.getStyle(''background-image'') };    this.element.setStyle({backgroundImage: ''none''});    if(!!this.options.endcolor)      this.options.endcolor = this.element.getStyle(''background-color'').parseColor(''#ffffff'');    if(!!this.options.restorecolor)      this.options.restorecolor = this.element.getStyle(''background-color'');    // init color calculations    this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));    this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));  },  update: function(position) {    this.element.setStyle({backgroundColor: $R(0,2).inject(''#'',function(m,v,i){      return m+(Math.round(this._base[i]+(this._delta[i]*position)).toColorPart()); }.bind(this)) });  },  finish: function() {    this.element.setStyle(Object.extend(this.oldStyle, {      backgroundColor: this.options.restorecolor    }));  }});Effect.ScrollTo = Class.create();Object.extend(Object.extend(Effect.ScrollTo.prototype, Effect.Base.prototype), {  initialize: function(element) {    this.element = $(element);    this.start(arguments[1] || {});  },  setup: function() {    Position.prepare();    var offsets = Position.cumulativeOffset(this.element);    if(this.options.offset) offsets[1] += this.options.offset;    var max = window.innerHeight ?       window.height - window.innerHeight :      document.body.scrollHeight -         (document.documentElement.clientHeight ?           document.documentElement.clientHeight : document.body.clientHeight);    this.scrollStart = Position.deltaY;    this.delta = (offsets[1] > max ? max : offsets[1]) - this.scrollStart;  },  update: function(position) {    Position.prepare();    window.scrollTo(Position.deltaX,       this.scrollStart + (position*this.delta));  }});/* ------------- combination effects ------------- */Effect.Fade = function(element) {  element = $(element);  var oldOpacity = element.getInlineOpacity();  var options = Object.extend({  from: element.getOpacity() || 1.0,  to:   0.0,  afterFinishInternal: function(effect) {     if(effect.options.to!!=0) return;    effect.element.hide();    effect.element.setStyle({opacity: oldOpacity});   }}, arguments[1] || {});  return new Effect.Opacity(element,options);}Effect.Appear = function(element) {  element = $(element);  var options = Object.extend({  from: (element.getStyle(''display'') == ''none'' ? 0.0 : element.getOpacity() || 0.0),  to:   1.0,  // force Safari to render floated elements properly  afterFinishInternal: function(effect) {    effect.element.forceRerendering();  },  beforeSetup: function(effect) {    effect.element.setOpacity(effect.options.from);    effect.element.show();   }}, arguments[1] || {});  return new Effect.Opacity(element,options);}Effect.Puff = function(element) {  element = $(element);  var oldStyle = {     opacity: element.getInlineOpacity(),     position: element.getStyle(''position''),    top:  element.style.top,    left: element.style.left,    width: element.style.width,    height: element.style.height  };  return new Effect.Parallel(   [ new Effect.Scale(element, 200,       { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),      new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],      Object.extend({ duration: 1.0,       beforeSetupInternal: function(effect) {        Position.absolutize(effect.effects[0].element)      },      afterFinishInternal: function(effect) {         effect.effects[0].element.hide();         effect.effects[0].element.setStyle(oldStyle); }     }, arguments[1] || {})   );}Effect.BlindUp = function(element) {  element = $(element);  element.makeClipping();  return new Effect.Scale(element, 0,    Object.extend({ scaleContent: false,       scaleX: false,       restoreAfterFinish: true,      afterFinishInternal: function(effect) {        effect.element.hide();        effect.element.undoClipping();      }     }, arguments[1] || {})  );}Effect.BlindDown = function(element) {  element = $(element);  var elementDimensions = element.getDimensions();  return new Effect.Scale(element, 100, Object.extend({     scaleContent: false,     scaleX: false,    scaleFrom: 0,    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},    restoreAfterFinish: true,    afterSetup: function(effect) {      effect.element.makeClipping();      effect.element.setStyle({height: ''0px''});      effect.element.show();     },      afterFinishInternal: function(effect) {      effect.element.undoClipping();    }  }, arguments[1] || {}));}Effect.SwitchOff = function(element) {  element = $(element);  var oldOpacity = element.getInlineOpacity();  return new Effect.Appear(element, Object.extend({    duration: 0.4,    from: 0,    transition: Effect.Transitions.flicker,    afterFinishInternal: function(effect) {      new Effect.Scale(effect.element, 1, {         duration: 0.3, scaleFromCenter: true,        scaleX: false, scaleContent: false, restoreAfterFinish: true,        beforeSetup: function(effect) {           effect.element.makePositioned();          effect.element.makeClipping();        },        afterFinishInternal: function(effect) {          effect.element.hide();          effect.element.undoClipping();          effect.element.undoPositioned();          effect.element.setStyle({opacity: oldOpacity});        }      })    }  }, arguments[1] || {}));}Effect.DropOut = function(element) {  element = $(element);  var oldStyle = {    top: element.getStyle(''top''),    left: element.getStyle(''left''),    opacity: element.getInlineOpacity() };  return new Effect.Parallel(    [ new Effect.Move(element, {x: 0, y: 100, sync: true }),       new Effect.Opacity(element, { sync: true, to: 0.0 }) ],    Object.extend(      { duration: 0.5,        beforeSetup: function(effect) {          effect.effects[0].element.makePositioned();         },        afterFinishInternal: function(effect) {          effect.effects[0].element.hide();          effect.effects[0].element.undoPositioned();          effect.effects[0].element.setStyle(oldStyle);        }       }, arguments[1] || {}));}Effect.Shake = function(element) {  element = $(element);  var oldStyle = {    top: element.getStyle(''top''),    left: element.getStyle(''left'') };    return new Effect.Move(element,       { x:  20, y: 0, duration: 0.05, afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -40, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x:  40, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -40, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x:  40, y: 0, duration: 0.1,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -20, y: 0, duration: 0.05, afterFinishInternal: function(effect) {        effect.element.undoPositioned();        effect.element.setStyle(oldStyle);  }}) }}) }}) }}) }}) }});}Effect.SlideDown = function(element) {  element = $(element);  element.cleanWhitespace();  // SlideDown need to have the content of the element wrapped in a container element with fixed height!!  var oldInnerBottom = $(element.firstChild).getStyle(''bottom'');  var elementDimensions = element.getDimensions();  return new Effect.Scale(element, 100, Object.extend({     scaleContent: false,     scaleX: false,     scaleFrom: window.opera ? 0 : 1,    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},    restoreAfterFinish: true,    afterSetup: function(effect) {      effect.element.makePositioned();      effect.element.firstChild.makePositioned();      if(window.opera) effect.element.setStyle({top: ''''});      effect.element.makeClipping();      effect.element.setStyle({height: ''0px''});      effect.element.show(); },    afterUpdateInternal: function(effect) {      effect.element.firstChild.setStyle({bottom:        (effect.dims[0] - effect.element.clientHeight) + ''px'' });     },    afterFinishInternal: function(effect) {      effect.element.undoClipping();       // IE will crash if child is undoPositioned first      if(/MSIE/.test(navigator.userAgent) && !!window.opera){        effect.element.undoPositioned();        effect.element.firstChild.undoPositioned();      }else{        effect.element.firstChild.undoPositioned();        effect.element.undoPositioned();      }      effect.element.firstChild.setStyle({bottom: oldInnerBottom}); }    }, arguments[1] || {})  );}Effect.SlideUp = function(element) {  element = $(element);  element.cleanWhitespace();  var oldInnerBottom = $(element.firstChild).getStyle(''bottom'');  return new Effect.Scale(element, window.opera ? 0 : 1,   Object.extend({ scaleContent: false,     scaleX: false,     scaleMode: ''box'',    scaleFrom: 100,    restoreAfterFinish: true,    beforeStartInternal: function(effect) {      effect.element.makePositioned();      effect.element.firstChild.makePositioned();      if(window.opera) effect.element.setStyle({top: ''''});      effect.element.makeClipping();      effect.element.show(); },      afterUpdateInternal: function(effect) {      effect.element.firstChild.setStyle({bottom:        (effect.dims[0] - effect.element.clientHeight) + ''px'' }); },    afterFinishInternal: function(effect) {      effect.element.hide();      effect.element.undoClipping();      effect.element.firstChild.undoPositioned();      effect.element.undoPositioned();      effect.element.setStyle({bottom: oldInnerBottom}); }   }, arguments[1] || {})  );}// Bug in opera makes the TD containing this element expand for a instance after finish Effect.Squish = function(element) {  return new Effect.Scale(element, window.opera ? 1 : 0,     { restoreAfterFinish: true,      beforeSetup: function(effect) {        effect.element.makeClipping(effect.element); },        afterFinishInternal: function(effect) {        effect.element.hide(effect.element);         effect.element.undoClipping(effect.element); }  });}Effect.Grow = function(element) {  element = $(element);  var options = Object.extend({    direction: ''center'',    moveTransition: Effect.Transitions.sinoidal,    scaleTransition: Effect.Transitions.sinoidal,    opacityTransition: Effect.Transitions.full  }, arguments[1] || {});  var oldStyle = {    top: element.style.top,    left: element.style.left,    height: element.style.height,    width: element.style.width,    opacity: element.getInlineOpacity() };  var dims = element.getDimensions();      var initialMoveX, initialMoveY;  var moveX, moveY;    switch (options.direction) {    case ''top-left'':      initialMoveX = initialMoveY = moveX = moveY = 0;       break;    case ''top-right'':      initialMoveX = dims.width;      initialMoveY = moveY = 0;      moveX = -dims.width;      break;    case ''bottom-left'':      initialMoveX = moveX = 0;      initialMoveY = dims.height;      moveY = -dims.height;      break;    case ''bottom-right'':      initialMoveX = dims.width;      initialMoveY = dims.height;      moveX = -dims.width;      moveY = -dims.height;      break;    case ''center'':      initialMoveX = dims.width / 2;      initialMoveY = dims.height / 2;      moveX = -dims.width / 2;      moveY = -dims.height / 2;      break;  }    return new Effect.Move(element, {    x: initialMoveX,    y: initialMoveY,    duration: 0.01,     beforeSetup: function(effect) {      effect.element.hide();      effect.element.makeClipping();      effect.element.makePositioned();    },    afterFinishInternal: function(effect) {      new Effect.Parallel(        [ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),          new Effect.Scale(effect.element, 100, {            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },             sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})        ], Object.extend({             beforeSetup: function(effect) {               effect.effects[0].element.setStyle({height: ''0px''});               effect.effects[0].element.show();              },             afterFinishInternal: function(effect) {               effect.effects[0].element.undoClipping();               effect.effects[0].element.undoPositioned();               effect.effects[0].element.setStyle(oldStyle);              }           }, options)      )    }  });}Effect.Shrink = function(element) {  element = $(element);  var options = Object.extend({    direction: ''center'',    moveTransition: Effect.Transitions.sinoidal,    scaleTransition: Effect.Transitions.sinoidal,    opacityTransition: Effect.Transitions.none  }, arguments[1] || {});  var oldStyle = {    top: element.style.top,    left: element.style.left,    height: element.style.height,    width: element.style.width,    opacity: element.getInlineOpacity() };  var dims = element.getDimensions();  var moveX, moveY;    switch (options.direction) {    case ''top-left'':      moveX = moveY = 0;      break;    case ''top-right'':      moveX = dims.width;      moveY = 0;      break;    case ''bottom-left'':      moveX = 0;      moveY = dims.height;      break;    case ''bottom-right'':      moveX = dims.width;      moveY = dims.height;      break;    case ''center'':        moveX = dims.width / 2;      moveY = dims.height / 2;      break;  }    return new Effect.Parallel(    [ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })    ], Object.extend({                     beforeStartInternal: function(effect) {           effect.effects[0].element.makePositioned();           effect.effects[0].element.makeClipping(); },         afterFinishInternal: function(effect) {           effect.effects[0].element.hide();           effect.effects[0].element.undoClipping();           effect.effects[0].element.undoPositioned();           effect.effects[0].element.setStyle(oldStyle); }       }, options)  );}Effect.Pulsate = function(element) {  element = $(element);  var options    = arguments[1] || {};  var oldOpacity = element.getInlineOpacity();  var transition = options.transition || Effect.Transitions.sinoidal;  var reverser   = function(pos){ return transition(1-Effect.Transitions.pulse(pos)) };  reverser.bind(transition);  return new Effect.Opacity(element,     Object.extend(Object.extend({  duration: 3.0, from: 0,      afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }    }, options), {transition: reverser}));}Effect.Fold = function(element) {  element = $(element);  var oldStyle = {    top: element.style.top,    left: element.style.left,    width: element.style.width,    height: element.style.height };  Element.makeClipping(element);  return new Effect.Scale(element, 5, Object.extend({       scaleContent: false,    scaleX: false,    afterFinishInternal: function(effect) {    new Effect.Scale(element, 1, {       scaleContent: false,       scaleY: false,      afterFinishInternal: function(effect) {        effect.element.hide();        effect.element.undoClipping();         effect.element.setStyle(oldStyle);      } });  }}, arguments[1] || {}));};[''setOpacity'',''getOpacity'',''getInlineOpacity'',''forceRerendering'',''setContentZoom'', ''collectTextNodes'',''collectTextNodesIgnoreClass'',''childrenWithClassName''].each(   function(f) { Element.Methods[f] = Element[f]; });Element.Methods.visualEffect = function(element, effect, options) {  s = effect.gsub(/_/, ''-'').camelize();  effect_class = s.charAt(0).toUpperCase() + s.substring(1);  new Effect[effect_class](element, options);  return $(element);};Element.addMethods();'! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:41'!dDragDrop	^ '// script.aculo.us dragdrop.js v1.6.4, Wed Sep 06 11:30:58 CEST 2006// Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//           (c) 2005 Sammi Williams (http://www.oriontransfer.co.nz, sammi@oriontransfer.co.nz)// // See scriptaculous.js for full license./*--------------------------------------------------------------------------*/if(typeof Effect == ''undefined'')  throw("dragdrop.js requires including script.aculo.us'' effects.js library");var Droppables = {  drops: [],  remove: function(element) {    this.drops = this.drops.reject(function(d) { return d.element==$(element) });  },  add: function(element) {    element = $(element);    var options = Object.extend({      greedy:     true,      hoverclass: null,      tree:       false    }, arguments[1] || {});    // cache containers    if(options.containment) {      options._containers = [];      var containment = options.containment;      if((typeof containment == ''object'') &&         (containment.constructor == Array)) {        containment.each( function(c) { options._containers.push($(c)) });      } else {        options._containers.push($(containment));      }    }        if(options.accept) options.accept = [options.accept].flatten();    Element.makePositioned(element); // fix IE    options.element = element;    this.drops.push(options);  },    findDeepestChild: function(drops) {    deepest = drops[0];          for (i = 1; i < drops.length; ++i)      if (Element.isParent(drops[i].element, deepest.element))        deepest = drops[i];        return deepest;  },  isContained: function(element, drop) {    var containmentNode;    if(drop.tree) {      containmentNode = element.treeNode;     } else {      containmentNode = element.parentNode;    }    return drop._containers.detect(function(c) { return containmentNode == c });  },    isAffected: function(point, element, drop) {    return (      (drop.element!!=element) &&      ((!!drop._containers) ||        this.isContained(element, drop)) &&      ((!!drop.accept) ||        (Element.classNames(element).detect(           function(v) { return drop.accept.include(v) } ) )) &&      Position.within(drop.element, point[0], point[1]) );  },  deactivate: function(drop) {    if(drop.hoverclass)      Element.removeClassName(drop.element, drop.hoverclass);    this.last_active = null;  },  activate: function(drop) {    if(drop.hoverclass)      Element.addClassName(drop.element, drop.hoverclass);    this.last_active = drop;  },  show: function(point, element) {    if(!!this.drops.length) return;    var affected = [];        if(this.last_active) this.deactivate(this.last_active);    this.drops.each( function(drop) {      if(Droppables.isAffected(point, element, drop))        affected.push(drop);    });            if(affected.length>0) {      drop = Droppables.findDeepestChild(affected);      Position.within(drop.element, point[0], point[1]);      if(drop.onHover)        drop.onHover(element, drop.element, Position.overlap(drop.overlap, drop.element));            Droppables.activate(drop);    }  },  fire: function(event, element) {    if(!!this.last_active) return;    Position.prepare();    if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active))      if (this.last_active.onDrop)         this.last_active.onDrop(element, this.last_active.element, event);  },  reset: function() {    if(this.last_active)      this.deactivate(this.last_active);  }}var Draggables = {  drags: [],  observers: [],    register: function(draggable) {    if(this.drags.length == 0) {      this.eventMouseUp   = this.endDrag.bindAsEventListener(this);      this.eventMouseMove = this.updateDrag.bindAsEventListener(this);      this.eventKeypress  = this.keyPress.bindAsEventListener(this);            Event.observe(document, "mouseup", this.eventMouseUp);      Event.observe(document, "mousemove", this.eventMouseMove);      Event.observe(document, "keypress", this.eventKeypress);    }    this.drags.push(draggable);  },    unregister: function(draggable) {    this.drags = this.drags.reject(function(d) { return d==draggable });    if(this.drags.length == 0) {      Event.stopObserving(document, "mouseup", this.eventMouseUp);      Event.stopObserving(document, "mousemove", this.eventMouseMove);      Event.stopObserving(document, "keypress", this.eventKeypress);    }  },    activate: function(draggable) {    if(draggable.options.delay) {       this._timeout = setTimeout(function() {         Draggables._timeout = null;         window.focus();         Draggables.activeDraggable = draggable;       }.bind(this), draggable.options.delay);     } else {      window.focus(); // allows keypress events if window isn''t currently focused, fails for Safari      this.activeDraggable = draggable;    }  },    deactivate: function() {    this.activeDraggable = null;  },    updateDrag: function(event) {    if(!!this.activeDraggable) return;    var pointer = [Event.pointerX(event), Event.pointerY(event)];    // Mozilla-based browsers fire successive mousemove events with    // the same coordinates, prevent needless redrawing (moz bug?)    if(this._lastPointer && (this._lastPointer.inspect() == pointer.inspect())) return;    this._lastPointer = pointer;        this.activeDraggable.updateDrag(event, pointer);  },    endDrag: function(event) {    if(this._timeout) {       clearTimeout(this._timeout);       this._timeout = null;     }    if(!!this.activeDraggable) return;    this._lastPointer = null;    this.activeDraggable.endDrag(event);    this.activeDraggable = null;  },    keyPress: function(event) {    if(this.activeDraggable)      this.activeDraggable.keyPress(event);  },    addObserver: function(observer) {    this.observers.push(observer);    this._cacheObserverCallbacks();  },    removeObserver: function(element) {  // element instead of observer fixes mem leaks    this.observers = this.observers.reject( function(o) { return o.element==element });    this._cacheObserverCallbacks();  },    notify: function(eventName, draggable, event) {  // ''onStart'', ''onEnd'', ''onDrag''    if(this[eventName+''Count''] > 0)      this.observers.each( function(o) {        if(o[eventName]) o[eventName](eventName, draggable, event);      });    if(draggable.options[eventName]) draggable.options[eventName](draggable, event);  },    _cacheObserverCallbacks: function() {    [''onStart'',''onEnd'',''onDrag''].each( function(eventName) {      Draggables[eventName+''Count''] = Draggables.observers.select(        function(o) { return o[eventName]; }      ).length;    });  }}/*--------------------------------------------------------------------------*/var Draggable = Class.create();Draggable._dragging    = {};Draggable.prototype = {  initialize: function(element) {    var defaults = {      handle: false,      reverteffect: function(element, top_offset, left_offset) {        var dur = Math.sqrt(Math.abs(top_offset^2)+Math.abs(left_offset^2))*0.02;        new Effect.Move(element, { x: -left_offset, y: -top_offset, duration: dur,          queue: {scope:''_draggable'', position:''end''}        });      },      endeffect: function(element) {        var toOpacity = typeof element._opacity == ''number'' ? element._opacity : 1.0;        new Effect.Opacity(element, {duration:0.2, from:0.7, to:toOpacity,           queue: {scope:''_draggable'', position:''end''},          afterFinish: function(){             Draggable._dragging[element] = false           }        });       },      zindex: 1000,      revert: false,      scroll: false,      scrollSensitivity: 20,      scrollSpeed: 15,      snap: false,  // false, or xy or [x,y] or function(x,y){ return [x,y] }      delay: 0    };        if(arguments[1] && typeof arguments[1].endeffect == ''undefined'')      Object.extend(defaults, {        starteffect: function(element) {          element._opacity = Element.getOpacity(element);          Draggable._dragging[element] = true;          new Effect.Opacity(element, {duration:0.2, from:element._opacity, to:0.7});         }      });        var options = Object.extend(defaults, arguments[1] || {});    this.element = $(element);        if(options.handle && (typeof options.handle == ''string'')) {      var h = Element.childrenWithClassName(this.element, options.handle, true);      if(h.length>0) this.handle = h[0];    }    if(!!this.handle) this.handle = $(options.handle);    if(!!this.handle) this.handle = this.element;        if(options.scroll && !!options.scroll.scrollTo && !!options.scroll.outerHTML) {      options.scroll = $(options.scroll);      this._isScrollChild = Element.childOf(this.element, options.scroll);    }    Element.makePositioned(this.element); // fix IE        this.delta    = this.currentDelta();    this.options  = options;    this.dragging = false;       this.eventMouseDown = this.initDrag.bindAsEventListener(this);    Event.observe(this.handle, "mousedown", this.eventMouseDown);        Draggables.register(this);  },    destroy: function() {    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);    Draggables.unregister(this);  },    currentDelta: function() {    return([      parseInt(Element.getStyle(this.element,''left'') || ''0''),      parseInt(Element.getStyle(this.element,''top'') || ''0'')]);  },    initDrag: function(event) {    if(typeof Draggable._dragging[this.element] !!= ''undefined'' &&      Draggable._dragging[this.element]) return;    if(Event.isLeftClick(event)) {          // abort on form elements, fixes a Firefox issue      var src = Event.element(event);      if(src.tagName && (        src.tagName==''INPUT'' ||        src.tagName==''SELECT'' ||        src.tagName==''OPTION'' ||        src.tagName==''BUTTON'' ||        src.tagName==''TEXTAREA'')) return;              var pointer = [Event.pointerX(event), Event.pointerY(event)];      var pos     = Position.cumulativeOffset(this.element);      this.offset = [0,1].map( function(i) { return (pointer[i] - pos[i]) });            Draggables.activate(this);      Event.stop(event);    }  },    startDrag: function(event) {    this.dragging = true;        if(this.options.zindex) {      this.originalZ = parseInt(Element.getStyle(this.element,''z-index'') || 0);      this.element.style.zIndex = this.options.zindex;    }        if(this.options.ghosting) {      this._clone = this.element.cloneNode(true);      Position.absolutize(this.element);      this.element.parentNode.insertBefore(this._clone, this.element);    }        if(this.options.scroll) {      if (this.options.scroll == window) {        var where = this._getWindowScroll(this.options.scroll);        this.originalScrollLeft = where.left;        this.originalScrollTop = where.top;      } else {        this.originalScrollLeft = this.options.scroll.scrollLeft;        this.originalScrollTop = this.options.scroll.scrollTop;      }    }        Draggables.notify(''onStart'', this, event);            if(this.options.starteffect) this.options.starteffect(this.element);  },    updateDrag: function(event, pointer) {    if(!!this.dragging) this.startDrag(event);    Position.prepare();    Droppables.show(pointer, this.element);    Draggables.notify(''onDrag'', this, event);        this.draw(pointer);    if(this.options.change) this.options.change(this);        if(this.options.scroll) {      this.stopScrolling();            var p;      if (this.options.scroll == window) {        with(this._getWindowScroll(this.options.scroll)) { p = [ left, top, left+width, top+height ]; }      } else {        p = Position.page(this.options.scroll);        p[0] += this.options.scroll.scrollLeft;        p[1] += this.options.scroll.scrollTop;                p[0] += (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0);        p[1] += (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0);                p.push(p[0]+this.options.scroll.offsetWidth);        p.push(p[1]+this.options.scroll.offsetHeight);      }      var speed = [0,0];      if(pointer[0] < (p[0]+this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[0]+this.options.scrollSensitivity);      if(pointer[1] < (p[1]+this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[1]+this.options.scrollSensitivity);      if(pointer[0] > (p[2]-this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[2]-this.options.scrollSensitivity);      if(pointer[1] > (p[3]-this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[3]-this.options.scrollSensitivity);      this.startScrolling(speed);    }        // fix AppleWebKit rendering    if(navigator.appVersion.indexOf(''AppleWebKit'')>0) window.scrollBy(0,0);        Event.stop(event);  },    finishDrag: function(event, success) {    this.dragging = false;    if(this.options.ghosting) {      Position.relativize(this.element);      Element.remove(this._clone);      this._clone = null;    }    if(success) Droppables.fire(event, this.element);    Draggables.notify(''onEnd'', this, event);    var revert = this.options.revert;    if(revert && typeof revert == ''function'') revert = revert(this.element);        var d = this.currentDelta();    if(revert && this.options.reverteffect) {      this.options.reverteffect(this.element,         d[1]-this.delta[1], d[0]-this.delta[0]);    } else {      this.delta = d;    }    if(this.options.zindex)      this.element.style.zIndex = this.originalZ;    if(this.options.endeffect)       this.options.endeffect(this.element);          Draggables.deactivate(this);    Droppables.reset();  },    keyPress: function(event) {    if(event.keyCode!!=Event.KEY_ESC) return;    this.finishDrag(event, false);    Event.stop(event);  },    endDrag: function(event) {    if(!!this.dragging) return;    this.stopScrolling();    this.finishDrag(event, true);    Event.stop(event);  },    draw: function(point) {    var pos = Position.cumulativeOffset(this.element);    if(this.options.ghosting) {      var r   = Position.realOffset(this.element);      window.status = r.inspect();      pos[0] += r[0] - Position.deltaX; pos[1] += r[1] - Position.deltaY;    }        var d = this.currentDelta();    pos[0] -= d[0]; pos[1] -= d[1];        if(this.options.scroll && (this.options.scroll !!= window && this._isScrollChild)) {      pos[0] -= this.options.scroll.scrollLeft-this.originalScrollLeft;      pos[1] -= this.options.scroll.scrollTop-this.originalScrollTop;    }        var p = [0,1].map(function(i){       return (point[i]-pos[i]-this.offset[i])     }.bind(this));        if(this.options.snap) {      if(typeof this.options.snap == ''function'') {        p = this.options.snap(p[0],p[1],this);      } else {      if(this.options.snap instanceof Array) {        p = p.map( function(v, i) {          return Math.round(v/this.options.snap[i])*this.options.snap[i] }.bind(this))      } else {        p = p.map( function(v) {          return Math.round(v/this.options.snap)*this.options.snap }.bind(this))      }    }}        var style = this.element.style;    if((!!this.options.constraint) || (this.options.constraint==''horizontal''))      style.left = p[0] + "px";    if((!!this.options.constraint) || (this.options.constraint==''vertical''))      style.top  = p[1] + "px";        if(style.visibility=="hidden") style.visibility = ""; // fix gecko rendering  },    stopScrolling: function() {    if(this.scrollInterval) {      clearInterval(this.scrollInterval);      this.scrollInterval = null;      Draggables._lastScrollPointer = null;    }  },    startScrolling: function(speed) {    if(!!(speed[0] || speed[1])) return;    this.scrollSpeed = [speed[0]*this.options.scrollSpeed,speed[1]*this.options.scrollSpeed];    this.lastScrolled = new Date();    this.scrollInterval = setInterval(this.scroll.bind(this), 10);  },    scroll: function() {    var current = new Date();    var delta = current - this.lastScrolled;    this.lastScrolled = current;    if(this.options.scroll == window) {      with (this._getWindowScroll(this.options.scroll)) {        if (this.scrollSpeed[0] || this.scrollSpeed[1]) {          var d = delta / 1000;          this.options.scroll.scrollTo( left + d*this.scrollSpeed[0], top + d*this.scrollSpeed[1] );        }      }    } else {      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;      this.options.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;    }        Position.prepare();    Droppables.show(Draggables._lastPointer, this.element);    Draggables.notify(''onDrag'', this);    if (this._isScrollChild) {      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;      if (Draggables._lastScrollPointer[0] < 0)        Draggables._lastScrollPointer[0] = 0;      if (Draggables._lastScrollPointer[1] < 0)        Draggables._lastScrollPointer[1] = 0;      this.draw(Draggables._lastScrollPointer);    }        if(this.options.change) this.options.change(this);  },    _getWindowScroll: function(w) {    var T, L, W, H;    with (w.document) {      if (w.document.documentElement && documentElement.scrollTop) {        T = documentElement.scrollTop;        L = documentElement.scrollLeft;      } else if (w.document.body) {        T = body.scrollTop;        L = body.scrollLeft;      }      if (w.innerWidth) {        W = w.innerWidth;        H = w.innerHeight;      } else if (w.document.documentElement && documentElement.clientWidth) {        W = documentElement.clientWidth;        H = documentElement.clientHeight;      } else {        W = body.offsetWidth;        H = body.offsetHeight      }    }    return { top: T, left: L, width: W, height: H };  }}/*--------------------------------------------------------------------------*/var SortableObserver = Class.create();SortableObserver.prototype = {  initialize: function(element, observer) {    this.element   = $(element);    this.observer  = observer;    this.lastValue = Sortable.serialize(this.element);  },    onStart: function() {    this.lastValue = Sortable.serialize(this.element);  },    onEnd: function() {    Sortable.unmark();    if(this.lastValue !!= Sortable.serialize(this.element))      this.observer(this.element)  }}var Sortable = {  SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,    sortables: {},    _findRootElement: function(element) {    while (element.tagName !!= "BODY") {        if(element.id && Sortable.sortables[element.id]) return element;      element = element.parentNode;    }  },  options: function(element) {    element = Sortable._findRootElement($(element));    if(!!element) return;    return Sortable.sortables[element.id];  },    destroy: function(element){    var s = Sortable.options(element);        if(s) {      Draggables.removeObserver(s.element);      s.droppables.each(function(d){ Droppables.remove(d) });      s.draggables.invoke(''destroy'');            delete Sortable.sortables[s.element.id];    }  },  create: function(element) {    element = $(element);    var options = Object.extend({       element:     element,      tag:         ''li'',       // assumes li children, override with tag: ''tagname''      dropOnEmpty: false,      tree:        false,      treeTag:     ''ul'',      overlap:     ''vertical'', // one of ''vertical'', ''horizontal''      constraint:  ''vertical'', // one of ''vertical'', ''horizontal'', false      containment: element,    // also takes array of elements (or id''s); or false      handle:      false,      // or a CSS class      only:        false,      delay:       0,      hoverclass:  null,      ghosting:    false,      scroll:      false,      scrollSensitivity: 20,      scrollSpeed: 15,      format:      this.SERIALIZE_RULE,      onChange:    Prototype.emptyFunction,      onUpdate:    Prototype.emptyFunction    }, arguments[1] || {});    // clear any old sortable with same element    this.destroy(element);    // build options for the draggables    var options_for_draggable = {      revert:      true,      scroll:      options.scroll,      scrollSpeed: options.scrollSpeed,      scrollSensitivity: options.scrollSensitivity,      delay:       options.delay,      ghosting:    options.ghosting,      constraint:  options.constraint,      handle:      options.handle };    if(options.starteffect)      options_for_draggable.starteffect = options.starteffect;    if(options.reverteffect)      options_for_draggable.reverteffect = options.reverteffect;    else      if(options.ghosting) options_for_draggable.reverteffect = function(element) {        element.style.top  = 0;        element.style.left = 0;      };    if(options.endeffect)      options_for_draggable.endeffect = options.endeffect;    if(options.zindex)      options_for_draggable.zindex = options.zindex;    // build options for the droppables      var options_for_droppable = {      overlap:     options.overlap,      containment: options.containment,      tree:        options.tree,      hoverclass:  options.hoverclass,      onHover:     Sortable.onHover      //greedy:      !!options.dropOnEmpty    }        var options_for_tree = {      onHover:      Sortable.onEmptyHover,      overlap:      options.overlap,      containment:  options.containment,      hoverclass:   options.hoverclass    }    // fix for gecko engine    Element.cleanWhitespace(element);     options.draggables = [];    options.droppables = [];    // drop on empty handling    if(options.dropOnEmpty || options.tree) {      Droppables.add(element, options_for_tree);      options.droppables.push(element);    }    (this.findElements(element, options) || []).each( function(e) {      // handles are per-draggable      var handle = options.handle ?         Element.childrenWithClassName(e, options.handle)[0] : e;          options.draggables.push(        new Draggable(e, Object.extend(options_for_draggable, { handle: handle })));      Droppables.add(e, options_for_droppable);      if(options.tree) e.treeNode = element;      options.droppables.push(e);          });        if(options.tree) {      (Sortable.findTreeElements(element, options) || []).each( function(e) {        Droppables.add(e, options_for_tree);        e.treeNode = element;        options.droppables.push(e);      });    }    // keep reference    this.sortables[element.id] = options;    // for onupdate    Draggables.addObserver(new SortableObserver(element, options.onUpdate));  },  // return all suitable-for-sortable elements in a guaranteed order  findElements: function(element, options) {    return Element.findChildren(      element, options.only, options.tree ? true : false, options.tag);  },    findTreeElements: function(element, options) {    return Element.findChildren(      element, options.only, options.tree ? true : false, options.treeTag);  },  onHover: function(element, dropon, overlap) {    if(Element.isParent(dropon, element)) return;    if(overlap > .33 && overlap < .66 && Sortable.options(dropon).tree) {      return;    } else if(overlap>0.5) {      Sortable.mark(dropon, ''before'');      if(dropon.previousSibling !!= element) {        var oldParentNode = element.parentNode;        element.style.visibility = "hidden"; // fix gecko rendering        dropon.parentNode.insertBefore(element, dropon);        if(dropon.parentNode!!=oldParentNode)           Sortable.options(oldParentNode).onChange(element);        Sortable.options(dropon.parentNode).onChange(element);      }    } else {      Sortable.mark(dropon, ''after'');      var nextElement = dropon.nextSibling || null;      if(nextElement !!= element) {        var oldParentNode = element.parentNode;        element.style.visibility = "hidden"; // fix gecko rendering        dropon.parentNode.insertBefore(element, nextElement);        if(dropon.parentNode!!=oldParentNode)           Sortable.options(oldParentNode).onChange(element);        Sortable.options(dropon.parentNode).onChange(element);      }    }  },    onEmptyHover: function(element, dropon, overlap) {    var oldParentNode = element.parentNode;    var droponOptions = Sortable.options(dropon);            if(!!Element.isParent(dropon, element)) {      var index;            var children = Sortable.findElements(dropon, {tag: droponOptions.tag, only: droponOptions.only});      var child = null;                  if(children) {        var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1.0 - overlap);                for (index = 0; index < children.length; index += 1) {          if (offset - Element.offsetSize (children[index], droponOptions.overlap) >= 0) {            offset -= Element.offsetSize (children[index], droponOptions.overlap);          } else if (offset - (Element.offsetSize (children[index], droponOptions.overlap) / 2) >= 0) {            child = index + 1 < children.length ? children[index + 1] : null;            break;          } else {            child = children[index];            break;          }        }      }            dropon.insertBefore(element, child);            Sortable.options(oldParentNode).onChange(element);      droponOptions.onChange(element);    }  },  unmark: function() {    if(Sortable._marker) Element.hide(Sortable._marker);  },  mark: function(dropon, position) {    // mark on ghosting only    var sortable = Sortable.options(dropon.parentNode);    if(sortable && !!sortable.ghosting) return;     if(!!Sortable._marker) {      Sortable._marker = $(''dropmarker'') || document.createElement(''DIV'');      Element.hide(Sortable._marker);      Element.addClassName(Sortable._marker, ''dropmarker'');      Sortable._marker.style.position = ''absolute'';      document.getElementsByTagName("body").item(0).appendChild(Sortable._marker);    }        var offsets = Position.cumulativeOffset(dropon);    Sortable._marker.style.left = offsets[0] + ''px'';    Sortable._marker.style.top = offsets[1] + ''px'';        if(position==''after'')      if(sortable.overlap == ''horizontal'')         Sortable._marker.style.left = (offsets[0]+dropon.clientWidth) + ''px'';      else        Sortable._marker.style.top = (offsets[1]+dropon.clientHeight) + ''px'';        Element.show(Sortable._marker);  },    _tree: function(element, options, parent) {    var children = Sortable.findElements(element, options) || [];      for (var i = 0; i < children.length; ++i) {      var match = children[i].id.match(options.format);      if (!!match) continue;            var child = {        id: encodeURIComponent(match ? match[1] : null),        element: element,        parent: parent,        children: new Array,        position: parent.children.length,        container: Sortable._findChildrenElement(children[i], options.treeTag.toUpperCase())      }            /* Get the element containing the children and recurse over it */      if (child.container)        this._tree(child.container, options, child)            parent.children.push (child);    }    return parent;   },  /* Finds the first element of the given tag type within a parent element.    Used for finding the first LI[ST] within a L[IST]I[TEM].*/  _findChildrenElement: function (element, containerTag) {    if (element && element.hasChildNodes)      for (var i = 0; i < element.childNodes.length; ++i)        if (element.childNodes[i].tagName == containerTag)          return element.childNodes[i];      return null;  },  tree: function(element) {    element = $(element);    var sortableOptions = this.options(element);    var options = Object.extend({      tag: sortableOptions.tag,      treeTag: sortableOptions.treeTag,      only: sortableOptions.only,      name: element.id,      format: sortableOptions.format    }, arguments[1] || {});        var root = {      id: null,      parent: null,      children: new Array,      container: element,      position: 0    }        return Sortable._tree (element, options, root);  },  /* Construct a [i] index for a particular node */  _constructIndex: function(node) {    var index = '''';    do {      if (node.id) index = ''['' + node.position + '']'' + index;    } while ((node = node.parent) !!= null);    return index;  },  sequence: function(element) {    element = $(element);    var options = Object.extend(this.options(element), arguments[1] || {});        return $(this.findElements(element, options) || []).map( function(item) {      return item.id.match(options.format) ? item.id.match(options.format)[1] : '''';    });  },  setSequence: function(element, new_sequence) {    element = $(element);    var options = Object.extend(this.options(element), arguments[2] || {});        var nodeMap = {};    this.findElements(element, options).each( function(n) {        if (n.id.match(options.format))            nodeMap[n.id.match(options.format)[1]] = [n, n.parentNode];        n.parentNode.removeChild(n);    });       new_sequence.each(function(ident) {      var n = nodeMap[ident];      if (n) {        n[1].appendChild(n[0]);        delete nodeMap[ident];      }    });  },    serialize: function(element) {    element = $(element);    var options = Object.extend(Sortable.options(element), arguments[1] || {});    var name = encodeURIComponent(      (arguments[1] && arguments[1].name) ? arguments[1].name : element.id);        if (options.tree) {      return Sortable.tree(element, arguments[1]).children.map( function (item) {        return [name + Sortable._constructIndex(item) + "[id]=" +                 encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));      }).flatten().join(''&'');    } else {      return Sortable.sequence(element, arguments[1]).map( function(item) {        return name + "[]=" + encodeURIComponent(item);      }).join(''&'');    }  }}/* Returns true if child is contained within element */Element.isParent = function(child, element) {  if (!!child.parentNode || child == element) return false;  if (child.parentNode == element) return true;  return Element.isParent(child.parentNode, element);}Element.findChildren = function(element, only, recursive, tagName) {      if(!!element.hasChildNodes()) return null;  tagName = tagName.toUpperCase();  if(only) only = [only].flatten();  var elements = [];  $A(element.childNodes).each( function(e) {    if(e.tagName && e.tagName.toUpperCase()==tagName &&      (!!only || (Element.classNames(e).detect(function(v) { return only.include(v) }))))        elements.push(e);    if(recursive) {      var grandchildren = Element.findChildren(e, only, recursive, tagName);      if(grandchildren) elements.push(grandchildren);    }  });  return (elements.length>0 ? elements.flatten() : []);}Element.offsetSize = function (element, type) {  if (type == ''vertical'' || type == ''height'')    return element.offsetHeight;  else    return element.offsetWidth;}'! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:41'!eControls	^ '// script.aculo.us controls.js v1.6.4, Wed Sep 06 11:30:58 CEST 2006// Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//           (c) 2005 Ivan Krstic (http://blogs.law.harvard.edu/ivan)//           (c) 2005 Jon Tirsen (http://www.tirsen.com)// Contributors://  Richard Livsey//  Rahul Bhargava//  Rob Wills// // See scriptaculous.js for full license.// Autocompleter.Base handles all the autocompletion functionality // that''s independent of the data source for autocompletion. This// includes drawing the autocompletion menu, observing keyboard// and mouse events, and similar.//// Specific autocompleters need to provide, at the very least, // a getUpdatedChoices function that will be invoked every time// the text inside the monitored textbox changes. This method // should get the text for which to provide autocompletion by// invoking this.getToken(), NOT by directly accessing// this.element.value. This is to allow incremental tokenized// autocompletion. Specific auto-completion logic (AJAX, etc)// belongs in getUpdatedChoices.//// Tokenized incremental autocompletion is enabled automatically// when an autocompleter is instantiated with the ''tokens'' option// in the options parameter, e.g.:// new Ajax.Autocompleter(''id'',''upd'', ''/url/'', { tokens: '','' });// will incrementally autocomplete with a comma as the token.// Additionally, '','' in the above example can be replaced with// a token array, e.g. { tokens: ['','', ''\n''] } which// enables autocompletion on multiple tokens. This is most // useful when one of the tokens is \n (a newline), as it // allows smart autocompletion after linebreaks.if(typeof Effect == ''undefined'')  throw("controls.js requires including script.aculo.us'' effects.js library");var Autocompleter = {}Autocompleter.Base = function() {};Autocompleter.Base.prototype = {  baseInitialize: function(element, update, options) {    this.element     = $(element);     this.update      = $(update);      this.hasFocus    = false;     this.changed     = false;     this.active      = false;     this.index       = 0;         this.entryCount  = 0;    if(this.setOptions)      this.setOptions(options);    else      this.options = options || {};    this.options.paramName    = this.options.paramName || this.element.name;    this.options.tokens       = this.options.tokens || [];    this.options.frequency    = this.options.frequency || 0.4;    this.options.minChars     = this.options.minChars || 1;    this.options.onShow       = this.options.onShow ||       function(element, update){         if(!!update.style.position || update.style.position==''absolute'') {          update.style.position = ''absolute'';          Position.clone(element, update, {            setHeight: false,             offsetTop: element.offsetHeight          });        }        Effect.Appear(update,{duration:0.15});      };    this.options.onHide = this.options.onHide ||       function(element, update){ new Effect.Fade(update,{duration:0.15}) };    if(typeof(this.options.tokens) == ''string'')       this.options.tokens = new Array(this.options.tokens);    this.observer = null;        this.element.setAttribute(''autocomplete'',''off'');    Element.hide(this.update);    Event.observe(this.element, "blur", this.onBlur.bindAsEventListener(this));    Event.observe(this.element, "keypress", this.onKeyPress.bindAsEventListener(this));  },  show: function() {    if(Element.getStyle(this.update, ''display'')==''none'') this.options.onShow(this.element, this.update);    if(!!this.iefix &&       (navigator.appVersion.indexOf(''MSIE'')>0) &&      (navigator.userAgent.indexOf(''Opera'')<0) &&      (Element.getStyle(this.update, ''position'')==''absolute'')) {      new Insertion.After(this.update,        ''<iframe id="'' + this.update.id + ''_iefix" ''+       ''style="display:none;position:absolute;filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0);" '' +       ''src="javascript:false;" frameborder="0" scrolling="no"></iframe>'');      this.iefix = $(this.update.id+''_iefix'');    }    if(this.iefix) setTimeout(this.fixIEOverlapping.bind(this), 50);  },    fixIEOverlapping: function() {    Position.clone(this.update, this.iefix, {setTop:(!!this.update.style.height)});    this.iefix.style.zIndex = 1;    this.update.style.zIndex = 2;    Element.show(this.iefix);  },  hide: function() {    this.stopIndicator();    if(Element.getStyle(this.update, ''display'')!!=''none'') this.options.onHide(this.element, this.update);    if(this.iefix) Element.hide(this.iefix);  },  startIndicator: function() {    if(this.options.indicator) Element.show(this.options.indicator);  },  stopIndicator: function() {    if(this.options.indicator) Element.hide(this.options.indicator);  },  onKeyPress: function(event) {    if(this.active)      switch(event.keyCode) {       case Event.KEY_TAB:       case Event.KEY_RETURN:         this.selectEntry();         Event.stop(event);       case Event.KEY_ESC:         this.hide();         this.active = false;         Event.stop(event);         return;       case Event.KEY_LEFT:       case Event.KEY_RIGHT:         return;       case Event.KEY_UP:         this.markPrevious();         this.render();         if(navigator.appVersion.indexOf(''AppleWebKit'')>0) Event.stop(event);         return;       case Event.KEY_DOWN:         this.markNext();         this.render();         if(navigator.appVersion.indexOf(''AppleWebKit'')>0) Event.stop(event);         return;      }     else        if(event.keyCode==Event.KEY_TAB || event.keyCode==Event.KEY_RETURN ||          (navigator.appVersion.indexOf(''AppleWebKit'') > 0 && event.keyCode == 0)) return;    this.changed = true;    this.hasFocus = true;    if(this.observer) clearTimeout(this.observer);      this.observer =         setTimeout(this.onObserverEvent.bind(this), this.options.frequency*1000);  },  activate: function() {    this.changed = false;    this.hasFocus = true;    this.getUpdatedChoices();  },  onHover: function(event) {    var element = Event.findElement(event, ''LI'');    if(this.index !!= element.autocompleteIndex)     {        this.index = element.autocompleteIndex;        this.render();    }    Event.stop(event);  },    onClick: function(event) {    var element = Event.findElement(event, ''LI'');    this.index = element.autocompleteIndex;    this.selectEntry();    this.hide();  },    onBlur: function(event) {    // needed to make click events working    setTimeout(this.hide.bind(this), 250);    this.hasFocus = false;    this.active = false;       },     render: function() {    if(this.entryCount > 0) {      for (var i = 0; i < this.entryCount; i++)        this.index==i ?           Element.addClassName(this.getEntry(i),"selected") :           Element.removeClassName(this.getEntry(i),"selected");              if(this.hasFocus) {         this.show();        this.active = true;      }    } else {      this.active = false;      this.hide();    }  },    markPrevious: function() {    if(this.index > 0) this.index--      else this.index = this.entryCount-1;    this.getEntry(this.index).scrollIntoView(true);  },    markNext: function() {    if(this.index < this.entryCount-1) this.index++      else this.index = 0;    this.getEntry(this.index).scrollIntoView(false);  },    getEntry: function(index) {    return this.update.firstChild.childNodes[index];  },    getCurrentEntry: function() {    return this.getEntry(this.index);  },    selectEntry: function() {    this.active = false;    this.updateElement(this.getCurrentEntry());  },  updateElement: function(selectedElement) {    if (this.options.updateElement) {      this.options.updateElement(selectedElement);      return;    }    var value = '''';    if (this.options.select) {      var nodes = document.getElementsByClassName(this.options.select, selectedElement) || [];      if(nodes.length>0) value = Element.collectTextNodes(nodes[0], this.options.select);    } else      value = Element.collectTextNodesIgnoreClass(selectedElement, ''informal'');        var lastTokenPos = this.findLastToken();    if (lastTokenPos !!= -1) {      var newValue = this.element.value.substr(0, lastTokenPos + 1);      var whitespace = this.element.value.substr(lastTokenPos + 1).match(/^\s+/);      if (whitespace)        newValue += whitespace[0];      this.element.value = newValue + value;    } else {      this.element.value = value;    }    this.element.focus();        if (this.options.afterUpdateElement)      this.options.afterUpdateElement(this.element, selectedElement);  },  updateChoices: function(choices) {    if(!!this.changed && this.hasFocus) {      this.update.innerHTML = choices;      Element.cleanWhitespace(this.update);      Element.cleanWhitespace(this.update.firstChild);      if(this.update.firstChild && this.update.firstChild.childNodes) {        this.entryCount =           this.update.firstChild.childNodes.length;        for (var i = 0; i < this.entryCount; i++) {          var entry = this.getEntry(i);          entry.autocompleteIndex = i;          this.addObservers(entry);        }      } else {         this.entryCount = 0;      }      this.stopIndicator();      this.index = 0;            if(this.entryCount==1 && this.options.autoSelect) {        this.selectEntry();        this.hide();      } else {        this.render();      }    }  },  addObservers: function(element) {    Event.observe(element, "mouseover", this.onHover.bindAsEventListener(this));    Event.observe(element, "click", this.onClick.bindAsEventListener(this));  },  onObserverEvent: function() {    this.changed = false;       if(this.getToken().length>=this.options.minChars) {      this.startIndicator();      this.getUpdatedChoices();    } else {      this.active = false;      this.hide();    }  },  getToken: function() {    var tokenPos = this.findLastToken();    if (tokenPos !!= -1)      var ret = this.element.value.substr(tokenPos + 1).replace(/^\s+/,'''').replace(/\s+$/,'''');    else      var ret = this.element.value;    return /\n/.test(ret) ? '''' : ret;  },  findLastToken: function() {    var lastTokenPos = -1;    for (var i=0; i<this.options.tokens.length; i++) {      var thisTokenPos = this.element.value.lastIndexOf(this.options.tokens[i]);      if (thisTokenPos > lastTokenPos)        lastTokenPos = thisTokenPos;    }    return lastTokenPos;  }}Ajax.Autocompleter = Class.create();Object.extend(Object.extend(Ajax.Autocompleter.prototype, Autocompleter.Base.prototype), {  initialize: function(element, update, url, options) {    this.baseInitialize(element, update, options);    this.options.asynchronous  = true;    this.options.onComplete    = this.onComplete.bind(this);    this.options.defaultParams = this.options.parameters || null;    this.url                   = url;  },  getUpdatedChoices: function() {    entry = encodeURIComponent(this.options.paramName) + ''='' +       encodeURIComponent(this.getToken());    this.options.parameters = this.options.callback ?      this.options.callback(this.element, entry) : entry;    if(this.options.defaultParams)       this.options.parameters += ''&'' + this.options.defaultParams;    new Ajax.Request(this.url, this.options);  },  onComplete: function(request) {    this.updateChoices(request.responseText);  }});// The local array autocompleter. Used when you''d prefer to// inject an array of autocompletion options into the page, rather// than sending out Ajax queries, which can be quite slow sometimes.//// The constructor takes four parameters. The first two are, as usual,// the id of the monitored textbox, and id of the autocompletion menu.// The third is the array you want to autocomplete from, and the fourth// is the options block.//// Extra local autocompletion options:// - choices - How many autocompletion choices to offer//// - partialSearch - If false, the autocompleter will match entered//                    text only at the beginning of strings in the //                    autocomplete array. Defaults to true, which will//                    match text at the beginning of any *word* in the//                    strings in the autocomplete array. If you want to//                    search anywhere in the string, additionally set//                    the option fullSearch to true (default: off).//// - fullSsearch - Search anywhere in autocomplete array strings.//// - partialChars - How many characters to enter before triggering//                   a partial match (unlike minChars, which defines//                   how many characters are required to do any match//                   at all). Defaults to 2.//// - ignoreCase - Whether to ignore case when autocompleting.//                 Defaults to true.//// It''s possible to pass in a custom function as the ''selector'' // option, if you prefer to write your own autocompletion logic.// In that case, the other options above will not apply unless// you support them.Autocompleter.Local = Class.create();Autocompleter.Local.prototype = Object.extend(new Autocompleter.Base(), {  initialize: function(element, update, array, options) {    this.baseInitialize(element, update, options);    this.options.array = array;  },  getUpdatedChoices: function() {    this.updateChoices(this.options.selector(this));  },  setOptions: function(options) {    this.options = Object.extend({      choices: 10,      partialSearch: true,      partialChars: 2,      ignoreCase: true,      fullSearch: false,      selector: function(instance) {        var ret       = []; // Beginning matches        var partial   = []; // Inside matches        var entry     = instance.getToken();        var count     = 0;        for (var i = 0; i < instance.options.array.length &&            ret.length < instance.options.choices ; i++) {           var elem = instance.options.array[i];          var foundPos = instance.options.ignoreCase ?             elem.toLowerCase().indexOf(entry.toLowerCase()) :             elem.indexOf(entry);          while (foundPos !!= -1) {            if (foundPos == 0 && elem.length !!= entry.length) {               ret.push("<li><strong>" + elem.substr(0, entry.length) + "</strong>" +                 elem.substr(entry.length) + "</li>");              break;            } else if (entry.length >= instance.options.partialChars &&               instance.options.partialSearch && foundPos !!= -1) {              if (instance.options.fullSearch || /\s/.test(elem.substr(foundPos-1,1))) {                partial.push("<li>" + elem.substr(0, foundPos) + "<strong>" +                  elem.substr(foundPos, entry.length) + "</strong>" + elem.substr(                  foundPos + entry.length) + "</li>");                break;              }            }            foundPos = instance.options.ignoreCase ?               elem.toLowerCase().indexOf(entry.toLowerCase(), foundPos + 1) :               elem.indexOf(entry, foundPos + 1);          }        }        if (partial.length)          ret = ret.concat(partial.slice(0, instance.options.choices - ret.length))        return "<ul>" + ret.join('''') + "</ul>";      }    }, options || {});  }});// AJAX in-place editor//// see documentation on http://wiki.script.aculo.us/scriptaculous/show/Ajax.InPlaceEditor// Use this if you notice weird scrolling problems on some browsers,// the DOM might be a bit confused when this gets called so do this// waits 1 ms (with setTimeout) until it does the activationField.scrollFreeActivate = function(field) {  setTimeout(function() {    Field.activate(field);  }, 1);}Ajax.InPlaceEditor = Class.create();Ajax.InPlaceEditor.defaultHighlightColor = "#FFFF99";Ajax.InPlaceEditor.prototype = {  initialize: function(element, url, options) {    this.url = url;    this.element = $(element);    this.options = Object.extend({      okButton: true,      okText: "ok",      cancelLink: true,      cancelText: "cancel",      savingText: "Saving...",      clickToEditText: "Click to edit",      okText: "ok",      rows: 1,      onComplete: function(transport, element) {        new Effect.Highlight(element, {startcolor: this.options.highlightcolor});      },      onFailure: function(transport) {        alert("Error communicating with the server: " + transport.responseText.stripTags());      },      callback: function(form) {        return Form.serialize(form);      },      handleLineBreaks: true,      loadingText: ''Loading...'',      savingClassName: ''inplaceeditor-saving'',      loadingClassName: ''inplaceeditor-loading'',      formClassName: ''inplaceeditor-form'',      highlightcolor: Ajax.InPlaceEditor.defaultHighlightColor,      highlightendcolor: "#FFFFFF",      externalControl: null,      submitOnBlur: false,      ajaxOptions: {},      evalScripts: false    }, options || {});    if(!!this.options.formId && this.element.id) {      this.options.formId = this.element.id + "-inplaceeditor";      if ($(this.options.formId)) {        // there''s already a form with that name, don''t specify an id        this.options.formId = null;      }    }        if (this.options.externalControl) {      this.options.externalControl = $(this.options.externalControl);    }        this.originalBackground = Element.getStyle(this.element, ''background-color'');    if (!!this.originalBackground) {      this.originalBackground = "transparent";    }        this.element.title = this.options.clickToEditText;        this.onclickListener = this.enterEditMode.bindAsEventListener(this);    this.mouseoverListener = this.enterHover.bindAsEventListener(this);    this.mouseoutListener = this.leaveHover.bindAsEventListener(this);    Event.observe(this.element, ''click'', this.onclickListener);    Event.observe(this.element, ''mouseover'', this.mouseoverListener);    Event.observe(this.element, ''mouseout'', this.mouseoutListener);    if (this.options.externalControl) {      Event.observe(this.options.externalControl, ''click'', this.onclickListener);      Event.observe(this.options.externalControl, ''mouseover'', this.mouseoverListener);      Event.observe(this.options.externalControl, ''mouseout'', this.mouseoutListener);    }  },  enterEditMode: function(evt) {    if (this.saving) return;    if (this.editing) return;    this.editing = true;    this.onEnterEditMode();    if (this.options.externalControl) {      Element.hide(this.options.externalControl);    }    Element.hide(this.element);    this.createForm();    this.element.parentNode.insertBefore(this.form, this.element);    if (!!this.options.loadTextURL) Field.scrollFreeActivate(this.editField);    // stop the event to avoid a page refresh in Safari    if (evt) {      Event.stop(evt);    }    return false;  },  createForm: function() {    this.form = document.createElement("form");    this.form.id = this.options.formId;    Element.addClassName(this.form, this.options.formClassName)    this.form.onsubmit = this.onSubmit.bind(this);    this.createEditField();    if (this.options.textarea) {      var br = document.createElement("br");      this.form.appendChild(br);    }    if (this.options.okButton) {      okButton = document.createElement("input");      okButton.type = "submit";      okButton.value = this.options.okText;      okButton.className = ''editor_ok_button'';      this.form.appendChild(okButton);    }    if (this.options.cancelLink) {      cancelLink = document.createElement("a");      cancelLink.href = "#";      cancelLink.appendChild(document.createTextNode(this.options.cancelText));      cancelLink.onclick = this.onclickCancel.bind(this);      cancelLink.className = ''editor_cancel'';            this.form.appendChild(cancelLink);    }  },  hasHTMLLineBreaks: function(string) {    if (!!this.options.handleLineBreaks) return false;    return string.match(/<br/i) || string.match(/<p>/i);  },  convertHTMLLineBreaks: function(string) {    return string.replace(/<br>/gi, "\n").replace(/<br\/>/gi, "\n").replace(/<\/p>/gi, "\n").replace(/<p>/gi, "");  },  createEditField: function() {    var text;    if(this.options.loadTextURL) {      text = this.options.loadingText;    } else {      text = this.getText();    }    var obj = this;        if (this.options.rows == 1 && !!this.hasHTMLLineBreaks(text)) {      this.options.textarea = false;      var textField = document.createElement("input");      textField.obj = this;      textField.type = "text";      textField.name = "value";      textField.value = text;      textField.style.backgroundColor = this.options.highlightcolor;      textField.className = ''editor_field'';      var size = this.options.size || this.options.cols || 0;      if (size !!= 0) textField.size = size;      if (this.options.submitOnBlur)        textField.onblur = this.onSubmit.bind(this);      this.editField = textField;    } else {      this.options.textarea = true;      var textArea = document.createElement("textarea");      textArea.obj = this;      textArea.name = "value";      textArea.value = this.convertHTMLLineBreaks(text);      textArea.rows = this.options.rows;      textArea.cols = this.options.cols || 40;      textArea.className = ''editor_field'';            if (this.options.submitOnBlur)        textArea.onblur = this.onSubmit.bind(this);      this.editField = textArea;    }        if(this.options.loadTextURL) {      this.loadExternalText();    }    this.form.appendChild(this.editField);  },  getText: function() {    return this.element.innerHTML;  },  loadExternalText: function() {    Element.addClassName(this.form, this.options.loadingClassName);    this.editField.disabled = true;    new Ajax.Request(      this.options.loadTextURL,      Object.extend({        asynchronous: true,        onComplete: this.onLoadedExternalText.bind(this)      }, this.options.ajaxOptions)    );  },  onLoadedExternalText: function(transport) {    Element.removeClassName(this.form, this.options.loadingClassName);    this.editField.disabled = false;    this.editField.value = transport.responseText.stripTags();    Field.scrollFreeActivate(this.editField);  },  onclickCancel: function() {    this.onComplete();    this.leaveEditMode();    return false;  },  onFailure: function(transport) {    this.options.onFailure(transport);    if (this.oldInnerHTML) {      this.element.innerHTML = this.oldInnerHTML;      this.oldInnerHTML = null;    }    return false;  },  onSubmit: function() {    // onLoading resets these so we need to save them away for the Ajax call    var form = this.form;    var value = this.editField.value;        // do this first, sometimes the ajax call returns before we get a chance to switch on Saving...    // which means this will actually switch on Saving... *after* we''ve left edit mode causing Saving...    // to be displayed indefinitely    this.onLoading();        if (this.options.evalScripts) {      new Ajax.Request(        this.url, Object.extend({          parameters: this.options.callback(form, value),          onComplete: this.onComplete.bind(this),          onFailure: this.onFailure.bind(this),          asynchronous:true,           evalScripts:true        }, this.options.ajaxOptions));    } else  {      new Ajax.Updater(        { success: this.element,          // don''t update on failure (this could be an option)          failure: null },         this.url, Object.extend({          parameters: this.options.callback(form, value),          onComplete: this.onComplete.bind(this),          onFailure: this.onFailure.bind(this)        }, this.options.ajaxOptions));    }    // stop the event to avoid a page refresh in Safari    if (arguments.length > 1) {      Event.stop(arguments[0]);    }    return false;  },  onLoading: function() {    this.saving = true;    this.removeForm();    this.leaveHover();    this.showSaving();  },  showSaving: function() {    this.oldInnerHTML = this.element.innerHTML;    this.element.innerHTML = this.options.savingText;    Element.addClassName(this.element, this.options.savingClassName);    this.element.style.backgroundColor = this.originalBackground;    Element.show(this.element);  },  removeForm: function() {    if(this.form) {      if (this.form.parentNode) Element.remove(this.form);      this.form = null;    }  },  enterHover: function() {    if (this.saving) return;    this.element.style.backgroundColor = this.options.highlightcolor;    if (this.effect) {      this.effect.cancel();    }    Element.addClassName(this.element, this.options.hoverClassName)  },  leaveHover: function() {    if (this.options.backgroundColor) {      this.element.style.backgroundColor = this.oldBackground;    }    Element.removeClassName(this.element, this.options.hoverClassName)    if (this.saving) return;    this.effect = new Effect.Highlight(this.element, {      startcolor: this.options.highlightcolor,      endcolor: this.options.highlightendcolor,      restorecolor: this.originalBackground    });  },  leaveEditMode: function() {    Element.removeClassName(this.element, this.options.savingClassName);    this.removeForm();    this.leaveHover();    this.element.style.backgroundColor = this.originalBackground;    Element.show(this.element);    if (this.options.externalControl) {      Element.show(this.options.externalControl);    }    this.editing = false;    this.saving = false;    this.oldInnerHTML = null;    this.onLeaveEditMode();  },  onComplete: function(transport) {    this.leaveEditMode();    this.options.onComplete.bind(this)(transport, this.element);  },  onEnterEditMode: function() {},  onLeaveEditMode: function() {},  dispose: function() {    if (this.oldInnerHTML) {      this.element.innerHTML = this.oldInnerHTML;    }    this.leaveEditMode();    Event.stopObserving(this.element, ''click'', this.onclickListener);    Event.stopObserving(this.element, ''mouseover'', this.mouseoverListener);    Event.stopObserving(this.element, ''mouseout'', this.mouseoutListener);    if (this.options.externalControl) {      Event.stopObserving(this.options.externalControl, ''click'', this.onclickListener);      Event.stopObserving(this.options.externalControl, ''mouseover'', this.mouseoverListener);      Event.stopObserving(this.options.externalControl, ''mouseout'', this.mouseoutListener);    }  }};Ajax.InPlaceCollectionEditor = Class.create();Object.extend(Ajax.InPlaceCollectionEditor.prototype, Ajax.InPlaceEditor.prototype);Object.extend(Ajax.InPlaceCollectionEditor.prototype, {  createEditField: function() {    if (!!this.cached_selectTag) {      var selectTag = document.createElement("select");      var collection = this.options.collection || [];      var optionTag;      collection.each(function(e,i) {        optionTag = document.createElement("option");        optionTag.value = (e instanceof Array) ? e[0] : e;        if((typeof this.options.value == ''undefined'') &&           ((e instanceof Array) ? this.element.innerHTML == e[1] : e == optionTag.value)) optionTag.selected = true;        if(this.options.value==optionTag.value) optionTag.selected = true;        optionTag.appendChild(document.createTextNode((e instanceof Array) ? e[1] : e));        selectTag.appendChild(optionTag);      }.bind(this));      this.cached_selectTag = selectTag;    }    this.editField = this.cached_selectTag;    if(this.options.loadTextURL) this.loadExternalText();    this.form.appendChild(this.editField);    this.options.callback = function(form, value) {      return "value=" + encodeURIComponent(value);    }  }});// Delayed observer, like Form.Element.Observer, // but waits for delay after last key input// Ideal for live-search fieldsForm.Element.DelayedObserver = Class.create();Form.Element.DelayedObserver.prototype = {  initialize: function(element, delay, callback) {    this.delay     = delay || 0.5;    this.element   = $(element);    this.callback  = callback;    this.timer     = null;    this.lastValue = $F(this.element);     Event.observe(this.element,''keyup'',this.delayedListener.bindAsEventListener(this));  },  delayedListener: function(event) {    if(this.lastValue == $F(this.element)) return;    if(this.timer) clearTimeout(this.timer);    this.timer = setTimeout(this.onTimerEvent.bind(this), this.delay * 1000);    this.lastValue = $F(this.element);  },  onTimerEvent: function() {    this.timer = null;    this.callback(this.element, $F(this.element));  }};'! !!SULibrary methodsFor: 'scriptaculous' stamp: 'lr 9/6/2006 13:41'!fSlider	^ '// script.aculo.us slider.js v1.6.4, Wed Sep 06 11:30:58 CEST 2006// Copyright (c) 2005 Marty Haught, Thomas Fuchs //// See http://script.aculo.us for more info// // Permission is hereby granted, free of charge, to any person obtaining// a copy of this software and associated documentation files (the// "Software"), to deal in the Software without restriction, including// without limitation the rights to use, copy, modify, merge, publish,// distribute, sublicense, and/or sell copies of the Software, and to// permit persons to whom the Software is furnished to do so, subject to// the following conditions:// // The above copyright notice and this permission notice shall be// included in all copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.if(!!Control) var Control = {};Control.Slider = Class.create();// options://  axis: ''vertical'', or ''horizontal'' (default)//// callbacks://  onChange(value)//  onSlide(value)Control.Slider.prototype = {  initialize: function(handle, track, options) {    var slider = this;        if(handle instanceof Array) {      this.handles = handle.collect( function(e) { return $(e) });    } else {      this.handles = [$(handle)];    }        this.track   = $(track);    this.options = options || {};    this.axis      = this.options.axis || ''horizontal'';    this.increment = this.options.increment || 1;    this.step      = parseInt(this.options.step || ''1'');    this.range     = this.options.range || $R(0,1);        this.value     = 0; // assure backwards compat    this.values    = this.handles.map( function() { return 0 });    this.spans     = this.options.spans ? this.options.spans.map(function(s){ return $(s) }) : false;    this.options.startSpan = $(this.options.startSpan || null);    this.options.endSpan   = $(this.options.endSpan || null);    this.restricted = this.options.restricted || false;    this.maximum   = this.options.maximum || this.range.end;    this.minimum   = this.options.minimum || this.range.start;    // Will be used to align the handle onto the track, if necessary    this.alignX = parseInt(this.options.alignX || ''0'');    this.alignY = parseInt(this.options.alignY || ''0'');        this.trackLength = this.maximumOffset() - this.minimumOffset();    this.handleLength = this.isVertical() ?       (this.handles[0].offsetHeight !!= 0 ?         this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/,"")) :       (this.handles[0].offsetWidth !!= 0 ? this.handles[0].offsetWidth :         this.handles[0].style.width.replace(/px$/,""));    this.active   = false;    this.dragging = false;    this.disabled = false;    if(this.options.disabled) this.setDisabled();    // Allowed values array    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;    if(this.allowedValues) {      this.minimum = this.allowedValues.min();      this.maximum = this.allowedValues.max();    }    this.eventMouseDown = this.startDrag.bindAsEventListener(this);    this.eventMouseUp   = this.endDrag.bindAsEventListener(this);    this.eventMouseMove = this.update.bindAsEventListener(this);    // Initialize handles in reverse (make sure first handle is active)    this.handles.each( function(h,i) {      i = slider.handles.length-1-i;      slider.setValue(parseFloat(        (slider.options.sliderValue instanceof Array ?           slider.options.sliderValue[i] : slider.options.sliderValue) ||          slider.range.start), i);      Element.makePositioned(h); // fix IE      Event.observe(h, "mousedown", slider.eventMouseDown);    });        Event.observe(this.track, "mousedown", this.eventMouseDown);    Event.observe(document, "mouseup", this.eventMouseUp);    Event.observe(document, "mousemove", this.eventMouseMove);        this.initialized = true;  },  dispose: function() {    var slider = this;        Event.stopObserving(this.track, "mousedown", this.eventMouseDown);    Event.stopObserving(document, "mouseup", this.eventMouseUp);    Event.stopObserving(document, "mousemove", this.eventMouseMove);    this.handles.each( function(h) {      Event.stopObserving(h, "mousedown", slider.eventMouseDown);    });  },  setDisabled: function(){    this.disabled = true;  },  setEnabled: function(){    this.disabled = false;  },    getNearestValue: function(value){    if(this.allowedValues){      if(value >= this.allowedValues.max()) return(this.allowedValues.max());      if(value <= this.allowedValues.min()) return(this.allowedValues.min());            var offset = Math.abs(this.allowedValues[0] - value);      var newValue = this.allowedValues[0];      this.allowedValues.each( function(v) {        var currentOffset = Math.abs(v - value);        if(currentOffset <= offset){          newValue = v;          offset = currentOffset;        }       });      return newValue;    }    if(value > this.range.end) return this.range.end;    if(value < this.range.start) return this.range.start;    return value;  },  setValue: function(sliderValue, handleIdx){    if(!!this.active) {      this.activeHandleIdx = handleIdx || 0;      this.activeHandle    = this.handles[this.activeHandleIdx];      this.updateStyles();    }    handleIdx = handleIdx || this.activeHandleIdx || 0;    if(this.initialized && this.restricted) {      if((handleIdx>0) && (sliderValue<this.values[handleIdx-1]))        sliderValue = this.values[handleIdx-1];      if((handleIdx < (this.handles.length-1)) && (sliderValue>this.values[handleIdx+1]))        sliderValue = this.values[handleIdx+1];    }    sliderValue = this.getNearestValue(sliderValue);    this.values[handleIdx] = sliderValue;    this.value = this.values[0]; // assure backwards compat        this.handles[handleIdx].style[this.isVertical() ? ''top'' : ''left''] =       this.translateToPx(sliderValue);        this.drawSpans();    if(!!this.dragging || !!this.event) this.updateFinished();  },  setValueBy: function(delta, handleIdx) {    this.setValue(this.values[handleIdx || this.activeHandleIdx || 0] + delta,       handleIdx || this.activeHandleIdx || 0);  },  translateToPx: function(value) {    return Math.round(      ((this.trackLength-this.handleLength)/(this.range.end-this.range.start)) *       (value - this.range.start)) + "px";  },  translateToValue: function(offset) {    return ((offset/(this.trackLength-this.handleLength) *       (this.range.end-this.range.start)) + this.range.start);  },  getRange: function(range) {    var v = this.values.sortBy(Prototype.K);     range = range || 0;    return $R(v[range],v[range+1]);  },  minimumOffset: function(){    return(this.isVertical() ? this.alignY : this.alignX);  },  maximumOffset: function(){    return(this.isVertical() ?       (this.track.offsetHeight !!= 0 ? this.track.offsetHeight :        this.track.style.height.replace(/px$/,"")) - this.alignY :       (this.track.offsetWidth !!= 0 ? this.track.offsetWidth :         this.track.style.width.replace(/px$/,"")) - this.alignY);  },    isVertical:  function(){    return (this.axis == ''vertical'');  },  drawSpans: function() {    var slider = this;    if(this.spans)      $R(0, this.spans.length-1).each(function(r) { slider.setSpan(slider.spans[r], slider.getRange(r)) });    if(this.options.startSpan)      this.setSpan(this.options.startSpan,        $R(0, this.values.length>1 ? this.getRange(0).min() : this.value ));    if(this.options.endSpan)      this.setSpan(this.options.endSpan,         $R(this.values.length>1 ? this.getRange(this.spans.length-1).max() : this.value, this.maximum));  },  setSpan: function(span, range) {    if(this.isVertical()) {      span.style.top = this.translateToPx(range.start);      span.style.height = this.translateToPx(range.end - range.start + this.range.start);    } else {      span.style.left = this.translateToPx(range.start);      span.style.width = this.translateToPx(range.end - range.start + this.range.start);    }  },  updateStyles: function() {    this.handles.each( function(h){ Element.removeClassName(h, ''selected'') });    Element.addClassName(this.activeHandle, ''selected'');  },  startDrag: function(event) {    if(Event.isLeftClick(event)) {      if(!!this.disabled){        this.active = true;                var handle = Event.element(event);        var pointer  = [Event.pointerX(event), Event.pointerY(event)];        var track = handle;        if(track==this.track) {          var offsets  = Position.cumulativeOffset(this.track);           this.event = event;          this.setValue(this.translateToValue(            (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength/2)          ));          var offsets  = Position.cumulativeOffset(this.activeHandle);          this.offsetX = (pointer[0] - offsets[0]);          this.offsetY = (pointer[1] - offsets[1]);        } else {          // find the handle (prevents issues with Safari)          while((this.handles.indexOf(handle) == -1) && handle.parentNode)             handle = handle.parentNode;                  this.activeHandle    = handle;          this.activeHandleIdx = this.handles.indexOf(this.activeHandle);          this.updateStyles();                  var offsets  = Position.cumulativeOffset(this.activeHandle);          this.offsetX = (pointer[0] - offsets[0]);          this.offsetY = (pointer[1] - offsets[1]);        }      }      Event.stop(event);    }  },  update: function(event) {   if(this.active) {      if(!!this.dragging) this.dragging = true;      this.draw(event);      // fix AppleWebKit rendering      if(navigator.appVersion.indexOf(''AppleWebKit'')>0) window.scrollBy(0,0);      Event.stop(event);   }  },  draw: function(event) {    var pointer = [Event.pointerX(event), Event.pointerY(event)];    var offsets = Position.cumulativeOffset(this.track);    pointer[0] -= this.offsetX + offsets[0];    pointer[1] -= this.offsetY + offsets[1];    this.event = event;    this.setValue(this.translateToValue( this.isVertical() ? pointer[1] : pointer[0] ));    if(this.initialized && this.options.onSlide)      this.options.onSlide(this.values.length>1 ? this.values : this.value, this);  },  endDrag: function(event) {    if(this.active && this.dragging) {      this.finishDrag(event, true);      Event.stop(event);    }    this.active = false;    this.dragging = false;  },    finishDrag: function(event, success) {    this.active = false;    this.dragging = false;    this.updateFinished();  },  updateFinished: function() {    if(this.initialized && this.options.onChange)       this.options.onChange(this.values.length>1 ? this.values : this.value, this);    this.event = null;  }}'! !!SULibrary methodsFor: 'patches' stamp: 'lr 5/2/2006 11:11'!xTree	^ 'Object.extend(Sortable, {	tree_sequence: function(element, options) {		return Sortable.tree(element, options).children.map(function(each) {			return [encodeURIComponent(each.parent.id) + ":" + encodeURIComponent(each.id)]				.concat(each.children.map(arguments.callee));		}).flatten().join(","); } });'! !"Scriptaculous"!!MorphicTransform methodsFor: '*magma client' stamp: 'cmm 5/3/2005 16:37'!maAllowsWriteBarrier 	"Had a problem where this guy was losing his writeBarrier (nil) and so was blowing when it was modified.  Thought it had something to do with the fact that I was copied, but my testing shows the copy maintains access to the same WriteBarrier."	^ false	"My testing shows it should be ok..  What gives??| mt1 mt2 mt3 mt4 wb |wb _ WriteBarrier new.mt1 _ self offset: 2@3.wb add: mt1.mt2 _ mt1 withOffset: 3@4.mt3 _ mt2 withOffset: 4@5.mt4 _ mt1 withOffset: 5@6.{ mt1. mt2. mt3. mt4 } do: [ : e | e setAngle: Float pi ].{ mt1. mt2. mt3. mt4 } do: [ : e | e writeBarrier == wb ifFalse: [ self halt ] ].{ mt1. mt2. mt3. mt4 } do: [ : e | wb remove: e ]"! !!BlockContext class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:14'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ (aMaObjectSerializer materializeGraph: aByteArray) asBlockContext! !!BlockContext methodsFor: '*ma base additions' stamp: 'cmm 3/13/2005 17:37' prior: 17557630!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count _ 0.	endTime _ Time millisecondClockValue + 5000.	startTime _ Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count _ count + 1 ].	endTime _ Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!BlockContext methodsFor: '*ma object serialization' stamp: 'cmm 11/10/2004 12:01'!maAsStorageObject	^ MaBlockContextStorage newFor: self! !!BlockContext methodsFor: '*ma base additions' stamp: 'cmm 12/5/2002 21:43'!maBench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count _ 0.	endTime _ Time millisecondClockValue + 5000.	startTime _ Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count _ count + 1 ].	endTime _ Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!BlockContext methodsFor: '*ma time objects' stamp: 'cmm 12/5/2002 21:46'!maCalendarTimeToRun	| start |	start _ MaCalendarTime now.	self value.	^MaCalendarTime now - start! !!BlockContext methodsFor: '*ma base additions' stamp: 'cmm 3/23/2003 22:40'!maOn: exc1 do: block1 on: exc2 do: block2	^[		[ self value ]			on: exc1			do: block1 ]		on: exc2		do: block2! !!BlockContext methodsFor: '*ma base additions' stamp: 'cmm 3/23/2003 22:43'!maOn: exc1 do: block1 on: exc2 do: block2 on: exc3 do: block3	^[		[ self value ]			on: exc1			do: block1 ]		maOn: exc2		do: block2		on: exc3		do: block3! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 17:48'!assertConsistent: aBTree	| depths root |	root _ aBTree root.	 " http://www.cs.umbc.edu/~woodcock/cmsc341/btree/defn.htmlA B-Tree of order m is a search tree, where the data   (or pointers to it) is stored at the leaves, such that:1) the root is either a leaf (as well--i.e. the tree is      a single node) or has between 2 and m children"		self assert: (root isLeaf or: [root values size between: 2 and: aBTree order]).	"  2) all other (non-root) nodes have at least m/2 children,     but no more than m children"	root allChildrenDo: [:ea | self assert: (ea values size between: (aBTree order // 2) and: aBTree order)]. "  3) all leaves are at the same depth"	depths _ Set new.	root withAllChildrenDo: [:ea | ea isLeaf ifTrue: [depths add: ea depth]].	self assert: depths size = 1.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 22:48'!assertSorted: aTree	| last |	last _ nil.	aTree keysAndValuesDo:		[:k :v |		last ifNotNil: [self assert: last < k].		last _ k]! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:58'!checkTree: tree array: pairArray	pairArray withIndexDo:		[:pair :i |		tree at: pair first put: pair second.		self assert: tree size = i.		"self assertConsistent: tree.		self assertSorted: tree"].	pairArray shuffled do:		[:pair |		self assert: (tree at: pair first) = pair second].	self assert: tree size = pairArray size.	self assertConsistent: tree.	self assertSorted: tree.	^ tree		 ! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:59'!checkTree: tree items: count	| pairArray  |	pairArray _ ((1 to: count) collect: [:i | Array with: i asString with: i]) shuffled.	self checkTree: tree array: pairArray! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:59'!checkTreeWithOrder: order items: count	self checkTree: (BTree order: order) items: count! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:08'!testAddAndRetrieveWithSplit	self checkTreeWithOrder: 4 items: 5! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:08'!testAddAndRetrieveWithTwoSplits	self checkTreeWithOrder: 4 items: 17! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 14:45'!testCommonKeysDifferentValues	| large small expectedResults results |	large _ BTree new.	1 to: 1000 by: 2 do: [:i | large at: i put: i].	small _ BTree new.	2 to: 2000 by: 11 do: [:i | small at: i put: i*2].		expectedResults _ ((-9 to: 1000 by: 22) allButFirst collect: [:i | Array with: i with: i with: i*2]) asOrderedCollection.		results _ OrderedCollection new.	large commonKeysWith: small keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v1 with: v2)].	self assert: results = expectedResults.		results _ OrderedCollection new.	small commonKeysWith: large keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v2 with: v1)].	self assert: results = expectedResults! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 14:45'!testCommonKeysSameValues	| large small expectedResults results |	large _ BTree new.	1 to: 1000 by: 2 do: [:i | large at: i put: i].	small _ BTree new.	2 to: 2000 by: 11 do: [:i | small at: i put: i].		expectedResults _ ((-9 to: 1000 by: 22) allButFirst collect: [:i | Array with: i with: i with: i]) asOrderedCollection.		results _ OrderedCollection new.	large commonKeysWith: small keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v1 with: v2)].	self assert: results = expectedResults.		results _ OrderedCollection new.	small commonKeysWith: large keysAndValuesDo:		[:k :v1 :v2 |		results add: (Array with: k with: v2 with: v1)].	self assert: results = expectedResults! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testEmptyTree	self checkTreeWithOrder: 5 items: 0! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:44'!testLargeTree	"self checkTreeWithOrder: 8 items: 5000"	! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:08'!testMissing	| tree |	tree _ BTree new.	tree at: 1 put: 'foo'.	tree at: 2 put: 'bar'.	self assert: (tree at: 1 ifAbsent: [42]) = 'foo'.	self assert: (tree at: 2 ifAbsent: [42]) = 'bar'.	self assert: (tree at: 3 ifAbsent: [42]) = 42.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testMultipleAddAndRetrieve	self checkTreeWithOrder: 5 items: 3! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 10/8/2004 18:06'!testRange	| tree keys |	tree _ BTree new.	1 to: 100 by: 2 do: [:ea | tree at: ea put: ea * 2].	self assert: tree size = 50.	keys _ OrderedCollection new.	tree from: 12 to: 19 keysAndValuesDo:		[:k :v |		self assert: k * 2 = v.		keys add: k].	self assert: keys asArray = #(13 15 17 19).	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:08'!testRemoval	| tree |	tree _ BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	tree removeKey: #d.	self assert: tree size = 11.	self assert: (tree at: #d ifAbsent: [32]) = 32.	tree removeKey: #k.	self assert: tree size = 10.	self assert: (tree at: #k ifAbsent: [32]) = 32.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 1/11/2005 13:12'!testRemoval2	| tree |	tree := BTree new.	1 to: 15 do: [:i | tree at: i put: i].	1 to: 15 do: [:i | tree removeKey: i].	self assert: tree isEmpty! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:06'!testRemoveAll	| tree |	tree _ BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(a b c d e f g h i j k l)  shuffled do: [:ea | tree removeKey: ea].	self assert: tree size = 0.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:56'!testRemoveAllFailing	| tree |	tree _ BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(#c #j #g #i #k #l #f #e #d #h #a #b) do: [:ea | tree removeKey: ea].	self assert: tree size = 0.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:07'!testRemoveLots	| tree |	tree _ BTree new.	#(a b c d e f g h i j k l) do: [:ea | tree at: ea put: ea, '!!'].	self assert: tree size = 12.	#(a c e g i k) shuffled do: [:ea | tree removeKey: ea].	self assert: tree size = 6.	self assertSorted: tree.	self assertConsistent: tree.! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 02:06'!testSimpleAddAndRetrieve	self checkTreeWithOrder: 5 items: 1! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/28/2004 22:01'!testStoreNil	self checkTree: BTree new array: {{'x'. 1}. {'y'. nil}}! !!BTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:59'!testStringKeys	self checkTree: (BTree keys: BTreeStringKeys new) items: 100! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/21/2004 20:38'!setUp	tree := TSTree new.	self words shuffled do: [:ea | tree at: ea put: ea asUppercase].	empty _ TSTree new.! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 01:01'!testAt	self assert: (tree at: 'abear') = 'ABEAR'.	self assert: (tree at: 'abelmosk') = 'ABELMOSK'.	self assert: (tree at: 'abracadabra' ifAbsent: [42]) = 42.	self assert: (tree at: '' ifAbsent: [42]) = 42.	self assert: (empty at: 'foo' ifAbsent: [42]) = 42 ! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/21/2004 20:38'!testMatch	self assert: (tree matchesForString: 'abea' distance: 1) asSet = #(ABEAM ABEAR ABED ABEL ABET ABE) asSet.	self assert: (tree matchesForString: 'abel' distance: 2) asSet = #(ABELIA ABEAM ABEAR) asSet.	self assert: (tree matchesForString: 'abel' distance: 0) = #(ABEL).	self assert: (tree matchesForString: '' distance: 1) = #().	self assert: (empty matchesForString: 'foo' distance: 0) = #()! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 00:48'!testPrefix	self assert: (tree matchesForPrefix: 'abet') asSet = #(ABET ABETMENT) asSet.	self assert: (tree matchesForPrefix: 'abelm') asSet = #(ABELMOSCHUS ABELMOSK) asSet.	self assert: (tree matchesForPrefix: '') asSet = (self words asSet collect: [:ea | ea asUppercase]).	self assert: (empty matchesForPrefix: 'foo') = #()! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 12/13/2004 13:07'!testRemove	self assert: (tree at: 'abel') = 'ABEL'.	self assert: (tree removeKey: 'abel') = 'ABEL'.	self assert: (tree at: 'abel' ifAbsent: [42]) = 42.	self assert: (tree at: 'abelmosk') = 'ABELMOSK'.	self assert: (tree removeKey: 'foo' ifAbsent: [42]) = 42.	self assert: (tree removeKey: 'abel' ifAbsent: [42]) = 42.! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/21/2004 20:38'!testValues	self assert: tree values asSet = (self words asSet collect: [:ea | ea asUppercase]).	self assert: empty values isEmpty! !!TSTreeTest methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 00:58'!words	^ #(abeabeamabearabearanceabecedarianabecedariumabecedaryabedabeighabelabeleabeliaabelianabeliceaabeliteabeliteabelmoschusabelmoskabelonianabeltreeabencerragesabentericabepithymiaaberdeenaberdevineaberdonianaberiaaberranceaberrancyaberrantaberrateaberrationaberrationalaberratoraberrometeraberroscopeaberuncatorabetabetment) ! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!assertChanged: anObject	self assert: (barrier isDirty: anObject)! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!denyChanged: anObject	self deny: (barrier isDirty: anObject)! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!enableWriteBarrier: anObject	barrier add: anObject! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!resetChanged	barrier clearDirtySet ! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!setUp	barrier _ DirtySetWriteBarrier new! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:19'!tearDown	barrier unregister! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:01'!testAtPutDelegatingCollection	| coll |	coll _ OrderedCollection new: 5.	coll add: 'bar'.	self enableWriteBarrier: coll.	coll at: 1 put: 'foo'.	self denyChanged: coll.	1 to: 100 do: [:i | coll add: i].	self assertChanged: coll! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:01'!testAtPutOverriden	| array |	array _ ColorArray new: 3.	array at: 1 put: Color red.	self denyChanged: array.	self enableWriteBarrier: array.	array at: 2 put: Color blue.	self assertChanged: array! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:01'!testAtPutVariablySized	| array |	array _ Array new: 3.	array at: 1 put: 42.	self denyChanged: array.	self enableWriteBarrier: array.	array at: 2 put: 37.	self assertChanged: array! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 13:32'!testCannotAddBlock	self should: [self enableWriteBarrier: [2+2]] raise: Error! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:14'!testClassChange	| dict |	dict _ Dictionary new.	self assert: dict class == Dictionary.	self enableWriteBarrier: dict.	self deny: dict class  == Dictionary.! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:14'!testClassChangeCompact	| point |	point _ 2@2.	self assert: point class == Point.	self enableWriteBarrier: point.	self deny: point class  == Point.! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:14'!testCompetingManager	| manager2 x y |	manager2 _ WriteBarrier new.	x _ WBMock new.	self shouldnt: [manager2 add: x] raise: Error.	y _ WBMock new.	self enableWriteBarrier: y.	self should: [manager2 add: y] raise: Error	! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:06'!testDoubleWriteBarrier	| m |	m _ WBMock new.	self assert: m class == WBMock.	self enableWriteBarrier: m.	self assert: m class superclass == WBMock.	self enableWriteBarrier: m.	self assert: m class superclass == WBMock! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:02'!testNoWriteBarrier	| point |	point _ 2@2.	point setX: 25 setY: 25.	self denyChanged: point! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 13:09'!testRemove	| point |	point _ 2@2.	self enableWriteBarrier: point.	point setX: 25 setY: 25.	self assertChanged: point.	barrier remove: point.	self resetChanged.	point setX: 26 setY: 26.	self denyChanged: point! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:01'!testSelectiveNotification	| m |	m _ WBMock new.	self enableWriteBarrier: m.	self denyChanged: m.	m lazyX.	self assertChanged: m.	self resetChanged.	m lazyX.	self denyChanged: m! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 13:38'!testSpecies	| array interval |	array _ #(1 2 3) copy.	interval _ 1 to: 10.	self assert: array species == Array.	self assert: interval species == Array.	self enableWriteBarrier: array.	self enableWriteBarrier: interval.	self assert: array species == Array.	self assert: interval species == Array! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 17:07'!testString	| string |	string _ 'test' copy.	self shouldnt: [self enableWriteBarrier: string] raise: Error! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:02'!testTrackIndividualInstances	| point point2 point3 |	point _ 2@2.	point2 _ 2@2.	point3 _ 2@2.	self enableWriteBarrier: point.	self enableWriteBarrier: point2.	point setX: 25 setY: 25.	point3 setX: 25 setY: 25.	self assertChanged: point.	self denyChanged: point2.	self denyChanged: point3! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 4/3/2005 01:25'!testVariableSelectiveNotification	| a |	a _ Array with: true.	self enableWriteBarrier: a.	self denyChanged: a.	a at: 1 put: true.	self denyChanged: a.	a at: 1 put: false.	self assertChanged:a! !!WBTestBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:02'!testWriteBarrier	| point |	point _ 2@2.	self enableWriteBarrier: point.	point setX: 25 setY: 25.	self assertChanged: point! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:21'!barrierClass	^ barrier barrierClassForClass: WBMock! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:20'!setUp	barrier _ WriteBarrier new! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:47'!tearDown	barrier unregister! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testAddMutation	| c |	c _ self barrierClass.	self withDefaultMethod: 'y ^ y' on: WBMock do:		[self deny: (c selectors includes: #y).		WBMock compile: 'y ^ y ifNil: [y _ 37]' classified: 'accessing'.		self assert: (c selectors includes: #y)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testAddMutator	| c md cm |	c _ self barrierClass.	md _ c methodDictionary copy.	cm _ c >> #x:.	self withTemporaryMethod: 'q ^ x _ 42' on: WBMock do:		[self assert: (c >> #x:) == cm.		self deny: md = c methodDictionary.		self assert: (c selectors includes: #q)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testAddNonMutator	| c md cm |	c _ self barrierClass.	md _ c methodDictionary copy.	cm _ c >> #x:.	self withTemporaryMethod: 'q ^ 42' on: WBMock do:		[self assert: (c >> #x:) == cm.		self assert: md = c methodDictionary.		self deny: (c selectors includes: #q)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:21'!testChangeDifferentField	| c cm |	c _ self barrierClass.	self withDefaultMethod: 'x: n x _ n' on: WBMock do:		[cm _ c >> #x:.		WBMock compile: 'x: n y _ n'.		self deny: (c >> #x:) == cm]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testChangeSameField	| c cm |	c _ self barrierClass.	self withDefaultMethod: 'x: n x _ n' on: WBMock do:		[cm _ c >> #x:.		WBMock compile: 'x: n x _ n + 1'.		self assert: (c >> #x:) == cm]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testClassFormatChange	| oldFmt c |	oldFmt _ WBMock format.	c _ self barrierClass.	self assert: c format = WBMock format.	WBMock addInstVarName: 'foo'.	c _ self barrierClass.	[self deny: WBMock format = oldFmt.	self assert: c format = WBMock format]		ensure: [WBMock removeInstVarName: 'foo']! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:48'!testClassFormatChangeWithInstance	| instance instance2 |	instance _ WBMock new.	instance2 _ WBMock new.	barrier add: instance.	instance y: 42.	instance2 y: 23.	WBMock removeInstVarName: 'x'.	[self assert: instance2 y = 23.	self assert: instance y = 42]		ensure: [Object subclass: #WBMock	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'WriteBarrier-Tests']! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testRemoveField	| c |	c _ self barrierClass.	self assert: (c selectors includes: #y:).	WBMock removeInstVarName: 'y'.	c _ self barrierClass.	[self deny: (c selectors includes: #y:)]		ensure: [WBMock addInstVarName: 'y']! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testRemoveMutation	| c |	c _ self barrierClass.	self withDefaultMethod: 'x: n x _ n' on: WBMock do:		[self assert: (c selectors includes: #x:).		WBMock compile: 'x: n ^ 42'.		self deny: (c selectors includes: #x:)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testRemoveMutator	| c |	c _ self barrierClass.	self withDefaultMethod: 'x: n x _ n' on: WBMock do:		[self assert: (c selectors includes: #x:).		WBMock removeSelector: #x:.		self deny: (c selectors includes: #x:)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:22'!testSubClass	| c |	c _ (barrier builderForClass: WBMockSub) barrierClass.	self withDefaultMethod: 'y ^ y' on: WBMock do:		[self deny: (c selectors includes: #y).		WBMock compile: 'y ^ y ifNil: [y _ 37]' classified: 'accessing'.		self assert: (c selectors includes: #y)]! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:03'!withDefaultMethod: aString on: aClass do: aBlock	aClass compile: aString classified: 'tests'.	aBlock ensure: [aClass compile: aString classified: 'tests']! !!WBTestSystemChanges methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:08'!withTemporaryMethod: aString on: aClass do: aBlock	aClass compile: aString classified: 'tests'.	aBlock ensure: [aClass removeSelector: (Parser new parseSelector: aString)]! !!LargePositiveInteger class methodsFor: '*ma object serialization' stamp: 'cmm 12/1/2004 23:56'!maMaterializeFrom: aMaByteObjectBuffer using: aMaObjectSerializer	^ aMaByteObjectBuffer asByteObject: self! !!LargePositiveInteger methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!LargePositiveInteger methodsFor: '*magma client' stamp: 'cmm 3/27/2005 23:12'!maAllowsWriteBarrier 	"No reason to."	^ false! !!Dictionary class methodsFor: '*ma object serialization' stamp: 'cmm 12/2/2004 12:35'!maLoadVariableObjectFrom: aMaVariableObjectBuffer	| skeleton |	skeleton _ self new: aMaVariableObjectBuffer objectInstSize / 2. "key + value"	1		to: aMaVariableObjectBuffer objectInstSize		by: 2		do:			[ :index |			skeleton				at: (aMaVariableObjectBuffer maInstVarAt: index)				put: (aMaVariableObjectBuffer maInstVarAt: index + 1) ].	^ skeleton! !!Dictionary methodsFor: '*ma base additions'!maAllKeysAtValue: anObject	| aCollection |	aCollection := OrderedCollection new.	self keysAndValuesDo: [ :key :value | value = anObject ifTrue: [ aCollection add: key ] ].	^aCollection! !!Dictionary methodsFor: '*ma base additions'!maAt: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock	| current uniqueObj |	uniqueObj := 'x'.	^(current := self		at: anObject		ifAbsent: [ uniqueObj ]) == uniqueObj			ifTrue: [ zeroArgBlock value ]			ifFalse: [ oneArgBlock value: current ]! !!Dictionary methodsFor: '*ma object serialization' stamp: 'cmm 12/1/2004 22:55'!maBufferInstSize	^ self size * 2! !!Dictionary methodsFor: '*ma base additions' stamp: 'cmm 9/27/2003 19:40'!maDeepCopy	| answer |	answer _ self species new.	self keysAndValuesDo:		[ : eachKey : eachValue |		answer at: eachKey copy put: eachValue copy ]! !!Dictionary methodsFor: '*ma object serialization' stamp: 'cmm 3/27/2006 17:00'!maEstablishPointerReferencesUsing: aMaObjectSerializer	| transformer fullOfOidsCopy |	self isEmpty ifTrue: [ ^ self ]. "performance"	transformer _ [ :object | (aMaObjectSerializer objectWithOid: object) ].	fullOfOidsCopy _ self copy.	self maRemoveAll.	fullOfOidsCopy keysAndValuesDo:		[ :eachKey :eachValue |		self			at: (transformer value: eachKey)			put: (transformer value: eachValue) ]! !!Dictionary methodsFor: '*ma traverse object graphs' stamp: 'cmm 12/2/2004 17:29'!maGraphDo: aBlock using: aObjectTraversalStrategy path: path with: alreadyVisitedSet	| varIndex |	varIndex := 1.	self keysAndValuesDo:		[ : eachKey : eachValue |		[ : obj |			self				maValueGraphNode: obj				index: varIndex				using: aObjectTraversalStrategy				with: aBlock				path: path				with: alreadyVisitedSet.			varIndex := varIndex + 1 ]				value: eachKey;				value: eachValue ]! !!Dictionary methodsFor: '*magma client' stamp: 'cmm 2/23/2005 14:39'!maIsChangedFrom: aMaVariableObjectBuffer using: aMaObjectSerializer	| logicalInstSize oidDict |	logicalInstSize _ aMaVariableObjectBuffer objectInstSize.	self size*2 = logicalInstSize ifFalse: [ ^ true ].	oidDict _ Dictionary new: logicalInstSize / 2.	1 to: logicalInstSize by: 2 do:		[ :index | 		oidDict 			at: (aMaVariableObjectBuffer maInstVarAt: index)			put: (aMaVariableObjectBuffer maInstVarAt: index+1) ].	self keysAndValuesDo:		[ : eachKey : eachValue |		oidDict			maAt: (aMaObjectSerializer oidFor: eachKey)			ifPresent:				[ : valueOid |				valueOid = (aMaObjectSerializer oidFor: eachValue) ifFalse: [ ^true ] ]			ifAbsent: [ ^ true ] ].	^ false! !!Dictionary methodsFor: '*ma object serialization'!maIsHashedCollection	^true! !!Dictionary methodsFor: '*magma client' stamp: 'cmm 3/27/2006 17:01'!maRefreshTo: aMaVariableObjectBuffer using: aMagmaSession	"The linkedOids in aMaVariableObjectBuffer are in key->value pairs."	| save transformationBlock |	save _ self copy.  "prevent GC of my elements until I get repopulated."	save size.  "avoid friendly optimization intrusion."	self maRemoveAll.	transformationBlock _ [ :oid | aMagmaSession serializer objectWithOid: oid ].	1		to: aMaVariableObjectBuffer objectInstSize		by: 2		do:			[ :eachKeyIndex | | eachKey eachValue |			eachKey _ aMaVariableObjectBuffer maInstVarAt: eachKeyIndex.			eachValue _ aMaVariableObjectBuffer maInstVarAt: eachKeyIndex + 1.			self				at: (transformationBlock value: eachKey)				put: (transformationBlock value: eachValue) ]! !!Dictionary methodsFor: '*ma base additions' stamp: 'cmm 7/24/2002 20:45'!maShallowCopy	| copy |	copy _ self species new.  "new: seems buggy w/ Dictionaries.."	self keysAndValuesDo: 		[ :eachKey :eachValue | copy at: eachKey put: eachValue ].	^copy! !!Dictionary methodsFor: '*ma object serialization' stamp: 'cmm 11/28/2004 16:20'!maStreamVariablyInto: aMaVariableObjectBuffer for: aMaObjectSerializer	"Put the receivers instance variables into aMaVariableObjectBuffer."	| index |	index _ 1.	self keysAndValuesDo:		[ : eachKey : eachValue |		[ : obj |			aMaVariableObjectBuffer				maInstVarAt: index				put: (aMaObjectSerializer oidFor: obj).			index _ index + 1 ]				value: eachKey;				value: eachValue ].	"Now take care of additional named variables."	3 "skip array and tally, they're taken care of logically, above."		to: self maInstSize		do:			[ : namedIndex |			aMaVariableObjectBuffer				maInstVarAt: index + namedIndex				put: (aMaObjectSerializer oidFor: (self instVarAt: namedIndex)) ]! !!WriteStream methodsFor: '*ma base additions' stamp: 'cmm 11/10/2002 20:35' prior: 33835524!endEntry	"No-op for compatibility with TranscriptStream."! !!WriteStream methodsFor: '*ma base additions'!maPrint: anObject	anObject isString ifTrue: [ self nextPutAll: anObject ] ifFalse: [ anObject printOn: self ]! !!WriteStream methodsFor: '*ma base additions' stamp: 'cm 12/24/2001 16:03'!maPrintAbbreviated: aMaObject	aMaObject maPrintAbbreviatedOn: self! !!WriteStream methodsFor: '*ma base additions' stamp: 'cmm 8/23/2004 17:08'!maPrintNumber: anInteger template: templateStringself maMarked: 'dev'."I hate this method...  Find a better solution and a better name because you only support Integers!!"	templateString size - anInteger printString size timesRepeat: [ self nextPut: $0 ].	anInteger maPrintAbbreviatedOn: self! !!MaError commentStamp: '<historical>' prior: 0!Base abstraction for errors that occur in Ma code.!!MaHardwareError commentStamp: '<historical>' prior: 0!A hardware error occurs when a computing resource runs out of resources or fails.  Examples includes running out of disk storage, out of physical memory, network cable cut, etc.!!MaError methodsFor: 'as yet unclassified' stamp: 'cmm 12/19/2002 23:24'!copyAttributes: anArray from: sourceObject	anArray do:		[ :each |		self			instVarNamed: each asString			put: (sourceObject instVarNamed: each) copy ]! !!MaError methodsFor: 'as yet unclassified' stamp: 'cmm 8/26/2005 16:39'!copyWithAttributes: anArray	"anArray of instVar names in the receiver."	| copy |	^(copy := self copy)		copyAttributes: anArray		from: copy! !!MaError methodsFor: 'as yet unclassified' stamp: 'cmm 2/25/2003 18:02'!isUserError	^false! !!MaMalformedRequestError commentStamp: 'cmm 2/1/2005 15:26' prior: 0!I am signaled when a request is received from a client that could not be materialized.!!MaSoftwareError commentStamp: 'cmm 5/4/2005 10:25' prior: 0!A software error is a bug in the software.  Signal them when you have to code for something that "should never happen."  For example, if, based on your program logic, there should be an entry in a Dictionary, but it is not there, you would signal a software error.!!MaUserError commentStamp: '<historical>' prior: 0!I represent an error made by the user.!!MaUserError methodsFor: 'as yet unclassified' stamp: 'cmm 2/25/2003 18:01'!isUserError	^true! !!MagmaDuplicateObjectInCollection commentStamp: '<historical>' prior: 0!Signalled by MagmaSet if a duplicate object is added to the collection.!!MagmaInvalidOid commentStamp: 'cmm 3/1/2005 17:34' prior: 0!Signaled when the server is asked for an object at a particular oid but no object is present at that oid.!!MagmaCommitError commentStamp: 'cmm 3/21/2003 00:50' prior: 0!I am signaled when another user has committed a change an object that you changed since you began your transaction.!!MagmaCommitError methodsFor: 'as yet unclassified' stamp: 'cmm 12/17/2002 23:59'!result	^result! !!MagmaCommitError methodsFor: 'as yet unclassified' stamp: 'cmm 12/17/2002 23:59'!result: aMaCommitResult	result _ aMaCommitResult! !!MaIncomingChangeSetNotification methodsFor: 'as yet unclassified' stamp: 'cmm 2/3/2005 21:22'!defaultAction	"The ChangeSet will be created if it does not exist.  Resume with true to instruct Magma to file in the code with the ChangeSet."	self resume: false! !!MaNotification methodsFor: 'as yet unclassified' stamp: 'cmm 3/28/2005 21:52'!messageText	^super messageText ifNil: [ self species name, ' - no detailed message available' ]! !!MaProgressNotification methodsFor: 'actions' stamp: 'cmm 1/18/2004 22:33'!advance	(Delay forMilliseconds: 0) wait. "this should eliminate a lot of need for various Processor yields."	timeSinceLastSignal start.	advanceCount _ advanceCount + 1! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 1/18/2004 22:32'!advanceCount	^advanceCount! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 11/13/2003 00:47'!description	^attributes at: 'description' ifAbsent: [ '' ]! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:09'!description: aString	attributes at: 'description' put: aString! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 00:59'!hasDescription	^attributes includesKey: 'description'! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 01:00'!hasLogMessage	^attributes includesKey: 'logMessage'! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 00:59'!hasTaskSize	^attributes includesKey: 'taskSize'! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 00:59'!hasUnitsCompleted	^attributes includesKey: 'unitsCompleted'! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 00:59'!hasUnitsVerbPhrase	^attributes includesKey: 'unitsVerbPhrase'! !!MaProgressNotification methodsFor: 'initializing' stamp: 'cmm 3/3/2004 12:59'!initialize	super initialize.	attributes _ Dictionary new.	self signalFrequency: 4 maSeconds.	timeSinceLastSignal _ MaStopwatch new.	advanceCount _ 0! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/6/2003 00:40'!logMessage	^attributes at: 'logMessage'! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:27'!logMessage: aString	attributes at: 'logMessage' put: aString! !!MaProgressNotification methodsFor: 'testing' stamp: 'cmm 8/6/2003 00:41'!shouldAdvance	^attributes includesKey: 'shouldAdvance'! !!MaProgressNotification methodsFor: 'actions' stamp: 'cmm 1/18/2004 22:34'!signal	super signal.	timeSinceLastSignal restart.	advanceCount _ 0! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 11/13/2003 00:27'!signalFrequency: aMaDuration	signalFrequency _ aMaDuration! !!MaProgressNotification methodsFor: 'actions' stamp: 'cmm 11/13/2003 23:50'!signalIfTime	timeSinceLastSignal time > signalFrequency ifTrue: [ self signal ]! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/6/2003 00:40'!taskSize	^attributes at: 'taskSize'! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:10'!taskSize: anInteger	attributes at: 'taskSize' put: anInteger! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 11/13/2003 00:46'!unitsCompleted	^attributes at: 'unitsCompleted' ifAbsent: [ 0 ]! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:18'!unitsCompleted: anInteger	attributes at: 'unitsCompleted' put: anInteger! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 11/13/2003 00:46'!unitsVerbPhrase	^attributes at: 'unitsVerbPhrase' ifAbsent: [ '' ]! !!MaProgressNotification methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:18'!unitsVerbPhrase: anInteger	attributes at: 'unitsVerbPhrase' put: anInteger! !!MaTraverseProxyNotification class methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2005 20:26'!proxy: aMaMutatingProxy	^ self new		proxy: aMaMutatingProxy ;		yourself! !!MaTraverseProxyNotification methodsFor: 'testing' stamp: 'cmm 1/30/2005 20:25'!isResumable	^ true! !!MaTraverseProxyNotification methodsFor: 'accessing' stamp: 'cmm 1/30/2005 20:27'!proxy	^ proxy! !!MaTraverseProxyNotification methodsFor: 'accessing' stamp: 'cmm 1/30/2005 20:27'!proxy: aMaMutatingProxy	proxy _ aMaMutatingProxy! !!MagmaProxyMaterialization commentStamp: 'cmm 1/13/2005 23:05' prior: 0!I am signaled when a mutating proxy is materialized.  The materializedObject is available as an argument.To use:	[ ... do your stuff ... ]		on: MagmaProxyMaterialization 		do:			[ : theNotification |			doSomethingWith: theNotification.			theNotification resume "<-- very important!!" ]!!MagmaProxyMaterialization class methodsFor: 'signaling' stamp: 'cmm 4/10/2005 18:00'!signalMaterializedObject: anObject 	(self new)		messageText: 'materializing a ' , anObject maOriginalClass printString;		materializedObject: anObject;		signal! !!MagmaProxyMaterialization methodsFor: 'as yet unclassified' stamp: 'cmm 4/27/2003 20:14'!materializedObject	^materializedObject! !!MagmaProxyMaterialization methodsFor: 'as yet unclassified' stamp: 'cmm 5/2/2003 17:23'!materializedObject: anObject	materializedObject _ anObject! !!MagmaProxySerialization commentStamp: 'cmm 1/14/2005 12:30' prior: 0!Some users may want to know all of the "foreign" repositories that can be reached from their repository.  Magma doesn't maintain its own list, but will signal this notification for each one it encounters during serialization.  Client programs who care about this may track it, if they wish, just be sure to remember to resume the notification.!!MagmaProxySerialization class methodsFor: 'as yet unclassified' stamp: 'cmm 1/14/2005 12:30'!for: aMagmaForwardingProxy	^ self new		proxyBeingSerialized: aMagmaForwardingProxy ;		yourself! !!MagmaProxySerialization methodsFor: 'as yet unclassified' stamp: 'cmm 1/14/2005 12:29'!proxyBeingSerialized	^ proxyBeingSerialized! !!MagmaProxySerialization methodsFor: 'as yet unclassified' stamp: 'cmm 1/14/2005 12:29'!proxyBeingSerialized: aMagmaForwardingProxy	proxyBeingSerialized _ aMagmaForwardingProxy! !!MagmaSessionRequest commentStamp: 'cmm 1/13/2005 23:08' prior: 0!I am used to signal to the session controller a session directive, such as connect, commit, abort, disconnect, or others.Use my class-side api in your domain code.  For example, in your setters:	name: aString		MagmaSessionRequest signalCommit: [ name _ aString ]When Magma is not used, the session request has no effect.!!MagmaSessionRequest class methodsFor: 'private' stamp: 'cmm 4/22/2003 23:41'!signal: aString do: oneArgBlock	"oneArgBlock takes the session that you wish to do something to."	^self new		messageText: aString;		doBlock: oneArgBlock;		signal! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/24/2003 15:00'!signalAbort	self 		signal: 'aborting transaction'		do: [ :session | session abort ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/22/2003 23:42'!signalBegin	self 		signal: 'beginning transaction'		do: [ :session | session begin ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/22/2003 23:43'!signalCommit	self 		signal: 'committing transaction'		do: [ :session | session commit ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 12/11/2004 14:04'!signalCommit: aBlock	| result |	self signalBegin.	result _ aBlock value.	self signalCommit.	^ result! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/22/2003 23:50'!signalCommitAndBegin	self 		signal: 'committing transaction and beginning a new one'		do: [ :session | session commitAndBegin ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/24/2003 16:35'!signalFinalizeOids	self 		signal: 'beginning transaction'		do: [ :session | session finalizeOids ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/10/2005 19:13'!signalNoteOldKeysFor: anObject	self 		signal: 'committing transaction'		do: [ :session | session noteOldKeysFor: anObject ]! !!MagmaSessionRequest class methodsFor: 'signaling' stamp: 'cmm 4/22/2003 23:43'!signalStubOut: anObject	self		signal: 'stubbing out ', anObject printString		do: [ :session | session stubOut: anObject ]! !!MagmaSessionRequest methodsFor: 'private' stamp: 'cmm 3/20/2003 01:05'!doBlock: oneArgBlock	doBlock _ oneArgBlock! !!MagmaSessionRequest methodsFor: 'handler' stamp: 'cmm 3/23/2003 22:47'!handleAndResumeUsing: aMagmaSession	doBlock value: aMagmaSession.	self resume! !!MagmaUserRequirementNotification commentStamp: 'cmm 3/11/2005 14:13' prior: 0!I am used when Magma discovers it is missing an object and must get it from the user.  For example, when the user invokes a forwarding-proxy to another repository, connection credentials for that repository must be supplied.  Magma does not keep these for you, but it requires them.!!MagmaUserRequiredNotification class methodsFor: 'private' stamp: 'cmm 3/13/2005 18:08'!requestUserFor: aMagmaSession	^ (self session: aMagmaSession)		messageText: 'Supply a userId for ', aMagmaSession linkInformation ;		signal! !!MagmaUserRequiredNotification class methodsFor: 'as yet unclassified' stamp: 'cmm 3/13/2005 18:07'!session: aMagmaSession	^ self new		session: aMagmaSession ;		yourself! !!MagmaUserRequiredNotification methodsFor: 'as yet unclassified' stamp: 'cmm 3/13/2005 18:07'!defaultAction	"The user did not listen for this notification.  For now, bail them out by offering them an opportunity to create one on the fly."	self resume:		(session user			ifNil:				[ MagmaUser id: (FillInTheBlank request: 'Enter your user-id at ', session linkInformation) ])! !!MagmaUserRequiredNotification methodsFor: 'as yet unclassified' stamp: 'cmm 3/13/2005 18:07'!session: aMagmaSession	session _ aMagmaSession! !!Bitmap class methodsFor: '*ma object serialization' stamp: 'cmm 5/3/2005 11:44'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	| compressedByteArray |	compressedByteArray _ aMaObjectSerializer materializeGraph: aByteArray.	^ self decompressFromByteArray: compressedByteArray! !!Bitmap methodsFor: '*magma client' stamp: 'cmm 4/10/2005 16:20'!maAllowsWriteBarrier 	"Just trying to be 'safe'."	^ false! !!Bitmap methodsFor: '*ma object serialization' stamp: 'cmm 11/7/2004 22:54'!maAsStorageObject	^ self compressToByteArray! !!Bitmap methodsFor: '*magma client' stamp: 'cmm 5/1/2005 23:59'!maIsChangedFrom: aMaStorageObjectBuffer using: aMaObjectSerializer	| graphBuffer |	graphBuffer _ MaSerializedGraphBuffer byteArray: aMaStorageObjectBuffer asByteArray.	graphBuffer buffersDo:		[ : firstAndOnlyBuffer |		^ self compressToByteArray ~= firstAndOnlyBuffer asByteArray ]! !!Bitmap methodsFor: '*magma client' stamp: 'cmm 5/2/2005 00:06'!maRefreshTo: aMaStorageObjectBuffer using: aMagmaSession	| graphBuffer |	graphBuffer _ MaSerializedGraphBuffer byteArray: aMaStorageObjectBuffer asByteArray.	graphBuffer buffersDo:		[ : firstAndOnlyBuffer |  | s byteArray |		byteArray _ firstAndOnlyBuffer asByteArray.		s _ ReadStream on: byteArray.		self class decodeIntFrom: s.		self 			decompress: self 			fromByteArray: byteArray 			at: s position+1 ]! !!Bitmap methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:00'!maUsesStandardStorage	^ false! !!MaCalendarTime commentStamp: '<historical>' prior: 0!I represent a calendar time; either a duration represented in units of a Gregorian calendar (days, hours, minutes, seconds, etc.) or a point on the timeline of the Gregorian calendar.I support full arithmetic with other CalendarTimes and Integers as it makes sense.  For example, dividing 30 minutes by 3 makes sense, but not May 19th, 1969.I have fairly efficient storage, a single integer of the total number of milliseconds that have elapsed since my base time, 1/1/1901 @ 12:00am.!!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:40'!date: aDate time: aTime	^self fromSeconds: aDate asSeconds + aTime asSeconds! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:50'!date: aDate time: aTime milliseconds: anInteger	^self fromMilliseconds: (aDate asSeconds + aTime asSeconds) * 1000 + anInteger! !!MaCalendarTime class methodsFor: 'private' stamp: 'cmm 3/7/2002 22:51'!durationFromStream: aReadStream plusMilliseconds: anInteger ifInvalid: aBlock	"Correct form is hh:mm:ss.nnn."	| hours minutes seconds subseconds |	(hours _ (aReadStream upTo: $:) asNumber) isNil ifTrue: [ ^aBlock value ].	(minutes _ (aReadStream upTo: $:) asNumber) isNil ifTrue: [ ^aBlock value ].	(seconds _ (aReadStream upTo: $.) asNumber) isNil ifTrue: [ ^aBlock value ].	(subseconds _ aReadStream upToEnd asNumber) isNil ifTrue: [ ^aBlock value ].	subseconds > 999 ifTrue: [ ^aBlock value ].	^self fromMilliseconds:		anInteger + (hours * 3600 * 1000) + (minutes * 60 * 1000) + (seconds * 1000) + subseconds! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:51'!epoch	"Return a new instance of the receiver with its time set to 0.	This is useful for timing operations."	^self fromMilliseconds: 0! !!MaCalendarTime class methodsFor: 'private'!fromDurationString: aString ifInvalid: aBlock	"Correct form is hh:mm:ss.nnn."	| stream |	stream _ ReadStream on: aString trimBlanks.	^self		durationFromStream: stream		plusMilliseconds: 0		ifInvalid: aBlock! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:44'!fromMilliseconds: anInteger	^self new totalMilliseconds: anInteger! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:39'!fromSeconds: anInteger	"Returns a new instance of the receiver based on anInteger seconds."	^self new totalSeconds: anInteger! !!MaCalendarTime class methodsFor: 'creation'!fromString: aString	"Correct form is 'yyyy/mm/dd hh:mm:ss:nnn' or 'hh:mm:ss.nnn'	if you intend to use the new instance as a 'duration'."	^self		fromString: aString		ifInvalid: [ self error: aString, ' is not formatted properly for the default, simple parser.' ]! !!MaCalendarTime class methodsFor: 'creation'!fromString: aString ifInvalid: aBlock	"Correct form is 'yyyy/mm/dd hh:mm:ss:nnn' or 'hh:mm:ss.nnn'	if you intend to use the new instance as a 'duration'."	^aString size = 12		ifTrue:			[ self				fromDurationString: aString				ifInvalid: aBlock ]		ifFalse:			[ self				fromTimeStampString: aString				ifInvalid: aBlock ]! !!MaCalendarTime class methodsFor: 'private' stamp: 'cmm 3/7/2002 22:31'!fromTimeStampString: aString ifInvalid: aBlock	"Correct form is yyyy/mm/dd hh:mm:ss.mmm"	| stream year month day |	stream _ ReadStream on: aString.	(year _ (stream upTo: $/) asNumber) isNil ifTrue: [ ^aBlock value ].	(month _ (stream upTo: $/) asNumber) isNil ifTrue: [ ^aBlock value ].	(day _ (stream upTo: $ ) asNumber) isNil ifTrue: [ ^aBlock value ].	^self		durationFromStream: stream		plusMilliseconds:			(Date				newDay: day				month: month				year: year)					asSeconds * 1000		ifInvalid: aBlock! !!MaCalendarTime class methodsFor: 'initializing' stamp: 'cmm 4/29/2003 23:16'!initialize	Smalltalk addToStartUpList: self.	FirstRecordedMillisecondClock _ Time millisecondClockValue.	FirstTimestampMillisecond _ (Date today asSeconds + Time now asSeconds) * 1000.	BaseCalendarDate _ Date newDay: 1 month: 1 year: 1901! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/7/2002 22:51'!now	"answer a new timestamp for the current date and time."	^self fromMilliseconds:		(Time millisecondClockValue - FirstRecordedMillisecondClock + FirstTimestampMillisecond)! !!MaCalendarTime class methodsFor: 'creation' stamp: 'cmm 3/6/2002 22:13'!secondsPerDay	^86400! !!MaCalendarTime class methodsFor: 'initializing' stamp: 'cmm 3/18/2002 22:20'!startUp: amResumingPreviouslySavedImage	"amResumingPreviouslySavedImage is a boolean..  How about that?"	super startUp: amResumingPreviouslySavedImage.	self initialize! !!MaCalendarTime methodsFor: 'operators' stamp: 'cmm 3/28/2005 21:39'!+ aMaCalendarTime	^self species fromMilliseconds: totalMilliseconds + aMaCalendarTime totalMilliseconds! !!MaCalendarTime methodsFor: 'operators' stamp: 'cmm 2/2/2003 11:01'!- aMaCalendarTimeOrDuration	^(aMaCalendarTimeOrDuration isDuration		ifTrue: [ MaCalendarTime ]		ifFalse: [ MaDuration ])			fromMilliseconds: self totalMilliseconds - aMaCalendarTimeOrDuration totalMilliseconds! !!MaCalendarTime methodsFor: 'comparing' stamp: 'cmm 3/6/2002 23:29'!< aMaCalendarTime	^self totalMilliseconds < aMaCalendarTime totalMilliseconds! !!MaCalendarTime methodsFor: 'comparing' stamp: 'cmm 3/28/2005 21:40'!= aMaCalendarTime 	aMaCalendarTime species = self species ifFalse: [^false].	^self totalMilliseconds = aMaCalendarTime totalMilliseconds! !!MaCalendarTime methodsFor: 'printing' stamp: 'cmm 2/5/2003 20:11'!abbreviatedString	^String streamContents: [ :stream | self maPrintAbbreviatedOn: stream ]! !!MaCalendarTime methodsFor: 'as yet unclassified' stamp: 'cmm 8/31/2004 00:23'!asGmt	^ self asTimeIn: MaTimeZone gmt! !!MaCalendarTime methodsFor: 'as yet unclassified' stamp: 'cmm 8/30/2004 14:12'!asLocalTime	^ self asTimeIn: MaTimeZone localTimeZone! !!MaCalendarTime methodsFor: 'as yet unclassified' stamp: 'cmm 8/30/2004 14:00'!asTimeIn: aMaTimeZone	^ self + aMaTimeZone offset - self timeZone offset! !!MaCalendarTime methodsFor: 'accessing' stamp: 'cmm 3/7/2002 22:57'!date	^Date fromDays: self totalDays! !!MaCalendarTime methodsFor: 'building' stamp: 'cmm 3/7/2002 23:00'!date: aDate time: aTime	^self		date: aDate		time: aTime		milliseconds: 0! !!MaCalendarTime methodsFor: 'building' stamp: 'cmm 3/7/2002 22:59'!date: aDate time: aTime milliseconds: anInteger	self totalMilliseconds: (aDate asSeconds + aTime asSeconds) * 1000 + anInteger! !!MaCalendarTime methodsFor: 'private' stamp: 'cmm 2/2/2003 10:42'!hash	^self totalMilliseconds hash! !!MaCalendarTime methodsFor: 'testing' stamp: 'cmm 2/2/2003 11:02'!isDuration	^false! !!MaCalendarTime methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:32'!maPrintAbbreviatedOn: aStream	aStream		print: self date;		space;		print: self time! !!MaCalendarTime methodsFor: 'accessing'!milliseconds	^self totalMilliseconds \\ 1000! !!MaCalendarTime methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:33'!printOn: aStream	super printOn: aStream.	aStream space.	self maPrintAbbreviatedOn: aStream! !!MaCalendarTime methodsFor: 'operators' stamp: 'cmm 3/28/2005 21:40'!roundTo: aMaCalendarTime	"aMaCalendarTime should be a duration.	i.e., if the receiver is 5 minutes, 37 seconds, and aMaCalendarTime	is 2 minutes, then return 6 minutes."	^self species fromMilliseconds: (self totalMilliseconds roundTo: aMaCalendarTime totalMilliseconds)! !!MaCalendarTime methodsFor: 'accessing' stamp: 'cmm 3/7/2002 22:57'!time	^Time fromSeconds: self totalSeconds! !!MaCalendarTime methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:50'!timeZone	^ MaTimeZone localTimeZone! !!MaCalendarTime methodsFor: 'experimental' stamp: 'cmm 3/3/2004 13:00'!to: aMaCalendarTime	^self		to: aMaCalendarTime		by: 1 maSecond! !!MaCalendarTime methodsFor: 'experimental'!to: endTimeStamp by: stepDuration	^MaTimeInterval		from: self		to: endTimeStamp		by: stepDuration! !!MaCalendarTime methodsFor: 'experimental'!to: endTimeStamp by: durationIncrement do: aBlock	"Evaluate aBlock for each MaTimeStamp element in the interval.	Return stop."	(self		to: endTimeStamp		by: durationIncrement) do: [ :each | aBlock value: each ].		^endTimeStamp! !!MaCalendarTime methodsFor: 'accessing' stamp: 'cmm 3/28/2005 21:40'!totalDays	^self totalSeconds // self species secondsPerDay! !!MaCalendarTime methodsFor: 'accessing'!totalMilliseconds	^totalMilliseconds! !!MaCalendarTime methodsFor: 'accessing'!totalMilliseconds: anInteger	totalMilliseconds _ anInteger! !!MaCalendarTime methodsFor: 'accessing'!totalSeconds	^self totalMilliseconds // 1000! !!MaCalendarTime methodsFor: 'private'!totalSeconds: anInteger	self totalMilliseconds: anInteger * 1000! !!MaCalendarTime methodsFor: 'operators' stamp: 'cmm 3/28/2005 21:40'!truncateTo: aMaCalendarTime	"aMaCalendarTime should be a duration.	i.e., if the receiver is 5 minutes, 37 seconds, and duration	is 2 minutes, then return 4 minutes."	^self species		fromMilliseconds: (self totalMilliseconds truncateTo: aMaCalendarTime totalMilliseconds)! !!MaDuration methodsFor: 'operators' stamp: 'cmm 3/28/2005 21:49'!* anInteger	^self species fromMilliseconds: self totalMilliseconds * anInteger! !!MaDuration methodsFor: 'operators' stamp: 'cmm 3/28/2005 21:49'!- aMaDuration	^self species fromMilliseconds: self totalMilliseconds - aMaDuration totalMilliseconds! !!MaDuration methodsFor: 'operators' stamp: 'cmm 2/2/2003 10:35'!// anIntegerOrCalendarTime	^anIntegerOrCalendarTime maDivideIntoDuration: self! !!MaDuration methodsFor: 'operators' stamp: 'cmm 2/2/2003 10:37'!\\ anIntegerOrDuration	^anIntegerOrDuration maModuloDuration: self! !!MaDuration methodsFor: 'testing' stamp: 'cmm 2/2/2003 11:02'!isDuration	^true! !!MaDuration methodsFor: 'private' stamp: 'cmm 3/28/2005 21:49'!maDivideIntoDuration: aMaCalendarTime	^self species fromMilliseconds: aMaCalendarTime totalMilliseconds // self totalMilliseconds! !!MaDuration methodsFor: 'private' stamp: 'cmm 3/28/2005 21:49'!maModuloDuration: aMaCalendarTime	^self species fromMilliseconds: aMaCalendarTime totalMilliseconds \\ self totalMilliseconds! !!MaDuration methodsFor: 'printing' stamp: 'cmm 3/28/2005 21:49'!maPrintAbbreviatedOn: aStream	(self totalSeconds >= self species secondsPerDay)		ifTrue:			[ aStream				print: (self date subtractDate: BaseCalendarDate);				nextPutAll: ' days, ' ].	aStream 		nextPutAll: self time print24;		nextPut: $.;		maPrintNumber: self milliseconds		template: '000'! !!MaGlobalTime methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:52'!initialize	super initialize.	timeZone _ MaTimeZone localTimeZone! !!MaGlobalTime methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:21'!timeZone	^ timeZone! !!MaGlobalTime methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:21'!timeZone: aMaTimeZone	timeZone _ aMaTimeZone! !!ProcessorScheduler class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ Processor! !!ProcessorScheduler methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!ProcessorScheduler methodsFor: '*ma object serialization' stamp: 'cmm 12/19/2002 23:13'!maAsStorageObject	"We don't even need to store the name of the global.  It's class	gives it away."	^String maEmpty! !!ProcessorScheduler methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 15:03'!keys: aBTreeKeys	^ self basicNew initializeWithKeys: aBTreeKeys! !!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 12:38'!new	^ self order: 5! !!BTree class methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:01'!order: aNumber	^ self keys: (BTreeKeysArray new: aNumber)! !!BTree methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:51'!at: aMagnitude	^ self at: aMagnitude ifAbsent: [self error: aMagnitude printString, ' not found']! !!BTree methodsFor: 'accessing' stamp: 'jcg 1/17/2005 23:09'!at: aMagnitude ifAbsent: errorBlock       | leaf |       leaf _ root existingLeafForKey: aMagnitude.       leaf ifNil: [^ errorBlock value].       ^ leaf valueForKey: aMagnitude ifAbsent: errorBlock! !!BTree methodsFor: 'adding' stamp: 'avi 2/24/2004 12:08'!at: aMagnitude put: anObject	| leaf |	leaf _ root leafForKey: aMagnitude.	leaf insertKey: aMagnitude value: anObject.	root _ leaf root.	^ anObject! !!BTree methodsFor: 'enumerating' stamp: 'avi 4/21/2005 02:41'!commonKeysWith: aTree keysAndValuesDo: aBlock	^ aTree depth < self depth		ifTrue: [aTree root commonKeysWith: root keysAndValuesDo: aBlock flip: true]		ifFalse: [root commonKeysWith: aTree root keysAndValuesDo: aBlock flip: false]! !!BTree methodsFor: 'accessing' stamp: 'avi 4/21/2005 02:28'!depth	^ root depth! !!BTree methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:49'!do: aBlock	root allLeavesDo: [:ea | ea valuesDo: aBlock]! !!BTree methodsFor: 'copying' stamp: 'avi 5/1/2005 14:51'!emptyCopy	^ BTree keys: root keyArray emptyCopy! !!BTree methodsFor: 'enumerating' stamp: 'avi 10/8/2004 18:04'!from: start to: end do: aBlock	self from: start to: end keysAndValuesDo: [:k :v | aBlock value: v]! !!BTree methodsFor: 'enumerating' stamp: 'avi 10/8/2004 18:01'!from: start to: end keysAndValuesDo: aBlock	root leavesFrom: start to: end do:		[:ea |		ea keysAndValuesDo:			[:k :v |			(k between: start and: end) ifTrue:				[aBlock value: k value: v]]]! !!BTree methodsFor: 'initialize-release' stamp: 'avi 3/2/2004 15:02'!initializeWithKeys: aBTreeKeys	aBTreeKeys size > 3 ifFalse: [self error: 'The BTree order must be at least 4'].	root _ BTreeLeafNode keys: aBTreeKeys! !!BTree methodsFor: 'accessing' stamp: 'avi 4/20/2005 14:29'!keys	^ Array streamContents:		[:s |		self keysDo: [:k | s nextPut: k]]! !!BTree methodsFor: 'enumerating' stamp: 'avi 2/24/2004 22:49'!keysAndValuesDo: aBlock	root allLeavesDo: [:ea | ea keysAndValuesDo: aBlock]! !!BTree methodsFor: 'enumerating' stamp: 'avi 4/20/2005 14:29'!keysDo: aBlock	root allLeavesDo: [:ea | ea keysDo: aBlock]! !!BTree methodsFor: 'accessing' stamp: 'avi 2/25/2004 23:32'!order	^ root size! !!BTree methodsFor: 'adding' stamp: 'avi 2/26/2004 17:31'!removeKey: aMagnitude	| leaf |	leaf _ root leafForKey: aMagnitude.	leaf removeKey: aMagnitude.	root _ leaf root! !!BTree methodsFor: 'private' stamp: 'avi 2/23/2004 21:21'!root	^ root! !!BTree methodsFor: 'accessing' stamp: 'avi 2/24/2004 23:02'!values	^ Array streamContents:		[:s |		self keysAndValuesDo: [:k :v | s nextPut: v]]! !!WeakValueBTree methodsFor: 'accessing' stamp: 'cmm 3/23/2006 20:37'!at: key ifAbsent: aBlock	^ (super		at: key		ifAbsent: [ ^ aBlock value ]) at: 1! !!WeakValueBTree methodsFor: 'accessing' stamp: 'cmm 3/23/2006 21:26'!at: key put: anObject	super		at: key		put: (WeakArray with: anObject).	^ anObject! !!WeakValueBTree methodsFor: 'accessing' stamp: 'cmm 3/23/2006 19:15'!copy	| answer |	answer _ self class new.	self keysAndValuesDo: 		[ : eachKey : eachValue | 		answer 			at: eachKey 			put: eachValue ].	^ answer! !!WeakValueBTree methodsFor: 'enumerating' stamp: 'cmm 3/23/2006 21:42'!do: aBlock	self keysAndValuesDo:		[ : eachKey : eachValue |		aBlock value:			(Association				key: eachKey				value: eachValue) ]! !!WeakValueBTree methodsFor: 'enumerating' stamp: 'cmm 3/23/2006 19:41'!keysAndValuesDo: aBlock	super keysAndValuesDo:		[ : eachKey : eachValue |		aBlock			value: eachKey			value: (eachValue at: 1) ]! !!WeakValueBTree methodsFor: 'accessing' stamp: 'cmm 3/23/2006 19:15'!maAt: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock	| current uniqueObject |	uniqueObject _ ''.	^(current _ self		at: anObject		ifAbsent: [ uniqueObject ]) == uniqueObject			ifTrue: [ zeroArgBlock value ]			ifFalse: [ oneArgBlock value: current ]! !!WeakValueBTree methodsFor: 'enumerating' stamp: 'cmm 3/23/2006 21:47'!select: aBlock	| answer |	answer _ self species new.	self keysAndValuesDo:		[ : eachKey : eachValue |		(aBlock value: eachValue) ifTrue: 			[answer				at: eachKey				put: eachValue ] ].	^ answer! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 7/9/2002 22:59'!maConsistsOf: aCollection	"Answer whether the receiver and aCollection reference all equal	objects, including the same number of references to those objects.  Order	is not a factor."	^self size = aCollection size and: [ self maIncludesAll: aCollection ]! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 9/27/2003 19:46'!maDeepCopy	"Squeak, in my opinion, does not make deepCopies of Collections consistent with other objects."	^self collect: [ : each | each copy ]! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 1/16/2002 16:48'!maDetect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	"foundBlock takes one argument, the found object."	self 		do: [ :element | (aBlock value: element) ifTrue: [ ^foundBlock value: element ] ].	^exceptionBlock value! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 7/24/2004 01:05'!maDo: aBlock while: conditionBlock	conditionBlock value ifFalse: [ ^ self ].	self do:		[ : each |		aBlock value: each.		conditionBlock value ifFalse: [ ^ self ] ]! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 12/19/2002 21:32'!maIncludesAll: aCollection	"Return true if the receiver includes all elements in aCollection.	If aCollection contains duplicate elements, the receiver must have	one for each of them."	| otherColl |	aCollection size > self size ifTrue: [ ^false ].	self size > 20		ifTrue:			[ ^self asBag maIncludesAll: aCollection ].	otherColl :=		aCollection size > 20			ifTrue: [ aCollection asBag ]			ifFalse: [ aCollection ].	otherColl do:		[ :each | (self occurrencesOf: each) < (otherColl occurrencesOf: each) ifTrue: [ ^false ] ].	^true! !!Collection methodsFor: '*ma base additions'!maMatchesElementsOf: anotherCollection	"Answer whether the receiver points to equivalent objects as	anotherCollection.  In SequencableCollections, the order must be	the same as well."	^self maConsistsOf: anotherCollection! !!Collection methodsFor: '*ma base additions' stamp: 'cmm 10/23/2002 20:29'!maRemoveAll	"Efficiently removes all elements from the receiver."	self init: self size! !!Collection methodsFor: '*ma base additions'!maRemoveAll: aCollection forEachAbsent: aBlock	^aCollection do:		[ :element |		self			remove: element			ifAbsent: [ aBlock value: element ] ]! !!Collection methodsFor: '*magma client' stamp: 'brp 5/10/2005 14:23'!read: attributeSymbol at: key	"Allows Smalltalk collection to be used interchangeably with MagmaCollections"	^ self select: [ :each | (each perform: attributeSymbol) = key ]! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:11'!at: aString	^ self at: aString ifAbsent: [self error: aString printString, ' not found']! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/22/2004 01:01'!at: aString ifAbsent: exceptionBlock	aString isEmpty ifTrue: [^ exceptionBlock value].	root ifNil: [^ exceptionBlock value].		^ (root lookupString: aString startingAt: 1) ifNil: exceptionBlock! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:11'!at: aString ifAbsentPut: exceptionBlock	^ self at: aString ifAbsent: [self at: aString put: exceptionBlock value]! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/22/2004 01:05'!at: aString put: anObject	aString isEmpty ifTrue: [self error: 'Keys cannot be empty'].	root ifNil: [root _ TSTreeNode key: aString first].	root lookupString: aString startingAt: 1 insert: anObject.	^ anObject! !!TSTree methodsFor: 'enumerating' stamp: 'avi 9/22/2004 01:00'!do: aBlock	root ifNotNil: [root do: aBlock]! !!TSTree methodsFor: 'as yet unclassified' stamp: 'avi 9/15/2004 21:59'!matchesForPrefix: aString	^ Array streamContents:		[:s |		self matchesForPrefix: aString do:			[:match |			s nextPut: match]]! !!TSTree methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 00:57'!matchesForPrefix: aString do: aBlock	aString isEmpty		ifTrue: [self do: aBlock]		ifFalse: [root ifNotNil: [root matchesForPrefix: aString startingAt: 1 do: aBlock]]! !!TSTree methodsFor: 'as yet unclassified' stamp: 'avi 9/15/2004 15:21'!matchesForString: aString distance: aNumber	^ Array streamContents:		[:s |		self matchesForString: aString distance: aNumber do:			[:match |			s nextPut: match]]! !!TSTree methodsFor: 'as yet unclassified' stamp: 'avi 10/20/2004 21:26'!matchesForString: aString distance: aNumber do: aBlock	self matchesForString: aString distance: aNumber limitNodes: nil do: aBlock! !!TSTree methodsFor: 'as yet unclassified' stamp: 'avi 10/20/2004 21:26'!matchesForString: aString distance: aNumber limitNodes: maxNodes do: aBlock	| nodeCount |	nodeCount _ 0.	aString isEmpty ifTrue: [^ self].	root isNil ifTrue: [^ self].	root matchesForString: aString startingAt: 1 distance: aNumber do: aBlock nodesDo:		[:ea |		nodeCount _ nodeCount + 1.		nodeCount = maxNodes ifTrue: [^ self]]! !!TSTree methodsFor: 'accessing' stamp: 'avi 12/13/2004 13:09'!removeKey: aString	^ self removeKey: aString ifAbsent: [self error: 'Could not find key ', aString printString]! !!TSTree methodsFor: 'accessing' stamp: 'avi 12/13/2004 13:09'!removeKey: aString ifAbsent: errorBlock	| val |	val _ root removeString: aString startingAt: 1.	root canBeCulled ifTrue: [root _ nil].	^ val ifNil: errorBlock! !!TSTree methodsFor: 'accessing' stamp: 'avi 9/15/2004 21:34'!values	^ Array streamContents: [:s | self do: [:ea | s nextPut: ea]]! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!defaultEqualitySelector	^ #=! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:57'!defaultKeys	^ BTreeKeysArray new: 64! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!defaultSortSelector	^ #hash! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:43'!keys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol	^ self basicNew initializeWithKeys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:55'!new	^ self sortBy: self defaultSortSelector! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:56'!sortBy: aSymbol	^ self sortSelector: aSymbol equalitySelector: self defaultEqualitySelector! !!TreeSet class methodsFor: 'as yet unclassified' stamp: 'avi 5/1/2005 14:57'!sortSelector: sortSymbol equalitySelector: equalsSymbol	^ self keys: self defaultKeys sortSelector: sortSymbol equalitySelector: equalsSymbol! !!TreeSet methodsFor: 'public' stamp: 'avi 3/2/2004 14:45'!add: anObject	| key bucket |	key _ self keyForValue: anObject.	bucket _ tree at: key ifAbsent: [#()].	(self bucket: bucket includes: anObject) ifFalse:		[tree at: key put: (bucket copyWith: anObject)].! !!TreeSet methodsFor: 'public' stamp: 'avi 5/1/2005 14:48'!addAll: aCollection	| oldVals newVals combined |	(self isCompatibleTreeSetWith: aCollection) ifFalse: [^ super addAll: aCollection].	aCollection tree keysAndValuesDo:		[:key :vals |		oldVals _ tree at: key ifAbsent: [#()].		newVals _ oldVals isEmpty					ifTrue: [vals]					ifFalse: [vals reject: [:ea | self bucket: oldVals includes: ea]].		newVals isEmpty ifFalse:			[combined _ oldVals isEmpty ifTrue: [newVals] ifFalse: [oldVals, newVals].			tree at: key put: combined]]! !!TreeSet methodsFor: 'public' stamp: 'ac 5/17/2005 14:07'!atIndex: index	| count |	count _ 0.	self do: [:ea | (count _ count + 1) = index ifTrue: [^ ea]].	self error: 'No item at index: ', index asString.! !!TreeSet methodsFor: 'private' stamp: 'avi 5/21/2004 12:18'!bucket: anArray includes: anObject	^ anArray anySatisfy: [:ea | (self value: anObject matches: ea)]! !!TreeSet methodsFor: 'public' stamp: 'avi 3/2/2004 11:16'!do: aBlock	tree do: [:bucket | bucket do: aBlock]! !!TreeSet methodsFor: 'public' stamp: 'avi 5/1/2005 15:50'!equalitySelector	^ equalsKey ifNil: [equalsKey _ self class defaultEqualitySelector]! !!TreeSet methodsFor: 'public' stamp: 'ac 5/17/2005 14:07'!first	^ self atIndex: 1! !!TreeSet methodsFor: 'public' stamp: 'avi 5/21/2004 12:30'!includes: anObject	| bucket |	bucket _  tree at: (self keyForValue: anObject) ifAbsent: [^ false].	^ self bucket: bucket includes: anObject! !!TreeSet methodsFor: 'initialize-release' stamp: 'avi 5/1/2005 14:52'!initializeWithKeys: aBtreeKeys sortSelector: sortSymbol equalitySelector: equalsSymbol	self setTree: (BTree keys: aBtreeKeys) sortSelector: sortSymbol equalitySelector: equalsSymbol! !!TreeSet methodsFor: 'public' stamp: 'avi 5/1/2005 15:28'!intersection: aCollection	| newTree intersection |	(self isCompatibleTreeSetWith: aCollection) ifFalse: [^ super intersection: aCollection].	newTree _ tree emptyCopy.		tree commonKeysWith: aCollection tree keysAndValuesDo:		[:key :left :right |		intersection _ left select: [:ea | self bucket: right includes: ea].		intersection isEmpty ifFalse: [newTree at: key put: intersection]].		^ TreeSet basicNew setTree: newTree sortSelector: self sortSelector equalitySelector: self equalitySelector! !!TreeSet methodsFor: 'private' stamp: 'avi 5/1/2005 15:26'!isCompatibleTreeSetWith: aCollection	aCollection isTreeSet ifFalse: [^ false].	aCollection equalitySelector = self equalitySelector ifFalse: [^ false].	aCollection sortSelector = self sortSelector ifFalse: [^ false].	^ true! !!TreeSet methodsFor: 'public' stamp: 'avi 5/1/2005 14:10'!isTreeSet	^ true! !!TreeSet methodsFor: 'plugs' stamp: 'avi 3/2/2004 15:01'!keyForValue: anObject	^ anObject perform: sortKey! !!TreeSet methodsFor: 'public' stamp: 'avi 5/21/2004 12:30'!remove: anObject	| key bucket |	key _ self keyForValue: anObject.	bucket _ tree at: key ifAbsent: [^ self].	(self bucket: bucket includes: anObject) ifTrue:		[bucket _ bucket reject: [:ea | self value: anObject matches: ea].		bucket isEmpty			ifTrue: [tree removeKey: key]			ifFalse: [tree at: key put: bucket]]! !!TreeSet methodsFor: 'public' stamp: 'lr 5/3/2005 17:24'!remove: anObject ifAbsent: aBlock	self remove: anObject.! !!TreeSet methodsFor: 'public' stamp: 'avi 6/13/2005 16:44'!removeAllSuchThat: aBlock	| changes remove |	changes _ Dictionary new.	tree keysAndValuesDo:		[:key :bucket |		remove _ bucket select: aBlock.		remove isEmpty ifFalse:			[changes at: key put: (bucket copyWithoutAll: remove)]].	changes keysAndValuesDo:		[:key :bucket |		tree at: key put: bucket]! !!TreeSet methodsFor: 'public' stamp: 'ac 5/17/2005 14:07'!second	^ self atIndex: 2! !!TreeSet methodsFor: 'initialize-release' stamp: 'avi 5/1/2005 14:51'!setTree: aBTree sortSelector: sortSymbol equalitySelector: equalsSymbol	tree _ aBTree.	sortKey _ sortSymbol.	equalsKey _ equalsSymbol! !!TreeSet methodsFor: 'public' stamp: 'avi 4/21/2005 02:45'!sortSelector	^ sortKey! !!TreeSet methodsFor: 'private' stamp: 'avi 4/20/2005 14:16'!tree	^ tree! !!TreeSet methodsFor: 'private' stamp: 'avi 5/1/2005 13:55'!tree: aBTree	tree _ aBTree! !!TreeSet methodsFor: 'public' stamp: 'lr 5/4/2005 16:34'!uniqueOn: aSelector	| result |	result := Dictionary new.	self do: [ :each | 		result			at: (each perform: aSelector)			put: each ].	^ result values.! !!TreeSet methodsFor: 'plugs' stamp: 'avi 5/1/2005 15:51'!value: anObject matches: otherObject	^ anObject perform: self equalitySelector with: otherObject! !!SystemWindow methodsFor: '*ma object serialization' stamp: 'cmm 2/22/2005 12:49'!maTransientVariables	^ super maTransientVariables, #( 'owner' )! !!Metaclass class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 14:22'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ (Class		maMaterializeFromGraph: aByteArray		using: aMaObjectSerializer) class! !!Metaclass methodsFor: '*ma object serialization' stamp: 'cmm 10/27/2004 22:57'!maInstancesRequireOwnBuffer	^ true! !!Metaclass methodsFor: '*ma object serialization' stamp: 'cmm 10/27/2004 22:53'!maSerializationClass	^ Metaclass! !!Array class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:13'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in Array>>#objectForDataStream, whereby if the Array being stored is one of two special global Array's, a DiskProxy is stored instead.  For Ma object serialization, this was done on my instance-side in #maAsStorageObject.  If I was not stored as the DiskProxy, then I would not get to this method."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!Array methodsFor: '*magma client' stamp: 'cmm 6/27/2005 15:12'!isImmutableInMagma	"If I am one of the special global constant Array's, I am immutable, otherwise I'm not."	^ self maUsesStandardStorage not! !!Array methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 23:27'!maAsStorageObject	"I am about to be written on an object file.  If I am one of two shared global arrays, write a proxy instead."	"Note this behavior copied from Array>>#objectForDataStream:."	self == (TextConstants at: #DefaultTabsArray)		ifTrue: [ ^ DiskProxy global: #TextConstants selector: #at: args: #(DefaultTabsArray) ].	self == (TextConstants at: #DefaultMarginTabsArray)		ifTrue: [ ^ DiskProxy global: #TextConstants selector: #at: args: #(DefaultMarginTabsArray) ].	^ super maAsStorageObject! !!Array methodsFor: '*ma base additions' stamp: 'cmm 12/1/2004 23:10'!maInstSize	"Override from Object because this is considerably faster."	^ self size! !!Array methodsFor: '*magma client' stamp: 'cmm 2/8/2005 16:42'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"Because I got here, I am one of the shared special Array's in the system (see maAsStorageObject).  Changes are not tracked for logically referenced objects."	^ self maUsesStandardStorage		and:			[ super				maIsChangedFrom: aMaByteObjectBuffer				using: aMaObjectSerializer ]! !!Array methodsFor: '*ma object serialization' stamp: 'cmm 6/27/2005 15:12'!maUsesStandardStorage	^ self ~~ (TextConstants at: #DefaultTabsArray)	and: [ self ~~ (TextConstants at: #DefaultMarginTabsArray) ]! !!ScreenController class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in my instance-side #objectForDataStream:.  We use a reference in this materializing image rather than the creating a new object."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!ScreenController methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:35'!isImmutableInMagma	^ true! !!ScreenController methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:01'!maAsStorageObject	"Like DataStream, just store a reference to me instead of me."	^ DiskProxy		global: #ScheduledControllers		selector: #screenController args: #()! !!ScreenController methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:00'!maUsesStandardStorage 	^ false! !!StrikeFontSet class methodsFor: '*ma object serialization' stamp: 'cmm 8/24/2005 16:23'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"Materialize the DiskProxy which computes a reference to an appropriate StrikeFont in this materializing system."	| diskProxy |	diskProxy := aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!StrikeFontSet methodsFor: '*ma object serialization' stamp: 'cmm 8/24/2005 16:21'!maAsStorageObject 	^ DiskProxy		global: #StrikeFont selector: #familyName:size:emphasized:		args: { self familyName.  self height.  self emphasis }! !!StrikeFontSet methodsFor: '*ma object serialization' stamp: 'cmm 8/24/2005 16:22'!maUsesStandardStorage 	^ false! !!TTCFont methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 22:43'!maWantsPreSerialization 	^ true! !!TTFontDescription class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"Materialize the DiskProxy which computes a reference to an appropriate object in this materializing system."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!TTFontDescription methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!TTFontDescription methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:16'!maAsStorageObject 	^ DiskProxy 		global: #TTFontDescription selector: #descriptionNamed:		args: { self fullName }! !!TTFontDescription methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:15'!maUsesStandardStorage 	^ false! !!ByteArray methodsFor: '*magma client' stamp: 'cmm 4/10/2005 16:01'!maAllowsWriteBarrier	"Primitive failed when attempted."	^ false! !!ByteArray methodsFor: '*ma client server' stamp: 'cmm 10/1/2002 19:42'!maAsIpString	^self size = 4		ifTrue:			[ (WriteStream on: (String new: 4))				maPrint: (self at: 1);				nextPut: $.;				maPrint: (self at: 2);				nextPut: $.;				maPrint: (self at: 3);				nextPut: $.;				maPrint: (self at: 4);				contents ]		ifFalse: [ '(not an ip address)' ]! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 12/1/2004 23:02'!maInstSize	"Override from Object because this is many times faster."	^ self size! !!ByteArray methodsFor: '*magma client' stamp: 'cmm 10/9/2004 21:11'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	^self ~= aMaByteObjectBuffer asByteArray! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 10:12'!maUint: bits at: anInteger	| answer bytes |	bits == 64 ifTrue: [ ^ self maUnsigned64At: anInteger + 1 ].	bits == 56 ifTrue: [ ^ self maUnsigned56At: anInteger + 1 ].	bits == 48 ifTrue: [ ^ self maUnsigned48At: anInteger + 1 ].	bits == 40 ifTrue: [ ^ self maUnsigned40At: anInteger + 1 ].	bits == 32		ifTrue:			[ ^self				unsignedLongAt: anInteger + 1				bigEndian: false ].	bits == 16		ifTrue:			[ ^self				unsignedShortAt: anInteger + 1				bigEndian: false ].	bits == 8 		ifTrue:			[ ^self byteAt: anInteger + 1 ].	bytes _ bits // 8.	answer _ LargePositiveInteger new: bytes.	1 to: bytes do:		[ :digitPosition |		answer			digitAt: digitPosition			put: (self at: digitPosition + anInteger) ].	^answer normalize! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 10:30'!maUint: bits at: position put: anInteger	position + 1		to: position + (bits // 8)		do:			[ :pos |			self				at: pos				put: (anInteger digitAt: pos-position) ].	^anInteger! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 10:09'!maUnsigned40At: index	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 w |	w _ self at: index.	b3 _ self at: index+1.	b2 _ self at: index+2.	b1 _ self at: index+3.	b0 _ self at: index+4.	"Minimize LargeInteger arithmetic"	b3 = 0 ifFalse:[w _ (b3 bitShift: 8) + w].	b2 = 0 ifFalse:[w _ (b2 bitShift: 16) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 24) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 32) + w].	^w! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 10:04'!maUnsigned48At: index	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 b4 w |	w _ self at: index.	b4 _ self at: index+1.	b3 _ self at: index+2.	b2 _ self at: index+3.	b1 _ self at: index+4.	b0 _ self at: index+5.	"Minimize LargeInteger arithmetic"	b4 = 0 ifFalse:[w _ (b4 bitShift: 8) + w].	b3 = 0 ifFalse:[w _ (b3 bitShift: 16) + w].	b2 = 0 ifFalse:[w _ (b2 bitShift: 24) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 32) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 40) + w].	^w! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 10:03'!maUnsigned56At: index	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 b4 b5 w |	w _ self at: index.	b5 _ self at: index+1.	b4 _ self at: index+2.	b3 _ self at: index+3.	b2 _ self at: index+4.	b1 _ self at: index+5.	b0 _ self at: index+6.	"Minimize LargeInteger arithmetic"	b5 = 0 ifFalse:[w _ (b5 bitShift: 8) + w].	b4 = 0 ifFalse:[w _ (b4 bitShift: 16) + w].	b3 = 0 ifFalse:[w _ (b3 bitShift: 24) + w].	b2 = 0 ifFalse:[w _ (b2 bitShift: 32) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 40) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 48) + w].	^w! !!ByteArray methodsFor: '*ma base additions' stamp: 'cmm 3/18/2005 09:59'!maUnsigned64At: index	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 b4 b5 b6 w |	w _ self at: index.	b6 _ self at: index+1.	b5 _ self at: index+2.	b4 _ self at: index+3.	b3 _ self at: index+4.	b2 _ self at: index+5.	b1 _ self at: index+6.	b0 _ self at: index+7.	"Minimize LargeInteger arithmetic"	b6 = 0 ifFalse:[w _ (b6 bitShift: 8) + w].	b5 = 0 ifFalse:[w _ (b5 bitShift: 16) + w].	b4 = 0 ifFalse:[w _ (b4 bitShift: 24) + w].	b3 = 0 ifFalse:[w _ (b3 bitShift: 32) + w].	b2 = 0 ifFalse:[w _ (b2 bitShift: 40) + w].	b1 = 0 ifFalse:[w _ (b1 bitShift: 48) + w].	b0 = 0 ifFalse:[w _ (b0 bitShift: 56) + w].	^w! !!EventSensor class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:15'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"If I was the Sensor global, then I was stored as an empty String in a MaByteObjectBuffer and, thus, got to this method.  Otherwise, we materialize standard through the fixed-buffer."	^ Sensor! !!EventSensor methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:35'!isImmutableInMagma	^ true! !!EventSensor methodsFor: '*ma object serialization' stamp: 'cmm 2/6/2005 17:21'!maAsStorageObject 	^ self == Sensor		ifTrue: [ String maEmpty ]		ifFalse: [ self ]! !!EventSensor methodsFor: '*ma object serialization' stamp: 'cmm 2/6/2005 16:57'!maUsesStandardStorage	^ self ~~ Sensor! !!ScrollBar methodsFor: '*magma client' stamp: 'cmm 4/13/2005 14:11'!isImmutableInMagma 	"disallow one clients scrolling to affect other clients."	^ true! !!ScrollBar methodsFor: '*magma client' stamp: 'cmm 4/13/2005 14:10'!wantsMagmaEvents	"We don't refresh scrollbars.  Although this technically isn't necessary as long I answer true to isImmutableInMagma, this will prevent my updatableActionMap from getting the event-listeners put in there unnecessarily."	^ false! !!Float class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ false! !!Float methodsFor: '*ma object serialization' stamp: 'cmm 8/8/2002 23:05'!maOid	^MaOidCalculator oidForFloat: self! !!LimitedWriteStream methodsFor: '*ma base additions' stamp: 'cm 12/24/2001 16:02'!maPrintAbbreviated: aMaObject	aMaObject maPrintAbbreviatedOn: self! !!Color methodsFor: '*ma object serialization' stamp: 'cmm 11/26/2004 13:12'!maWantsPreSerialization 	^ true! !!String class methodsFor: '*ma base additions' stamp: 'cmm 1/28/2003 15:51'!maEmpty	"Using a canonical empty String can reduce object-count in memory or a large Magma database."	^''! !!String methodsFor: '*ma base additions' stamp: 'cmm 7/6/2006 12:11'!between: minString and: maxString	^ self >= minString  and: [self <= maxString ]! !!String methodsFor: '*magma client' stamp: 'cmm 3/28/2005 12:39'!maAllowsWriteBarrier	"Primitive failed when attempted."	^ false! !!String methodsFor: '*ma base additions'!maAsIntegerFromRadix: anInteger	"Answer a Smalltalk Integer with an equivalent value of the receiver	represented in radix anInteger."	^self		inject: 0		into: [ :sum :character | (sum * anInteger) + character digitValue ]! !!String methodsFor: '*ma base additions' stamp: 'cmm 12/19/2002 23:32'!maBeginsWith: aString ignoringCase: aBoolean	"Returns true if the receiver begins with the elements in aString,	while ignoring the case if aBoolean is true."	^aBoolean		ifTrue:			[ self asLowercase beginsWith: aString asLowercase ]		ifFalse:			[ self beginsWith: aString ]! !!String methodsFor: '*ma base additions' stamp: 'cmm 1/23/2002 01:24'!maEndsWith: aString ignoringCase: aBoolean	"Returns true if the receiver begins with the elements in aString,	while ignoring the case if aBoolean is true."	^aBoolean		ifTrue:			[ self asLowercase endsWith: aString asLowercase ]		ifFalse:			[ self endsWith: aString ]! !!String methodsFor: '*ma base additions' stamp: 'cmm 1/28/2003 11:57'!maFormattedForPlural: aNumber	"This is kind of a wing-nut method, but it can save you some	redundant code if you care to make your programs user message	plural and singular friendly.  It will add or remove an s based on	aNumber and whether or not the receiver already ends in s."	^aNumber > 0 & (aNumber <= 1)		ifTrue:			[ "should not end in s"			(self				maEndsWith: 's'				ignoringCase: true)					ifTrue:						[ self							copyFrom: 1							to: self size - 1 ]					ifFalse:						[ self ] ]		ifFalse:			[ (self				maEndsWith: 's'				ignoringCase: true)					ifTrue:						[ "should end in s"						self ]					ifFalse:						[ self , 's' ] ]! !!String methodsFor: '*ma base additions' stamp: 'cmm 12/1/2004 23:02'!maInstSize	"Override from Object because this is many times faster."	^ self size! !!String methodsFor: '*magma client' stamp: 'cmm 10/17/2004 14:24'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	^self ~= aMaByteObjectBuffer asString! !!String methodsFor: '*ma base additions' stamp: 'cm 12/24/2001 16:39'!maPrintAbbreviatedOn: aStream	self printOn: aStream! !!Behavior methodsFor: '*writebarrier' stamp: 'avi 10/6/2004 12:57'!canUncompact	^ true! !!Behavior methodsFor: '*writebarrier' stamp: 'avi 4/3/2005 01:23'!ensureUncompact	self indexIfCompact > 0 ifTrue:		[self canUncompact			ifTrue: [self becomeUncompact]			ifFalse: [ self error: 'Cannot uncompact ', self name]]! !!Behavior methodsFor: '*writebarrier' stamp: 'avi 10/7/2004 02:23'!fieldsWrittenToBySelector: aSymbol	| cm |	cm _ self lookupSelector: aSymbol.	^ cm ifNil: [#()] ifNotNil: [(1 to: self instSize) select: [:i | cm writesField: i]]! !!Behavior methodsFor: '*writebarrier' stamp: 'avi 10/6/2004 12:06'!holder	^ #holder -> self! !!Behavior methodsFor: '*magma client' stamp: 'cmm 5/2/2005 17:54'!isImmutableInMagma 	^ true! !!Behavior methodsFor: '*ma object serialization' stamp: 'cmm 12/2/2004 15:27'!maAllInstVarNamesAt: anInteger	| x |	x _ 0.	self maAllInstVarNamesDo:		[ : each | 		x _ x + 1.		x = anInteger ifTrue: [ ^ each ] ].	self error: 'Index out of bounds:  ', anInteger printString! !!Behavior methodsFor: '*ma base additions' stamp: 'cmm 12/2/2004 15:07'!maAllInstVarNamesDo: aBlock	superclass ifNotNil: [ superclass maAllInstVarNamesDo: aBlock ].	self instVarNames do: aBlock! !!Behavior methodsFor: '*ma base additions' stamp: 'cmm 12/16/2004 01:26'!maAllSelectorsDo: aBlock	self selectorsDo: aBlock.	superclass ifNotNil: [ superclass maAllSelectorsDo: aBlock ]! !!Behavior methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 15:24'!maAsStorageObject	^ MaClassReference className: self theNonMetaClass name! !!Behavior methodsFor: '*ma base additions' stamp: 'cmm 11/19/2003 22:48'!maFirstCommentAt: selector	"A much more-convenient method than firstCommentAt:, which requires you to specify the exact class, a problem when the method is implemented in the superclass methodDict."	^(self methodDict includesKey: selector)		ifTrue: [ self firstCommentAt: selector ]		ifFalse: [ self superclass maFirstCommentAt: selector ]! !!Behavior methodsFor: '*ma base additions' stamp: 'cmm 11/19/2003 22:53'!maFirstCommentOrNilAt: selector	"A much more-convenient method than firstCommentAt:, which requires you to specify the exact class, a problem when the method is implemented in the superclass methodDict."	| string |	^(string _ self maFirstCommentAt: selector) isEmpty		ifTrue: [ nil ]		ifFalse: [ string ]! !!Behavior methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 15:18'!maUsesStandardStorage	^ false! !!Behavior methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 15:18'!maWantsPreSerialization	^ true! !!ReadStream methodsFor: '*ma base additions' stamp: 'cmm 7/1/2003 22:12'!maUpToIncluding: anObject	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: end! !!EToyVocabulary class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:15'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	| vocabOrDiskProxy |	vocabOrDiskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ vocabOrDiskProxy maIsDiskProxy		ifTrue: [ vocabOrDiskProxy comeFullyUpOnReload: nil ]		ifFalse: [ vocabOrDiskProxy ]! !!EToyVocabulary methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 21:49'!maAsStorageObject	"copied from #objectForDataStream:"	vocabularyName == #eToy ifFalse: [^ self].	^ DiskProxy 		global: #Vocabulary		selector: #vocabularyNamed: 		args: (Array with: vocabularyName)! !!EToyVocabulary methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"We get here only if using non-standard storage, in which case we reference to existing global vocabularies, and changes to logically-referenced globals are not tracked."	^ self maUsesStandardStorage not! !!EToyVocabulary methodsFor: '*ma object serialization' stamp: 'cmm 2/8/2005 16:36'!maUsesStandardStorage	^ vocabularyName == #eToy! !!DisplayScreen class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:14'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in my instance-side #objectForDataStream, whereby a DiskProxy is stored instead.  For Ma object serialization, this was done on my instance-side in #maAsStorageObject."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!DisplayScreen methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:35'!isImmutableInMagma	^ true! !!DisplayScreen methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 12:42'!maAsStorageObject	"Emulate the same behavior as #objectForDataStream:."	^ DiskProxy global: #Display selector: #yourself args: #()! !!DisplayScreen methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 12:42'!maUsesStandardStorage 	^ false! !!ScriptEditorMorph methodsFor: '*ma object serialization' stamp: 'cmm 11/26/2004 14:35'!maWantsPostMaterialization 	^ true! !!Set class methodsFor: '*ma object serialization' stamp: 'cmm 11/22/2004 16:08'!maIsLogicallyVariable	"Answer whether, for ma serialization purposes, I am stored as a fixed or variable object."	^ true! !!Set class methodsFor: '*ma object serialization' stamp: 'cmm 12/2/2004 12:35'!maLoadVariableObjectFrom: aMaVariableObjectBuffer	| skeleton |	skeleton _ self new: aMaVariableObjectBuffer objectInstSize.	1		to: aMaVariableObjectBuffer objectInstSize		do: [ :index | skeleton add: (aMaVariableObjectBuffer maInstVarAt: index) ].	^ skeleton! !!Set methodsFor: '*magma client' stamp: 'cmm 3/27/2005 20:38'!maAllowsWriteBarrier	^ false! !!Set methodsFor: '*ma object serialization' stamp: 'cmm 12/1/2004 22:55'!maBufferInstSize	^ self size! !!Set methodsFor: '*ma object serialization' stamp: 'cmm 3/27/2006 17:05'!maEstablishPointerReferencesUsing: aMaObjectSerializer	"I am currently loaded with oids of the objects that I should be referencing.  Now that objects for these oids are, themselves, materialized, I can now replace my referernces to oids wtih references to the real objects."	| fullOfOidsCopy |	self isEmpty ifTrue: [ ^ self ]. "performance, avoid the copy if possible.."	fullOfOidsCopy _ self copy.	self maRemoveAll.	fullOfOidsCopy do:		[ :each |		self add: (aMaObjectSerializer objectWithOid: each) ]! !!Set methodsFor: '*ma traverse object graphs' stamp: 'cmm 12/2/2004 17:29'!maGraphDo: aBlock using: aObjectTraversalStrategy path: path with: alreadyVisitedSet	"Sets and Dictionary's are enumerated logically."	| varIndex |	varIndex _ 1.	self do:		[ :each |		self			maValueGraphNode: each			index: varIndex			using: aObjectTraversalStrategy			with: aBlock			path: path			with: alreadyVisitedSet.		varIndex _ varIndex + 1 ]! !!Set methodsFor: '*magma client' stamp: 'cmm 3/27/2005 23:16'!maIsChangedFrom: aMaVariableObjectBuffer using: aMaObjectSerializer	| oidSet |	aMaVariableObjectBuffer objectInstSize ~= self size ifTrue: [ ^ true ].	oidSet _ Set new: aMaVariableObjectBuffer objectInstSize.	aMaVariableObjectBuffer instVarsDoWithIndex: [ : eachOid : x | oidSet add: eachOid ].	self do: [ :each | (oidSet includes: (aMaObjectSerializer oidFor: each)) ifFalse: [ ^ true ] ].	^ false! !!Set methodsFor: '*ma object serialization'!maIsHashedCollection	^true! !!Set methodsFor: '*magma client' stamp: 'cmm 10/22/2004 00:01'!maRefreshTo: aMaVariableObjectBuffer using: aMagmaSession	| save |	save _ self copy.  "prevent GC of my items until we get it refreshed.."	save size.   "prevent compiler from optimizing it out.."	self maRemoveAll.	aMaVariableObjectBuffer instVarsDoWithIndex:		[ : each : x |		self add: (			aMagmaSession				objectWithOid: each				ifAbsent: [ self error: 'shoud be present' ]) ]! !!Set methodsFor: '*ma base additions' stamp: 'cmm 10/23/2002 22:01'!maRemoveAll	"Efficiently removes all elements from the receiver."	self init: (self size max: 4)! !!Set methodsFor: '*ma base additions' stamp: 'cmm 7/24/2002 20:41'!maShallowCopy	| copy |	copy _ self species new: self size.	self do: [ :each | copy add: each ].	^copy! !!Set methodsFor: '*ma object serialization' stamp: 'cmm 11/28/2004 16:21'!maStreamVariablyInto: aMaVariableBuffer for: aMaObjectSerializer	"Put the receivers instance variables into aMaVariableObjectBuffer as they fit."	| index |	index _ 1.	self do:		[ : eachLinkedObject |		aMaVariableBuffer			maInstVarAt: index			put:				(aMaVariableBuffer 					numberToStoreFor: eachLinkedObject					using: aMaObjectSerializer).		index _ index + 1 ].	3 "skip array and tally, they're taken care of logically, above."		to: self maInstSize		do:			[ : namedIndex |			aMaVariableBuffer				maInstVarAt: index + namedIndex				put: (aMaObjectSerializer oidFor: (self instVarAt: namedIndex)) ]! !!Association class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:13'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in Association>>#objectForDataStream, whereby if the Array being stored is a Smalltalk global, a DiskProxy is stored instead.  For Ma object serialization, this was done on my instance-side in #maAsStorageObject.  If I was not stored as the DiskProxy, then I would not get to this method."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!Association methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:36'!isImmutableInMagma	"Magma does not track changes to globals.  Therefore, if I am one of the entries in the Smalltalk global dictionary, I am immutable, otherwise I'm not."	^ self maUsesStandardStorage not! !!Association methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 00:13'!maAsStorageObject	"I am about to be serialized into a ByteArray.  If I am a known global, write a proxy that will hook up with the same resource in the destination system.  This behavior emulates what Association>>#objectForDataStream: does."	^ self maUsesStandardStorage 		ifTrue: [ self ]		ifFalse:			[ DiskProxy				global: #Smalltalk selector: #associationOrUndeclaredAt: 				args: (Array with: key) ]! !!Association methodsFor: '*magma client' stamp: 'apg 4/25/2005 10:06'!maIsAssociation	^ true! !!Association methodsFor: '*magma client' stamp: 'cmm 2/8/2005 16:08'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"If I was an Association for a known global (see #maAsStorageObject), then I am being stored as a Proxy.  Changes to these global relationships are not tracked."	^ false! !!Association methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 00:10'!maUsesStandardStorage	^ (Smalltalk associationAt: key ifAbsent: [nil]) ~~ self! !!Integer methodsFor: '*ma base additions' stamp: 'cmm 9/1/2006 17:53'!maBitClear: index	"Return the receiver with the bit at index set."	^self bitAnd: (1 bitShift: index-1) - 1! !!Integer methodsFor: '*ma base additions' stamp: 'cmm 4/29/2005 17:12'!maBitSet: index	"Return the receiver with the bit at index set."	^self bitOr: (1 bitShift: index - 1)! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:17'!maDay	^self maDays! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:01'!maDays	^MaDuration fromSeconds: self * MaCalendarTime secondsPerDay! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 2/2/2003 10:10'!maDivideIntoCalendarTime: aMaDuration	^MaDuration fromMilliseconds: aMaDuration totalMilliseconds // self! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 2/2/2003 10:34'!maDivideIntoDuration: aMaDuration	^MaDuration fromMilliseconds: aMaDuration totalMilliseconds // self! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:15'!maHour	^self maHours! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:04'!maHours	^MaDuration fromSeconds: self * 3600 "seconds in an hour"! !!Integer methodsFor: '*ma base additions' stamp: 'cmm 9/1/2006 17:51'!maIsBitClear: bitPosition 	^ (self maIsBitSet: bitPosition) not! !!Integer methodsFor: '*ma base additions' stamp: 'cmm 9/1/2006 17:52'!maIsBitSet: bitPosition 	^ self 		anyBitOfMagnitudeFrom: bitPosition		to: bitPosition! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:15'!maMillisecond	"Return an MaDuration (to be used as a magnitude) with	a magnitude of the number of milliseconds the receiver represents."	^self maMilliseconds! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:10'!maMilliseconds	"Return an MaDuration (to be used as a magnitude) with	a magnitude of the number of milliseconds the receiver represents."	^MaDuration fromMilliseconds: self! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:21'!maMinute	^ self maMinutes! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 13:21'!maMinutes	^MaDuration fromSeconds: self * 60! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 2/2/2003 10:38'!maModuloDuration: aMaDuration	^MaDuration fromMilliseconds: aMaDuration totalMilliseconds \\ self! !!Integer methodsFor: '*ma object serialization'!maOid	^MaOidCalculator oidForInteger: self! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 8/24/2004 13:30'!maSecond	^self maSeconds! !!Integer methodsFor: '*ma time objects' stamp: 'cmm 3/3/2004 12:58'!maSeconds	"Return an MaDuration (to be used as a magnitude) with a magnitude of the number of seconds the receiver represents."	^MaDuration fromSeconds: self! !!ViewerFlapTab methodsFor: '*ma object serialization' stamp: 'cmm 11/26/2004 14:34'!maWantsPostMaterialization 	^ true! !!StrikeFont class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"Materialize the DiskProxy which computes a reference to an appropriate StrikeFont in this materializing system."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!StrikeFont methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:10'!maAsStorageObject 	^ DiskProxy		global: #StrikeFont selector: #familyName:size:emphasized:		args: { self familyName.  self height.  self emphasis }! !!StrikeFont methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:05'!maUsesStandardStorage 	^ false! !!MCLocalMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:53'!creationTemplate	^ self name, ' path: ''<fully qualified path'''! !!MCLocalMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:37'!description	^ 'Magma (local)'! !!MCLocalMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:13'!fillInTheBlankRequest	^ 'Local Magma Repository:'! !!MCLocalMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2005 18:46'!path: aString	^ self location: (MagmaLocalLocation path: aString)! !!MCLocalMagmaRepository methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2005 18:44'!description	^ 'magmaLocal://', location description! !!MCMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 1/31/2005 23:49'!location: aMagmaLocation	^ self new		location: aMagmaLocation ;		yourself! !!MCMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:19'!morphicConfigure	^ self fillInTheBlankConfigure! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 2/15/2005 13:07'!basicStoreVersion: aMCVersion	self ensureConnectedSession commit: [ self codeBase storeVersion: aMCVersion ]! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 2/15/2005 14:21'!codeBase	^ self ensureConnectedSession codeBase! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 3/11/2005 14:11'!ensureConnectedSession	session 		ifNil: 			[ session _ MagmaSession connectedSessions				detect: [ : each | each location = location ]				ifNone: [ location newSession ] ].	[ session ensureConnected ]		on: MagmaUserRequiredNotification 		do: [ : request | request resume: (MagmaUser id: 'monticello ui_', UUID new asString36) ].	^ session! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 2/15/2005 13:07'!includesVersionNamed: aString	^ self ensureConnectedSession codeBase includesVersionNamed: aString! !!MCMagmaRepository methodsFor: 'private' stamp: 'cmm 1/30/2005 18:44'!location: aMagmaLocation	location _ aMagmaLocation! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 10/24/2004 23:33'!morphicOpen: aWorkingCopy	(MCRepositoryInspector repository: self workingCopy: aWorkingCopy) show! !!MCMagmaRepository methodsFor: 'accessing' stamp: 'cmm 11/5/2004 00:15'!packages	^ (self codeBase packages collect: [ : each | each package ]) asSet		asSortedCollection: [ : a : b | a name < b name ]! !!MCMagmaRepository methodsFor: 'framework' stamp: 'cmm 10/26/2004 23:36'!versionWithInfo: aVersionInfo ifAbsent: errorBlock	^ self codeBase		versionWithInfo: aVersionInfo		ifAbsent: errorBlock! !!MCMagmaRepository methodsFor: 'reading packages' stamp: 'cmm 10/26/2004 22:23'!versionsAvailableForPackage: aPackage	^ self codeBase versionsAvailableForPackage: aPackage! !!MCRemoteMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 7/26/2005 22:33'!creationTemplate	^ self name, '		host: ''localhost''		port: 1010'! !!MCRemoteMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:37'!description	^ 'Magma (remote)'! !!MCRemoteMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 10/27/2004 12:13'!fillInTheBlankRequest	^ 'Remote Magma Repository:'! !!MCRemoteMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2005 18:45'!host: hostName port: anInteger	^ self location:		(MagmaRemoteLocation			host: hostName			port: anInteger)! !!MCRemoteMagmaRepository methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2005 18:45'!description	^ 'magmaRemote://', location description! !!Message methodsFor: '*ma base additions' stamp: 'cmm 7/10/2003 23:12'!maArguments: anArray	args _ anArray! !!FlapTab class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:15'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in my instance-side #objectForDataStream, whereby if the FlapTab being stored is a global flap (i.e., present in all Projects), a DiskProxy is stored instead.  For Ma object serialization, this was done on my instance-side in #maAsStorageObject.  If I was not stored as the DiskProxy, then I would not get to this method."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!FlapTab methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!FlapTab methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 12:47'!maAsStorageObject	"Emulating the behavior of #objectForDataStream:."	^ self isGlobalFlap		ifTrue:			[ DiskProxy				global: #Flaps selector: #globalFlapTabOrDummy: 				args: {self flapID} ]		ifFalse: [ self ]! !!FlapTab methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 12:47'!maUsesStandardStorage	^ self isGlobalFlap not! !!MaProgressBarMorph methodsFor: 'as yet unclassified' stamp: 'cmm 11/12/2003 22:59'!initialize	super initialize.	self		extent: 100@12;		color: Color gray;		layoutPolicy: TableLayout new;		position: 100@100.	bar _ RectangleMorph new		color: Color green;		extent: 0@self height;		layoutInset: 0;		position: 0@0;		setBorderStyle: #complexRaised;		vResizing: #spaceFill;		yourself.	self percent: 0.0.	self addMorph: bar! !!MaProgressBarMorph methodsFor: 'as yet unclassified' stamp: 'cmm 8/6/2003 00:23'!percent: aFloat "between 0.0 and 1.0"	| secureFloat |	secureFloat _ aFloat > 1.0 ifTrue: [ 1.0 ] ifFalse: [ aFloat < 0.0 ifTrue: [ 0.0 ] ifFalse: [ aFloat ] ].	bar width: self width*secureFloat! !!MaProgressBarMorph methodsFor: 'as yet unclassified' stamp: 'cmm 7/19/2004 23:52'!veryDeepInner: aDeepCopier	super veryDeepInner: aDeepCopier.	bar _ bar veryDeepCopyWith: aDeepCopier! !!Morph methodsFor: '*magma client' stamp: 'cmm 2/25/2005 17:23'!aboutToRefreshFromMagma: aMagmaRefreshEvent	| restoreData |	self isInWorld ifFalse: [ "no need"  ^ self ].	self isWorldMorph ifTrue: [ "not supported"  ^ self ].	"capture position and index, then delete so it can be updated 'offline'."	restoreData _ Dictionary new.	restoreData		at: #owner put: owner ;		at: #index put: (owner submorphs indexOf: self) ;		at: #wasStepping put: (self isWorldMorph or: [ self isStepping ]).	aMagmaRefreshEvent restoreData: restoreData.	self delete! !!Morph methodsFor: '*magma client' stamp: 'cmm 4/10/2005 16:19'!maAllowsWriteBarrier 	"Just trying to be 'safe'."	^ false! !!Morph methodsFor: '*ma object serialization' stamp: 'cmm 2/22/2005 12:49'!maTransientVariables	^ owner == World  "If serializing a live Morph in the world."		ifTrue: [ super maTransientVariables, #('owner') ]		ifFalse: [ super maTransientVariables ]! !!Morph methodsFor: '*ma object serialization' stamp: 'cmm 2/7/2005 21:55'!maWantsPreSerialization	^ true! !!Morph methodsFor: '*magma client' stamp: 'cmm 2/27/2005 18:48'!refreshedFromMagma: aMagmaRefreshEvent	aMagmaRefreshEvent hasRestoreData		ifTrue:			[ (aMagmaRefreshEvent restoreData at: #owner)				addMorph: self				asElementNumber: (aMagmaRefreshEvent restoreData at: #index).			owner isWorldMorph				ifTrue: 					[ owner startSteppingSubmorphsOf: self.					WorldState addDeferredUIMessage: (MessageSend receiver: owner selector: #clearTurtleTrails) ]				ifFalse:					[ (aMagmaRefreshEvent restoreData at: #wasStepping)						ifTrue: [ self startStepping ] ] ]! !!Morph methodsFor: '*magma client' stamp: 'cmm 2/22/2005 21:10'!wantsMagmaEvents	^ true! !!SystemOrganizer class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"A simpler, alternative way to store a direct global reference than using DiskProxy."	^ SystemOrganization! !!SystemOrganizer methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:33'!isImmutableInMagma	^ true! !!SystemOrganizer methodsFor: '*ma object serialization' stamp: 'cmm 2/17/2005 13:56'!maAsStorageObject 	^ String maEmpty! !!SystemOrganizer methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 17:13'!maUsesStandardStorage 	^ false! !!Rectangle methodsFor: '*ma base additions' stamp: 'cmm 8/25/2003 23:42'!maPointAtRandom	^(self topLeft x + self width atRandom) @ (self topLeft y + self height atRandom)! !!HandMorph class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:15'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ ActiveHand! !!HandMorph methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!HandMorph methodsFor: '*ma object serialization' stamp: 'cmm 6/30/2004 13:58'!maAsStorageObject	"We don't yet support serialization of individual HandMorphs.  For now, we restore any HandMorph as a logical link to the ActiveHand."	^ String maEmpty! !!HandMorph methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !!MaMinimalObject commentStamp: 'cmm 1/13/2005 14:25' prior: 0!I am the main superclass for objects with a minimal api.  I am meant to have just enough api to be able to develop and debug.!!MaForwardingProxy methodsFor: 'as yet unclassified' stamp: 'cmm 1/13/2005 16:21'!doesNotUnderstand: aMessage	^ self		forward: aMessage		to: self realObject! !!MaForwardingProxy methodsFor: 'as yet unclassified' stamp: 'cmm 1/13/2005 16:20'!forward: aMessage to: anObject	^ aMessage sendTo: anObject! !!MaForwardingProxy methodsFor: 'as yet unclassified' stamp: 'cmm 1/13/2005 17:15'!maIsForwardingProxy	^ true! !!MaForwardingProxy methodsFor: 'as yet unclassified' stamp: 'cmm 1/13/2005 16:22'!realObject	self subclassResponsibility! !!MagmaForwardingProxy commentStamp: 'cmm 1/13/2005 14:47' prior: 0!I refer to an object in the repository indicated by my 'magmaId'.  You send me a message and I'll signal my session to try to connect if necessary and forward the message on to the real object in that repository.If my session cannot make a connection, I will create an "MagmaOfflineObject" which will remember the message you sent and try to send it when the session becomes available.!!MagmaForwardingProxy class methodsFor: 'as yet unclassified' stamp: 'cmm 7/18/2005 14:00'!session: aMagmaSession oid: anInteger	^ self new		forwardingProxySession: aMagmaSession ;		forwardingProxyOid: anInteger		"no yourself because it causes materialization of the proxy!!"! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/13/2005 17:49'!canGetRealObject	^ cachedObject notNil	or: [ session notNil and: [ session isConnected ] ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/18/2005 12:57'!doesNotUnderstand: aMessage	(aMessage arguments anySatisfy: [ : each | each isMagmaOfflineObject ])				ifTrue:					[ MagmaEnvironmentError signal: 'Can''t use an offline object as input to a message.' ].	^ self canGetRealObject		ifTrue:			[ self				forward: aMessage				to: self realObject ]		ifFalse:			[ self ensureConnectedOrOffline.			session isConnected				ifTrue:					[ self						forward: aMessage						to: self realObject ]				ifFalse:					[ "attempt to soften the impact of being on a plane with some sort of offline functionality."					MagmaNotification signal: 'Creating offline object for ', oid printString, ' needing message ', aMessage printString.					self offlineResults add: (MagmaOfflineObject needingMessage: aMessage) ] ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/18/2005 17:02'!ensureConnectedOrOffline	"If the state of this proxy is still ambiguous, disambiguate it by trying to connect to my session."	(self isForwardingProxyOffline not or: [ session isNil ]) ifTrue:		[ [ self forwardingProxySession ensureConnected ]			on: MaNetworkError			do:				[ : err | MagmaNotification signal: 'could not connect to ', self forwardingProxySession linkInformation, '.' ] ]! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/15/2005 13:36'!forward: aMessage to: anObject	| answer |	answer _		super			forward: aMessage			to: anObject.	self hasOfflineResults ifTrue:		[ offlineResults do:			[ : each |			each				becomeForward: (each waitingMessage sendTo: answer)				copyHash: false ].		MagmaWarning signal: 'Reconnecting to ', session magmaId name, ' has caused temporary offline-objects to become real objects.  Please rehash collections as necessary.'.		self resetOfflineResults ].	^ answer! !!MagmaForwardingProxy methodsFor: 'initialize-release' stamp: 'cmm 1/18/2005 16:22'!forwardingProxyOid: anInteger	oid _ anInteger! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/18/2005 16:16'!forwardingProxySession	"This has such an ugly name so as not to conflict with other API named #session, to which I need to invoke my doesNotUnderstand: logic."	^ session ifNil: [ session _ magmaId session ]! !!MagmaForwardingProxy methodsFor: 'initialize-release' stamp: 'cmm 1/18/2005 16:22'!forwardingProxySession: aMagmaSession	session _ aMagmaSession.	magmaId _ aMagmaSession magmaId.	magmaId location: aMagmaSession location! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/14/2005 12:18'!hasOfflineResults	"I am offline if an attempt has been made to connect to my session but failed.  Once offline, I will not continue to try connecting to my session each time a message is sent."	^ offlineResults isEmptyOrNil not! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/18/2005 16:24'!isForwardingProxyOffline	"I am offline if an attempt has been made to connect to my session but failed.  Once offline, I will not continue to try connecting to my session each time a message is sent."	^ self hasOfflineResults! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 4/8/2005 15:20'!isImmutableInMagma 	"There is absolutely no reason to subject yourself to the danger of trying to point this to a different object.  Just create a new one via #asMagmaForwardingProxy."	^ true! !!MagmaForwardingProxy methodsFor: 'serialization' stamp: 'cmm 1/14/2005 12:30'!maPreserialize	(MagmaProxySerialization for: self) signal! !!MagmaForwardingProxy methodsFor: 'testing' stamp: 'cmm 1/16/2005 23:52'!maRequiresOwnBuffer	^ true! !!MagmaForwardingProxy methodsFor: 'serialization' stamp: 'cmm 2/22/2005 12:49'!maTransientVariables 	^ super maTransientVariables, #( 'session' 'cachedObject' 'offlineResults' )! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 17:36'!name	^ self doesNotUnderstand: (Message selector: #name)! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/13/2005 16:04'!offlineResults	^ offlineResults ifNil: [ offlineResults _ OrderedCollection new ]! !!MagmaForwardingProxy methodsFor: 'actions' stamp: 'cmm 4/18/2005 16:43'!proxyDisconnect	"If I was unable to connect to my repository earlier, use this method to try to connect again."	self forwardingProxySession disconnect! !!MagmaForwardingProxy methodsFor: 'actions' stamp: 'cmm 1/18/2005 16:18'!proxyReconnect	"If I was unable to connect to my repository earlier, use this method to try to connect again."	self forwardingProxySession ensureConnected! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/13/2005 17:41'!realObject	^ cachedObject ifNil:		[ cachedObject _ session			objectWithOid: oid			ifAbsent:				[ MagmaGarbageCollectedObject signal: 'Sorry, this object has been dereferenced and subsequently garbage collected.' ] ]! !!MagmaForwardingProxy methodsFor: 'initialize-release' stamp: 'cmm 1/13/2005 16:03'!resetOfflineResults	offlineResults _ nil! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 13:02'!size	^ self doesNotUnderstand: (Message selector: #size)! !!MagmaForwardingProxy methodsFor: 'private' stamp: 'cmm 1/17/2005 21:57'!value	^ self doesNotUnderstand: (Message selector: #value)! !!MaMinimalObject methodsFor: 'Public methods'!= anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject! !!MaMinimalObject methodsFor: 'accessing'!basicClass	^self proxyClass! !!MaMinimalObject methodsFor: 'Public methods'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0 ! !!MaMinimalObject methodsFor: 'actions' stamp: 'cmm 1/13/2005 13:46'!becomeForward: otherObject copyHash: copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the recevier.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)				copyHash: copyHash! !!MaMinimalObject methodsFor: 'accessing'!class	^self proxyClass! !!MaMinimalObject methodsFor: 'actions'!error: aString	"Stop the currently executing process and display	 the error message aString."	^nil error: aString! !!MaMinimalObject methodsFor: 'actions' stamp: 'cmm 1/13/2005 14:26'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority.""This method copied from Object."! !!MaMinimalObject methodsFor: 'debugging'!halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	Halt signal! !!MaMinimalObject methodsFor: 'debugging'!halt: aString 	"This is the typical message to use for inserting breakpoints during 	debugging. It creates and schedules a Notifier with the argument, 	aString, as the label."		Halt new signal: aString! !!MaMinimalObject methodsFor: 'debugging' stamp: 'cmm 12/1/2004 14:28'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	self inspectorClass openOn: self withEvalPane: true! !!MaMinimalObject methodsFor: 'debugging' stamp: 'cmm 12/1/2004 14:28'!inspectorClass	^ Inspector! !!MaMinimalObject methodsFor: 'accessing' stamp: 'cmm 12/25/2002 00:44'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	"Access beyond fixed variables."	<primitive: 73>	self primitiveFailed! !!MaMinimalObject methodsFor: 'accessing' stamp: 'cmm 2/3/2005 11:12'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!MaMinimalObject methodsFor: 'testing' stamp: 'cmm 5/4/2005 11:15'!isBehindWriteBarrier	"Proxy's don't change anyway.."	^ false! !!MaMinimalObject methodsFor: 'testing' stamp: 'cmm 2/15/2005 10:45'!isMorph	"this is here to satisfy CommandHistory."	^ false! !!MaMinimalObject methodsFor: '*magma client' stamp: 'cmm 3/28/2005 17:02'!maAllowsWriteBarrier	^ false! !!MaMinimalObject methodsFor: 'private' stamp: 'cmm 12/25/2002 00:42'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: 'a primitive has failed'! !!MaMinimalObject methodsFor: 'printing'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title _ self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!MaMinimalObject methodsFor: 'printing' stamp: 'cmm 12/25/2002 00:41'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^String streamContents: [ :s | self printOn: s ]! !!MaMinimalObject methodsFor: 'accessing'!proxyClass	"Answer a Class which is the receiver's class"	<primitive: 111>	self primitiveFailed! !!MaMinimalObject methodsFor: 'Public methods' stamp: 'cmm 1/16/2005 22:51'!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	self error: 'My subclass should have overridden ', thisContext sender methodSelector printString! !!MaMinimalObject methodsFor: 'Public methods'!~= anObject	"Answer a Boolean which is false when the receiver and anObject	 are equivalent, and true otherwise."	^(self = anObject) not! !!MaMutatingProxy methodsFor: 'private' stamp: 'cmm 1/25/2005 23:49'!doesNotUnderstand: aMessage	"Trying this retry approach to satisfy the case where a Symbol is materialized and immediately used as the argument to perform:.  I discovered this was happening on Morphic objects but I had to set their read depth to 99999 anyway."	| didRetry |	didRetry _ false.	^ [ self maIsMutatingProxy ifTrue: [ self mutateAndSend: aMessage ] ifFalse: [ aMessage sendTo: self ] ]		on: MessageNotUnderstood 		do:			[ : err |			didRetry				ifFalse: 	[ didRetry _ true.  err retry ]				ifTrue: [ err signal ] ]! !!MaMutatingProxy methodsFor: 'private' stamp: 'cmm 1/13/2005 13:45'!maIsMutatingProxy	^ true! !!MaMutatingProxy methodsFor: 'private' stamp: 'cmm 12/24/2002 16:17'!mutant	"subclass responsibility"! !!MaMutatingProxy methodsFor: 'private'!mutateAndSend: aMessage	^self mutant		perform: aMessage selector		withArguments: aMessage arguments! !!MagmaMutatingProxy class methodsFor: 'creation' stamp: 'cmm 7/18/2005 14:00'!session: aMagmaSession oid: anInteger	^ self new		mutatingProxySession: aMagmaSession ;		mutatingProxyOid: anInteger		"no yourself because it causes materialization of the proxy!!"! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 2/21/2005 21:36'!= object	"The only way to answer correctly is for the fully-materialized objects to tell you.  However, if object is the same object as me, it would be true.  Getting two separate mutating-proxies for the same object is possible when a storage-object refers to a persistent object (i.e., MaCompiledMethodStorage>>'className')."	self == object ifTrue: [ ^ true ].	^ object maIsMutatingProxy		ifTrue:			[ self mutatingProxySession magmaId = object mutatingProxySession magmaId			and: [ self mutatingProxyOid = object mutatingProxyOid ] ]		ifFalse: [ self mutant = object ]! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 5/28/2002 00:36'!identityHash	^self mutant identityHash! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'cmm 1/13/2005 13:43'!maRequiresOwnBuffer	^false! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 2/21/2005 21:41'!mutant	| answer s |	s _ session.  "do this because, after realObjectFor:, we will be in the context of the new object, not this proxy, and session will not be available."	answer _ session realObjectFor: self mutatingProxyOid.	self == answer		ifFalse:			[ "This is possible when we reference back into the persistent model from a substitute storage-object (i.e., MaCompiledMethodStorage>>'name'.  See also, MaObjectSerializer>>append:."			self				becomeForward: answer				copyHash: false ].	s preferences signalProxyMaterializations		ifTrue: [ MagmaProxyMaterialization signalMaterializedObject: answer ].	^answer! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:10'!mutatingProxyOid	^ oid! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:10'!mutatingProxyOid: anInteger	oid _ anInteger! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:16'!mutatingProxySession	"This has such an ugly name so as not to conflict with other API named #session, to which I need to invoke my doesNotUnderstand: logic."	^session! !!MagmaMutatingProxy methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:20'!mutatingProxySession: aMagmaSession	session _ aMagmaSession! !!MagmaMutatingProxy methodsFor: 'printing' stamp: 'cmm 10/16/2002 16:11'!printOn: aStream	MagmaPreferences debugProxies		ifTrue:			[ super printOn: aStream ]		ifFalse:			[ self mutant printOn: aStream ]! !!MagmaMutatingProxy methodsFor: 'commenting'!whyNoHash	"Because we don't want to allow the receiver to ever be added to a hashed	collection.  We want it to mutate and then be added, otherwise we'd have to	know which hashed collections to rehash once the receiver was mutated."! !!ProtoObject class methodsFor: '*ma object serialization' stamp: 'cmm 1/17/2005 12:29'!maIsLogicallyVariable	"Answer whether, for ma serialization purposes, I am stored as a fixed or variable object."	^ self isVariable! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 13:39'!maAsStorageObject	"Some objects should be converted to another object before being stored	in a buffer."	^self! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 14:26'!maBufferInstSize	"Answer the number of pointers to other objects I logically have (which can be fewer than the number of physical pointers due to implementation of extra growth-space)."	^ self maInstSize! !!ProtoObject methodsFor: '*ma traverse object graphs' stamp: 'cmm 1/16/2005 13:43'!maGraphDo: aBlock using: aObjectTraversalStrategy path: path with: alreadyVisitedSet	"If this implementation changes, be sure to check subclasses below Collection which needed to copy this implementation."	1		to: self maInstSize		do:			[ :varIndex |			self				maValueGraphNode: (self instVarAt: varIndex)				index: varIndex				using: aObjectTraversalStrategy				with: aBlock				path: path				with: alreadyVisitedSet ]! !!ProtoObject methodsFor: '*ma traverse object graphs' stamp: 'cmm 1/16/2005 13:56'!maGraphWhere: threeArgConditionBlock do: threeArgBlock	| strategy |	strategy := MaObjectGraphTraversalStrategy new traverseWhen: threeArgConditionBlock.	self		maGraphDo: threeArgBlock		using: strategy! !!ProtoObject methodsFor: '*ma base additions' stamp: 'cmm 1/16/2005 14:03'!maInstSize	"Answer the number of named and indexed instance variables referenced by	the receiver."	^self class instSize + self basicSize! !!ProtoObject methodsFor: '*ma proxy support' stamp: 'cmm 1/16/2005 18:07'!maIsForwardingProxy	^ false! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 14:28'!maIsHashedCollection	^false! !!ProtoObject methodsFor: '*magma client' stamp: 'cmm 3/16/2005 12:37'!maIsLargeCollection 	^ false! !!ProtoObject methodsFor: '*ma proxy support' stamp: 'cmm 1/25/2005 21:54'!maIsMutatingProxy	^ false! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 2/13/2005 21:52'!maIsTransient: varIndex	"Answers whether my object referenced at varIndex should be serialized."		varIndex = 0 "root object" ifTrue: [ ^ false ].	self maTransientVariables isEmpty ifTrue: [ ^ false ].	varIndex > self class instSize ifTrue: [ ^ false ].	^ self maTransientVariables includes: (self class maAllInstVarNamesAt: varIndex)! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 14:52'!maSelectPreMadeObjectBufferFrom: aMaObjectSerializer	| cl |	cl _ self class.	cl isBytes ifTrue: [ ^ aMaObjectSerializer preMadeByteObjectBuffer ].	(cl isWords and: [ cl isPointers not ]) ifTrue: [ ^ aMaObjectSerializer preMadeVariableWordBuffer ].	cl maIsLogicallyVariable ifTrue: [ ^ aMaObjectSerializer preMadeVariableObjectBuffer ].	^ aMaObjectSerializer preMadeFixedObjectBuffer! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 17:57'!maSerializationClass	"All objects that can be serialized by Ma object serialization have their classes recorded mapped to an id except for Classes instances.  The class for these objects maps directly to Metaclass, rather than their specific metaclass instance."	^ self class! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 17:58'!maShouldAppendWithPath: path parent: parent index: indexInteger	^ parent isNil	or:		[ self maRequiresOwnBuffer		and: [ (parent maIsTransient: indexInteger) not ] ]! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 17:59'!maShouldTraverseWithPath: path parent: parent index: indexInteger	| cl |	cl _ self class.	cl isBytes ifTrue: [ ^ false ].	(cl isVariable and: [ cl isPointers not ]) ifTrue: [ ^ false ].	^ self maUsesStandardStorage	and: [ (parent maIsTransient: indexInteger) not ]! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 14:27'!maSizeIn: aMaObjectBuffer	"Answer the size of the buffer that contains the object references, excluding the header."	^ self maBufferInstSize * aMaObjectBuffer slotSize! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 18:00'!maTransientVariables	^ #()! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 17:30'!maUsesStandardStorage	"Override this method to store a different externalized version of me."	^ true! !!ProtoObject methodsFor: '*ma traverse object graphs' stamp: 'cmm 2/2/2005 11:10'!maValueGraphNode: anObject index: anInteger using: aObjectTraversalStrategy with: aBlock path: path with: alreadyVisitedSet	| stepInto |	anObject == nil ifTrue: [ ^anObject ].	anObject maIsMutatingProxy ifTrue: [ (MaTraverseProxyNotification proxy: anObject) signal.  ^ self ].  "Never traverse or value a proxy.."	(alreadyVisitedSet includes: anObject) ifTrue: [ ^anObject ].	path add: anObject.	stepInto :=		aObjectTraversalStrategy			shouldTraverseIntoLastOf: path			from: self			index: anInteger.	(aObjectTraversalStrategy		shouldValueLastOf: path		from: self		index: anInteger)			ifTrue:				[ alreadyVisitedSet add: anObject.  "IMPORTANT, this needs to be here and not above.."				aBlock					value: path					value: self					value: anInteger ].	stepInto		ifTrue:			[ anObject				maGraphDo: aBlock				using: aObjectTraversalStrategy				path: path				with: alreadyVisitedSet ].	path removeLast! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 18:04'!maWantsPostMaterialization	"Most objects do not need any preserialization behavior, therefore this allows the serializer to avoid the overhead of withAllSuperclassesDo:."	^ false! !!ProtoObject methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 18:04'!maWantsPreSerialization	"Most objects do not need any preserialization behavior, therefore this allows the serializer to avoid the overhead of withAllSuperclassesDo:."	^ false! !!ProtoObject methodsFor: '*magma client' stamp: 'cmm 4/13/2005 14:04'!wantsMagmaEvents	"If true, this object will listen to #magmaAboutToRefresh events from the event-listener mechanism (see Object 'events' method category).  After overriding with true in your class, you may then use #when:send:to: to direct the events to your purpose.  For example:		self when: #magmaAboutToRefresh send: #doSomething to: anyObject	self when: #magmaRefreshed send: #changed to: self	self when: #materializedFromMagma send: #upgrade: to: self  (arg is a MagmaMaterializationEvent)"	^ false! !!TimeProfileBrowser class methodsFor: '*ma base additions' stamp: 'cmm 12/24/2003 13:25'!maOnBlock: block if: conditionBlock	"Allows you to build up your sample set before invoking the profiler."	^conditionBlock value 		ifTrue: [ self onBlock: block ]		ifFalse: [ block value ]! !!Point methodsFor: '*magma client' stamp: 'cmm 5/3/2005 10:24'!maAllowsWriteBarrier	"Seems to cause a problem in Balloon when rendering.."	^ false! !!Symbol class methodsFor: '*ma object serialization' stamp: 'cmm 11/23/2004 12:47'!maMaterializeFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"This is the standard-case for building a skeleton of a variable-byte-sized object."	^ aMaByteObjectBuffer asString asSymbol! !!Symbol methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:34'!isImmutableInMagma	^ true! !!Symbol methodsFor: '*magma client' stamp: 'cmm 10/8/2004 17:19'!maRefreshTo: aMaByteObjectBuffer using: aMagmaSession	"Never try to refresh a Symbol.  They cannot change."! !!SystemDictionary class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ Smalltalk! !!SystemDictionary methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:35'!isImmutableInMagma	^ true! !!SystemDictionary methodsFor: '*ma object serialization' stamp: 'cmm 12/19/2002 23:13'!maAsStorageObject	"We don't even need to store the name of the global.  It's class	gives it away."	^String maEmpty! !!SystemDictionary methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !!ByteString methodsFor: '*ma base additions' stamp: 'cmm 11/10/2005 20:48'!maAlphabeticalNext	"Answer the next higher String.  This is useful in indexing systems to search for left-side matching strings."	| nextValue stream |	nextValue := (self asByteArray inject: 0 into: [ :sum :each | sum * 256 + each ]) + 1.	stream := WriteStream on: ByteArray new.	nextValue digitLength to: 1 by: -1 do:		[ : digitIndex |		stream nextPut: (nextValue digitAt: digitIndex) ].	^ stream contents asString! !!Number methodsFor: '*ma base additions' stamp: 'cm 12/24/2001 16:40'!maPrintAbbreviatedOn: aStream	self printOn: aStream! !!UUID methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:34'!isImmutableInMagma	^ true! !!UndefinedObject class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ false! !!UndefinedObject methodsFor: '*magma client' stamp: 'cmm 9/20/2005 11:19'!maIsChangedFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"Because nil keys develop in WeakKeyDictionaries, this method is necessary."	^ false! !!UndefinedObject methodsFor: '*ma object serialization'!maOid	^MaOidCalculator oidForNil! !!UndefinedObject methodsFor: '*magma client' stamp: 'cmm 9/20/2005 11:19'!maRefreshTo: aMaStorageObjectBuffer using: aMagmaSession	"Because nil keys develop in WeakKeyDictionaries, this method is necessary."	^ self! !!SortedCollection methodsFor: '*ma base additions' stamp: 'cmm 7/15/2006 15:12'!maIsSortedCollection	^ true! !!Interval methodsFor: '*ma base additions' stamp: 'cmm 6/4/2005 17:22'!maEnvelopes: anInterval 	"Return true if anInterval fits entirely inside the receiver."	^ (anInterval first between: start and: stop)	and: [ anInterval last between: start and: stop ]! !!Interval methodsFor: '*ma base additions' stamp: 'cmm 6/4/2005 01:09'!maIntersects: anInterval 	"Return true if the receiver overlaps with anInterval."	^(start between: anInterval first and: anInterval last) 		or: [ anInterval first between: start and: stop ]! !!SecureHashAlgorithm methodsFor: '*ma base additions' stamp: 'cmm 6/9/2005 11:55'!maHashMessage: aStringOrByteArray from: startPos to: stopPos	"Hash the given message using the Secure Hash Algorithm."	^ self		maHashStream: 			((ReadStream on: aStringOrByteArray asByteArray)				position: startPos-1 ;				yourself)		to: stopPos! !!SecureHashAlgorithm methodsFor: '*ma base additions' stamp: 'cmm 6/9/2005 11:59'!maHashStream: aPositionableStream to: endPosition	"Hash the contents of the given stream from the current position to endPosition using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	| currentPosition buf bitLength |	self initializeTotals.	aPositionableStream atEnd ifTrue: [self error: 'empty stream'].	endPosition > aPositionableStream size ifTrue: [ self error: 'invalid endPosition' ].	[ currentPosition _ aPositionableStream position.	currentPosition < endPosition ]		whileTrue:			[ buf _ aPositionableStream next: (64 min: endPosition-currentPosition).			(currentPosition < endPosition			and: [buf size = 64])				ifTrue: [ self processBuffer: buf ]				ifFalse: 					[ bitLength _ (endPosition - currentPosition) * 8.					self processFinalBuffer: buf bitLength: bitLength ] ].	^ self finalHash! !!BasicClassOrganizer class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:13'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"This method exists to mirror the logic in my instance-side #objectForDataStream:, whereby if the organizer being stored has a normal Class subect, a DiskProxy is stored instead.  For Ma object serialization, this was done on my instance-side in #maAsStorageObject.  If I was not stored as the DiskProxy, then I would not get to this method."	| diskProxy |	diskProxy _ aMaObjectSerializer materializeGraph: aByteArray.	^ diskProxy comeFullyUpOnReload: nil! !!BasicClassOrganizer methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:33'!isImmutableInMagma	^ true! !!BasicClassOrganizer methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 00:19'!maAsStorageObject 	^ self maUsesStandardStorage		ifTrue: [ super maAsStorageObject ]		ifFalse: [ DiskProxy global: self subject name selector: #organization args: #() ]! !!BasicClassOrganizer methodsFor: '*ma object serialization' stamp: 'cmm 2/4/2005 00:17'!maUsesStandardStorage 	^ (self hasSubject and: [ self subject isKindOf: Class ]) not! !!AbstractFont methodsFor: '*magma client' stamp: 'cmm 8/24/2005 16:23'!isImmutableInMagma	^ true! !!ScrollPane methodsFor: '*magma client' stamp: 'cmm 4/13/2005 14:11'!isImmutableInMagma 	"disallow one clients scrolling to affect other clients."	^ true! !!ScrollPane methodsFor: '*magma client' stamp: 'cmm 4/13/2005 14:11'!wantsMagmaEvents	"We don't refresh scrollbars.  Although this technically isn't necessary as long I answer true to isImmutableInMagma, this will prevent my updatableActionMap from getting the event-listeners put in there unnecessarily."	^ false! !!Boolean class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ false! !!FileDirectory methodsFor: '*ma base additions' stamp: 'cmm 6/8/2005 16:03'!maCopyFileNamed: sourceFilename toDirectory: aFileDirectory	| sourceStream |	sourceStream _ (self readOnlyFileNamed: sourceFilename) binary.	aFileDirectory		putFile: sourceStream		named: (aFileDirectory localNameFor: sourceFilename)! !!FileDirectory methodsFor: '*ma base additions' stamp: 'cmm 4/8/2002 20:52'!maEntriesMatching: pat	"FileDirectory default fileNamesMatching: '*'"	^ self entries select: [ :each | pat match: each name ]! !!Character class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ false! !!Character methodsFor: '*ma object serialization'!maOid	^MaOidCalculator oidForCharacter: self! !!Character methodsFor: '*ma base additions' stamp: 'cmm 7/24/2002 20:44'!maShallowCopy	"Characters are unique."	^self! !!CompiledMethod class methodsFor: '*writebarrier' stamp: 'avi 10/7/2004 13:29'!canUncompact	^ false! !!CompiledMethod class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:14'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ (aMaObjectSerializer materializeGraph: aByteArray) asCompiledMethod! !!CompiledMethod methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:34'!isImmutableInMagma	^ true! !!CompiledMethod methodsFor: '*ma object serialization' stamp: 'cmm 11/12/2004 10:54'!maAsStorageObject	^ MaCompiledMethodStorage newFor: self! !!CompiledMethod methodsFor: '*ma base additions' stamp: 'cmm 2/17/2002 16:16'!maMethodClass	^self who first! !!CompiledMethod methodsFor: '*ma base additions' stamp: 'cmm 7/3/2003 12:31'!maSourceString	^(self		getSourceFor: self selector		in: self maMethodClass) asString! !!CompiledMethod methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !!Class class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 14:21'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	| classReference |	classReference _ aMaObjectSerializer materializeGraph: aByteArray.	^ (aMaObjectSerializer classIdManager classDefinitionsForId: classReference id) last		ensureClassUsing: aMaObjectSerializer! !!Class methodsFor: '*ma object serialization' stamp: 'cmm 10/27/2004 22:53'!maSerializationClass	^ Class! !!MethodReference methodsFor: '*ma base additions' stamp: 'cmm 12/3/2004 10:39'!maActualMethod	| class |	^(class _ self actualClass)		ifNil: [ nil ]		ifNotNil:			[ (class canUnderstand: self methodSymbol)				ifTrue: [ class >> self methodSymbol ]				ifFalse: [ nil ] ]! !!MethodReference methodsFor: '*ma base additions' stamp: 'cmm 8/19/2003 23:53'!maCategory	^ self actualClass organization categoryOfElement: methodSymbol! !!MethodReference methodsFor: '*ma base additions' stamp: 'cmm 12/3/2004 11:07'!maSourceCode	^ self maActualMethod		ifNotNilDo: [ : method | self actualClass sourceCodeAt: methodSymbol ]! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 20:40'!canGrow	^ (self at: self size) isNil! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 18:00'!canShrink	^  (self at: self size // 2 + 1) notNil! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 23:39'!emptyCopy	^ self class new: self size! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:39'!findIndexForKey: aMagnitude	self withIndexDo:		[:key :i |		(key isNil or: [key > aMagnitude]) ifTrue:			[^ i - 1]].	^ self size! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:02'!first	^ self at: 1! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 17:40'!shiftLeftTo: index	index to: self size - 1 by: 1 do:		[:i |		self at: i put: (self at: i+1)].	self at: self size put: nil.! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 23:37'!shiftRightFrom: index	self size to: index+1 by: -1 do:		[:i |		self at: i put: (self at: i - 1)]	! !!BTreeKeys methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:02'!withIndexDo: aBlock	1 to: self size do: [:i | aBlock value: (self at: i) value: i]! !!BTreeStringKeys class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 14:31'!new	^ self new: 8! !!BTreeStringKeys class methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:04'!new: aNumber	^ self basicNew initializeWithSize: aNumber! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:00'!abbreviationSize	^ 3! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:43'!abbreviationsAndIndicesDo: aBlock	| stream |	stream _ abbreviations readStream.	1 to: self size do:		[:i |		stream atEnd			ifFalse: [aBlock value: prefix, (stream next: self abbreviationSize) value: i]			ifTrue: [aBlock value: nil value: i]]! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 15:41'!at: aNumber	^ keys at: aNumber! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:51'!at: aNumber put: aString	keys at: aNumber put: aString.	prefix _ self nilPrefix.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:39'!buildAbbreviationsFrom: readStreams	| nextChars |	1 to: self abbreviationSize do:		[:i |		nextChars _ readStreams collect: [:ea | ea next ifNil: [Character value: 0]].		nextChars withIndexDo:			[:c :j |			abbreviations at: (j-1 * self abbreviationSize) + i put: c]].	^ abbreviations! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:42'!extractPrefixFrom: readStreams	| prefixStream nextChars |	prefixStream _ String new writeStream.		[readStreams anySatisfy: [:ea | ea atEnd]] whileFalse:		[nextChars _ readStreams collect: [:ea | ea next].		(nextChars allSatisfy: [:ea | ea = nextChars first])				ifTrue: [prefixStream nextPut: nextChars first]				ifFalse: [readStreams do: [:ea | ea skip: -1]. ^ prefixStream contents]].	^ prefixStream contents! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:51'!findIndexForKey: aString	| stream str diff |	prefix = self nilPrefix ifTrue: [self rebuildAbbreviations].	stream _ aString readStream.	str _ stream next: prefix size + self abbreviationSize.	diff _ prefix size + self abbreviationSize - str size.	str _ str, (String new: diff).	self abbreviationsAndIndicesDo:		[:abbr :i |		abbr ifNil: [^ i - 1].		str < abbr ifTrue: [^ i - 1].		str = abbr ifTrue: [^ super findIndexForKey: aString]].	^ self size! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:51'!initializeWithSize: aNumber	keys _ Array new: aNumber.	prefix _ self nilPrefix.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:51'!nilPrefix	^ '^^^'! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 18:47'!rebuildAbbreviations	| keyStreams filled |	filled _ keys count: [:ea | ea notNil].	abbreviations _ String new: (filled * self abbreviationSize).	filled = 0 ifTrue: [prefix _ ''. ^ self ].	keyStreams _ (1 to: filled) collect: [:i | (keys at: i) readStream].		prefix _ self extractPrefixFrom: keyStreams.	abbreviations _ self buildAbbreviationsFrom: keyStreams.! !!BTreeStringKeys methodsFor: 'as yet unclassified' stamp: 'avi 3/2/2004 16:47'!size	^ keys size! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:40'!childForKey: aMagnitude	| index |	index _ keys findIndexForKey: aMagnitude.	index = 0 ifTrue:		[keys at: 1 put: aMagnitude.		^ self at: 1].	^ self at: index		! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:47'!childrenDo: aBlock	self valuesDo: aBlock! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 17:20'!commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean	| index |	aNode firstKey < self firstKey ifTrue: [^ aNode commonKeysWith: self keysAndValuesDo: aBlock flip: aBoolean not].	index _ (keys findIndexForKey: aNode firstKey) max: 1.	index to: self size do:		[:i |		(self at: i) ifNotNilDo: [:c | c commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean]]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 4/21/2005 02:28'!depth	^ 1 + self firstChild depth! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'jcg 1/17/2005 22:59'!existingChildForKey: aMagnitude       "Unlike #childForKey:, this method looks for a child, but doesn't mess with the tree if it doesn't exist."       | index |       index _ keys findIndexForKey: aMagnitude.       index = 0               ifTrue: [^ nil]               ifFalse: [^ self at: index].! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'jcg 1/17/2005 23:00'!existingLeafForKey: aMagnitude       "Unlike #leafForKey:, this method looks for a leaf but doesn't mess with the tree if it doesn't exist."       | child |       child _ self existingChildForKey: aMagnitude.       ^ child ifNotNil: [child existingLeafForKey: aMagnitude]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 00:39'!firstChild	self childrenDo: [:ea | ^ ea].	self error: 'No children'.! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 12:05'!insertKey: aMagnitude value: anObject at: index	super insertKey: aMagnitude value: anObject at: index.	anObject parent: self! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 00:22'!isLeaf	^ false! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/24/2004 01:59'!leafForKey: aMagnitude	^ (self childForKey: aMagnitude) leafForKey: aMagnitude! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 10/8/2004 18:04'!leavesFrom: start to: end do: aBlock	| startIndex endIndex |	startIndex _ (keys findIndexForKey: start) max: 1.	endIndex _ (keys findIndexForKey: end).	startIndex to: endIndex do: [:i | (self at: i) leavesFrom: start to: end do: aBlock]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 2/27/2004 21:01'!nextSiblingForChild: aNode	| index |	index _ keys findIndexForKey: aNode firstKey.	^ (index = self size or: [(keys at: index+1) isNil]) 		ifTrue: [index = 1 ifFalse: [self at: index - 1] ifTrue: [nil]]		ifFalse: [self at: index + 1]! !!BTreeInteriorNode methodsFor: 'as yet unclassified' stamp: 'avi 1/11/2005 13:13'!updateKey: oldMagnitude to: newMagnitude       keys withIndexDo:               [:key :i |               key = oldMagnitude ifTrue:                       [(i = 1 and: [parent notNil]) ifTrue:                               [parent updateKey: oldMagnitude to: newMagnitude].                       ^ keys at: i put: newMagnitude]].       self error: 'No such key'! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:45'!childrenDo: aBlock	"no children"! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'ac 5/17/2005 15:01'!commonKeysWith: aNode keysAndValuesDo: aBlock flip: aBoolean	| index key block leaf advanceKey last |	aNode firstKey ifNil: [^ self].	block _ aBoolean ifTrue: [[:k :v1 :v2 | aBlock value: k value: v2 value: v1]] ifFalse: [aBlock].	index _ 0.	advanceKey _		[index _ index + 1.		index > self size ifTrue: [^ self].		key _ keys at: index.		key ifNil: [^ self]].	last _ self lastKey.		advanceKey value.	[key < aNode firstKey] whileTrue: advanceKey.			[leaf _ aNode existingLeafForKey: key.	leaf lastKey < key ifTrue: advanceKey ifFalse:		[leaf keysAndValuesDo:			[:otherKey :otherValue |			otherKey > last ifTrue: [^ self].			[key < otherKey] whileTrue: advanceKey.			key = otherKey ifTrue: [block value: key value: (self at: index) value: otherValue]].		key > leaf lastKey ifFalse: advanceKey]] repeat! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/21/2005 02:28'!depth	^ 1! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'jcg 1/17/2005 23:08'!existingLeafForKey: aMagnitude       ^ self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:22'!isLeaf	^ true! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 16:41'!keys	^ Array streamContents: [:s | self keysDo: [:ea | s nextPut: ea]]! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 16:34'!lastKey	| last |	last _ nil.	self keysDo: [:k | last _ k].	^ last! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/23/2004 21:41'!leafForKey: aMagnitude	^ self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 10/8/2004 18:00'!leavesFrom: start to: end do: aBlock	aBlock value: self! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 2/26/2004 00:40'!valueForKey: aMagnitude ifAbsent: errorBlock	| i |	i _ keys findIndexForKey: aMagnitude.	^ (i > 0 and: [(keys at: i) = aMagnitude])		ifTrue: [self at: i]		ifFalse: [errorBlock value]! !!BTreeLeafNode methodsFor: 'as yet unclassified' stamp: 'avi 4/20/2005 15:03'!valueForKey: aMagnitude ifPresent: aBlock	^ aBlock value: (self valueForKey: aMagnitude ifAbsent: [^ nil])! !!BTreeNode class methodsFor: 'as yet unclassified' stamp: 'avi 2/25/2004 12:28'!keys: anArray	^ (self new: (anArray size)) keys: anArray! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:24'!allChildrenDo: aBlock	self childrenDo:		[:ea |		aBlock value: ea.		ea allChildrenDo: aBlock]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:34'!allLeavesDo: aBlock	self withAllChildrenDo: [:ea | ea isLeaf ifTrue: [aBlock value: ea]]! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/27/2004 20:41'!canGrow	^ keys canGrow! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/26/2004 17:59'!canShrink	^ keys canShrink! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:23'!children	^ Array streamContents: [:s | self childrenDo: [:ea | s nextPut: ea]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:44'!childrenDo: aBlock	self subclassResponsibility! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:27'!depth	^ parent ifNil: [1] ifNotNil: [1 + parent depth]! !!BTreeNode methodsFor: 'private' stamp: 'avi 4/29/2005 12:57'!ensureParent	parent ifNil:		 [self parent: (self interiorNodeClass keys: keys emptyCopy).		parent insertKey: self firstKey value: self].	^ parent! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/26/2004 00:35'!firstKey	^ keys first! !!BTreeNode methodsFor: 'private' stamp: 'avi 4/29/2005 12:57'!grow	| sibling |	parent ifNotNil:		[sibling _ parent nextSiblingForChild: self.		sibling ifNil: ["we're the new root". self parent: nil. ^ self].		sibling canShrink			ifTrue: [self stealFrom: sibling]			ifFalse: [self mergeWith: sibling]]				! !!BTreeNode methodsFor: 'inserting' stamp: 'avi 2/27/2004 20:41'!insertKey: aMagnitude value: anObject	| index key |	index _ keys findIndexForKey: aMagnitude.	index = 0 ifTrue:		[self canGrow			ifTrue:				[self shiftRightFrom: 1.				^ self insertKey: aMagnitude value: anObject at: 1]			ifFalse:				[self split.				^ (parent childForKey: aMagnitude) insertKey: aMagnitude value: anObject]].		key _ keys at: index.	key = aMagnitude ifTrue:		[^ self insertKey: aMagnitude value: anObject at: index].	index < self size ifTrue:		[key _ keys at: index + 1.		key			ifNil: [^ self insertKey: aMagnitude value: anObject at: index+1]			ifNotNil:				[self canGrow ifTrue:					[self shiftRightFrom: index+1.					^ self insertKey: aMagnitude value: anObject at: index+1]]].	"otherwise"	self split.	^ (parent childForKey: aMagnitude) insertKey: aMagnitude value: anObject! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 23:29'!insertKey: aMagnitude value: anObject at: index	keys at: index put: aMagnitude.	self at: index put: anObject! !!BTreeNode methodsFor: 'private' stamp: 'avi 4/29/2005 12:51'!interiorNodeClass	^ BTreeInteriorNode! !!BTreeNode methodsFor: 'testing' stamp: 'avi 2/24/2004 00:22'!isLeaf	self subclassResponsibility! !!BTreeNode methodsFor: 'private' stamp: 'avi 5/1/2005 13:56'!keyArray	^ keys! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 12:27'!keys: anArray	keys _ anArray! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/25/2004 23:31'!keysAndValuesDo: aBlock	keys withIndexDo:		[:key :i |		key ifNotNil: [aBlock value: key value: (self at: i)]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 4/20/2005 16:33'!keysDo: aBlock	keys withIndexDo:		[:key :i |		key ifNotNil: [aBlock value: key] ifNil: [^ self]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 10/8/2004 17:57'!leavesFrom: start to: end do: aBlock	self subclassResponsibility! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/27/2004 21:05'!mergeWith: aNode			| oldKey |	oldKey _ self firstKey.	aNode keysAndValuesDo:		[:k :v |		self insertKey: k value: v].	parent removeKey: aNode firstKey.	parent updateKey: oldKey to: self firstKey.! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/24/2004 00:24'!parent	^ parent! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/24/2004 00:24'!parent: aBTreeNode	parent _ aBTreeNode! !!BTreeNode methodsFor: 'removing' stamp: 'avi 2/27/2004 21:55'!removeKey: aMagnitude	| index key |	self canShrink ifFalse: [self grow].		index _ keys findIndexForKey: aMagnitude.	key _ keys at: index.	key = aMagnitude ifFalse: [^ self error: 'No such key'].		self shiftLeftTo: index.		index = 1 ifTrue: [parent ifNotNil: [parent updateKey: key to: self firstKey]]! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 22:17'!root	^ parent		ifNil: [self]		ifNotNil: [parent root]! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/26/2004 17:39'!shiftLeftTo: index	keys shiftLeftTo: index.	index to: self size - 1 by: 1 do:		[:i |		self at: i put: (self at: i+1)].	self at: self size put: nil.! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 23:37'!shiftRightFrom: index	keys shiftRightFrom: index.	self size to: index+1 by: -1 do:		[:i |		self at: i put: (self at: i-1)]! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/25/2004 23:39'!split	| other midpoint |	other _ self class keys: keys emptyCopy.	midpoint _ self size // 2 + 1.	midpoint to: self size do:		[:i |		other insertKey: (keys at: i) value: (self at: i) at: (i - midpoint + 1).		keys at: i put: nil.		self at: i put: nil].		self ensureParent insertKey: other firstKey value: other! !!BTreeNode methodsFor: 'private' stamp: 'avi 2/27/2004 21:55'!stealFrom: aNode	| key value |	aNode firstKey > self firstKey		ifTrue: [value _ aNode at: 1. key _ aNode firstKey]		ifFalse:			[aNode keysAndValuesDo: [:k :v | key _ k. value _ v].			parent ifNotNil: [parent updateKey: self firstKey to: key]].	self insertKey: key value: value.	aNode removeKey: key! !!BTreeNode methodsFor: 'accessing' stamp: 'avi 2/23/2004 21:47'!values	^ Array streamContents: [:s | self valuesDo: [:ea | s nextPut: ea]]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:59'!valuesDo: aBlock	self keysAndValuesDo: [:k :v | aBlock value: v]! !!BTreeNode methodsFor: 'enumerating' stamp: 'avi 2/23/2004 21:27'!withAllChildrenDo: aBlock	aBlock value: self.	self allChildrenDo: aBlock.! !!MaBasicReadStrategy commentStamp: '<historical>' prior: 0!This class operates on the client and server.!!MaBasicReadStrategy class methodsFor: 'creation'!deep	^self minimumDepth: 99999! !!MaBasicReadStrategy class methodsFor: 'creation'!minimumDepth: anInteger	^self new minimumDepth: anInteger! !!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 23:53'!beNew	"Be in a state that indicates I have changed and am different than my cached version on the server."	isNew _ true! !!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 14:55'!beOld	"Indicate that I have been checked against my classDefinitions and all possible depthSpecifications have been converted to the required server format (id's instead of classes)."	isNew _ false! !!MaBasicReadStrategy methodsFor: 'copying' stamp: 'cmm 2/8/2005 23:03'!copyWithoutSpecifications	^ self copy! !!MaBasicReadStrategy methodsFor: '*magma server' stamp: 'cmm 1/26/2005 17:28'!depthOfAttribute: attributeIndex onClassWithId: classId version: versionNumber	"Answer the delta-depth from the current depth to read.  This is distinct from my minimumDepth, which was used at the start of this graph-read."	^ 0! !!MaBasicReadStrategy methodsFor: 'unused depths' stamp: 'cmm 4/28/2003 22:38'!hasUnusedDepths	^false! !!MaBasicReadStrategy methodsFor: 'private' stamp: 'cmm 8/8/2006 22:59'!initialize	super initialize.	isNew _ true.	minimumDepth _ 1! !!MaBasicReadStrategy methodsFor: 'accessing' stamp: 'cmm 4/7/2005 15:14'!isBasic	^ true! !!MaBasicReadStrategy methodsFor: 'new/old' stamp: 'cmm 1/25/2005 23:53'!isNew	"Answer whether I have changed and now need to be cached in my session on the server."	^isNew! !!MaBasicReadStrategy methodsFor: 'building' stamp: 'cmm 1/26/2005 00:02'!makeReadyForUseUsing: aMaClassIdManager	"nothing to do for MaBasicReadStrategy's."! !!MaBasicReadStrategy methodsFor: 'accessing'!minimumDepth	^minimumDepth! !!MaBasicReadStrategy methodsFor: 'building' stamp: 'cmm 1/25/2005 23:52'!minimumDepth: anInteger	minimumDepth _ anInteger.	self beNew! !!MaReadStrategy commentStamp: 'cmm 1/26/2005 21:28' prior: 0!When objects are retrieved from a Magma repository, the server must eventually decide to stop traversing the graph and return a reasonable chunk of objects.  Sometimes, the default pattern of reading may be ineffecient for the processing needed.Therefore, my instances can be used to suggest to the server a particular depth for particular class or even a variable within a class.Implementation notes:There are two parts; 'specifications' and 'depths'.  The specifications track what the user wants, while the depths are the efficiently-integerized representation for each MaClassDefinition (and version).  That's why there are not more first-class objects here, MaObjectSerializer is efficient with #'s (although now with the server caching it's probably no longer an excuse).  Whenever the specs change, or when the ClassDefinitions change the depths need to be rebuilt.  That's what my #isNew api is all about.When transmitted to the server, it caches me there and I am then told to #beOld.  But only my depths are actually transmitted for further efficiency.  My '*magma server' methods are employed to determine the depth on the server.Use my 'building' methods so that the Testing methods can then answer whether a particular depth should be read on a particular object or class.!!MaReadStrategy methodsFor: 'private' stamp: 'cmm 1/26/2005 22:28'!convertSpecificationsToIdsUsing: aMaClassIdManager	"Convert the classes in the receiver to classId's, since that is what the server goes by."	| specifiedClassNames |	specifiedClassNames _ depthSpecifications keys collect: [ : each | each name ].	aMaClassIdManager classDefinitionsById do:		[ : eachDefinitions |		eachDefinitions do:			[ : eachDefinition |			eachDefinition withAllSuperclassDefinitionsDo:				[ : eachDef |				(specifiedClassNames includes: eachDef name)					ifTrue:						[ depths							at: { eachDefinition id.  eachDefinition version }							ifAbsentPut:								[ self beNew.								(self instVarMapFor: eachDef) ] ] ] ] ]! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 5/2/2005 22:12'!copyWithoutSpecifications	^ self copy		resetSpecifications ;		yourself! !!MaReadStrategy methodsFor: 'accessing' stamp: 'cmm 1/26/2005 11:16'!depthArrayOfSize: arraySize	^(Array new: arraySize) atAllPut: 0; yourself! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 6/10/2004 22:27'!depthDictionaryOfSize: arraySize	^ Dictionary new: arraySize! !!MaReadStrategy methodsFor: '*magma server' stamp: 'cmm 1/26/2005 12:22'!depthOfAttribute: attributeIndex onClassWithId: classId version: versionNumber	"Answer the depth that the attribute at attributeIndex should be traversed into *from the current depth*."	^depths		maAt: { classId. versionNumber }		ifPresent:			[ :depth |			depth isInteger				ifTrue: [ depth ]				ifFalse: [ depth at: attributeIndex ifAbsent: [ 0 ] ] ]		ifAbsent: [ 0 ]! !!MaReadStrategy methodsFor: 'building' stamp: 'bf 3/27/2006 19:15'!forVariableNamed: aString onAny: aClass readToDepth: anInteger	(aClass allInstVarNames includes: aString)		ifFalse:			[ MagmaUserError signal: aString , ' is not an attribute of ' , aClass name ].	(depthSpecifications		at: aClass		ifAbsentPut: [ self depthDictionaryOfSize: aClass instSize ])			at: aString			put: anInteger! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 6/28/2004 14:56'!hasUnusedDepths	^ depthSpecifications notEmpty! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 3/28/2006 17:34'!inheritDeeperDepthsUsing: aMaClassIdManager 	"When the user specifies:		myReadStrategy			forVariableNamed: 'submorphs'			onAny: Morph			readToDepth: 99999	then we need to ensure that any subclasses of Morph also read to 99999 for that variable.  Since each class has its own entire set of depth specs, we update the subclasses with the greater depth between their own and that of all their superclasses."	depths keysAndValuesDo: 		[ : eachIdAndVersion : eachDepths | 		eachDepths isInteger 			ifTrue: 				[ "using one default base depth for all variables"				depths 					at: eachIdAndVersion					put: (eachDepths max: (depths at: eachIdAndVersion)) ]			ifFalse: 				[ | definition |				definition _ aMaClassIdManager 					definitionForClassId: eachIdAndVersion first					version: eachIdAndVersion last.				eachDepths withIndexDo: 					[ : eachDepth : instVarIndex | 					definition allSuperclassDefinitionsDo: 						[ : eachDefinition | 						eachDefinition namedInstSize >= instVarIndex ifTrue: 							[ depths 								maAt: { eachDefinition id. eachDefinition version }								ifPresent: 									[ : foundDepths | 									| superclassDepth |									superclassDepth _ foundDepths at: instVarIndex.									eachDepths 										at: instVarIndex										put: (eachDepth max: superclassDepth) ]								ifAbsent: [ "depth not specified by superclass, no problem." ] ] ] ] ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 2/9/2005 10:14'!initialize	super initialize.	"depths:  key is converted to the classId, value is either	anInteger for depth of all instVars or an Array detailing the	depth of each instVar."	self 		resetDepths ;		initializeDefaultSpecifications! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 7/17/2006 13:31'!initializeDefaultSpecifications	depthSpecifications _ Dictionary new.	self		onAny: MaRootAnchor			readToDepth: 1 ;		onAny: Collection			readToDepth: 1.	#(MagmaCollection MaClassDefinition Morph Project Color Timespan DateAndTime Duration Point Time TimeZone) do: 		[ : each | 		(self class environment hasClassNamed: each) ifTrue: 			[ self 				onAny: (self class environment classNamed: each)				readToDepth: 99 ] ]! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 1/26/2005 22:21'!instVarMapFor: aMaClassDefinition	"Answer an Array with an instVarMap of aMaClassDefinition according to user-declared read depths."	| specifiedDepths answer |	(aMaClassDefinition isDefined	and: [ depthSpecifications includesKey: aMaClassDefinition classObject ])		ifTrue:			[ specifiedDepths _ depthSpecifications at: aMaClassDefinition classObject.			specifiedDepths isInteger				ifTrue: [ answer _ specifiedDepths ]				ifFalse:					[ answer _ self depthArrayOfSize: aMaClassDefinition namedInstSize.					specifiedDepths keysAndValuesDo:						[ : eachInstVarName : eachDepth |						answer							at: (aMaClassDefinition allInstVarNames indexOf: eachInstVarName)							put: eachDepth ] ] ].	^ answer! !!MaReadStrategy methodsFor: 'accessing' stamp: 'cmm 4/7/2005 15:14'!isBasic	^ false! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 1/26/2005 22:56'!makeReadyForUseUsing: aMaClassIdManager	self 		resetDepths ;		convertSpecificationsToIdsUsing: aMaClassIdManager ;		inheritDeeperDepthsUsing: aMaClassIdManager! !!MaReadStrategy methodsFor: 'building' stamp: 'cmm 6/28/2004 14:56'!onAny: aClass readToDepth: anInteger	depthSpecifications		at: aClass		put: anInteger! !!MaReadStrategy methodsFor: 'private' stamp: 'cmm 6/30/2004 17:14'!resetDepths	depths _ Dictionary new! !!MaReadStrategy methodsFor: 'specifications' stamp: 'cmm 9/23/2004 15:55'!resetSpecifications	depthSpecifications _ nil! !!MaBlockContextStorage class methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:11'!newFor: aBlockContext	^ self new		initializeFrom: aBlockContext ;		yourself! !!MaBlockContextStorage methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:07'!asBlockContext	| methodContext |	methodContext _ home asMethodContext.	^ (BlockContext newForMethod: methodContext method)		home: methodContext		startpc: startpc		nargs: nargs! !!MaBlockContextStorage methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:12'!initializeFrom: aBlockContext	nargs _ aBlockContext numArgs.	startpc _ aBlockContext startpc.	home _ MaMethodContextStorage newFor: aBlockContext home! !!MaChangedKeySpecification class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:19'!object: anObject attribute: aSymbol oldHashValues: oldHashValueInteger newHashValues: newHashValueInteger	^self new		object: anObject ;		attribute: aSymbol ;		oldHashValues: oldHashValueInteger ;		newHashValues: newHashValueInteger ;		yourself! !!MaChangedKeySpecification methodsFor: 'accessing'!attribute	^attribute! !!MaChangedKeySpecification methodsFor: 'private building'!attribute: aSymbol	attribute _ aSymbol! !!MaChangedKeySpecification methodsFor: 'accessing' stamp: 'cmm 12/5/2002 17:54'!newHashValues	^newHashValues! !!MaChangedKeySpecification methodsFor: 'private building' stamp: 'cmm 12/5/2002 18:00'!newHashValues: anArray	newHashValues _ anArray! !!MaChangedKeySpecification methodsFor: 'accessing'!object	^object! !!MaChangedKeySpecification methodsFor: 'private building'!object: anObject	object _ anObject! !!MaChangedKeySpecification methodsFor: 'accessing'!oid	^object! !!MaChangedKeySpecification methodsFor: 'accessing' stamp: 'cmm 12/5/2002 17:54'!oldHashValues	^oldHashValues! !!MaChangedKeySpecification methodsFor: 'private building' stamp: 'cmm 12/5/2002 18:00'!oldHashValues: anArray	oldHashValues _ anArray! !!MaChangedKeySpecification methodsFor: 'building' stamp: 'cmm 11/19/2002 22:42'!serializeUsing: aMaObjectSerializer	object _ aMaObjectSerializer oidFor: object! !!MaClassIdManager commentStamp: 'cmm 6/11/2004 16:53' prior: 0!classDefinitionsById -- all versions of all classes that I know about inImageDefinitions -- the in-image version of each class I know about.!!MaClassIdManager class methodsFor: 'accessing' stamp: 'cmm 8/24/2005 16:17'!minimumClasses	"These are the classes required to transmit a MaClassDefinition, used to establish protocol between two images."	^ { Metaclass.  Class.  MaClassReference.  MaClassDefinition.	Boolean. SmallInteger. Character. Float. UndefinedObject.	Array. #size class. '' class. ByteArray. Set.  OrderedCollection. Dictionary } ! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 10/29/2004 11:01'!addClassDefinition: aMaClassDefinition	| definitions answer |	definitions _ self ensureClassDefinitionsFor: aMaClassDefinition.	(answer _ self definitionLike: aMaClassDefinition in: definitions)		ifNil:			[ answer _ aMaClassDefinition.			definitions add: aMaClassDefinition.			aMaClassDefinition version: definitions size ].	answer isDefined ifTrue:		[ self			idOfClass: answer classObject			is: answer id.		self refreshInImageDefinition: answer classObject.		(answer superclassDefinition isNil and: [ answer classObject superclass ~= nil ])			ifTrue:				[ self addNewClass: answer classObject superclass.				answer initializeSuperclassDefinitionUsing: self ] ].	answer superclassDefinition notNil		ifTrue:			[ self addClassDefinition: answer superclassDefinition ].	^ answer! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 10/17/2004 22:38'!addNewClass: aClass	"Answer the storage definition created for aClass."	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ self addClassDefinition: (MaClassDefinition className: aClass name)! !!MaClassIdManager methodsFor: 'accessing'!classDefinitionsById	^classDefinitionsById! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 6/29/2004 17:42'!classDefinitionsById: aDictionary	classDefinitionsById _ aDictionary! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/17/2004 22:39'!classDefinitionsForClass: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ self classDefinitionsForId: (self idForClass: aClass)! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 8/22/2005 09:23'!classDefinitionsForId: anInteger	^ self		classDefinitionsForId: anInteger		ifAbsent: [ MaObjectSerializationSoftwareError signal: 'class-definition not found' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/12/2004 22:16'!classDefinitionsForId: anInteger ifAbsent: aBlock	^ anInteger		ifNil: [ aBlock value ]		ifNotNil:			[ classDefinitionsById				at: anInteger				ifAbsent: aBlock ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/8/2004 16:13'!classForId: anInteger	^ self		classForId: anInteger		ifAbsent: [ self error: anInteger printString, ' is not a known class id.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 12:46'!classForId: anInteger ifAbsent: aBlock	^ anInteger <= minimumClasses size		ifTrue:			[ minimumClasses at: anInteger ]		ifFalse:			[ classesById				at: anInteger				ifAbsent: aBlock ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/17/2004 22:39'!currentVersionOfClass: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ (self		inImageDefinition: aClass		ifAbsent: [ ^ 1 ]) version! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 3/23/2005 13:25'!definitionForClassId: classIdInteger version: classVersionInteger	^ classVersionInteger = 0		ifTrue: [ self inImageDefinition: (self classForId: classIdInteger) ]		ifFalse: [ (self classDefinitionsForId: classIdInteger) at: classVersionInteger ]! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 10/13/2004 23:43'!definitionLike: aMaClassDefinition in: definitionsCollection	definitionsCollection isEmpty ifTrue: [ ^ nil ].	(definitionsCollection anySatisfy: [ : each | each className = aMaClassDefinition className ]) ifFalse: [ ^ nil ].	(definitionsCollection includes: aMaClassDefinition) ifTrue: [ ^ aMaClassDefinition ].	^ definitionsCollection 		detect: [ : eachDef | eachDef hasSameDefinitionAs: aMaClassDefinition ]		ifNone: [ nil ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/14/2004 09:42'!ensureClassDefinitionsFor: aMaClassDefinition	"Look for the collection of versions of the same class that aMaClassDefinition is for.  If none exist create and answer the new collection that will hold aMaClassDefinition and its future versions."	^ (aMaClassDefinition id notNil and: [ classDefinitionsById includesKey: aMaClassDefinition id ])		ifTrue: [ classDefinitionsById at: aMaClassDefinition id ]		ifFalse:			[ classDefinitionsById 				maDetect: [ : eachDefinitions | eachDefinitions anySatisfy: [ : each | each isKnownAs: aMaClassDefinition className ] ]				ifFound:					[ : foundDefinitions | 					aMaClassDefinition id: foundDefinitions first id.					foundDefinitions ]				ifNone:					[ "None found, let's create one."					| id class |					"First figure out the id."					id _ aMaClassDefinition hasId						ifTrue: [ aMaClassDefinition id ]						ifFalse:							[ "Make sure not one of the minimumClasses."							((Smalltalk hasClassNamed: aMaClassDefinition className) and: [ self isMemberOfMinimumClasses: (class _ Smalltalk at: aMaClassDefinition className) ])								ifTrue: [ self idForClass: class ]								ifFalse: [ self nextClassId ] ].					aMaClassDefinition id: id.					classDefinitionsById						at: id						put: (OrderedCollection new: 1) ] ]! !!MaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/1/2004 15:21'!handleClassModification: aClass using: aMaObjectSerializer	"Optional subclass hook."! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 10/15/2004 12:31'!hasClassDefinitionFor: aClass	| foundQuickly |	foundQuickly _ inImageDefinitions		maAt: aClass		ifPresent: [ : definition | definition isPartOfClassDefinitions ]		ifAbsent: [ false ].	^ foundQuickly or:		[ classDefinitionsById anySatisfy:			[ : eachDefinitions |			(eachDefinitions last isKnownAs: aClass name)			and: [ eachDefinitions				anySatisfy:					[ : each | each hasSameDefinitionAs: aClass ] ] ] ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 8/26/2002 22:03'!idForClass: aClass	^self		idForClass: aClass		ifAbsent: [ MaSoftwareError signal: aClass name, ' has no id assigned.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 12:52'!idForClass: aClass ifAbsent: aBlock	| index |	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ idsByClass		at: aClass		ifAbsent: 			[ self maMarked: 'performance'.  "I think you can get rid of this indexOf: check.  It should be in the idsByClass dictionary..  shouldn't it?"			(index _ minimumClasses indexOf: aClass) > 0				ifTrue: [ index ]				ifFalse: [ aBlock value ] ]! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 10/15/2004 12:06'!idOfClass: aClass is: anInteger	nextClassId _ nextClassId max: anInteger.	classesById		at: anInteger		put: aClass.	^idsByClass		at: aClass		put: anInteger! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/6/2004 19:46'!inImageDefinition: aClass	^ self		inImageDefinition: aClass		ifAbsent: [ self error: aClass name, ' is not part of my inImageDefinitions.' ]! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 10/15/2004 11:58'!inImageDefinition: aClass ifAbsent: aBlock	^ inImageDefinitions		at: (aClass isMeta ifTrue: [ Metaclass ] ifFalse: [ aClass ])		ifAbsent: aBlock! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 6/30/2004 00:03'!includesIdForClass: aClass	^ idsByClass includesKey: aClass! !!MaClassIdManager methodsFor: 'copy' stamp: 'cmm 3/24/2005 12:06'!independentCopy	^ self copy postIndependentCopy! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 6/29/2004 17:47'!initialize	super initialize.	idsByClass _ Dictionary new.	classesById _ Dictionary new.	nextClassId _ 100.	inImageDefinitions _ Dictionary new.	self classDefinitionsById: Dictionary new.	self initializeMinimumClasses! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 7/11/2005 12:45'!initializeMinimumClasses	minimumClasses _ self class minimumClasses.	minimumClasses do: [ : each | self addNewClass: each ]! !!MaClassIdManager methodsFor: 'testing' stamp: 'cmm 7/11/2005 12:46'!isMemberOfMinimumClasses: aClass	aClass isMeta ifTrue: [ MaObjectSerializationSoftwareError signal: 'Metaclass instances are not stored here.' ].	^ minimumClasses includes: aClass! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 12:46'!minimumClasses	^ minimumClasses! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 8/15/2002 23:53'!nextClassId	^nextClassId _ nextClassId + 1! !!MaClassIdManager methodsFor: 'accessing' stamp: 'cmm 7/11/2005 14:38'!numberOfClasses	^ classDefinitionsById size! !!MaClassIdManager methodsFor: 'private' stamp: 'cmm 3/24/2005 12:05'!postIndependentCopy	classesById _ classesById copy.	idsByClass _ idsByClass copy.	classDefinitionsById _ classDefinitionsById copy.	inImageDefinitions _ inImageDefinitions copy! !!MaClassIdManager methodsFor: 'building' stamp: 'cmm 1/16/2005 22:16'!refreshInImageDefinition: aClass	"Whenever the user recompiles a class in the image (e.g., during development)."	({ Object. ProtoObject } includes: aClass)		ifTrue:			[ (self hasClassDefinitionFor: aClass)				ifTrue:					[ inImageDefinitions						at: aClass						ifAbsentPut: [ (self classDefinitionsForClass: aClass) last ].			^ self  "performance" ] ].	aClass withAllSubclassesDo:		[ : eachClass |  	| knownDefinitions |		(eachClass = aClass or: [ self includesIdForClass: eachClass ])			ifTrue:				[ knownDefinitions _ (self hasClassDefinitionFor: eachClass)					ifTrue: [ self classDefinitionsForClass: eachClass ]					ifFalse: [ #() ].				inImageDefinitions					at: eachClass					put:						(knownDefinitions							maDetect: [ : each | each hasSameDefinitionAs: eachClass ]							ifFound:								[ : foundDef |								"In the rare case, where a classdef was materialized but not defined in the image, so it was added to definitions only.  Now we're defining it so we need to be sure we set up its mappings."								self									idOfClass: eachClass									is: foundDef id.								foundDef ]							ifNone: [ MaClassDefinition className: eachClass name ]) ] ]! !!MagmaClassIdManager commentStamp: 'cmm 6/28/2004 15:04' prior: 0!The purpose of this class is to keep track of which classes are persistent.!!MagmaClassIdManager methodsFor: 'as yet unclassified' stamp: 'cmm 10/15/2004 12:40'!assimilateInImageDefinition: aClass	aClass isMeta ifTrue: [ MagmaSoftwareError signal: 'Metaclass instances are not stored here.' ].	self addClassDefinition: (self inImageDefinition: aClass)! !!MagmaClassIdManager methodsFor: 'accessing' stamp: 'cmm 6/29/2004 17:43'!classDefinitionsById: aDictionary	super classDefinitionsById: aDictionary.	self rebuildTransientClassMaps! !!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/1/2004 15:19'!handleClassModification: aClass using: aMaObjectSerializer	self refreshInImageDefinition: aClass! !!MagmaClassIdManager methodsFor: 'event handling' stamp: 'cmm 10/1/2004 15:21'!handleClassRename: aRenamedEvent	"aRenamedEvent's item has just been renamed."	aRenamedEvent isRenamed ifFalse: [ ^ self ].	(self includesIdForClass: aRenamedEvent item) ifFalse: [ ^ self ].	(self classDefinitionsForClass: aRenamedEvent item) do:		[ : eachClassDefinition |		eachClassDefinition className: aRenamedEvent newName ]! !!MagmaClassIdManager methodsFor: 'special-case' stamp: 'cmm 4/10/2005 18:00'!rebuildTransientClassMaps	| highestId |	idsByClass := idsByClass maOriginalClass new: idsByClass size.	classesById := classesById maOriginalClass new: classesById size.	inImageDefinitions := inImageDefinitions maOriginalClass 				new: inImageDefinitions size.	highestId := 0.	classDefinitionsById keysAndValuesDo: 			[:eachId :eachDefinitions | 			| eachClass |			eachDefinitions last isDefined 				ifTrue: 					[eachClass := eachDefinitions last classObject.					highestId := highestId max: eachId.					self idOfClass: eachClass is: eachId.					self refreshInImageDefinition: eachClass]].	nextClassId := highestId max: nextClassId! !!MaClientServerPreferences commentStamp: 'cmm 2/1/2005 15:27' prior: 0!Control your Ma client server preferences with this class.!!MaClientServerPreferences class methodsFor: 'accessing' stamp: 'cmm 1/2/2003 14:35'!debug	^Debug! !!MaClientServerPreferences class methodsFor: 'accessing' stamp: 'cmm 1/2/2003 14:53'!debug: aBoolean	Debug _ aBoolean! !!MaClientServerPreferences class methodsFor: 'private' stamp: 'cmm 1/2/2003 14:35'!initialize	super initialize.	Debug _ false! !!MaClientSocket commentStamp: 'cmm 2/1/2005 15:29' prior: 0!An easy-to-use class to send ByteArray or String requests to a socket listening on the network.  The other socket is listening using MaServerSocket.!!MaClientSocket class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:19'!hostAddress: aByteArray port: anInteger	Socket initializeNetwork.	^self new		hostAddress: aByteArray ;		port: anInteger ;		yourself! !!MaClientSocket class methodsFor: 'initializing' stamp: 'cmm 5/2/2003 15:08'!initialize	Smalltalk addToStartUpList: self! !!MaClientSocket class methodsFor: 'initializing' stamp: 'cmm 5/2/2003 15:11'!startUp: aBoolean	super startUp: aBoolean.	Socket initializeNetwork! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 9/22/2002 21:33'!disconnect	socket close! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 11/26/2004 09:45'!ensureByteArrayCanHold: anInteger	anInteger > 10000000 ifTrue: [ MaSecurityViolation signal: 'Possible attack.' ].	anInteger > byteArray size		ifTrue:			[ | newByteArray |			newByteArray _ ByteArray new: anInteger.			newByteArray				replaceFrom: 1				to: byteArray size				with: byteArray				startingAt: 1.			byteArray _ newByteArray ]! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 9/20/2002 14:28'!headerSize	^4! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/20/2002 12:24'!hostAddress	^hostAddress! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/20/2002 12:23'!hostAddress: aByteArray	hostAddress _ aByteArray! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 10/1/2002 19:43'!hostAndPortString	^'host: ', hostAddress maAsIpString, ' port: ', port printString! !!MaClientSocket methodsFor: 'initializing' stamp: 'cmm 12/24/2002 15:49'!initialize	super initialize.	byteArray _ ByteArray new: 1000.	timeoutSeconds _ 30! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 1/27/2003 23:57'!loadByteArrayWith: aByteArray startingAt: indexPosition count: anInteger	self ensureByteArrayCanHold: self headerSize + anInteger.	byteArray		replaceFrom: self headerSize + 1		to: self headerSize + anInteger		with: aByteArray		startingAt: indexPosition.	byteArray		maUint: 32		at: 0		put: self headerSize + anInteger! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/20/2002 12:23'!port	^port! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/20/2002 12:23'!port: anInteger	port _ anInteger! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 9/12/2005 13:37'!receiveInto: aByteArray	"First, we receive into *my* byteArray, then I paste it into aByteArray."	| bytesExpected bytesReceived answer |	bytesReceived := 0.	bytesExpected := nil.	[ bytesExpected isNil or: [ bytesReceived < bytesExpected ] ]		whileTrue:			[ socket 				waitForDataFor: timeoutSeconds				ifClosed: [ MaNetworkError signal: 'Connection closed while waiting for response.' ]				ifTimedOut: [ MaNetworkError signal: 'response not received from ', self hostAndPortString, ' within the timeout period.' ].			[ bytesReceived := bytesReceived				+ (socket					receiveSomeDataInto: byteArray					startingAt: bytesReceived + 1) ]				on: Error				do: 					[ : err | 					err messageText = 'a primitive has failed' 						ifTrue: [ err resignalAs: (MaNetworkError new messageText: 'Network failure while receiving response.'; yourself) ] ].			bytesExpected ifNil:				[ bytesReceived >= self headerSize 					ifTrue:						[ bytesExpected := byteArray maUint: 32 at: 0.						self ensureByteArrayCanHold: bytesExpected ] ] ].	"We should now have the full buffer in my byteArray, paste it into the answer ByteArray."	answer := (bytesReceived - self headerSize) > aByteArray size		ifTrue: [ ByteArray new: bytesReceived - self headerSize ]		ifFalse: [ aByteArray ].	answer		replaceFrom: 1		to: bytesReceived - self headerSize		with: byteArray		startingAt: self headerSize + 1.	^ answer! !!MaClientSocket methodsFor: 'private' stamp: 'cmm 7/2/2004 16:07'!send: anInteger	socket		sendData: byteArray		count: anInteger.	socket waitForSendDoneFor: timeoutSeconds.	socket sendDone ifFalse: [ MaNetworkError signal: 'Connection to ', self hostAndPortString, ' lost.' ]! !!MaClientSocket methodsFor: 'send' stamp: 'cmm 1/30/2003 22:08'!sendData: requestByteArray	| answer |	answer _ ByteArray new: 500.	^self		sendData: requestByteArray		startingAt: 1		count: requestByteArray size		waitForReplyIn: answer! !!MaClientSocket methodsFor: 'send' stamp: 'cmm 9/21/2005 12:36'!sendData: requestByteArray startingAt: startIndex count: numberOfBytes waitForReplyIn: answerByteArray	"Perform a synchronous TCP call, sending count bytes of requestByteArray from position startIndex to my peer socket and then wait up to my timeout period for a reply, which I'll put in answerByteArray.  If I run out of room in answerByteArray, I'll create you a new one and return it, otherwise you'll get your own answerByteArray back.  If communications are disrupted, I'll signal a MaNetworkError."	| answer retries |	retries := 0.	[ socket := Socket newTCP.	socket 		connectTo: hostAddress 		port: port ]		on: NetworkError		do: 			[ : error | 			retries < 10				ifTrue: 					[ MaNetworkNotification signal: 'Socket couldn''t connect, retrying.'.					(Delay forMilliseconds: 1000) wait.					retries := retries + 1.  					error retry ]				ifFalse: [ MaNetworkError signal: error messageText ] ].	self		loadByteArrayWith: requestByteArray		startingAt: startIndex		count: numberOfBytes.	[ self send: numberOfBytes + self headerSize ]		on: Error		do: [ : err |		(err messageText = 'a primitive has failed'		or: [ err class = NetworkError ]) 			ifTrue:				[ err resignalAs: (MaNetworkError new messageText: err messageText, ' while sending request.') ] ].	[ answer := self receiveInto: answerByteArray ]		on: NetworkError		do: [ : err | err resignalAs: (MaNetworkError new messageText: err messageText, ' while receiving response.') ].	socket closeAndDestroy: timeoutSeconds.	^ answer! !!MaClientSocket methodsFor: 'accessing' stamp: 'cmm 9/20/2002 15:10'!timeoutSeconds: anInteger	timeoutSeconds _ anInteger! !!MaCommitPackage commentStamp: 'cmm 3/8/2005 09:41' prior: 0!This class represents all of the changes made from a single client for a single transaction.!!MaCommitPackage class methodsFor: 'creation'!new	"Don't have unnecessarily large physicalSize.  Keep the work on the client."	^self new: 8! !!MaCommitPackage class methodsFor: 'creation'!new: anInteger	^super new setSize: anInteger! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 4/5/2005 21:37'!addLargeCollectionChanges: aMaLargeCollectionChanges using: aMagmaSession	"Add a copy of the changes instead of the originals because each serialization mutates the changes from first-class objects into oids."	self allLargeCollectionChanges add: aMaLargeCollectionChanges copyForSerialization.	"Make sure we get new objects that may only be referenced by a LargeCollection."	aMaLargeCollectionChanges		addNewAdditionsTo: self		using: aMagmaSession! !!MaCommitPackage methodsFor: 'building'!addObject: anObject	^objects add: anObject! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 4/5/2005 21:38'!allLargeCollectionChanges	^ allLargeCollectionChanges ifNil: [ allLargeCollectionChanges _ Set new ]! !!MaCommitPackage methodsFor: 'building'!allLargeCollectionChanges: aSet	allLargeCollectionChanges _ aSet! !!MaCommitPackage methodsFor: 'enumerate' stamp: 'cmm 4/5/2005 21:39'!allLargeCollectionChangesDo: aBlock	allLargeCollectionChanges ifNotNil: [ allLargeCollectionChanges do: aBlock ]! !!MaCommitPackage methodsFor: 'copying'!copyWithNewLargeCollectionChanges	^self copy		allLargeCollectionChanges: (self allLargeCollectionChanges collect: [ :each | each copy ])! !!MaCommitPackage methodsFor: 'testing'!hasNewIndexes	"Don't use conform: or detect: because it forces creation of a collection for	the new indexes."	self		allLargeCollectionChangesDo: [ :eachChanges | eachChanges hasAddedIndexes ifTrue: [ ^true ] ].	^false! !!MaCommitPackage methodsFor: 'testing' stamp: 'cmm 11/26/2002 22:18'!hasRemovedIndexes	self		allLargeCollectionChangesDo: [ :eachChanges | eachChanges hasRemovedIndexes ifTrue: [ ^true ] ].	^false! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 4/6/2005 18:03'!largeCollectionChangesFor: aMagmaLargeCollection	allLargeCollectionChanges ifNil: [ MagmaSoftwareError signal: 'no changes found' ].	^ allLargeCollectionChanges		detect: [ : each | each collection == aMagmaLargeCollection ]		ifNone: [ MagmaSoftwareError signal: 'no changes found' ]! !!MaCommitPackage methodsFor: 'actions'!newIndexesDo: twoArgBlock	"For all largeCollections that have had one or more indexes added on this	transaction, evaluate twoArgBlock.  The first argument is collection (or oid of	the colection if the receiver has serialized itself, the second is a collection of	the indexes."	self allLargeCollectionChangesDo:		[ :eachChanges |		eachChanges hasAddedIndexes			ifTrue:				[ twoArgBlock					value: eachChanges collection					value: eachChanges addedIndexes ] ]! !!MaCommitPackage methodsFor: 'actions'!newObjectsDo: aBlock	"This can only be used after the receiver has serialialized his objects	(via #serializeObjectsUsing:)."	| isRootBuffer |	"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."	isRootBuffer _ true.	objects buffersDo:		[ :each |		isRootBuffer			ifTrue:				[ isRootBuffer _ false ]			ifFalse:				[ (MaOidCalculator isOidForNewObject: each oid) ifTrue: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'accessing'!objects	^objects! !!MaCommitPackage methodsFor: 'actions' stamp: 'cmm 12/19/2002 23:25'!objectsDo: aBlock	objects isCollection		ifTrue:			[ objects do: aBlock ]		ifFalse:			[ | isRootBuffer |			"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."			isRootBuffer _ true.			objects buffersDo:				[ :each |				isRootBuffer ifTrue: [ isRootBuffer _ false ] ifFalse: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'actions'!persistentObjectsDo: aBlock	"This can only be used after the receiver has serialialized his objects	(via #serializeObjectsUsing:)."	| isRootBuffer |	"Skip the first buffer because that is the receivers objects OC itself, not part of any client objects."	isRootBuffer _ true.	objects buffersDo:		[ :each |		isRootBuffer			ifTrue:				[ isRootBuffer _ false ]			ifFalse:				[ (MaOidCalculator isOidForNewObject: each oid) ifFalse: [ aBlock value: each ] ] ]! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 3/27/2005 20:52'!removeObject: anObject	objects		remove: anObject		ifAbsent: [ "no problem" ]! !!MaCommitPackage methodsFor: 'actions' stamp: 'cmm 11/26/2002 22:14'!removedIndexesDo: twoArgBlock	"For all largeCollections that have had one or more indexes removed on this transaction, evaluate twoArgBlock.  The first argument is the collection (or oid of the collection if the receiver has serialized itself, the second is a collection of the indexes)."	self allLargeCollectionChangesDo:		[ :eachChanges |		eachChanges hasRemovedIndexes			ifTrue:				[ twoArgBlock					value: eachChanges collection					value: eachChanges removedIndexes ] ]! !!MaCommitPackage methodsFor: 'private' stamp: 'cmm 11/14/2002 21:35'!serializeLargeCollectionsChangesUsingCopyOf: aMaObjectSerializer	"The objects are serialized, now serialize the allLargeCollectionChanges of	the receiver."	| copiedSerializer |	copiedSerializer _ nil.	self allLargeCollectionChangesDo:		[ :eachChanges | 		copiedSerializer ifNil: [ copiedSerializer _ aMaObjectSerializer copyWithNewBuffer ].		eachChanges serializeUsing: copiedSerializer ]! !!MaCommitPackage methodsFor: 'building' stamp: 'cmm 4/20/2005 17:25'!serializeObjectsUsing: aMagmaSession	"Serialize my 'objects' into a MaSerializedGraphBuffer since the server does not deal with objects, just their buffers."	| mustReserialize serializer numberOfClassesBefore |	serializer _ aMagmaSession serializer.	numberOfClassesBefore _ serializer classIdManager numberOfClasses.	mustReserialize _ false.	[ objects _		serializer			serializeGraph: objects			do:				[ :each |				"Determine if class definition of each has changed."				(serializer classIdManager hasClassDefinitionFor: each maSerializationClass)					ifFalse:						[ mustReserialize _ true.						serializer classIdManager assimilateInImageDefinition: each maSerializationClass ].				"Look for any newly created LargeCollections.."				each maIsLargeCollection					ifTrue:						[ (aMagmaSession managesMagmaCollection: each)							ifFalse:								[ mustReserialize _ true.								aMagmaSession addLargeCollection: each ] ] ] ]		on: MaTraverseProxyNotification 		do:			[ : error | 			error proxy mutatingProxySession magmaId = aMagmaSession magmaId				ifTrue: [ error resume ]				ifFalse: [ MagmaUserError signal: 'Halting to protect you from yourself.  You should only share copies, not the actual instances, across repositories.' ] ].	self serializeLargeCollectionsChangesUsingCopyOf: serializer.	^mustReserialize or: [ serializer classIdManager numberOfClasses > numberOfClassesBefore ]! !!MaCommitPackage methodsFor: 'private' stamp: 'cmm 4/21/2002 23:11'!setSize: anInteger	objects _ IdentitySet new: anInteger! !!MaCommitPackage methodsFor: '*magma server' stamp: 'cmm 4/5/2005 21:34'!shouldServerRefresh	"Anytime a largeCollection domain object changes, the server should	refresh so we process all of the new large collections or their new	indexes."	^ allLargeCollectionChanges notNil	and: [ allLargeCollectionChanges anySatisfy: [ :each | each requiresServerRefresh ] ]! !!MaCommitPackage methodsFor: 'accessing' stamp: 'cmm 12/31/2002 00:21'!size	self maMarked: 'dev'.  "If you can get rid of ensurePreparedToAllocateNewOids:, then you should be able to get rid of this."	^objects size! !!MaCompiledMethodStorage class methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:12'!newFor: aCompiledMethod	^ self new		initializeFrom: aCompiledMethod ;		yourself! !!MaCompiledMethodStorage methodsFor: 'as yet unclassified' stamp: 'cmm 11/25/2004 23:34'!asCompiledMethod	| answer |	answer _ 		CompiledMethod 			newMethod: endPc - startPc + 1 + 4			header: header.	literals withIndexDo: 		[ : each : index |		answer			literalAt: index			put: each ]."	answer setSourcePointer: sourcePointer."  "<-- don't restore it, it could be wrong.""In fact..."sourcePointer > 0 ifTrue: [ answer zapSourcePointer ].	answer		replaceFrom: startPc		to: endPc		with: byteCodes		startingAt: 1.	self restoreLiterals: answer.	^ answer! !!MaCompiledMethodStorage methodsFor: 'as yet unclassified' stamp: 'cmm 2/22/2005 10:03'!cleanLiterals: aCompiledMethod	"Strip class-var objects from anArray (nil them out).  Class vars are not stored, but we will try to hook them up by name upon materialization."	| answer |	answer _ aCompiledMethod literals.	answer withIndexDo:		[ : eachLiteral : index |		(eachLiteral isVariableBinding		and: [ eachLiteral isSpecialWriteBinding not		and: [ eachLiteral key notNil		and: [ (Smalltalk includesKey: eachLiteral key) not ] ] ])			ifTrue:				[ answer at: index put: eachLiteral copy.				"nil out the global object, we will remap to it by name upon materialization (see restoreLiterals:)."				(answer at: index) value: nil ] ].	^ answer! !!MaCompiledMethodStorage methodsFor: 'as yet unclassified' stamp: 'cmm 5/2/2005 22:04'!initializeFrom: aCompiledMethod	className _ aCompiledMethod maMethodClass name.	literals _ self cleanLiterals: aCompiledMethod.	header _ aCompiledMethod header.	sourcePointer _ aCompiledMethod sourcePointer.	startPc _ aCompiledMethod initialPC.	endPc _ aCompiledMethod endPC.	byteCodes _ ByteArray new: endPc - startPc + 1.	byteCodes		replaceFrom: 1		to: byteCodes size		with: aCompiledMethod		startingAt: startPc! !!MaCompiledMethodStorage methodsFor: 'as yet unclassified' stamp: 'cmm 2/22/2005 10:05'!restoreLiterals: aCompiledMethod	"This method attempts to logically restore any reference to class-vars in aCompiledMethod.  Even though aCompiledMethod is not installed in the system, I saved its class and selector during serialization, now I can use that information to, if present, re-hook up the class variable up to the one in this image." 	aCompiledMethod literals withIndexDo:		[ : eachLiteral : index |		(eachLiteral isVariableBinding		and: [ eachLiteral isSpecialWriteBinding not ])			ifTrue:				[ | methodClass classVarNames classBinding |				methodClass _ Smalltalk at: className ifAbsent: [ nil ].				classBinding _ (eachLiteral key notNil and: [ methodClass notNil and: [ methodClass allClassVarNames includes: eachLiteral key ] ])					ifTrue: [ methodClass bindingOf: eachLiteral key ]					ifFalse:						[ "Ok, not a class-var (at least not any more), check to see if its a Smalltalk global."						(eachLiteral key notNil and: [ (Smalltalk includesKey: eachLiteral key) not ])							ifTrue:								[ ^ MaObjectSerializationWarning signal: 'Warning, cannot remap ', className, '>>''', eachLiteral key asString, ''' because that global is no longer defined.  nil will be substituted.' ].						eachLiteral ].				aCompiledMethod					literalAt: index					put: classBinding ] ]! !!MaDictionary commentStamp: 'cmm 12/28/2005 12:50' prior: 0!I am identical to a Dictionary but a lot faster when my size grows beyond 4K elements.  Squeak uses a 12-bit identity hash for its object identity, causing lots of hash collisions once you get more than 4K (2 raisedTo: 12) objects in it.  As this script demonstrates, I am comparable at adding, accessing and replacing, but much faster with removing.| sd md r |Transcript clear.r _ (1 to: 15500) collect: [ :e | Object new ].r _ r shuffled.sd _ WeakIdentityKeyDictionary new.md _ MaWeakIdentityKeyDictionary new.Transcript cr; show: 'time to add to sd: ', ([ r do: [ :each | sd at: each put: each ] ] timeToRun) printString.Transcript cr; show: 'time to add to md: ', ([ r do: [ :each | md at: each put: each ] ] timeToRun) printString.r_r shuffled.Transcript cr; show: 'time to access to sd: ', ([ r do: [ :each | sd at: each ] ] timeToRun) printString.Transcript cr; show: 'time to access to md: ', ([ r do: [ :each | md at: each ] ] timeToRun) printString.r _ r shuffled.Transcript cr; show: 'time to replace to sd: ', ([ r do: [ :each | sd at: each put: each ] ] timeToRun) printString.Transcript cr; show: 'time to replace to md: ', ([ r do: [ :each | md at: each put: each ] ] timeToRun) printString.r _ r shuffled.Transcript cr; show: 'time to remove 300 from sd: ', ([ (r copyFrom: 1 to: 300) do: [ :each | sd removeKey: each ] ] timeToRun) printString.Transcript cr; show: 'time to remove 300 from md: ', ([ (r copyFrom: 1 to: 300) do: [ :each | md removeKey: each ] ] timeToRun) printString.!!MaDictionary class methodsFor: 'creation' stamp: 'cmm 12/27/2002 10:09'!new	^self new: 8! !!MaDictionary class methodsFor: 'creation' stamp: 'cmm 12/13/2002 14:28'!new: anInteger	^super new capacity: anInteger; yourself! !!MaDictionary methodsFor: 'adding' stamp: 'cmm 12/12/2002 17:10'!add: anAssociation	self		removeKey: anAssociation key		ifAbsent: [ "do nothing" ].	self qualifyingDict add: anAssociation! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/22/2002 18:26'!associationsDo: aBlock	dicts do: [ :each | each associationsDo: aBlock ]! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 16:43'!at: anObject	^self		at: anObject		ifAbsent: [ self errorKeyNotFound ]! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/13/2002 14:34'!at: anObject ifAbsent: aBlock	| uniqueObject |	uniqueObject _ ''.	dicts do:		[ :each |		| result |		result _ each			at: anObject			ifAbsent: [ uniqueObject ].		result == uniqueObject ifFalse: [ ^result ] ].	^aBlock value! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 16:44'!at: key ifAbsentPut: aBlock	^self		at: key		ifAbsent:			[ self 				at: key 				put: aBlock value ]! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 6/8/2004 12:51'!at: key put: anObject	key ifNil: [ self error: 'nil cannot be used as a key to a Dictionary.' ].	dicts do:		[ :each |		(each includesKey: key) ifTrue: [ ^each at: key put: anObject ] ].	^self qualifyingDict		at: key		put: anObject! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/27/2002 09:57'!capacity: anInteger	| numberOfDicts |	numberOfDicts _ anInteger // self criticalSize.	dicts _ OrderedCollection new: numberOfDicts.	numberOfDicts timesRepeat: [ dicts add: (self squeakDictionaryClass new: self criticalSize) ].	anInteger \\ self criticalSize > 0		ifTrue:			[ dicts add: (self squeakDictionaryClass new: anInteger \\ self criticalSize) ]! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/12/2002 17:17'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection _ OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MaDictionary methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:04'!copy	^ self copy postCopy! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/27/2002 10:05'!criticalSize	"Since the Squeak Set allocates about 4/3rd's extra space for future growth, we have the potential to grow a little out of its efficiency range.  Compensate."	^4096*3//4! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 2/5/2003 20:47'!detect: aBlock	^self		detect: aBlock		ifNone: [ self error: 'not in MaDictionary' ]! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 2/5/2003 20:47'!detect: aBlock ifNone: notFoundBlock	self do: [ :each | (aBlock value: each) ifTrue: [ ^each ] ].	^notFoundBlock value! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/12/2002 16:58'!do: aBlock	dicts do: [ :each | each do: aBlock ]! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 16:43'!errorKeyNotFound	self error: 'key not found'! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/13/2002 14:03'!finishCopy	dicts _ dicts collect: [ :each | each copy ]! !!MaDictionary methodsFor: 'testing' stamp: 'cmm 12/12/2002 17:14'!includes: anObject	self do: [:each | anObject = each ifTrue: [^true]].	^false! !!MaDictionary methodsFor: 'testing' stamp: 'cmm 12/12/2002 17:14'!includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."		self at: key ifAbsent: [^false].	^true! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 16:52'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/25/2002 23:28'!keysAndValuesDo: twoArgBlock	dicts do: [ :each | each keysAndValuesDo: twoArgBlock ]! !!MaDictionary methodsFor: 'removing' stamp: 'cmm 12/12/2002 17:06'!keysAndValuesRemove: twoArgBlock	dicts do: [ :each | each keysAndValuesRemove: twoArgBlock ]! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/12/2002 16:52'!keysDo: aBlock	dicts do: [ :each | each keysDo: aBlock ]! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 17:12'!maAllKeysAtValue: anObject	| aCollection |	aCollection := OrderedCollection new.	self keysAndValuesDo: [ :key :value | value = anObject ifTrue: [ aCollection add: key ] ].	^aCollection! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/13/2002 14:33'!maAt: anObject ifPresent: oneArgBlock ifAbsent: zeroArgBlock	| current uniqueObject |	uniqueObject _ ''.	^(current := self		at: anObject		ifAbsent: [ uniqueObject ]) == uniqueObject			ifTrue: [ zeroArgBlock value ]			ifFalse: [ oneArgBlock value: current ]! !!MaDictionary methodsFor: 'testing' stamp: 'cmm 12/12/2002 17:15'!maIsHashedCollection	^true! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 17:16'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| count |	count _ 0.	self do: [:each | anObject = each ifTrue: [count _ count + 1]].	^count! !!MaDictionary methodsFor: 'copying' stamp: 'cmm 5/2/2005 22:13'!postCopy	super postCopy.	dicts := dicts copy.	self finishCopy! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 23:20'!qualifyingDict	^dicts		detect: [ :each | each size < self criticalSize ]		ifNone: [ dicts addFirst: self squeakDictionaryClass new ]! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 17:15'!rehash	dicts do: [ :each | each rehash ]! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 1/9/2003 00:40'!reject: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a	new dictionary, only those associations for which aBlock evaluates to	true."	| newCollection |	newCollection _ self species new.	self associationsDo: 		[:each | 		(aBlock value: each value) ifFalse: [newCollection add: each]].	^newCollection! !!MaDictionary methodsFor: 'removing' stamp: 'cmm 12/12/2002 17:04'!remove: anObject	self shouldNotImplement! !!MaDictionary methodsFor: 'removing' stamp: 'cmm 12/12/2002 17:04'!remove: anObject ifAbsent: exceptionBlock	self shouldNotImplement! !!MaDictionary methodsFor: 'removing' stamp: 'cmm 12/12/2002 17:05'!removeKey: key 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self removeKey: key ifAbsent: [self errorKeyNotFound]! !!MaDictionary methodsFor: 'removing' stamp: 'cmm 12/13/2002 14:34'!removeKey: key ifAbsent: aBlock	| uniqueObject |	uniqueObject _ ''.	dicts do:		[ :each |		| removed |		removed _ each			removeKey: key			ifAbsent: [ uniqueObject ].		removed == uniqueObject ifFalse: [ ^removed ] ].	^aBlock value! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/12/2002 17:09'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a	new dictionary, only those associations for which aBlock evaluates to	true."	| newCollection |	newCollection _ self species new.	self associationsDo: 		[:each | 		(aBlock value: each value) ifTrue: [newCollection add: each]].	^newCollection! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 22:38'!size	^dicts		inject: 0		into: [ :sum :each | sum + each size ]! !!MaDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 16:48'!squeakDictionaryClass	^Dictionary! !!MaDictionary methodsFor: 'accessing' stamp: 'cmm 12/12/2002 17:11'!values	"Answer a Collection containing the receiver's values."	| out |	out _ WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!MaDictionary methodsFor: 'enumerating' stamp: 'cmm 12/12/2002 16:57'!valuesDo: aBlock	dicts do: [ :each | each valuesDo: aBlock ]! !!MaWeakIdentityKeyDictionary methodsFor: 'private' stamp: 'cmm 1/12/2003 21:26'!finalizeValues	dicts do: [ :e | e finalizeValues ]! !!MaWeakIdentityKeyDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 22:27'!squeakDictionaryClass	^WeakIdentityKeyDictionary! !!MaWeakValueDictionary methodsFor: 'private' stamp: 'cmm 12/12/2002 22:27'!squeakDictionaryClass	^WeakValueDictionary! !!MaFixedLengthRecord class methodsFor: 'as yet unclassified' stamp: 'cmm 5/19/2005 11:05'!new: anInteger	^ self new		byteArray: (ByteArray new: anInteger) ;		yourself! !!MaFixedLengthRecord methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:52'!byteArray	^ byteArray! !!MaFixedLengthRecord methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:52'!byteArray: aByteArray	byteArray _ aByteArray! !!MaHashIndexRecord commentStamp: 'cmm 4/28/2005 21:25' prior: 0!keySize and valueSize are specified in bits.entrySize is in bytes.!!MaHashIndexRecord class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!keySize: keyBits valueSize: valueBits numberOfSlots: entrySizeInteger	^ self new		keySize: keyBits		valueSize: valueBits		numberOfSlots: entrySizeInteger ;		postInitialize ;		yourself! !!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 12/6/2002 00:05'!addAnomaliesTo: aDictionary usingParent: parentRecord	| originalCount |	originalCount _ aDictionary size.	self		addChildCountAnomaliesTo: aDictionary		using: parentRecord.	^aDictionary size > originalCount! !!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 12/6/2002 00:04'!addChildCountAnomaliesTo: aDictionary using: parentRecord	| bax parentNumberOfChildren isCorrect |	bax _ self baxInParent: parentRecord for: self.	parentNumberOfChildren _ (parentRecord numberOfChildrenAtByteArrayIndex: bax).	isCorrect _ (self lowKey = self highKey or: [ self numberOfChildren = 0 ])		ifTrue: 			[ "it's possible for the record not to have an entry in the parent under this condition."			(parentRecord hasEntryAtByteArrayIndex: bax)				ifTrue: [ (parentNumberOfChildren - 1) = self numberOfChildren ]				ifFalse: [ parentNumberOfChildren = self numberOfChildren ] ]		ifFalse:			[ (parentNumberOfChildren - 1) = self numberOfChildren ].	isCorrect ifFalse:		[ (aDictionary			at: 'number of children discrepency'			ifAbsentPut: [ OrderedCollection new ]) add: { parentRecord.  self } ]! !!MaHashIndexRecord methodsFor: 'printing'!allNumberOfChildren	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self numberOfChildrenAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/1/2006 18:47'!atKey: keyInteger put: valueInteger 	"The receiver has been verified for some available slot for keyInteger."	self 		eligibleByteArrayIndexesFor: keyInteger		reverseDo: 			[ : index | 			(self hasSlotAvailableAtByteArrayIndex: index) ifTrue: 				[ self 					keyAtByteArrayIndex: index					put: keyInteger.				self 					valueAtByteArrayIndex: index					put: valueInteger.				self occupySlotAtByteArrayIndex: index.				^ index ] ].	MaSoftwareError signal: 'I should have been verified for an available slot.'! !!MaHashIndexRecord methodsFor: 'SUnit tests' stamp: 'cmm 11/29/2002 23:39'!baxInParent: parentRecord for: childRecord	parentRecord		byteArrayIndexesFrom: 0		do:			[ :bax |			(parentRecord recordNumberAtByteArrayIndex: bax) = childRecord recordNumber				ifTrue: [ ^bax ] ].	self error: 'I am not child of parentRecord'! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 7/1/2005 17:00'!baxMap	| map |	map _ OrderedCollection new.	self		byteArrayIndexesFrom: 0		do: [ :each | map add: (self slotIndexForBax: each) -> each ].	^map asArray! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 3/30/2005 10:25'!beFrom: lowKeyInteger to: highKeyInteger	self		lowKey: lowKeyInteger;		highKey: highKeyInteger.	self setLowKey: lowKeyInteger highKey: highKeyInteger! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 7/1/2005 17:09'!beZoomedInToward: keyInteger from: aMaHashIndexRecord	"Set the receivers low and highIndex to the correct range that can	accomodate the index where keyInteger belongs in aMaHashIndexRecord."	| index |	index _ aMaHashIndexRecord slotIndexFor: keyInteger.	self		beFrom: (aMaHashIndexRecord lowestKeyAtIndex: index)		to: (aMaHashIndexRecord highestKeyAtIndex: index)! !!MaHashIndexRecord methodsFor: 'accessing'!bufferSize	^byteArray size! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/22/2002 00:12'!byteArrayIndexContainingGlobalIndex: anInteger base: baseInteger	"baseInteger is 0-based."	| count |	count _ baseInteger.	self		byteArrayIndexesFrom: 0		do:			[ :each |			count _ count + (self numberOfChildrenAtByteArrayIndex: each).			count >= anInteger ifTrue: [ ^each ] ].	^nil! !!MaHashIndexRecord methodsFor: 'private'!byteArrayIndexFor: entryIndex	^entryIndex * entrySize + self headerSize! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/27/2002 14:55'!byteArrayIndexOfLowestEntry	"Answers nil if no entries on this record."	self		byteArrayIndexesFrom: 0		do:			[ :each | (self hasEntryAtByteArrayIndex: each) ifTrue: [ ^each ] ].	^nil! !!MaHashIndexRecord methodsFor: 'actions' stamp: 'cmm 7/1/2005 16:51'!byteArrayIndexesFrom: startingEntryIndex do: oneArgBlock	self		byteArrayIndexesFrom: startingEntryIndex		to: numberOfSlots - 1		do: oneArgBlock! !!MaHashIndexRecord methodsFor: 'actions'!byteArrayIndexesFrom: startingEntryIndex to: endingEntryIndex do: oneArgBlock	(self byteArrayIndexFor: startingEntryIndex)		to: (self byteArrayIndexFor: endingEntryIndex)		by: entrySize		do: oneArgBlock! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 5/18/2005 10:11'!cacheAttributes	self 		setLowKey: self lowKey		highKey: self highKey! !!MaHashIndexRecord methodsFor: 'testing'!canAdd: keyInteger	self		eligibleByteArrayIndexesFor: keyInteger		do: [ :index | (self hasSlotAvailableAtByteArrayIndex: index) ifTrue: [ ^true ] ].	^false! !!MaHashIndexRecord methodsFor: 'testing'!canHoldDuplicateKeys	^canHoldDuplicateKeys! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/1/2006 18:11'!controlAtByteArrayIndex: anInteger	^ byteArray 		maUint: self sizeOfControlFieldInBits		at: anInteger + self controlEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/1/2006 18:12'!controlAtByteArrayIndex: index put: anInteger	^ byteArray 		maUint: self sizeOfControlFieldInBits		at: index + self controlEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 8/30/2006 21:08'!controlEntryOffset	^ 0! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/10/2006 20:54'!decrementNumberOfChildrenAtByteArrayIndex: anInteger	| currentNumberOfChildren |	currentNumberOfChildren _ self numberOfChildrenAtByteArrayIndex: anInteger.	currentNumberOfChildren = 0 ifTrue: [MaSoftwareError signal].	self		numberOfChildrenAtByteArrayIndex: anInteger		put: currentNumberOfChildren - 1! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 11/30/2002 23:51'!decrementNumberOfChildrenAtKey: keyInteger	self decrementNumberOfChildrenAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 3/9/2004 23:53'!dumpEntries	self dumpEntriesTo: Transcript! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 9/10/2006 00:36'!dumpEntriesTo: aStream 	self 		byteArrayIndexesFrom: 0		do: 			[ : eachBax | 			(self numberOfChildrenAtByteArrayIndex: eachBax) > 0 ifTrue: 				[ | x |				x _ self slotIndexForBax: eachBax.				aStream					cr ;					space ;					space ;					maPrint: 'x:' ;					maPrint: x ;					maPrint: ' [' ;					maPrint: (self lowestKeyAtIndex: x) ;					maPrint: '..' ;					maPrint: (self highestKeyAtIndex: x) ;					maPrint: ']' ;					maPrint: ' bx:' ;					maPrint: (self byteArrayIndexFor: x).				(self hasSlotAvailableAtByteArrayIndex: eachBax) ifTrue: [ aStream nextPutAll: ' *empty slot* ' ].				aStream					maPrint: ' k:' ;					maPrint: (self keyAtByteArrayIndex: eachBax) ;					maPrint: ' v:' ;					maPrint: (self valueAtByteArrayIndex: eachBax) ;					maPrint: ' r:' ;					maPrint: (self recordNumberAtByteArrayIndex: eachBax) ;					maPrint: ' c:' ;					maPrint: (self numberOfChildrenAtByteArrayIndex: eachBax) ;					endEntry ] ]! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 4/28/2005 21:47'!dumpStructureTo: aStream	self		maPrintAttributes: #(			recordNumber lowKey highKey canHoldDuplicateKeys keys recordNumbers values			allNumberOfChildren possibleKeys)		on: aStream! !!MaHashIndexRecord methodsFor: 'actions'!eligibleByteArrayIndexesFor: keyInteger do: oneArgBlock	(self lowestByteArrayIndexFor: keyInteger)		to: (self highestByteArrayIndexFor: keyInteger)		by: entrySize		do: [ :index | oneArgBlock value: index ]! !!MaHashIndexRecord methodsFor: 'actions' stamp: 'cmm 3/10/2004 01:00'!eligibleByteArrayIndexesFor: keyInteger reverseDo: oneArgBlock	(self highestByteArrayIndexFor: keyInteger)		to: (self lowestByteArrayIndexFor: keyInteger)		by: 0-entrySize		do: [ :index | oneArgBlock value: index ]! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 3/12/2004 15:37'!entryWeight	^ entryWeight! !!MaHashIndexRecord methodsFor: 'testing'!hasChildAtByteArrayIndex: byteArrayIndex	^(self recordNumberAtByteArrayIndex: byteArrayIndex) > 0! !!MaHashIndexRecord methodsFor: 'testing' stamp: 'cmm 12/1/2002 21:44'!hasChildAtHighestByteArrayIndexForBax: byteArrayIndex	^(self recordNumberAtHighestByteArrayIndexForBax: byteArrayIndex) > 0! !!MaHashIndexRecord methodsFor: 'testing'!hasEntryAtByteArrayIndex: anInteger	^(self hasSlotAvailableAtByteArrayIndex: anInteger) not! !!MaHashIndexRecord methodsFor: 'testing'!hasEntryForKey: keyInteger	"Answer whether keyInteger resides in an entry of the receiver."	self		eligibleByteArrayIndexesFor: keyInteger		do:			[ :index |			((self hasEntryAtByteArrayIndex: index)				and: [ (self keyAtByteArrayIndex: index) = keyInteger ])					ifTrue:						[ ^true ] ].	^false! !!MaHashIndexRecord methodsFor: 'testing' stamp: 'cmm 9/1/2006 17:57'!hasSlotAvailableAtByteArrayIndex: anInteger	^ (self controlAtByteArrayIndex: anInteger) maIsBitClear: self slotFilledControlBit! !!MaHashIndexRecord methodsFor: 'private'!headerSize	"Low and high keys.	^(keySize / 8) * 2  simplified to / 4 for max performance."	^keySize / 4! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!highKey	^byteArray		maUint: keySize		at: keySize / 8! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!highKey: anInteger	^byteArray		maUint: keySize		at: (keySize / 8)		put: anInteger! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:12'!highestByteArrayIndexFor: keyInteger	"This will vary from the lowestByteArrayIndexFor: keyInteger only when the receiver canHoldDuplicateKeys."	^ self byteArrayIndexFor: (self highestSlotIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:00'!highestByteArrayIndexForAnyKeyAt: byteArrayIndex	"this is for records that canHoldDuplicateKeys when we need to find the next child record number, since that is stored at the highestByteArrayIndexFor: that key."	^self highestByteArrayIndexFor: (self lowestKeyAtIndex: (self slotIndexForBax: byteArrayIndex))! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 3/12/2004 10:51'!highestKeyAtIndex: anInteger	^canHoldDuplicateKeys		ifTrue:			[ self lowestKeyAtIndex: anInteger ]		ifFalse:			[ (self lowestKeyAtIndex: anInteger + 1) - 1 ]! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 3/11/2004 21:19'!highestPossibleKey	^ (2 raisedTo: keySize) - 1! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 17:11'!highestSlotIndexFor: keyInteger	^ canHoldDuplicateKeys		ifTrue:			[ (self slotIndexFor: keyInteger + 1) - 1 ]		ifFalse:			[ self slotIndexFor: keyInteger ]! !!MaHashIndexRecord methodsFor: 'building'!incrementNumberOfChildrenAtByteArrayIndex: anInteger	| currentNumberOfChildren |	currentNumberOfChildren _ self numberOfChildrenAtByteArrayIndex: anInteger.	self		numberOfChildrenAtByteArrayIndex: anInteger		put: currentNumberOfChildren + 1! !!MaHashIndexRecord methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:03'!independentCopy	^ self copy postIndependentCopy! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!keyAtByteArrayIndex: anInteger	^byteArray		maUint: keySize		at: anInteger + self keyEntryOffset! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!keyAtByteArrayIndex: index put: anInteger	^byteArray		maUint: keySize		at: index + self keyEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'accessing'!keyAtHighestSlotFor: keyInteger	^self keyAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:13'!keyAtSlotIndex: anInteger	^ self keyAtByteArrayIndex: (self byteArrayIndexFor: anInteger)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 4/28/2005 22:44'!keyEntryOffset	^ self recordNumberEntryOffset + self sizeOfRecordNumber! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 3/11/2004 21:53'!keySize	^ keySize! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/1/2006 18:29'!keySize: keyBits valueSize: valueBits numberOfSlots: numberOfSlotsInteger	keySize _ keyBits.	valueSize _ valueBits.	numberOfSlots _ numberOfSlotsInteger.	"Each entry consists of:  value, record number, key, number of child entries."	entrySize _ self sizeOfControlFieldInBytes + (valueSize/8) + self sizeOfRecordNumber + ((keySize / 8) * 2).	byteArray _ ByteArray new: self headerSize + (entrySize * numberOfSlotsInteger)! !!MaHashIndexRecord methodsFor: 'printing'!keys	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self keyAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!lowKey	^byteArray		maUint: keySize		at: 0! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 1/27/2003 23:57'!lowKey: anInteger	^byteArray		maUint: keySize		at: 0		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 17:08'!lowestByteArrayIndexFor: keyInteger	^self byteArrayIndexFor: (self slotIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 16:51'!lowestKeyAtIndex: entryIndex	"Answer the lowest-possible key that can be stored at entryIndex."	^ lowKey + (entryIndex * entryWeight // numberOfSlots)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 12/29/2005 22:59'!lowestPossibleKey	^ 0! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 9/10/2006 14:17'!maPrintAbbreviatedOn: aStream	self		maPrintAttributes: #(recordNumber lowKey highKey entryWeight possibleKeys canHoldDuplicateKeys)		on: aStream.	aStream cr; maPrint: 'entries:'.	self dumpEntriesTo: aStream! !!MaHashIndexRecord methodsFor: 'accessing'!numberOfChildren	| total |	total _ 0.	self		byteArrayIndexesFrom: 0		do: [ :index | total _ total + (self numberOfChildrenAtByteArrayIndex: index) ].	^total! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 1/27/2003 23:51'!numberOfChildrenAtByteArrayIndex: anInteger	^byteArray		maUint: keySize		at: anInteger + self numberOfChildrenEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 1/27/2003 23:57'!numberOfChildrenAtByteArrayIndex: index put: anInteger	^byteArray		maUint: keySize		at: index + self numberOfChildrenEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 17:08'!numberOfChildrenBefore: keyInteger	| lastByteArrayIndex entryIndex totalInSlotsBeforeKey |	entryIndex _ self slotIndexFor: keyInteger.	lastByteArrayIndex _ self byteArrayIndexFor: entryIndex.	totalInSlotsBeforeKey _ self numberOfChildrenBeforeByteArrayIndex: lastByteArrayIndex.	^((self keyAtByteArrayIndex: lastByteArrayIndex) < keyInteger		and: [ self hasEntryAtByteArrayIndex: lastByteArrayIndex ])			ifTrue:				[ (lastByteArrayIndex = (self highestByteArrayIndexFor: keyInteger))					ifTrue: [ totalInSlotsBeforeKey + 1 ]					ifFalse: [ totalInSlotsBeforeKey + (self numberOfChildrenAtByteArrayIndex: lastByteArrayIndex) ] ]			ifFalse: [ totalInSlotsBeforeKey ]! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 11/22/2002 00:13'!numberOfChildrenBeforeByteArrayIndex: anInteger	| total |	total _ 0.	self		byteArrayIndexesFrom: 0		do:			[ :each |			each = anInteger ifTrue: [ ^total ].			total _ total + (self numberOfChildrenAtByteArrayIndex: each) ].	self error: anInteger printString, ' is not a valid byteArrayIndex.'! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 12/30/2002 21:20'!numberOfChildrenEntryOffset	^self keyEntryOffset + (keySize / 8)! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 16:51'!numberOfSlots	^ numberOfSlots! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/1/2006 18:45'!occupySlotAtByteArrayIndex: anInteger 	| controlValue |	controlValue _ self controlAtByteArrayIndex: anInteger.	self 		controlAtByteArrayIndex: anInteger		put: (controlValue maBitSet: self slotFilledControlBit)! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 3/14/2004 13:43'!populateFrom: aMaHashIndexRecord	byteArray		replaceFrom: 1		to: byteArray size		with: aMaHashIndexRecord byteArray.	recordNumber _ aMaHashIndexRecord recordNumber.	self 		setLowKey: aMaHashIndexRecord primLowKey 		highKey: aMaHashIndexRecord primHighKey! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 7/1/2005 16:51'!possibleKeys	| answer |	answer _ WriteStream on: (String new: numberOfSlots * 2).	0		to: numberOfSlots - 1		do:			[ : index |  | low high |			low _ self lowestKeyAtIndex: index.			high _ self highestKeyAtIndex: index.			answer nextPutAll: ' | '.			low = high				ifTrue:					[ answer maPrint: low ]				ifFalse:					[ answer						maPrint: low;						maPrint: '..';						maPrint: high ] ].	^ answer contents! !!MaHashIndexRecord methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:03'!postIndependentCopy	byteArray _ byteArray copy! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 12/29/2005 23:00'!postInitialize	self		beFrom: self lowestPossibleKey 		to: self highestPossibleKey! !!MaHashIndexRecord methodsFor: 'accessing'!primHighKey	^highKey! !!MaHashIndexRecord methodsFor: 'accessing'!primLowKey	^lowKey! !!MaHashIndexRecord methodsFor: 'accessing'!recordNumber	^recordNumber! !!MaHashIndexRecord methodsFor: 'building'!recordNumber: anInteger	recordNumber _ anInteger! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 1/27/2003 23:51'!recordNumberAtByteArrayIndex: anInteger	^byteArray 		maUint: 32		at: anInteger + self recordNumberEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 1/27/2003 23:58'!recordNumberAtByteArrayIndex: index put: anInteger	^byteArray		maUint: 32		at: index + self recordNumberEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 12/1/2002 20:57'!recordNumberAtHighestByteArrayIndexForBax: anInteger	^self recordNumberAtByteArrayIndex: (self highestByteArrayIndexForAnyKeyAt: anInteger)! !!MaHashIndexRecord methodsFor: 'building'!recordNumberAtSlotForKey: keyInteger put: recordNumberInteger	self		recordNumberAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)		put: recordNumberInteger! !!MaHashIndexRecord methodsFor: 'accessing'!recordNumberCloserTo: keyInteger	^self recordNumberAtByteArrayIndex: (self highestByteArrayIndexFor: keyInteger)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 8/30/2006 21:08'!recordNumberEntryOffset	^ self valueEntryOffset + (valueSize/8 "bits")! !!MaHashIndexRecord methodsFor: 'printing'!recordNumbers	"This is intended to be used only for printing!!"	^(self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ :index | self recordNumberAtByteArrayIndex: index ]! !!MaHashIndexRecord methodsFor: 'building' stamp: 'cmm 9/10/2006 20:56'!removeKey: keyInteger withValue: valueInteger 	self 		eligibleByteArrayIndexesFor: keyInteger		do: 			[ : each | 			((self keyAtByteArrayIndex: each) = keyInteger 			and: [ (self valueAtByteArrayIndex: each) = valueInteger			and: [ self hasEntryAtByteArrayIndex: each ] ]) ifTrue: 				[ self					vacateSlotAtByteArrayIndex: each ;					decrementNumberOfChildrenAtByteArrayIndex: each.				^ each ] ].	^ nil! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 7/1/2005 16:51'!setLowKey: lowKeyInteger highKey: highKeyInteger	lowKey _ self lowKey.	highKey _ self highKey.	canHoldDuplicateKeys _ (highKey - lowKey + 1) < numberOfSlots.	entryWeight _ highKey - lowKey + 1! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 8/30/2006 21:17'!sizeOfControlFieldInBits	^ 8! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 8/30/2006 21:17'!sizeOfControlFieldInBytes	^ 1! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 12/30/2002 21:35'!sizeOfRecordNumber	^4! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/1/2006 17:39'!slotFilledControlBit	"Bit #1 of the  1-byte control field is used to mark whether a particular slot is filled or empty."	^ 1! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 8/17/2005 19:18'!slotIndexFor: keyInteger	"The lowest slot index in which keyInteger can reside."	^ (keyInteger - lowKey) * numberOfSlots // entryWeight! !!MaHashIndexRecord methodsFor: 'accessing' stamp: 'cmm 7/1/2005 16:59'!slotIndexForBax: anInteger	"Bax means 'byteArrayIndex'."	^(anInteger - self headerSize) / entrySize! !!MaHashIndexRecord methodsFor: 'debugging' stamp: 'cmm 3/11/2004 21:41'!structure	^ String streamContents: [ : stream | self dumpStructureTo: stream ]! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 9/1/2006 18:45'!vacateSlotAtByteArrayIndex: anInteger 	| controlValue |	controlValue _ self controlAtByteArrayIndex: anInteger.	self 		controlAtByteArrayIndex: anInteger		put: (controlValue maBitClear: self slotFilledControlBit)! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 4/28/2005 21:44'!valueAtByteArrayIndex: anInteger	^ byteArray 		maUint: valueSize		at: anInteger + self valueEntryOffset! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 4/28/2005 21:44'!valueAtByteArrayIndex: index put: anInteger	^ byteArray		maUint: valueSize		at: index + self valueEntryOffset		put: anInteger! !!MaHashIndexRecord methodsFor: 'private' stamp: 'cmm 8/30/2006 21:17'!valueEntryOffset	^ self controlEntryOffset + self sizeOfControlFieldInBytes! !!MaHashIndexRecord methodsFor: 'printing' stamp: 'cmm 4/28/2005 21:52'!values	"This is intended to be used only for printing!!"	^ (self headerSize		to: byteArray size - 1		by: entrySize)			collect: [ : index | self valueAtByteArrayIndex: index ]! !!MaClassDefinition class methodsFor: 'creation' stamp: 'cmm 6/16/2004 11:26'!className: aSymbol	^(super className: aSymbol)		initializeFrom: (Smalltalk classNamed: aSymbol) ;		yourself! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 12/19/2002 21:45'!allInstVarNames	^instVarNames! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 1/26/2005 13:06'!allSuperclassDefinitionsDo: oneArgBlock	"Value oneArgBlock with each of my superclass-definitions, in turn."	superclassDefinition ifNotNil: [ superclassDefinition withAllSuperclassDefinitionsDo: oneArgBlock ]! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:38'!classInstanceVariablesString	^ self stringForVariables: classInstVarNames! !!MaClassDefinition methodsFor: 'building' stamp: 'cmm 10/13/2004 23:52'!className: newClassName	self className ifNotNil: [ aliases add: self className ].	super className: newClassName! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:37'!classVariablesString	^ self stringForVariables: classVarNames! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 3/8/2005 13:51'!createClassUsing: aMaObjectSerializer	| superClass |	superClass _ self superclassDefinition ensureClassUsing: aMaObjectSerializer.	^ SystemChangeNotifier uniqueInstance doSilently:		[ ((ClassBuilder new)			name: self className			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category)						ifNotNilDo:				[ : class |				aMaObjectSerializer classIdManager					idOfClass: class					is: self id.				class class instanceVariableNames: self classInstanceVariablesString.				class hasComment					ifTrue: 						[ class 							classComment: comment 							stamp: commentStamp ].				aMaObjectSerializer classIdManager refreshInImageDefinition: class.				class ] ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 10/27/2004 23:34'!ensureClassUsing: aMaObjectSerializer	^ self isDefined		ifTrue: [ self classObject ]		ifFalse: [ self createClassUsing: aMaObjectSerializer ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 10/13/2004 16:44'!hasSameDefinitionAs: aClassOrMaClassDefinition	^ self allInstVarNames maMatchesElementsOf: aClassOrMaClassDefinition allInstVarNames! !!MaClassDefinition methodsFor: 'converting' stamp: 'cmm 6/16/2004 22:40'!indexOfInstVarCorrespondingTo: instVarIndex of: anotherMaClassDefinition	"Answer the index of the instVar in me that corresponds to the one at instVarIndex in anotherMaClassDefinition."	self == anotherMaClassDefinition ifTrue: [ ^ instVarIndex ].	"different versions, determine if instVarIndex refers to a named or indexed var"	^ instVarIndex > anotherMaClassDefinition allInstVarNames size		ifTrue:			[ "indexed inst var" 			self allInstVarNames size + (instVarIndex - anotherMaClassDefinition allInstVarNames size) ]		ifFalse:			[ "find the instVar with the same name."			self allInstVarNames				indexOf: (anotherMaClassDefinition allInstVarNames at: instVarIndex) ]! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 10/13/2004 23:50'!initialize	super initialize.	self version: 0.	aliases _ OrderedCollection new! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 6/10/2004 23:43'!initializeFrom: aClass	self globalName: aClass name.	instVarNames _ aClass allInstVarNames.	classVarNames _ aClass classVarNames.	poolDictionaryNames _ aClass poolDictionaryNames.	classInstVarNames _ aClass class instVarNames.	category _ aClass category.	type _ aClass typeOfClass.	comment _ aClass organization classComment asString.	commentStamp _ aClass organization commentStamp! !!MaClassDefinition methodsFor: 'building' stamp: 'cmm 6/11/2004 00:33'!initializeSuperclassDefinitionUsing: aMaClassIdManager	| superclassDefinitions |	superclassDefinitions _ aMaClassIdManager classDefinitionsForClass: self classObject superclass.	superclassDefinition _		superclassDefinitions			detect: [ : each | each hasSameDefinitionAs: self classObject superclass ]			ifNone: [ aMaClassIdManager inImageDefinition: self classObject superclass ]! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 10/13/2004 13:03'!instanceVariablesString	^ self stringForVariables: (instVarNames copyWithoutAll: superclassDefinition allInstVarNames)! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 6/8/2004 15:58'!isDefined	^ Smalltalk hasClassNamed: self className! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 10/13/2004 23:53'!isKnownAs: className	^ self name = className	or: [ aliases includes: className ]! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 6/7/2004 21:35'!isPartOfClassDefinitions	^ version > 0! !!MaClassDefinition methodsFor: 'printing' stamp: 'cmm 6/24/2004 14:42'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttribute: #version		on: aStream! !!MaClassDefinition methodsFor: 'testing' stamp: 'cmm 11/26/2004 15:12'!maWantsPostMaterialization	^ true! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/2/2005 15:21'!maWantsPreSerialization	^ false! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 12/19/2002 21:43'!namedInstSize	^self allInstVarNames size! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:35'!sharedPoolsString	^ self stringForVariables: poolDictionaryNames! !!MaClassDefinition methodsFor: 'private' stamp: 'cmm 5/18/2004 00:34'!stringForVariables: aCollection	^ String streamContents:		[ :stream |		aCollection			do: [ :ea | stream nextPutAll: ea ]			separatedBy: [ stream space ] ]! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 6/11/2004 00:55'!superclassDefinition	^ superclassDefinition! !!MaClassDefinition methodsFor: 'accessing' stamp: 'cmm 6/10/2004 23:49'!superclassName	^ superclassDefinition className! !!MaClassDefinition methodsFor: 'accessing'!version	^version! !!MaClassDefinition methodsFor: 'building' stamp: 'cmm 6/23/2004 13:49'!version: anInteger	version _ anInteger! !!MaClassDefinition methodsFor: 'actions' stamp: 'cmm 10/17/2004 15:04'!withAllSuperclassDefinitionsDo: oneArgBlock	"Value oneArgBlock with myself, then each of my superclass-definitions, in turn."	oneArgBlock value: self.	superclassDefinition ifNotNil: [ superclassDefinition withAllSuperclassDefinitionsDo: oneArgBlock ]! !!MaClassReference class methodsFor: 'creation' stamp: 'cmm 6/28/2004 18:05'!className: aSymbol	^ self globalName: aSymbol! !!MaClassReference methodsFor: 'accessing'!className	^self globalName! !!MaClassReference methodsFor: 'building'!className: aSymbol	self globalName: aSymbol! !!MaClassReference methodsFor: 'accessing'!classObject	^self globalObject! !!MaClassReference methodsFor: 'accessing' stamp: 'cmm 6/23/2004 00:03'!hasId	^ self id notNil! !!MaClassReference methodsFor: 'accessing'!id	^id! !!MaClassReference methodsFor: 'building'!id: anInteger	id _ anInteger! !!MaClassReference methodsFor: 'private' stamp: 'cmm 5/2/2005 15:20'!maWantsPreSerialization	^ true! !!MaClassReference methodsFor: 'accessing' stamp: 'cmm 1/1/2003 23:52'!name	"For interface compatibility with Class."	^self className! !!MaGlobalReference class methodsFor: 'creation'!globalName: aSymbol	^self new globalName: aSymbol! !!MaGlobalReference methodsFor: 'private'!globalName	^globalName! !!MaGlobalReference methodsFor: 'private'!globalName: aSymbol	globalName _ aSymbol! !!MaGlobalReference methodsFor: 'accessing' stamp: 'cmm 6/28/2004 14:29'!globalObject	^Smalltalk		at: self globalName		ifAbsent:			[ MaObjectSerializationSoftwareError signal: self globalName, ' not defined in this image.'.			self ]! !!MaGlobalReference methodsFor: 'printing' stamp: 'cmm 4/22/2002 22:25'!maPrintAbbreviatedOn: aStream	aStream nextPutAll: self globalName! !!MaHashIndexRecordFactory class methodsFor: 'creation' stamp: 'cmm 12/4/2002 23:31'!index: aMaHashIndex	^self new		index: aMaHashIndex;		postInitialize;		yourself! !!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 7/1/2005 17:15'!createPreMadeNewRecord	preMadeNewRecord :=		MaHashIndexRecord			keySize: index keySize			valueSize: index valueSize			numberOfSlots: index hashRecordSize! !!MaHashIndexRecordFactory methodsFor: 'accessing'!entryIndexAtLevel: anInteger	^entryIndexPath at: anInteger! !!MaHashIndexRecordFactory methodsFor: 'private' stamp: 'cmm 12/4/2002 23:35'!index: aMaHashIndex	index := aMaHashIndex! !!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 7/1/2005 17:15'!initializeRecordPathRecords	1		to: self maxDepth		do:			[ :x |			recordPath				at: x				put: (					MaHashIndexRecord						keySize: index keySize						valueSize: index valueSize						numberOfSlots: index hashRecordSize) ]! !!MaHashIndexRecordFactory methodsFor: 'private' stamp: 'cmm 7/1/2005 16:54'!maxDepth	^(index highestPossibleKey log: index numberOfSlots) asInteger! !!MaHashIndexRecordFactory methodsFor: 'initializing' stamp: 'cmm 12/4/2002 23:35'!postInitialize	recordNumbersPath := OrderedCollection new: self maxDepth.	entryIndexPath := OrderedCollection new: self maxDepth.	byteArrayIndexPath := OrderedCollection new: self maxDepth.	recordPath := Array new: self maxDepth.	self		createPreMadeNewRecord;		initializeRecordPathRecords! !!MaHashIndexRecordFactory methodsFor: 'accessing'!preMadeNewRecord	^preMadeNewRecord! !!MaHashIndexRecordFactory methodsFor: 'building' stamp: 'cmm 7/1/2005 17:00'!put: aMaHashIndexRecord atLevel: levelInteger byteArrayIndex: indexInteger	levelInteger > recordNumbersPath size		ifTrue:			[ recordNumbersPath add: aMaHashIndexRecord recordNumber.			byteArrayIndexPath add: indexInteger.			entryIndexPath add: (aMaHashIndexRecord slotIndexForBax: indexInteger) ]		ifFalse:			[ recordNumbersPath				at: levelInteger				put: aMaHashIndexRecord recordNumber.			byteArrayIndexPath				at: levelInteger				put: indexInteger.			entryIndexPath				at: levelInteger				put: (aMaHashIndexRecord slotIndexForBax: indexInteger) ].	levelInteger > recordPath size		ifFalse:			[ (recordPath at: levelInteger) populateFrom: aMaHashIndexRecord ]! !!MaHashIndexRecordFactory methodsFor: 'accessing' stamp: 'cmm 11/29/2002 22:47'!recordAtLevel: levelInteger	^levelInteger > recordPath size		ifTrue:			[ recordPath first independentCopy ]		ifFalse:			[ recordPath at: levelInteger ]! !!MaHashIndexRecordFactory methodsFor: 'accessing'!recordNumberAtLevel: anInteger	^recordNumbersPath at: anInteger! !!MaIntervalCollection commentStamp: 'cmm 6/4/2005 00:48' prior: 0!This class keeps track of a collection of intervals.As intervals are added that intersect or are within the proximityThresholdof existing intervals, the existing interval is enlarged to include for the new interval.If an interval is removed in the middle of a large interval such thata "hole" is created, a new interval will be created and the other onewill be adjusted so that they will represent only the valid ranges.For example:	if an instance of this class has 1..10	and we add: 8..15, then this class will have a single interval from 1..15	Then remove 5..11..  Assuming a proximityThreshold of 1, this class will have the following two intervals:		1..4		12..15Use a proximityThreshold of 0 to track the real-numbers..!!MaIntervalCollection methodsFor: 'add / remove' stamp: 'cmm 6/13/2005 15:43'!addFrom: low to: high	| intersecting lowestLow highestHigh |	low > high ifTrue: [ self error: 'low should be lower than high' ].	intersecting _ self intervalsIntersecting: (self expandedFrom: low to: high).	lowestLow _ low.	highestHigh _ high.	intersecting do:		[ : each |		lowestLow _ lowestLow min: each first.		highestHigh _ highestHigh max: each last ].	intervals		removeAll: intersecting ;		add: (lowestLow to: highestHigh)! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:04'!expandedFrom: low to: high	^ low-proximityThreshold to: high+proximityThreshold! !!MaIntervalCollection methodsFor: 'testing' stamp: 'cmm 6/4/2005 01:07'!includes: aNumber	^ intervals anySatisfy: [ : each | each includes: aNumber ]! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:08'!initialize	super initialize.	intervals _ SortedCollection sortBlock: [ : a : b | a first < b first ].	proximityThreshold _ 1! !!MaIntervalCollection methodsFor: 'enumerating' stamp: 'cmm 4/12/2006 10:48'!intervalsDo: aBlock	intervals do: aBlock! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 17:22'!intervalsInside: anInterval	^ intervals select: [ : each | anInterval maEnvelopes: each ]! !!MaIntervalCollection methodsFor: 'private' stamp: 'cmm 6/4/2005 01:04'!intervalsIntersecting: anInterval	^ intervals select: [ : each | each maIntersects: anInterval ]! !!MaIntervalCollection methodsFor: 'printing' stamp: 'cmm 6/4/2005 18:04'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	intervals do:		[ : each |		aStream 			maPrint: each first ;			maPrint: '..' ;			maPrint: each last ;			space ]! !!MaIntervalCollection methodsFor: 'copying' stamp: 'cmm 10/19/2005 10:05'!postCopy	super postCopy.	intervals _ intervals copy! !!MaIntervalCollection methodsFor: 'add / remove' stamp: 'cmm 6/4/2005 18:19'!removeFrom: low to: high"Removing is a two-step process:1) remove intervals completely contained by input2) adjust intersecting intervals	- each intersects input-low only, set its high to input-low	- each intersects input-high only, set its low to input-high	- each intersects input-low and input-high, set its high to inputs-low and addFrom: inputs-high to its original high"	(self intervalsInside: (low to: high)) do: [ : each | intervals remove: each ].	(self intervalsIntersecting: (self expandedFrom: low to: high))		do: 			[ : each |  | eachIntersectsLow eachIntersectsHigh |			eachIntersectsLow _ low between: each first and: each last.			eachIntersectsHigh _ high between: each first and: each last.			{ eachIntersectsLow. eachIntersectsHigh } caseOf:				{ [ { true. false } ] -> [ each setFrom: each first to: high by: each increment ].				[ { false. true } ] -> [ each setFrom: low to: each last by: each increment ].				[ { true. true } ] -> 					[ | oldHigh |					oldHigh _ each last.					each setFrom: each first to: low by: each increment.					self addFrom: high to: oldHigh ] } ]! !!MaLargeArrayOfNumbers commentStamp: 'cmm 4/28/2005 20:55' prior: 0!MaLargeArrayOfNumbers is an auto-growing, never-shrinking array of numbers.  All numbers have the same number of bits available to represent them.  It maintains the collection in a single randomly-accessed file, and is therefore constrained by available disk space or the addressability of the file.!!MaLargeArrayOfNumbers class methodsFor: 'utilities' stamp: 'cmm 6/13/2005 23:09'!create: aReadWriteStream bitSize: anInteger	^ (self newWithBitSize: anInteger)		create: aReadWriteStream ;		yourself! !!MaLargeArrayOfNumbers class methodsFor: 'utilities' stamp: 'cmm 6/14/2005 12:57'!createNamed: filenameString bitSize: anInteger	(FileStream isAFileNamed: filenameString)		ifTrue: [ MaEnvironmentError signal: filenameString, ' already exists.' ].	^ self		create: (FileStream fileNamed: filenameString) binary		bitSize: anInteger! !!MaLargeArrayOfNumbers class methodsFor: 'creation' stamp: 'cmm 5/23/2005 17:45'!newWithBitSize: anInteger	^ self new		byteSize: anInteger / 8 ;		yourself! !!MaLargeArrayOfNumbers class methodsFor: 'accessing' stamp: 'cmm 3/20/2005 19:23'!suggestedFileExtension	^ 'idx'! !!MaLargeArrayOfNumbers methodsFor: 'accessing'!add: anInteger	^self		at: self size + 1		put: anInteger! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 3/15/2005 21:42'!at: index	^ self		at: index		ifAbsent: [ self error: 'index out of bounds' ]! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 6/4/2005 18:38'!at: logicalIndex ifAbsent: aBlock	(self includesKey: logicalIndex) ifFalse: [ ^ aBlock value ].	broker		readInto: record		at: logicalIndex-1.	^ record byteArray		maUint: broker recordSize*8		at: 0! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/31/2005 15:50'!at: logicalIndex put: anInteger	logicalIndex > self maxSize ifTrue: [ MaUserError signal: 'Out of range.' ].	self loadRecordWith: anInteger.	broker		writeFrom: record		at: logicalIndex-1.  "-1 because broker supports 0-based indexing, I do not."	^ anInteger! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 7/18/2005 11:02'!byteSize: anInteger	broker		headerSize: self headerSize ;		recordSize: anInteger.	self initializePremadeRecord! !!MaLargeArrayOfNumbers methodsFor: '*magma server' stamp: 'cmm 3/22/2005 18:07'!do: aBlock for: aMagmaFileTraverser using: aMaReadStrategy	1 to: self size do:		[ : x |  | oid |		(oid _ self at: x) ~= 0			ifTrue:				[ aMagmaFileTraverser					graphFrom: oid					do: aBlock					using: aMaReadStrategy ] ]! !!MaLargeArrayOfNumbers methodsFor: 'private'!headerSize	"Header consists of:		number of bits per Integer in the receiver."	^1! !!MaLargeArrayOfNumbers methodsFor: 'testing' stamp: 'cmm 6/4/2005 18:38'!includesKey: anInteger	^ anInteger		between: 1		and: self size! !!MaLargeArrayOfNumbers methodsFor: 'initialize' stamp: 'cmm 5/19/2005 10:09'!initializeFromHeader: aByteArray	broker recordSize: (		aByteArray 			maUint: 8			at: 0).	self initializePremadeRecord! !!MaLargeArrayOfNumbers methodsFor: 'initialize' stamp: 'cmm 5/19/2005 10:08'!initializePremadeRecord	record _ MaFixedLengthRecord new: broker recordSize! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 5/19/2005 10:49'!loadRecordWith: anInteger	^ record byteArray		maUint: broker recordSize * 8		at: 0		put: anInteger! !!MaLargeArrayOfNumbers methodsFor: 'printing' stamp: 'cmm 2/5/2003 00:25'!maPrintAbbreviatedOn: aStream	1		to: (self size min: 100)		do:			[ :each |			aStream				space;				maPrint: (self at: each ifAbsent: [ 'error at: ', each printString ]) ].	self size > 100 ifTrue: [ aStream nextPutAll: ' ...' ]! !!MaLargeArrayOfNumbers methodsFor: 'private' stamp: 'cmm 3/15/2005 21:40'!maxFileSize	^ 2000000000! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/19/2005 10:39'!maxSize	^ self maxFileSize // broker recordSize! !!MaLargeArrayOfNumbers methodsFor: 'initialize' stamp: 'cmm 5/19/2005 10:43'!newHeaderBytes	"Answer a new ByteArray containing the header for the receiver.	This is only used when creating the an instance of this class with	the create: constructor."	^(ByteArray new: self headerSize)		maUint: 8		at: 0		put: broker recordSize;		yourself! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/31/2005 15:47'!record	^ record! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 5/17/2005 23:39'!size	^ broker size! !!MaLargeArrayOfNumbers methodsFor: 'accessing' stamp: 'cmm 4/13/2005 15:27'!upTo: countInteger startingAt: startInteger	| answer size targetX |	size _ self size.	startInteger > size ifTrue: [ ^ #() ].	answer _ Array new: (countInteger min: size-startInteger+1).	targetX _ 0.	startInteger to: (startInteger+countInteger-1 min: size) do:		[ : sourceX |		answer			at: (targetX _ targetX + 1)			put: (self at: sourceX) ].	^ answer! !!MaLargeArrayOfRecords class methodsFor: 'create' stamp: 'cmm 6/14/2005 10:34'!open: aReadWriteStream	^ self new open: aReadWriteStream! !!MaLargeArrayOfRecords class methodsFor: 'create' stamp: 'cmm 6/14/2005 12:59'!openNamed: filenameString	(FileStream isAFileNamed: filenameString)		ifFalse: [ MaEnvironmentError signal: filenameString, ' does not exist.' ].	^ self open: (FileStream fileNamed: filenameString) binary! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 6/14/2005 10:41'!close	broker close! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:37'!create: aReadWriteStream	broker _ 		(MaFileRecordBroker headerSize: self headerSize)			recordSize: broker recordSize ;			yourself.	broker create: aReadWriteStream.	self writeHeader! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/22/2005 21:24'!delete	broker delete! !!MaLargeArrayOfRecords methodsFor: 'access' stamp: 'cmm 6/6/2005 12:31'!filename	^ broker filename! !!MaLargeArrayOfRecords methodsFor: 'access' stamp: 'cmm 7/6/2005 22:52'!filesDo: oneArgBlock	broker filesDo: oneArgBlock! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 7/18/2005 13:27'!headerSize	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/23/2005 17:35'!initialize	super initialize.	broker _ MaInImageRecordBroker new! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 5/18/2005 16:22'!initializeFromHeader: aByteArray	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: 'subclass responsibility' stamp: 'cmm 6/30/2005 23:14'!newHeaderBytes	self subclassResponsibility! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 6/14/2005 10:10'!open: aReadWriteStream	broker _ MaFileRecordBroker headerSize: self headerSize.	broker open: aReadWriteStream.	self readHeader! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/19/2005 10:13'!readHeader	| headerBytes |	headerBytes _ ByteArray new: self headerSize.	broker readHeaderInto: headerBytes.	self initializeFromHeader: headerBytes! !!MaLargeArrayOfRecords methodsFor: '*magma server-recovery' stamp: 'cmm 6/5/2005 18:24'!unapplyUsing: aMaApplyRecord	broker unapplyUsing: aMaApplyRecord! !!MaLargeArrayOfRecords methodsFor: 'initialize-release' stamp: 'cmm 5/18/2005 15:53'!writeHeader	broker writeHeaderFrom: self newHeaderBytes! !!MaMagnitudeIndex commentStamp: '<historical>' prior: 0!keySize in bits.!!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 6/13/2005 23:07'!create: aReadWriteStream keySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger	^ (self		newWithKeySize: numberOfBitsInteger		valueSize: valueSize		recordSize: entriesInteger)		create: aReadWriteStream ;		yourself! !!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 6/14/2005 12:57'!createNamed: filenameString keySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger	(FileStream isAFileNamed: filenameString)		ifTrue: [ MaEnvironmentError signal: filenameString, ' already exists.' ].	^ self		create: (FileStream fileNamed: filenameString) binary		keySize: numberOfBitsInteger		valueSize: valueSize		recordSize: entriesInteger! !!MaHashIndex class methodsFor: 'creation' stamp: 'cmm 3/26/2006 19:43'!newWithKeySize: numberOfBitsInteger valueSize: valueSize recordSize: entriesInteger	"Use this constructor only when you want to create in-memory cached-hash-index."	(self validRecordSizes includes: entriesInteger) 		ifFalse: [ MaUserError signal: 'recordSize must be one of ', MaHashIndex validRecordSizes printString ].	^ self new		keySize: numberOfBitsInteger		valueSize: valueSize		hashRecordSize: entriesInteger ;		writeNewRoot ;		yourself! !!MaHashIndex class methodsFor: 'creation'!suggestedFileExtension	^'hdx'! !!MaHashIndex class methodsFor: 'accessing' stamp: 'cmm 8/17/2005 21:21'!validRecordSizes	"Record sizes must be a power of 2 so that slots in every MaHashIndexRecord will be uniformely sized."	^ #(2 4 8 16 32 64 128)! !!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 9/1/2006 18:45'!add: valueInteger at: keyInteger 	"Find the record which either has space for keyInteger or is as far zoomed-in as possible (with either space for keyInteger or not).  If a record already contains another key greater than keyInteger, that entry must be 'pushed' down so we can maintain key order.  Additionally, we must increment the numberOfChildren for each record to the path of where we finally add."	guard critical: 		[ | currentKeyToWrite currentValueToWrite hasSpace reachedBottom |		self 			validateCanAdd: valueInteger			at: keyInteger.		currentKeyToWrite _ keyInteger.		currentValueToWrite _ valueInteger.		self selectRoot.		hasSpace _ false.		reachedBottom _ false.		[ hasSpace | reachedBottom ] whileFalse: 			[ | highestBax keyToMove valueToMove childRecordNumber |			highestBax _ record highestByteArrayIndexFor: currentKeyToWrite.			((hasSpace _ record canAdd: currentKeyToWrite) or: 				[ (keyToMove _ record keyAtHighestSlotFor: currentKeyToWrite) > currentKeyToWrite ]) 				ifTrue: 					[ hasSpace ifFalse: 						[ valueToMove _ record valueAtByteArrayIndex: highestBax.						record vacateSlotAtByteArrayIndex: highestBax ].					"Incrementing here is 'corrected', below, if necessary.."					record incrementNumberOfChildrenAtByteArrayIndex: (record 							atKey: currentKeyToWrite							put: currentValueToWrite).					hasSpace ifFalse: 						[ "It should be safe to assume, here, that highestBax is where currentKeyToWrite was just placed."						(record canAdd: keyToMove) 							ifTrue: 								[ record									incrementNumberOfChildrenAtByteArrayIndex: (record 											atKey: keyToMove											put: valueToMove) ;									decrementNumberOfChildrenAtByteArrayIndex: highestBax.								hasSpace _ true ]							ifFalse: 								[ "If the displaced entry will not be a child of the displacer, we need to correct the increment, (see) above, by decrement the numberOfChildren and incrementing where it *will* be placed."								| newBax |								newBax _ record highestByteArrayIndexFor: keyToMove.								highestBax = newBax ifFalse: 									[ record										decrementNumberOfChildrenAtByteArrayIndex: highestBax ;										incrementNumberOfChildrenAtByteArrayIndex: newBax ] ] ] ]				ifFalse: [ record incrementNumberOfChildrenAtByteArrayIndex: highestBax ].			self writeRecord: record.			valueToMove notNil ifTrue: 				[ "we will need to push this key/value pair down"				currentKeyToWrite _ keyToMove.				currentValueToWrite _ valueToMove ].			childRecordNumber _ record recordNumberCloserTo: currentKeyToWrite.			reachedBottom _ childRecordNumber = 0.			reachedBottom ifFalse: [ self selectRecord: childRecordNumber ] ].		(reachedBottom and: [ hasSpace not ]) ifTrue: 			[ self selectNewRecordFor: currentKeyToWrite.			record incrementNumberOfChildrenAtByteArrayIndex: (record 					atKey: currentKeyToWrite					put: currentValueToWrite).			self writeRecord ] ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:48'!allRecordsDo: twoArgBlock 	guard critical: 		[ self selectRoot.		self 			recordsFrom: record independentCopy			do: twoArgBlock ]! !!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 3/26/2006 19:22'!at: key put: value	"For collection api compatibility."	self		add: value		at: key.	^ value! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 7/18/2005 13:22'!createRecord	record _		(MaHashIndexRecord			keySize: keySize			valueSize: valueSize			numberOfSlots: hashRecordSize)				beFrom: 0				to: (2 raisedTo: keySize) - 1;				recordNumber: 0 ;				yourself.	broker recordSize: record bufferSize! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 3/22/2005 18:05'!do: aBlock for: aMagmaFileTraverser using: aMaReadStrategy	self		entriesFromIndex: 1		do:			[ :eachRecord :recordPosition :levels |			aMagmaFileTraverser				graphFrom: (eachRecord keyAtByteArrayIndex: recordPosition)				do: aBlock				using: aMaReadStrategy ]		until:			[ :eachRecord :recordPosition :levels | false ]! !!MaHashIndex methodsFor: 'enumerating'!entriesFrom: keyInteger do: threeArgBlock until: conditionBlock	"The first two arguments of threeArgBlock and conditionBlock are the record and the	internal index position needed to access the of each entry in those records via	keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.	The third argument is the levels from the root record, where the root is level 1.	This is used to reference into the receivers preMadeRecords, a performance optimization."	^self		slotsFrom: keyInteger		do:			[ :currentRecord :byteArrayIndex :level |			(currentRecord hasEntryAtByteArrayIndex: byteArrayIndex)				ifTrue:					[ threeArgBlock						value: currentRecord						value: byteArrayIndex						value: level ] ]		until: conditionBlock! !!MaHashIndex methodsFor: 'enumerating'!entriesFromIndex: globalIndex do: threeArgBlock until: conditionBlock	^self		slotsFromIndex: globalIndex		do:			[ :currentRecord :byteArrayIndex :level |			(currentRecord hasEntryAtByteArrayIndex: byteArrayIndex)				ifTrue:					[ threeArgBlock						value: currentRecord						value: byteArrayIndex						value: level ] ]		until: conditionBlock! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 9/9/2006 23:42'!findAnomalies	| answer |	answer _ Dictionary new.	self allRecordsDo:		[ :eachParentRec :eachChildRec |		(eachChildRec 			addAnomaliesTo: answer 			usingParent: eachParentRec) ifTrue:				[ MaNotification new					tag: answer;					signal ] ].	^answer! !!MaHashIndex methodsFor: 'private'!getNextRecordNumber	^nextRecordNumber _ nextRecordNumber + 1! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 7/2/2005 17:06'!hasAnomalies	^ self findAnomalies notEmpty! !!MaHashIndex methodsFor: 'accessing'!hashRecordSize	^hashRecordSize! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/29/2005 12:13'!headerSize	"Header consists of:		keySize:  8 bits		valueSize: 8 bits		recordSize: 8 bits"	^ 3! !!MaHashIndex methodsFor: 'testing' stamp: 'cmm 6/12/2006 22:50'!includesKey: anInteger 	^ guard critical: 		[ self selectFirstRecordWithKeyEqualOrGreaterThan: anInteger.		record hasEntryForKey: anInteger ]! !!MaHashIndex methodsFor: 'testing' stamp: 'cmm 4/28/2005 21:55'!includesValue: valueInteger at: keyInteger	| hasEntry key |	self		entriesFrom: keyInteger		do:			[ : eachRecord : eachByteArrayIndex : level |			(hasEntry and:				[ key = keyInteger					and: [ (eachRecord valueAtByteArrayIndex: eachByteArrayIndex) = valueInteger ] ])						ifTrue:							[ ^ true ] ]		until:			[ : eachRecord : eachByteArrayIndex : level |			"Until we're on an entry that could not possibly hold keyInteger."			((hasEntry _ eachRecord hasEntryAtByteArrayIndex: eachByteArrayIndex)				and: [ (key _ eachRecord keyAtByteArrayIndex: eachByteArrayIndex) > keyInteger ])					or: [ eachByteArrayIndex > (eachRecord highestByteArrayIndexFor: keyInteger) ] ].	^ false! !!MaHashIndex methodsFor: 'accessing'!indexOf: keyInteger	^self		indexOfLowest: keyInteger		exactKey: true! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:27'!indexOfHighest: keyInteger 	"If keyInteger is present, answer the index of its last occurrence.  Otherwise, answer the index of the next lower key.  If keyInteger is lower than all keys in the receiver, answer 0."	| lowestIndexOfNextHigherKey |	^ guard critical: 		[ keyInteger >= self highestPossibleKey ifTrue: [ ^ self size ].		lowestIndexOfNextHigherKey _ self 			indexOfLowest: keyInteger + 1			exactKey: false.		lowestIndexOfNextHigherKey = 1 ifTrue: [ ^ 0 ].	"lower than all"		lowestIndexOfNextHigherKey = 0 			ifTrue: [ self size ]			ifFalse: [ lowestIndexOfNextHigherKey - 1 max: 1 ] ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 6/12/2006 17:26'!indexOfLowest: keyInteger exactKey: aBoolean 	"If aBoolean is true, answer 0 if we don't find an exact key.  If false answer the index of the first equal or higher key."	| total index |	^ guard critical: 		[ total _ 0.		self 			navigateToward: keyInteger			until: 				[ : currentRecord | 				| foundRecord |				foundRecord _ false.				currentRecord 					eligibleByteArrayIndexesFor: keyInteger					do: 						[ : each | 						((currentRecord hasEntryAtByteArrayIndex: each) and: [ (currentRecord keyAtByteArrayIndex: each) >= keyInteger ]) ifTrue: [ foundRecord _ true ] ].				total _ total + (record numberOfChildrenBefore: keyInteger).				foundRecord ]			do: 				[ : currentRecord | "nada" ].		"We now have the correct potential record selected and a correct total number of entries that occur before the entry that would contain keyInteger.  Now determine whether we should answer it or nil"		index _ total + 1.		aBoolean 			ifTrue: 				[ (record hasEntryForKey: keyInteger) 					ifTrue: [ ^ index ]					ifFalse: [ 0 ] ]			ifFalse: 				[ index > self size 					ifTrue: [ 0 ]					ifFalse: [ index ] ] ]! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 6/12/2006 17:22'!initialize	super initialize.	self initializePreMadeAnswerArrays.	guard _ Monitor new! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 6/14/2005 13:22'!initializeFromHeader: aByteArray	self		keySize: (aByteArray maUint: 8 at: 0)+1		valueSize: (aByteArray maUint: 8 at: 1)+1		hashRecordSize: (aByteArray maUint: 8 at: 2).	broker recordSize: record bufferSize! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 4/17/2005 22:01'!initializePreMadeAnswerArrays	preMadeKeysArrays _ (1 to: 250) collect: [ :eachSize | Array new: eachSize ].	preMadeValuesArrays _ (1 to: 250) collect: [ :eachSize | Array new: eachSize ]! !!MaHashIndex methodsFor: 'initializing'!initializeRecordFactory	recordFactory _ MaHashIndexRecordFactory index: self! !!MaHashIndex methodsFor: 'initializing'!initializeRecords	self		createRecord;		initializeRecordFactory! !!MaHashIndex methodsFor: 'initializing' stamp: 'cmm 5/23/2005 17:54'!keySize: keySizeInteger valueSize: valueSizeInteger hashRecordSize: recordSizeInteger	keySize _ keySizeInteger.	valueSize _ valueSizeInteger.	hashRecordSize _ recordSizeInteger.	self initializeRecords! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/4/2006 12:53'!keysAndValuesFrom: lowKey startingAt: anInteger do: twoArgBlock until: conditionBlock 	"Value twoArgBlock with each key and value pair, until conditionBlock is false for same key-value pair, starting at anInteger after the lowest index of lowKey."	| lowest currentIndex |	currentIndex _ 0.	lowest _ self 		indexOfLowest: lowKey		exactKey: false.	lowest > 0 ifTrue: 		[ self 			entriesFromIndex: lowest + anInteger - 1			do: 				[ : currentRecord : byteArrayIndex : level | 				currentIndex _ currentIndex + 1.				twoArgBlock 					value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)					value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]			until: 				[ : currentRecord : byteArrayIndex : level | 				conditionBlock 					value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)					value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ] ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/17/2005 22:02'!keysArrayOfSize: anInteger	^anInteger > preMadeKeysArrays size		ifTrue:			[ Array new: anInteger ]		ifFalse:			[ preMadeKeysArrays at: anInteger ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/27/2002 13:22'!navigateToward: keyInteger until: untilBlock do: doBlock	"Select records between the root and the one that can contain keyInteger	and value one-argument doBlock on each of those records until the	one-argument untilBlock values true or we cannot navigate any	closer to keyInteger."	| level |	level _ 1.	self selectRoot.	[ | goalRecordReached bax |	bax _ record highestByteArrayIndexFor: keyInteger.	recordFactory		put: record		atLevel: level		byteArrayIndex: bax.	goalRecordReached _ untilBlock value: record.	goalRecordReached not and: 	[ record hasChildAtByteArrayIndex: bax ] ]		whileTrue:			[ doBlock value: record.			self selectRecord: (record recordNumberCloserTo: keyInteger).			level _ level + 1 ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 6/14/2005 13:22'!newHeaderBytes	^ (ByteArray new: self headerSize)		maUint: 8		at: 0		put: keySize-1 ;   "-1 because we want to allow up to 256 bits"		maUint: 8		at: 1		put: valueSize-1 ;		maUint: 8		at: 2		put: hashRecordSize ;		yourself! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:28'!numberOfEntriesFrom: lowKey to: highKey 	"Inclusive of lowKey and highKey, if those keys exist.	If lowKey does not exist, we count from the next higher key.	If highKey doesn't exist, we count up to the next highestKey."	^ guard critical: 		[ | lowest |		(lowest _ self 			indexOfLowest: lowKey			exactKey: false) = 0 ifTrue: [ ^ 0 ].		(self indexOfHighest: highKey) - lowest + 1 ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 7/1/2005 16:54'!numberOfSlots	^ record numberOfSlots! !!MaHashIndex methodsFor: 'accessing'!occurrencesOf: keyInteger	^self		numberOfEntriesFrom: keyInteger		to: keyInteger! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 5/22/2005 22:54'!readRecord: aMaHashIndexRecord at: recordIndex	broker		readInto: aMaHashIndexRecord		at: recordIndex.	^ aMaHashIndexRecord 		cacheAttributes ;		recordNumber: recordIndex ;		yourself! !!MaHashIndex methodsFor: 'private'!recordSize	^record bufferSize! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:49'!recordsDo: twoArgBlock level: level byteArrayIndex: anInteger 	guard critical: 		[ | parent |		recordFactory 			put: record			atLevel: level			byteArrayIndex: anInteger.		parent _ recordFactory recordAtLevel: level.		twoArgBlock 			value: parent			value: level.		parent 			byteArrayIndexesFrom: 0			do: 				[ : eachBax | 				(parent hasChildAtByteArrayIndex: eachBax) ifTrue: 					[ self selectRecord: (parent recordNumberAtByteArrayIndex: eachBax).					self 						recordsDo: twoArgBlock						level: level + 1						byteArrayIndex: anInteger ] ] ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:49'!recordsFrom: aMaHashIndexRecord do: twoArgBlock 	guard critical: 		[ | childRec |		aMaHashIndexRecord 			byteArrayIndexesFrom: 0			do: 				[ : eachBax | 				(aMaHashIndexRecord hasChildAtByteArrayIndex: eachBax) ifTrue: 					[ childRec _ aMaHashIndexRecord independentCopy.					self 						readRecord: childRec						at: (aMaHashIndexRecord recordNumberAtByteArrayIndex: eachBax).					twoArgBlock 						value: aMaHashIndexRecord						value: childRec.					self 						recordsFrom: childRec						do: twoArgBlock ] ] ]! !!MaHashIndex methodsFor: 'add / remove' stamp: 'cmm 9/1/2006 18:45'!remove: valueInteger at: keyInteger 	"Answer a boolean indicating whether anything was removed."	guard critical: 		[ | currentBaxToFill sourceBax parentRecord childRecord baxFilled |		(self 			includesValue: valueInteger			at: keyInteger) ifFalse: [ ^ false ].		self 			navigateToward: keyInteger			until: 				[ : eachRecord | 				(currentBaxToFill _ eachRecord 					removeKey: keyInteger					withValue: valueInteger) notNil ]			do: 				[ : eachRecord | 				"No need for beforeImageSignal here because we already signaled it in the until block."				eachRecord decrementNumberOfChildrenAtKey: keyInteger.				self writeRecord ].		self writeRecord.		"get out if we can.."		currentBaxToFill ifNil: [ ^ true ].		(record hasChildAtByteArrayIndex: currentBaxToFill) ifFalse: [ ^ true ].		"Now pull up child record entries into the newly vacated slot because add looks for the first available slot that is eligible for the key it is adding, which *could* be greater than the key of the next child (meaning we'd then be out of order)."		sourceBax _ 0.	"non-nil"		parentRecord _ record independentCopy.		childRecord _ record independentCopy.				[ sourceBax notNil and: [ parentRecord hasChildAtHighestByteArrayIndexForBax: currentBaxToFill ] ] whileTrue: 			[ | highestByteArrayIndexForBaxToFill |			highestByteArrayIndexForBaxToFill _ parentRecord highestByteArrayIndexForAnyKeyAt: currentBaxToFill.			self 				readRecord: childRecord				at: (parentRecord recordNumberAtByteArrayIndex: highestByteArrayIndexForBaxToFill).			sourceBax _ childRecord byteArrayIndexOfLowestEntry.			sourceBax ifNotNil: 				[ baxFilled _ parentRecord 					atKey: (childRecord keyAtByteArrayIndex: sourceBax)					put: (childRecord valueAtByteArrayIndex: sourceBax).				baxFilled ~= highestByteArrayIndexForBaxToFill ifTrue: 					[ parentRecord incrementNumberOfChildrenAtByteArrayIndex: baxFilled.					parentRecord decrementNumberOfChildrenAtByteArrayIndex: highestByteArrayIndexForBaxToFill ].				childRecord					decrementNumberOfChildrenAtByteArrayIndex: sourceBax ;					vacateSlotAtByteArrayIndex: sourceBax.				self					writeRecord: parentRecord ;					writeRecord: childRecord.				parentRecord populateFrom: childRecord.				currentBaxToFill _ sourceBax ] ].		^ true ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 7/1/2005 17:10'!selectFirstRecordWithKeyEqualOrGreaterThan: keyInteger	"If keyInteger is larger than every key in the index, answer nil, otherwise answer the level of the record with the answer."	| level searchedLevel |	level _ 1.	self		navigateToward: keyInteger		until:			[ : currentRecord |			currentRecord				eligibleByteArrayIndexesFor: keyInteger				do:					[ : each |					((currentRecord hasEntryAtByteArrayIndex: each)						and: [ (currentRecord keyAtByteArrayIndex: each) >= keyInteger ])							ifTrue:								[ ^ level ] ].			false ]		do: [ :currentRecord | level _ level + 1 ].	"Though we have arrived at the record which would contain keyInteger,	in case it does not have entries whose keys are >= keyInteger,	look for the next higher key."	self		traverseSlotsFromRecord: record		index: (record slotIndexFor: keyInteger)		do: [ : currentRecord : byteArrayIndex : currentLevel | "nothing" ]		until:			[ : currentRecord : byteArrayIndex : currentLevel |			searchedLevel _ currentLevel.			currentRecord hasEntryAtByteArrayIndex: byteArrayIndex ]		level: level.	^ searchedLevel! !!MaHashIndex methodsFor: 'private'!selectNewRecordFor: keyInteger	"We need to make sure we reference the new record from the	current record."	self setUpNewRecordFor: keyInteger.	"Reference new record and write before selecting the new record."	record		recordNumberAtSlotForKey: keyInteger		put: recordFactory preMadeNewRecord recordNumber.	self		writeRecord; "replace record that now references newRecord.."		selectPreMadeNewRecord! !!MaHashIndex methodsFor: 'private'!selectPreMadeNewRecord	record populateFrom: recordFactory preMadeNewRecord! !!MaHashIndex methodsFor: 'private'!selectRecord: anInteger	self		readRecord: record		at: anInteger! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/30/2002 13:03'!selectRecordAt: globalIndex	"Answer the level and the byteArrayIndex of the selected record, or nil if out of bounds.	Since the caller of this method is going to call traverseSlotsFromRecord:index:do:until:level:,	we must be sure to populate the receivers path."	| level byteArrayIndex currentGlobalPosition outOfBounds |	self selectRoot.	level _ 1.	currentGlobalPosition _ 0.  "0-based"	outOfBounds _ false.	[		byteArrayIndex _			record				byteArrayIndexContainingGlobalIndex: globalIndex				base: currentGlobalPosition.		byteArrayIndex isNil			ifTrue:				[ outOfBounds _ true.				false ]			ifFalse:				[ currentGlobalPosition _					currentGlobalPosition +						(record numberOfChildrenBeforeByteArrayIndex: byteArrayIndex).				(record hasEntryAtByteArrayIndex: byteArrayIndex)					ifTrue: [ currentGlobalPosition _ currentGlobalPosition + 1 ].				(currentGlobalPosition < globalIndex) and:					[ "this should never be false if above is true"					record hasChildAtByteArrayIndex: byteArrayIndex ] ] ]						whileTrue:							[ recordFactory								put: record								atLevel: level								byteArrayIndex: byteArrayIndex.							self selectRecord:								(record recordNumberAtByteArrayIndex: byteArrayIndex).							level _ level + 1 ].	^outOfBounds		ifTrue:			[ nil ]		ifFalse:			[ Array				with: byteArrayIndex				with: level ]! !!MaHashIndex methodsFor: 'private'!selectRoot	self selectRecord: 0! !!MaHashIndex methodsFor: 'private'!setUpNewRecordFor: keyInteger	recordFactory preMadeNewRecord		beZoomedInToward: keyInteger			from: record;		recordNumber: self getNextRecordNumber! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:26'!size	^ guard critical: 		[ self selectRoot.		record numberOfChildren ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/12/2006 22:46'!slotsFrom: keyInteger do: threeArgBlock until: conditionBlock 	"The first two arguments of threeArgBlock and conditionBlock are the record and the internal index position needed to access the of each entry in those records via keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.  The third argument is the levels from the root record, where the root is level 1.  This is used to reference into the receivers preMadeRecords, a performance optimization."	guard critical: 		[ | level startingEntryIndex |		(level _ self selectFirstRecordWithKeyEqualOrGreaterThan: keyInteger) isNil ifTrue: [ ^ self ].		"For inverted records, it is possible the entryIndex for keyInteger will be consumed by the next lower key.  Unfortunately, we have to check."		startingEntryIndex _ record slotIndexFor: keyInteger.		(record keyAtSlotIndex: startingEntryIndex) < keyInteger ifTrue: [ startingEntryIndex _ startingEntryIndex + 1 ].		self 			traverseSlotsFromRecord: record			index: startingEntryIndex			do: threeArgBlock			until: conditionBlock			level: level ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 6/12/2006 22:46'!slotsFromIndex: globalIndex do: threeArgBlock until: conditionBlock 	"The first two arguments of threeArgBlock and conditionBlock are the record and the internal index position needed to access the of each entry in those records via keyAtByteArrayIndex:, oidAtByteArrayIndex:, and recordNumberAtByteArrayIndex:.  The third argument is the levels from the root record, where the root is level 1.  This is used to reference into the receivers preMadeRecords, a performance optimization."	guard critical: 		[ | byteArrayIndexAndLevelArray |		(byteArrayIndexAndLevelArray _ self selectRecordAt: globalIndex) isNil ifTrue: [ ^ self ].		self 			traverseSlotsFromRecord: record			index: (record slotIndexForBax: byteArrayIndexAndLevelArray first)			do: threeArgBlock			until: conditionBlock			level: byteArrayIndexAndLevelArray last ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/29/2002 22:46'!traverseSlotsFromParentRecord: aMaHashIndexRecord index: entryIndex do: threeArgBlock until: conditionBlock level: levelInteger	"levelInteger is 1 for the root record."	| conditionMet |	conditionMet _ false.	aMaHashIndexRecord		byteArrayIndexesFrom: entryIndex		do:			[ :index | | nextToRead |			conditionMet				ifFalse:					[ nextToRead _ aMaHashIndexRecord recordNumberAtByteArrayIndex: index.					(conditionBlock						value: aMaHashIndexRecord						value: index						value: levelInteger)							ifTrue:								[ conditionMet _ true ]							ifFalse:								[ threeArgBlock									value: aMaHashIndexRecord									value: index									value: levelInteger ] ].			conditionMet				ifFalse:					[ nextToRead > 0						ifTrue:							[ | currentRecord |							currentRecord _ recordFactory recordAtLevel: levelInteger + 1.							self								readRecord: currentRecord								at: nextToRead.							conditionMet _								self									traverseSlotsFromParentRecord: currentRecord									index: 0									do: threeArgBlock									until: conditionBlock									level: levelInteger + 1 ] ] ].	^conditionMet! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 11/29/2002 22:46'!traverseSlotsFromRecord: aMaHashIndexRecord index: entryIndex do: threeArgBlock until: conditionBlock level: levelInteger	"levelInteger is 1 for the root record."	| done |	done _		self			traverseSlotsFromParentRecord: aMaHashIndexRecord			index: entryIndex			do: threeArgBlock			until: conditionBlock			level: levelInteger.	(done not and: [ levelInteger > 1 ])		ifTrue:			[ | nextStart |			nextStart _ recordFactory recordAtLevel: levelInteger - 1.			self				readRecord: nextStart				at: (recordFactory recordNumberAtLevel: levelInteger - 1).			self				traverseSlotsFromRecord: nextStart				index: (recordFactory entryIndexAtLevel: levelInteger - 1) + 1				do: threeArgBlock				until: conditionBlock				level: levelInteger - 1 ]! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 4/17/2005 22:13'!upTo: countInteger at: keyInteger	^ self		upTo: countInteger		keysAndValuesFrom: keyInteger		to: keyInteger		startingAt: 1! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:29'!upTo: countInteger keysAndValuesFrom: lowKey to: highKey startingAt: index 	"Answer the specified number of values starting at logical-position index *within* the lowKey to highKey range."	^ guard critical: 		[ | answerIndex keys values |		answerIndex _ 0.		keys _ self keysArrayOfSize: countInteger.		values _ self valuesArrayOfSize: countInteger.		self 			upTo: countInteger			keysAndValuesFrom: lowKey			to: highKey			startingAt: index			do: 				[ : eachKey : eachValue | 				keys 					at: (answerIndex _ answerIndex + 1)					put: eachKey.				values 					at: answerIndex					put: eachValue ].		answerIndex = 0 			ifTrue: 				[ {  #(). #()  } ]			ifFalse: 				[ answerIndex < countInteger 					ifTrue: 						[ { 							(keys 								copyFrom: 1								to: answerIndex).							(values 								copyFrom: 1								to: answerIndex)						 } ]					ifFalse: 						[ {  keys. values  } ] ] ]! !!MaHashIndex methodsFor: 'enumerating' stamp: 'cmm 4/12/2006 21:53'!upTo: countInteger keysAndValuesFrom: lowKey to: highKey startingAt: index do: twoArgBlock	"Answer the specified number of values starting at logical-position index within the lowKey to highKey range, value twoArgBlock with each key-value pair in that range."	| lowest currentIndex |	currentIndex _ 0.	lowest _ self indexOfLowest: lowKey exactKey: false.	lowest > 0		ifTrue:			[ self				entriesFromIndex: lowest + index - 1				do:					[ : currentRecord : byteArrayIndex : level |					currentIndex _ currentIndex + 1.					twoArgBlock						value: (currentRecord keyAtByteArrayIndex: byteArrayIndex)						value: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]				until:					[  : currentRecord : byteArrayIndex : level |					currentIndex = countInteger					or: [ (currentRecord keyAtByteArrayIndex: byteArrayIndex) > highKey ] ] ]! !!MaHashIndex methodsFor: 'accessing' stamp: 'cmm 6/12/2006 17:30'!upTo: countInteger keysAndValuesFromIndex: lowIndex 	^ guard critical: 		[ | answerIndex keys values |		keys _ self keysArrayOfSize: countInteger.		values _ self valuesArrayOfSize: countInteger.		answerIndex _ 0.		self 			entriesFromIndex: lowIndex			do: 				[ : currentRecord : byteArrayIndex : level | 				keys 					at: (answerIndex _ answerIndex + 1)					put: (currentRecord keyAtByteArrayIndex: byteArrayIndex).				values 					at: answerIndex					put: (currentRecord valueAtByteArrayIndex: byteArrayIndex) ]			until: [ : currentRecord : index : level | answerIndex = countInteger ].		answerIndex = 0 			ifTrue: 				[ {  #(). #()  } ]			ifFalse: 				[ answerIndex < countInteger 					ifTrue: 						[ { 							(keys 								copyFrom: 1								to: answerIndex).							(values 								copyFrom: 1								to: answerIndex)						 } ]					ifFalse: 						[ {  keys. values  } ] ] ]! !!MaHashIndex methodsFor: 'SUnit tests' stamp: 'cmm 6/12/2006 22:49'!upTo: countInteger keysFrom: startKey 	guard critical: 		[ | result answerIndex |		result _ self valuesArrayOfSize: countInteger.		answerIndex _ 1.		self 			entriesFrom: startKey			do: 				[ : currentRecord : index : level | 				(currentRecord hasEntryAtByteArrayIndex: index) ifTrue: 					[ result 						at: answerIndex						put: (currentRecord keyAtByteArrayIndex: index).					answerIndex _ answerIndex + 1 ] ]			until: [ : currentRecord : index : level | answerIndex > countInteger ].		"Need to check in case of a small index (say only 9 entries?)."		^ answerIndex < countInteger 			ifTrue: 				[ result 					copyFrom: 1					to: answerIndex - 1 ]			ifFalse: [ result ] ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 3/20/2005 17:49'!validateCanAdd: oidInteger at: keyInteger	keyInteger > self highestPossibleKey ifTrue:		[ MaHashIndexUserError signal: keyInteger printString, ' is larger than the highestPossibleKey.' ]! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 4/17/2005 22:01'!valuesArrayOfSize: anInteger	^anInteger > preMadeValuesArrays size		ifTrue:			[ Array new: anInteger ]		ifFalse:			[ preMadeValuesArrays at: anInteger ]! !!MaHashIndex methodsFor: 'private'!writeNewRoot	self writeRecord! !!MaHashIndex methodsFor: 'private'!writeRecord	self writeRecord: record! !!MaHashIndex methodsFor: 'private' stamp: 'cmm 5/22/2005 22:54'!writeRecord: aMaHashIndexRecord	broker 		writeFrom: aMaHashIndexRecord		at: aMaHashIndexRecord recordNumber! !!MaMagnitudeIndex methodsFor: 'building'!add: oidInteger at: keyInteger	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'accessing'!headerSize	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 3/20/2005 17:50'!highestPossibleKey	^ highestPossibleKey ifNil:		[ highestPossibleKey _ (2 raisedTo: keySize) - 1 ]! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 5/23/2005 23:13'!initialize	super initialize.	nextRecordNumber _ 0! !!MaMagnitudeIndex methodsFor: 'accessing'!keySize	^keySize! !!MaMagnitudeIndex methodsFor: 'private'!keySize: numberOfBitsInteger	keySize _ numberOfBitsInteger! !!MaMagnitudeIndex methodsFor: 'accessing'!lowestPossibleKey	^0! !!MaMagnitudeIndex methodsFor: 'private' stamp: 'cmm 10/31/2002 19:37'!open	self open: self filename! !!MaMagnitudeIndex methodsFor: 'private' stamp: 'cmm 8/22/2005 09:24'!open: aReadWriteStream	super open: aReadWriteStream.	nextRecordNumber := broker nextRecordNumber.	nextRecordNumber isInteger		ifFalse:			[ MaSpecialCollectionsSoftwareError signal: 'Invalid index size.  Requires maintenance tool.' ]! !!MaMagnitudeIndex methodsFor: 'accessing'!recordSize	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'framework' stamp: 'cmm 12/23/2002 22:16'!size	self subclassResponsibility! !!MaMagnitudeIndex methodsFor: 'accessing' stamp: 'cmm 4/28/2005 21:12'!valueSize	^ valueSize! !!MaLargeCollectionManager commentStamp: 'cmm 3/16/2005 12:48' prior: 0!I perform server-side operations for MagmaLargeCollections.  Adding, removing and accessing.!!MaLargeCollectionManager class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!collection: aMagmaCollection repository: aMaObjectRepository	^self new		collection: aMagmaCollection ;		repository: aMaObjectRepository ;		yourself! !!MaLargeCollectionManager methodsFor: 'initializing' stamp: 'cmm 3/16/2005 14:24'!close	memberIndex ifNotNil: [ memberIndex close.  memberIndex _ nil ]! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:57'!collection	^ collection! !!MaLargeCollectionManager methodsFor: 'private' stamp: 'cmm 3/17/2005 22:23'!collection: aMagmaLargeCollection	collection := aMagmaLargeCollection! !!MaLargeCollectionManager methodsFor: 'private' stamp: 'cmm 12/2/2004 13:22'!collectionOid	^ repository session oidFor: collection! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 7/12/2005 11:02'!createNewLargeCollection	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'actions' stamp: 'cmm 7/12/2005 11:18'!createSupplementaryIndexes	"Nothing to do by default."! !!MaLargeCollectionManager methodsFor: 'initializing' stamp: 'cmm 7/12/2005 12:57'!ensureMemberIndexOpen	memberIndex ifNil:		[ memberIndex _ self openIndex: (repository collectionFilenameFor: collection) asString ]! !!MaLargeCollectionManager methodsFor: 'actions' stamp: 'cmm 3/17/2005 17:22'!ensureOpen	^ self 		ensureMemberIndexOpen ;		yourself! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/9/2006 17:25'!fileIdForIndex: anInteger	"To support recovery, we must populate MaBeforeImageRecords with a fileId, which identifies which file it is a before-image of.  We have eight bytes available for this.  The high-order 6 bytes are my collectionOid, the low-order two bytes indicate which index of the collection it is.  0 is the memberIndex."	^ (self collectionOid bitShift: 16) + anInteger! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 8/22/2002 19:25'!filename	^memberIndex filename! !!MaLargeCollectionManager methodsFor: 'accessing' stamp: 'cmm 6/8/2005 15:13'!filenames	^ { repository directory localNameFor: self filename }! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/5/2005 23:43'!filesDo: twoArgBlock	memberIndex filesDo: 		[ : each |		twoArgBlock			value: each			value: (self fileIdForIndex: 0) ]! !!MaLargeCollectionManager methodsFor: 'recovery' stamp: 'cmm 5/30/2005 21:25'!indexForFileId: anInteger	"To support recovery of LargeCollections, we must replace the applied records to their prior-state, which is contained inside MaBeforeImageRecords."	^ memberIndex "the only possibility"! !!MaLargeCollectionManager methodsFor: 'testing' stamp: 'cmm 7/9/2006 17:42'!isLoading	"Answer whether this collection is being loaded from another collection.  This happens only for MagmaCollections when the client requests they be sorted, it never happens for MagmaArrays."	^ false! !!MaLargeCollectionManager methodsFor: 'testing' stamp: 'cmm 2/25/2003 10:19'!isOpen	^memberIndex ~= nil! !!MaLargeCollectionManager methodsFor: 'accessing'!memberIndex	^memberIndex! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/17/2005 23:14'!openIndex: filenameString	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 22:57'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 14:17'!processAddsIn: aMaCollectionChanges using: aMaCommitResult	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 21:24'!recordConflictsBetween: aMagmaCollectionChanges and: challengingCommitLogEntry in: myCommitLogEntry	"If there are any conflicts, record them in myCommitLogEntry."	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 3/16/2005 21:24'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	self subclassResponsibility! !!MaLargeCollectionManager methodsFor: 'private'!repository: aMaObjectRepository	repository := aMaObjectRepository! !!MaLargeCollectionManager methodsFor: 'accessing'!size	^memberIndex size! !!MaLargeCollectionManager methodsFor: 'override' stamp: 'cmm 4/30/2005 11:16'!upTo: anInteger inSegmentFromIndex: lowIndex	self subclassResponsibility! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 7/12/2005 12:59'!createNewLargeCollection	| fullFilename |	fullFilename _ repository collectionFilenameFor: collection.	memberIndex _		MaLargeArrayOfNumbers			create: (MaTransactionalFileStream fileNamed: fullFilename)			bitSize: MaObjectFiler maxDbSize! !!MagmaArrayManager methodsFor: 'initializing' stamp: 'cmm 7/8/2005 10:47'!openIndex: filenameString	^ MaLargeArrayOfNumbers open:		(MaTransactionalFileStream fileNamed: filenameString)! !!MagmaArrayManager methodsFor: 'actions' stamp: 'cmm 3/18/2005 10:55'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self		processAddsIn: aMaCollectionChanges		using: aMaCommitResult.! !!MagmaArrayManager methodsFor: 'private' stamp: 'cmm 5/14/2005 19:05'!processAddsIn: aMagmaArrayChanges using: aMaCommitResult	aMagmaArrayChanges additionsDo:		[ : eachIndex : eachOid |  | addedObjectOid |		addedObjectOid :=			(MaOidCalculator isOidForNewObject: eachOid)				ifTrue: [ aMaCommitResult permanentOids at: eachOid ]				ifFalse: [ eachOid ].		memberIndex			at: eachIndex			put: addedObjectOid ]! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 3/20/2005 21:29'!recordConflictsBetween: aMagmaArrayChanges and: challengingCommitLogEntry in: myCommitLogEntry	"For MagmaArray's, different sessions may update the Array as long as they update different indexes."	(challengingCommitLogEntry hasChangesToMagmaArray: aMagmaArrayChanges collectionOid)		ifTrue:			[ | foreignChanges |			foreignChanges _ challengingCommitLogEntry magmaArrayAdditionsAt: aMagmaArrayChanges collectionOid.			aMagmaArrayChanges additionsDo:				[ : eachIndex : eachOid |				((foreignChanges includesKey: eachIndex)				and: [ (foreignChanges at: eachIndex) ~= eachOid ])					ifTrue:						[ "this user tried to put a different oid at the same index, conflict!!"						myCommitLogEntry							failResultWith: challengingCommitLogEntry connection							on: aMagmaArrayChanges collectionOid ] ] ]! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 3/18/2005 13:33'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	"no general conflicts for MagmaArray's."! !!MagmaArrayManager methodsFor: 'overriding' stamp: 'cmm 6/5/2006 23:35'!upTo: anInteger inSegmentFromIndex: lowIndex	| oids |	oids _ 		memberIndex			upTo: anInteger			startingAt: lowIndex.	^ MagmaCollectionSegment new		lastKnownSize: memberIndex size ;		startIndex: lowIndex ;		objects: oids ;		yourself! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/4/2006 15:43'!addMember: addedObjectOid atHashes: eachHashIndexArrays 	memberIndex 		add: self dummyValue		at: addedObjectOid.	eachHashIndexArrays withIndexDo: 		[ : eachHashValues : x | 		eachHashValues do: 			[ : eachHashValue | 			(oidIndexes at: x) 				add: addedObjectOid				at: eachHashValue.			(keyIndexes at: x) 				add: eachHashValue				at: addedObjectOid ] ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 13:42'!addNewIndex: aMaIndexDefinition 	oidIndexes add: 		(oidIndexesByAttribute 			at: aMaIndexDefinition attribute			put: 				(MaHashIndex 					create: 						(MaTransactionalFileStream fileNamed: (self 							fullFileNameStringFor: 'oids'							of: aMaIndexDefinition))					keySize: aMaIndexDefinition keySize					valueSize: MaObjectBuffer oidSize					recordSize: aMaIndexDefinition recordSize)).	keyIndexes add: 		(keyIndexesByAttribute 			at: aMaIndexDefinition attribute			put: 				(MaHashIndex 					create: 						(MaTransactionalFileStream fileNamed: (self 							fullFileNameStringFor: 'keys'							of: aMaIndexDefinition))					keySize: MaObjectBuffer oidSize					valueSize: aMaIndexDefinition keySize					recordSize: aMaIndexDefinition recordSize))! !!MagmaCollectionManager methodsFor: 'locking' stamp: 'cmm 3/16/2005 14:13'!beLockedBy: aMagmaClientConnection	lockedBy _ aMagmaClientConnection! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 14:30'!close	super close.	oidIndexes do: [ : each | each close ].	keyIndexes do: [ : each | each close ]! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 8/17/2005 21:03'!createNewLargeCollection	| fullFilename |	fullFilename := repository collectionFilenameFor: collection.	memberIndex :=		MaHashIndex			create: (MaTransactionalFileStream fileNamed: fullFilename)			keySize: MaObjectBuffer oidSize			valueSize: 8			recordSize: 8! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 7/12/2005 11:20'!createSupplementaryIndexes	| position |	position _ 0.	collection indexesDo:		[ : eachIndexDefinition |		self			ensureIndex: eachIndexDefinition			at: (position _ position + 1) ]! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 6/13/2006 00:26'!delete	self filesDo: 		[ : eachFile : eachFileId | 		eachFile close.		repository directory deleteFileNamed: eachFile filename ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/2/2006 21:22'!dummyValue	"For the memberIndex, we only use the keys, answer a dummy value for the values."	^ 0! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 10:05'!ensureIndex: aMaIndexDefinition at: indexPosition 	oidIndexes size < indexPosition ifTrue: [ self addNewIndex: aMaIndexDefinition ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 4/13/2006 13:39'!ensureIndexesOpen	collection indexesDo: 		[ : each | 		(self hasIndexFor: each attribute) ifFalse: 			[ oidIndexes add: 				(oidIndexesByAttribute 					at: each attribute					put: 						(self openIndex: 							(self 								fullFileNameStringFor: 'oids'								of: each))).			keyIndexes add: 				(keyIndexesByAttribute 					at: each attribute					put: 						(self openIndex: 							(self 								fullFileNameStringFor: 'keys'								of: each))) ] ]! !!MagmaCollectionManager methodsFor: 'actions' stamp: 'cmm 3/17/2005 17:22'!ensureOpen	super ensureOpen.	self ensureIndexesOpen! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/11/2006 21:38'!fileIdForOids: aBoolean index: anInteger	"To support recovery, we must populate MaBeforeImageRecords with a fileId identifying which file it is a before-image of.  We have eight bytes available for this.  The high-order 48-bits are my collectionOid, the low-order 15 bits indicate which index of the collection it is.  0 is the memberIndex.  For the other indexes (where lower-order 15 bits > 0), bit 16 is 1 for keys, 0 for oids."	| isKeysBit indexId |	isKeysBit _ 16.	(anInteger maIsBitSet: isKeysBit) ifTrue: 		[ MagmaSoftwareError signal: 'Cannot have more than ' , ((0 maBitSet: isKeysBit) - 1) printString , ' indexes for a single collection.' ].	indexId _ aBoolean 		ifTrue: [ anInteger ]		ifFalse: [ anInteger maBitSet: isKeysBit ].	^ (self collectionOid bitShift: 16) + indexId! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 3/16/2005 21:28'!filenameComponentFor: aMaIndexDefinition	^ self collectionOid printString , aMaIndexDefinition uniqueFileIdentifier! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 13:36'!filenameFor: keysOrOids of: aMaIndexDefinition	^ (String streamContents:		[ : stream |		stream			nextPutAll: (self filenameComponentFor: aMaIndexDefinition) ;			nextPut: $- ;			nextPutAll: keysOrOids ;			nextPut: $. ;			nextPutAll: MaHashIndex suggestedFileExtension ])! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 4/13/2006 12:48'!filenames	^ super filenames , 	(oidIndexes, keyIndexes collect: [ : each | repository directory localNameFor: each filename ])! !!MagmaCollectionManager methodsFor: 'recovery' stamp: 'cmm 4/14/2006 12:41'!filesDo: twoArgBlock 	super filesDo: twoArgBlock.	oidIndexes withIndexDo: 		[ : each : x | 		each filesDo: 			[ : eachIndexFile | 			twoArgBlock 				value: eachIndexFile				value: 					(self 						fileIdForOids: true						index: x) ] ].	keyIndexes withIndexDo: 		[ : each : x | 		each filesDo: 			[ : eachIndexFile | 			twoArgBlock 				value: eachIndexFile				value: 					(self 						fileIdForOids: false						index: x) ] ]! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:53'!fractionLoaded	self isLoading 		ifTrue: 			[ loadExecutor 				ifNil: [ 0 ]				ifNotNil: [ loadExecutor progress ] ]		ifFalse: [ 1 ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 13:32'!fullFileNameStringFor: keysOrOids of: aMaIndexDefinition 	^ repository directory fullNameFor: 		(self 			filenameFor: keysOrOids			of: aMaIndexDefinition)! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 4/13/2006 10:05'!hasIndexFor: attributeSymbol 	^ oidIndexesByAttribute includesKey: attributeSymbol! !!MagmaCollectionManager methodsFor: 'recovery' stamp: 'cmm 7/16/2006 22:41'!indexForFileId: anInteger 	"To support recovery of LargeCollections, we must replace the applied records to their prior-state, which is contained inside MaBeforeImageRecords."	| indexId |	indexId _ 2r111111111111111 bitAnd: anInteger.	"15-bit index #"	^ indexId = 0 		ifTrue: [ memberIndex ]		ifFalse: 			[ (anInteger maIsBitSet: 16) 				ifTrue: [ keyIndexes at: indexId ]				ifFalse: [ oidIndexes at: indexId ] ]! !!MagmaCollectionManager methodsFor: 'initialize-release' stamp: 'cmm 7/4/2006 18:36'!initialize	super initialize.	"we need them mapped to the correct attribute."	oidIndexesByAttribute _ Dictionary new.	keyIndexesByAttribute _ Dictionary new.	"and we must know the correct order, as well"	oidIndexes _ OrderedCollection new.	keyIndexes _ OrderedCollection new.	shouldStopLoading _ false! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 7/4/2006 18:34'!isLoading	^ loadProcess notNil and: [ loadProcess isTerminated not ]! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 3/16/2005 14:22'!isLocked	^lockedBy ~= nil! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 4/13/2006 17:12'!keysIndexForAttribute: aSymbol	aSymbol isNil ifTrue: [ ^ self memberIndex ].	^ keyIndexesByAttribute 		at: aSymbol		ifAbsent: 			[ MagmaSoftwareError signal: 'The keys index for ' , aSymbol , ' was not found. ' ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 8/6/2006 21:21'!load: aMagmaCollectionReaderSegment upTo: anInteger where: aMaExpression withObjects: aBoolean except: removedOids	(MaQueryExecutor 		collectionManager: self		expression: aMaExpression) 		load: aMagmaCollectionReaderSegment		upTo: anInteger		withObjects: aBoolean		except: removedOids.	^ aMagmaCollectionReaderSegment! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:39'!loadExecutor	^loadExecutor! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:39'!loadExecutor: aMaQueryExecutor	loadExecutor := aMaQueryExecutor! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/4/2006 18:33'!loadProcess	^loadProcess! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/4/2006 18:33'!loadProcess: aProcess	loadProcess := aProcess! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/26/2006 20:26'!loadProgress	^ self isLoading 		ifTrue: 			[ loadExecutor 				ifNil: [ 0 ]				ifNotNil: [ loadExecutor fractionComplete ] ]		ifFalse: [ 1 ]! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:22'!lockedBy	"Answers a MagmaClientConnection."	^lockedBy! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:13'!oidOfIndexesCollection: anInteger	oidOfIndexesCollection := anInteger! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 4/13/2006 17:12'!oidsIndexForAttribute: aSymbol	aSymbol isNil ifTrue: [ ^ self memberIndex ].	^ oidIndexesByAttribute 		at: aSymbol		ifAbsent: 			[ MagmaSoftwareError signal: 'The oids index for ' , aSymbol , ' was not found. ' ]! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 7/7/2005 15:19'!openIndex: aString	^ MaHashIndex open: (MaTransactionalFileStream fileNamed: aString)! !!MagmaCollectionManager methodsFor: 'accessing' stamp: 'cmm 7/4/2006 18:36'!pleaseStopLoading	shouldStopLoading _ true! !!MagmaCollectionManager methodsFor: 'overriding' stamp: 'cmm 3/16/2005 22:57'!process: aMaCollectionChanges recordResultsIn: aMaCommitResult	self		processLockIn: aMaCollectionChanges		using: aMaCommitResult connection.	self processRemovedIndexesIn: aMaCollectionChanges.	self		processAddsIn: aMaCollectionChanges		using: aMaCommitResult.	self		processRemovesIn: aMaCollectionChanges;		processChangedIndexValuesIn: aMaCollectionChanges;		processAddNewIndexValuesIn: aMaCollectionChanges! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 17:34'!processAddNewIndexValuesIn: aMagmaCollectionChanges 	"Serialize the new values for an index that is being built."	aMagmaCollectionChanges hasNewIndexValues ifFalse: [ ^ self ].	aMagmaCollectionChanges newIndexValues keysAndValuesDo: 		[ : eachAttribute : eachValues | 		| oidsIndex keysIndex |		oidsIndex _ self oidsIndexForAttribute: eachAttribute.		keysIndex _ self keysIndexForAttribute: eachAttribute.		eachValues do: 			[ : eachAssociation | 			eachAssociation key do: 				[ : eachKey | 				oidsIndex 					add: eachAssociation value					at: eachKey.				keysIndex					add: eachKey					at: eachAssociation value ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/11/2006 20:35'!processAddsIn: aMaCollectionChanges using: aMaCommitResult 	aMaCollectionChanges additionsDo: 		[ : eachOid : eachHashIndexArrays | 		| addedObjectOid |		addedObjectOid _ (MaOidCalculator isOidForNewObject: eachOid) 			ifTrue: [ aMaCommitResult permanentOids at: eachOid ]			ifFalse: [ eachOid ].		self 			addMember: addedObjectOid			atHashes: eachHashIndexArrays ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 17:29'!processChangedIndexValuesIn: aMaCollectionChanges 	aMaCollectionChanges changedKeySpecificationsDo: 		[ : each | 		| oidsIndex keysIndex |		oidsIndex _ self oidsIndexForAttribute: each attribute.		keysIndex _ self keysIndexForAttribute: each attribute.		(memberIndex includesKey: each object) ifTrue: 			[ each oldHashValues do: 				[ : eachHashKeyValue | 				oidsIndex 					remove: each oid					at: eachHashKeyValue.				keysIndex					remove: eachHashKeyValue 					at: each oid ].			each newHashValues do: 				[ : eachHashKeyValue | 				oidsIndex 					add: each oid					at: eachHashKeyValue.				keysIndex					add: eachHashKeyValue 					at: each oid ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 3/16/2005 22:58'!processLockIn: aMaCollectionChanges using: aMagmaConnection	aMaCollectionChanges hasLockSpecified		ifTrue:			[ aMaCollectionChanges isLocked				ifTrue: [ self beLockedBy: aMagmaConnection ]				ifFalse: [ self beLockedBy: nil ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 4/13/2006 17:19'!processRemovedIndexesIn: aMaCollectionChanges 	aMaCollectionChanges removedIndexesDo: 		[ : eachAttribute | 		{ (self oidsIndexForAttribute: eachAttribute).		(self keysIndexForAttribute: eachAttribute) } 			do: [ : eachHashIndex | self removeIndex: eachHashIndex ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 7/12/2006 23:29'!processRemovesIn: aMaLargeCollectionChanges 	aMaLargeCollectionChanges removedDo: 		[ : eachOid : eachHashIndexValuesArray | 		| didRemove |		didRemove _ memberIndex 			remove: self dummyValue			at: eachOid.		didRemove ifTrue: 			[ eachHashIndexValuesArray withIndexDo: 				[ : eachArray : x | 				eachArray do: 					[ : eachKeyValue | 					(oidIndexes at: x) 						remove: eachOid						at: eachKeyValue.					(keyIndexes at: x) 						remove: eachKeyValue						at: eachOid ] ] ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 3/16/2005 21:20'!recordConflictsBetween: aMagmaCollectionChanges and: challengingCommitLogEntry in: myCommitLogEntry	"Fail my result if any indexes have been added or removed since my last transaction boundary."	(challengingCommitLogEntry hasCommitted: oidOfIndexesCollection)		ifTrue:			[ myCommitLogEntry				failResultWith: challengingCommitLogEntry connection				on: oidOfIndexesCollection ].	"Fail my result if any objects being added or removed have been changed by any other session."	aMagmaCollectionChanges additionsDo:		[ : eachOid : eachHashIndexValues |		(challengingCommitLogEntry hasCommitted: eachOid)			ifTrue:				[ myCommitLogEntry					failResultWith: challengingCommitLogEntry connection					on: eachOid ] ].	aMagmaCollectionChanges removedDo:		[ : eachOid : eachHashIndexValues |		(challengingCommitLogEntry hasCommitted: eachOid)			ifTrue:				[ myCommitLogEntry					failResultWith: challengingCommitLogEntry connection					on: eachOid ] ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 3/16/2005 21:09'!recordGeneralConflictsWith: aMagmaLargeCollectionChanges in: aMaCommitLogEntry	"If its locked by someone else, no changes are allowed."	(self isLocked	and: [ aMaCommitLogEntry connection ~= lockedBy ])		ifTrue:			[ aMaCommitLogEntry				failResultWith: self lockedBy				on: aMagmaLargeCollectionChanges collectionOid ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/6/2005 12:32'!removeIndex: aMaHashIndex	aMaHashIndex close.	repository queueForDelete: aMaHashIndex filename! !!MagmaCollectionManager methodsFor: 'testing' stamp: 'cmm 7/4/2006 18:32'!shouldStopLoading	^ shouldStopLoading or: [ repository wantsToClose ]! !!MagmaCollectionManager methodsFor: 'private' stamp: 'cmm 6/5/2006 23:34'!upTo: anInteger inSegmentFromIndex: lowIndex	| keysAndValues |	keysAndValues _  		memberIndex			upTo: anInteger			keysAndValuesFromIndex: lowIndex.	^ MagmaCollectionSegment new		lastKnownSize: memberIndex size ;		startIndex: lowIndex ;		objects: keysAndValues first  "there are no 'values' in the member-index, the keys are the objects." ;		yourself! !!MaMethodContextStorage class methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:11'!newFor: aMethodContext	^ self new		initializeFrom: aMethodContext ;		yourself! !!MaMethodContextStorage methodsFor: 'as yet unclassified' stamp: 'cmm 11/12/2004 16:37'!asMethodContext	| cm |	^ (MethodContext newForMethod: (cm _ method asCompiledMethod))		privRefreshWith: cm ;		yourself! !!MaMethodContextStorage methodsFor: 'as yet unclassified' stamp: 'cmm 11/9/2004 15:14'!initializeFrom: aMethodContext	method _ MaCompiledMethodStorage newFor: aMethodContext method! !!MaObject class methodsFor: 'as yet unclassified' stamp: 'cmm 8/11/2005 13:18'!compileInitializingNewMethod	MaObject class		compile:'new	^ super new initialize'		classified: 'create'! !!MaObject class methodsFor: 'as yet unclassified' stamp: 'cmm 8/12/2005 17:21'!initialize	"For Squeak 3.7 and beyond, objects are initialized automatically.  For <= 3.6, including Jasmine (Croquet), initialization must be performed by the end-user program."	| imageVersion |	CompatibilityInitialized = true ifTrue: [ "already done." ^ self ].	imageVersion := SystemVersion current version.	imageVersion size > 'Squeak' size		ifTrue:			[ "Try to extract version number.."			| versionNumber |			versionNumber := [ (imageVersion copyFrom: 7 to: imageVersion size) asNumber ] on: Error do: [ : err | err return: nil ].			(versionNumber isNil "Jasmine" or: [ versionNumber < 3.7 ])				ifTrue:					[ self compileInitializingNewMethod ] ].	CompatibilityInitialized := true! !!MaObject methodsFor: 'copying' stamp: 'cmm 12/19/2002 23:23'!copyAttributes: anArray from: sourceObject	anArray do:		[ :each |		self			instVarNamed: each asString			put: (sourceObject instVarNamed: each) copy ]! !!MaObject methodsFor: 'private'!initialize	"Default, do nothing."! !!MaObject methodsFor: 'printing' stamp: 'cmm 4/22/2002 22:13'!printOn: aStream	super printOn: aStream.	aStream space.	self maPrintAbbreviatedOn: aStream! !!MaObjectBuffer commentStamp: 'cmm 5/1/2005 21:05' prior: 0!This class encapsulates a single object into its byteArray.  The 0-based buffer positions of my fields are:	0 = oid (6 bytes)	6 = physicalSize (3 bytes)	9 = control-fields (1 byte)		4 bits = buffer-type		4 bits = available	10 = classId (2 bytes)!!MaFixedObjectBuffer commentStamp: 'cmm 4/26/2005 08:13' prior: 0!This class encapsulates an object that has a fixed-size.  Most objects are fixed-size.  My 0-based buffer fields are:	(see superclass)	12 = classVersion (2 bytes)!!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 4/26/2005 08:13'!bufferPositionOfClassVersion	"Zero-based position."	^ 12! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:32'!bufferType	^ 3! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 22:05'!classVersion	^self 		uint: 16		at: self bufferPositionOfClassVersion! !!MaFixedObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 22:05'!classVersion: anInteger	self		uint: 16		at: self bufferPositionOfClassVersion		put: anInteger! !!MaFixedObjectBuffer methodsFor: 'creation' stamp: 'cmm 12/2/2004 12:35'!createObjectUsing: aMaObjectSerializer	| class skeleton indexedSize sourceDefinition inImageDefinition |	class _ self ensureClassUsing: aMaObjectSerializer.	sourceDefinition _ 		aMaObjectSerializer classIdManager			definitionForClassId: self classId			version: self classVersion.	inImageDefinition _ aMaObjectSerializer classIdManager inImageDefinition: class.	indexedSize _ self objectInstSize - sourceDefinition namedInstSize.	skeleton _ indexedSize = 0 ifTrue: [ class basicNew ] ifFalse: [ class basicNew: indexedSize ].	self instVarsDoWithIndex:		[ : eachOid : sourceIndex |  | targetIndex |		targetIndex _			inImageDefinition				indexOfInstVarCorrespondingTo: sourceIndex				of: sourceDefinition.		targetIndex > 0 			ifTrue:				[ skeleton					instVarAt: targetIndex					put: eachOid ]			ifFalse:				[ eachOid = MaOidCalculator oidForNil					ifFalse: 	[ aMaObjectSerializer recordTruncatedObject: skeleton ] ] ].	^ skeleton! !!MaFixedObjectBuffer methodsFor: 'building' stamp: 'cmm 3/27/2006 17:01'!establishReferencesFrom: anObject using: aMaObjectSerializer	1		to: anObject maInstSize		do:			[ : instVarIndex | | oid |			oid _ anObject instVarAt: instVarIndex.			oid ifNotNil: "could be nil if different class def"				[ anObject					instVarAt: instVarIndex					put: (aMaObjectSerializer objectWithOid: oid) ] ]! !!MaFixedObjectBuffer methodsFor: '*magma server' stamp: 'cmm 5/2/2005 12:05'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	aMagmaFileTraverser		graphFromPointers: self		do: oneArgBlock		using: aMaReadStrategy.	(aBoolean not and: [ aMagmaFileTraverser isOidForLargeCollection: self oid ])		ifTrue:			[ aMagmaFileTraverser				graphFromLargeCollection: self oid				do: oneArgBlock				using: aMaReadStrategy ]! !!MaFixedObjectBuffer methodsFor: '*magma client' stamp: 'cmm 9/20/2005 13:38'!isDifferent: anObject using: aMaObjectSerializer	"Only report anObject different if any of its *recorded* instVars changed, or if any of its *new* instVars is not nil."	| classIdManager inImageDefinition bufferDefinition |	anObject ifNil: [ ^ false ]. "WeakKeyDictionaries can have nil keys."	classIdManager := aMaObjectSerializer classIdManager.	inImageDefinition := classIdManager inImageDefinition: anObject maSerializationClass.	bufferDefinition := 		classIdManager			definitionForClassId: (classIdManager idForClass: anObject maSerializationClass)			version: self classVersion.	1 to: anObject maInstSize do:		[ : index |  | instVarIndexInBackup |		(anObject maIsTransient: index) ifFalse:			[ instVarIndexInBackup := bufferDefinition				indexOfInstVarCorrespondingTo: index				of: inImageDefinition.			(instVarIndexInBackup = 0 and: [ (anObject instVarAt: index) notNil ]) ifTrue: [ ^ true ].			(aMaObjectSerializer oidFor: (anObject instVarAt: index)) = (self maInstVarAt: instVarIndexInBackup) ifFalse: [ ^ true ] ] ].	^ false! !!MaFixedObjectBuffer methodsFor: 'building' stamp: 'cmm 11/29/2004 16:56'!populateBodyFor: storageObject using: aMaObjectSerializer	1		to: storageObject maInstSize		do:			[ :index |			self				maInstVarAt: index				put:					((storageObject maIsTransient: index)						ifTrue: [ MaOidCalculator oidForNil ]						ifFalse: [ aMaObjectSerializer oidFor: (storageObject instVarAt: index) ]) ]! !!MaFixedObjectBuffer methodsFor: 'building' stamp: 'cmm 10/21/2004 23:18'!populateHeaderFor: anObject storageObject: storageObject using: aMaObjectSerializer	| classVersion |	super		populateHeaderFor: anObject		storageObject: storageObject		using: aMaObjectSerializer.	classVersion _ 		aMaObjectSerializer classIdManager			currentVersionOfClass: (aMaObjectSerializer classFor: anObject).	self classVersion: classVersion! !!MaFixedObjectBuffer methodsFor: 'printing' stamp: 'cmm 12/1/2004 23:43'!printOn: aStream	super printOn: aStream.	self		maPrintAttributes: #(classVersion oids)		on: aStream! !!MaFixedObjectBuffer methodsFor: '*magma client' stamp: 'cmm 3/27/2006 17:02'!refresh: anObject using: aMagmaSession	| inImageDefinition linkDescriptionDefinition classIdManager |	anObject ifNil: [ ^ self ].  "WeakKeyDictionaries can have nil keys."	classIdManager _ aMagmaSession serializer classIdManager.	inImageDefinition _  classIdManager inImageDefinition: anObject maSerializationClass.	linkDescriptionDefinition _ classIdManager		definitionForClassId: (classIdManager idForClass: anObject maSerializationClass)		version: self classVersion.	self instVarsDoWithIndex:		[ : sourceOid : sourceIndex |  | targetIndex |		targetIndex _ 			inImageDefinition				indexOfInstVarCorrespondingTo: sourceIndex				of: linkDescriptionDefinition.		targetIndex > 0			ifTrue:				[ (anObject maIsTransient: targetIndex) ifFalse:					[ anObject						instVarAt: targetIndex						put: (aMagmaSession serializer objectWithOid: sourceOid) ] ]			ifFalse:				[ sourceOid = MaOidCalculator oidForNil					ifFalse:						[ aMagmaSession serializer recordTruncatedObject: anObject ] ] ]! !!MaObjectBuffer class methodsFor: 'private accessing' stamp: 'cmm 4/26/2005 08:00'!bufferClassFor: aByteArray startPos: anInteger	^ self bufferClasses at: 		(self			bufferTypeIn: aByteArray			startingAt: anInteger)! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 7/15/2002 23:04'!bufferClasses	^BufferClasses! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/26/2005 07:57'!bufferPositionOfControlFields	"Zero-based position of the control-fields (buffer-type and isStorageObject)."	^ 9! !!MaObjectBuffer class methodsFor: 'private accessing' stamp: 'cmm 4/27/2005 23:01'!bufferPositionOfPhysicalSize	"Zero-based logical position within this buffer's byteArray that contains the physical size of this buffer."	^ 6! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/26/2005 07:57'!bufferTypeIn: aByteArray startingAt: startPositionOfObjectBuffer	"The bufferType is stored in the 4 low-order bits of the controlFields."	^ (self 		controlFieldsIn: aByteArray		startingAt: startPositionOfObjectBuffer) bitAnd: 2r00001111! !!MaObjectBuffer class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:22'!byteArray: aByteArray startPos: anInteger	^self new		startPos: anInteger ;		byteArray: aByteArray ;		yourself! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/27/2005 22:59'!controlFieldsIn: aByteArray startingAt: startPositionOfObjectBuffer	^ aByteArray		maUint: 8		at: startPositionOfObjectBuffer + self bufferPositionOfControlFields! !!MaObjectBuffer class methodsFor: 'creation' stamp: 'cmm 7/10/2002 20:28'!createFromByteArray: aByteArray startPos: anInteger	^(self		bufferClassFor: aByteArray		startPos: anInteger)			byteArray: aByteArray			startPos: anInteger! !!MaObjectBuffer class methodsFor: 'required overrides' stamp: 'cmm 4/26/2005 08:15'!headerSize	"The number of bytes in each object record before the data for the object begins."	^ 14! !!MaObjectBuffer class methodsFor: 'initializing' stamp: 'cmm 5/2/2005 14:47'!initialize	"Called from preamble of MaObjectSerialization."	BufferClasses _ Array		with: MaByteObjectBuffer		with: MaVariableObjectBuffer		with: MaFixedObjectBuffer		with: MaVariableWordBuffer		with: MaStorageObjectBuffer! !!MaObjectBuffer class methodsFor: 'accessing' stamp: 'cmm 4/21/2005 15:43'!oidSize	^ 48! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 1/25/2005 14:58'!appendGraphNode: oid into: aMaSerializedGraphBuffer using: aMaReadStrategy currentDepth: anInteger minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	| buffer |	(alreadyAppendedSet includes: oid) ifTrue: [ ^self ].	alreadyAppendedSet add: oid.	buffer _ aMaObjectFiler		appendObject: oid		into: aMaSerializedGraphBuffer.	buffer		appendGraphUsing: aMaReadStrategy		into: aMaSerializedGraphBuffer		currentDepth: anInteger + 1		minDepth: minDepth		with: alreadyAppendedSet		filer: aMaObjectFiler! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 1/25/2005 14:01'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	1		to: self objectInstSize		do:			[ :varIndex | | oid |			(MaOidCalculator isOidForOptimizedObject: (oid _ self maInstVarAt: varIndex))				ifFalse:					[ | newMinDepth |					currentDepth < (						newMinDepth _							(aMaReadStrategy								depthOfAttribute: varIndex								onClassWithId: self classId								version: self classVersion) + currentDepth									max: minDepth)										ifTrue:											[ self												appendGraphNode: oid												into: aMaSerializedGraphBuffer												using: aMaReadStrategy												currentDepth: currentDepth												minDepth: newMinDepth												with: alreadyAppendedSet												filer: aMaObjectFiler ] ] ]! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 3/28/2005 21:53'!asSentientBuffer	"Answer the newwwwwww meeee!!  That's right!!  I've been injected	with the ByteArray-of-truth and now know what kind of buffer	I always wondered I was going to grow up to be."	^self species		createFromByteArray: byteArray		startPos: startPos! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 5/24/2005 17:20'!bufferPositionOfBytesToStore	"Default 1-based position of the byte within each byteArray that we start storing to disk at."	^ 7! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 4/27/2005 23:14'!bufferPositionOfClassId	"Zero-based position of the class id."	^ 10! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 07:57'!bufferPositionOfControlFields	"Zero-based position of the control-fields (buffer-type and isStorageObject)."	^ self class bufferPositionOfControlFields! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 11/19/2004 15:52'!bufferPositionOfInstVarAt: anInteger	"Answer the physical 0-based byte-position within the receivers byteArray	where the instVar with index anInteger is located."	^ self headerSize + ((anInteger - 1) * self slotSize)! !!MaObjectBuffer methodsFor: 'private'!bufferPositionOfOid	"Zero-based position within a buffer that the oid is at."	^0! !!MaObjectBuffer methodsFor: 'private'!bufferPositionOfPhysicalSize	"Zero-based logical position within the byteArray that contains the	physical size of this portion of the buffer (e.g., not including continuations)."	^self class bufferPositionOfPhysicalSize! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 07:35'!bufferType	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'private'!byteArray	^byteArray! !!MaObjectBuffer methodsFor: 'private'!byteArray: aByteArray	byteArray _ aByteArray! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 12:41'!classId	^self 		uint: 16		at: self bufferPositionOfClassId! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/21/2004 12:41'!classId: anInteger	self		uint: 16		at: self bufferPositionOfClassId		put: anInteger! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/30/2004 16:00'!classVersion	^ 1! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 08:03'!controlFields	^ self class		controlFieldsIn: byteArray		startingAt: startPos! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 08:08'!controlFields: anInteger	self		uint: 8		at: self class bufferPositionOfControlFields		put: anInteger! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:02'!copyWithNewBuffer	^ self copy postCopyWithNewBuffer! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 10/10/2004 00:03'!copyWithSameBuffer	^ self copy! !!MaObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 12:44'!createObjectUsing: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/21/2004 23:29'!ensureClassUsing: aMaObjectSerializer	^ (aMaObjectSerializer classIdManager		classForId: self classId		ifAbsent:			[ "going to materialize an instance of the missing class."			| sourceDefinition |			sourceDefinition _				(aMaObjectSerializer classIdManager classDefinitionsForId: self classId) last.  "the most-recent one is the best guess."			sourceDefinition createClassUsing: aMaObjectSerializer ])! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/21/2004 22:43'!ensureSpaceFor: storageObject	| totalSize requiredSpace |	requiredSpace _ self physicalSizeFor: storageObject.	(totalSize _ requiredSpace + self startPos) > 10000000		ifTrue:			 [ MaObjectSerializationSecurityViolation signal: 'Serializations beyond 10 megabytes are not allowed.' ].	totalSize > byteArray size ifTrue: [ self growTo: totalSize*2 ].	self physicalSize: requiredSpace! !!MaObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/22/2004 14:40'!establishReferencesFrom: anObject using: aMaObjectSerializer	"This is the second-stage of materializing anObject.  The first stage populated its instVars with oids, this stage now replaces those oids with the actual objects.  Typically, only Fixed and VariableObject buffers will need to do anything on this."! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 5/1/2005 22:57'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:09'!growTo: anInteger	self byteArray: (		(ByteArray new: anInteger)			replaceFrom: 1			to: byteArray size			with: byteArray			startingAt: 1)! !!MaObjectBuffer methodsFor: 'private'!headerSize	"The number of bytes in each object record before the addresses of its	'data' (instance variables, in the case of a NormalObjectBuffer) begins.	The zero-based position in any buffer where the value of the object	is stored, either the actual value or the address to it."	^self class headerSize! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:00'!independentCopy	^ self copy postIndependentCopy! !!MaObjectBuffer methodsFor: 'initializing'!initialize	super initialize.	startPos _ 0! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 12/2/2004 12:35'!instVarsDoWithIndex: twoArgBlock	1		to: self objectInstSize		do:			[ :index |			twoArgBlock				value: (self maInstVarAt: index)				value: index ]! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/21/2004 22:46'!isBytes	^ false! !!MaObjectBuffer methodsFor: '*magma client' stamp: 'cmm 11/23/2004 23:19'!isDifferent: anObject using: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:00'!isPointers	^ true! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 4/21/2005 15:44'!maInstVarAt: anInteger 	^ self 		uint: 48   "self class oidSize"		at: (self bufferPositionOfInstVarAt: anInteger)! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 4/21/2005 15:45'!maInstVarAt: anInteger put: oid	self		uint: 48  "self class oidSize"		at: (self bufferPositionOfInstVarAt: anInteger)		put: oid! !!MaObjectBuffer methodsFor: '*magma server' stamp: 'cmm 11/24/2004 13:35'!numberOfBytesToStore	"Answer the number of bytes that should be stored for this buffer.  This is used by Magma, which doesn't need to store the oid since that is kept in the oid table."	^self physicalSize - self bufferPositionOfBytesToStore + 1! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 12/2/2004 12:35'!objectInstSize	"Answer the capacity of this buffer to hold references to other objects."	^ self objectSize / self slotSize! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 12/2/2004 12:34'!objectSize	^ self physicalSize - self headerSize! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 4/27/2005 23:03'!oid	^self 		uint: 48  "self class oidSize"		at: self bufferPositionOfOid! !!MaObjectBuffer methodsFor: 'building' stamp: 'cmm 4/21/2005 15:47'!oid: anInteger	self		uint: 48  "self class oidSize"		at: self bufferPositionOfOid		put: anInteger! !!MaObjectBuffer methodsFor: 'reference access' stamp: 'cmm 4/21/2005 15:46'!oids	"This method is intended for printing only.  Use instVarsDoWithIndex: if you need to enumerate my oids."	| oids |	self objectInstSize isInteger ifFalse: [ ^ '** invalid **' ].	oids _ OrderedCollection new.	1		to: self objectInstSize		do: [ :index | oids add: (self maInstVarAt: index) ].	^ oids! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 12/1/2004 22:54'!physicalDataSizeNeededFor: storageObject	^ storageObject maSizeIn: self! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 10/20/2004 22:44'!physicalSize	"See method comment for more info."	^self 		uint: 24		at: self bufferPositionOfPhysicalSize! !!MaObjectBuffer methodsFor: 'building' stamp: 'cmm 3/24/2005 14:10'!physicalSize: anInteger	self		uint: 24		at: self bufferPositionOfPhysicalSize		put: anInteger! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 11/21/2004 22:25'!physicalSizeFor: storageObject	^ self headerSize + (self physicalDataSizeNeededFor: storageObject)! !!MaObjectBuffer methodsFor: 'building' stamp: 'cmm 11/21/2004 18:53'!populateBodyFor: storageObject using: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'building' stamp: 'cmm 10/21/2004 23:16'!populateHeaderFor: anObject storageObject: storageObject using: aMaObjectSerializer	"physicalSize was already set in ensureSpaceFor:, no need to calculate it again."	self		oid: (aMaObjectSerializer oidFor: anObject) ;		type: self bufferType ;		classId:			(aMaObjectSerializer classIdManager				idForClass: anObject maSerializationClass				ifAbsent: [ (aMaObjectSerializer classIdManager addNewClass: anObject maSerializationClass) id ])! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:01'!postCopyWithNewBuffer	byteArray _ byteArray copy! !!MaObjectBuffer methodsFor: 'copying' stamp: 'cmm 3/24/2005 12:00'!postIndependentCopy	byteArray _ byteArray copy! !!MaObjectBuffer methodsFor: 'printing' stamp: 'cmm 2/23/2005 14:39'!printOn: aStream	super printOn: aStream.	self		maPrintAttributes: #(oid classId objectInstSize)		on: aStream! !!MaObjectBuffer methodsFor: '*magma client' stamp: 'cmm 11/23/2004 22:54'!refresh: anObject using: aMaObjectSerializer	self subclassResponsibility! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 4/28/2005 12:50'!slotSize	^ 6   "self class oidSize / 8"! !!MaObjectBuffer methodsFor: 'accessing'!startPos	^startPos! !!MaObjectBuffer methodsFor: 'private'!startPos: anInteger	startPos _ anInteger! !!MaObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 23:41'!type	"Answer the type of buffer this is.		1=MaByteObjectBuffer		2=MaVariableObjectBuffer		3=MaFixedObjectBuffer		4=MaVariableWordBuffer 		5=MaStorageObjectBuffer		6=MaClassReferenceBuffer"	^ self controlFields bitAnd: 2r00001111! !!MaObjectBuffer methodsFor: 'building' stamp: 'cmm 4/27/2005 23:22'!type: anInteger	| controlFieldsValue withZeroedBits |	controlFieldsValue _ self controlFields.	"Zero out 4 lowest-order bits, that's where this field is stored."	withZeroedBits _ controlFieldsValue >> 4 << 4.	"Now and these bits with anInteger."	self controlFields: (withZeroedBits bitOr: anInteger)! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:09'!uint: numberOfBits at: position	^byteArray		maUint: numberOfBits		at: self startPos + position! !!MaObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!uint: numberOfBits at: zeroBasedIndexPosition put: valueInteger	^byteArray		maUint: numberOfBits		at: self startPos + zeroBasedIndexPosition		put: valueInteger! !!MaVariableBuffer commentStamp: 'cmm 12/1/2004 23:13' prior: 0!This class encapsulates an object that has a variable logical size, primarily Smalltalk collections including Byte-oriented collections such as ByteArray and String.I add no additional fields, only behavior.!!MaByteObjectBuffer commentStamp: '<historical>' prior: 0!I encapsulate objects that represented as a series of bytes; such as Strings, ByteArrays, CompiledMethods, etc.!!MaByteObjectBuffer methodsFor: '*magma server' stamp: 'cmm 1/25/2005 14:07'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	"Nothing to do for a byte-object."! !!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 12/1/2004 22:47'!asByteArray	^ self asByteObject: ByteArray! !!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 2/23/2005 14:38'!asByteObject: byteClass	^ self fillByteObject: (byteClass new: self objectSize)! !!MaByteObjectBuffer methodsFor: 'converting' stamp: 'cmm 12/1/2004 22:47'!asString	^ self asByteObject: String! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:32'!bufferType	^ 1! !!MaByteObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 22:41'!createObjectUsing: aMaObjectSerializer	"Objects with byte-based storage-objects can and do materialize now, rather than pointer-based storage-objects, which aren't actually well-formed until after establishingReferencesFrom:."	^ (self ensureClassUsing: aMaObjectSerializer)		maMaterializeFrom: self		using: aMaObjectSerializer! !!MaByteObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!fillByteObject: byteObject	^byteObject		replaceFrom: 1		to: byteObject size		with: byteArray		startingAt: self startPos + self headerSize + 1.! !!MaByteObjectBuffer methodsFor: '*magma server' stamp: 'cmm 5/1/2005 23:05'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	"nothing to do for a Byte-object buffer."! !!MaByteObjectBuffer methodsFor: 'testing' stamp: 'cmm 10/8/2004 12:09'!isBytes	^ true! !!MaByteObjectBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:01'!isPointers	^ false! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 7/18/2005 13:32'!numberToStoreFor: anObject using: aMaObjectSerializer	"This method stores either anObject itself or the oid for anInteger."	self shouldNotImplement! !!MaByteObjectBuffer methodsFor: 'actions' stamp: 'cmm 11/21/2004 19:04'!populateBodyFor: storageObject using: aMaObjectSerializer	self		replaceFrom: 1		to: storageObject size		with: storageObject		startingAt: 1! !!MaByteObjectBuffer methodsFor: 'private' stamp: 'cmm 4/3/2003 00:10'!replaceFrom: startInteger to: endInteger with: byteObject startingAt: startingInteger	byteArray		replaceFrom: self startPos + self headerSize + startInteger		to: self startPos + self headerSize + endInteger		with: byteObject		startingAt: startingInteger! !!MaByteObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 11:08'!slotSize	^ 1! !!MaStorageObjectBuffer commentStamp: 'cmm 5/1/2005 21:12' prior: 0!I am a buffer for an object that requires first-class, custom 'storage-object' for serialization.  I contain a MaSerializedGraphBuffer which can be used to materialize the first-class storage object.!!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 21:13'!bufferType	^ 5! !!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/2/2005 13:39'!buffersDo: aBlock	(MaSerializedGraphBuffer byteArray: self asByteArray) buffersDo: aBlock! !!MaStorageObjectBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 22:29'!createObjectUsing: aMaObjectSerializer	^ (self ensureClassUsing: aMaObjectSerializer)		maMaterializeFromGraph: self asByteArray		using: aMaObjectSerializer copyWithNewOidSpace! !!MaStorageObjectBuffer methodsFor: '*magma server' stamp: 'cmm 5/2/2005 13:49'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	"Though I am an object stored in a different representation, that representation is fully part of the repository, so enumerate the buffers my MaSerializedGraphBuffers buffers."	oneArgBlock value: self.	self buffersDo:		[ : eachBuffer |		"The buffers of a storage-object are never assigned permanent oids.  But if already-persistent objects are referenced from the storage-object, they will be and should be traversed normally."		(MaOidCalculator isOidForUserObject: eachBuffer oid)			ifTrue:				[ eachBuffer					graphDo: oneArgBlock					using: aMaReadStrategy					for: aMagmaFileTraverser					inDefinition: aBoolean ]			ifFalse:				[ oneArgBlock value: eachBuffer ] ]! !!MaVariableBuffer methodsFor: '*magma server' stamp: 'cmm 5/2/2005 12:04'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	aMagmaFileTraverser		graphFromPointers: self		do: oneArgBlock		using: aMaReadStrategy! !!MaVariableBuffer methodsFor: '*magma client' stamp: 'cmm 11/24/2004 09:23'!isDifferent: anObject using: aMaObjectSerializer	"To determine different for variable classes requires special-case, therefore dispatch."	^ anObject		maIsChangedFrom: self		using: aMaObjectSerializer! !!MaVariableBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anObject using: aMaObjectSerializer	"This method stores either anObject itself or the oid for anInteger."	self subclassResponsibility! !!MaVariableBuffer methodsFor: '*magma client' stamp: 'cmm 11/23/2004 23:10'!refresh: variableObject using: aMagmaSession	"Collections require special-case behavior to handle this, dispatch."	variableObject		maRefreshTo: self		using: aMagmaSession! !!MaVariableObjectBuffer commentStamp: 'cmm 10/21/2004 22:05' prior: 0!This class encapsulates variably-sized objects that reference objects.My buffer fields are (these are 0-based indexes, sorry):	(see superclass)	24 = inst var #1!!MaVariableObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:33'!bufferType	^ 2! !!MaVariableObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 12:44'!createObjectUsing: aMaObjectSerializer	| class |	class _ self ensureClassUsing: aMaObjectSerializer.	"Set and Dictionary are special-case for this because we store their logical rather than physical representation.  Therefore, dispatch to the class to build the skeleton for VariableObjectBuffers."	^ class maLoadVariableObjectFrom: self! !!MaVariableObjectBuffer methodsFor: 'creation' stamp: 'cmm 11/23/2004 10:28'!establishReferencesFrom: anObject using: aMaObjectSerializer	"Set and Dictionary require special-case processing, therefore we dispatch."	anObject maEstablishPointerReferencesUsing: aMaObjectSerializer! !!MaVariableObjectBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anObject using: aMaObjectSerializer	^ aMaObjectSerializer oidFor: anObject! !!MaVariableObjectBuffer methodsFor: 'building' stamp: 'cmm 11/28/2004 16:21'!populateBodyFor: storageObject using: aMaObjectSerializer	"Logical storage of collections varies by collection, therefore dispatch back to it."	storageObject		maStreamVariablyInto: self		for: aMaObjectSerializer! !!MaVariableObjectBuffer methodsFor: 'printing' stamp: 'cmm 12/1/2004 23:43'!printOn: aStream	super printOn: aStream.	self		maPrintAttributes: #(oids)		on: aStream! !!MaVariableWordBuffer methodsFor: '*magma server' stamp: 'cmm 1/25/2005 14:07'!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	"Nothing to do for a variable-word object."! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 5/1/2005 21:08'!bufferType	^ 4! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 12/2/2004 12:35'!createObjectUsing: aMaObjectSerializer	| answer |	answer _ (self ensureClassUsing: aMaObjectSerializer) basicNew: self objectInstSize.	1 to: self objectInstSize do:		[ : x |		answer			basicAt: x			put: (self wordAt: x) ].	^ answer! !!MaVariableWordBuffer methodsFor: '*magma server' stamp: 'cmm 5/1/2005 23:05'!graphDo: oneArgBlock using: aMaReadStrategy for: aMagmaFileTraverser inDefinition: aBoolean	"nothing to do for a word-object buffer."! !!MaVariableWordBuffer methodsFor: '*magma client' stamp: 'cmm 2/14/2005 10:33'!isDifferent: anObject using: aMaObjectSerializer	"To determine different for variable classes requires special-case, therefore dispatch."	anObject maInstSize ~= self objectInstSize ifTrue: [ ^ true ].	self instVarsDoWithIndex: 		[ : eachWord : index |		eachWord ~= (anObject instVarAt: index) ifTrue: [ ^ true ] ].	^ false! !!MaVariableWordBuffer methodsFor: 'testing' stamp: 'cmm 2/8/2005 18:01'!isPointers	^ false! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:12'!maInstVarAt: logicalPosition	^ self wordAt: logicalPosition! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:12'!maInstVarAt: logicalPosition put: anInteger	^ self		wordAt: logicalPosition		put: anInteger! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 12:41'!numberToStoreFor: anInteger using: aMaObjectSerializer	^ anInteger! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/21/2004 19:19'!populateBodyFor: storageObject using: aMaObjectSerializer	1		to: storageObject maInstSize		do:			[ :index |			self				wordAt: index				put: (storageObject instVarAt: index) ]! !!MaVariableWordBuffer methodsFor: 'printing' stamp: 'cmm 11/19/2004 17:28'!printOn: aStream	super printOn: aStream.	self		maPrintAttributes: #(words)		on: aStream! !!MaVariableWordBuffer methodsFor: '*magma client' stamp: 'cmm 2/14/2005 10:32'!refresh: variableObject using: aMagmaSession	"Collections require special-case behavior to handle this, dispatch."	self instVarsDoWithIndex:		[ : eachWord : eachIndex |		variableObject			instVarAt: eachIndex			put: eachWord ]! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/20/2004 11:08'!slotSize	^ 4! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:10'!wordAt: logicalPosition	^ self 		uint: 32		at: (self bufferPositionOfInstVarAt: logicalPosition)! !!MaVariableWordBuffer methodsFor: 'accessing' stamp: 'cmm 11/19/2004 15:09'!wordAt: logicalPosition put: anInteger	self		uint: 32		at: (self bufferPositionOfInstVarAt: logicalPosition)		put: anInteger! !!MaVariableWordBuffer methodsFor: 'printing' stamp: 'cmm 12/2/2004 12:35'!words	"This is intended for printing only."	self objectInstSize isInteger ifFalse: [ ^ '** invalid **' ].	^ (1 to: self objectInstSize) collect: [ : index | self maInstVarAt: index ]! !!MaObjectFiler commentStamp: 'cmm 5/25/2005 14:24' prior: 0!I am used to cache values committed in the server.  When a value is cached, we must remember from which commitPackage it came from in case the same object is updated again by a subsequent commitPackage, in which case we would not want to uncache the value when the first commitPackage is applied.!!MaObjectFiler class methodsFor: 'creation' stamp: 'cmm 9/24/2004 12:52'!create: aFileDirectory	^ self new create: aFileDirectory! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 4/28/2005 11:36'!maxDbSize	"Answers the maximum size of a Magma database as a power of 2.  Hmm, wow, 281 Terabytes huh..  This seems to be beyond any practical limits for a single repository; at least in year 2005, so we'll go with this for now."	^ 48! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 5/10/2005 19:04'!objectPointersFilename	^ 'objects.idx'! !!MaObjectFiler class methodsFor: 'accessing' stamp: 'cmm 5/10/2005 19:04'!objectsFilename	^ 'objects'! !!MaObjectFiler class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:23'!open: aFileDirectory	^ self new		directory: aFileDirectory ;		open ;		yourself! !!MaObjectFiler class methodsFor: 'accessing'!sizeOfEmptyRepository	"Answer in bytes."	^1024! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:38'!anchorOid	^ self primitiveAttributeAt: 'anchorOid'! !!MaObjectFiler methodsFor: 'building' stamp: 'cmm 12/2/2004 13:38'!anchorOid: anInteger	^ self		primitiveAttributeAt: 'anchorOid'		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 11/24/2004 15:33'!append: aMaObjectBuffer to: aMaSerializedGraphBuffer withDataAt: filePositionInteger	| startPos |	startPos _ aMaSerializedGraphBuffer bufferSize.	self		ensureByteArrayIn: aMaObjectBuffer		and: aMaSerializedGraphBuffer		canAccomodate: self trackSize + aMaObjectBuffer bufferPositionOfBytesToStore		bytesFrom: startPos + 1.	aMaSerializedGraphBuffer increaseBufferSizeBy:		(self			read: self trackSize			bytesInto: aMaObjectBuffer			and: aMaSerializedGraphBuffer			startingAt: startPos			filePosition: filePositionInteger)! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 1/25/2005 14:10'!appendObject: oidInteger into: aMaSerializedGraphBuffer	"Read a single object into aMaSerializedGraphBuffer and adjust its bufferSize accordingly."	| buffer |	preMadeObjectBuffer		byteArray: aMaSerializedGraphBuffer byteArray;		startPos: aMaSerializedGraphBuffer bufferSize.	self		append: preMadeObjectBuffer		to: aMaSerializedGraphBuffer		withDataAt: (self filePointerForOid: oidInteger).	buffer _ preMadeObjectBuffer asSentientBuffer.	"Set oid only after append because that is where the need for growth is checked."	buffer oid: oidInteger.	^buffer! !!MaObjectFiler methodsFor: 'debugging' stamp: 'cmm 5/3/2005 14:26'!bufferFor: oidInteger	| buffer |	buffer _ MaSerializedGraphBuffer new: 1000.	self		appendObject: oidInteger		into: buffer.	^ buffer rootBuffer! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:40'!classDefinitionsOid	^self primitiveAttributeAt: 'classDefinitionsOid'! !!MaObjectFiler methodsFor: 'building' stamp: 'cmm 12/2/2004 13:40'!classDefinitionsOid: anInteger	self		primitiveAttributeAt: 'classDefinitionsOid'		put: anInteger! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 9/24/2004 13:22'!close	file ifNotNil:		[ file closed ifFalse: [ file close ].		file _ nil ].	filePositionIndex ifNotNil:		[ filePositionIndex close.		filePositionIndex _ nil ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 16:42'!create: aFileDirectory	self		directory: aFileDirectory assureExistence ;		createDataFile ;		createFilePositionIndex.	^ self! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/7/2005 22:19'!createDataFile	(directory fileExists: self class objectsFilename)		ifTrue:			[ MagmaEnvironmentError signal: self dataFileName, ' already exists.' ].	self openObjectsFile.	file		maWrite: self class sizeOfEmptyRepository		bytesFromPosition: 1		of: (ByteArray new: self class sizeOfEmptyRepository)		atFilePosition: 0.	self		classDefinitionsOid: MaOidCalculator oidForNil;		definitionOid: MaOidCalculator oidForNil;		signature: MaObjectRepository recognitionSignature;		version: MagmaSession magmaVersion! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/11/2005 23:21'!createFilePositionIndex	filePositionIndex _ 		MaLargeArrayOfNumbers			create: (MaTransactionalFileStream fileStream: (FileStream fileNamed: self filePositionIndexFileName))			bitSize: self class maxDbSize! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 9/24/2004 13:02'!dataFileName	^ directory fullNameFor: self class objectsFilename! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:42'!definitionOid	^ self primitiveAttributeAt: 'definitionOid'! !!MaObjectFiler methodsFor: 'building' stamp: 'cmm 12/2/2004 13:42'!definitionOid: anInteger	^self		primitiveAttributeAt: 'definitionOid'		put: anInteger! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 9/26/2004 20:25'!directory	^ directory! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 12:55'!directory: aFileDirectory	directory _ aFileDirectory! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/30/2002 17:28'!ensureByteArrayIn: aMaObjectBuffer and: aMaSerializedGraphBuffer canAccomodate: anInteger bytesFrom: startPos	(startPos + anInteger) > aMaObjectBuffer byteArray size		ifTrue:			[ | bigByteArray beforeSize afterSize |			beforeSize _ aMaObjectBuffer byteArray size.			afterSize _ (aMaObjectBuffer byteArray size * 2) max: startPos + anInteger.			bigByteArray _ ByteArray new: afterSize.			bigByteArray				replaceFrom: 1				to: beforeSize				with: aMaSerializedGraphBuffer byteArray				startingAt: 1.			aMaObjectBuffer byteArray: bigByteArray.			aMaSerializedGraphBuffer byteArray: bigByteArray ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 6/1/2005 23:57'!ensureFilesOpen	file ifNotNil: [ file closed ifTrue: [ self openObjectsFile ] ].	filePositionIndex ifNil: [ self openFilePositionIndex ]! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 3/1/2005 17:36'!filePointerForOid: oidInteger	| answer |	answer _ filePositionIndex 		at: (MaOidCalculator indexPositionForOid: oidInteger)		ifAbsent: [ MagmaInvalidOid signal: oidInteger printString, ' is not a valid oid.' ].	answer = 0 ifTrue: [ MagmaInvalidOid signal: oidInteger printString, ' is not a valid oid.' ].	^ answer! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 9/24/2004 13:07'!filePositionIndexFileName	^ directory fullNameFor: self class objectPointersFilename! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 7/5/2005 23:39'!filesDo: twoArgBlock	twoArgBlock		value: file 		value: MaApplyRecord objectsFileId.	filePositionIndex filesDo:		[ : each |		twoArgBlock			value: each			value: MaApplyRecord filePositionsFileId ]! !!MaObjectFiler methodsFor: 'actions'!finalize	self close! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:32'!getNextOid	^MaOidCalculator oidForFilePositionIndexPosition: filePositionIndex size + 1! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 12/2/2004 13:45'!index: oidInteger at: filePositionInteger	^filePositionIndex		at: (MaOidCalculator indexPositionForOid: oidInteger)		put: filePositionInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 10/21/2004 12:53'!initialize	super initialize.	preMadeObjectBuffer _ MaObjectBuffer new.	usedByteArrays _ (1 to: 8) collect: [ :each | ByteArray new: each ].	self initializePrimitiveAttributeAddressesMap! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/29/2004 00:22'!initializePrimitiveAttributeAddressesMap	primitiveAttributeAddressesMap _ Dictionary new		at: 'signature' put: (Association key: 0 value: 64);		at: 0 put: 'signature';		at: 'version' put: (Association key: 8 value: 16);		at: 2 put: 'version';		at: 'booleanFlags' put: (Association key: 10 value: 8);		at: 10 put: 'booleanFlags';		at: 'definitionOid' put: (Association key: 11 value: 64);		at: 11 put: 'definitionOid';		"gap 19-26"		at: 'classDefinitionsOid' put: (Association key: 27 value: 64);		at: 27 put: 'classDefinitionsOid';		at: 'anchorOid' put: (Association key: 43 value: 64);		at: 43 put: 'anchorOid';		yourself! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 5/1/2003 17:37'!isOpen	^file notNil and: [ file closed not ]! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:29'!objectFileSize	^file size! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 6/14/2006 21:40'!open	(directory exists and: [ directory fileExists: self class objectsFilename ]) ifFalse: [ MagmaEnvironmentError signal: self dataFileName , ' not found.' ].	self openObjectsFile.	[ self validateSignature ] ifCurtailed: 		[ self close.		^ self ].	self openFilePositionIndex! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/7/2005 22:08'!openFile: unqualifiedName	| answer |	answer _ MaTransactionalFileStream fileStream: (directory fileNamed: unqualifiedName).	answer		ifNil: [ MagmaEnvironmentError signal: 'Could not open files in ', directory pathName ]		ifNotNil: [ answer binary ].	^ answer! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/8/2005 10:11'!openFilePositionIndex	filePositionIndex _		[ MaLargeArrayOfNumbers open:			(MaTransactionalFileStream fileNamed: self filePositionIndexFileName) ] ifCurtailed: [ self close ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 5/10/2005 19:08'!openObjectsFile	file _ self openFile: self class objectsFilename! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 7/15/2005 12:35'!physicalSizeOfObjectAt: filePointer	"Answers the size of the buffer currently residing at filePointer."	preMadeObjectBuffer startPos: 0.	file		maRead: MaObjectBuffer headerSize - preMadeObjectBuffer bufferPositionOfBytesToStore + 1		bytesFromPosition: preMadeObjectBuffer bufferPositionOfBytesToStore		of: preMadeObjectBuffer byteArray		atFilePosition: filePointer.	^ preMadeObjectBuffer physicalSize! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 12/30/2002 21:15'!primitiveAttributeAddressesMap	^primitiveAttributeAddressesMap! !!MaObjectFiler methodsFor: 'accessing'!primitiveAttributeAt: aString	| assoc |	^self		uint: (assoc _ self primitiveAttributeAddressesMap at: aString) value		at: assoc key! !!MaObjectFiler methodsFor: 'private'!primitiveAttributeAt: aString put: anInteger	| assoc |	self		uint: (assoc _ self primitiveAttributeAddressesMap at: aString) value		at: assoc key		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 6/16/2005 10:23'!read: numberOfBytes bytesInto: aMaObjectBuffer and: aMaSerializedGraphBuffer startingAt: startPos filePosition: anInteger	"startPos is 0-based, answer the physicalSize of the buffer read."	| physicalSize numberOfBytesRead numberOfBytesStored |	numberOfBytesRead _		file			maRead: numberOfBytes			bytesFromPosition: startPos + aMaObjectBuffer bufferPositionOfBytesToStore			of: aMaObjectBuffer byteArray			atFilePosition: anInteger.	"See if we have read enough, if not read the rest of the buffer."	numberOfBytesStored _ aMaObjectBuffer numberOfBytesToStore.	physicalSize _ aMaObjectBuffer physicalSize.	numberOfBytesStored > numberOfBytesRead		ifTrue:			[ | resumePosition |			resumePosition _ startPos + numberOfBytesRead + aMaObjectBuffer bufferPositionOfBytesToStore.			self				ensureByteArrayIn: aMaObjectBuffer				and: aMaSerializedGraphBuffer				canAccomodate: physicalSize				bytesFrom: resumePosition.			file				next: numberOfBytesStored - numberOfBytesRead				into: aMaSerializedGraphBuffer byteArray				startingAt: resumePosition ].	^ physicalSize! !!MaObjectFiler methodsFor: 'accessing'!signature	^self primitiveAttributeAt: 'signature'! !!MaObjectFiler methodsFor: 'private'!signature: anInteger	self		primitiveAttributeAt: 'signature'		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 8/12/2002 23:48'!trackSize	"This is the minimum number of bytes to read from disk for any object.	This particular value allows up to 32 instVars to be read at once."	"^MaAbstractObjectBuffer addressSize * 32 + MaNormalObjectBuffer headerSize"	^280 "same as above, but faster.."! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 9/24/2004 13:22'!uint: bits at: anInteger	| address bytes |	address _ self usedByteArray: (bytes _ bits / 8).	file		maRead: bytes		bytesFromPosition: 1		of: address		atFilePosition: anInteger.	^address		maUint: bits		at: 0! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 6/14/2005 16:19'!uint: bits at: filePointer put: anInteger	| ba bytes |	ba _ self usedByteArray: (bytes _ bits / 8).	ba		maUint: bits		at: 0		put: anInteger.	file		maWrite: bytes		bytesFromPosition: 1		of: ba		atFilePosition: filePointer.	file maCommit! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 6/5/2005 18:24'!unapplyFilePositionsFileUsing: aMaApplyRecord	filePositionIndex unapplyUsing: aMaApplyRecord! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 7/12/2005 22:46'!unapplyObjectsFileUsing: aMaApplyRecord	aMaApplyRecord unapplySelf: file physicalStream! !!MaObjectFiler methodsFor: 'recovery' stamp: 'cmm 6/13/2005 21:50'!unapplyUsing: aMaApplyRecord	"Reapply the contents of aMaBeforeImageRecord to the file it came from."	aMaApplyRecord fileId		caseOf:			{ [ MaApplyRecord objectsFileId ] -> [ self unapplyObjectsFileUsing: aMaApplyRecord ].			[ MaApplyRecord filePositionsFileId ] -> [ self unapplyFilePositionsFileUsing: aMaApplyRecord ] }		otherwise:			[ MagmaSoftwareError signal: 'unknown fileId' ]! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/16/2002 00:08'!usedByteArray: size	^usedByteArrays at: size! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 7/16/2002 00:01'!validateSignature	self signature = MaObjectRepository recognitionSignature		ifFalse:			[ MagmaUserError signal: 'This does not appear to be a Magma database.' ]! !!MaObjectFiler methodsFor: 'accessing' stamp: 'cmm 7/16/2002 21:53'!version	^self primitiveAttributeAt: 'version'! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 7/16/2002 21:53'!version: anInteger	self		primitiveAttributeAt: 'version'		put: anInteger! !!MaObjectFiler methodsFor: 'private' stamp: 'cmm 1/19/2005 15:40'!write: aMaObjectBuffer at: filePosition	"Note that the oid is stored in the filePositionsIndex, so there is no need to store it in the data file too.  The oid is the first 8-bytes of the buffer."	file		maWrite: aMaObjectBuffer numberOfBytesToStore		bytesFromPosition:			aMaObjectBuffer startPos + aMaObjectBuffer bufferPositionOfBytesToStore		of: aMaObjectBuffer byteArray		atFilePosition: filePosition! !!MaObjectFiler methodsFor: 'actions' stamp: 'cmm 12/2/2004 13:45'!write: aMaObjectBuffer index: aBoolean	"write a single object encapsulated by aMaObjectBuffer."	| filePosition |	filePosition _		aBoolean			ifTrue:				[ self					index: aMaObjectBuffer oid					at: file size ]			ifFalse:				[ | pos |				pos _ self filePointerForOid: aMaObjectBuffer oid.				(self physicalSizeOfObjectAt: pos) < aMaObjectBuffer physicalSize					ifTrue: [ self index: aMaObjectBuffer oid at: file size ]					ifFalse: [ pos ] ].	self		write: aMaObjectBuffer		at: filePosition! !!MaObjectRepository class methodsFor: 'creation' stamp: 'cmm 9/24/2004 12:50'!create: aFileDirectory controller: aMaRepositoryController	^ (self new repositoryController: aMaRepositoryController) create: aFileDirectory! !!MaObjectRepository class methodsFor: 'class initialization' stamp: 'cmm 7/13/2005 17:31'!initialize	super initialize.	SimulateOutage _ false.	RunningTestCases _ false! !!MaObjectRepository class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:23'!open: aFileDirectory controller: aMaRepositoryController	^self new		repositoryController: aMaRepositoryController ;		open: aFileDirectory ;		yourself! !!MaObjectRepository class methodsFor: 'accessing'!recognitionSignature	^5191969! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 1/18/2005 22:39'!abortTransactionFor: sessionId	^ transactionLog 		abortTransactionEntryFor: sessionId		repository: self! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 7/8/2005 15:58'!applyToCache: aMaCommitLogEntry	| newObjects |	newObjects _ aMaCommitLogEntry result newObjectBuffers.	aMaCommitLogEntry commitPackage objectsDo:		[ : eachBuffer |		filer			write: eachBuffer			index: (newObjects includesKey: eachBuffer oid) ].	"If writing regular objects caused any new LargeCollections we need to refresh my sessions view of the repository so I know about those collections because I'm about to update them."	(aMaCommitLogEntry commitPackage shouldServerRefresh or: [ aMaCommitLogEntry shouldServerRefresh ])		ifTrue:			[ repositoryController refreshView ].	self		updateLargeCollectionsIn: aMaCommitLogEntry commitPackage		recordResultsIn: aMaCommitLogEntry result! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 3/19/2005 10:59'!byteArrayAt: oidInteger using: aMaReadStrategy	^ (MaOidCalculator isOidForUserObject: oidInteger)		ifTrue:			[ (self				graphBufferAt: oidInteger				using: aMaReadStrategy) trimmedByteArray ]		ifFalse:			[ "When could this happen?  (Sigh), when they put an atomic in a MagmaLargeCollection."			(self session serializer serializeGraph:				(MaOidCalculator					objectWithOid: oidInteger					ifNone: [ MagmaSoftwareError signal: 'unknown oid' ])) trimmedByteArray ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/8/2005 14:21'!captureBeforeImages	"Capture a current description of the actual files in the places where we intend to change them.  We capture whether a file is new, whether it will be extended in length, and what file positions will be overwritten and what contents are there presently."	self dbFilesDo:		[ : eachTransactionalFile : eachFileId |		recoveryManager 			writeRollbackRecordsFor: eachTransactionalFile			fileId: eachFileId ].	recoveryManager flush! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:41'!classDefinitionsByteArray	"When initially creating the repository, before even the system root is	written, the classDefinitionsOid will be a new-object oid."	| loid |	^MaOidCalculator oidForNil = (loid _ filer classDefinitionsOid)		ifTrue:			[ (self serverSerializer serializeGraph: repositoryController definition classDefinitions) trimmedByteArray ]		ifFalse:			[ self				byteArrayAt: loid				using: MaBasicReadStrategy deep "we need it all" ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 7/9/2006 17:43'!close	self isOpen ifFalse: [ ^ self ].	wantsToClose _ true.	[ applyProcess notNil and: [ applyProcess isTerminated not ] ] whileTrue: [ (Delay forSeconds: 1) wait ].	[ largeCollectionManagers anySatisfy: [ : each | each isLoading ] ] whileTrue: [ (Delay forMilliseconds: 500) wait ].	self commitCritical: [ self isOpen ifTrue: [ self flushCache	"just to be sure" ] ].	filer ifNotNil: [ filer close ].	largeCollectionManagers do: [ : each | each close ].	recoveryManager ifNotNil: [ recoveryManager close ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/12/2005 12:57'!collectionFilenameFor: aMaLargeCollection	^ self directory fullNameFor:		(String streamContents:			[ : stream |			stream				print: (self session oidFor: aMaLargeCollection) ;				nextPut: $. ;				nextPutAll: aMaLargeCollection implementationClass suggestedFileExtension ])! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/12/2005 13:00'!collectionFilenameFor: oidInteger extension: aStringself maMarked: 'delete'.	^ self directory fullNameFor:		(String streamContents:			[ : stream |			stream				print: oidInteger ;				nextPut: $. ;				nextPutAll: aString ])! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 6/16/2005 10:53'!collectionManagerFor: oidInteger	^ self		collectionManagerFor: oidInteger		ifAbsent:			[ MagmaSoftwareError signal:				'MagmaCollection ' , oidInteger printString ,					' not found.  MaObjectRepository>>collectionManagerFor:' ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 6/16/2005 10:52'!collectionManagerFor: oidInteger ifAbsent: aBlock	^ largeCollectionManagers		at: oidInteger		ifAbsent: aBlock! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 7/5/2005 12:36'!commitCritical: aBlock	^ commitGuard critical: aBlock! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 5/30/2005 22:28'!create: aFileDirectory	filer _ MaObjectFiler create: aFileDirectory.	nextOid _ filer getNextOid.	recoveryManager _ MaRecoveryManager open: self directory.	^ self! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/8/2005 14:07'!dbFilesDo: twoArgBlock	"Value twoArgBlock with each database file and its fileId."	filer filesDo: twoArgBlock.	largeCollectionManagers do: [ : each | each filesDo: twoArgBlock ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:43'!definitionByteArray	| oid |	^MaOidCalculator oidForNil = (oid _ filer definitionOid)		ifTrue:			[ (self serverSerializer serializeGraph: repositoryController definition) trimmedByteArray ]		ifFalse:			[ self				byteArrayAt: oid				using: MaBasicReadStrategy deep "we need it all" ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/7/2005 10:13'!deleteApplyFile	self directory		rename: recoveryManager class applyFilename		toBe: 			(self directory				nextNameFor: recoveryManager beforeImagesBaseFilename				extension: recoveryManager imagesExtension)! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 9/24/2004 15:42'!directory	^ filer directory! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 6/11/2006 21:30'!ensureManagerCreatedFor: aMagmaLargeCollection 	^ largeCollectionManagers 		at: (self session oidFor: aMagmaLargeCollection)		ifAbsentPut: [ aMagmaLargeCollection newManagerUsing: self ]! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 5/14/2005 18:08'!ensureReadStrategy: aMaReadStrategy forSession: sessionId	| strategy |	^(strategy _		self			renewCurrentReadStrategy: aMaReadStrategy			for: sessionId)				ifNil: [ self systemReadStrategy ] 				ifNotNil: [ strategy ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/16/2005 11:04'!fileManagerFor: aMaApplyRecord ifPresent: oneArgBlock ifAbsent: aBlock	| fileManager |	fileManager _ aMaApplyRecord fileId		caseOf:			{ [ MaApplyRecord objectsFileId ] -> [ filer ].			[ MaApplyRecord filePositionsFileId ] -> [ filer ] }		otherwise:			[ (self 				collectionManagerFor: aMaApplyRecord collectionOid				ifAbsent: [ ^ aBlock value ]) indexForFileId: aMaApplyRecord fileId ].	^ oneArgBlock value: fileManager! !!MaObjectRepository methodsFor: 'accessing'!filer	^filer! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/8/2005 14:20'!flushCache	"Flush all caches as an uncorruptible unit-of-work.  If this forked code completes all files are flushed.  Should a power outage occur somewhere in the middle, the recovery will reverse what had been written so far."	recoveryManager beginApply.	self 		captureBeforeImages ;		flushIndividualCaches.	SimulateOutage ifTrue: [ self simulateOutage ].	recoveryManager endApply! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/11/2005 10:06'!flushCacheSoon	"Flushing is horribly expensive, but essential to ensure we can survive a power-outage without corruption.  To balance these opposing forces, we apply and flush only at certain interval, and only in the background.  This method ensures an apply will occur soon."	applyProcess ifNil:		[ applyProcess _			[ (Delay forSeconds: repositoryController cacheFlushFrequency) wait.			self commitCritical:				[ self flushCache.				applyProcess _ nil ] ] fork.		applyProcess name: 'flush Magma cache' ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/8/2005 14:11'!flushIndividualCaches	self dbFilesDo: [ : eachFile : eachFileId | eachFile maCommit: true ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/26/2006 17:54'!fractionLoaded: collectionOid	^ (self collectionManagerFor: collectionOid) loadProgress! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 12/2/2004 13:25'!getNextOid	^nextOid _ nextOid + 1! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 8/6/2006 18:32'!getTrunkFor: collectionOid expression: aMaTerm 	| executor |	executor _ MaQueryExecutor 		collectionManager: (self collectionManagerFor: collectionOid)		expression: aMaTerm.	^ executor trunk! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 1/25/2005 14:04'!graphBufferAt: oidInteger using: aMaReadStrategy	"Answers a MaSerializedGraphBuffer."	| answer rootBuffer |	answer _ MaSerializedGraphBuffer new: 400.	rootBuffer _ 		filer			appendObject: oidInteger			into: answer.	rootBuffer		appendGraphUsing: aMaReadStrategy		into: answer		currentDepth: 1		minDepth: aMaReadStrategy minimumDepth		with: Set new		filer: filer.	^ answer! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 7/19/2006 18:16'!hashKeysReferencing: eachOid inIndexesOf: sourceManager using: aMagmaCollectionManager 	| hashesByIndex |	hashesByIndex _ OrderedCollection new.	"Normally there will be just one index at this time (building a sort result), but be generic anyway.."	aMagmaCollectionManager collection indexesDo: 		[ : eachIndex | 		| eachKeysHdx eachHashes |		eachHashes _ OrderedCollection new.		eachKeysHdx _ sourceManager keysIndexForAttribute: eachIndex attribute.		eachKeysHdx 			keysAndValuesFrom: eachOid			startingAt: 1			do: [ : eachOidAgain : eachKeyLocation | eachHashes add: eachKeyLocation ]			until: [ : eachOidAgain : eachKeyLocation | eachOidAgain > eachOid ].		hashesByIndex add: eachHashes ].	^ hashesByIndex! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 6/12/2006 13:02'!initialize	super initialize.	transactionLog _ MaTransactionLog new.	largeCollectionManagers _ Dictionary new.	sessions _ Dictionary new.	commitGuard _ Monitor new! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 2/1/2005 22:45'!initializeClassDefinitionsSpecialOids	"This collection of special oids can grow.  When it does, clients need to know about it."	repositoryController definition classDefinitions do:		[ : each |		(repositoryController session isPersistent: each)			ifTrue:				[ transactionLog					onChangeOf: (repositoryController session oidFor: each "OrderedCollection of definitions")					clientsShould: #refreshClassVersions ] ]! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 2/1/2005 22:47'!initializeSpecialOidsList	"See MagmaSession>>#handleSpecialOidNotifications:"	| classDefinitions session |	classDefinitions _ repositoryController definition classDefinitions.	session _ repositoryController session.	(session isPersistent: classDefinitions)		ifTrue:			[ transactionLog				onChangeOf: (repositoryController session oidFor: repositoryController definition classDefinitions)				clientsShould: #refreshClassDefinitions ].	self initializeClassDefinitionsSpecialOids! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 2/9/2005 10:26'!initializeSystemReadStrategyUsing: aMaClassIdManager	"The object and its immediate variables"self maMarked: 'dev'.  "Should minimumDepth be 0?  If not, then perhaps we don't need to extend any Collection 1-level further, since the point for it was to merely get its immediately referenced objects...??"	systemReadStrategy _ MaReadStrategy minimumDepth: 1.	systemReadStrategy makeReadyForUseUsing: aMaClassIdManager! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 11/1/2004 10:23'!isOpen	^ filer notNil and: [ filer isOpen ]! !!MaObjectRepository methodsFor: 'accessing'!largeCollectionManagers	^largeCollectionManagers! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 7/26/2006 17:22'!load: aMagmaCollection using: aMaTerm from: oidInteger forSession: sessionId distinct: aBoolean 	| permanentOid result cm newManager |	permanentOid _ self getNextOid.	(self sessionWithId: sessionId) addTransientMagmaCollection: permanentOid.	result _ (MaReducedReaderResult new)		collectionOid: permanentOid ;		yourself.	self session serializer 		oidOf: aMagmaCollection		is: permanentOid.	newManager _ (self ensureManagerCreatedFor: aMagmaCollection) createNewLargeCollection.	(cm _ self collectionManagerFor: permanentOid) createSupplementaryIndexes.	newManager loadProcess: (		[ self 			loadMemberIndexOf: cm			using: aMaTerm			from: oidInteger			distinct: aBoolean ] forkAt: Processor userBackgroundPriority).	newManager loadProcess name: 'loading ', permanentOid printString.	^ result! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 7/26/2006 17:39'!loadMemberIndexOf: aMagmaCollectionManager using: aMaTerm from: oidInteger distinct: wantsDistinct 	"Load memberIndex from the results expression aMaTerm."	| executor sourceManager |	sourceManager _ self collectionManagerFor: oidInteger.	executor _ MaQueryExecutor 		collectionManager: sourceManager		expression: aMaTerm.	aMagmaCollectionManager loadExecutor: executor.	executor 		trunkFrom: 1		do: 			[ : eachKey : eachOid | 			| canPossiblyAdd |			canPossiblyAdd _ (wantsDistinct and: [ aMagmaCollectionManager memberIndex includesKey: eachOid ]) not.			(canPossiblyAdd and: 				[ aMaTerm 					shouldInclude: eachOid					using: sourceManager ]) ifTrue: 				[ | hashesByIndex |				hashesByIndex _ self 					hashKeysReferencing: eachOid					inIndexesOf: sourceManager					using: aMagmaCollectionManager.				"rare, but possible that it would be made persistent and the commit changes to while sorting and then accessed, therefore critical.."				self commitCritical: 					[ aMagmaCollectionManager 						addMember: eachOid						atHashes: hashesByIndex.					self flushCacheSoon ] ] ]		until: [ aMagmaCollectionManager shouldStopLoading ]! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 6/7/2004 15:20'!newSessionFor: userIdString numberOfChallengers: anInteger	"Answer an Association whose key is the session id, value is the classMap	array for that session."	| connection |	connection _		transactionLog			newSessionFor: userIdString			numberOfChallengers: anInteger.	sessions at: connection sessionId put: connection.	^(Array new: 3)		at: 1			put: connection sessionId;		at: 2			put: self classDefinitionsByteArray ;		at: 3			put: self definitionByteArray;		yourself! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 1/28/2005 00:04'!newTransactionFor: sessionIdInteger	(transactionLog entryFor: sessionIdInteger) isCommitEntry		ifTrue:			[ MagmaSoftwareError signal: 'Already in a transaction.' ].	^ transactionLog		newTransactionFor: sessionIdInteger		repository: self! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 4/13/2006 17:11'!numberOfEntriesFrom: lowKeyInteger to: highKeyInteger inLargeCollection: collectionOid on: attributeSymbol 	| index |	index _ (self collectionManagerFor: collectionOid) 		oidsIndexForAttribute: attributeSymbol.	^ index 		numberOfEntriesFrom: lowKeyInteger		to: highKeyInteger! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:26'!objectCount	^nextOid - MaOidCalculator firstUserObjectOid! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:29'!objectFileSize	^filer objectFileSize! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 7/4/2006 16:18'!open: aFileDirectory 	filer _ MaObjectFiler open: aFileDirectory.	[ self validateVersion ] ifCurtailed: [ filer close ].	nextOid _ filer getNextOid.	recoveryManager _ MaRecoveryManager open: aFileDirectory.	wantsToClose _ false! !!MaObjectRepository methodsFor: 'building' stamp: 'cmm 3/16/2005 23:06'!openLargeCollectionIfNecessary: aMagmaLargeCollection	(self ensureManagerCreatedFor: aMagmaLargeCollection) ensureOpen! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/1/2005 23:56'!primitiveRecover	"This is needed in very rare, dire circumstances where the server was actually writing its own system-definition when an outage occurred.  In that case the repository will not even be able to open normally to get to the normal recovery.  That condition is trapped for any Error and sent here to try opening all files in the directory and then doing a normal unapply (rollback).  Theoretically, that should work."	filer ensureFilesOpen.	recoveryManager primitiveRecoverUsing: self! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 6/6/2005 12:42'!queueForDelete: filename	"When removing indexees, we actually remove the supporting file.  However, we don't want to do that until the commit actually succeeds.  Therefore, we a queue the files to deleted until the commit succeeds, then we delete it."	recoveryManager queueForDelete: (self directory fullNameFor: filename)! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 5/14/2005 18:11'!read: oidInteger for: sessionId using: aMaReadStrategy	| result |	result _ MaReadResult byteArray:		(self			byteArrayAt: oidInteger			using:				(self 					ensureReadStrategy: aMaReadStrategy					forSession: sessionId)).	self		renewServerNotificationsIn: result		for: sessionId.	^ result! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 5/14/2005 18:27'!readAnchorFor: sessionId using: aMaReadStrategy	| anchorOid |	^ MaOidCalculator oidForNil = (anchorOid _ filer anchorOid)		ifTrue:			[ (self serverSerializer serializeGraph: MaRootAnchor new) trimmedByteArray ]		ifFalse:			[ self				read: anchorOid				for: sessionId				using: aMaReadStrategy ]! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 7/16/2005 16:56'!recoverIfNecessary	^ recoveryManager isRollbackNeeded		ifTrue:			[ RunningTestCases ifFalse: [ MagmaRecoveryNeeded signal: 'A partially flushed cache has been detected!!  This repository will now be recovered.' ].			recoveryManager rollbackUsing: self. "NOTE:  This replaces me in my repositoryController, that's why we return from this method after the rollback, to unwind this now-stale instance and re-call in the new instance."			true ]		ifFalse:			[ recoveryManager				reapplyCommitPackagesUsing: self ;				resetFiles.			false ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 8/6/2006 21:22'!refreshSegmentIn: aMaRefreshSegmentRequest 	(self collectionManagerFor: aMaRefreshSegmentRequest collectionOid) 		load: aMaRefreshSegmentRequest segment		upTo: aMaRefreshSegmentRequest quantity		where: aMaRefreshSegmentRequest expression		withObjects: aMaRefreshSegmentRequest loadObjects		except: aMaRefreshSegmentRequest exceptions.	aMaRefreshSegmentRequest segment 		collectBuffers: aMaRefreshSegmentRequest sessionId		from: self		using: aMaRefreshSegmentRequest readStrategy.	self 		renewServerNotificationsIn: aMaRefreshSegmentRequest segment		for: aMaRefreshSegmentRequest sessionId.	^ aMaRefreshSegmentRequest segment! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 6/13/2006 00:01'!removeManager: collectionOid 	largeCollectionManagers 		removeKey: collectionOid		ifAbsent: 			[ "no foul no harm"			 ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/4/2006 18:56'!removeSessionFor: sessionId 	self removeTransientMagmaCollectionsFor: sessionId.	sessions 		removeKey: sessionId		ifAbsent: [ MagmaUserError signal: 'session not connected.' ].	transactionLog 		removeEntryForSessionId: sessionId		ifAbsent: [ MagmaUserError signal: 'session not connected.' ]! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 8/2/2006 21:34'!removeTransientMagmaCollectionsFor: sessionId 	"any sort operations that had required building of a transient MagmaCollection that never actually got committed to the db should have their files cleaned up."	(self sessionWithId: sessionId) ifNotNilDo: 		[ : aMagmaClientConnection | 		aMagmaClientConnection transientMagmaCollectionOidsDo: 			[ : each | 			| cm |			cm _ self 				collectionManagerFor: each				ifAbsent: 					[ "seems like this shouldn't happen, but we probably shouldn't complain if it does"					nil ].			cm pleaseStopLoading.			[ cm isLoading ] whileTrue: [ (Delay forMilliseconds: 250) wait ].			self				commitCritical: [ cm delete ] ;				removeManager: each ] ]! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 4/28/2003 23:51'!renewCurrentReadStrategy: aMaReadStrategy for: sessionId	| session |	session _ self sessionWithId: sessionId.	aMaReadStrategy ifNotNil: [ session currentReadStrategy: aMaReadStrategy ].	^session currentReadStrategy! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 12/16/2002 23:52'!renewRefreshFlagFor: sessionId	^(transactionLog entryFor: sessionId) renewRefreshFlag! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/25/2005 17:03'!renewServerNotificationsIn: aMagmaServerResult for: sessionId	self		renewServerNotificationsIn: aMagmaServerResult		for: sessionId		from: (transactionLog entryFor: sessionId)! !!MaObjectRepository methodsFor: 'actions' stamp: 'cmm 1/25/2005 17:02'!renewServerNotificationsIn: aMagmaServerResult for: sessionId from: aMaTransactionLogEntry	aMagmaServerResult		serverNotifications: aMaTransactionLogEntry renewServerNotifications ;		shouldRefresh: (self renewRefreshFlagFor: sessionId).	aMagmaServerResult serverNotifications keysAndValuesDo:		[ : eachKey : eachSet |		aMagmaServerResult serverNotifications			at: eachKey			put: (eachSet collect: [ : eachOid | self byteArrayAt: eachOid using: MaReadStrategy deep ]) ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/8/2005 17:16'!repositoryController	^ repositoryController! !!MaObjectRepository methodsFor: 'building'!repositoryController: aMaRepositoryController	repositoryController _ aMaRepositoryController.	aMaRepositoryController repository == self ifFalse: [ aMaRepositoryController repository: self ]! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 12/31/2002 12:56'!serverSerializer	^repositoryController serverSerializer! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 12/31/2002 12:55'!session	^repositoryController session! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 6/9/2005 14:40'!sessionWithId: anInteger	^sessions 		at: anInteger		ifAbsent: [ MagmaSessionLost signal ]! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 5/2/2003 15:05'!sessions	^sessions! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 6/14/2005 17:30'!sizeOfLargeCollection: oidInteger	^ (self collectionManagerFor: oidInteger) size! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 7/8/2005 15:39'!submitAll: aMaCommitPackage for: sessionId beginAnother: aBoolean	"Save all of the serialized objects in aMaCommitPackage to the repository.	If any of the objects in aMaCommitPackage have been changed by other transactions	signal a commit failure."	| entry |	entry _ 		transactionLog			renewEntryFor: sessionId			beginAnother: aBoolean			for: self.	entry isCommitEntry ifFalse: [ MagmaUserError signal: 'No transaction to commit.' ].	entry		determineResultFor: aMaCommitPackage		using: largeCollectionManagers.	entry result hasConflicts		ifTrue:			[ MagmaCommitError new				result: entry result;				signal ]		ifFalse:			[ entry commitPackage: aMaCommitPackage.			self write: entry ].	"Make sure system session doesn't exceed maximumNumberOfChallengers"	self maMarked: 'performance'.  "the repositoryController session never enters a transaction, so it should be sensitive to the maximumNumberOfChallengers built-in mechanism for suggesting an abort.  Let's test that.."	(sessionId ~= repositoryController sessionId		and: [ transactionLog isFirstEntryFor: repositoryController sessionId ])			ifTrue: [ repositoryController refreshView ].	^entry result! !!MaObjectRepository methodsFor: 'read strategies' stamp: 'cmm 9/1/2003 19:11'!systemReadStrategy	^systemReadStrategy! !!MaObjectRepository methodsFor: 'recovery' stamp: 'cmm 6/16/2005 11:12'!unapply: aMaApplyRecord	"Reapply the contents of aMaApplyRecord to the file it came from."	self 		fileManagerFor: aMaApplyRecord		ifPresent: [ : fileManager | fileManager unapplyUsing: aMaApplyRecord ]		ifAbsent: 			[ "This could happen if a new file was created (i.e., a new large-collection) but the system crashed before the writes of the definition occurred; in which case the largeCollectionManager would not be able to be opened."			aMaApplyRecord "should be a MaNewFileRecord" 				unapplySelf:					(self directory fileNamed: aMaApplyRecord filename) ]! !!MaObjectRepository methodsFor: 'client-requests' stamp: 'cmm 4/12/2006 21:14'!upTo: anInteger oidsFromIndex: startIndex inLargeCollection: collectionOid using: aMaReadStrategy forSession: sessionId 	| segmentResult |	segmentResult _ (self collectionManagerFor: collectionOid) 		upTo: anInteger		inSegmentFromIndex: (startIndex max: 1).	segmentResult 		collectBuffers: sessionId		from: self		using: aMaReadStrategy.	self 		renewServerNotificationsIn: segmentResult		for: sessionId.	^ segmentResult! !!MaObjectRepository methodsFor: 'magma-collections' stamp: 'cmm 7/12/2005 11:25'!updateLargeCollectionsIn: aMaCommitPackage recordResultsIn: aMaCommitResult	"The repositoryControllers sessions view of the repository must be completely refreshed, it must know about all new collections."	aMaCommitPackage allLargeCollectionChangesDo:		[ : each |		each isNewCollection			ifTrue:				[ | permanentOid mc |				permanentOid _ aMaCommitResult permanentOids at: each collectionOid ifAbsent: [ MagmaSoftwareError signal: 'expected to find permanent oid for new collection ', each collectionOid printString ].				each collectionOid: permanentOid.				mc _ 					self session 						objectWithOid: each collectionOid 						ifAbsent:							[ MagmaSoftwareError signal: 'expected to know about MagmaCollection ', each collectionOid, ' here.' ].				(self ensureManagerCreatedFor: mc) 	createNewLargeCollection ].		each hasAddedIndexes 			ifTrue:				[ (self collectionManagerFor: each collectionOid) createSupplementaryIndexes ] ].	aMaCommitPackage allLargeCollectionChangesDo:		[ :each |		(self collectionManagerFor: each collectionOid)			process: each			recordResultsIn: aMaCommitResult ]! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 6/14/2006 21:43'!validateVersion	filer version = MagmaSession magmaVersion		ifFalse:			[ MagmaUserError signal: 'This database requires code version ', self version printString, '.  You are running version ', MagmaSession magmaVersion printString ]! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 4/21/2003 16:02'!version	^filer version! !!MaObjectRepository methodsFor: 'accessing' stamp: 'cmm 7/4/2006 16:20'!wantsToClose	^ wantsToClose ! !!MaObjectRepository methodsFor: 'private' stamp: 'cmm 7/17/2005 00:29'!write: aMaCommitLogEntry	aMaCommitLogEntry		registerUsing: self ;		link ;		record.	aMaCommitLogEntry hasAnyCommitted		ifTrue:			[ transactionLog challengeEntriesWith: aMaCommitLogEntry ].	aMaCommitLogEntry didCommitSpecialOid		ifTrue:			[ self initializeClassDefinitionsSpecialOids ].	self commitCritical:		[ | trimmedEntry |		trimmedEntry _ aMaCommitLogEntry trimmedCopy.		self applyToCache: trimmedEntry "because the trimmedEntry must work on recovery!!".		recoveryManager 			log: trimmedEntry			flush: repositoryController flushAggressively.		self flushCacheSoon ]! !!MaObjectSerializer class methodsFor: 'creation' stamp: 'cmm 10/15/2002 22:15'!new	^self new: 1000! !!MaObjectSerializer class methodsFor: 'creation'!new: anInteger	^super new optimumByteArraySize: anInteger! !!MaObjectSerializer class methodsFor: 'debugging' stamp: 'cmm 8/23/2005 18:56'!testMaterialize: anObject	| s1 graphBuffer |	s1 := self new.	graphBuffer := s1 serializeGraph: anObject.	^ self new		classDefinitionsByteArray: s1 classDefinitionsByteArray ;		materializeGraph: graphBuffer byteArray copy! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 19:49'!append: anObject	"Append only anObject to the receiver.  However, in the case where anObject is stored via a storage-object (see #maAsStorageObject), the entire graph of the storage object must be stored."	| storageObject |	storageObject _ anObject maAsStorageObject.	anObject maWantsPreSerialization ifTrue: [ self preSerialize: storageObject ].	storageObject ~~ anObject		ifTrue:			[ "This is a storage object, so serialize it into an inner serialized graph ByteArray."			storageObject _ (self copyWithNewBuffer serializeGraph: storageObject) trimmedByteArray ].	self graphBuffer increaseBufferSizeBy:		(self			bufferFor: anObject			storageObject: storageObject			startingAt: self graphBuffer bufferSize)				physicalSize.	"Since the need is so scarce anyway, if you order pre-serialization, you get post too."	anObject maWantsPreSerialization ifTrue: [ self postSerialize: storageObject ]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/29/2004 17:12'!appendGraph: anObject do: oneArgBlock	"Answer a MaSerializedObjectBuffer containing anObject and all objects	it can reach, serialized into aByteArray."	self beBusy.	anObject		maGraphDo:			[ : path : parent : index |			(path last				maShouldAppendWithPath: path				parent: parent				index: index)				ifTrue:					[ self append: path last.					oneArgBlock value: path last ] ]		using: self traversalStrategy.	self beBored.	^ self graphBuffer! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/29/2002 23:22'!beBored	amBusy _ false! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/29/2002 23:33'!beBusy	amBusy _ true! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 21:43'!bufferFor: anObject storageObject: storageObject startingAt: anInteger	| buffer |	buffer _ anObject == storageObject		ifTrue: [ (storageObject maSelectPreMadeObjectBufferFrom: self) ]		ifFalse: [ self preMadeStorageObjectBuffer ].	buffer		startPos: anInteger ;		ensureSpaceFor: storageObject.	buffer byteArray == self byteArray		ifFalse:			[ "aByteArray must not have been big enough.."			self byteArray: buffer byteArray ].	buffer		populateHeaderFor: anObject		storageObject: storageObject		using: self.	buffer		populateBodyFor: storageObject		using: self.	^ buffer! !!MaObjectSerializer methodsFor: 'accessing'!byteArray	^self graphBuffer byteArray! !!MaObjectSerializer methodsFor: 'accessing'!byteArray: aByteArray	self graphBuffer byteArray: aByteArray.	preMadeObjectBuffers do: [ :each | each byteArray: aByteArray ]! !!MaObjectSerializer methodsFor: '*magma client' stamp: 'cmm 5/8/2003 13:50'!cachedObjectCountByClass	^oidManager objectCountByClass! !!MaObjectSerializer methodsFor: '*ma object serialization' stamp: 'cmm 6/3/2004 14:07'!classDefinitions: aDictionary	"aDictionary keys are the classId (an Integer), values are a collection of known MaClassDefinitions, representing different versions of that class."	self classIdManager classDefinitionsById: aDictionary! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 6/8/2004 21:14'!classDefinitionsByteArray	"Answer a ByteArray that can be used to reinitialize a new instance of the receiver so that it can materialize the objects it has serialized."	^ (self copyWithNewBuffer serializeGraph: self classIdManager classDefinitionsById) trimmedByteArray! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 6/8/2004 22:09'!classDefinitionsByteArray: aByteArray	"Initialize the receiver with aByteArray that materializes to my classDefinitions.  These are the classDefinitions used to work with objects that were being used when the user saved off the byteArray by calling the getter, #classDefinitionsByteArray."	self classDefinitions: (self materializeGraph: aByteArray)! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 5/23/2004 22:18'!classDefinitionsOid	^self oidFor: self classIdManager classDefinitionsById! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/10/2005 18:56'!classFor: anObject 	^ anObject maSerializationClass! !!MaObjectSerializer methodsFor: 'accessing'!classIdManager	^classIdManager! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 5/2/2005 15:03'!classIdManager: aMaClassIdManager	classIdManager _ aMaClassIdManager.	self setUpClassDefinitionProcessing! !!MaObjectSerializer methodsFor: '*magma client' stamp: 'cmm 6/6/2004 16:04'!cleanObject: anObject	truncatedObjects		removeKey: anObject		ifAbsent: [ "no problem" ].	^oidManager cleanObject: anObject! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:59'!copyWithNewBuffer	^ self copy		postCopyWithNewBuffer ;		yourself! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:58'!copyWithNewOidSpace	"Answer a new instance of the me that shares my class-ids, but not the oids."		^ self copyWithNewBuffer		postCopyWithNewOidSpace ;		yourself! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 1/20/2003 22:26'!finalizeOids	oidManager finalizeOids! !!MaObjectSerializer methodsFor: 'accessing'!graphBuffer	^graphBuffer! !!MaObjectSerializer methodsFor: 'building'!graphBuffer: aMaSerializedGraphBuffer	graphBuffer _ aMaSerializedGraphBuffer! !!MaObjectSerializer methodsFor: 'event handling' stamp: 'cmm 12/12/2004 18:54'!handleClassModification: aModifiedClassDefinitionEvent	aModifiedClassDefinitionEvent isModified ifFalse: [ ^ self ].	aModifiedClassDefinitionEvent item isMeta ifTrue: [ ^ self ].	oidManager		handleClassModification: aModifiedClassDefinitionEvent item		using: self.	classIdManager		handleClassModification: aModifiedClassDefinitionEvent item		using: self! !!MaObjectSerializer methodsFor: 'testing' stamp: 'cmm 7/17/2002 22:49'!hasOidFor: anObject	^oidManager hasOidFor: anObject! !!MaObjectSerializer methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:51'!independentCopy	"Answer a completely independent copy of the receiver.  This will probably mostly be used during debugging."	^ self copy postIndependentCopy! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 2/1/2005 15:27'!initialize	super initialize.	preferences _ MaObjectSerializerPreferences new.	self		oidManager: MaOidManager new;		classIdManager: MaClassIdManager new;		initializeTraversalStrategy;		toCreateProxies: [ :oid | MaObjectSerializationUserError signal: 'No createProxyBlock specified.  See MaObjectSerializer>>toCreateProxies:' ].	self graphBuffer: (MaSerializedGraphBuffer new: 50).	self initializePreMadeObjectBuffers.	self beBored.	truncatedObjects _ WeakIdentityKeyDictionary new  "want a WeakIdentitySet..".	self setUpPreAndPostProcessing! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 10/21/2004 12:53'!initializePreMadeObjectBuffers	preMadeObjectBuffers _ MaObjectBuffer bufferClasses collect:		[ :each |		each			byteArray: self byteArray			startPos: 0 ]! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 11/29/2004 11:04'!initializeTraversalStrategy	traversalStrategy _		MaObjectGraphTraversalStrategy new			traverseWhen:				[ : path : parent : indexInteger | 				path last					maShouldTraverseWithPath: path					parent: parent					index: indexInteger ]! !!MaObjectSerializer methodsFor: 'testing' stamp: 'cmm 6/5/2004 17:26'!isTruncated: anObject	"A truncated object is one that has been read, but the in-image definition did not have a place for one of its inst vars.  This is useful for then detecting if the user tries to write that object back out to warn him that he will lose data."	^ truncatedObjects includesKey: anObject! !!MaObjectSerializer methodsFor: 'materializing' stamp: 'cmm 10/9/2004 23:58'!materializeGraph: aByteArray	^self		materializeGraph: aByteArray		do: [ : eachObject : eachBuffer | "do nothing" ]! !!MaObjectSerializer methodsFor: 'materializing' stamp: 'cmm 1/30/2005 20:47'!materializeGraph: aByteArray do: twoArgBlock	"Answer a fully-formed object from aByteArray of aMaSerializedGraphBuffer.  If buffers are missing to complete the full-graph, I will substitute with proxy's based on the block specified by toCreateProxies:."	"Guard against stepping on my own buffers if I'm busy serializing or materializing already."	^ amBusy		ifTrue:			[ self copyWithNewBuffer				byteArray: aByteArray;				materializeGraphDo: twoArgBlock ]		ifFalse:			[ self				byteArray: aByteArray;				materializeGraphDo: twoArgBlock ]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 2/3/2005 11:18'!materializeGraphDo: twoArgBlock	"Materialize as much as the object in the receivers byteArray as possible.  For each object *materialized*, value twoArgBlock [ : eachObject : eachBuffer | ].  twoArgBlock is not valued for objects encountered in the materialized graph if they were already present in the receivers oidManager, that way we know when objects are exactly materialized."	| skeletons rootObject needToRehash |	needToRehash _ false.	skeletons _ OrderedCollection new: 48.	rootObject _ nil.	self beBusy.	self graphBuffer buffersDo:		[ : each | | object |		object _			self				objectWithOid: each oid				ifFound:					[ : foundObj |					foundObj maIsMutatingProxy "true when materializing a proxy"						ifTrue: [ skeletons add: (self newSkeletonFor: each fromProxy: foundObj) -> each copyWithSameBuffer ].					foundObj ]				ifAbsent:					[ | newObject |					skeletons add: (Association key: (newObject _ self newSkeletonFor: each fromProxy: nil) value: each copyWithSameBuffer).					newObject ].		rootObject ifNil: [ rootObject _ object ] ].	"Do not merge these do's.."	skeletons do:		[ : eachAssociation |  | eachObject eachBuffer |		eachObject _ eachAssociation key.		eachBuffer _ eachAssociation value.		(eachObject maIsHashedCollection and: [ eachObject notEmpty ]) ifTrue: [ needToRehash _ true ].		eachBuffer			establishReferencesFrom: eachObject			using: self ].	needToRehash ifTrue:		[ skeletons do:			[ : eachAssociation | 			eachAssociation key maIsHashedCollection ifTrue: [ eachAssociation key rehash ] ] ].	skeletons do:		[ : eachAssociation |  | eachFullyFormedObject eachBuffer |		eachFullyFormedObject _ eachAssociation key.  eachBuffer _ eachAssociation value.		eachFullyFormedObject maWantsPostMaterialization ifTrue: [ self postMaterialize: eachFullyFormedObject ].		twoArgBlock			value: eachFullyFormedObject			value: eachBuffer "up to user to copy this if they need to." ].	self beBored.	^ rootObject! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 1/18/2005 16:09'!newSkeletonFor: aMaObjectBuffer fromProxy: aMaMutatingProxy	| skel |	skel _ aMaObjectBuffer createObjectUsing: self.	aMaMutatingProxy ifNotNil: [ aMaMutatingProxy becomeForward: skel copyHash: false ].	self		oidOf: skel		is: aMaObjectBuffer oid.	^ skel! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/27/2006 16:45'!objectWithOid: anInteger	^ oidManager		objectWithOid: anInteger		ifAbsent: [ self proxyFor: anInteger ]! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:55'!objectWithOid: anInteger ifAbsent: aBlock	^oidManager		objectWithOid: anInteger		ifAbsent: aBlock! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:54'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^oidManager		objectWithOid: anInteger		ifFound: oneArgBlock		ifAbsent: aBlock! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 12/29/2004 14:26'!objectsDo: oneArgBlock	oidManager objectsDo: oneArgBlock! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 4/20/2003 22:18'!oidCount	"Answers the number of objects that have oids."	^oidManager oidCount! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 3/20/2003 21:54'!oidFor: anObject	^oidManager oidFor: anObject! !!MaObjectSerializer methodsFor: 'building'!oidManager: aMaOidManager	oidManager _ aMaOidManager! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 6/23/2004 17:41'!oidOf: anObject is: anInteger	oidManager		oidOf: anObject		is: anInteger! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 12/29/2002 16:49'!optimumByteArraySize: anInteger	self byteArray: (ByteArray new: anInteger).	self resetByteArray! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 3/24/2005 14:20'!postCopyWithNewBuffer	graphBuffer _ MaSerializedGraphBuffer new: 1000.	self		initializePreMadeObjectBuffers;		resetByteArray;		beBored! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 3/28/2005 22:24'!postCopyWithNewOidSpace		self oidManager: oidManager species new! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 3/24/2005 11:49'!postIndependentCopy	"Answer a completely independent copy of the receiver.  This will probably mostly be used during debugging."	self 		oidManager: oidManager independentCopy;		classIdManager: self classIdManager independentCopy;		resetByteArray.	graphBuffer _ graphBuffer copy.	traversalStrategy _ traversalStrategy copy! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/10/2005 18:00'!postMaterialize: anObject 	"maPostMaterialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPostMaterialize) 		ifTrue: [anObject maPostMaterialize].	anObject maOriginalClass withAllSuperclassesDo: 			[:eachClass | 			preferences postMaterializers 				maAt: eachClass name				ifPresent: 					[:valuators | 					valuators do: [:each | each valueWithArguments: { 										anObject}]]				ifAbsent: 					["do nothing"					]]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/10/2005 18:00'!postSerialize: anObject 	"maPostSerialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPostSerialize) ifTrue: [anObject maPostSerialize].	anObject maOriginalClass withAllSuperclassesDo: 			[:eachClass | 			preferences postSerializers 				maAt: eachClass name				ifPresent: [:valuators | valuators do: [:each | each value: anObject]]				ifAbsent: 					["do nothing"					]]! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:42'!preMadeByteObjectBuffer	^ self preMadeObjectBufferAt: 1! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:43'!preMadeFixedObjectBuffer	^ self preMadeObjectBufferAt: 3! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:42'!preMadeObjectBufferAt: bufferTypeInteger	^ preMadeObjectBuffers at: bufferTypeInteger! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 21:42'!preMadeStorageObjectBuffer	^ self preMadeObjectBufferAt: 5! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 11/11/2004 15:43'!preMadeVariableObjectBuffer	^ self preMadeObjectBufferAt: 2! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 5/1/2005 22:14'!preMadeVariableWordBuffer	^ self preMadeObjectBufferAt: 4! !!MaObjectSerializer methodsFor: 'private' stamp: 'cmm 4/10/2005 18:00'!preSerialize: anObject 	"maPreserialize could be useful for when you don't necessarily require serialization, but needed so that it *can* be used, if desired."	(anObject respondsTo: #maPreserialize) ifTrue: [anObject maPreserialize].	anObject maOriginalClass withAllSuperclassesDo: 			[:eachClass | 			preferences preSerializers 				maAt: eachClass name				ifPresent: 					[:valuators | 					valuators do: [:each | each valueWithArguments: { 										anObject}]]				ifAbsent: 					["do nothing"					]]! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 11/26/2004 09:46'!preferences	^ preferences! !!MaObjectSerializer methodsFor: 'accessing' stamp: 'cmm 4/23/2003 23:16'!proxyFor: oid	^oidManager retainIdentityOfProxy: (createProxyBlock value: oid)! !!MaObjectSerializer methodsFor: 'building' stamp: 'cmm 6/5/2004 17:27'!recordTruncatedObject: anObject	"A truncated object is one that has been read, but the in-image definition did not have a place for one of its inst vars.  This is useful for then detecting if the user tries to write that object back out to warn him that he will lose data.  See also isTruncated:."	truncatedObjects at: anObject put: nil! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 12/29/2004 17:30'!rehashOids	oidManager rehashOids! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 11/26/2004 09:43'!resetByteArray	"Ensure my preMade buffers share the same byteArray as my graphBuffer (a performance optimization) and set my size to 0 objects."	preMadeObjectBuffers first byteArray ~~ self byteArray		ifTrue: [ preMadeObjectBuffers do: [ :each | each byteArray: self byteArray ] ].	self graphBuffer resetBufferSize! !!MaObjectSerializer methodsFor: '*magma client' stamp: 'cmm 4/20/2005 17:27'!resetNewObjects	oidManager resetNewObjects! !!MaObjectSerializer methodsFor: 'actions' stamp: 'cmm 6/8/2006 15:45'!resetOidManager	"If receiving a byteArray from another serializer, this method should be invoked prior to materializing here so cached oids in the oidManager that may not match the objects that were serialized by the other serializer."	oidManager reset! !!MaObjectSerializer methodsFor: 'serializing'!serializeGraph: anObject	"Answer a MaSerializedGraphBuffer containing anObject and all objects	it can reach, serialized into aByteArray."	^self		serializeGraph: anObject		do: [ :each | nil ]! !!MaObjectSerializer methodsFor: 'serializing' stamp: 'cmm 11/16/2004 23:39'!serializeGraph: anObject do: oneArgBlock	"Answer a MaSerializedGraphBuffer containing anObject and all objects it can reach, serialized into aByteArray."	^ self copyWithNewBuffer		resetByteArray;		appendGraph: anObject		do: oneArgBlock! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 11/2/2005 22:48'!setUpClassDefinitionProcessing	preferences		beforeSerializingAny: #MaClassReference		do:			[ : aMaClassReference |			aMaClassReference id:				(classIdManager					idForClass: aMaClassReference classObject					ifAbsent:						[ (classIdManager addNewClass: aMaClassReference classObject theNonMetaClass) id ]).			aMaClassReference := nil ] ;		afterMaterializingAny: #MaClassDefinition		do:			(MessageSend				receiver: classIdManager				selector: #addClassDefinition:)! !!MaObjectSerializer methodsFor: 'initializing' stamp: 'cmm 11/2/2005 23:32'!setUpPreAndPostProcessing	"Initiailize the pre and post-materializers for classes that come with standard Squeak.  Base Squeak uses one of two methods for serializing objects; ReferenceStream and ImageSegments.  MaObjectSerialization more-closely resembles ReferenceStream.  While the setup for these processors is based on the behavior in those other two frameworks, there are bound to be some minor differences."	self setUpClassDefinitionProcessing.	preferences		beforeSerializingAny: #Color		do:			[ : aColor | 			aColor flushCache "saves space".			thisContext home removeSelf ]."preferences	beforeSerializingAny: #Form	do: [ : aForm | aForm hibernate ].preferences	afterSerializingAny: #Form	do: [ : aForm | aForm unhibernate ].preferences	afterMaterializingAny: #Form	do: [ : aForm | aForm unhibernate ].""preferences	beforeSerializingAny: #ColorForm	do: [ : aColorForm | aColorForm clearColormapCache ]."	preferences		beforeSerializingAny: #PasteUpMorph		do:			[ : aPasteUpMorph | 			aPasteUpMorph prepareToBeSaved.  "Amen" 			thisContext home removeSelf ]."preferences	afterSerializingAny: #ScriptEditorMorph	do: [ : aScriptEditorMorph | aScriptEditorMorph class = BooleanScriptEditor ifFalse: [ aScriptEditorMorph unhibernate ] ].preferences	afterMaterializingAny: #ScriptEditorMorph	do: [ : aScriptEditorMorph | aScriptEditorMorph class = BooleanScriptEditor ifFalse: [ aScriptEditorMorph unhibernate ] ]."	preferences		beforeSerializingAny: #TTCFont		do: 			[ : aTTCFont | 			aTTCFont flushCache.			thisContext home removeSelf ]."preferences		beforeSerializingAny: #Wonderland		do: [ : aWonderland | aWonderland prepareToBeSaved ].preferences	beforeSerializingAny: #ViewerFlapTab	do: [ : aViewFlapTab | aViewFlapTab hibernate ]."self maMarked: 'dev'."You've got this commented out because it changes the shape of the object while you're serializing it, which ends up causing the graphBuffer to not be #isWhole (which causes problems on materialization).Do we need this?  It appears that Project>>exportSegmentWithChangeSet:  fileName:  directory: calls it at the end.  Also, Project>>exportSegmentWithCatagories: classes: fileName: directory:""preferences	afterSerializingAny: #ViewerFlapTab	do: [ : aViewerFlapTab | aViewerFlapTab unhibernate ].preferences	afterMaterializingAny: #ViewerFlapTab	do: [ : aViewerFlapTab | aViewerFlapTab unhibernate ]."	preferences		beforeSerializingAny: #Project		do:			[ : aProject |  | world |			world := aProject world.			aProject world setProperty: #optimumExtentFromAuthor toValue: aProject world extent.  "As suggested by Project>>#storeOnServerAssumingNameValid".			"The following is from Project>>#exportSegmentWithChangeSet:fileName:directory:"			Utilities emptyScrapsBook.			world currentHand pasteBuffer: nil.	  "don't write the paste buffer."			world currentHand mouseOverHandler initialize.	  "forget about any references here"				"Display checkCurrentHandForObjectToPaste."			Command initialize.			world clearCommandHistory.			world fullReleaseCachedState; releaseViewers. 			world cleanseStepList.			world releaseSqueakPages.			ScriptEditorMorph writingUniversalTiles: (aProject projectParameterAt: #universalTiles ifAbsent: [false]).			thisContext home removeSelf ].	preferences		afterMaterializingAny: #Project		do:			[ : aProject |			aProject setParent: Project current.			aProject world beWorldForProject: aProject. "sets aProject's worldState"			"This behavior suggested by ImageSegment>>#comeFullyUpOnReload:"			aProject ensureChangeSetNameUnique.			Project addingProject: aProject.			aProject restoreReferences.			self maMarked: 'dev'.  "need to restore dependents??"			ScriptEditorMorph writingUniversalTiles: 				((aProject projectPreferenceAt: #universalTiles) ifNil: [false]).			thisContext home removeSelf ]."preferences	afterMaterializingAny: #WorldState	do:		[ : aWorldState |		aWorldState			convertStepList ;			convertAlarms ]."! !!MaObjectSerializer methodsFor: 'testing' stamp: 'cmm 12/29/2004 14:27'!sharesAnyObjectsWith: anotherMaObjectSerializer	anotherMaObjectSerializer objectsDo:		[ : each |		(self hasOidFor: each) ifTrue: [ ^ true ] ].	self objectsDo:		[ : each |		(anotherMaObjectSerializer hasOidFor: each) ifTrue: [ ^ true ] ].	^ false! !!MaObjectSerializer methodsFor: 'building'!toCreateProxies: oneArgBlock	createProxyBlock _ oneArgBlock! !!MaObjectSerializer methodsFor: 'accessing'!traversalStrategy	^traversalStrategy! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!afterMaterializingAny: className do: oneArgValuator	"Set up preference for materializing instances of the class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	| valuators |	self		validate: className		has: #maWantsPostMaterialization.	valuators _ 		(postMaterializers			at: className			ifAbsentPut: [ OrderedCollection new ]).	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!afterSerializingAny: className do: oneArgValuator	"Set up preference for serializing instances of class named className by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization."	| valuators |	self		validate: className		has: #maWantsPreSerialization.	valuators _ postSerializers		at: className		ifAbsentPut: [ OrderedCollection new ].	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/11/2005 11:17'!beforeSerializingAny: className do: oneArgValuator	"Set up preference for serializing instances of aClass by sending oneArgValuator.  The first argument is the object being serialized, the second is the serializer (aMaObjectSerializer) doing the serialization.	Note, only do this if aClass is present."	| valuators |	self		validate: className		has: #maWantsPreSerialization.	valuators _ 		preSerializers			at: className			ifAbsentPut: [ OrderedCollection new ].	(valuators includes: oneArgValuator) ifFalse: [ valuators add: oneArgValuator ]! !!MaObjectSerializerPreferences methodsFor: 'initializing' stamp: 'cmm 11/28/2004 19:22'!initialize	super initialize.	preSerializers _ Dictionary new.	postSerializers _ Dictionary new.	postMaterializers _ Dictionary new! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/26/2004 10:17'!postMaterializers	^ postMaterializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/28/2004 17:12'!postSerializers	^ postSerializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 11/26/2004 10:17'!preSerializers	^ preSerializers! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:54'!releasePostMaterializationFor: className	"Remove all post-materialization behaviors for the class named className."	postMaterializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:55'!releasePostSerializationFor: className	"Remove all post-materialization behaviors for the class named className."	postSerializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'pre and post processing' stamp: 'cmm 2/3/2005 22:51'!releasePreserializationFor: className	"Remove all preserialization behaviors for the Class named className."	preSerializers		removeKey: className		ifAbsent: [ "ok" ]! !!MaObjectSerializerPreferences methodsFor: 'validate' stamp: 'cmm 7/18/2005 13:09'!validate: className has: selector	(Smalltalk hasClassNamed: className) ifFalse: [ "No validation needed" ^ self ].	((Smalltalk at: className) basicNew perform: selector)		ifFalse:			[ MaObjectSerializationUserError signal: 'Need to implement ', selector, ' on ', className ]! !!MaOidCalculator commentStamp: 'cmm 6/1/2005 09:46' prior: 0!The oid ranges are as follows:The range from (0 to: SmallInteger maxVal - SmallInteger minVal) are reserved for:  user objects, the non-integral atomics including 65536 characters and space for 4000000 new-object oids (bigger than any transaction should ever be!!).  We should allow a few thousand for future-use as well.SmallInteger minVal actually starts at the oid with the value SmallInteger maxVal + 1.  Thus, SmallInteger maxVal has the oidWe start at the bottom so user-objects are contiguous above    a   n u m b e r   l i n e|<--- SmallInteger range -------------->|< - - - - - -  LargeInteger range - - - - - - - - - ->|atomics | chars | new objects          |    user objects             | Floats | SmallIntegers  |0	nil1	false2	true3	indicate an unused slot in a MaHashIndex4 to: 65539	DB character-set (only SB currently supported)65540 to: 66540	future use?66541 to: 66541 + 4000000  "no more than four-million new objects are allowed in a single commit."	new-object oids4066542 to: 281468533259712 (oid for smallest float - 1)	user objects281468533259713 to: self oidForSmallestOptimizedInteger-1	32-bit IEEE floats281472829227008 to: 281474976710655	SmallIntegers!!MaOidCalculator class methodsFor: 'special' stamp: 'cmm 4/29/2005 12:20'!firstCharacterOid	^ 4! !!MaOidCalculator class methodsFor: '*magma client' stamp: 'cmm 6/1/2005 09:13'!firstUserObjectOid	^ 4066542! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 8/8/2002 23:01'!floatFromOid: anInteger	^Float fromIEEE32Bit: anInteger - self oidForSmallestFloat! !!MaOidCalculator class methodsFor: 'special' stamp: 'cmm 4/21/2005 15:40'!highestPossibleOid	^ 281474976710655    "(2 raisedTo: 48) - 1"! !!MaOidCalculator class methodsFor: '*magma server' stamp: 'cmm 6/8/2005 17:07'!indexPositionForOid: anInteger	^ anInteger - self firstUserObjectOid + 1! !!MaOidCalculator class methodsFor: '*magma client-debugging' stamp: 'cmm 7/18/2005 10:53'!infoFor: oidInteger	| obj |	obj _		self			objectWithOid: oidInteger			ifNone:				[ ^(self isOidForNewObject: oidInteger)					ifTrue: [ 'new object' ]					ifFalse: [ 'index position: ', (self indexPositionForOid: oidInteger) printString ] ].	^'(' , obj printString , ')'! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 8/6/2002 23:52'!integerFromOid: oidInteger	^oidInteger - self oidForZero! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 4/21/2005 15:32'!isOidForFloat: oidInteger	^ oidInteger		between: self oidForSmallestFloat		and: 281472828227007  "self oidForSmallestOptimizedInteger - 1"! !!MaOidCalculator class methodsFor: '*magma client' stamp: 'cmm 12/30/2002 21:48'!isOidForNewObject: anInteger	^anInteger		between: self newOidMinimum		and: self firstUserObjectOid - 1! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 6/1/2005 09:43'!isOidForOptimizedInteger: oidInteger	^ oidInteger		between: 281472829227008  "self oidForZero + SmallInteger minVal"		and: 281474976710655  "self oidForZero + SmallInteger maxVal"! !!MaOidCalculator class methodsFor: '*magma server' stamp: 'cmm 8/13/2002 23:57'!isOidForOptimizedObject: oidInteger	"Answer whether oidInteger is an oid for anObject which will never require its own buffer.  These include optimized Integers, nil, true, false, and all Characters."	^(self isOidForNewObject: oidInteger) not		and: [ (self isOidForUserObject: oidInteger) not ]! !!MaOidCalculator class methodsFor: '*magma server' stamp: 'cmm 11/13/2002 23:05'!isOidForUserObject: anInteger	"A 'user' object is a persistent object stored in a Magma database that does not have a special oid, such as SmallIntegers, Floats, Booleans, etc. have."	^anInteger		between: self firstUserObjectOid		and: self lastUserObjectOid! !!MaOidCalculator class methodsFor: 'special' stamp: 'cmm 4/29/2005 12:21'!lastCharacterOid	"^self firstCharacterOid + 65535"   "DBCS"	^ 65539! !!MaOidCalculator class methodsFor: '*magma server' stamp: 'cmm 4/21/2005 15:41'!lastUserObjectOid	^ 281468533259712   "self oidForSmallestFloat - 1"! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 9/1/2002 22:54'!newOidMinimum	^66541! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/8/2002 22:57'!objectWithOid: anInteger ifNone: aBlock	anInteger == self oidForNil ifTrue: [ ^nil ].	anInteger == self oidForFalse ifTrue: [ ^false ].	anInteger == self oidForTrue ifTrue: [ ^true ].	(self isOidForFloat: anInteger)		ifTrue:			[ ^self floatFromOid: anInteger ].	(self isOidForOptimizedInteger: anInteger)		ifTrue:			[ ^self integerFromOid: anInteger ].	(anInteger		between: self firstCharacterOid		and: self lastCharacterOid)			ifTrue:				[ ^Character value: anInteger - self firstCharacterOid ].	^aBlock value! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:40'!oidForCharacter: aCharacter	^self firstCharacterOid + aCharacter asciiValue! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:41'!oidForFalse	^1! !!MaOidCalculator class methodsFor: '*magma server' stamp: 'cmm 12/2/2004 13:32'!oidForFilePositionIndexPosition: anInteger	^ self firstUserObjectOid + anInteger! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 8/8/2002 23:06'!oidForFloat: aFloat	^aFloat asIEEE32BitWord + self oidForSmallestFloat! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 8/6/2002 23:51'!oidForInteger: anInteger	^anInteger + self oidForZero! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:37'!oidForNil	^0! !!MaOidCalculator class methodsFor: 'floats' stamp: 'cmm 4/21/2005 15:32'!oidForSmallestFloat	^ 281468533259713  "self oidForSmallestOptimizedInteger - 16rFFFFFFFF"! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 4/21/2005 15:32'!oidForSmallestOptimizedInteger	^ self oidForInteger: SmallInteger minVal! !!MaOidCalculator class methodsFor: 'atomics' stamp: 'cmm 8/6/2002 23:41'!oidForTrue	^2! !!MaOidCalculator class methodsFor: 'integers' stamp: 'cmm 6/1/2005 09:42'!oidForZero	"^16rFFFFFFFFFFFF - SmallInteger maxVal"	^ 281473902968832! !!MaOidManager methodsFor: '*magma client' stamp: 'cmm 6/10/2003 22:36'!cleanObject: anObject	^oids		removeKey: anObject		ifAbsent: [ nil ]! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 1/20/2003 22:28'!finalizeOids	oids finalizeValues! !!MaOidManager methodsFor: 'private' stamp: 'cmm 7/26/2005 13:09'!getNextOid	^ nextOid _ nextOid + 1! !!MaOidManager methodsFor: 'event handling' stamp: 'cmm 6/24/2004 11:59'!handleClassModification: aClass using: aMaObjectSerializer	"optional subclass responsibility"! !!MaOidManager methodsFor: 'testing' stamp: 'cmm 7/17/2002 22:51'!hasOidFor: anObject	^oids includesKey: anObject! !!MaOidManager methodsFor: 'copying' stamp: 'cmm 3/24/2005 11:36'!independentCopy	^ self copy postIndependentCopy! !!MaOidManager methodsFor: 'private' stamp: 'cmm 3/23/2006 20:23'!initialize	super initialize.	self		reset;		resetNextOid ;		resetLastClean! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 12/27/2002 16:03'!objectWithOid: anInteger ifAbsent: aBlock	^self		objectWithOid: anInteger		ifFound: [ :foundObj | foundObj ]		ifAbsent: aBlock! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 12/25/2002 12:15'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^MaOidCalculator		objectWithOid: anInteger		ifNone:			[ objects				maAt: anInteger				ifPresent:					[ :obj |					obj   "oid key marked to be cleaned"						ifNil: [ aBlock value ]						ifNotNil: [ oneArgBlock value: obj ] ]				ifAbsent: [ aBlock value ] ]! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 12/29/2004 13:54'!objectsDo: oneArgBlock	objects do: oneArgBlock! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 4/20/2003 22:18'!oidCount	^oids size! !!MaOidManager methodsFor: 'accessing'!oidFor: anObject	^self		oidFor: anObject		ifAbsent:			[ self				oidOf: anObject				is: self getNextOid ]! !!MaOidManager methodsFor: 'accessing' stamp: 'cmm 1/18/2005 16:12'!oidFor: anObject ifAbsent: aBlock	anObject maIsMutatingProxy ifTrue: [ ^ anObject mutatingProxyOid ].	^anObject maRequiresOwnBuffer		ifTrue:			[ oids				maAt: anObject				ifPresent: [ : oid | oid ifNil: [ aBlock value ] ifNotNil: [ oid ] ]				ifAbsent: aBlock ]		ifFalse:			[ anObject maOid ]! !!MaOidManager methodsFor: 'building' stamp: 'cmm 5/30/2006 21:03'!oidOf: anObject is: anInteger 	self shouldRemoveGarbageCollectedEntries ifTrue: [ self removeGarbageCollectedObjectEntries ].	objects 		at: anInteger		put: anObject.	^ oids 		at: anObject		put: anInteger! !!MaOidManager methodsFor: 'private' stamp: 'cmm 3/24/2005 11:36'!postIndependentCopy	objects _ objects copy.	oids _ oids copy.	self resetNextOid! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 12/29/2004 17:29'!rehashOids	oids rehash! !!MaOidManager methodsFor: 'private' stamp: 'cmm 3/23/2006 20:23'!removeGarbageCollectedObjectEntries	objects _ objects reject: [ : each | each isNil ].	self resetLastClean! !!MaOidManager methodsFor: 'actions' stamp: 'cmm 3/23/2006 23:01'!reset	oids _ WeakIdentityKeyDictionary new.	objects _ MaWeakValueDictionary new! !!MaOidManager methodsFor: 'private' stamp: 'cmm 3/23/2006 20:23'!resetLastClean	lastClean _ Time millisecondClockValue! !!MaOidManager methodsFor: 'private'!resetNextOid	nextOid _ MaOidCalculator newOidMinimum! !!MaOidManager methodsFor: 'building' stamp: 'cmm 1/18/2005 16:12'!retainIdentityOfProxy: aMaMutatingProxy	^ objects		at: aMaMutatingProxy mutatingProxyOid		put: aMaMutatingProxy! !!MaOidManager methodsFor: 'private' stamp: 'cmm 7/30/2006 19:05'!shouldRemoveGarbageCollectedEntries	| count size |	Time millisecondClockValue - lastClean > 30000 ifFalse: [ ^ false ].	size _ count _ 0.	objects keysAndValuesDo: 		[ : eachOid : eachObject | 		size _ size + 1.		eachObject ifNotNil: [ count _ count + 1 ] ].	self resetLastClean.	^ size > (count * 2)! !!MagmaOidManager commentStamp: 'cmm 6/21/2004 00:20' prior: 0!Because removeKey: is so slow in Squeak, I keep track of which ones are newObjects.  That way, when we return from a commit, replacement of temp to permanent oids is much faster.!!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 3/23/2006 22:44'!initializeNewObjects	newObjects _ MaWeakValueDictionary new! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:24'!initializeNewOids	newOids _ WeakIdentityKeyDictionary new! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/10/2005 18:00'!objectCountByClass	^(objects collect: [:e | e maOriginalClass]) asBag sortedCounts! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 3/20/2003 13:18'!objectWithOid: anInteger ifFound: oneArgBlock ifAbsent: aBlock	^MaOidCalculator		objectWithOid: anInteger		ifNone:			[ (MaOidCalculator isOidForNewObject: anInteger)				ifTrue:					[ newObjects						maAt: anInteger						ifPresent:							[ :obj |							obj 								ifNil: [ aBlock value ] 								ifNotNil: [ oneArgBlock value: obj ] ]						ifAbsent: aBlock ]				ifFalse:					[ objects						maAt: anInteger						ifPresent:							[ :obj |							obj   "oid key marked to be cleaned"								ifNil: [ aBlock value ]								ifNotNil: [ oneArgBlock value: obj ] ]						ifAbsent: aBlock ] ]! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:14'!oidFor: anObject ifAbsent: aBlock	anObject maIsMutatingProxy ifTrue: [ ^ anObject mutatingProxyOid ].	^ anObject maRequiresOwnBuffer		ifTrue:			[ newOids				maAt: anObject				ifPresent: [ : oid | oid ifNil: [ aBlock value ] ifNotNil: [ oid ] ]				ifAbsent:					[ super						oidFor: anObject						ifAbsent: aBlock ] ]		ifFalse:			[ super				oidFor: anObject				ifAbsent: aBlock ]! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:17'!oidOf: anObject is: anInteger	^(MaOidCalculator isOidForNewObject: anInteger)		ifTrue:			[ newObjects 				at: anInteger 				put: anObject.			newOids				at: anObject				put: anInteger ]		ifFalse:			[ "removeKey: is very slow, that's the whole point of newObejcts and newOids.  They're a dangerous hack to avoid removeKey."			super				oidOf: anObject				is: anInteger ]! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:16'!postIndependentCopy	super postIndependentCopy.	newObjects _ newObjects copy.	newOids _ newOids copy! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 3/20/2003 12:58'!removeGarbageCollectedObjectEntries	super removeGarbageCollectedObjectEntries.	newObjects _ newObjects reject: [ :each | each isNil ]! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:23'!reset	super reset.	self resetNewObjects! !!MagmaOidManager methodsFor: 'as yet unclassified' stamp: 'cmm 4/20/2005 22:23'!resetNewObjects	"This is needed because we only have 2 million new-object oids.  If we didn't do this, the nextOid counter continues to increase to its ceiling."	self		initializeNewObjects ;		initializeNewOids ;		resetNextOid	! !!MaPermutator class methodsFor: 'actions'!permutationsOf: anArrayOfArrays do: aBlock	"For each combination of elements in anArrayOfArray's, value aBlock	with the arguments of each combination of elements.  There must be	as many arguments in aBlock as there are elements in the outer array	of Array's.	Note, this also works with any sequenceable collection of sequenceable	collections."	| numberOfCombinations args |	numberOfCombinations :=		anArrayOfArrays			inject: 1			into: [ :prod :each | each size * prod ].	args := Array new: anArrayOfArrays size.	1		to: numberOfCombinations		do:			[ :elementIndex |			1				to: anArrayOfArrays size				do:					[ :innerIndex | | eachInnerArray radix |					eachInnerArray := anArrayOfArrays at: innerIndex.					radix := 1.					1						to: innerIndex - 1						do: [ :eachOrder | radix := radix * (anArrayOfArrays at: eachOrder) size ].					args						at: innerIndex						put: (eachInnerArray at: (elementIndex // radix \\ eachInnerArray size + 1)) ].			aBlock valueWithArguments: args ]! !!MaPermutator methodsFor: 'building'!addArguments: aSequenceableCollection	^self arguments add: aSequenceableCollection! !!MaPermutator methodsFor: 'accessing'!arguments	^arguments! !!MaPermutator methodsFor: 'building'!arguments: aSequenceableCollectionOfSequenceableCollections	arguments := aSequenceableCollectionOfSequenceableCollections! !!MaPermutator methodsFor: 'private initializing' stamp: 'cmm 12/24/2002 15:51'!initialize	super initialize.	arguments := OrderedCollection new! !!MaPermutator methodsFor: 'actions'!permutationsDo: oneArgBlock	"For each combination of elements in the receivers args, value aBlock	with the arguments of each combination of elements.  The argument to	oneArgBlock is the Array of parameters for each combination."	| args |	args := Array new: self arguments size.	1		to: self size		do:			[ :elementIndex |			1				to: self arguments size				do:					[ :innerIndex | | eachInnerArray radix |					eachInnerArray := self arguments at: innerIndex.					radix := 1.					1						to: innerIndex - 1						do: [ :eachOrder | radix := radix * (self arguments at: eachOrder) size ].					args						at: innerIndex						put: (eachInnerArray at: (elementIndex // radix \\ eachInnerArray size + 1)) ].			oneArgBlock value: args ]! !!MaPermutator methodsFor: 'actions'!permutationsWhere: conditionBlock do: oneArgBlock	"Same as permutationsDo: except the conditionBlock must also be	satisfied for aBlock to run.  This is only for mildly better looking code	since a case statement could achieve the same effect."	| args |	args := Array new: self arguments size.	1		to: self size		do:			[ :elementIndex |			1				to: self arguments size				do:					[ :innerIndex | | eachInnerArray radix |					eachInnerArray := self arguments at: innerIndex.					radix := 1.					1						to: innerIndex - 1						do: [ :eachOrder | radix := radix * (self arguments at: eachOrder) size ].					args						at: innerIndex						put: (eachInnerArray at: (elementIndex // radix \\ eachInnerArray size + 1)) ].			(conditionBlock value: args) ifTrue: [ oneArgBlock value: args ] ]! !!MaPermutator methodsFor: 'accessing'!size	^self arguments		inject: 1		into: [ :prod :each | each size * prod ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/6/2003 00:44'!addLogMessage: aString	log add: aString! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:29'!advance	unitsCompleted _ unitsCompleted + 1! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 11/13/2003 00:40'!advance: anInteger	unitsCompleted _ unitsCompleted + anInteger! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 7/20/2004 20:47'!description	"A message from the domain."	^description! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:06'!description: aString	description _ aString! !!MaProgressor methodsFor: 'private' stamp: 'cmm 7/19/2004 23:06'!initialize	super initialize.	stopwatch _ MaStopwatch new.	unitsVerbPhrase _ ' units processed.'.	unitsCompleted _ 0.	log _ OrderedCollection new.	description _ 'not running.'! !!MaProgressor methodsFor: 'testing' stamp: 'cmm 6/30/2003 16:21'!isRunning	^stopwatch isRunning! !!MaProgressor methodsFor: 'testing' stamp: 'cmm 8/7/2003 17:06'!knowsTaskSize	^self taskSize notNil and: [ self taskSize > 0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:30'!percentComplete	"Answers a Float between 0.0 and 1.0."	^self knowsTaskSize		ifTrue: [ (unitsCompleted / taskSize) asFloat ]		ifFalse: [ 0.0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/6/2003 14:31'!progressMessage	^String streamContents:		[ : stream |		stream maPrint: self unitsCompleted.		self knowsTaskSize			ifTrue:				[ stream					maPrint: ' of ';					maPrint: self taskSize ].		stream space.		stream maPrint: self unitsVerbPhrase ] ! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 1/19/2004 00:17'!rateMessage	^String streamContents:		[ : stream |		stream			maPrint: self ratePerSecond;			maPrint: ' / second in ';			maPrint: stopwatch time abbreviatedString ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 12/18/2004 18:46'!ratePerSecond	| totalMilliseconds |	^ (totalMilliseconds _ self runningTime totalMilliseconds) > 0		ifTrue: [ (self unitsCompleted * 1000 / totalMilliseconds) asFloat roundTo: 0.1 ]		ifFalse: [ 0.0 ]! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/6/2003 12:45'!remainingTime	self maMarked: 'dev'! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:33'!runningTime	^stopwatch time! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:28'!start	stopwatch start! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 8/4/2003 23:04'!startTime	^stopwatch startTime! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/30/2003 16:18'!stop	stopwatch stop! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:27'!taskSize	^taskSize! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:27'!taskSize: anInteger	taskSize _ anInteger! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:32'!unitsCompleted	^unitsCompleted! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:33'!unitsCompleted: anInteger	unitsCompleted _ anInteger! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:32'!unitsVerbPhrase	^unitsVerbPhrase! !!MaProgressor methodsFor: 'accessing' stamp: 'cmm 6/29/2003 23:28'!unitsVerbPhrase: aString	unitsVerbPhrase _ aString! !!MaProgressor methodsFor: 'updating' stamp: 'cmm 11/13/2003 00:41'!updateFrom: aMaProgressNotification	self advance: aMaProgressNotification advanceCount.	aMaProgressNotification hasDescription ifTrue: [ self description: aMaProgressNotification description ].	aMaProgressNotification hasTaskSize ifTrue: [ self taskSize: aMaProgressNotification taskSize ].	aMaProgressNotification hasUnitsCompleted ifTrue: [ self unitsCompleted: aMaProgressNotification unitsCompleted ].	aMaProgressNotification hasUnitsVerbPhrase ifTrue: [ self unitsVerbPhrase: aMaProgressNotification unitsVerbPhrase ].	aMaProgressNotification hasLogMessage ifTrue: [ self addLogMessage: aMaProgressNotification logMessage ]! !!MaQueryExecutor class methodsFor: 'create' stamp: 'cmm 6/11/2006 20:06'!collectionManager: aMagmaCollectionManager expression: aMaExpression 	^ self new 		setCollectionManager: aMagmaCollectionManager		expression: aMaExpression! !!MaQueryExecutor methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:53'!fractionComplete	^ trunkPosition 		ifNil: [ 0 ]		ifNotNil: 			[ | trunkSize |			trunkSize _ self trunk trunkSize.			trunkSize = 0 				ifTrue: [ 1 ]				ifFalse: [ trunkPosition / self trunk trunkSize ] ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 8/31/2006 19:03'!load: aMagmaCollectionSegment upTo: anInteger withObjects: aBoolean except: removedSet 	"Load my segment with up to anInteger oids.  Since we load segments in succession, only capture the answer oids for the page that surrounds targetIndexInteger."	| trunkEndPosition hitCount highestKey endIndex |	highestKey _ hitCount _ 0.	trunkEndPosition _ self 		trunkFrom: aMagmaCollectionSegment trunkStart		do: 			[ : eachKey : eachOid | 			(expression 				shouldInclude: eachOid				using: collectionManager) ifTrue: 				[ highestKey _ eachKey max: highestKey.				(removedSet includes: eachOid) ifFalse: 					[ hitCount _ hitCount + 1.					aBoolean ifTrue: [ aMagmaCollectionSegment addObject: eachOid ] ] ] ]		until: [ hitCount = anInteger ].	endIndex _ aMagmaCollectionSegment startIndex + hitCount - 1.	aMagmaCollectionSegment		trunk: self trunk ;		highestKey: highestKey ;		trunkEnd: trunkEndPosition.	aMagmaCollectionSegment endIndex: endIndex.	self 		recordLastKnownSizeOn: aMagmaCollectionSegment		to: endIndex		ifBeyond: trunkEndPosition! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 7/28/2006 14:57'!recordLastKnownSizeOn: aMagmaCollectionReaderSegment to: endIndex ifBeyond: trunkEndPosition 	trunk trunkSize = 0 		ifTrue: 			[ "empty, no possible results"			aMagmaCollectionReaderSegment lastKnownSize: 0 ]		ifFalse: 			[ trunkEndPosition ifNotNil: 				[ aMagmaCollectionReaderSegment lastKnownSize: (trunkEndPosition >= trunk trunkSize ifTrue: [ endIndex ]) ] ]! !!MaQueryExecutor methodsFor: 'initializing' stamp: 'cmm 6/11/2006 20:06'!setCollectionManager: aMagmaCollectionManager expression: aMaExpression 	collectionManager _ aMagmaCollectionManager.	expression _ aMaExpression! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 6/13/2006 13:27'!trunk	^ trunk ifNil: 		[ trunk _ MaQueryTrunk new.		expression 			addMinimumEnumerationsTo: trunk			using: collectionManager.		trunk ]! !!MaQueryExecutor methodsFor: 'private' stamp: 'cmm 7/26/2006 17:36'!trunkFrom: startPosition do: twoArgBlock until:  conditionBlock	"Enumerate my query-trunk from a particular starting point."	| trunkSearchPosition |	trunkSearchPosition _ 1.	trunkPosition _ nil.	self trunk trunkDo: 		[ : eachTrunkClause | 		| hdx rangeSize |		hdx _ collectionManager oidsIndexForAttribute: eachTrunkClause attribute.		rangeSize _ hdx 			numberOfEntriesFrom: eachTrunkClause lowKey			to: eachTrunkClause highKey.		eachTrunkClause lastKnownSize: rangeSize.		"is this NOT the trunk-clause which will contain trunk-position startPosition?"		trunkSearchPosition + rangeSize - 1 < startPosition 			ifTrue: [ trunkSearchPosition _ trunkSearchPosition + rangeSize ]			ifFalse: 				[ "trunkSearchPosition is only set to position of the beginning of this clause of the trunk, trunkPosition keeps the actual trunkPosition."				trunkPosition ifNil: [ trunkPosition _ startPosition - 1 "start one-back since we pre-increment (because post-increment leaves it advanced one too far)" ].				conditionBlock value ifFalse:					[ hdx 						keysAndValuesFrom: eachTrunkClause lowKey						startingAt: (startPosition - trunkSearchPosition + 1 max: 1)						do: 							[ : eachKey : eachOid | 							trunkPosition _ trunkPosition + 1.							twoArgBlock value: eachKey value: eachOid  ]						until: 							[ : eachKey : eachOid | 							conditionBlock value 							or: [ eachKey > eachTrunkClause highKey ] ].					trunkSearchPosition _ trunkPosition ] ]. ].	^ trunkPosition! !!MaQueryTrunk commentStamp: '<historical>' prior: 0!My ranges represent the shortest path through the query.!!MaQueryTrunk methodsFor: 'initializing' stamp: 'cmm 5/31/2006 20:19'!addClause: aMaQueryTrunkClause 	^ clauses add: aMaQueryTrunkClause! !!MaQueryTrunk methodsFor: 'initializing' stamp: 'cmm 5/31/2006 20:36'!initialize	super initialize.	clauses _ OrderedCollection new! !!MaQueryTrunk methodsFor: 'accessing' stamp: 'cmm 7/2/2006 21:12'!sortAttribute	"My clauses are reduced to just the ones that must be enumerated to find the result.  If that reduction was down to one then the order will be per that indexed attribute."	^ clauses size = 1 ifTrue: [ clauses first attribute ]! !!MaQueryTrunk methodsFor: 'enumerating' stamp: 'cmm 5/31/2006 21:58'!trunkDo: aBlock	clauses do: aBlock! !!MaQueryTrunk methodsFor: 'accessing' stamp: 'cmm 5/31/2006 20:11'!trunkSize	^ clauses inject: 0 into: [ : sum : each | sum + each lastKnownSize ]! !!MaRecordBroker commentStamp: 'cmm 5/18/2005 09:46' prior: 0!I am an abstract superclass for record-based collections such as MaHashIndex and MaLargeArrayOfNumbers.  By plugging them with my appropriate subclass, they are able to be file-based or in-memory (or maybe remote network location in the future).I don't actually deal with the records themselves, just their reading and writing to the storage.!!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 5/17/2005 23:32'!close	file ifNotNil: [ file closed ifFalse: [ file close ] ]! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 6/13/2005 23:22'!create: aFileStream	file _ aFileStream ifNil: [ ReadWriteStream on: (ByteArray new: 1000) ]! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 5/18/2005 13:30'!delete	self close.	(FileDirectory forFileName: file name) deleteFileNamed: file name! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 5/18/2005 14:30'!filePositionFor: recordIndex	^ recordIndex * recordSize + headerSize! !!MaFileRecordBroker methodsFor: '*magma server-recovery' stamp: 'cmm 6/3/2005 17:28'!fileSize	^ file size! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 5/30/2006 08:49'!filename	^ file filename! !!MaFileRecordBroker methodsFor: '*magma server-recovery' stamp: 'cmm 7/6/2005 22:52'!filesDo: oneArgBlock	oneArgBlock value: file! !!MaFileRecordBroker methodsFor: 'overriding' stamp: 'cmm 5/23/2005 14:11'!nextRecordNumber	^ (file size - self headerSize) / recordSize! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 6/14/2005 10:31'!open: aReadWriteStream	file _ aReadWriteStream! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 5/17/2005 23:28'!readHeaderInto: aByteArray	file		maRead: self headerSize		bytesFromPosition: 1		of: aByteArray		atFilePosition: 0! !!MaFileRecordBroker methodsFor: 'record' stamp: 'cmm 5/22/2005 22:53'!readInto: aMaFixedLengthRecord at: recordIndex	file		maRead: recordSize		bytesFromPosition: 1		of: aMaFixedLengthRecord byteArray		atFilePosition: (self filePositionFor: recordIndex)! !!MaFileRecordBroker methodsFor: '*magma server-recovery' stamp: 'cmm 6/1/2005 13:19'!recoverUsing: aMaBeforeImageRecord	file		maWrite: aMaBeforeImageRecord recordSize		bytesFromPosition: 1		of: aMaBeforeImageRecord record		atFilePosition: aMaBeforeImageRecord location! !!MaFileRecordBroker methodsFor: 'overriding' stamp: 'cmm 5/23/2005 14:12'!size	^ self nextRecordNumber! !!MaFileRecordBroker methodsFor: '*magma server-recovery' stamp: 'cmm 7/12/2005 22:45'!unapplyUsing: aMaApplyRecord	aMaApplyRecord unapplySelf: file physicalStream! !!MaFileRecordBroker methodsFor: 'record' stamp: 'cmm 5/22/2005 22:54'!writeFrom: aMaFixedLengthRecord at: recordIndex	file		maWrite: recordSize		bytesFromPosition: 1		of: aMaFixedLengthRecord byteArray		atFilePosition: (self filePositionFor: recordIndex)! !!MaFileRecordBroker methodsFor: 'file-specific' stamp: 'cmm 7/11/2005 09:03'!writeHeaderFrom: aByteArray	file		maWrite: self headerSize		bytesFromPosition: 1		of: aByteArray		atFilePosition: 0! !!MaInImageRecordBroker methodsFor: 'overriding' stamp: 'cmm 5/23/2005 23:24'!close	"nothing to do.."! !!MaInImageRecordBroker methodsFor: 'initialize' stamp: 'cmm 5/23/2005 17:22'!initialize	super initialize.	records _ OrderedCollection new! !!MaInImageRecordBroker methodsFor: 'initialize' stamp: 'cmm 5/23/2005 14:34'!nextRecordNumber	^ records size! !!MaInImageRecordBroker methodsFor: 'overriding' stamp: 'cmm 5/25/2005 16:24'!readInto: aMaFixedLengthRecord at: recordIndex	"Since records can be 0-based (sigh), we +1 the recordIndex."	aMaFixedLengthRecord byteArray: (records at: recordIndex+1) byteArray copy! !!MaInImageRecordBroker methodsFor: 'overriding' stamp: 'cmm 5/23/2005 23:37'!writeFrom: aMaFixedLengthRecord at: recordIndex	(records 		at: recordIndex+1		ifAbsentPut: aMaFixedLengthRecord copy) byteArray: aMaFixedLengthRecord byteArray copy! !!MaRecordBroker class methodsFor: 'as yet unclassified' stamp: 'cmm 5/17/2005 23:52'!headerSize: anInteger	^ self new		headerSize: anInteger ;		yourself! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/23/2005 14:32'!delete	"Do nothing by default."! !!MaRecordBroker methodsFor: 'accessing' stamp: 'cmm 6/5/2005 12:55'!fileSize	"Typically only needed for file-based brokers, but needed here for compatibility of non file-based brokers."	^ self size * self recordSize! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/17/2005 22:52'!filename	self subclassResponsibility ! !!MaRecordBroker methodsFor: '*magma server-recovery' stamp: 'cmm 7/5/2005 22:29'!filesDo: aBlock	"nothing to do by default."! !!MaRecordBroker methodsFor: 'accessing' stamp: 'cmm 5/17/2005 23:49'!headerSize	^ headerSize! !!MaRecordBroker methodsFor: 'accessing' stamp: 'cmm 5/17/2005 23:49'!headerSize: anInteger	headerSize _ anInteger! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/17/2005 23:01'!nextRecordNumber	self subclassResponsibility ! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/17/2005 23:01'!open: fileNameString	self subclassResponsibility ! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/23/2005 22:50'!readInto: aMaFixedLengthRecord at: recordIndex	self subclassResponsibility! !!MaRecordBroker methodsFor: 'accessing' stamp: 'cmm 5/22/2005 21:15'!recordSize	^ recordSize! !!MaRecordBroker methodsFor: 'accessing' stamp: 'cmm 5/22/2005 21:15'!recordSize: anInteger	recordSize _ anInteger! !!MaRecordBroker methodsFor: 'override' stamp: 'cmm 5/23/2005 23:04'!writeFrom: aMaFixedLengthRecord at: recordIndex	self subclassResponsibility! !!MaRecoveryManager commentStamp: 'cmm 7/4/2005 23:07' prior: 0!I am responsible for recovery behaviors.Commit-packages received into the server are prepared, serialized and flushed, wrapped in MaRecoveryRecord, to a commitPackages file.  A separate process runs repeatedly, Delaying five seconds and then forking an atomicApply.An atomicApply enumerates all of the MaTransactionalFileWriters and captures before-images of the portions of the files about to be overwritten, flushes them to the before-images file.  Then flushes all of the MaTransactionalFileWriters to their respective files.  Finally, an endApply record is flushed to the before-images file and the commitPackages filePointer is reset.Reads can be interleaved with the atomicWrite but not commits.  We want to be sure to only apply to the files *between* commits.  So we could use a commitCritical: method to MaObjectRepository and also each MaTransactionalFileStream would need to have a read guard.RecoveryIf an outage occurs, we have, in the worst case:	1) some data partially applied	2) some data written to commitPackages, but not yet appliedRecovery addresses these in order.Read the apply-file and look for an incomplete group, a set of RecoveryRecords that have no EndApplyRecord.  If this condition is discovered, the server was in the middle of an atomicApply when failure occurred.  A partial apply occurred and we must write all of the before-images back to the various files.  Do that.Now we know we do not have corrupt files, however we next need to apply all of the commitPackages that were written to the commitPackages file but not yet applied.*If* we had an incomplete group of recovery records in step 1, the entire commitPackages file will need reapplied.  Otherwise, we just apply the commitPackages whose groupId is greater than the groupId of the group in the applyFile, which will be all or none of them.The CommitPackages FileWhen the server receives a commit-package, it contains a bunch of MaObjectBuffers of the changes that client applied.  Some of these buffers are for new (uncomitted) objects (which can be identified by their oid being in the reserved range for new-objects).  Before writing, the server will examine the commit-package to determine whether its application will result in any commit-conflicts (and signal an exception if necessary).  Next, it must assign permanent-oids for all of the new objects and update references to them in the other buffers.Now the commit-package is flushed to the commits file.  Hopefully what was just written will never need to be read.!!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 6/9/2005 15:55'!applyFilename	^ 'applied.images'! !!MaRecoveryManager class methodsFor: 'accessing' stamp: 'cmm 7/7/2005 22:28'!commitPackagesFilename	^ 'commitPackages'! !!MaRecoveryManager class methodsFor: 'create' stamp: 'cmm 5/30/2005 22:28'!open: aFileDirectory	^ self new		open: aFileDirectory ;		yourself! !!MaRecoveryManager methodsFor: 'debugging' stamp: 'cmm 7/16/2005 17:58'!applyRecords	| answer |	answer _ OrderedCollection new.	[ self applyRecordsDo:		[ : each |		answer add: each independentCopy ] ]		on: MaUnreadableRecoveryRecord		do: [ : err | answer add: err messageText ].	^ answer! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!applyRecordsDo: aBlock	"Enumerate the block of RecoveryRecords for a single groupId in my applyFile."	| currentPosition selectedRecord |	currentPosition _ 0.	[ selectedRecord _ 		self 			readRecoveryFile: applyFile			at: currentPosition.	selectedRecord isBeginApply		ifTrue: [ groupId _ selectedRecord groupId ]		ifFalse: 			[ selectedRecord groupId = groupId				ifFalse:					[ MaUnreadableRecoveryRecord signal: 'expected groupId ', groupId printString, ' but encountered record with ', selectedRecord groupId printString. ] ].	aBlock value: selectedRecord.	selectedRecord isEndApply ]		whileFalse:			[ currentPosition _ currentPosition + selectedRecord physicalSize ]! !!MaRecoveryManager methodsFor: 'access' stamp: 'cmm 6/2/2005 22:51'!beforeImagesBaseFilename	^ 'recovered'! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/12/2005 14:28'!beginApply	self preMadeBeginApplyRecord		groupId: self getNextGroupId ;		writeTo: applyFile  "no need to flush until the first ApplyRecord is written."! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/4/2005 23:19'!close	applyFile close.	commitPackagesFile close! !!MaRecoveryManager methodsFor: 'debugging' stamp: 'cmm 7/16/2005 18:19'!commitPackageRecords	| answer |	answer _ OrderedCollection new.	[ self commitPackageRecordsDo:		[ : each |		answer add: each independentCopy ] ]		on: MaUnreadableRecoveryRecord		do: [ : err | answer add: err messageText ].	^ answer! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/10/2005 23:37'!commitPackageRecordsDo: aBlock	"Because the file is truncated after every successful open, we know the only possible well-formed records starting from the beginning are the ones that need to be reapplied."	| currentPosition selectedRecord |	currentPosition _ 0.	[ selectedRecord _ 		self 			readRecoveryFile: commitPackagesFile			at: currentPosition.	aBlock value: selectedRecord.	commitPackagesFile atEnd ]		whileFalse:			[ currentPosition _ currentPosition + selectedRecord physicalSize ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/13/2005 17:25'!deleteFilesQueuedForDelete	filesToDelete do:		[ : each |  | fd |		(fd _ FileDirectory on: each) deleteFileNamed: (fd localNameFor: each) ].	self initializeFilesToDelete! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/25/2005 17:06'!endApply	self preMadeEndApplyRecord		groupId: groupId ;		writeTo: applyFile.	applyFile flush.	self deleteFilesQueuedForDelete.	"Ok, this group is a wrap.  We can now start back at the beginning."	applyFile position: 0.	commitPackagesFile position: 0.	serializer resetOidManager! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 5/31/2005 17:36'!ensureByteArray: aByteArray canHold: anInteger	| newAnswer |	^aByteArray size < anInteger		ifTrue:			[ newAnswer _ ByteArray new: anInteger.			newAnswer				replaceFrom: 1				to: aByteArray size				with: aByteArray				startingAt: 1.			newAnswer ]		ifFalse: [ aByteArray ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/7/2005 22:58'!flush	applyFile flush! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 6/5/2005 21:40'!getNextGroupId 	^ groupId _ groupId + 1! !!MaRecoveryManager methodsFor: 'access' stamp: 'cmm 6/2/2005 22:49'!imagesExtension	^ 'images'! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 7/16/2005 22:07'!initialize	super initialize.	groupId _ 0.	self 		initializePreMadeRecords ;		initializeFilesToDelete ;		initializeSerializer! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 6/6/2005 12:37'!initializeFilesToDelete	filesToDelete _ OrderedCollection new! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 7/8/2005 11:07'!initializePreMadeRecords	preMadeRecords _ 		{ MaBeginApplyRecord new.		MaBeforeImageRecord new.		MaFileGrowthRecord new.		MaNewFileRecord new.		MaEndApplyRecord new.		MaCommitPackageRecord new }! !!MaRecoveryManager methodsFor: 'initialize' stamp: 'cmm 8/17/2005 19:12'!initializeSerializer	| allClasses |	serializer := MaObjectSerializer new.	allClasses := OrderedCollection new.	allClasses addAll: 		{ MaCommitLogEntry.  MaCommitPackage.  IdentityDictionary.  MaCommitResult.  MaSerializedGraphBuffer. MaChangedKeySpecification }.	MaObjectBuffer withAllSubclassesDo: [ : each | allClasses add: each ].	MagmaLargeCollectionChanges allSubclassesDo: [ : each | allClasses add: each ].	MagmaCollectionIndex allSubclassesDo: [ : each | allClasses add: each ].	allClasses do: [ : each | serializer classIdManager addNewClass: each ]! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!isRollbackNeeded	| hasRecords hasValidEndApplyIndicator |	hasRecords _ false.	hasValidEndApplyIndicator _ false.	[ self applyRecordsDo:		[ : each |		each isBeginApply ifTrue: [ hasRecords _ true ].		each isEndApply			ifTrue:				[ hasValidEndApplyIndicator _ true ] ] ]		on: MaUnreadableRecoveryRecord		do: 			[ : error |			"An incomplete set of records for a single transactionId was found."			MagmaNotification signal: error messageText.			error return ].	^ hasRecords and: [ hasValidEndApplyIndicator not ]! !!MaRecoveryManager methodsFor: 'commit-packages' stamp: 'cmm 7/16/2005 22:09'!log: aMaCommitLogEntry flush: aBoolean	self preMadeCommitPackageRecord		record: (serializer serializeGraph: aMaCommitLogEntry) trimmedByteArray ;		groupId: self getNextGroupId ;		writeTo: commitPackagesFile.	aBoolean ifTrue: [ commitPackagesFile flush ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/4/2005 23:25'!open: aFileDirectory	self		openApplyFile: aFileDirectory ;		openCommitPackagesFile: aFileDirectory! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/7/2005 15:09'!openApplyFile: aFileDirectory	applyFile _ aFileDirectory fileNamed: self class applyFilename.	applyFile		binary ;		position: 0! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/7/2005 22:32'!openCommitPackagesFile: aFileDirectory	commitPackagesFile _ aFileDirectory fileNamed: self class commitPackagesFilename.	commitPackagesFile		binary ;		position: 0! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:40'!preMadeBeforeImageRecord	^ preMadeRecords at: MaBeforeImageRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeBeginApplyRecord 	^ preMadeRecords at: MaBeginApplyRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 7/8/2005 11:06'!preMadeCommitPackageRecord 	^ preMadeRecords at: MaCommitPackageRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeEndApplyRecord 	^ preMadeRecords at: MaEndApplyRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeFileGrowthRecord	^ preMadeRecords at: MaFileGrowthRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'preMadeRecords' stamp: 'cmm 6/5/2005 16:41'!preMadeNewFileRecord	^ preMadeRecords at: MaNewFileRecord assignedRecordType! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!primitiveRecoverUsing: aMaObjectRepository	"This recovery only happens if there was an outage exactly at the moment where the system was writing its own definition.  In that case, it would not even be able to open properly to perform a normal recovery; therefore we do this initial recovyer which should then *allow* it to materialize its definition so that it can then perform a normal recovery which will get the large-collections.  Whew!!"	MagmaRecoveryNotification signal: 'System recovery needed!!'.	[ self applyRecordsDo: 		[ : eachRecoveryRecord | 		(eachRecoveryRecord isApply and: [ eachRecoveryRecord isForObjectsFile or: [ eachRecoveryRecord isForFilePositionsFile ] ])			ifTrue:				[ aMaObjectRepository unapply: eachRecoveryRecord ] ] ]		on: MaUnreadableRecoveryRecord		do: 			[ : error | 			MagmaRecoveryNotification signal: error messageText, '.  System recovery complete.' ].	^ true! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 6/6/2005 12:40'!queueForDelete: filename	filesToDelete add: filename! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 5/31/2006 19:13'!readRecoveryFile: aStandardFileStream at: filePosition	| messagePrefix bytesRead inputRecord |	messagePrefix _ 'Ungraceful end of commit-group:  '.	inputRecord _ MaRecoveryRecord new: self reasonableRecordSize.	bytesRead _ aStandardFileStream		maRead: self reasonableRecordSize		bytesFromPosition: 1		of: inputRecord byteArray		atFilePosition: filePosition.	(bytesRead between: 1 and: MaRecoveryRecord sizeOfPhysicalSizeField) ifTrue: [ MaUnreadableRecoveryRecord signal: messagePrefix, 'physicalSize field truncated' ].	inputRecord physicalSize = 0 ifTrue: [ MaUnreadableRecoveryRecord signal: messagePrefix, 'physicalSize 0 found.' ].	inputRecord physicalSize > self unreasonablePhysicalSize		ifTrue: [ MaUnreadableRecoveryRecord signal: messagePrefix, 'unreasonable physicalSize found' ].	"check physicalSize to see if we've read enough."	inputRecord physicalSize > bytesRead 		ifTrue:			[ "We haven't read enough, read the rest, ensuring we get as much as we should."			inputRecord byteArray:				(self					ensureByteArray: inputRecord byteArray					canHold: inputRecord physicalSize).			bytesRead _ aStandardFileStream				maRead: inputRecord physicalSize - self reasonableRecordSize				bytesFromPosition: self reasonableRecordSize + 1				of: inputRecord byteArray				atFilePosition: filePosition + self reasonableRecordSize.			bytesRead = (inputRecord physicalSize - self reasonableRecordSize) ifFalse: [ MaUnreadableRecoveryRecord signal: messagePrefix, 'end of file' ] ].	inputRecord hasValidCheckSum 		ifFalse:			[ MaUnreadableRecoveryRecord signal: 'record could not validate its checkSum.' ].	^ self selectPreMadeRecord: inputRecord! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/17/2005 12:13'!reapplyCommitPackagesUsing: aMaObjectRepository	"Note, we just performed step 1 of the recovery which should have properly set my groupId."	| count |	count _ 0.	groupId = 0 "we didn't get a valid beginApply record!!" ifTrue: [ ^ self ].	[ self commitPackageRecordsDo: 		[ : each |  | eachCommitLogEntry |		each groupId > groupId			ifTrue:				[ (MagmaServerPreferences debugRecovery and: [ count = 0 ]) ifTrue: [ self halt: 'about to reapply' ].				count _ count + 1.				eachCommitLogEntry _ serializer materializeGraph: each record.				aMaObjectRepository applyToCache: eachCommitLogEntry ] ] ]		on: MaUnreadableRecoveryRecord		do: 			[ : error | 			MagmaRecoveryNotification signal: error messageText, '.  ', count printString, ' reapply''s completed.' ].	count > 0 ifTrue: [ aMaObjectRepository flushCache ]! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/11/2005 09:28'!reasonableRecordSize	^ 100! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/11/2005 09:33'!resetFiles	"Done with a recovery, now we should truncate both files so that future sessions have no chance to encounter the data in these files and think recovery operations are needed from them (very remote chance, but possible on the commitPackages file.."	commitPackagesFile truncate; close; open.	applyFile truncate; close; open! !!MaRecoveryManager methodsFor: 'recover' stamp: 'cmm 7/15/2005 16:25'!rollbackUsing: aMaObjectRepository	"If a beginApply record with a valid checkSum is found, then we must find a corresponding endApply record also with a valid checkSum.  If we don't, then we must reverse the entire transaction by starting back at the beginning and applying all of the beforeImage records with valid checkSums back to their files."	MagmaServerPreferences debugRecovery ifTrue: [ self halt: 'about to rollback' ].	[ self applyRecordsDo: 		[ : each | each isApply ifTrue: [ aMaObjectRepository unapply: each ] ] ]		on: MaUnreadableRecoveryRecord		do: 			[ : error | 			MagmaRecoveryNotification signal: error messageText, '.  Rollback complete.' ].	aMaObjectRepository repositoryController close "because class-definitions or largeCollections may have even needed rolled-back; refreshView will not refresh them.".	aMaObjectRepository deleteApplyFile.  "so we don't try to recover again on the next open.."	aMaObjectRepository repositoryController open! !!MaRecoveryManager methodsFor: 'file' stamp: 'cmm 7/15/2005 16:25'!selectPreMadeRecord: aMaApplyRecord	^ (preMadeRecords 		at: aMaApplyRecord recordType		ifAbsent:			[ MaUnreadableRecoveryRecord signal: 'Ungraceful end of commit-group:  invalid recordType found (', aMaApplyRecord recordType printString, ').' ])		byteArray: aMaApplyRecord byteArray copy ;		yourself! !!MaRecoveryManager methodsFor: 'error handling' stamp: 'cmm 5/31/2005 21:48'!unreasonablePhysicalSize	"No commit record should ever be more than 10-meg.  Due to the nature of disaster-recovery, it is possible we are reading a partially-written file.  It could potentially have even shot-craps in the middle of writing the physicalSize portion of the record.  Therefore, we cannot trust even that not to have bytes in it that cause the computer to attempt to allocate gigs of resources.."	^ 10000000! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/13/2005 15:03'!writeBeforeImageRecordsFrom: aMaTransactionalFileStream fileId: fileId	| hasWrittenFileGrowth |	hasWrittenFileGrowth _ false.	aMaTransactionalFileStream writersDo:		[ : each |		each willCauseGrowth			ifTrue:				[ hasWrittenFileGrowth "Only need to write one of these."					ifFalse:						[ self preMadeFileGrowthRecord							originalSize: aMaTransactionalFileStream committedSize ;							fileId: fileId ;							groupId: groupId ;							writeTo: applyFile.						hasWrittenFileGrowth _ true ] ]			ifFalse:				[ self preMadeBeforeImageRecord					location: each filePos ;					record: each currentRecord ;					fileId: fileId ;					groupId: groupId ;					writeTo: applyFile ] ]! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/7/2005 13:03'!writeFileGrowthRecordFrom: aMaTransactionalFileStream fileId: fileId	self preMadeFileGrowthRecord		originalSize: aMaTransactionalFileStream committedSize ;		fileId: fileId ;		groupId: groupId ;		writeTo: applyFile! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 5/24/2006 22:21'!writeNewFileRecordFrom: aMaTransactionalFileStream fileId: fileId	self preMadeNewFileRecord		filename: aMaTransactionalFileStream filename ;		fileId: fileId ;		groupId: groupId ;		writeTo: applyFile! !!MaRecoveryManager methodsFor: 'record' stamp: 'cmm 7/16/2005 18:03'!writeRollbackRecordsFor: aMaTransactionalFileStream fileId: fileId	aMaTransactionalFileStream isNew		ifTrue:			[ self 				writeNewFileRecordFrom: aMaTransactionalFileStream				fileId: fileId ]		ifFalse: 			[ self				writeBeforeImageRecordsFrom: aMaTransactionalFileStream				fileId: fileId ]! !!MaRecoveryRecord commentStamp: 'cmm 7/11/2006 20:33' prior: 0!My instances are records that faciliate the automatic recovery of Magma files when the server was interrupted by an external event such as a power-outage or sysadmin killing of my VM, and files could be partially applied and in an inconsistent state.There are four types of changes that can occur to a file that must be tracked:	- the file was just created new (MaNewFileRecord), when recover we delete it.	- updating bytes within an existing file (MaBeforeImageRecord).  When we recover we put those bytes back.	- extending the length of a file with new bytes (MaFileGrowthRecord).  When we recover we truncate the file back to its original length.	- an existing file is deleted.  To handle this we simply don't delete the file until the entire apply has completed and flushed successfully.There are also two records which indicate the begin and end of the group of records for a single commit (by transactionId).  My transactionId associates me with all of my other records for this transaction.Every record also has a hash-checkSum calculated so that the recovery process can ensure the record was written wholly and correctly.All of this is contained completely within my own ByteArray with the following format (0-based positions):	0 : physicalSize (3-bytes)	3 : record type (1-byte)	4 : group-id (4-bytes)	8 to: n-21 : ... other fields implemented by my subclasses ...	n-20 - checkSum (SHA1)!!MaApplyRecord commentStamp: 'cmm 6/5/2005 14:21' prior: 0!I am an abstract class for the types of records that, on recovery, require rollback of some particular file.  My fileId identifies which file it is.	... see superclass ...	8 - file-id (8-bytes), identifies which file this record describes	... subclasses may add more fields ...	... see superclass ...!!MaApplyRecord class methodsFor: 'as yet unclassified' stamp: 'cmm 6/3/2005 17:16'!filePositionsFileId	^ 2! !!MaApplyRecord class methodsFor: 'as yet unclassified' stamp: 'cmm 6/3/2005 17:16'!objectsFileId	^ 1! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 15:47'!bufferPositionOfFileId	"This field is 8-bytes to make it easy for Magma.  6-bytes for the oid, 2-bytes for the index #."	^ 8! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 6/6/2005 10:29'!collectionOid	"for Magma, the fileId is stored in two parts, the high-order 6 bytes represent the oid of the collection.  The low-order 2 bytes represent the index # for that collection or 0 if it is the memberIndex.  This method answers the oid."	^ self fileId bitShift: -16! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:44'!fileId	^ byteArray		maUint: 64		at: self bufferPositionOfFileId! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:44'!fileId: anInteger	byteArray		maUint: 64		at: self bufferPositionOfFileId 		put: anInteger! !!MaApplyRecord methodsFor: 'accessing' stamp: 'cmm 6/5/2005 15:50'!headerSize	^ 16! !!MaApplyRecord methodsFor: 'testing' stamp: 'cmm 6/5/2005 18:13'!isApply	^ true! !!MaApplyRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:08'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(fileId)		on: aStream! !!MaApplyRecord methodsFor: 'recovery' stamp: 'cmm 6/5/2005 18:35'!unapplySelf: aStandardFileStream	self subclassResponsibility! !!MaBeforeImageRecord commentStamp: 'cmm 6/5/2005 14:21' prior: 0!This type of RecoveryRecord is used to restore any bytes in any file to their state prior to the beginning of the interrupted commit.My #fileId identifies the file that was updated.My #location provides information necessary to know *where* in the file I came from.	... see superclass ...	16 - file-position	22 - the record	... see superclass ...I should not be created for updates to new files or for writes beyond the end of the file.!!MaBeforeImageRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:38'!assignedRecordType	^ 2! !!MaBeforeImageRecord class methodsFor: 'private' stamp: 'cmm 7/4/2005 22:37'!record: aByteArrayself maMarked: 'delete'.	^ self new 		record: aByteArray size: aByteArray size startingAt: 1 ;		yourself! !!MaBeforeImageRecord methodsFor: 'debugging' stamp: 'cmm 6/2/2005 13:05'!asMaObjectBuffer	self fileId = 1 ifFalse: [ self error: 'not a before-image of a MaObjectBuffer.' ].	^ (MaObjectBuffer		byteArray: (ByteArray new: MaObjectBuffer oidSize/8), self record		startPos: 0) asSentientBuffer! !!MaBeforeImageRecord methodsFor: 'initializing' stamp: 'cmm 6/3/2005 16:18'!bodySize	^ 1000  "variable length"! !!MaBeforeImageRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 14:21'!bufferPositionOfLocation	"this field is 6 bytes"	^ 16! !!MaBeforeImageRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 14:21'!bufferPositionOfRecord	"this field is variable in size, and ends up determining how large the entire record is."	^ 22! !!MaBeforeImageRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 22:45'!headerSize	^ 22! !!MaBeforeImageRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 15:53'!isFixed	^ false! !!MaBeforeImageRecord methodsFor: 'testing' stamp: 'cmm 6/2/2005 16:54'!isForFilePositionsFile	^ self fileId = self class filePositionsFileId! !!MaBeforeImageRecord methodsFor: 'testing' stamp: 'cmm 6/1/2005 23:51'!isForLargeCollection	^ self fileId = 0 "member index"	or: [ self fileId > 1000 "it would be much larger than this but..." ]! !!MaBeforeImageRecord methodsFor: 'testing' stamp: 'cmm 6/2/2005 16:54'!isForObjectsFile	^ self fileId = self class objectsFileId! !!MaBeforeImageRecord methodsFor: 'accessing' stamp: 'cmm 6/1/2005 13:18'!location	^ byteArray		maUint: 48		at: self bufferPositionOfLocation! !!MaBeforeImageRecord methodsFor: 'initializing' stamp: 'cmm 6/1/2005 13:18'!location: anInteger	byteArray		maUint: 48		at: self bufferPositionOfLocation		put: anInteger! !!MaBeforeImageRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:09'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(location recordSize)		on: aStream! !!MaBeforeImageRecord methodsFor: 'recovery' stamp: 'cmm 6/5/2005 18:27'!unapplySelf: aStandardFileStream	aStandardFileStream		maWrite: self recordSize		bytesFromPosition: 1		of: self record		atFilePosition: self location! !!MaFileGrowthRecord commentStamp: 'cmm 6/5/2005 15:40' prior: 0!I am used to track files that grow in size while applying a commit.  I record the #originalSize such that, during recovery, the file can be truncated: back to its original size.I should not be created for new files.	... see superclass ...	16 - originalSize (6 bytes)	... see superclass ...!!MaFileGrowthRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 3! !!MaFileGrowthRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 16:00'!bodySize  "in bytes"	^ self sizeOfOriginalSizeField / 8! !!MaFileGrowthRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:09'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(originalSize)		on: aStream! !!MaFileGrowthRecord methodsFor: 'access' stamp: 'cmm 6/3/2005 16:01'!originalSize	^ byteArray		maUint: self sizeOfOriginalSizeField 		at: self headerSize! !!MaFileGrowthRecord methodsFor: 'access' stamp: 'cmm 6/3/2005 16:01'!originalSize: anInteger	^ byteArray		maUint: self sizeOfOriginalSizeField 		at: self headerSize		put: anInteger! !!MaFileGrowthRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 15:59'!sizeOfOriginalSizeField	^ 48 "bits"! !!MaFileGrowthRecord methodsFor: 'recovery' stamp: 'cmm 6/6/2005 10:34'!unapplySelf: aStandardFileStream	aStandardFileStream		truncate: self originalSize ;		"close and open to get around bug; see http://lists.squeakfoundation.org/pipermail/squeak-dev/2005-June/092041.html"		close ;		open! !!MaNewFileRecord commentStamp: 'cmm 6/5/2005 15:40' prior: 0!Sometimes new files are created during a commit.  If a disaster happens before that commit finishes then, upon recovery, those files should be deleted.I record the #filename of the file that should be deleted.	... see superclass ...	16 - filename (variable length)	... see superclass ...!!MaNewFileRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 4! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 16:18'!bodySize	^ 300  "variable length"! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!filename	^ (byteArray		copyFrom: self headerSize+1		to: self checkSumPosition-1) asString! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 7/4/2005 22:54'!filename: aString	self record: aString! !!MaNewFileRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 15:53'!isFixed	^ false! !!MaNewFileRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(filename)		on: aStream! !!MaNewFileRecord methodsFor: 'recovery' stamp: 'cmm 6/5/2005 18:36'!unapplySelf: aStandardFileStream	aStandardFileStream close.	aStandardFileStream directory deleteFileNamed: (aStandardFileStream directory localNameFor: aStandardFileStream name)! !!MaBeginApplyRecord commentStamp: 'cmm 6/3/2005 15:15' prior: 0!I am the first record of a group of RecoveryRecords for the same transactionId.  If a disaster happens in the middle of a commit and, during recovery, a valid BeginApply record is found in the apply file *without* a valid EndApply record, then we know the commit did not finish and all of the records must be unapplied.!!MaBeginApplyRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 1! !!MaBeginApplyRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 16:20'!bodySize	^ 0! !!MaBeginApplyRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isBeginApply	^ true! !!MaBeginApplyRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(isBeginApply)		on: aStream! !!MaCommitPackageRecord commentStamp: '<historical>' prior: 0!These are the "after-images" which are written to the commitPackages file.!!MaCommitPackageRecord class methodsFor: 'accessing' stamp: 'cmm 7/8/2005 11:05'!assignedRecordType	^ 6! !!MaEndApplyRecord commentStamp: 'cmm 6/3/2005 15:17' prior: 0!I am the last record of a group of RecoveryRecords for the same transactionId.  If a disaster happens then, during recovery, I am looked for in the applyFile with the same transactionId as my BeginApply counterpart.  If I'm found, then no were no commits happening at the time of the failure and, thus, no recovery is necessary.!!MaEndApplyRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:39'!assignedRecordType	^ 5! !!MaEndApplyRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 16:20'!bodySize	^ 0! !!MaEndApplyRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isEndApply	^ true! !!MaEndApplyRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 17:10'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(isEndApply)		on: aStream! !!MaRecoveryRecord class methodsFor: 'accessing' stamp: 'cmm 6/5/2005 16:54'!assignedRecordType	^ 0! !!MaRecoveryRecord class methodsFor: 'create' stamp: 'cmm 6/5/2005 16:46'!byteArray: aByteArray	^ self new		byteArray: aByteArray ;		yourself! !!MaRecoveryRecord class methodsFor: 'class initialization' stamp: 'cmm 6/5/2005 13:38'!initialize	super initialize.	self initializeReusableSha ! !!MaRecoveryRecord class methodsFor: 'class initialization' stamp: 'cmm 6/3/2005 14:41'!initializeReusableSha	ReusableSha _ SecureHashAlgorithm new! !!MaRecoveryRecord class methodsFor: 'create' stamp: 'cmm 6/5/2005 16:46'!new: anInteger	^ self byteArray: (ByteArray new: anInteger)! !!MaRecoveryRecord class methodsFor: 'accessing' stamp: 'cmm 6/3/2005 16:35'!sizeOfPhysicalSizeField	"this field, in particular, has its size defined this way because of the potential dual-read required should the initial default read not be large enough."	^ 3! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 16:47'!bodySize	"Subclasses override"	^ 0! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 21:34'!bufferPositionOfGroupId	"this fields is 4-bytes."	^ 4! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 14:21'!bufferPositionOfPhysicalSize	"This field is 3-bytes."	^ 0! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/5/2005 17:34'!bufferPositionOfRecordType	^ 3! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:22'!bufferSize	^ byteArray size! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:21'!byteArray	^ byteArray! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 6/3/2005 14:21'!byteArray: aByteArray	byteArray _ aByteArray! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!calculatedCheckSum	^ ReusableSha 		maHashMessage: byteArray		from: 1		to: self physicalSize - self checkSumSize! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!checkSum	^ byteArray		maUint: 160		at: self checkSumPosition-1 "-1 to convert to 0-based"! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSum: anInteger	^ byteArray		maUint: 160		at: self physicalSize - self checkSumSize		put: anInteger! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSumPosition	^ self physicalSize - self checkSumSize + 1! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!checkSumSize	^ 20 "bytes"! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 9/21/2005 09:53'!ensureCanHold: numberOfBytes	byteArray size >= (self headerSize + numberOfBytes + self checkSumSize)		ifFalse:			[ | newByteArray |			newByteArray := ByteArray new: self headerSize + numberOfBytes + self checkSumSize.			newByteArray				replaceFrom: 1				to: byteArray size				with: byteArray				startingAt: 1.			byteArray := newByteArray ]! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/5/2005 21:34'!groupId	^ byteArray		maUint: 32		at: self bufferPositionOfGroupId! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/5/2005 21:35'!groupId: anInteger	byteArray		maUint: 32		at: self bufferPositionOfGroupId 		put: anInteger! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 9/21/2005 10:52'!hasValidCheckSum	^ self checkSumPosition > self bufferPositionOfGroupId	and: [ self calculatedCheckSum = self checkSum ]! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 15:58'!headerSize	^ 8! !!MaRecoveryRecord methodsFor: 'copying' stamp: 'cmm 6/3/2005 14:33'!independentCopy	^ self copy		byteArray: (byteArray copyFrom: 1 to: self physicalSize) ;		yourself! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 9/21/2005 09:54'!initialize	super initialize.	byteArray := ByteArray new: self headerSize + self bodySize + self checkSumSize.	self isFixed ifTrue: [ self physicalSize: byteArray size ].	self recordType: self class assignedRecordType! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/5/2005 18:13'!isApply	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:57'!isBeginApply	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 16:58'!isEndApply	^ false! !!MaRecoveryRecord methodsFor: 'testing' stamp: 'cmm 6/3/2005 15:52'!isFixed	^ true! !!MaRecoveryRecord methodsFor: 'printing' stamp: 'cmm 6/5/2005 21:35'!maPrintAbbreviatedOn: aStream	super maPrintAbbreviatedOn: aStream.	self		maPrintAttributes: #(physicalSize recordType groupId)		on: aStream! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 6/3/2005 14:23'!physicalSize	^ byteArray		maUint: self class sizeOfPhysicalSizeField * 8		at: self bufferPositionOfPhysicalSize! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/3/2005 14:23'!physicalSize: anInteger	byteArray		maUint: self class sizeOfPhysicalSizeField * 8		at: self bufferPositionOfPhysicalSize		put: anInteger! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 7/16/2005 18:34'!record	| startOfRecord |	startOfRecord _ self headerSize+1 "because bufferPositionOfRecord is 0-based".	^ byteArray		copyFrom: startOfRecord		to: startOfRecord + self recordSize - 1! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 7/4/2005 22:53'!record: aByteArray	self		record: aByteArray		size: aByteArray size		startingAt: 1! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 9/21/2005 09:54'!record: aByteArray size: anInteger startingAt: startPos	self ensureCanHold: anInteger.	byteArray		replaceFrom: self headerSize+1		to: self headerSize + anInteger		with: aByteArray		startingAt: startPos.	self physicalSize: self headerSize + anInteger + self checkSumSize! !!MaRecoveryRecord methodsFor: 'as yet unclassified' stamp: 'cmm 9/21/2005 09:54'!recordSize	^ self physicalSize - self headerSize - self checkSumSize! !!MaRecoveryRecord methodsFor: 'accessing' stamp: 'cmm 7/5/2005 23:28'!recordType	"record type indicates what kind of MaRecoveryRecord this is.  See the class-side hierarchy, #assignedRecordType methods for the values."	^ byteArray		maUint: 8		at: self bufferPositionOfRecordType! !!MaRecoveryRecord methodsFor: 'initialize-release' stamp: 'cmm 7/5/2005 23:28'!recordType: anInteger	"record type indicates what kind of MaRecoveryRecord this is.  See the class-side hierarchy, #assignedRecordType methods for the values."	^ byteArray		maUint: 8		at: self bufferPositionOfRecordType		put: anInteger! !!MaRecoveryRecord methodsFor: 'private' stamp: 'cmm 6/10/2005 10:08'!resetChecksum	"Calculate my checksum which is used during recovery to ensure my byteArray was written completely and correctly."	self checkSum: self calculatedCheckSum.	MagmaServerPreferences debugRecovery ifTrue: [ self hasValidCheckSum ifFalse: [ self halt: 'checksum not correct!!' ] ]! !!MaRecoveryRecord methodsFor: 'file' stamp: 'cmm 6/6/2005 10:37'!writeTo: applyFile	self resetChecksum.	applyFile		next: self physicalSize		putAll: byteArray		startingAt: 1! !!MaRootAnchor commentStamp: 'cmm 2/28/2005 12:47' prior: 0!This class represents the real root of every repository.  It provides us with areplaceable root, since the locations of objects can never change.  It also makesit cleaner to write the root, since all we have to do is write this object using specialcode, then we can write the root by simply changing this object.This class will live on the client and server, since the client can ask for to replacethe root.!!MaRootAnchor class methodsFor: 'creation'!object: anObject	^self new object: anObject! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:55'!definition	^ definition! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:56'!definition: aMagmaRepositoryDefinition	definition _ aMagmaRepositoryDefinition! !!MaRootAnchor methodsFor: 'initialize-release' stamp: 'cmm 12/29/2004 00:03'!initialize	super initialize.	stats _ OrderedCollection new! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:55'!root	^ root! !!MaRootAnchor methodsFor: 'building' stamp: 'cmm 12/28/2004 23:55'!root: anObject	root _ anObject! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:56'!stats	^ stats! !!MaRootAnchor methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:56'!stats: aMagmaServerStatistics	stats _ aMagmaServerStatistics! !!MaSerializedGraphBuffer commentStamp: '<historical>' prior: 0!Header:	total physical size of this buffer.  Necessary because we otherwise have no	way of knowing where the actual end of the buffer is.!!MaSerializedGraphBuffer class methodsFor: 'creation' stamp: 'cmm 5/1/2005 22:27'!byteArray: aByteArray	^ self new		byteArray: aByteArray ;		yourself! !!MaSerializedGraphBuffer class methodsFor: 'private accessing' stamp: 'cmm 9/22/2002 23:52'!headerSize	"header only has 32-bit integer representing the physicalSize of my byteArray that holds the entire serialized graph."	^4! !!MaSerializedGraphBuffer class methodsFor: 'creation'!new: anInteger	^self new resetByteArray: (ByteArray new: anInteger)! !!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 10/21/2004 12:52'!bufferPositionsDo: oneArgBlock	"Value oneArgBlock with the value of the starting position of each	buffer in the receiver."	| pos end |	pos _ self headerSize.	end _ self bufferSize - 1.	[ pos <= end ] whileTrue:		[ oneArgBlock value: pos.		pos _			pos +				(byteArray 					maUint: 24					at: pos + MaObjectBuffer bufferPositionOfPhysicalSize) ]! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 4/3/2003 00:10'!bufferSize	^byteArray 		maUint: 32		at: 0! !!MaSerializedGraphBuffer methodsFor: 'private building' stamp: 'cmm 4/3/2003 00:11'!bufferSize: anInteger	byteArray		maUint: 32		at: 0		put: anInteger! !!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 4/26/2005 07:59'!bufferTypeAt: startPositionOfObjectBuffer	^ MaObjectBuffer		bufferTypeIn: byteArray		startingAt: startPositionOfObjectBuffer! !!MaSerializedGraphBuffer methodsFor: 'creation' stamp: 'cmm 6/15/2005 22:53'!buffers	| coll |	coll _ OrderedCollection new.	self buffersDo: [ :each | coll add: each independentCopy ].	^coll! !!MaSerializedGraphBuffer methodsFor: 'actions' stamp: 'cmm 4/3/2003 00:11'!buffersDo: oneArgBlock	"Value oneArgBlock with each ObjectBuffer in the	receiver.  There is one ObjectBuffer for each object in the graph that	the receiver represents."	| preMadeBuffers |	preMadeBuffers _ self newPremadeBuffers.	self bufferPositionsDo:		[ :eachPosition | | buffer |		buffer _ (preMadeBuffers at: (self bufferTypeAt: eachPosition)).		buffer			byteArray: byteArray;			startPos: eachPosition.		oneArgBlock value: buffer ]! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 3/28/2005 21:54'!buffersMissingFromWhole	"Answer whether I have all the object buffers needed to reconstitute my entire graph."	| oids missing |	missing _ OrderedCollection new.	oids _ (self buffers collect: [ : each | each oid ]) asSet.	self buffers do:		[ : each |		each species = MaFixedObjectBuffer			ifTrue:				[ each oids do:					[ : eachOid | 					((MaOidCalculator isOidForOptimizedObject: eachOid) not					and: [ (oids includes: eachOid) not ]) ifTrue: [ missing add: eachOid->each copyWithSameBuffer ] ] ] ].	^ missing! !!MaSerializedGraphBuffer methodsFor: 'accessing'!byteArray	"One ByteArray holds the entire graph of objects."	^byteArray! !!MaSerializedGraphBuffer methodsFor: 'building'!byteArray: aByteArray	byteArray _ aByteArray! !!MaSerializedGraphBuffer methodsFor: 'private creation' stamp: 'cmm 3/24/2005 12:49'!copy	^ super copy postCopy! !!MaSerializedGraphBuffer methodsFor: '*magma server' stamp: 'cmm 8/13/2002 21:27'!decreaseBufferSizeBy: anInteger	self bufferSize: self bufferSize - anInteger! !!MaSerializedGraphBuffer methodsFor: 'private' stamp: 'cmm 7/16/2002 21:42'!headerSize	^self class headerSize! !!MaSerializedGraphBuffer methodsFor: 'building' stamp: 'cmm 3/7/2005 14:37'!increaseBufferSizeBy: anInteger	anInteger < self headerSize		ifTrue:			[ MaObjectSerializationSoftwareError signal: 'This object being appended is not properly supported.' ].	self bufferSize: self bufferSize + anInteger! !!MaSerializedGraphBuffer methodsFor: 'debugging' stamp: 'cmm 2/7/2005 17:29'!isWhole	"Answer whether I have all the object buffers needed to reconstitute my entire graph."	^ self buffersMissingFromWhole isEmpty! !!MaSerializedGraphBuffer methodsFor: 'private creation' stamp: 'cmm 10/21/2004 12:52'!newPremadeBuffers	^MaObjectBuffer bufferClasses collect: [ :each | each new ]! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 2/15/2005 22:18'!objectCount	| count |	count _ 0.	self buffersDo: [ : each | count _ count + 1 ].	^ count! !!MaSerializedGraphBuffer methodsFor: 'private creation' stamp: 'cmm 5/2/2005 22:14'!postCopy	super postCopy.	byteArray := byteArray copy! !!MaSerializedGraphBuffer methodsFor: 'printing' stamp: 'cmm 7/25/2006 23:48'!printOn: aStream	super printOn: aStream.	byteArray notNil		ifTrue:			[ aStream				nextPutAll: ' (';				maPrint: self objectCount;				nextPutAll: ' objects in ';				maPrint: self bufferSize;				nextPutAll: ' bytes)' ]! !!MaSerializedGraphBuffer methodsFor: 'building'!resetBufferSize	"Reset the current pointer (which is the bufferSize) back to the beginning."	self bufferSize: self headerSize! !!MaSerializedGraphBuffer methodsFor: 'building'!resetByteArray: aByteArray	self		byteArray: aByteArray;		resetBufferSize! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 5/3/2005 12:41'!rootBuffer	self buffersDo: [ : each | ^ each ]! !!MaSerializedGraphBuffer methodsFor: 'accessing' stamp: 'cmm 4/3/2003 00:11'!trimmedByteArray	^byteArray		copyFrom: 1		to: self bufferSize! !!MaServer commentStamp: 'cmm 2/1/2005 15:35' prior: 0!Abstract superclass for the "server engine".  I know a console which I send output to.!!MaRequestServer commentStamp: 'cmm 2/20/2005 17:15' prior: 0!Abstract class whose subclass instances handle the server portion of the client-server activity.  The processor should be an object that responds to #value:.  The argument is the actual request object and it should answer the result object.  Requests and responses can be arbitrary objects, not just byte-objects like Strings and ByteArrays, although you must set up your #protocol.!!MaLocalRequestServer commentStamp: 'cmm 2/1/2005 15:29' prior: 0!Use this server as a stub when you are running your server locally within the same image.!!MaLocalRequestServer class methodsFor: 'creation' stamp: 'cmm 9/19/2004 22:38'!processor: oneArgBlockOrProcessor	^ self new 		processor: oneArgBlockOrProcessor ;		yourself! !!MaLocalRequestServer methodsFor: 'as yet unclassified' stamp: 'cmm 5/2/2005 22:25'!isRunning	^ true! !!MaRequestServer methodsFor: 'initializing' stamp: 'cmm 1/5/2003 23:12'!initialize	super initialize.	console _ MaRequestServerConsole new! !!MaRequestServer methodsFor: 'testing' stamp: 'cmm 2/20/2005 17:18'!isRunning	self subclassResponsibility! !!MaRequestServer methodsFor: 'private' stamp: 'cmm 9/19/2004 22:09'!processRequest: aMaServerRequest	"Here's your request object, do something with it and answer any object, though for remote connections only, every class throughout the entire request and responses graph must be part of your #protocol."	| answer |	console noteProcessingRequest: aMaServerRequest.	answer _ [ processor value: aMaServerRequest ]		on: MaNotification		do:			[ :noti | console note: noti messageText.			noti resume ].	console noteRequestProcessed: aMaServerRequest.	^answer! !!MaRequestServer methodsFor: 'accessing' stamp: 'cmm 12/8/2004 13:34'!processor	^ processor! !!MaRequestServer methodsFor: 'private' stamp: 'cmm 9/19/2004 22:10'!processor: oneArgBlock	"oneArgBlock takes the request object, answers the response object you want to send back to the client.  For remote, these can only be objects defined in the protocol."	processor _ oneArgBlock! !!MaTcpRequestServer commentStamp: 'cmm 2/1/2005 15:40' prior: 0!The server to use when you want to allow requests and responses to be any object and run on a remote server.!!MaTcpRequestServer class methodsFor: 'creation' stamp: 'cmm 10/8/2002 22:50'!protocol: collectionOfClasses	"collectionOfClasses are all request classes and all response classes any client can expect to encounter in the full graph of the requests and responses"	^self new protocol: collectionOfClasses! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 10/11/2002 00:24'!connectionInfo	^Array		with: self getNextId		with: self protocolByteArray! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 10/11/2002 00:22'!connectionRequest	^'connect'! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 10/11/2002 00:25'!getNextId	^nextId _ nextId + 1! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 11/26/2004 13:15'!initialize	super initialize.	socket _		MaServerSocket new			server: self;			yourself.	nextId _ 1.	self initializeSerializer! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 6/10/2005 12:21'!initializeSerializer	serializer _ MaObjectSerializer new! !!MaTcpRequestServer methodsFor: 'testing' stamp: 'cmm 2/20/2005 17:18'!isRunning	^ socket isRunning! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 2/2/2005 12:26'!materializeRequest: requestByteArray	serializer resetOidManager.	^ [ serializer materializeGraph: requestByteArray ]		on: Error		do:			[ :exc |			MaClientServerPreferences debug				ifTrue: [ exc pass ]				ifFalse:					[ MaMalformedRequestError new						messageText: exc messageText ;						yourself ] ]! !!MaTcpRequestServer methodsFor: 'start / stop' stamp: 'cmm 4/29/2003 23:28'!processOn: portNumber	"Listen on portNumber in the background.  For each client request received, evaluate my processBlock.  I queue all requests so that your block will never be evaluating more than one client-request at a time."	socket server: self.	socket listenOn: portNumber! !!MaTcpRequestServer methodsFor: 'start / stop' stamp: 'cmm 2/20/2005 19:38'!processOn: portNumber do: oneArgBlock	"Listen on portNumber in the background.  For each client request received, evaluate oneArgBlock.  The argument to the block is the request object sent from the client.  I queue all requests so that your block will never be evaluating more than one client-request at a time."self deprecated: 'Use processOn:using:'.	processor _ oneArgBlock.	self processOn: portNumber! !!MaTcpRequestServer methodsFor: 'start / stop' stamp: 'cmm 2/20/2005 18:47'!processOn: portNumber using: yourProcessor	"Listen on portNumber in the background.  For each client request received, value: yourProcessor (which must respond to #value:).  I queue all requests and ensure your yourProcessor will never be evaluating more than one client-request at a time."	processor _ yourProcessor.	self processOn: portNumber! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 2/1/2005 15:51'!processRequestByteArray: requestByteArray	"Materialize the object serialized in requestByteArray, and serialize the response I get from telling my processor to process it."	| requestObject responseObject |	requestObject _ self materializeRequest: requestByteArray.	responseObject _ requestObject = self connectionRequest		ifTrue: [ self connectionInfo ]		ifFalse: [ self processRequest: requestObject ].	^ self serializeResponse: responseObject! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 6/22/2004 12:21'!protocol: aCollection	"Establish the class ids of classes in the protocol."	aCollection do: [ : each | serializer classIdManager addNewClass: each ]! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 10/8/2002 22:20'!protocolByteArray	^serializer classDefinitionsByteArray! !!MaTcpRequestServer methodsFor: 'private' stamp: 'cmm 12/27/2002 10:21'!serializeResponse: anObject	serializer resetOidManager.	^(serializer serializeGraph: anObject) trimmedByteArray! !!MaTcpRequestServer methodsFor: 'start / stop' stamp: 'cmm 12/31/2002 14:01'!shutdown	socket shutdown.	"socket shutdown immediately disallows any more requests, but blocks until pending requests get processed.  Those remaining requests which are not finished writing responses can and will continue to write, but the server is no longer needed and able to shutdown."	console noteServerShutdown! !!MaTcpRequestServer methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds	^socket timeoutSeconds! !!MaTcpRequestServer methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds: anInteger	socket timeoutSeconds: anInteger! !!MaServer methodsFor: 'console' stamp: 'cmm 10/7/2002 23:45'!console: aMaServerConsole	console _ aMaServerConsole! !!MaServer methodsFor: 'private' stamp: 'cmm 10/8/2002 23:05'!initialize	super initialize.	console _ MaServerConsole new! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:29'!note: aString	"The socket is notifying us of a message."	console note: aString! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:29'!noteClientAborted: aSocket	"Some client submitted aSocket to us, but when we tried to write to it, it was no longer connected."	console noteClientAborted: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:29'!noteException: anException whileReceivingRequestFrom: aSocket	"anException was signaled when trying to read from aSocket.  Maybe they disconnected?"	console 		noteException: anException 		whileReceivingRequestFrom: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:30'!noteNoLongerAcceptingRequests	"Called when the socket has previously been told to shutdown and can no longer accept requests."	console noteNoLongerAcceptingRequests! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:30'!noteNoLongerExtractingRequests	"Called when the socket has previously been told to shutdown and extracted the last pending sockets request."	console noteNoLongerExtractingRequests! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:30'!noteNoLongerProcessingRequests	"Called when the socket has previously been told to shutdown and has processed the last pending request."	console noteNoLongerProcessingRequests! !!MaServer methodsFor: 'notifications' stamp: 'cmm 1/5/2003 23:03'!noteRequestDequeued: requestByteArray for: aSocket	"Indicates aSocket has delivered aByteArray as a request that it wants processed and the response returned."	console		noteRequestDequeued: requestByteArray		for: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/16/2002 21:41'!noteRequestQueued: aByteArray for: aSocket	"Indicates aSocket has delivered aByteArray as a request that it wants processed and the response returned."	console		noteRequestQueued: aByteArray		for: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:42'!noteResponseSent: aByteArray to: aSocket	"Successfully sent the aByteArray to aSocket."	console		noteResponseSent: aByteArray		to: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:32'!noteSendResponse: aByteArray timedOutOn: aSocket	"aSocket must have disconnected or something, we couldn't get the response to them."	console		noteSendResponse: aByteArray		timedOutOn: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:31'!noteSendingResponse: aByteArray to: aSocket	"a ByteArray is about to be sent to aSocket."	console		noteSendingResponse: aByteArray 		to: aSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 1/5/2003 18:18'!noteSocketDequeued: clientSocket	"clientSocket has been accepted by the server, and a process forked to extracted its byteArray request."	console noteSocketDequeued: clientSocket! !!MaServer methodsFor: 'notifications' stamp: 'cmm 10/10/2002 00:32'!noteSocketQueued: clientSocket	"clientSocket has been accepted by the server, and a process forked to extracted its byteArray request."	console noteSocketQueued: clientSocket! !!MaServer methodsFor: 'private' stamp: 'cmm 8/23/2005 20:08'!processRequestByteArray: aByteArray	"Default answer empty string."	^ String maEmpty! !!MaServerConsole commentStamp: 'cmm 2/1/2005 15:34' prior: 0!I am used to receive messages from the server.!!MaRequestServerConsole commentStamp: 'cmm 2/1/2005 15:34' prior: 0!I am used to receive messages from the server.!!MaRequestServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 21:39'!noteProcessingRequest: yourRequestObject	"optional subclass responsibility"! !!MaRequestServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 22:41'!noteRequestProcessed: yourRequestObject	"optional subclass responsibility"! !!MaTranscriptConsole commentStamp: 'cmm 2/1/2005 15:41' prior: 0!A default console that prints messages to the Transcript.!!MaTranscriptConsole methodsFor: 'output' stamp: 'cmm 10/1/2002 22:49'!newLine	Transcript cr! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/1/2002 23:33'!note: aString	self		newLine;		showMessage: aString! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 3/28/2005 22:27'!noteException: anException onSocket: aSocket	"anException was signaled when trying to read from aSocket.  Maybe they disconnected?"	self		newLine;		showSocket: aSocket;		showSeparator;		showMessage:			(anException messageText isEmpty				ifTrue: [ anException species name ]				ifFalse: [ anException messageText ])! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 12/27/2004 00:05'!noteException: anException whileReceivingRequestFrom: aSocket	"anException was signaled when trying to read from aSocket.  Maybe they disconnected?"	self		noteException: anException		onSocket: aSocket! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/9/2002 23:07'!noteNoLongerProcessingRequests	"Called when the socket has previously been told to shutdown and has processed the last pending request."	self newLine; showMessage: 'I shall process no more requests.'! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/1/2002 23:14'!noteResponseSent: aByteArray to: aSocket	"Successfully sent the aByteArray to aSocket."	self		newLine;		showMessage: 'sent ', aByteArray size printString, ' bytes to ', aSocket remoteAddress maAsIpString! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/1/2002 23:15'!noteSendResponse: aByteArray timedOutOn: aSocket	"aSocket must have disconnected or something, we couldn't get the response to them."	self		newLine;		showMessage: 'timed out trying to send ', aByteArray size printString, ' bytes to ', aSocket remoteAddress maAsIpString! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/1/2002 23:15'!noteSendingResponse: aByteArray to: aSocket	"a ByteArray is about to be sent to aSocket."	self		newLine;		showMessage: 'about to send ', aByteArray size printString, ' bytes to ', aSocket remoteAddress maAsIpString! !!MaTranscriptConsole methodsFor: 'notifications' stamp: 'cmm 10/1/2002 23:16'!noteSocketQueued: clientSocket	"clientSocket has been accepted by the server, and a process forked to extracted its byteArray request."	self		newLine;		showMessage: 'queued ', clientSocket remoteAddress maAsIpString ! !!MaTranscriptConsole methodsFor: 'output' stamp: 'cmm 10/1/2002 22:49'!showMessage: aString	Transcript show: aString! !!MaTranscriptConsole methodsFor: 'output' stamp: 'cmm 10/1/2002 22:53'!showSeparator	Transcript show: ' - '! !!MaTranscriptConsole methodsFor: 'output' stamp: 'cmm 10/1/2002 22:51'!showSocket: aSocket	Transcript show: aSocket remoteAddress maAsIpString! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 12/18/2002 21:52'!controller	^controller! !!MagmaServerConsole methodsFor: 'initializing' stamp: 'cmm 12/24/2002 15:50'!initialize	super initialize.	statistics := MagmaServerStatistics new! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/4/2003 17:17'!note: stringMessage	Transcript cr; show: stringMessage! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 22:56'!noteProcessingRequest: yourRequestObject	statistics startRequestTimer! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 22:53'!noteRequestDequeued: requestByteArray for: aSocket	"Indicates aSocket has delivered a ByteArray request that is about to be processed by my server."	statistics decrementRequestsQueued! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 2/4/2003 12:36'!noteRequestProcessed: requestObject	statistics stopRequestTimer! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 22:44'!noteRequestQueued: aByteArray for: aSocket	"Indicates aSocket has delivered aByteArray as a request that it wants processed and the response returned."	statistics		incrementRequestsQueued;		recordRequestSize: aByteArray size! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 2/4/2003 13:09'!noteResponseSent: aByteArray to: aSocket	"Successfully sent the aByteArray to aSocket."	statistics recordResponseSize: aByteArray size! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 4/30/2003 17:44'!noteServerShutdown	controller close.	statistics stopTime: MaCalendarTime now.	self note: controller printString, ' closed.'! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 18:19'!noteSocketDequeued: aSocket	statistics decrementSocketsQueued! !!MagmaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 22:06'!noteSocketQueued: aSocket	statistics incrementSocketsQueued! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 6/13/2005 14:09'!open: pathName	controller _ MagmaRepositoryController open: pathName! !!MagmaServerConsole methodsFor: 'deprecated' stamp: 'cmm 6/13/2005 17:27'!open: filename processOn: portself deprecated: 'Use #open: followed by #processOn:  separately.'.	self		open: filename ;			processOn: port! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 6/13/2005 14:10'!processOn: portInteger	server _ (MaTcpRequestServer protocol: controller protocol) console: self.	statistics startTime: MaCalendarTime now.	server 		processOn: portInteger		using: [ :eachRequest | controller processRequest: eachRequest ].	^ self! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 3/3/2005 10:10'!server	^ server! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'cmm 10/7/2002 00:42'!shutdown	server shutdown! !!MagmaServerConsole methodsFor: 'accessing' stamp: 'cmm 1/27/2004 15:55'!statistics	^statistics! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!note: aString	"The socket is notifying us of a message."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteException: anException whileReceivingRequestFrom: aSocket	"anException was signaled when trying to read from aSocket.  Maybe they disconnected?"! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerAcceptingRequests	"Called when the socket has previously been told to shutdown and can no longer accept requests."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerExtractingRequests	"Called when the socket has previously been told to shutdown and extracted the last pending sockets request."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteNoLongerProcessingRequests	"Called when the socket has previously been told to shutdown and has processed the last pending request."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 22:53'!noteRequestDequeued: requestByteArray for: aSocket	"Indicates aSocket has delivered a ByteArray request that is about to be processed by my server."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/16/2002 21:41'!noteRequestQueued: aByteArray for: aSocket	"Indicates aSocket has delivered aByteArray as a request that it wants processed and the response returned."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteResponseSent: aByteArray to: aSocket	"Successfully sent the aByteArray to aSocket."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteSendResponse: aByteArray timedOutOn: aSocket	"aSocket must have disconnected or something, we couldn't get the response to them."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteSendingResponse: aByteArray to: aSocket	"a ByteArray is about to be sent to aSocket."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/8/2002 23:10'!noteServerShutdown! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 1/5/2003 18:18'!noteSocketDequeued: clientSocket	"clientSocket is about processed by the server."! !!MaServerConsole methodsFor: 'notifications' stamp: 'cmm 10/7/2002 23:51'!noteSocketQueued: clientSocket	"clientSocket has been accepted by the server, and a process forked to extracted its byteArray request."! !!MaServerLink commentStamp: 'cmm 2/1/2005 15:36' prior: 0!Abstract superclass representing a clients link to a server.  A client uses this link to submit request objects via #submit:.!!MaLocalServerLink commentStamp: 'cmm 2/1/2005 15:32' prior: 0!This is your clients interface to the server when the server is running locally (e.g., with MaLocalRequestServer).!!MaLocalServerLink class methodsFor: 'as yet unclassified' stamp: 'cmm 3/30/2002 22:50'!localRequestServer: aMaLocalRequestServer	^self new localRequestServer: aMaLocalRequestServer! !!MaLocalServerLink methodsFor: 'accessing' stamp: 'cmm 8/26/2003 22:50'!hostAddress	MaUserError signal: 'not remotly connected.'! !!MaLocalServerLink methodsFor: 'testing' stamp: 'cmm 10/8/2002 23:59'!isLocal	^true! !!MaLocalServerLink methodsFor: 'accessing' stamp: 'cmm 1/14/2005 15:11'!linkInformation	^ 'local-link to ', localRequestServer processor pathName! !!MaLocalServerLink methodsFor: 'private' stamp: 'cmm 7/2/2004 13:17'!localRequestServer	^ localRequestServer! !!MaLocalServerLink methodsFor: 'private' stamp: 'cmm 3/30/2002 22:52'!localRequestServer: aMaLocalRequestServer	localRequestServer _ aMaLocalRequestServer! !!MaLocalServerLink methodsFor: 'accessing' stamp: 'cmm 8/26/2003 22:50'!port	MaUserError signal: 'not remotly connected.'! !!MaLocalServerLink methodsFor: 'actions' stamp: 'cmm 3/30/2002 22:03'!submit: aMaServerRequest	^localRequestServer processRequest: aMaServerRequest! !!MaServerLink methodsFor: 'actions' stamp: 'cmm 4/8/2002 23:33'!connect	"Remote links have connection code they need to run.."! !!MaServerLink methodsFor: 'actions' stamp: 'cmm 4/1/2002 00:25'!disconnect	"Remote links need to clean up resources."! !!MaServerLink methodsFor: 'testing' stamp: 'cmm 10/8/2002 23:59'!isLocal	^false! !!MaServerLink methodsFor: 'override' stamp: 'cmm 7/2/2004 17:16'!linkInformation	self subclassResponsibility! !!MaServerLink methodsFor: 'actions' stamp: 'cmm 3/30/2002 22:01'!submit: aMaServerRequest	self subclassResponsibility! !!MaServerLink methodsFor: 'as yet unclassified' stamp: 'cmm 10/16/2002 22:05'!timeoutSeconds: anInteger	"for interface compatibility with remote server links."! !!MaTcpRequestServerLink commentStamp: 'cmm 2/1/2005 15:40' prior: 0!This is your clients interface to the server when the server is running remotely (e.g., with MaTcpRequestServer).!!MaTcpRequestServerLink class methodsFor: 'creation' stamp: 'cmm 10/8/2002 22:17'!hostAddress: aByteArray port: anInteger	"bufferSize is the size of the byteArray used to send requests and materialize responses."	^self new		socket:			(MaClientSocket				hostAddress: aByteArray				port: anInteger);		yourself! !!MaTcpRequestServerLink methodsFor: 'connections' stamp: 'cmm 1/2/2003 23:11'!connect	| idAndProtocol |	idAndProtocol _ self submit: self connectionRequest.	serializer classDefinitionsByteArray: (idAndProtocol at: 2)! !!MaTcpRequestServerLink methodsFor: 'private' stamp: 'cmm 10/16/2002 14:26'!connectionRequest	^'connect'! !!MaTcpRequestServerLink methodsFor: 'connections' stamp: 'cmm 4/15/2002 00:18'!disconnect	socket disconnect! !!MaTcpRequestServerLink methodsFor: 'private' stamp: 'cmm 10/14/2004 22:24'!getByteArrayResponseFor: aMaServerRequest	| graphBuffer |	^ socket		sendData: (graphBuffer _ serializer serializeGraph: aMaServerRequest) byteArray		startingAt: 1		count: graphBuffer bufferSize		waitForReplyIn: serializer byteArray! !!MaTcpRequestServerLink methodsFor: 'accessing' stamp: 'cmm 5/8/2002 23:24'!hostAddress	^socket hostAddress! !!MaTcpRequestServerLink methodsFor: 'private' stamp: 'cmm 11/26/2004 13:15'!initialize	super initialize.	self initializeSerializer.	submitGuard _ Semaphore forMutualExclusion! !!MaTcpRequestServerLink methodsFor: 'private' stamp: 'cmm 6/10/2005 12:21'!initializeSerializer	serializer _ MaObjectSerializer new! !!MaTcpRequestServerLink methodsFor: 'accessing' stamp: 'cmm 7/2/2004 17:16'!linkInformation	^ (self hostAddress->self port) printString! !!MaTcpRequestServerLink methodsFor: 'accessing' stamp: 'cmm 5/8/2002 23:24'!port	^socket port! !!MaTcpRequestServerLink methodsFor: 'private' stamp: 'cmm 9/22/2002 21:32'!socket: aMaClientSocket	socket _ aMaClientSocket! !!MaTcpRequestServerLink methodsFor: 'actions' stamp: 'cmm 3/12/2003 22:52'!submit: aMaServerRequest	| responseByteArray |	^submitGuard critical:		[ serializer resetOidManager.		responseByteArray _ self getByteArrayResponseFor: aMaServerRequest.		serializer resetOidManager.		serializer materializeGraph: responseByteArray ]! !!MaTcpRequestServerLink methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:23'!timeoutSeconds	^socket timeoutSeconds! !!MaTcpRequestServerLink methodsFor: 'accessing' stamp: 'cmm 10/8/2002 22:22'!timeoutSeconds: anInteger	socket timeoutSeconds: anInteger! !!MaServerSocket commentStamp: 'cmm 2/1/2005 15:39' prior: 0!I am the class which manages the underlying Squeak socket.  I receive and process requests in the order received in the background and send responses off in their own background process as well.This class is based off of a design by John McIntosh.!!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 4/30/2003 00:49'!initialize	ActiveSockets _ Set new.	Smalltalk		addToStartUpList: self;		addToShutDownList: self! !!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 12/27/2004 23:16'!shutDown: aboutToQuit	super shutDown: aboutToQuit.	ActiveSockets do: [ :each | each primShutdown ]! !!MaServerSocket class methodsFor: 'initializing' stamp: 'cmm 2/10/2005 09:42'!startUp: amResuming	super startUp: amResuming.	ActiveSockets do: 		[ :each | 		"If another startUp method creates and starts one of me listening, then I don't want to tell it to listen again"		each isRunning ifFalse: [ each listen ] ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 1/5/2003 22:52'!dequeueByteArrayRequest	| socketAndByteArrayRequest |	socketAndByteArrayRequest _ requestQueue next.	server 		noteRequestDequeued: socketAndByteArrayRequest value		for: socketAndByteArrayRequest key.	^socketAndByteArrayRequest! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 10/3/2002 21:09'!ensureByteArray: aByteArray canHold: anInteger	| newAnswer |	^aByteArray size < anInteger		ifTrue:			[ newAnswer _ ByteArray new: anInteger.			newAnswer				replaceFrom: 1				to: aByteArray size				with: aByteArray				startingAt: 1.			newAnswer ]		ifFalse: [ aByteArray ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 1/5/2003 22:22'!extractByteArrayFrom: aSocket	[	| requestByteArray |	[ requestByteArray _ self receiveByteArrayFrom: aSocket ]		on: Exception		do:			[ :exc | 			server				noteException: exc 				whileReceivingRequestFrom: aSocket.			nil ].	requestByteArray ifNotNil: [ self queueRequest: aSocket->requestByteArray ]		] fork! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/24/2002 23:01'!headerSize	"4-byte size header."	^4! !!MaServerSocket methodsFor: 'printing' stamp: 'cmm 10/2/2002 23:23'!hostAndPortStringFor: aSocket	^'host: ', aSocket remoteAddress maAsIpString, ' port: ', aSocket port printString! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 2/10/2005 09:45'!initialize	super initialize.	running _ false.	self initializeQueues.	optimumRequestSize := 400.	timeoutSeconds := 30.	self server: MaServer new	"use the do-nothing server by default".	doBlock _ [ :byteArray | server processRequestByteArray: byteArray ]! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 4/30/2003 00:30'!initializeQueues	socketQueue := SharedQueue new.	requestQueue := SharedQueue new! !!MaServerSocket methodsFor: 'testing' stamp: 'cmm 2/10/2005 09:42'!isRunning	^ running! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 2/10/2005 09:38'!listen	"By using this method, I will call my servers #processRequestByteArray:.  If you don't want to have a MaServer class, use listenOn:answer:."	running ifTrue: [ MaClientServerUserError signal: 'socket already listening.' ].	running _ true.	ActiveSockets add: self.	server note: 'initializing network drivers'.	server note: 'creating server socket'.	socket _ Socket newTCP.	socket		listenOn: port		backlogSize: 50.	socket isValid ifFalse: [ MaNetworkError signal: 'TCP/IP accept() not supported.' ].	server note: 'now listening on ', port printString.	self		startAcceptingRequests;		startExtractingRequests;		startProcessingRequests! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 4/30/2003 00:24'!listenOn: portNumber	"By using this method, I will call my servers #processRequestByteArray:.  If you don't want to have a MaServer class, use listenOn:answer:."	port _ portNumber.	self listen! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 8/20/2005 21:36'!listenOn: portNumber answer: oneArgBlock	"Listen on portNumber, for each ByteArray request received answer the value of oneArgBlock (which should answer a ByteArray)."	doBlock _ oneArgBlock.	self listenOn: portNumber! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 6/30/2004 23:58'!optimumRequestSize: anInteger	optimumRequestSize _ anInteger! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 2/21/2005 17:28'!primShutdown	running _ false.	server note: 'new sockets no longer accepted.'.	socketQueue isEmpty ifFalse: [ server note: 'waiting for queued sockets..' ].	[ socketQueue isEmpty ] whileFalse: [ (Delay forSeconds: 1) wait ].	socketExtractProcess terminate.	requestQueue isEmpty ifFalse: [ server note: 'waiting for pending requests to process..' ].	[ requestQueue isEmpty ] whileFalse: [ (Delay forSeconds: 1) wait ].	processRequestProcess terminate.	server note: 'deallocating resources.'.	socket ifNotNil: [ socket closeAndDestroy ].	self initializeQueues.	socket _ nil! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 9/29/2002 21:27'!processRequest: socketAndRequestAssociation	| responseByteArray |	responseByteArray _ doBlock value: socketAndRequestAssociation value.	self		sendData: responseByteArray		using: socketAndRequestAssociation key! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 1/5/2003 22:22'!queueRequest: socketAndByteArray	requestQueue nextPut: socketAndByteArray.	server 		noteRequestQueued: socketAndByteArray value 		for: socketAndByteArray key! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 1/5/2003 18:13'!queueSocket: aSocket	socketQueue nextPut: aSocket.	server noteSocketQueued: aSocket! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 7/2/2004 16:29'!receiveByteArrayFrom: aSocket	| bytesExpected bytesReceived answer |	bytesReceived _ 0.	bytesExpected _ nil.	answer _ ByteArray new: optimumRequestSize.	[ bytesExpected isNil or: [ bytesReceived < bytesExpected ] ]		whileTrue:			[ aSocket waitForDataFor: timeoutSeconds.			aSocket dataAvailable ifFalse: [ MaNetworkError signal: 'data not available from ', (self hostAndPortStringFor: aSocket) ].			bytesReceived _ bytesReceived				+ (aSocket					receiveSomeDataInto: answer					startingAt: bytesReceived + 1).			bytesExpected ifNil:				[ bytesReceived >= self headerSize					ifTrue:						[ bytesExpected _ answer maUint: 32 at: 0.						answer _ self							ensureByteArray: answer 							canHold: bytesExpected ] ] ].	answer _ answer		copyFrom: self headerSize + 1		to: bytesExpected.	^answer! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 12/27/2004 13:43'!sendData: aByteArray using: aSocket	[	| byteArrayToSend |	byteArrayToSend _ ByteArray new: aByteArray size + self headerSize.	byteArrayToSend maUint: 32 at: 0 put: byteArrayToSend size.	byteArrayToSend replaceFrom: self headerSize + 1 to: byteArrayToSend size with: aByteArray startingAt: 1.	aSocket isConnected		ifTrue:			[ server noteSendingResponse: aByteArray to: aSocket.			[ aSocket				sendData: byteArrayToSend ;				waitForSendDoneFor: timeoutSeconds ]					on: ConnectionTimedOut					do: [ : exc | aSocket closeAndDestroy ].			(aSocket isConnected and: [ aSocket sendDone ])				ifTrue:					[ server noteResponseSent: aByteArray to: aSocket ]				ifFalse:					[ server noteSendResponse: aByteArray timedOutOn: aSocket ] ]		ifFalse: [ server noteClientAborted: aSocket ].	aSocket closeAndDestroy		] forkAt: Processor userBackgroundPriority! !!MaServerSocket methodsFor: 'server' stamp: 'cmm 12/30/2002 22:08'!server: aMaServer	"It is not required for the user to set this, a default one will be created."	server _ aMaServer! !!MaServerSocket methodsFor: 'start/stop' stamp: 'cmm 4/30/2003 00:46'!shutdown	ActiveSockets remove: self ifAbsent: [ "do nothing" ].	self primShutdown! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/27/2004 12:53'!startAcceptingRequests	| clientSocket |	[		[ running ] whileTrue:			[ clientSocket _ socket				waitForAcceptFor: 5 "seconds"				ifTimedOut: [ nil ].			(clientSocket notNil and: [ clientSocket isConnected ])				ifTrue: [ self queueSocket: clientSocket ] ].		server noteNoLongerAcceptingRequests.		] newProcess name: 'Socket acceptor'; resume.	server note: 'Ready to queue sockets'! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 3/24/2005 12:22'!startExtractingRequests	socketExtractProcess _		[			[ running or: [ socketQueue notEmpty ] ]				whileTrue:					[ | clientSocket |					clientSocket _ socketQueue next.					server noteSocketDequeued: clientSocket.					self extractByteArrayFrom: clientSocket.					clientSocket _ nil ].			server noteNoLongerExtractingRequests.			] newProcess name: 'Request extractor'; resume.	server note: 'ready to extract requests'! !!MaServerSocket methodsFor: 'private' stamp: 'cmm 8/27/2004 12:54'!startProcessingRequests	processRequestProcess _ 		[			[ running or: [ requestQueue notEmpty ] ]				whileTrue: [ self processRequest: self dequeueByteArrayRequest ].			server noteNoLongerProcessingRequests.			] newProcess name: 'Request processor'; resume.	server note: 'ready to process requests'! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 9/29/2002 21:33'!timeoutSeconds	^timeoutSeconds! !!MaServerSocket methodsFor: 'accessing' stamp: 'cmm 9/29/2002 21:32'!timeoutSeconds: anInteger	timeoutSeconds _ anInteger! !!MaSingleton class methodsFor: 'accessing' stamp: 'cmm 1/10/2005 21:55'!current	^ current ifNil: [ current _ self new ]! !!MaSingleton class methodsFor: 'actions' stamp: 'cmm 1/10/2005 21:54'!initialize	super initialize.	self reset! !!MaSingleton class methodsFor: 'actions' stamp: 'cmm 1/10/2005 21:56'!reset	current _ nil! !!MaStat class methodsFor: 'as yet unclassified' stamp: 'cmm 11/16/2004 10:51'!example	| stat |	stat _ self new.	#(1 2 5 8 9 15) do: [ :each | stat addValue: each ].	stat! !!MaStat methodsFor: 'accessing' stamp: 'cmm 11/16/2004 21:54'!addValue: aMagnitude	"This is named addValue: instead of add: to be easier to find senders."	self last: aMagnitude.	count _ count + 1.	min _ min ifNil: [ aMagnitude ] ifNotNil: [ min min: aMagnitude ].	max _ max ifNil: [ aMagnitude ] ifNotNil: [ max max: aMagnitude ].	sum _ sum ifNil: [ aMagnitude ] ifNotNil: [ sum + aMagnitude ]! !!MaStat methodsFor: 'accessing' stamp: 'cmm 2/4/2003 11:53'!count	^count! !!MaStat methodsFor: 'private' stamp: 'cmm 7/1/2004 10:51'!initialize	super initialize.	count := 0! !!MaStat methodsFor: 'accessing' stamp: 'cmm 11/16/2004 21:49'!last	^ last! !!MaStat methodsFor: 'accessing' stamp: 'cmm 11/16/2004 21:50'!last: aMagnitude	last _ aMagnitude! !!MaStat methodsFor: 'printing' stamp: 'cmm 11/16/2004 21:52'!maPrintAbbreviatedOn: aStream	self		maPrintAttributes: #(min max sum count mean)		on: aStream! !!MaStat methodsFor: 'accessing' stamp: 'cmm 2/4/2003 11:53'!max	^max! !!MaStat methodsFor: 'accessing' stamp: 'cmm 11/16/2004 21:52'!mean	^ (sum / count) asFloat! !!MaStat methodsFor: 'accessing' stamp: 'cmm 2/4/2003 11:53'!min	^min! !!MaStat methodsFor: 'accessing' stamp: 'cmm 11/16/2004 21:51'!sum	^ sum! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:09'!< anObject	self upTo: anObject! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:09'!<= anObject	self to: anObject! !!MaClause methodsFor: 'comparing' stamp: 'cmm 8/7/2006 22:10'!= anObject 	^ (anObject isKindOf: MaClause) 		ifFalse: [ self equals: anObject ]		ifTrue: 			[ anObject maOriginalClass = self maOriginalClass 			and: [ attribute = anObject attribute 			and: [ lowKey = anObject lowKey 			and: [ highKey = anObject highKey ] ] ] ]! !!MaClause methodsFor: 'operators' stamp: 'cmm 5/30/2006 21:34'!> anObject	lowKey := (self index indexHashForIndexObject: anObject)+1.	highKey := self index highestPossibleKey! !!MaClause methodsFor: 'operators' stamp: 'cmm 5/30/2006 21:34'!>= anObject	self from: anObject! !!MaClause methodsFor: '*magma server-private' stamp: 'cmm 6/3/2006 14:47'!addMinimumEnumerationsTo: aMaQueryTrunk using: aMagmaLargeCollectionManager 	aMaQueryTrunk addClause: 		(self asTrunkClause			lastKnownSize:				((aMagmaLargeCollectionManager oidsIndexForAttribute: attribute) 					numberOfEntriesFrom: lowKey					to: highKey))! !!MaClause methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	aCollection add: self! !!MaClause methodsFor: 'converting' stamp: 'cmm 6/3/2006 14:46'!asTrunkClause	^ MaQueryTrunkClause new		attribute: attribute ;		lowKey: lowKey ;		highKey: highKey ;		yourself! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:08'!at: anObject 	self 		from: anObject		to: anObject! !!MaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:39'!attribute	^ attribute! !!MaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:38'!attribute: aByteSymbol 	attribute _ aByteSymbol! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:07'!between: lowObject and: highObject 	self 		from: lowObject		to: highObject! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:08'!equals: anObject 	self 		from: anObject		to: anObject! !!MaClause methodsFor: 'evaluating' stamp: 'cmm 8/3/2006 19:48'!evaluationCount: anObject 	^ (self index indexHashesForIndexObject: (anObject perform: attribute)) count: 		[ : each | 		each 			between: lowKey			and: highKey ]! !!MaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: anObject	lowKey := self index indexHashForIndexObject: anObject.	highKey := self index highestPossibleKey ! !!MaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: lowObject to: highObject	lowKey := self index indexHashForIndexObject: lowObject.	highKey := self index indexHashForIndexObject: highObject! !!MaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!from: lowObject upTo: highObject	lowKey := self index indexHashForIndexObject: lowObject.	highKey := (self index indexHashForIndexObject: highObject) - 1 max: 0.! !!MaClause methodsFor: 'comparing' stamp: 'cmm 4/10/2006 22:45'!hash	"try to be fast and avoid tons of collisions"	^ attribute hash bitOr: (lowKey bitOr: highKey)! !!MaClause methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:10'!highKey	^ highKey! !!MaClause methodsFor: 'initialize-release' stamp: 'brp 4/6/2006 11:22'!highKey: anInteger	highKey := anInteger! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:19'!in: aCollection	self includesAnyOf: aCollection! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:04'!includesAllOf: aCollection	| expression |	expression := MaExpression new reader: reader; operator: #&.	aCollection do: 		[ :each | expression addTerm: (self copy at: each) ].	self become: expression! !!MaClause methodsFor: 'operators' stamp: 'cmm 8/8/2006 23:04'!includesAnyOf: aCollection	| expression |	expression := MaExpression new reader: reader; operator: #|.	aCollection do: 		[ :each | expression addTerm: (self copy at: each) ].	self become: expression! !!MaClause methodsFor: 'accessing' stamp: 'cmm 4/7/2006 16:15'!index	^ reader indexNamed: attribute ! !!MaClause methodsFor: 'testing' stamp: 'cmm 6/8/2006 22:00'!isSorted	^ true! !!MaClause methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:09'!lowKey	^ lowKey! !!MaClause methodsFor: 'initialize-release' stamp: 'brp 4/6/2006 11:23'!lowKey: anInteger	lowKey := anInteger! !!MaClause methodsFor: '*magma server-private' stamp: 'cmm 4/13/2006 17:05'!minimumSearchSpaceSizeUsing: aMagmaCollectionManager 	^ (aMagmaCollectionManager oidsIndexForAttribute: attribute) 		numberOfEntriesFrom: lowKey		to: highKey! !!MaClause methodsFor: 'printing' stamp: 'cmm 6/3/2006 16:57'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(; 		nextPutAll: attribute ; 		space;		print: self lowKey;		nextPutAll: '..' ;		print: self highKey;		nextPut: $)! !!MaClause methodsFor: '*magma server-private' stamp: 'cmm 4/13/2006 17:13'!shouldInclude: oid using: aMagmaCollectionManager 	"in the keys indexes, the oid is the key, the key is the value."	(aMagmaCollectionManager keysIndexForAttribute: attribute) 		entriesFrom: oid		do: 			[ : eachRecord : bax : level | 			((eachRecord valueAtByteArrayIndex: bax) "key"				between: lowKey				and: highKey) ifTrue: [ ^ true ] ]		until: 			[ : eachRecord : bax : level | 			(eachRecord keyAtByteArrayIndex: bax) > oid ].	^ false! !!MaClause methodsFor: 'operators' stamp: 'gk 5/26/2006 13:28'!to: anObject	lowKey := 0.	highKey := self index indexHashForIndexObject: anObject.! !!MaClause methodsFor: 'operators' stamp: 'cmm 6/13/2006 20:55'!upTo: highObject	lowKey := 0.	highKey := (self index indexHashForIndexObject: highObject) - 1 max: 0.! !!MaQueryTrunkClause commentStamp: 'cmm 6/1/2006 23:05' prior: 0!I represent the "normalized" clauses of an expression.  Some queries may specify the same attribute more than once, sometimes even with overlapping key ranges.  In this case there is no reason to search the overlapping keyspaces more than once.Therefore, my 'clauses' and 'sizes' are parallel ordered collections, the MaClauses for a particular attribute and the number of entries in that range, respectively.  The key ranges of my clauses are coalesced into my ranges, a MaIntervalCollection.!!MaQueryTrunkClause methodsFor: 'accessing' stamp: 'cmm 6/3/2006 14:34'!lastKnownSize	^ lastKnownSize! !!MaQueryTrunkClause methodsFor: 'accessing' stamp: 'cmm 6/3/2006 16:56'!lastKnownSize: anInteger	lastKnownSize _ anInteger! !!MaExpression methodsFor: 'comparing' stamp: 'cmm 4/10/2006 22:10'!= aMaExpression	aMaExpression maOriginalClass = self maOriginalClass ifFalse: [ ^ false ].	^ operator = aMaExpression operator	and: [ self terms = aMaExpression terms ]! !!MaExpression methodsFor: '*magma server-private' stamp: 'cmm 5/31/2006 20:23'!addMinimumEnumerationsTo: aMaQueryTrunk using: aMagmaLargeCollectionManager 	"For each OR'd condition, we must add a new range to aMaQueryTrunk.  Within each OR, we select the shortest ANDed condition to add to aMaQueryTrunk."	self isConjunction 		ifTrue: 			[ | smallest smallestSize |			smallest _ smallestSize _ nil.			self terms do: 				[ : each | 				| eachSize |				eachSize _ each minimumSearchSpaceSizeUsing: aMagmaLargeCollectionManager.				(smallest isNil or: [ eachSize < smallestSize ]) ifTrue: 					[ smallest _ each.					smallestSize _ eachSize ] ].			smallest 				addMinimumEnumerationsTo: aMaQueryTrunk				using: aMagmaLargeCollectionManager ]		ifFalse: 			[ self terms do: 				[ : each | 				each 					addMinimumEnumerationsTo: aMaQueryTrunk					using: aMagmaLargeCollectionManager ] ]! !!MaExpression methodsFor: 'accessing' stamp: 'brp 4/9/2006 11:59'!addTerm: aMaTerm	self terms add: aMaTerm! !!MaExpression methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	aCollection addAll: self terms! !!MaExpression methodsFor: 'enumerating' stamp: 'brp 4/9/2006 12:00'!do: aBlock	"depth-first traversal"	self terms do: [ :t | t do: aBlock ].	aBlock value: self! !!MaExpression methodsFor: 'evaluating' stamp: 'cmm 7/16/2006 11:25'!evaluationCount: anObject 	"Answer how many hashes cause anObject to qualify for the reiver expression."	^ self isConjunction 		ifTrue: 			[ self terms 				inject: self terms size				into: [ : min : eachTerm | min min: (eachTerm evaluationCount: anObject) ] ]		ifFalse: 			[ self terms 				inject: 0				into: [ : sum : eachTerm | sum + (eachTerm evaluationCount: anObject) ] ]! !!MaExpression methodsFor: 'testing' stamp: 'cmm 7/16/2006 14:03'!hasDisjunctions	^ self isDisjunction or: [ self terms anySatisfy: [:each|each isDisjunction]]! !!MaExpression methodsFor: 'comparing' stamp: 'cmm 4/10/2006 22:10'!hash	"At the expression level we have bigger numbers, so a lot of bits are set.  Therefore I chose to try bitXor: at this level instead of bitOr:."	^ self terms 		inject: operator hash		into: [ : hash : each | hash bitXor: each hash ]! !!MaExpression methodsFor: 'testing' stamp: 'cmm 4/10/2006 21:53'!isConjunction	^ operator = #&! !!MaExpression methodsFor: 'testing' stamp: 'cmm 4/10/2006 21:55'!isDisjunction	^ operator = #|! !!MaExpression methodsFor: 'testing' stamp: 'brp 4/9/2006 11:52'!isExpression	^ true! !!MaExpression methodsFor: '*magma server-private' stamp: 'cmm 4/12/2006 16:26'!minimumSearchSpaceSizeUsing: aMaLargeCollectionManager 	| calculateSizeBlock |	calculateSizeBlock _ 	[ : each | 	each minimumSearchSpaceSizeUsing: aMaLargeCollectionManager ].	^ self isConjunction 		ifTrue: [ self terms detectMin: calculateSizeBlock ]		ifFalse: [ self terms detectSum: calculateSizeBlock ]! !!MaExpression methodsFor: 'expressions' stamp: 'cmm 4/13/2006 23:10'!normalize	super normalize.	self 		normalizePrecedence ;		normalizeOverlappingValues! !!MaExpression methodsFor: 'private' stamp: 'cmm 5/28/2006 21:38'!normalizeOverlappingValues	"compress silly queries like (age to: 30) | (age to: 50), (age between: 20 and: 30) & (age between: 25 and: 35), or (age to: 30) & (age between: 40 and: 50).  MaIntervalCollection could be helpful with this."	self maMarked: 'dev'! !!MaExpression methodsFor: 'private' stamp: 'cmm 4/13/2006 23:14'!normalizePrecedence	self terms do: [ : t | t normalize ].	((self terms select: [ : t | t isExpression ]) allSatisfy: [ : t | t operator = self operator ]) 		ifTrue: 			[ | all |			all _ OrderedCollection new.			self terms do: [ : t | t addTermsTo: all ].			terms _ all ].	terms _ self terms asArray! !!MaExpression methodsFor: 'accessing' stamp: 'brp 4/6/2006 12:07'!operator	^ operator! !!MaExpression methodsFor: 'accessing' stamp: 'brp 4/9/2006 11:22'!operator: aSymbol	operator := aSymbol! !!MaExpression methodsFor: 'printing' stamp: 'brp 4/9/2006 11:22'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self operator; nextPut: $)! !!MaExpression methodsFor: 'private' stamp: 'cmm 7/16/2006 14:03'!reader: aMagmaCollectionReader 	super reader: aMagmaCollectionReader.	self terms do: [ : each | each reader: aMagmaCollectionReader ]! !!MaExpression methodsFor: '*magma server-private' stamp: 'cmm 4/12/2006 00:22'!shouldInclude: oid using: aMagmaCollectionManager 	^ self isConjunction 		ifTrue: 			[ self terms allSatisfy: 				[ : each | 				each 					shouldInclude: oid					using: aMagmaCollectionManager ] ]		ifFalse: 			[ self terms anySatisfy: 				[ : each | 				each 					shouldInclude: oid					using: aMagmaCollectionManager ] ]! !!MaExpression methodsFor: 'accessing' stamp: 'brp 4/9/2006 11:58'!terms	^ terms ifNil: [ terms := OrderedCollection new ]! !!MaTerm methodsFor: 'expressions' stamp: 'brp 4/9/2006 11:36'!& aMaTerm	^ self connect: aMaTerm operator: #&! !!MaTerm methodsFor: 'private' stamp: 'cmm 4/13/2006 23:12'!addTermsTo: aCollection	self subclassResponsibility! !!MaTerm methodsFor: 'expressions' stamp: 'brp 6/14/2006 12:42'!connect: aMaTerm operator: aSymbol 	| expression |	expression := MaExpression new		reader: reader ;		operator: aSymbol ;		addTerm: self ;		addTerm: aMaTerm yourself.	reader expression: expression.	^ expression! !!MaTerm methodsFor: 'evaluate' stamp: 'cmm 7/16/2006 17:17'!evaluate: anObject 	^ (self evaluationCount: anObject) > 0! !!MaTerm methodsFor: 'evaluate' stamp: 'cmm 7/15/2006 14:51'!evaluationCount: anObject	self subclassResponsibility ! !!MaTerm methodsFor: 'testing' stamp: 'cmm 5/30/2006 22:00'!hasDisjunctions	^ false! !!MaTerm methodsFor: 'testing' stamp: 'brp 4/9/2006 11:51'!isExpression	^ false! !!MaTerm methodsFor: 'testing' stamp: 'cmm 6/8/2006 21:59'!isSorted	^ false! !!MaTerm methodsFor: 'serialization' stamp: 'cmm 5/28/2006 22:04'!maTransientVariables	^super maTransientVariables, #('reader')! !!MaTerm methodsFor: 'expressions' stamp: 'cmm 4/13/2006 22:48'!normalize	"do nothing by default"! !!MaTerm methodsFor: 'private' stamp: 'cmm 5/28/2006 22:03'!reader: aMagmaExpressionReader 	reader := aMagmaExpressionReader ! !!MaTerm methodsFor: 'expressions' stamp: 'brp 4/9/2006 11:36'!| aMaTerm	^ self connect: aMaTerm operator: #|! !!MaTextMessage commentStamp: '<historical>' prior: 0!This little tool helps you build non-wimpy message strings.!!MaTextMessage methodsFor: 'building' stamp: 'cmm 3/6/2002 22:47'!append: aString	self appendString: aString! !!MaTextMessage methodsFor: 'building'!appendAndedList: aCollection	self		appendList: (			aCollection				collect: [ :each | each isString ifTrue: [ each ] ifFalse: [ each printString ] ])		with: ' and '! !!MaTextMessage methodsFor: 'building'!appendCount: aNumber of: aString	"aString should be a non-plural word.  This method will append the	plural version of aString (by simply adding 's') if aNumber is > 1."	self		append: aNumber;		space.	self		appendProperlyPluralized: aString		for: aNumber! !!MaTextMessage methodsFor: 'private initializing'!appendList: aCollection with: aString	| index |	aCollection isEmpty ifTrue: [ ^nil ].	index := 1.	aCollection do:		[ :each |		self append: each.		aCollection size > 1			ifTrue:				[ index < (aCollection size - 1)					ifTrue:						[ self append: ', ' ]					ifFalse:						[ index = (aCollection size - 1) ifTrue: [ self append: aString ] ] ].		index := index + 1 ]! !!MaTextMessage methodsFor: 'building' stamp: 'cmm 11/25/2003 00:19'!appendProperlyPluralized: aString for: aNumber	"aString should be a non-plural word.  This method will append the	plural version of aString (by simply adding 's') if aNumber is > 1."	self append: aString.	aString last asLowercase = $s		ifTrue: [ stream nextPut: $' ]		ifFalse: [ stream nextPut: $s ]! !!MaTextMessage methodsFor: 'private building' stamp: 'cmm 11/25/2003 00:17'!appendString: anObject	anObject isString 		ifTrue: [ stream nextPutAll: anObject ] 		ifFalse: [ anObject printOn: stream ]! !!MaTextMessage methodsFor: 'private initializing' stamp: 'cmm 11/25/2003 00:16'!initialize	super initialize.	stream _ String new writeStream! !!MaTextMessage methodsFor: 'accessing' stamp: 'cmm 11/25/2003 00:22'!messageText	stream last = $. ifFalse: [ stream nextPut: $. ].	^stream contents! !!MaTextMessage methodsFor: 'building'!space	self append: $ ! !!MaTextMessage methodsFor: 'private accessing' stamp: 'cmm 11/25/2003 00:16'!string	^stream contents! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 14:07'!findTimeZone: aString	^ self timeZones detect: 		[ : each | 		each abbreviation = aString		or: [ each name includesSubstring: aString caseSensitive: false ] ]! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 14:12'!gmt	^ self timeZoneAbbreviated: 'GMT'! !!MaTimeZone class methodsFor: 'initialize' stamp: 'cmm 8/30/2004 12:45'!initialize	super initialize.	self initializeAllTimeZones! !!MaTimeZone class methodsFor: 'initialize' stamp: 'cmm 3/17/2005 20:15'!initializeAllTimeZones	"This information was obtained from http://www.timeanddate.com/library/abbreviations/timezones/"	AllTimeZones _ OrderedCollection new.	AllTimeZones		add: (MaTimeZone name: 'Alpha Time Zone' abbreviation: 'A' offset: 1 maHour) ;		add: (MaTimeZone name: 'Australian Central Daylight Time' abbreviation: 'ACDT' offset: 10 maHours + 30 maMinutes) ;		add: (MaTimeZone name: 'Australian Central Standard Time' abbreviation: 'ACST' offset: 9 maHours + 30 maMinutes) ;		add: (MaTimeZone name: 'Atlantic Daylight Time' abbreviation: 'ADT' offset: -3 maHours) ;		add: (MaTimeZone name: 'Australian Eastern Daylight Time' abbreviation: 'AEDT' offset: 11 maHours) ;		add: (MaTimeZone name: 'Australian Eastern Standard Time' abbreviation: 'AEST' offset: 10 maHours) ;		add: (MaTimeZone name: 'Alaska Daylight Time' abbreviation: 'AKDT' offset: -8 maHours) ;		add: (MaTimeZone name: 'Alaska Standard Time' abbreviation: 'AKST' offset: -9 maHours) ;		add: (MaTimeZone name: 'Atlantic Standard Time' abbreviation: 'AST' offset: -4 maHours) ;		add: (MaTimeZone name: 'Australian Western Standard Time' abbreviation: 'AWST' offset: 8 maHours) ;		add: (MaTimeZone name: 'Bravo Time Zone' abbreviation: 'B' offset: 2 maHours) ;		add: (MaTimeZone name: 'British Summer Time' abbreviation: 'BST' offset: 1 maHours) ;		add: (MaTimeZone name: 'Charlie Time Zone' abbreviation: 'C' offset: 3 maHours) ;		add: (MaTimeZone name: 'Central Daylight Time (North America)' abbreviation: 'CDT' offset: -5 maHours) ;		add: (MaTimeZone name: 'Central European Summer Time' abbreviation: 'CEST' offset: 2 maHours) ;		add: (MaTimeZone name: 'Central European Time' abbreviation: 'CET' offset: 1 maHours) ;		add: (MaTimeZone name: 'Central Standard Time (North America)' abbreviation: 'CST' offset: -6 maHours) ;		add: (MaTimeZone name: 'Christmas Island Time' abbreviation: 'CXT' offset: 7 maHours) ;		add: (MaTimeZone name: 'Delta Time Zone' abbreviation: 'D' offset: 4 maHours) ;		add: (MaTimeZone name: 'Echo Time Zone' abbreviation: 'E' offset: 5 maHours) ;		add: (MaTimeZone name: 'Eastern Daylight Time (Australia)' abbreviation: 'AEDT' offset: 11 maHours) ;		add: (MaTimeZone name: 'Eastern Daylight Time (North America)' abbreviation: 'EDT' offset: -4 maHours) ;		add: (MaTimeZone name: 'Eastern European Summer Time' abbreviation: 'EEST' offset: 3 maHours) ;		add: (MaTimeZone name: 'Eastern European Time' abbreviation: 'EET' offset: 2 maHours) ;		add: (MaTimeZone name: 'Eastern Standard Time (Australia)' abbreviation: 'AEST' offset: 10 maHours) ;		add: (MaTimeZone name: 'Eastern Standard Time (North America)' abbreviation: 'EST' offset: -5 maHours) ;		add: (MaTimeZone name: 'Foxtrot Time Zone' abbreviation: 'F' offset: 6 maHours) ;		add: (MaTimeZone name: 'Golf Time Zone' abbreviation: 'G' offset: 7 maHours) ;		add: (MaTimeZone name: 'Greenwich Mean Time' abbreviation: 'GMT' offset: 0 maHours) ;		add: (MaTimeZone name: 'Hotel Time Zone' abbreviation: 'H' offset: 8 maHours) ;		add: (MaTimeZone name: 'India Time Zone' abbreviation: 'I' offset: 9 maHours) ;		add: (MaTimeZone name: 'Irish Summer Time' abbreviation: 'IST' offset: 1 maHours) ;		add: (MaTimeZone name: 'Kilo Time Zone' abbreviation: 'K' offset: 10 maHours) ;		add: (MaTimeZone name: 'Lima Time Zone' abbreviation: 'L' offset: 11 maHours) ;		add: (MaTimeZone name: 'Mike Time Zone' abbreviation: 'M' offset: 12 maHours) ;		add: (MaTimeZone name: 'Mountain Daylight Time' abbreviation: 'MDT' offset: -6 maHours) ;		add: (MaTimeZone name: 'Mountain Standard Time' abbreviation: 'MST' offset: -7 maHours) ;		add: (MaTimeZone name: 'November Time Zone' abbreviation: 'MDT' offset: -1 maHours) ;		add: (MaTimeZone name: 'Newfoundland Daylight Time' abbreviation: 'NDT' offset: -2 maHours - 30 maMinutes) ;		add: (MaTimeZone name: 'Norfolk (Island) Time' abbreviation: 'NFT' offset: 11 maHours + 30 maMinutes) ;		add: (MaTimeZone name: 'Newfoundland Standard Time' abbreviation: 'NST' offset: -3 maHours - 30 maMinutes) ;		add: (MaTimeZone name: 'Oscar Time Zone' abbreviation: 'O' offset: -2 maHours) ;		add: (MaTimeZone name: 'Papa Time Zone' abbreviation: 'P' offset: -3 maHours) ;		add: (MaTimeZone name: 'Pacific Daylight Time' abbreviation: 'PDT' offset: -7 maHours) ;		add: (MaTimeZone name: 'Pacific Standard Time' abbreviation: 'PST' offset: -8 maHours) ;		add: (MaTimeZone name: 'Quebec Time Zone' abbreviation: 'Q' offset: -4 maHours) ;		add: (MaTimeZone name: 'Romeo Time Zone' abbreviation: 'R' offset: -5 maHours) ;		add: (MaTimeZone name: 'Sierra Time Zone' abbreviation: 'S' offset: -6 maHours) ;		add: (MaTimeZone name: 'Tango Time Zone' abbreviation: 'T' offset: -7 maHours) ;		add: (MaTimeZone name: 'Uniform Time Zone' abbreviation: 'U' offset: -8 maHours) ;		add: (MaTimeZone name: 'Coordinated Universal Time' abbreviation: 'UTC' offset: 0 maHours) ;		add: (MaTimeZone name: 'Victor Time Zone' abbreviation: 'V' offset: -9 maHours) ;		add: (MaTimeZone name: 'Whiskey Time Zone' abbreviation: 'W' offset: -10 maHours) ;		add: (MaTimeZone name: 'Western European Summer Time' abbreviation: 'WEST' offset: 1 maHours) ;		add: (MaTimeZone name: 'Western European Time' abbreviation: 'WET' offset: 0 maHours) ;		add: (MaTimeZone name: 'Western Standard Time' abbreviation: 'WST' offset: 8 maHours) ;		add: (MaTimeZone name: 'Xray Time Zone' abbreviation: 'X' offset: -11 maHours) ;		add: (MaTimeZone name: 'Yankee Time Zone' abbreviation: 'Y' offset: -12 maHours) ;		add: (MaTimeZone name: 'Zulu Time Zone' abbreviation: 'Z' offset: 0 maHours)! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 11:44'!localTimeZone	^ LocalTimeZone! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:20'!localTimeZone: aMaTimeZone	LocalTimeZone _ aMaTimeZone! !!MaTimeZone class methodsFor: 'create' stamp: 'cmm 8/30/2004 12:07'!name: nameString abbreviation: abbreviationString offset: aMaDuration	^ self new		name: nameString ;		abbreviation: abbreviationString ;		offset: aMaDuration ;		yourself! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 14:05'!timeZoneAbbreviated: aString	^ self timeZones detect: [ : each | each abbreviation = aString ]! !!MaTimeZone class methodsFor: 'accessing' stamp: 'cmm 8/30/2004 13:24'!timeZones	^ AllTimeZones! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:08'!abbreviation	"Answer the value of abbreviation"	^ abbreviation! !!MaTimeZone methodsFor: 'initialize' stamp: 'cmm 8/30/2004 12:08'!abbreviation: anObject	"Set the value of abbreviation"	abbreviation _ anObject! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:09'!addLocation: locationString	locations add: locationString! !!MaTimeZone methodsFor: 'initialize' stamp: 'cmm 8/30/2004 12:09'!initialize	super initialize.	locations _ Set new! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:08'!locations	"Answer the value of locations"	^ locations! !!MaTimeZone methodsFor: 'printing' stamp: 'cmm 8/30/2004 13:25'!maPrintAbbreviatedOn: aStream	aStream		print: self abbreviation! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:08'!name	^ name! !!MaTimeZone methodsFor: 'initialize' stamp: 'cmm 8/30/2004 12:08'!name: anObject	"Set the value of name"	name _ anObject! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:08'!offset	"Answer the value of offset"	^ offset! !!MaTimeZone methodsFor: 'initialize' stamp: 'cmm 8/30/2004 12:08'!offset: anObject	"Set the value of offset"	offset _ anObject! !!MaTimeZone methodsFor: 'accessing' stamp: 'cmm 8/30/2004 12:10'!removeLocation: locationString	locations remove: locationString! !!MaTransactionLog commentStamp: '<historical>' prior: 0!This class resides on the server.!!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 1/18/2005 22:43'!abortTransactionEntryFor: sessionIdInteger repository: aMaObjectRepository	^(self		renewEntryFor: sessionIdInteger		beginAnother: false		for: aMaObjectRepository) result! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 7/11/2005 15:08'!challengeEntriesWith: aMaCommitLogEntry	"We record all objects that were committed to all the entries in the receiver.  Some of the entries are in transaction, some are not.  The ones that are will use aMaCommitLogEntry to verify their commit has no conflicts with this entry.  The ones that are not will use the result of the receiver to know which objects need refreshed."	| entriesToRemove |	entriesToRemove _ nil.	self entriesDo:		[ :each |		(each isForSameSessionAs: aMaCommitLogEntry)			ifFalse:				[ each addChallengingEntry: aMaCommitLogEntry.				each					recordChangesToSpecialObjectsIn: aMaCommitLogEntry					using: self.				each hasExcessiveNumberOfChallengers					ifTrue:						[ self maMarked: 'dev'.						"here is where we manage the health of the server.  Our current strategy is that your session 'times out' if you stay idle and get too far out of sync w/ the db.  Further work can be done here.  We should look into just marking this LogEntry 'bad' then, later, when they finally refresh, force it to refresh this sessions entire readSet..  something like that.."						entriesToRemove ifNil: [ entriesToRemove _ OrderedCollection new ].						entriesToRemove add: each.						each needsToRefresh: true ] ] ].	entriesToRemove ifNotNil:		[ entriesToRemove 			do:				[ :each |				self					removeEntryForSessionId: each sessionId					ifAbsent: [ "shouldn't happen" ] ] ]! !!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 7/11/2005 15:07'!entriesDo: aBlock	entries do: aBlock! !!MaTransactionLog methodsFor: 'accessing' stamp: 'cmm 7/15/2005 11:50'!entryFor: sessionId	^entries		detect: [ :each | each sessionId = sessionId ]		ifNone: [ MagmaSessionLost ]! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 5/14/2005 17:44'!getNextId	^ nextId _ nextId + 1! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 5/14/2005 17:43'!initialize	super initialize.	"An OrderedCollection of MaCommitLogEntrys and MaTransactionLogEntrys.."	entries _ OrderedCollection new.	specialOids _ Dictionary new.	nextId _ 0! !!MaTransactionLog methodsFor: 'testing' stamp: 'cmm 12/31/2002 12:31'!isFirstEntryFor: sessionId	^entries notEmpty and: [ entries first connection sessionId = sessionId ]! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 5/14/2005 17:48'!newSessionFor: userIdString numberOfChallengers: anInteger	^ (entries add: (		MaTransactionLogEntry			id: self getNextId			connection: (				MagmaClientConnection					userId: userIdString					sessionId: self nextAvailableSessionId					maximumNumberOfChallengers: anInteger))) connection! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 1/28/2005 00:04'!newTransactionFor: sessionIdInteger repository: aMaObjectRepository	^ (self		renewEntryFor: sessionIdInteger		beginAnother: true		for: aMaObjectRepository) result! !!MaTransactionLog methodsFor: 'creation'!nextAvailableSessionId	^(entries		inject: 0		into: [ :highest :each | highest max: each sessionId ]) + 1! !!MaTransactionLog methodsFor: 'special oids' stamp: 'cmm 5/19/2004 22:24'!onChangeOf: anInteger clientsShould: aSymbol	specialOids		at: anInteger		put: aSymbol! !!MaTransactionLog methodsFor: 'building' stamp: 'cmm 6/12/2006 23:50'!removeEntryForSessionId: sessionId ifAbsent: aBlock 	^ entries 		maDetect: [ : each | each sessionId = sessionId ]		ifFound: [ : foundTransactionLogEntry | entries remove: foundTransactionLogEntry ]		ifNone: aBlock! !!MaTransactionLog methodsFor: 'actions' stamp: 'cmm 7/15/2005 11:50'!renewEntryFor: sessionIdInteger beginAnother: aBoolean for: aMaObjectRepository	"Gives the session identified by sessionIdInteger a new TranslactionLogEntry, where its challengers will be accumulated.  The entry prior to replacement is answered."	| entry |	entry _ self		renewEntryFor: sessionIdInteger		withNew: (aBoolean ifTrue: [ MaCommitLogEntry ] ifFalse: [ MaTransactionLogEntry ])		ifAbsent: [ MagmaSessionLost signal ].	aMaObjectRepository		renewServerNotificationsIn: entry result		for: sessionIdInteger		from: entry.	^ entry! !!MaTransactionLog methodsFor: 'private' stamp: 'cmm 5/14/2005 17:49'!renewEntryFor: sessionIdInteger withNew: aClass ifAbsent: aBlock	"aClass should be either MaTransactionLogEntry or MaCommitLogEntry"	| entry |	entry _		(self			removeEntryForSessionId: sessionIdInteger			ifAbsent: [ ^ aBlock value ]).	entry recordAllChangedObjects.	entries add: 		(aClass			id: self getNextId			connection: entry result connection).	^ entry! !!MaTransactionLog methodsFor: 'special oids' stamp: 'cmm 5/19/2004 00:10'!specialOidsDo: twoArgBlock	specialOids keysAndValuesDo: twoArgBlock! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 5/9/2005 22:48'!applyTo: aMaObjectRepository	| new |	new _ result newObjectBuffers.	commitPackage objectsDo:		[ : eachBuffer |		aMaObjectRepository filer			write: eachBuffer			index: (new includesKey: eachBuffer oid) ]! !!MaCommitLogEntry methodsFor: 'accessing' stamp: 'cmm 5/9/2005 21:24'!commitPackage	^ commitPackage! !!MaCommitLogEntry methodsFor: 'accessing' stamp: 'cmm 5/9/2005 21:24'!commitPackage: aMaCommitPackage	commitPackage _ aMaCommitPackage! !!MaCommitLogEntry methodsFor: 'private'!committed	^committed! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 10/15/2004 16:57'!determineResultFor: aMaCommitPackage using: lcManagersDictionary	self		recordLargeCollectionConflictsWith: aMaCommitPackage			using: lcManagersDictionary;		recordObjectConflictsIn: aMaCommitPackage.	^ result! !!MaCommitLogEntry methodsFor: 'testing' stamp: 'cmm 5/20/2004 21:39'!didCommitSpecialOid	^ didCommitSpecialOid! !!MaCommitLogEntry methodsFor: 'private' stamp: 'cmm 10/15/2004 16:57'!failResultWith: aMagmaClientConnection on: oidInteger	result _		result asFailedResult			recordObjectConflictWith: aMagmaClientConnection			on: oidInteger! !!MaCommitLogEntry methodsFor: 'testing' stamp: 'cmm 3/22/2005 16:27'!hasAnyCommitted	^ committed notEmpty or: [ magmaArrayCommits notNil ]! !!MaCommitLogEntry methodsFor: 'magmaArray support' stamp: 'cmm 3/20/2005 21:12'!hasChangesToMagmaArray: oidInteger	^ magmaArrayCommits notNil and:	[ self magmaArrayCommits includesKey: oidInteger ]! !!MaCommitLogEntry methodsFor: 'testing' stamp: 'cmm 10/15/2004 16:52'!hasCommitted: oidInteger	^ committed includesKey: oidInteger! !!MaCommitLogEntry methodsFor: 'initializing' stamp: 'cmm 5/20/2004 21:36'!initialize	super initialize.	committed _ Dictionary new.	didCommitSpecialOid _ false! !!MaCommitLogEntry methodsFor: 'initializing'!initializeResult	result _ MaCommitResult new! !!MaCommitLogEntry methodsFor: 'testing'!isCommitEntry	^true! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 5/9/2005 22:15'!link	| oidMap |	oidMap _ result permanentOids.	commitPackage objectsDo:		[ : eachBuffer |		eachBuffer isPointers			ifTrue:				[ eachBuffer instVarsDoWithIndex:					[ : oid : index |					(MaOidCalculator isOidForNewObject: oid)						ifTrue:							[ "replace the temp oid with the permanent one."							eachBuffer								maInstVarAt: index								put:									(oidMap 										at: oid										ifAbsent: [ MagmaUserError signal: 'Invalid reference, an object may not change during serialization.' ]) ] ] ] ]! !!MaCommitLogEntry methodsFor: 'magmaArray support' stamp: 'cmm 3/20/2005 21:23'!magmaArrayAdditionsAt: oidInteger	^ self magmaArrayCommits		at: oidInteger		ifAbsentPut: [ Dictionary new ]! !!MaCommitLogEntry methodsFor: 'magmaArray support' stamp: 'cmm 3/20/2005 21:08'!magmaArrayCommits	"A Dictionary, keyed by the oid of the MagmaArray that was changed; value is another Dictionary of the index->oids put into that array."	^ magmaArrayCommits ifNil:		[ magmaArrayCommits _ Dictionary new ]! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 5/20/2004 21:38'!noteDidCommitSpecialOid	didCommitSpecialOid _ true! !!MaCommitLogEntry methodsFor: 'recovery' stamp: 'cmm 7/8/2005 16:08'!postTrimmedCopy	"We do this for performance.  We no longer need these fields, and we're about to serialize the receiver."	super postTrimmedCopy.	committed _ nil.	magmaArrayCommits _ nil! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 6/12/2006 23:47'!record	"Record my successful commit in the places that need to know."	commitPackage objectsDo:		[ : eachBuffer |		(result newObjectBuffers includesKey: eachBuffer oid)			ifFalse:				[ self connection removeTransientMagmaCollection: eachBuffer oid.				committed					at: eachBuffer oid					put: eachBuffer copyWithSameBuffer ] ].	result changedObjectBuffers: committed.	"Note the MagmaArray changes to faciliate future concurrency checking."	commitPackage allLargeCollectionChangesDo:		[ : eachChanges |		eachChanges isForMagmaArray			ifTrue:				[ eachChanges additionsDo:					[ : eachIndex : eachOid |					(self magmaArrayAdditionsAt: eachChanges collectionOid)						at: eachIndex						put: eachOid ] ] ]! !!MaCommitLogEntry methodsFor: 'private' stamp: 'cmm 3/16/2005 21:21'!recordLargeCollectionConflictsWith: aMaCommitPackage using: lcManagersDictionary	aMaCommitPackage allLargeCollectionChangesDo:		[ : eachChanges |		eachChanges isNewCollection ifFalse:			[ | collectionManager |			collectionManager _ lcManagersDictionary at: eachChanges collectionOid.			collectionManager				recordGeneralConflictsWith: eachChanges				in: self.			challengingEntries do:				[ : eachEntry |				collectionManager					recordConflictsBetween: eachChanges					and: eachEntry					in: self ] ] ]! !!MaCommitLogEntry methodsFor: 'private' stamp: 'cmm 10/15/2004 16:56'!recordObjectConflictsIn: aMaCommitPackage	"Go through everyone who has challenged me.  Determine if they have a same changed	oid that I have.  Also fail if a new instance of a class is being added and shouldn't be."	aMaCommitPackage persistentObjectsDo:		[ :eachObjectBuffer |		challengingEntries do:			[ :eachEntry |			(eachEntry hasCommitted: eachObjectBuffer oid)				ifTrue:					[ self						failResultWith: eachEntry connection						on: eachObjectBuffer oid ] ] ]! !!MaCommitLogEntry methodsFor: 'building' stamp: 'cmm 5/30/2005 22:19'!registerUsing: aMaObjectRepository	"Register all new objects by assigning them their permanentOids."	| map |	map _ Dictionary new: 100.	commitPackage newObjectsDo:		[ : eachBuffer |		eachBuffer oid: 			(map				at: eachBuffer oid				put: aMaObjectRepository getNextOid).		result recordNewObjectBuffer: eachBuffer copyWithSameBuffer ].	result permanentOids: map! !!MaCommitLogEntry methodsFor: 'testing' stamp: 'cmm 6/18/2004 15:52'!shouldServerRefresh	^ self didCommitSpecialOid! !!MaCommitLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:57'!stopTime	^ result stopTime! !!MaTransactionLogEntry class methodsFor: 'creation' stamp: 'cmm 5/14/2005 17:48'!id: anInteger connection: aMagmaClientConnection	^ self new 		id: anInteger ;		connection: aMagmaClientConnection ;		yourself! !!MaTransactionLogEntry methodsFor: 'building' stamp: 'cmm 10/15/2004 16:56'!addChallengingEntry: aMaCommitLogEntry	challengingEntries add: aMaCommitLogEntry! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:58'!connection	^ result connection! !!MaTransactionLogEntry methodsFor: 'private' stamp: 'cmm 10/15/2004 16:58'!connection: aMagmaClientConnection	result connection: aMagmaClientConnection! !!MaTransactionLogEntry methodsFor: 'private' stamp: 'cmm 7/11/2005 15:40'!ensureWillCall: specialOidsName at: oidInteger	(serverNotifications		at: specialOidsName  "see MaObjectRepository>>#initializeSpecialOidsList"		ifAbsentPut: [ Set new ]) add: oidInteger! !!MaTransactionLogEntry methodsFor: 'testing' stamp: 'cmm 10/15/2004 16:56'!hasExcessiveNumberOfChallengers	^ challengingEntries size > self connection maximumNumberOfChallengers! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 5/14/2005 17:46'!id	^ id! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 5/14/2005 17:46'!id: anInteger	id _ anInteger! !!MaTransactionLogEntry methodsFor: 'private' stamp: 'cmm 3/20/2005 20:20'!initialize	"of MaTransactionLogEntries or MaCommitLogEntries that challenge me."	super initialize.	challengingEntries _ OrderedCollection new.	self initializeResult.	needsToRefresh _ false.	self initializeServerNotifications! !!MaTransactionLogEntry methodsFor: 'private'!initializeResult	result _ MaRefreshViewResult new! !!MaTransactionLogEntry methodsFor: 'actions' stamp: 'cmm 5/19/2004 00:20'!initializeServerNotifications	serverNotifications _ Dictionary new! !!MaTransactionLogEntry methodsFor: 'testing'!isCommitEntry	^false! !!MaTransactionLogEntry methodsFor: 'testing' stamp: 'cmm 3/3/2002 19:00'!isForSameSessionAs: aMaTransactionLogEntry	^self connection == aMaTransactionLogEntry connection! !!MaTransactionLogEntry methodsFor: 'printing' stamp: 'cmm 6/20/2004 12:06'!maPrintAbbreviatedOn: aStream	aStream		maPrint: '(' ;		maPrint: self sessionId ;		maPrint: ') ' ;		maPrint: result userId! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 12/16/2002 23:28'!needsToRefresh: aBoolean	needsToRefresh _ aBoolean! !!MaTransactionLogEntry methodsFor: 'recovery' stamp: 'cmm 7/15/2005 14:22'!postTrimmedCopy	"We do this for performance.  We no longer need these fields, and we're about to serialize the receiver."	challengingEntries _ nil.	serverNotifications _ nil.	result _ result trimmedCopy! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:56'!recordAllChangedObjects	"Record all of the objects that the client will need to refresh."	challengingEntries do: [ :each | result addToBeRefreshed: each committed ]! !!MaTransactionLogEntry methodsFor: 'actions' stamp: 'cmm 7/11/2005 15:40'!recordChangesToSpecialObjectsIn: aMaCommitLogEntry using: aMaTransactionLog	aMaTransactionLog specialOidsDo:		[ : eachOid : eachKey |		(aMaCommitLogEntry hasCommitted: eachOid)			ifTrue:				[ aMaCommitLogEntry noteDidCommitSpecialOid.				self					ensureWillCall: eachKey					at: eachOid ] ]! !!MaTransactionLogEntry methodsFor: 'actions' stamp: 'cmm 12/25/2002 12:48'!renewRefreshFlag	| answer |	answer _ needsToRefresh & self isCommitEntry not.	self needsToRefresh: false.	^answer! !!MaTransactionLogEntry methodsFor: 'actions' stamp: 'cmm 5/19/2004 22:43'!renewServerNotifications	| answer |	answer _ serverNotifications.	serverNotifications notEmpty ifTrue: [ self initializeServerNotifications ].	^ answer! !!MaTransactionLogEntry methodsFor: 'private'!result	^result! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:58'!sessionId	^ result sessionId! !!MaTransactionLogEntry methodsFor: 'accessing' stamp: 'cmm 10/15/2004 16:58'!startTime	^ result startTime! !!MaTransactionLogEntry methodsFor: 'recovery' stamp: 'cmm 7/8/2005 16:10'!trimmedCopy	"Make a copy without things needed merely to applyToCache: so that serialization to the commitPackages recovery file will be quicker."	^ self copy postTrimmedCopy! !!MaTransactionalFileStream commentStamp: 'cmm 7/7/2005 12:11' prior: 0!This class emulates a StandardFileStream except doesn't actually write contents to disk until you send #maCommit.  Instead, it caches the written contents to a collection of MaTransactionalFileWriters.!!MaTransactionalFileStream class methodsFor: 'create' stamp: 'cmm 7/11/2005 17:32'!fileNamed: filenameString	^ (FileDirectory on: filenameString) exists		ifTrue:			[ self fileStream: (FileStream fileNamed: filenameString) ]		ifFalse:			[ self new				filename: filenameString ;				yourself ]! !!MaTransactionalFileStream class methodsFor: 'create' stamp: 'cmm 8/17/2005 23:14'!fileStream: aFileStream	aFileStream ifNil: [ MaUserError signal: 'fileStream required' ].	^ self new		setFileStream: aFileStream ;		yourself! !!MaTransactionalFileStream methodsFor: 'accessing' stamp: 'cmm 7/11/2005 22:07'!bePhysical	self isPhysical ifFalse:		[ fileStream _ (FileStream fileNamed: filename) binary "only binary files supported by this" ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:07'!binary	self isPhysical ifTrue: [ fileStream binary ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/12/2005 14:09'!close	self isPhysical 		ifTrue:			[ self maCommit.			fileStream close ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:05'!closed	^ self isPhysical and: [ fileStream closed ]! !!MaTransactionalFileStream methodsFor: 'accessing' stamp: 'cmm 7/11/2005 22:09'!committedSize	^ self isPhysical		ifTrue: [ fileStream size ]		ifFalse: [ 0 ]! !!MaTransactionalFileStream methodsFor: 'accessing' stamp: 'cmm 5/24/2006 22:17'!copyToDirectory: targetFileDirectory 	| shouldOpen dir |	shouldOpen _ self closed not.	self close.	[ dir _ self directory.	dir		maCopyFileNamed: (dir localNameFor: self filename)		toDirectory: targetFileDirectory ] ensure: [ shouldOpen ifTrue: [ self open ] ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:22'!directory	^ FileDirectory forFileName: filename! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 5/24/2006 21:50'!filename	^ filename! !!MaTransactionalFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:28'!filename: aString	filename _ aString! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/7/2005 22:27'!flush	self maCommit.	fileStream flush! !!MaTransactionalFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/4/2005 21:53'!initialize	super initialize.	self initializeWriters.	position _ 0.	guard _ Semaphore forMutualExclusion ! !!MaTransactionalFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/13/2005 15:04'!initializeWriters	writers _ BTree new.	uncommittedSize _ 0! !!MaTransactionalFileStream methodsFor: 'testing' stamp: 'cmm 7/11/2005 22:04'!isNew	^ self isPhysical not! !!MaTransactionalFileStream methodsFor: 'testing' stamp: 'cmm 7/11/2005 22:04'!isPhysical	^ fileStream notNil! !!MaTransactionalFileStream methodsFor: 'commit' stamp: 'cmm 7/4/2005 17:47'!maCommit	self maCommit: false! !!MaTransactionalFileStream methodsFor: 'commit' stamp: 'cmm 7/13/2005 15:28'!maCommit: shouldFlush	"writers, write!!"	| needsFlush |	guard critical:		[ self bePhysical.		needsFlush _ false.		self writersDo: 			[ : each | 			each write.			needsFlush _ true ].		self initializeWriters.		(shouldFlush and: [ needsFlush ]) ifTrue: [ fileStream flush ] ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:25'!maRead: someNumber bytesFromPosition: bufferPosition of: aByteArray atFilePosition: filePosition	| writer numberOfBytesRead |	^ guard critical:		[ (writer _ self writerAt: filePosition)			ifNil:				[ self bePhysical.				numberOfBytesRead _ 					fileStream						maRead: someNumber						bytesFromPosition: bufferPosition						of: aByteArray						atFilePosition: filePosition.				position _ fileStream position.				numberOfBytesRead ]			ifNotNil:				[ numberOfBytesRead _ someNumber min: writer byteArray size.				aByteArray					replaceFrom: bufferPosition					to: bufferPosition + numberOfBytesRead - 1					with: writer byteArray					startingAt: 1.				position _ filePosition + numberOfBytesRead.				numberOfBytesRead ] ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/13/2005 15:04'!maWrite: numberOfBytes bytesFromPosition: bufferPosition of: byteArray atFilePosition: filePosition	| writer |	writer _ 		MaTransactionalFileWriter			file: self			filePos: filePosition			byteArray: 				(byteArray 					copyFrom: bufferPosition 					to: bufferPosition + numberOfBytes - 1).	guard critical:		[ writers			at: writer endFilePos			put: writer.		uncommittedSize _ uncommittedSize max: filePosition + numberOfBytes.		position _ filePosition + numberOfBytes ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 5/24/2006 21:51'!nameself maMarked: 'delete'.	^ filename! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:25'!next: n into: aByteArray startingAt: startIndex	"This method is only called when logRecoveryRecords is turned on AND the initial read of an object did not fit within the #trackSize AND we are reading a part of the file has not yet been written to disk (still in my 'writers').  This happens when the server must refresh its session in the middle of a commit because new classes or LargeCollections have been added.  This is all so we can minimize flushing to disk, so we can have tolerable performance on normal hardware with logRecoveryRecords turned on.  Sheesh."	| writer |	guard critical:		[ (writer _ self writerAt: position)			ifNil:				[ self bePhysical.				fileStream					next: n					into: aByteArray					startingAt: startIndex.				position _ fileStream position ]			ifNotNil:				[ aByteArray					replaceFrom: startIndex					to: startIndex + (n min: writer byteArray size) - 1					with: writer byteArray					startingAt: position - writer filePos + 1.				position _ position + n ] ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/7/2005 22:17'!next: numberOfBytes putAll: aByteArray startingAt: startPos	"This isn't needed for Magma, and I don't feel like implementing it right now.  Better to just give an explicit error than get it wrong."	self error: 'not supported'! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:07'!open	self isPhysical ifTrue: [ fileStream open ]! !!MaTransactionalFileStream methodsFor: 'accessing' stamp: 'cmm 7/11/2005 22:03'!physicalStream	^ fileStream ifNil:		[ fileStream _ FileStream fileNamed: filename ]! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:06'!position: anInteger	self isPhysical ifTrue: [ fileStream position: anInteger ].	position _ anInteger! !!MaTransactionalFileStream methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:29'!setFileStream: aFileStream	fileStream _ aFileStream.	self filename: aFileStream name! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/7/2005 12:51'!size	^ self committedSize max: uncommittedSize! !!MaTransactionalFileStream methodsFor: 'filestream api' stamp: 'cmm 7/11/2005 22:18'!truncate: anInteger	| toBeRemoved |	self isPhysical ifTrue: [ fileStream truncate: anInteger ].	uncommittedSize _ uncommittedSize min: anInteger.	toBeRemoved _ OrderedCollection new. "Not sure if I can remove from a BTree while enumerating it.."	writers		from: anInteger		to: 999999999999999999999		do: [ : each | (each coversFilePosition: anInteger) ifTrue: [ toBeRemoved add: each ] ].	toBeRemoved do: [ : each | writers removeKey: each endFilePos ]! !!MaTransactionalFileStream methodsFor: 'private' stamp: 'cmm 6/16/2005 09:23'!writerAt: filePosition	writers		from: filePosition		to: 999999999999999999999		do: [ : each | ^ (each coversFilePosition: filePosition) ifTrue: [ each ] ].	^ nil! !!MaTransactionalFileStream methodsFor: 'accessing' stamp: 'cmm 7/13/2005 15:02'!writersDo: aBlock	writers do: aBlock! !!MaTransactionalFileWriter class methodsFor: 'as yet unclassified' stamp: 'cmm 7/4/2005 22:01'!file: aStandardFileStream filePos: anInteger byteArray: aByteArray	^ self new		setFile: aStandardFileStream		filePos: anInteger		byteArray: aByteArray! !!MaTransactionalFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 10:27'!byteArray	^ byteArray! !!MaTransactionalFileWriter methodsFor: 'testing' stamp: 'cmm 6/15/2005 17:11'!coversFilePosition: filePosition	^ filePosition		between: filePos		and: filePos + byteArray size - 1! !!MaTransactionalFileWriter methodsFor: 'accessing' stamp: 'cmm 7/11/2005 22:13'!currentRecord	| answer |	answer _ ByteArray new: byteArray size.	file physicalStream		maRead: byteArray size		bytesFromPosition: 1		of: answer		atFilePosition: filePos.	^ answer! !!MaTransactionalFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 22:18'!endFilePos	^ filePos + byteArray size - 1! !!MaTransactionalFileWriter methodsFor: 'accessing' stamp: 'cmm 6/15/2005 17:27'!filePos	^ filePos! !!MaTransactionalFileWriter methodsFor: 'initialize-release' stamp: 'cmm 7/11/2005 22:13'!setFile: aMaTransactionalWriter filePos: anInteger byteArray: aByteArray	file _ aMaTransactionalWriter.	filePos _ anInteger.	byteArray _ aByteArray! !!MaTransactionalFileWriter methodsFor: 'testing' stamp: 'cmm 7/12/2005 22:20'!willCauseGrowth	^ filePos >= file committedSize! !!MaTransactionalFileWriter methodsFor: 'actions' stamp: 'cmm 7/11/2005 22:12'!write	file physicalStream		maWrite: byteArray size		bytesFromPosition: 1		of: byteArray		atFilePosition: filePos! !!MaTree methodsFor: 'building'!add: anObject	"Adds anObject as a main parent in the receiver."	self		add: anObject		asChildOf: nil.	^anObject! !!MaTree methodsFor: 'building' stamp: 'cmm 2/12/2004 00:02'!add: anObject asChildOf: aParentObject	parents at: anObject put: aParentObject.	^anObject! !!MaTree methodsFor: 'building'!addAll: aCollection	"Adds all in aCollection as a main parents in the receiver."	aCollection do: [ :each | self add: each ]! !!MaTree methodsFor: 'building' stamp: 'cmm 6/10/2003 22:59'!addPath: anOrderedCollection	"Adds each object in anOrderedCollection as a new path in	the receiver.  The first element in anOrderedCollection is the	main parent, and each subsequent element is a child of the	previous.  Any parts of the path that need created will be."	^self		addPath: anOrderedCollection		to: nil! !!MaTree methodsFor: 'building'!addPath: anOrderedCollection to: parentObject	"Adds each object in anOrderedCollection as a new path in	the receiver.  The first element in anOrderedCollection is the	main parent, and each subsequent element is a child of the	previous.  If part of the path already exists, there it is	replaced (though they should be equivalent anyway)."	anOrderedCollection		inject: parentObject		into:			[ :parent :each |			self				add: each				asChildOf: parent.			each ].	^anOrderedCollection! !!MaTree methodsFor: 'building'!addTree: aMaTree	^self addTree: aMaTree to: nil! !!MaTree methodsFor: 'building' stamp: 'cmm 12/24/2002 16:08'!addTree: aMaTree to: anObject	(self includes: anObject) ifFalse: [ self error: anObject printString, ' is not part of ', self printString ].	aMaTree withParentsDo: [ :each :eachParent | self add: each asChildOf: eachParent ].	^aMaTree! !!MaTree methodsFor: 'enumerating'!allLeafsDo: aBlock	"Value aBlock with each element in the receiver that has no children."	| children |	children := self children.	parents keysAndValuesDo:		[ :eachChild :eachParent |		(children includesKey: eachChild) ifFalse: [ aBlock value: eachChild ] ]! !!MaTree methodsFor: 'accessing'!allMembers	"Returns a Set of all the members of the hierarchy"	^parents keys! !!MaTree methodsFor: 'accessing' stamp: 'cmm 6/10/2003 23:04'!allMembersDo: aBlock	"Returns a Set of all the members of the hierarchy"	^parents keysDo: aBlock! !!MaTree methodsFor: 'accessing' stamp: 'cmm 1/23/2002 14:30'!children	| children |	children := Dictionary new: parents size.	parents keysAndValuesDo:		[ :eachChild :eachParent |		(children			at: eachParent			ifAbsentPut: [ OrderedCollection new ])				add: eachChild ].	^children! !!MaTree methodsFor: 'accessing'!childrenOf: anObject 	^parents maAllKeysAtValue: anObject! !!MaTree methodsFor: 'accessing'!collect: aBlock	"Returns a new tree whose nodes have all been operated on by aBlock."	^self		collect: aBlock		into: self class new! !!MaTree methodsFor: 'private' stamp: 'cmm 1/23/2002 14:30'!collect: aBlock into: aMaTree 	"Since some objects may share a parent, we use the map to	make sure we only value each parent just once, otherwise we	could have some identity problems."	| map |	map := Dictionary new.	parents keysAndValuesDo: 			[:eachKey :eachValue | 			eachValue isNil 				ifTrue: [aMaTree add: (map at: eachKey ifAbsentPut: [aBlock value: eachKey])]				ifFalse: 					[aMaTree add: (map at: eachKey ifAbsentPut: [aBlock value: eachKey])						asChildOf: (map at: eachValue ifAbsentPut: [aBlock value: eachValue])]].	^aMaTree! !!MaTree methodsFor: 'accessing'!conform: aBlock 	parents keysDo: [:each | (aBlock value: each) ifFalse: [^false]].	^true! !!MaTree methodsFor: 'building' stamp: 'cmm 3/24/2005 11:06'!copy	^ super copy		parents: parents ;		yourself! !!MaTree methodsFor: 'enumerating'!depthFirstDo: twoArgBlock	"Value twoArgBlock with each object in the receiver and its parent in the order	of depthFirst."	self roots do:		[ :each |		twoArgBlock			value: each			value: nil.		self			depthFirstDo: twoArgBlock			at: each ]! !!MaTree methodsFor: 'enumerating'!depthFirstDo: twoArgBlock at: anObject	(self childrenOf: anObject) do:		[ :each |		twoArgBlock			value: each			value: anObject.		self			depthFirstDo: twoArgBlock			at: each ]! !!MaTree methodsFor: 'accessing'!depthOf: anObject	"Returns the number of parents anObject has."	| depth prevChild |	(self includes: anObject)		ifFalse:			[ self error: self printString , ' does not include ' , anObject printString ].	depth := 0.	prevChild := anObject.	[ prevChild isNil ] whileFalse:		[ prevChild := self parentOf: prevChild.		depth := depth + 1 ].	^depth! !!MaTree methodsFor: 'accessing' stamp: 'cmm 6/10/2003 23:02'!detect: aBlock	^parents detect: aBlock! !!MaTree methodsFor: 'accessing' stamp: 'cmm 6/10/2003 23:02'!detect: aBlock ifNone: exceptionBlock	^parents		detect: aBlock		ifNone: exceptionBlock value! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/24/2002 16:07'!do: oneArgBlock	parents keysDo: oneArgBlock! !!MaTree methodsFor: 'testing' stamp: 'cmm 7/25/2002 19:43'!hasChildFor: anObject 	"Returns true if anObject has any children.  Signal an error	if anObject is not part of the hierarchy."	^parents includes: anObject! !!MaTree methodsFor: 'testing'!hasParentFor: anObject	"Returns true if anObject has a parent"	^(self parentOf: anObject) notNil! !!MaTree methodsFor: 'testing'!includes: anObject 	^parents includesKey: anObject! !!MaTree methodsFor: 'private' stamp: 'cmm 3/24/2005 11:07'!initialize	super initialize.	self parents: Dictionary new! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 6/10/2003 23:02'!maDetect: aBlock ifFound: foundBlock ifNone: exceptionBlock 	^parents		maDetect: aBlock		ifFound: foundBlock		ifNone: exceptionBlock value! !!MaTree methodsFor: 'building' stamp: 'cmm 6/10/2003 23:00'!move: anObject to: newParentObject 	^parents at: anObject put: newParentObject! !!MaTree methodsFor: 'accessing'!nodesInPathFrom: someChildObject to: someParentObject	"Returns a collection of nodes between someChildObject	and someParentObject."	|answer node|	answer := OrderedCollection new.	self		nodesInPathFrom: someChildObject		to: someParentObject		do: [ :each | answer add: each ].	^answer! !!MaTree methodsFor: 'enumerating'!nodesInPathFrom: someChildObject to: someParentObject do: oneArgBlock	"For each node in the tree from someChildObject to someParentObject, value	oneArgBlock.  The highest level parent (nil) will not be used as an argument	to value oneArgBlock."	| node |	node := someChildObject.	oneArgBlock value: someChildObject.	[ node isNil or: [ node = someParentObject ] ] whileFalse:		[ oneArgBlock value: node.		node := self parentOf: node ].	someParentObject notNil ifTrue: [ oneArgBlock value: someParentObject ]! !!MaTree methodsFor: 'accessing'!parentOf: anObject 	^parents at: anObject! !!MaTree methodsFor: 'private' stamp: 'cmm 3/24/2005 11:07'!parents: aDictionary	parents _ aDictionary! !!MaTree methodsFor: 'accessing'!pathFrom: anObject	"Returns a collection of the objects that are contained in	the path to anObject ordered from an Object to the top of the hierarchy."	^self		nodesInPathFrom: anObject		to: nil! !!MaTree methodsFor: 'enumerating'!pathFrom: anObject do: aBlock	"Value aBlock with the objects from anObject to its highest level parent."	^self		nodesInPathFrom: anObject		to: nil		do: aBlock! !!MaTree methodsFor: 'accessing'!pathTo: anObject	"Returns a collection of the objects that are contained in	the path to anObject, ordered from the the top	of the hierarchy to anObject."	^(self pathFrom: anObject) reverse! !!MaTree methodsFor: 'testing'!pathTo: anObject includes: anotherObject	"Returns a boolean.  Example:  in the Smalltalk	class hierarchy, pathTo: Integer includes: Magnitude would	return true.  We use pathFrom in the implementation because	it is faster."	^(self pathFrom: anObject) includes: anotherObject! !!MaTree methodsFor: 'printing' stamp: 'cmm 12/24/2002 16:08'!printOn: aStream	super printOn: aStream.	self depthFirstDo:		[ :eachChild :eachParent |		aStream			cr;			tab: (self depthOf: eachChild);			maPrintAbbreviated: eachChild ]! !!MaTree methodsFor: 'accessing' stamp: 'cmm 7/1/2004 00:34'!reject: aBlock 	"Returns a new Tree with all branches removed that	meet aBlock criteria.  See method comment for more	info."	^self reject: [:each | aBlock value: each ]! !!MaTree methodsFor: 'building' stamp: 'cmm 7/25/2002 19:42'!remove: anObject	"Removes anObject and all of its children."	^self		remove: anObject		ifAbsent: [ self error: anObject printString, ' was not found in ', self printString ]! !!MaTree methodsFor: 'building'!remove: anObject ifAbsent: oneArgBlock 	"Answers the collection of removed objects removed after removing	anObject after removing it and all of its children."	| tree |	(tree := self treeAt: anObject) allMembers 		do: [:each | parents removeKey: each]! !!MaTree methodsFor: 'accessing' stamp: 'cmm 6/10/2003 23:08'!roots	"Answers a collection of all roots in this tree."	^self childrenOf: nil! !!MaTree methodsFor: 'accessing' stamp: 'cmm 4/10/2005 18:00'!select: aBlock 	"Returns a new Tree with all branches removed that	meet aBlock criteria.  See method comment for more	info."	| newTree |	newTree := self maOriginalClass new.	self allMembersDo: 			[:each | 			(aBlock value: each) ifTrue: [newTree addPath: (self pathTo: each)]].	^newTree! !!MaTree methodsFor: 'accessing'!size	^parents size! !!MaTree methodsFor: 'accessing' stamp: 'cmm 7/25/2002 19:43'!treeAt: aNode	"Return a new instance of the receiver which has a single main	parent aNode."	^self		treeAt: aNode		ifAbsent: [ self error: aNode printString, ' was not found in ', self printString ]! !!MaTree methodsFor: 'accessing'!treeAt: anObject ifAbsent: aBlock	"Return a new instance of the receiver which has a single main	parent anObject."	| newTree |	(self includes: anObject) ifFalse: [ ^aBlock value ].	newTree := self class new.	self		depthFirstDo:			[ :each :eachParent |			newTree				add: each				asChildOf: eachParent ]		at: anObject.	^newTree! !!MaTree methodsFor: 'enumerating' stamp: 'cmm 12/24/2002 16:09'!withParentsDo: twoArgBlock	parents keysAndValuesDo: twoArgBlock! !!MagmaClientConnection class methodsFor: 'creation' stamp: 'cmm 7/18/2005 13:20'!userId: aString sessionId: sessionIdInteger maximumNumberOfChallengers: anInteger	^self new		userId: aString ;		sessionId: sessionIdInteger ;		maximumNumberOfChallengers: anInteger ;		yourself! !!MagmaClientConnection methodsFor: 'transient MagmaCollections' stamp: 'cmm 6/12/2006 23:32'!addTransientMagmaCollection: collectionOid	transientMagmaCollections add: collectionOid! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 4/28/2003 16:48'!currentReadStrategy	^currentReadStrategy! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 4/28/2003 16:48'!currentReadStrategy: aMaReadStrategy	currentReadStrategy _ aMaReadStrategy! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 6/12/2006 23:30'!initialize	super initialize.	transientMagmaCollections _ Set new! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!maximumNumberOfChallengers	^maximumNumberOfChallengers! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!maximumNumberOfChallengers: anInteger	maximumNumberOfChallengers _ anInteger! !!MagmaClientConnection methodsFor: 'transient MagmaCollections' stamp: 'cmm 6/12/2006 23:47'!removeTransientMagmaCollection: collectionOid 	transientMagmaCollections 		remove: collectionOid		ifAbsent: 			[ "we call this loosely, not just with collection oids."			 ]! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!sessionId	^sessionId! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 6/26/2002 00:21'!sessionId: anInteger	sessionId _ anInteger! !!MagmaClientConnection methodsFor: 'transient MagmaCollections' stamp: 'cmm 6/12/2006 23:35'!transientMagmaCollectionOidsDo: aBlock	transientMagmaCollections do: aBlock! !!MagmaClientConnection methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:21'!userId	^userId! !!MagmaClientConnection methodsFor: 'initialize' stamp: 'cmm 6/26/2002 00:21'!userId: aString	userId _ aString! !!MaByteSequenceIndex commentStamp: 'cmm 12/25/2004 23:47' prior: 0!I represent an index that is based on a sequence of bytes to calculate the index-hash value.  I know the number of meaningful characters I can be searched by based on my bit-size.!!MaAsciiStringIndex commentStamp: 'cmm 8/20/2006 22:12' prior: 0!THIS CLASS IS NOW DEPRECATED.USE MaSearchStringIndex with #beAscii for full ascii-range index.I search based on an exactly matching sequence of ASCII characters (characters between 0 and 127).!!MaAsciiStringIndex methodsFor: 'accessing' stamp: 'cmm 8/20/2006 23:59'!canIndex: anObject	^(super canIndex: anObject) and: [ (self indexObjectFor: anObject) isString ]! !!MaAsciiStringIndex methodsFor: 'accessing' stamp: 'cmm 2/2/2005 22:03'!indexHashForIndexObject: aString	"Answer the index hash value of the receiver, a value	for a MaHashIndex.  Only ASCII values 0 - 127 are meaningful,	all others in aString are ignored."	| answer power |	aString isString ifFalse: [ MagmaInvalidIndexObject signal: 'Not a valid index object.  Need a String please.' ].	answer _ 0.	power _ meaningfulCharacters - 1.	aString do:		[ :eachChar |		(eachChar asciiValue			between: 0			and: 127)				ifTrue:					[ answer _ answer + (eachChar asciiValue * (self sizeOfCharacterSet raisedTo: power)).					power _ power - 1.					power < 0 ifTrue: [ ^answer ] ] ].	^answer! !!MaAsciiStringIndex methodsFor: 'private accessing'!sizeOfCharacterSet	^128! !!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 4/10/2005 18:00'!indexHashForIndexObject: aStringOrByteArray 	"Answer the index hash value of the receiver, a value for a MaHashIndex."	| byteArray |	aStringOrByteArray maOriginalClass isBytes 		ifFalse: 			[MagmaInvalidIndexObject 				signal: 'Not a valid index object.  Need a byte-object please.'].	byteArray := ByteArray new: keySize * 8.	byteArray 		replaceFrom: 1		to: (byteArray size min: aStringOrByteArray size)		with: aStringOrByteArray		startingAt: 1.	^byteArray maUint: keySize at: 0! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 2/22/2004 21:45'!initialize	super initialize.	self keySize: 32! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:31'!initializeNumberOfMeaningfulCharacters	meaningfulCharacters _ ((2 raisedTo: keySize) log: self sizeOfCharacterSet) truncated! !!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 2/22/2004 21:04'!keySize	^keySize! !!MaByteSequenceIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:31'!keySize: numberOfBits 	"Only set this ONCE, when you create.  It is not changeable after the dictionary is created."	keySize _ numberOfBits.	self initializeNumberOfMeaningfulCharacters! !!MaByteSequenceIndex methodsFor: 'accessing'!meaningfulCharacters	"Answer the number of characters this index will use to index."		^meaningfulCharacters! !!MaByteSequenceIndex methodsFor: 'accessing' stamp: 'cmm 3/13/2005 20:02'!sizeOfCharacterSet	^ 256! !!MaSearchStringIndex commentStamp: 'cmm 12/25/2004 23:50' prior: 0!I represent an index with just 64 characters of the ascii range utilized; 33 - 96, so we must do without the {, }, |, ~, and space characters.  This increases my number of meaningful characters and eliminates the need for case-sensitive matching.!!MaKeywordIndex commentStamp: 'cmm 12/25/2004 23:50' prior: 0!I am just like a MaSearchStringIndexDefinition except I index a collection of words.!!MaKeywordIndex methodsFor: 'accessing' stamp: 'cmm 7/2/2006 22:38'!ascendingSortBlock	^ [ : a : b | (self indexHashesFor: a) min < (self indexHashesFor: b) min ]! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:33'!beAlpha	"Set up this index to include only alpha characters; 		(65 to: 90) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 65		highChar: 90! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:33'!beAlphaNumeric	"Set up this index to include only alpha characters; 		(48 to: 90) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 48		highChar: 90! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:38'!beAscii	"Set up this index to include basic punctuation; 		(0 to: 127) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 0		highChar: 127! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:32'!bePunctuated	"Set up this index to include basic punctuation; 		(33 to: 96) collect: [ : each | Character value: each ]	This can only be called when the index is initially created, do not call this after the index is persistent."	self 		setLowChar: 33		highChar: 96! !!MaSearchStringIndex methodsFor: 'testing' stamp: 'cmm 8/21/2006 00:11'!canIndex: anObject 	^ (super canIndex: anObject) and: [ (self indexObjectFor: anObject) isCollection ]! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 22:11'!conditionedKeyword: aString 	"Answer the keyword aString conditioned for keyword search (i.e., padded to meaningfulCharacters, characters not in my lowChar..highChar range stripped)."	| stringIndex conditionedStringIndex conditionedString |	conditionedString _ (String new: meaningfulCharacters) atAllPut: (Character value: self lowChar).	stringIndex _ 1.	conditionedStringIndex _ 1.	"First, load conditionedString with conditioned characters from aString."	[ conditionedStringIndex <= meaningfulCharacters and: [ stringIndex <= aString size ] ] whileTrue: 		[ | conditionedChar |		conditionedChar _ (aString at: stringIndex) asUppercase.		(conditionedChar asciiValue 			between: self lowChar			and: self highChar) ifTrue: 			[ conditionedString 				at: conditionedStringIndex				put: conditionedChar.			conditionedStringIndex _ conditionedStringIndex + 1 ].		stringIndex _ stringIndex + 1 ].	^ conditionedString! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:03'!highChar	^ highChar ifNil: 		[ self bePunctuated.		highChar ]! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 22:31'!indexHashForIndexObject: aString 	"Answer the index hash value of the receiver, a value for a MaHashIndex."	"First, load zeroString with conditioned characters from aString."	"Now compute the hash value."	| answer conditionedString |	aString isString ifFalse: 		[ MagmaInvalidIndexObject signal: 'Invalid index object, need a String.' ].	conditionedString _ self conditionedKeyword: aString.	answer _ 0.	conditionedString doWithIndex: 		[ : eachChar : index | 		answer _ answer + ((eachChar asciiValue - self lowChar) * (self sizeOfCharacterSet raisedTo: meaningfulCharacters - index)) ].	^ answer! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:04'!lowChar	^ lowChar ifNil: 		[ self bePunctuated.		lowChar ]! !!MaSearchStringIndex methodsFor: 'initialize' stamp: 'cmm 8/20/2006 21:32'!setLowChar: lowInteger highChar: highInteger	lowChar _ lowInteger.	highChar _ highInteger.	self initializeNumberOfMeaningfulCharacters! !!MaSearchStringIndex methodsFor: 'private' stamp: 'cmm 8/20/2006 21:28'!sizeOfCharacterSet	^ self highChar - self lowChar + 1! !!MaDateAndTimeIndex commentStamp: 'brp 12/21/2005 15:07' prior: 0!This class indexes DateAndTime attributes.A DateAndTime has four instance variables:	julianDayNumber 	- any day since 24 November -4713	seconds				- seconds since midnight	nanoSeconds		- up to 10 rasiedTo: 9 per second	offset				- a Duration from UTCThis would require many byes of hash space. Fortunately most of this power is seldom used.This class allows the user to specify the earliest date indexed (epoch), the clock precision and how far into the future dates may be specified (duration). All dates are manipulated in UTC.This allows a far more compact hash value to be generated!!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 15:08'!duration	^ duration! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 15:08'!duration: aDuration	duration := aDuration! !!MaDateAndTimeIndex methodsFor: 'testing' stamp: 'brp 12/21/2005 16:52'!earliestDateAndTime	^ self epoch + DateAndTime clockPrecision ! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 14:57'!epoch	^ epoch! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 15:37'!epoch: aDateAndTime	epoch := aDateAndTime asDateAndTime asUTC.! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'brp 7/30/2006 06:32'!indexHashForIndexObject: aDateAndTime	^ aDateAndTime		ifNil: [0]		ifNotNil: [			| delta hash |			delta := aDateAndTime asDateAndTime asUTC - self epoch.			hash := delta asSeconds * self magnification.			delta nanoSeconds isZero ifFalse: [ 				hash := hash + (delta nanoSeconds /							(self precision / 1 second * NanosInSecond))								floor ].			hash < 0 ifTrue: [ MagmaInvalidIndexObject signal: 				'Not a valid DateAndTime: . The index object must be greater than ' , 				self epoch printString ].			hash ]! !!MaDateAndTimeIndex methodsFor: 'private' stamp: 'brp 12/21/2005 16:40'!initialize	super initialize.	self 		epoch: DateAndTime epoch;		duration: (365.24 * 1024) ceiling days;		precision: 1 nanoSecond! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'brp 12/21/2005 15:32'!keySize	"The keySize is a function of the epoch, duration, and precision"	| bits |	bits := ((self duration asSeconds * self magnification) log: 2) ceiling.	^ (bits / 8) ceiling * 8! !!MaDateAndTimeIndex methodsFor: 'testing' stamp: 'brp 12/21/2005 16:52'!latestDateAndTime	^ self epoch + self duration - DateAndTime clockPrecision ! !!MaDateAndTimeIndex methodsFor: 'must override' stamp: 'brp 12/21/2005 15:26'!magnification	"Answer the factor by which the modified julian day number must be 	multiplied in order to accomodate the clock precision"	^ 1 second / self precision! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 14:57'!precision	^ precision! !!MaDateAndTimeIndex methodsFor: 'accessing' stamp: 'brp 12/21/2005 15:20'!precision: aDuration	( self validPrecisions includes: aDuration)		ifTrue: [ precision := aDuration ]		ifFalse: [ self error: 'invalid precision' ]! !!MaDateAndTimeIndex methodsFor: 'private' stamp: 'brp 12/21/2005 15:21'!validPrecisions 	^ { 1 second. 1 milliSecond. 1 nanoSecond } ! !!MaDateIndex commentStamp: 'cmm 12/25/2004 23:51' prior: 0!I am a 24-bit index useful for indexing objects by a Date.!!MaDateIndex methodsFor: 'as yet unclassified' stamp: 'cmm 8/4/2006 14:04'!indexHashForIndexObject: aDate	(aDate respondsTo: #julianDayNumber)		ifFalse:			[ MagmaInvalidIndexObject signal: 'Not a valid date.' ].	^ aDate julianDayNumber! !!MaDateIndex methodsFor: 'as yet unclassified' stamp: 'cmm 4/8/2004 00:41'!keySize"Rationale for 24-bit index:	Date julianDayNumber: (2 raisedTo: 24) (prints 10 May 41222)Will Squeak still be around then??"	^ 24! !!MaFloatIndex commentStamp: 'cmm 12/25/2004 23:51' prior: 0!I am a 32-bit index usefulf or indexing objects by a Float value.!!MaFloatIndex methodsFor: 'as yet unclassified' stamp: 'cmm 2/2/2005 22:03'!indexHashForIndexObject: aFloat	aFloat isFloat ifFalse: [ MagmaInvalidIndexObject signal: 'Not a valid index object.  Need a Float please.' ].	^aFloat asIEEE32BitWord! !!MaFloatIndex methodsFor: 'as yet unclassified' stamp: 'cmm 2/22/2004 21:59'!keySize	^ 32! !!MaIntegerIndex methodsFor: 'overriding' stamp: 'cmm 7/17/2005 21:25'!indexHashForIndexObject: anInteger	^ anInteger! !!MaIntegerIndex methodsFor: 'initialize' stamp: 'cmm 7/17/2005 21:26'!initialize	super initialize.	keySize _ 32! !!MaIntegerIndex methodsFor: 'accessing' stamp: 'cmm 7/18/2005 13:29'!keySize	^ keySize! !!MaIntegerIndex methodsFor: 'overriding' stamp: 'cmm 7/17/2005 21:25'!keySize: numberOfBits	"Only set this ONCE, when you create.  It is not changeable after the index is created."	keySize _ numberOfBits! !!MaUUIDIndex commentStamp: 'brp 12/20/2005 09:50' prior: 0!This class is as index on a 16 Byte UUID.!!MaUUIDIndex methodsFor: 'must override' stamp: 'brp 12/21/2005 09:38'!indexHashForIndexObject: anUUID	"anUUID is a 16 byte ByteArray"	^ anUUID maUint: self keySize at: 0! !!MaUUIDIndex methodsFor: 'must override' stamp: 'brp 12/20/2005 09:56'!keySize	"Answer an Integer number of bits, in multiples of 8, that each key value can be."	^ 128	"UUID new size * 8"! !!MagmaCollectionIndex class methodsFor: 'creation' stamp: 'cmm 9/26/2004 20:22'!attribute: aSymbol	^ super new		attribute: aSymbol;		yourself! !!MagmaCollectionIndex class methodsFor: 'inappropriate use' stamp: 'cmm 9/26/2004 20:23'!new	MagmaUserError signal: 'Should not create indexes with #new.  Use #attribute: instead.'! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'cmm 6/14/2006 12:49'!ascendingSortBlock	^ [ :a :b | (self indexHashFor: a) < (self indexHashFor: b) ]! !!MagmaCollectionIndex methodsFor: 'accessing'!attribute	"the accessor symbol for any kind of object that has this attribute.	These are used to determine what whether the receiver is appropriate to restrict	or sort a Query."	^attribute! !!MagmaCollectionIndex methodsFor: 'private'!attribute: aSymbol	attribute _ aSymbol! !!MagmaCollectionIndex methodsFor: 'testing'!canIndex: anObject	^anObject respondsTo: attribute! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'cmm 6/14/2006 12:49'!descendingSortBlock	^ [ :a :b | (self indexHashFor: a) > (self indexHashFor: b) ]! !!MagmaCollectionIndex methodsFor: 'private'!highestPossibleKey	^(2 raisedTo: self keySize) - 1! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 4/11/2005 16:26'!indexHashFor: anObject 	"Answer the Integer hash used to locate anObject."	self validateCanIndex: anObject.	^ self indexHashForIndexObject: (self indexObjectFor: anObject)! !!MagmaCollectionIndex methodsFor: 'must override' stamp: 'cmm 11/7/2002 23:06'!indexHashForIndexObject: anObject	self subclassResponsibility! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 12/5/2002 17:31'!indexHashesFor: anObject 	"Answer an Integer or Array of Integers that will be used to locate the receiver."	self validateCanIndex: anObject.	^self indexHashesForIndexObject: (self indexObjectFor: anObject)! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 7/2/2006 22:30'!indexHashesForIndexObject: anObject 	"Answer a collection of Integers which are the MaHashIndex locations at which anObject will be indexed."	^ (anObject isCollection and: [ anObject maOriginalClass isPointers ]) 		ifTrue: [ anObject collect: [ : each | self indexHashForIndexObject: each ] ]		ifFalse: [ Array with: (self indexHashForIndexObject: anObject) ]! !!MagmaCollectionIndex methodsFor: 'private' stamp: 'cmm 7/2/2006 23:37'!indexObjectFor: anObject	"Answer the object by which I am indexed."	^anObject perform: attribute! !!MagmaCollectionIndex methodsFor: 'initialize' stamp: 'cmm 8/17/2005 21:14'!initialize	super initialize.	self recordSize: 8  "use a fair recordSize in case keys have poor density"! !!MagmaCollectionIndex methodsFor: 'must override' stamp: 'cmm 2/22/2004 21:47'!keySize	"Answer an Integer number of bits, in multiples of 8, that each key value can be."	self subclassResponsibility! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'brp 7/18/2006 20:17'!lowestPossibleKey	^ 0! !!MagmaCollectionIndex methodsFor: 'printing' stamp: 'cmm 4/22/2002 22:25'!maPrintAbbreviatedOn: aStream	aStream nextPutAll: self attribute! !!MagmaCollectionIndex methodsFor: 'accessing' stamp: 'cmm 12/10/2002 23:30'!recordSize	^recordSize! !!MagmaCollectionIndex methodsFor: 'initialize' stamp: 'cmm 9/21/2005 14:19'!recordSize: anInteger	"Only set this ONCE, when you create.  It is not changeable after the dictionary is created."	(MaHashIndex validRecordSizes includes: anInteger)		ifTrue: [ recordSize := anInteger ]		ifFalse:			[ MagmaUserError signal: 'recordSize must be one of ', MaHashIndex validRecordSizes printString ]! !!MagmaCollectionIndex methodsFor: 'private'!uniqueFileIdentifier	^self attribute! !!MagmaCollectionIndex methodsFor: 'validate' stamp: 'cmm 8/17/2005 21:18'!validRecordSizes	"Record sizes must be a power of 2 so that slots in every MaHashIndexRecord will be uniformely sized."	^ #(2 4 8 16 32 64 128)! !!MagmaCollectionIndex methodsFor: 'validate' stamp: 'cmm 5/1/2002 23:12'!validateCanIndex: anObject	(self canIndex: anObject)		ifFalse:			[ MagmaUserError signal:				'Cannot calculate the hashIndexFor: ' , anObject printString ]! !!MagmaCollectionReader commentStamp: 'cmm 6/5/2006 20:45' prior: 0!I represent a set of objects contained by a MagmaCollection satisfying my query 'expression'.  Though I am not a Collection, I can be thought of one in terms of reading objects (I can't add or remove any objects for you, but I can hand you my #collection who'll do it for you).I am created by sending #where: to a MagmaCollection.  My #size is how many objects satisfy the query, which may take some time to compute.I am persistable in Magma just like any object.  I can be stored as a "pre-defined" query or something.  I'll work just fine after enduring storage and retrieval to a Magma database.!!MagmaCollectionReader class methodsFor: 'creation' stamp: 'cmm 4/14/2006 16:13'!collection: aMagmaCollection index: aMaHashIndex lowKey: lowHashKey highKey: highHashKey readStrategy: aMaReadStrategyself maMarked: 'delete'.	^self new		collection: aMagmaCollection ;		index: aMaHashIndex ;		lowKey: lowHashKey ;		highKey: highHashKey ;		readStrategy: aMaReadStrategy ;		yourself! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/1/2006 17:34'!adjustLastKnownSize: anInteger 	(segments notEmpty and: [ segments last atEnd ]) ifTrue: [ segments last adjustLastKnownSize: anInteger ]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 8/1/2006 20:34'!anyOne	^ self isLoaded 		ifTrue: [ segment objects anyOne ]		ifFalse: [ self detect: [ : e | true ] ]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 8/1/2006 20:35'!asArray: count 	"Answer an Array of up to count elements contained in me."	| a |	a _ Array new: (count min: self lastKnownSize).	self withIndexDo: 		[ : each : x | 		a 			at: x			put: each.		x = count ifTrue: [ ^ a ] ].	^ a! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 8/8/2006 21:00'!asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'gk 5/26/2006 15:54'!asOrderedCollection	"Answer an OrderedCollection of me."	^OrderedCollection new setContents: (self asArray: self size); yourself! !!MagmaCollectionReader methodsFor: 'converting' stamp: 'cmm 11/16/2004 23:04'!asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 5/28/2006 21:45'!ascend	self descending: false! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 8/1/2006 20:36'!at: anInteger 	^ self 		at: anInteger		ifOutOfBounds: [ MagmaUserError signal: 'out of bounds' ]! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 4/29/2005 11:38'!at: anInteger ifOutOfBounds: aBlock	^ self		primAt: 			(reversed				ifTrue: [ self lastKnownSize - anInteger + 1 ]				ifFalse: [ anInteger ])		ifOutOfBounds: aBlock! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:58'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/30/2002 23:49'!collection	^collection! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 4/14/2005 23:08'!collection: aMagmaCollection	collection _ aMagmaCollection.	self setUpListener! !!MagmaCollectionReader methodsFor: 'copying' stamp: 'brp 5/13/2005 19:52'!copyFrom: startIndex to: endIndex	^ (startIndex to: endIndex) collect: [ :i | self at: i ]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:59'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum _ 0.	self do: [:each | (aBlock value: each) ifTrue: [sum _ sum + 1]].	^ sum! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 5/28/2006 21:45'!descend	self descending: true! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/9/2006 16:02'!descending: aBoolean 	self isSorted ifFalse: [ MagmaUserError signal: 'not sorted' ].	reversed _ aBoolean! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:01'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val _ aBlock value: each) > maxValue ifTrue: [					maxElement _ each.					maxValue _ val]]			ifTrue: ["first element"				maxElement _ each.				maxValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:01'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val _ aBlock value: each) < minValue ifTrue: [					minElement _ each.					minValue _ val]]			ifTrue: ["first element"				minElement _ each.				minValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:02'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 7/30/2006 16:08'!do: oneArgBlock 	1 		to: self lastKnownSize		do: [ : n | oneArgBlock value: (self at: n) ]! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 12:56'!doesNotUnderstand: aMessage 	| clause |	clause _ MaClause new		reader: self ;		attribute: aMessage selector ;		yourself.	self expression ifNil: [ self expression: clause ].	^ clause! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:00'!errorNotFound: anObject	MagmaUserError signal: 'Object is not in the collection.'! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'brp 4/5/2005 10:52'!errorNotPersistent	MagmaUserError signal: 'Not supported for non-persistent collections.'! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 12:54'!expression	^ expression! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 12:54'!expression: aTerm	expression := aTerm! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'brp 10/28/2005 13:16'!first	^ self at: 1! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/16/2006 14:01'!fixUpExpression	expression reader: self! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 7/26/2006 20:20'!fractionSorted	"For MagmaCollections that are sorted in a background server process, we must ask the server for progress."	^ collection fractionLoaded! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/30/2006 10:46'!getNextSegmentAndLoad: aBoolean 	| toRefresh |	toRefresh _ segments 		ifEmpty: 			[ (MagmaCollectionReaderSegment new)				startIndex: 1 ;				trunkStart: 1 ;				yourself ]		ifNotEmpty: [ segments last nextSegment ].	self 		refreshSegment: toRefresh		loadObjects: aBoolean.	"Return nil unless a new segment was created."	^ (segments isEmpty or: [ segments last ~= toRefresh ]) ifTrue: [ segments add: toRefresh ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/2/2006 22:44'!hasMergedRemovals: aMagmaCollectionReaderSegment 	"Providing #at: access to unsorted is complicated, but useful for paging through results in lists.  For unsorted, each segment is only merged once.  This method answers whether aMagmaCollectionReaderSegment has already had local removals merged from a prior access."	| segmentPosition |	segmentPosition _ segments indexOf: aMagmaCollectionReaderSegment.	^ segmentPosition > 1  "should always be, but let's not blow up if its not"		ifTrue: 			[ (segments at: segmentPosition - 1) mergedCount > aMagmaCollectionReaderSegment mergedCount ]		ifFalse: [ false ]! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:12'!ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	^ self isEmpty ifTrue: emptyBlock ifFalse: [notEmptyBlock valueWithPossibleArgument: self]! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:12'!ifEmpty: emptyBlock ifNotEmptyDo: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	"Evaluate the notEmptyBlock with the receiver as its argument"	^ self isEmpty ifTrue: emptyBlock ifFalse: [notEmptyBlock value: self]! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:13'!ifNotEmpty: aBlock	"Evaluate the given block unless the receiver is empty.      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	^self isEmpty ifFalse: [aBlock valueWithPossibleArgument: self].! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:13'!ifNotEmpty: notEmptyBlock ifEmpty: emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	 If the notEmptyBlock has an argument, eval with the receiver as its argument"	^ self isEmpty ifFalse: [notEmptyBlock valueWithPossibleArgument: self] ifTrue: emptyBlock! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:13'!ifNotEmptyDo: aBlock	"Evaluate the given block with the receiver as its argument."	^self isEmpty ifFalse: [aBlock value: self].! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 15:14'!ifNotEmptyDo: notEmptyBlock ifEmpty: emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	Evaluate the notEmptyBlock with the receiver as its argument"	^ self isEmpty ifFalse: [notEmptyBlock value: self] ifTrue: emptyBlock! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 4/14/2006 13:03'!includes: anObject	(collection includes: anObject) ifFalse: [ ^ false ].	^ expression evaluate: anObject! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/14/2006 15:35'!indexNamed: attributeSymbol	^ collection indexNamed: attributeSymbol! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 6/5/2006 20:57'!initialize	super initialize.	self pageSize: 125.	reversed _ false.	self initializeSegments! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 8/1/2006 17:14'!initializeSegments	trunk _ nil.	"let's share the trunk"	segment _ nil.	segments _ OrderedCollection new.	localAdditionsSegment _ nil! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue _ thisValue.	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].	^nextValue! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/16/2006 16:31'!isDescending	^ reversed! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 7/18/2002 15:44'!isEmpty	^self size = 0! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 6/8/2006 16:29'!isLoaded	"Answer whether I have a page of objects loaded."	^ segment notNil! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 4/5/2005 12:31'!isNewCollection	^ collection isNewCollection! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/8/2006 16:22'!isSorted	^ self sortIndex notNil! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'cmm 6/5/2006 00:08'!knowsSize	^ segments notEmpty and: [segments last atEnd]! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 8/1/2006 20:40'!last	^ self at: self lastKnownSize! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/29/2006 18:17'!lastKnownSize	| didLoad |	didLoad _ false.	[ segments isEmpty or: [ segments last atEnd not ] ] whileTrue: 		[ self getNextSegmentAndLoad: false.		didLoad _ true ].	didLoad ifTrue: [ collection isNewCollection ifFalse: [ self mergeChanges ] ].	^ segments last lastKnownSize! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/3/2006 12:42'!loadFromIndex: indexInteger pageSize: pageSizeInteger 	"we can simply integrate the non-persistents all into one dedicated page at the beginning?"	(self segmentContaining: indexInteger) ifNotNilDo: 		[ : desiredSegment | 		"if swapping to a different segment, save memory by clipping its objects."		(segment notNil and: [ segment ~= desiredSegment ]) ifTrue: [ segment initializeObjects ].		segment _ desiredSegment.		collection isNewCollection ifFalse: 			[ self mergeChanges.			"If merging changes caused segments to shift enough where indexInteger is no longer part of the originally-retrieved segment, then re-retrieve it given that we now know which segment will contain it."			(segment notNil and: [ (segment includesIndex: indexInteger) not ]) 				ifTrue: 					[ self 						loadFromIndex: indexInteger						pageSize: pageSizeInteger ]				ifFalse: [ self stronglyReferencePage ] ] ]! !!MagmaCollectionReader methodsFor: 'ma contextual search' stamp: 'cmm 1/8/2005 18:38'!maNewSearchContext	^ MagmaCollectionContext reader: self! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/29/2006 17:58'!maTransientVariables 	^ super maTransientVariables, #('trunk' 'segment' 'segments' 'changesSegment' )! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/14/2005 23:48'!maWantsPostMaterialization 	^ true! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/20/2006 15:47'!merge: oneArgBlock at: hashKey advance: anInteger 	| containingSegment |	containingSegment _ self segmentSpanningKey: hashKey.	containingSegment ifNil: [ ^ self ].	oneArgBlock value: containingSegment.	containingSegment advanceEnd: anInteger.	self 		segmentsAfter: containingSegment		do: [ : eachSegment | eachSegment advanceStart: anInteger ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/16/2006 17:34'!mergeAddition: anObject at: hashKey 	"Fixup my segments by acknowledging that anObject exists in this reader at positions hashKeys.  If anObject is in the range of the active page (i.e., my 'segment'), then add it to its objects collection."	| sortNeeded |	sortNeeded _ false.	self 		merge: 			[ : containingSegment | 			containingSegment == segment ifTrue: 				[ sortNeeded _ true.				segment addObject: anObject ] ]		at: hashKey		advance: 1.	^ sortNeeded! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 6/8/2006 16:13'!mergeChanges	self isSorted 		ifTrue: [ self mergeChangesSorted ]		ifFalse: [ self mergeChangesUnsorted ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/7/2006 15:34'!mergeChangesSorted	"I am sorted.  My segment may be populated with the desired segment, my segments are populated.  Merge in my collections changes, fixing up my segments as necessary."	| indexOfSortIndex sortNeeded sortIndex indexHashes minHash |	sortNeeded _ false.	self resetSegmentRanges.	indexOfSortIndex _ collection indexes indexOf: self sortIndex.	collection changes additionsDo: 		[ : eachObject : eachHashes | 		indexHashes _ eachHashes at: indexOfSortIndex.		minHash _ indexHashes min.		(expression evaluationCount: eachObject) timesRepeat: 			[ sortNeeded _ sortNeeded 				| (self 					mergeAddition: eachObject					at: minHash) ] ].	sortIndex _ self sortIndex.	(sortNeeded and: [ sortIndex notNil ]) ifTrue: [ segment sortObjects: sortIndex ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/7/2006 15:35'!mergeChangesUnsorted	"I am not sorted.  My segment is populated with the desired segment, my segments are populated.  Put my collections changes at the beginning, fixing up my subsequent segments as necessary."	localAdditionsSegment ifNil: [ self mergeChangesUnsortedAdditions ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/4/2006 15:03'!mergeChangesUnsortedAdditions	"I am not sorted.  My segment is populated with the desired segment, my segments are populated.  Put my collections changes at the beginning, fixing up my subsequent segments as necessary."	collection changes additionsDo: 		[ : eachObject : eachHashes | 		(expression evaluate: eachObject) ifTrue: 			[ localAdditionsSegment _ localAdditionsSegment ifNil: 				[ segments addFirst: (					(MagmaCollectionReaderSegment new)						startIndex: 1 ;						endIndex: 0 ;						trunk: trunk ;						yourself) ].			localAdditionsSegment				addObject: eachObject ;				advanceEnd: 1.			self 				segmentsAfter: localAdditionsSegment				do: [ : each | each advanceStart: 1 ] ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/7/2006 15:35'!mergeChangesUnsortedRemovals	"I am not sorted.  Persistent objects have been removed but not yet committed.  For each removal qualifying my expression, retreat the appropriate segments positions.  For the loaded segment (i.e., my 'segment') also remove the removed object if its there."	| shouldRetreat |self maMarked: 'delete'.	segment ifNil: [ ^ self ].	shouldRetreat _ (self hasMergedRemovals: segment) not.	collection changes removedDo: 		[ : eachObject : eachHashes | 		(expression evaluate: eachObject) ifTrue: 			[ (segment objects includes: eachObject) ifTrue: 				[ segment removeObject: eachObject.				shouldRetreat ifTrue: 					[ segment advanceEnd: -1.					self 						segmentsAfter: segment						do: [ : eachSubsequent | eachSubsequent advanceStart: -1 ] ] ] ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/16/2006 17:38'!mergeRemoval: anObject at: hashKey 	self 		merge: 			[ : containingSegment | 			containingSegment == segment ifTrue: [ segment removeObject: anObject ] ]		at: hashKey		advance: -1! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/27/2006 21:06'!newReducedReaderOn: attribute makeDistinct: aBoolean 	"Create a new MagmaCollection and install it on the server without going through the normal transaction process.  This is nothing more than a transient object that happens to require server support."	| newMc index |	index _ self indexNamed: attribute.	newMc _ MagmaCollection new.	newMc indexes add: index.	collection isNewCollection 		ifTrue: 			[ aBoolean 				ifTrue: [ self asSet do: [ : each | newMc add: each ] ]				ifFalse: [ self do: [ : each | newMc add: each ] ] ]		ifFalse: 			[ collection 				load: newMc				from: self				makeDistinct: aBoolean ].	^ newMc read: attribute! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:20'!normalize	self expression normalize! !!MagmaCollectionReader methodsFor: 'testing' stamp: 'brp 11/8/2004 18:42'!notEmpty	^ self isEmpty not! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:12'!pageSize	"The number of object retrieved to memory at a time."	^ pageSize! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 7/16/2006 20:00'!pageSize: anInteger 	"Tell the receiver to retrieve anInteger number of elements at a time when 'scrolling' to a new part of the collection via at:."	pageSize _ anInteger.	"We must refresh because my segments are laid out by my page-size and is also how my changes are merged."	self refresh! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 6/14/2006 12:43'!primAt: indexInteger ifOutOfBounds: aBlock	"Interrogates the committed and uncommitted contents of the underlying collection."	^ (self isLoaded and: [ segment includesIndex: indexInteger ])		ifTrue:			[ segment at: indexInteger ]		ifFalse:			[ self				loadFromIndex: indexInteger				pageSize: pageSize.			(segment notNil and: [segment includesIndex: indexInteger])				ifTrue: [ segment at: indexInteger ]				ifFalse: [ aBlock value ] ]! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:11'!read: attributeSymbol at: key	"Answers a MaLargeCollectionReader with access to all elements at key."	^ self		read: attributeSymbol		from: key		to: key! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: lowKey	"Answers a MaLargeCollectionReader with access to all of my elements after lowKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: lowKey)		toHash: index highestPossibleKey! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: startKey to: endKey	"Answers a MaLargeCollectionReader with access to all of my elements between startKey and endKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: startKey)		toHash: (index indexHashForIndexObject: endKey)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol from: startKey upTo: endKey      "Answers a MaLargeCollectionReader with access to all of my elements between startKey and endKey, but NOT including endKey.  This is useful with MaByteSequenceIndexDefinitions where you want to find all matching the left-side of a particular key."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: (index indexHashForIndexObject: startKey)		toHash: ((index indexHashForIndexObject: endKey) - 1 max: 0)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:17'!read: attributeSymbol to: highKey	"Answers a MaLargeCollectionReader with access to all of my elements up to highKey."	| index |	index := self indexNamed: attributeSymbol.	^ self		readIndex: index		fromHash: 0		toHash: (index indexHashForIndexObject: highKey)! !!MagmaCollectionReader methodsFor: 'expressions' stamp: 'cmm 4/14/2006 16:11'!readIndex: aMagmaCollectionIndex fromHash: lowHashValue toHash: highHashValue 	"Answers a MaLargeCollectionReader."	| clause |	clause _ MaClause new		reader: self ;		attribute: aMagmaCollectionIndex attribute ;		lowKey: lowHashValue ;		highKey: highHashValue ;		yourself.	self expression ifNil: [ self expression: clause ].	^ clause! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/7/2002 22:57'!readStrategy	^readStrategy! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 11/7/2002 22:50'!readStrategy: aMaReadStrategy	readStrategy _ aMaReadStrategy! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 6/5/2006 20:58'!refresh	"clear out my caches.  The next access will force retrieve my latest state from the server."	self initializeSegments! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/1/2006 17:14'!refreshSegment: aMagmaCollectionReaderSegment loadObjects: aBoolean 	aMagmaCollectionReaderSegment = localAdditionsSegment ifFalse: 		[ collection 			refreshSegment: aMagmaCollectionReaderSegment			where: expression			pageSize: pageSize			using: readStrategy			loadObjects: aBoolean ].	self trunk: aMagmaCollectionReaderSegment trunk.	self sortIndex ifNotNilDo: [ : sortIndex | aMagmaCollectionReaderSegment sortObjects: sortIndex ]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 23:03'!reject: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:element | (aBlock value: element) == false]! !!MagmaCollectionReader methodsFor: 'initialize-release' stamp: 'cmm 7/18/2005 13:17'!release	super release.	self removeListener! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 5/2/2005 22:11'!removeListener	collection removeDependent: self! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/1/2006 17:14'!removePriorLocalAdditionsSegment	localAdditionsSegment ifNotNil: 		[ segments remove: localAdditionsSegment.		localAdditionsSegment _ nil ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/2/2006 20:07'!resetSegmentRanges	"Before each merge of local changes, my segments must be reset to indicate the page index ranges as they exist in the repository, otherwise, multiple page retrieves would continue to modify the index ranges when changes were merged (incorrectly).  My lastKnownSize must also be reset."	| totalMerged |	totalMerged _ 0.	segments withIndexDo: 		[ : each : index | 		each = segments last ifTrue: [ totalMerged _ each mergedCount ].		each			startIndex: (index - 1) * pageSize + 1 ;			endIndex: each startIndex + pageSize - 1 ;			resetMergedCount ].	self adjustLastKnownSize: totalMerged! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/30/2006 10:54'!segmentContaining: anInteger 	"My expression is complex, an object at anInteger is being requested.  If I have previously loaded the segment containing anInteger, switch to it immediately from my cached 'segments'.  Otherwise, keep getting the next segment until we have the requested index."	| desiredSegment |	^ segments 		maDetect: [ : each | each includesIndex: anInteger ]		ifFound: 			[ : foundSegment | 			self 				refreshSegment: foundSegment				loadObjects: true.			foundSegment ]		ifNone: 			[ 			[ desiredSegment _ self getNextSegmentAndLoad: true.			desiredSegment isNil or: [ (desiredSegment includesIndex: anInteger) or: [ desiredSegment atEnd ] ] ] whileFalse.			(desiredSegment notNil and: [ desiredSegment includesIndex: anInteger ]) 				ifTrue: [ desiredSegment ]				ifFalse: [ nil ] ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/31/2006 13:59'!segmentSpanningKey: anInteger 	^ segments 		detect: [ : each | each isFitted and: [ anInteger <= each highestKey ] ]		ifNone: [ nil ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/15/2006 12:14'!segmentsAfter: aMagmaCollectionReaderSegment do: aBlock 	| foundIt |	foundIt _ false.	segments do: 		[ : each | 		foundIt ifTrue: [ aBlock value: each ].		each = aMagmaCollectionReaderSegment ifTrue: [ foundIt _ true ] ]! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 11/16/2004 22:57'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/18/2002 15:44'!session	^collection session! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 4/14/2005 23:09'!setUpListener	"Whenever aMagmaCollection changes, we need to remerge its changes in with me."	collection addDependent: self! !!MagmaCollectionReader methodsFor: 'accessing' stamp: 'cmm 6/5/2006 20:56'!size	"Retrieve the latest-known size from the server, regardless if I'm already loaded."	self refresh.	^ self lastKnownSize! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 7/4/2006 22:46'!sortBlock	^ self isDescending 		ifTrue: [ self sortIndex descendingSortBlock ]		ifFalse: [ self sortIndex ascendingSortBlock ]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 7/3/2006 23:21'!sortBy: attributeSymbol 	"Determine if I am already sorted by attributeSymbol and, if so, answer self immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me."	^ self 		sortBy: attributeSymbol		makeDistinct: false! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 8/8/2006 23:32'!sortBy: attributeSymbol makeDistinct: aBoolean 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately, but it is being sorted in the background."	^ (aBoolean not and: [ self isSorted and: [ self sortIndex attribute = attributeSymbol ] ]) 		ifTrue: [ self ]		ifFalse: 			[ self 				newReducedReaderOn: attributeSymbol				makeDistinct: aBoolean ]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 6/13/2006 17:08'!sortComplete	^ self fractionSorted = 1! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 8/6/2006 20:57'!sortIndexself maMarked: 'dev'."We can be more lazy here, ask the expression if hasDisjunctions to before fetching the trunk."	trunk ifNil: 		[ expression isSorted 			ifTrue: [ ^ self indexNamed: expression attribute ]			ifFalse: [ self isNewCollection ifTrue: [ ^ nil ] ].		trunk _ collection getTrunk: expression ].	^ trunk sortAttribute ifNotNilDo: [ : attribute | self indexNamed: attribute ]! !!MagmaCollectionReader methodsFor: 'sort' stamp: 'cmm 8/8/2006 23:33'!sortedBy: attributeSymbol makeDistinct: aBoolean 	"If I am already sorted by attributeSymbol and can allow duplicates, answer myself immediately.  Otherwise, create a new a new MagmaCollection with a single-index on attributeSymbol, containing only the objects in me.  Answer it immediately only after the sort has completed."	| answer |	answer _ self 		sortBy: attributeSymbol		makeDistinct: aBoolean.	[ answer sortComplete ] whileFalse: [ (Delay forMilliseconds: 400) wait ].	^ answer! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 11/16/2004 22:57'!species	^ OrderedCollection! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 7/18/2005 10:41'!stronglyReferencePage	| session |	session := self session.	(session notNil and:	[ session inTransaction and:	[ segment notNil ] ]) 		ifTrue:			[ session stronglyReference: segment objects ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 6/8/2006 16:09'!trunk: aMaQueryTrunk	trunk _ aMaQueryTrunk.	"Share aMaQueryTrunk among all my segments."	segment ifNotNil: [ segment trunk: aMaQueryTrunk ].	segments do: [ : each | each trunk: aMaQueryTrunk ]! !!MagmaCollectionReader methodsFor: 'private' stamp: 'cmm 8/2/2006 21:36'!update: addedOrRemovedSymbol	"My collection has had an object added or removed, I will now need to remerge its uncommitted contents into my segment."	self initializeSegments! !!MagmaCollectionReader methodsFor: 'enumerating' stamp: 'cmm 8/1/2006 21:29'!withIndexDo: elementAndIndexBlock 	| x |	x _ 0.	self do: 		[ : each | 		elementAndIndexBlock 			value: each			value: (x _ x + 1) ]! !!MagmaCommitConflict commentStamp: 'cmm 3/21/2003 00:50' prior: 0!When a MagmaCommitError is signaled, it will have a list of me in it so you can determine the cause of the conflict.  I describe what objects were in conflict (conflictingObjects) and who changed them (connection).conflictingObjects only reflects what is still in your image (e.g., not GC'd).  conflictingOids contains the oid of every object that was in conflict.!!MagmaCommitConflict class methodsFor: 'creation' stamp: 'cmm 7/5/2004 14:37'!connection: aMagmaClientConnection	^ self new		connection: aMagmaClientConnection ;		yourself! !!MagmaCommitConflict methodsFor: 'private' stamp: 'cmm 6/26/2002 00:00'!addConflictingOid: oidInteger	conflictingOids add: oidInteger! !!MagmaCommitConflict methodsFor: 'accessing' stamp: 'cmm 7/5/2004 14:40'!conflictingConnection	^ connection! !!MagmaCommitConflict methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:01'!conflictingObjects	^conflictingObjects! !!MagmaCommitConflict methodsFor: 'accessing' stamp: 'cmm 6/26/2002 00:01'!conflictingOids	^conflictingOids! !!MagmaCommitConflict methodsFor: 'initializing' stamp: 'cmm 7/5/2004 14:39'!connection: aMagmaClientConnection	connection _ aMagmaClientConnection! !!MagmaCommitConflict methodsFor: 'initializing' stamp: 'cmm 12/24/2002 15:52'!initialize	super initialize.	conflictingOids := OrderedCollection new! !!MagmaCommitConflict methodsFor: 'private' stamp: 'cmm 6/26/2002 22:46'!initializeConflictingObjectsUsing: aMaObjectSerializer	conflictingObjects _ OrderedCollection new.	conflictingOids 		do: 			[ :each | 			aMaObjectSerializer 				objectWithOid: each				ifFound: [ :foundObj | conflictingObjects add: foundObj ]				ifAbsent: [ "do nothing" ] ]! !!MagmaCompressionResult methodsFor: 'as yet unclassified' stamp: 'cmm 8/21/2002 21:44'!unreferencedClasses	^unreferencedClasses! !!MagmaCompressionResult methodsFor: 'as yet unclassified' stamp: 'cmm 8/21/2002 21:45'!unreferencedClasses: aCollection	unreferencedClasses _ aCollection! !!MagmaCompressionResult methodsFor: 'as yet unclassified' stamp: 'cmm 8/21/2002 21:45'!unreferencedMagmaCollections	^unreferencedMagmaCollections! !!MagmaCompressionResult methodsFor: 'as yet unclassified' stamp: 'cmm 8/21/2002 21:45'!unreferencedMagmaCollections: aCollection	unreferencedMagmaCollections _ aCollection! !!MagmaCompressor commentStamp: 'cmm 8/29/2002 22:35' prior: 0!I garbage collect a Magma repository and output a smaller file by eliminating buffers no longer referenced from the root buffer.I always create a new object file, but if you use compressAndRename, I'll rename the source files to 'old...' so you can get with using the compressed repository right away.If you don't want me to rename, just use #compressTo:.Oh, and I'm not meant to work while the files are on-line.  For that, use:	yourRepositoryController garbageCollect(Note:  a potential strategy for on-line GC would be to set a boolean flag indicating to the filer not to reuse buffers made available through grown objects, but rather to always add to the end.  During this time, a background thread can start reading from the root and build a new copy of the 'memory' map (the MaIntervalCollection).  Once it has accounted for every byte in the real memory map, we know the real one can be replaced with this new one.  Do a quick write of the new memory map and you're done!!)!!MagmaCompressor class methodsFor: 'creation' stamp: 'cmm 9/24/2004 16:49'!inputController: aMagmaRepositoryController	"NOT YET SUPPORTED.  The premise of this is that you can compress a running repository, but it is not complete.  Do not use!!"	^self new inputController: aMagmaRepositoryController! !!MagmaCompressor class methodsFor: 'creation' stamp: 'cmm 9/24/2004 16:49'!source: pathString	^self new sourceDirectory: (FileDirectory on: pathString)! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 2/28/2005 15:38'!buildClassIdMap	"This should normally not be necessary.  But if Magma has been modified where an object is added to the repository definition, it's possible the initial class ids will not match.  This method builds a map of oldId->newId used when we write the new buffers."	| inputClassMap outputClassMap |	classIdMap _ Dictionary new.	inputController requestCritical:		[ inputClassMap _ inputController definition classDefinitions copy.	outputClassMap _ outputController definition classDefinitions copy.	inputClassMap keysAndValuesDo:		[ : eachId : eachVersions |  | className |		className _ (inputClassMap at: eachId) last className.		"if output has consumed id for different class"		((outputClassMap includesKey: eachId)		and: [ (outputClassMap at: eachId) first className ~= eachVersions first className ])			ifTrue:				[ "try to find corresponding class-id in output, otherwise assign a new one."				classIdMap					at: eachId					put:						(outputClassMap							maDetect: [ : eachDefinitions | eachDefinitions last className = className ]							ifFound: [ : foundDefinitions | foundDefinitions last id ]							ifNone: [ self nextAvailableClassId ]) ] ] ].	classIdMap keysAndValuesDo:		[ :eachOld :eachNew |		MagmaNotification signal:			'converting classId ', eachOld printString, 			' to ', eachNew printString ]! !!MagmaCompressor methodsFor: 'compress' stamp: 'cmm 2/28/2005 12:18'!compressTo: outputDirectory	| shouldCloseInput |	shouldCloseInput _ inputController isNil.	inputController ifNil: [ self openInput ].	self		createOutput: outputDirectory;		openOutput: outputDirectory;		ensureNoOidReuse ;		buildClassIdMap;		copyPrimitiveAttributes;		writeGraphs ;		copyMagmaCollections.	outputController close.	self removeUnreferencedCollectionsAndClasses: outputDirectory.	shouldCloseInput ifTrue: [ inputController close ].	^result		unreferencedClasses: self unreferencedClasses;		unreferencedMagmaCollections: self unreferencedMagmaCollections;		yourself! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 6/14/2005 12:28'!copyMagmaCollections	inputController repository largeCollectionManagers do:		[ : each |		(referencedCollections includes: each collectionOid)			ifTrue:				[ each filenames do:					[ : eachMcFilename |					inputController directory						maCopyFileNamed: eachMcFilename						toDirectory: outputController directory ] ] ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 1/12/2005 21:13'!copyPrimitiveAttributes	| inputFiler outputFiler |	inputFiler _ inputController repository filer.	outputFiler _ outputController repository filer.	inputController requestCritical:		[ outputFiler			signature: inputFiler signature ;			"Even if this is a new version of Magma, the source buffers are still the old version."			version: inputFiler version ;			definitionOid: inputFiler definitionOid ;			classDefinitionsOid: inputFiler classDefinitionsOid ;			anchorOid: inputFiler anchorOid ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 9/24/2004 12:24'!createOutput: aString	MagmaRepositoryController create: aString! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 6/8/2005 20:06'!ensureNoOidReuse	"We can never allow an oid to be reused.  Once an object is created and persisted, its oid must be forever consumed.  Even if that object is later dereferenced, its oid will never be reused.  This is necessary to properly support universal-identity which is essential for MagmaForwardingProxys."	| highestOid |	"determine the next oid to be used in our inputController."	highestOid _ (inputController repository filer getNextOid) - 1.	"Force our output controller to allocate up to the current oid."	outputController repository filer		index: highestOid		at: 0! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'cmm 12/24/2002 15:51'!initialize	super initialize.	referencedClasses := Set new.	referencedCollections := Set new.	result := MagmaCompressionResult new! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'cmm 8/17/2002 15:25'!inputController: aMagmaRepositoryController	inputController _ aMagmaRepositoryController! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 5/2/2005 19:16'!markClassReferenced: aMaObjectBuffer 	| classIdManager |	classIdManager := inputController session serializer classIdManager.	(classIdManager 		definitionForClassId: aMaObjectBuffer classId		version: aMaObjectBuffer classVersion) 		withAllSuperclassDefinitionsDo: 			[ : eachClassDefinition | 			referencedClasses add: (self newClassIdFor: eachClassDefinition id) ].	"If a class-reference, be sure to get the referenced class itself."	(aMaObjectBuffer classId = (classIdManager idForClass: MaClassReference))		ifTrue:			[ | indexOfId classReferenceDefinition |			classReferenceDefinition _				classIdManager					definitionForClassId: aMaObjectBuffer classId					version: aMaObjectBuffer classVersion.			"Get the index of the 'id' variable."			indexOfId _ classReferenceDefinition allInstVarNames indexOf: 'id'.			indexOfId = 0 ifTrue: [ MagmaSoftwareError signal: 'Expected ''id'' variable.' ].			(classIdManager 				definitionForClassId:					(inputController session						objectWithOid: (aMaObjectBuffer maInstVarAt: indexOfId)						ifAbsent: [ MagmaSoftwareError signal: 'Expected an to find an id' ])				version: 1) 				withAllSuperclassDefinitionsDo: 					[ : eachClassDefinition | 					referencedClasses add: (self newClassIdFor: eachClassDefinition id) ] ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 8/22/2002 21:09'!markCollectionReferenced: oidInteger	referencedCollections add: oidInteger! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 7/2/2004 00:07'!newClassIdFor: sourceClassId	^ classIdMap at: sourceClassId ifAbsent: [ sourceClassId ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 7/1/2004 17:22'!nextAvailableClassId	"Answer the lowest commonly-available classId between the input and outputController."	^ inputController requestCritical:		[ | inputClassMap outputClassMap |		inputClassMap _ inputController definition classDefinitions.		outputClassMap _ outputController definition classDefinitions.		(inputClassMap keys max max: outputClassMap keys max) + 1 ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 9/24/2004 16:54'!openInput	inputController _ MagmaRepositoryController open: sourceDirectory pathName! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 8/14/2002 23:41'!openOutput: aString	outputController _ MagmaRepositoryController open: aString! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 2/23/2005 15:04'!removeUnreferencedCollectionsAndClasses: outputDirectory	| controller |	controller _ outputController privateOpen: (FileDirectory on: outputDirectory).	controller session commit:		[ controller definition classDefinitions copy			keysDo: 				[ :eachId |				(referencedClasses includes: eachId) ifFalse:					[ controller definition removeClassWithId: eachId ] ].		controller definition allLargeCollections copy do:			[ :eachCollection |			(referencedCollections includes: (controller session oidFor: eachCollection)) ifFalse:				[ controller definition removeCollection: eachCollection ] ] ].	controller close! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'cmm 9/24/2004 16:50'!sourceDirectory: aFileDirectory	sourceDirectory _ aFileDirectory! !!MagmaCompressor methodsFor: 'accessing' stamp: 'cmm 7/1/2004 23:35'!unreferencedClasses	^ outputController definition classDefinitions reject:		[ : eachDefinitions |		referencedClasses includes: eachDefinitions first id ]! !!MagmaCompressor methodsFor: 'accessing' stamp: 'cmm 7/12/2005 12:58'!unreferencedMagmaCollections	| unreferenced |	unreferenced _ inputController definition allLargeCollections reject: [ :each | referencedCollections includes: (inputController session oidFor: each) ].	^ unreferenced collect: 		[ : eachCollection | inputController repository collectionFilenameFor: eachCollection ]! !!MagmaCompressor methodsFor: 'private' stamp: 'cmm 7/13/2005 17:17'!writeGraphs	| inputTraverser |	inputTraverser _ MagmaFileTraverser repositoryController: inputController.	inputTraverser anchorGraphDo:		[ : eachBuffer |		self markClassReferenced: eachBuffer.		inputTraverser inDefinition ifFalse:			[ (inputTraverser isOidForLargeCollection: eachBuffer oid)				ifTrue:					[ self markCollectionReferenced: eachBuffer oid ] ].		eachBuffer classId: (self newClassIdFor: eachBuffer classId).		"If not in a buffer embedded in a MaStorageObjectBuffer..."		(MaOidCalculator isOidForUserObject: eachBuffer oid)			ifTrue:				[ outputController requestCritical:					[ outputController repository filer						write: eachBuffer						index: true ;						filesDo: [ : eachFile : eachFileId | eachFile maCommit ] ] ] ]! !!MagmaEvent class methodsFor: 'as yet unclassified' stamp: 'cmm 2/25/2005 12:51'!session: aMagmaSession	^ self new		session: aMagmaSession ;		yourself! !!MagmaEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 14:29'!session	"Answer the value of session"	^ session! !!MagmaEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 14:29'!session: anObject	"Set the value of session"	session _ anObject! !!MagmaMaterializationEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 13:59'!buffer	"Answer the value of buffer"	^ buffer! !!MagmaMaterializationEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 13:59'!buffer: anObject	"Set the value of buffer"	buffer _ anObject! !!MagmaMaterializationEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 13:59'!object	"Answer the value of object"	^ object! !!MagmaMaterializationEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 13:59'!object: anObject	"Set the value of object"	object _ anObject! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!buffer	"Answer the value of buffer"	^ buffer! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!buffer: anObject	"Set the value of buffer"	buffer _ anObject! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 13:44'!hasRestoreData	^ restoreData notNil! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!object	"Answer the value of object"	^ object! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!object: anObject	"Set the value of object"	object _ anObject! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!restoreData	"Answer the value of restoreData"	^ restoreData! !!MagmaRefreshEvent methodsFor: 'accessing' stamp: 'cmm 2/25/2005 12:51'!restoreData: anObject	"Set the value of restoreData"	restoreData _ anObject! !!MagmaFileTraverser commentStamp: 'cmm 8/5/2002 21:45' prior: 0!I walk the object buffers of an open Magma file and execute a Block for each buffer.I'm useful for the Magma garbage collection function, the compression function and for general purpose information gathering about what's in the repository.!!MagmaFileTraverser class methodsFor: 'creation' stamp: 'cmm 9/24/2004 15:56'!for: pathString	^ self new 		directory: (FileDirectory on: pathString) ;		yourself! !!MagmaFileTraverser class methodsFor: 'creation' stamp: 'cmm 8/15/2002 22:52'!repositoryController: aMagmaRepositoryController	^self new repositoryController: aMagmaRepositoryController! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 5/2/2005 10:37'!anchorGraphDo: aBlock	self		graphFrom: (repositoryController requestCritical: [ self repository filer anchorOid ])		do: aBlock! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 8/21/2002 00:24'!close	repositoryController ifNotNil:		[ repositoryController requestCritical: [ repositoryController close ] ]! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/24/2004 16:15'!deleteOidsVisited	oidsVisited ifNotNil: [ oidsVisited close ].	directory deleteFileNamed: self tempOidsVisitedFilename! !!MagmaFileTraverser methodsFor: 'actions' stamp: 'cmm 5/2/2005 10:37'!graphFrom: oid do: aBlock	"Value aBlock against every buffer in the receivers file."	| readStrategy shouldClose |	shouldClose _ false.	repositoryController ifNil: [ shouldClose _ true. self open ].	readStrategy _ MaBasicReadStrategy minimumDepth: 0.	MagmaNotification signal: 'Beginning traversal of ', oid printString, ' of ', directory pathName.	graphBuffer _ repositoryController session serializer graphBuffer copy resetBufferSize; yourself.  "sorry Demeter"	[ self initializeOidsVisited.	self		graphFrom: oid		do: aBlock		using: readStrategy ]		ensure:			[ shouldClose ifTrue: [ self close ].			self deleteOidsVisited ].	MagmaNotification signal: 'Traversal of ', oid printString, ' of ', directory pathName, ' complete.'! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 5/2/2005 10:36'!graphFrom: oidInteger do: oneArgBlock using: aMaReadStrategy	| buffer indexPosition |	(MaOidCalculator isOidForUserObject: oidInteger) ifFalse: [ ^self ].	indexPosition _ MaOidCalculator indexPositionForOid: oidInteger.	(oidsVisited at: indexPosition ifAbsent: [ 0 ]) = 0 ifFalse: [ ^self ].	"Don't enumerate the MagmaCollections referenced from the definition, just the ones referenced from the root, that way we can properly calculate which MagmaCollections are still referenced and which are not."	(inDefinition and: [ self isOidForLargeCollection: oidInteger ])		ifFalse:			[ oidsVisited				at: indexPosition				put: oidInteger ].	repositoryController requestCritical:		[ buffer _ self repository filer			appendObject: oidInteger			into: graphBuffer ].	oneArgBlock value: buffer.	(buffer oid = repositoryController repository filer definitionOid) 		ifTrue: [ inDefinition _ true ].	buffer		graphDo: oneArgBlock		using: aMaReadStrategy		for: self		inDefinition: inDefinition.	buffer oid = repositoryController repository filer definitionOid		ifTrue: [ inDefinition _ false ].	graphBuffer decreaseBufferSizeBy: buffer physicalSize! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 6/14/2005 17:29'!graphFromLargeCollection: oidInteger do: oneArgBlock using: aMaReadStrategy	"aMaByteObjectBuffer is for a storageObject.  Therefore enumerate its buffers because its objects are part of the repository too."	| fileIndex |	fileIndex _ (repositoryController 		requestCritical: 			[ repositoryController repository collectionManagerFor: oidInteger ]) memberIndex.	MagmaNotification signal: 'beginning enumeration of ', fileIndex size printString, ' objects in MagmaCollection ', oidInteger printString.	fileIndex		do: oneArgBlock		for: self		using: aMaReadStrategy.	MagmaNotification signal: 'MagmaCollection enumeration complete:  ', oidInteger printString! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 5/2/2005 12:04'!graphFromPointers: aMaObjectBuffer do: oneArgBlock using: aMaReadStrategy	"aMaObjectBuffer isPointers must be true to get here."	aMaObjectBuffer instVarsDoWithIndex:		[ :eachOid :index |		self			graphFrom: eachOid			do: oneArgBlock			using: aMaReadStrategy ]! !!MagmaFileTraverser methodsFor: 'testing' stamp: 'cmm 2/28/2005 13:40'!inDefinition	"Answer whether I am currently traversing inside my input-controller's repository-definition."	^ inDefinition! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 2/28/2005 13:40'!initialize	super initialize.	inDefinition _ false! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 7/12/2005 23:43'!initializeOidsVisited	oidsVisited ifNotNil: [ self deleteOidsVisited ].	oidsVisited _ 		MaLargeArrayOfNumbers			createNamed: self tempOidsVisitedFilename			bitSize: MaObjectFiler maxDbSize! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 3/22/2005 17:55'!isOidForLargeCollection: oidInteger	^ self repository largeCollectionManagers includesKey: oidInteger! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/24/2004 15:52'!open	"Use if you created with just a path, or if you know the MagmaRepositoryController needs opened.."	repositoryController _ MagmaRepositoryController open: directory pathName! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 8/13/2002 23:29'!repository	^repositoryController repository! !!MagmaFileTraverser methodsFor: 'accessing' stamp: 'cmm 1/19/2005 21:36'!repositoryController	^ repositoryController! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/24/2004 15:54'!repositoryController: aMagmaRepositoryController	repositoryController _ aMagmaRepositoryController.	directory _ aMagmaRepositoryController directory! !!MagmaFileTraverser methodsFor: 'private' stamp: 'cmm 9/26/2004 21:30'!tempOidsVisitedFilename	^ repositoryController directory fullNameFor: 'oidsVisited.tmp'! !!MagmaId methodsFor: 'testing' stamp: 'cmm 4/10/2005 18:00'!= aMagmaId 	self == aMagmaId ifTrue: [^true].	aMagmaId maOriginalClass = self species ifFalse: [^false].	^uuid = aMagmaId uuid! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:34'!contact	"If having trouble connecting to this repository."	^ contact! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 5/2/2005 22:00'!contact: aString	"Specify information on how to contact the person who maintains this repository."	contact _ aString! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:34'!description	"About this repository."	^ description! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:35'!description: aString	"A description of this repository."	description _ aString! !!MagmaId methodsFor: 'testing' stamp: 'cmm 1/16/2005 22:24'!hash	^ uuid hash! !!MagmaId methodsFor: 'initialize-release' stamp: 'cmm 5/2/2005 22:13'!initialize	super initialize.	uuid := UUID new.	name := uuid asString36! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/17/2005 13:52'!location	"The last known location of this repository."	^ location! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/17/2005 13:52'!location: aMagmaLocation	"The last known location of this repository."	location _ aMagmaLocation! !!MagmaId methodsFor: 'printing' stamp: 'cmm 1/17/2005 17:42'!maPrintAbbreviatedOn: aStream	self maPrintAttribute: #uuid on: aStream! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:35'!name	"How people refer to this repository."	^ name! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 22:36'!name: aString	name _ aString! !!MagmaId methodsFor: 'session' stamp: 'cmm 1/17/2005 17:15'!session	^ MagmaSession connectedSessions		detect: [ : each | each magmaId = self ]		ifNone: [ location newSession ]! !!MagmaId methodsFor: 'accessing' stamp: 'cmm 1/13/2005 10:35'!uuid	^ uuid! !!MagmaArray commentStamp: 'cmm 4/13/2005 15:21' prior: 0!I can be used like a normal Array up to ~250,000,000 objects and only consume memory for one "page" at a time (defined by #pageSize).I do not have to be pre-allocated.  You can use at:put: to any size up to the limit.  Once I grow, I don't shrink though; and size of my >   u  Àÿÿo>     Àÿÿp>   {>   F>   |>   }>   ~>   >   >   >        UUID     \    q>     Àÿÿr>     Àÿÿ*>   s>   F>   t>   u>   v>   w>   > !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/13/2005 15:18'!at: anIndex	^ self		at: anIndex		ifAbsent: [ self error: 'index out of range' ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/30/2006 20:07'!at: anInteger ifAbsent: aBlock 	^ (self isLoaded and: [ segment includesIndex: anInteger ]) 		ifTrue: [ segment at: anInteger ]		ifFalse: 			[ | size |			size _ self lastKnownSize.			changes 				at: anInteger				ifAbsent: 					[ self isNewCollection 						ifTrue: 							[ anInteger < size 								ifTrue: [ nil ]								ifFalse: [ aBlock value ] ]						ifFalse: 							[ self loadFromIndex: anInteger.							(segment includesIndex: anInteger) 								ifTrue: [ segment at: anInteger ]								ifFalse: 									[ anInteger < size 										ifTrue: [ nil ]										ifFalse: [ aBlock value ] ] ] ] ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/18/2005 13:21'!at: anInteger put: anObject	changes		add: anObject		at: anInteger.	^ anObject! !!MagmaArray methodsFor: 'enumerate' stamp: 'cmm 7/30/2006 19:39'!do: aBlock 	1 		to: self size		do: [ : x | aBlock value: (self at: x) ]! !!MagmaArray methodsFor: '*magma server' stamp: 'cmm 7/12/2005 12:52'!implementationClass	^ MaLargeArrayOfNumbers! !!MagmaArray methodsFor: 'do not use' stamp: 'cmm 3/21/2005 12:37'!includes: anObject	"This should not be used because, being large and non-indexed, would be a performance drain.  If you need this, you should probably use a regular MagmaCollection."	self shouldNotImplement! !!MagmaArray methodsFor: 'initialize' stamp: 'cmm 3/22/2005 12:40'!initialize	super initialize.	self pageSize: 125! !!MagmaArray methodsFor: 'initialize' stamp: 'cmm 3/17/2005 21:43'!initializeChanges	changes _ MagmaArrayChanges collection: self! !!MagmaArray methodsFor: 'private' stamp: 'cmm 3/21/2005 12:36'!isLoaded	^ segment notNil! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/30/2006 20:06'!lastKnownSize	^ segment 		ifNil: [ self size ]		ifNotNil: [ segment lastKnownSize max: changes maxIndex ]! !!MagmaArray methodsFor: 'private' stamp: 'cmm 5/1/2005 16:43'!loadFromIndex: indexInteger	segment _		self			segmentFromIndex: indexInteger			pageSize: pageSize			using: (session ifNotNil: [ session resetReadStrategy ])! !!MagmaArray methodsFor: 'private' stamp: 'cmm 3/19/2005 11:25'!maTransientVariables 	"Large-collection changes are processed separately in the server, therefore they are stored separately in the commit-package, therefore, we mark them transient."	^ super maTransientVariables, #( 'segment' )! !!MagmaArray methodsFor: '*magma server' stamp: 'cmm 3/17/2005 21:33'!newManagerUsing: aMaObjectRepository	^ MagmaArrayManager		collection: self		repository: aMaObjectRepository! !!MagmaArray methodsFor: 'do not use' stamp: 'cmm 3/21/2005 12:38'!occurrencesOf: anObject	"This should not be used because, being large and non-indexed, would be a performance drain.  If you need this, you should probably use a regular MagmaCollection."	self shouldNotImplement! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:30'!pageSize	^ pageSize! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 3/21/2005 12:30'!pageSize: anInteger	pageSize _ anInteger! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 7/30/2006 20:07'!refresh	segment _ nil! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:15'!size	^ session isNil		ifTrue:			[ changes maxIndex ]		ifFalse:			[ (session sizeOfLargeCollection: self) max: changes maxIndex ]! !!MagmaArray methodsFor: 'accessing' stamp: 'cmm 4/12/2005 17:24'!species	^ OrderedCollection! !!MagmaCollection class methodsFor: 'as yet unclassified' stamp: 'cmm 1/9/2005 14:57'!initialize	super initialize.	(Smalltalk hasClassNamed: #MauiRegistry)		ifTrue:			[ (Smalltalk at: #MauiRegistry) global				register: (Smalltalk at: #MauiCollectionMorph)				forAny: self ]				! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 4/15/2005 16:17'!add: anObject	self validateCanAdd: anObject.	changes		add: anObject		at: (indexes collect: [ :each | each indexHashesFor: anObject ]).	self changed: #added.	^ anObject! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 7/6/2006 22:39'!addAll: aCollection	aCollection do: [ : each | self add: each ].	^ aCollection! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 5/31/2005 13:33'!addIndex: aMaIndexDefinition	(self hasIndexNamed: aMaIndexDefinition attribute)		ifTrue:			[ MagmaUserError signal: 'You already have an index on ', aMaIndexDefinition attribute ].	self lock.	indexes add: aMaIndexDefinition.	changes addIndex: aMaIndexDefinition! !!MagmaCollection methodsFor: 'converting' stamp: 'cmm 7/31/2006 15:27'!asArray: anInteger	| answer x size |	answer _ Array new: ((size _ self size) min: anInteger).	x _ 1.	self		maDo: [ : each | answer at: x put: each. x _ x + 1 ]		while: [ x <= size ].	^ answer! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/17/2006 10:26'!buildIndexes: aCollection ignoring: objectOidsAlreadyIndexed 	"aCollection of MaIndexDefinitions."	MagmaNotification signal: 'About to build ' , aCollection size printString , ' indexes.'.	session begin.	self 		slowlyDo: 			[ : each | 			| oid |			oid _ session oidFor: each.			(MaOidCalculator isOidForNewObject: oid) ifTrue: [ MagmaSoftwareError signal: 'expected a persistent object' ].			(objectOidsAlreadyIndexed includes: oid) ifFalse: 				[ aCollection do: 					[ : eachIndex | 					changes 						add: each						at: (eachIndex indexHashesFor: each)						toIndexForAttribute: eachIndex attribute ] ] ]		pageBoundariesDo: [ session commitAndBegin ].	session commit.	self commitUnlock.	MagmaNotification signal: 'Indexes built.'! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 7/31/2002 00:15'!canAdd: anObject	^self canIndex: anObject! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 2/22/2004 19:21'!canIndex: anObject	^indexes allSatisfy: [ :each | each canIndex: anObject ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:44'!commitUnlock	[ session commit: [ self unlock ] ]		on: MagmaCommitError		do:			[ :error |			error messageText:				error messageText,				'Abnormal condition.  The enumeration completed, but your session was unable to unlock the collection.  No one can update the collection until it is unlocked.  ' ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 7/26/2006 20:26'!fractionLoaded	^ self isNewCollection 		ifTrue: [ 1 ]		ifFalse: [ session fractionLoaded: self ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 8/6/2006 20:55'!getTrunk: aMaTerm 	^ session 		getTrunkFor: self		expression: aMaTerm! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 5/31/2005 13:31'!hasIndexNamed: attributeSymbol	^ indexes anySatisfy: [ : each | each attribute = attributeSymbol ]! !!MagmaCollection methodsFor: '*magma server' stamp: 'cmm 7/12/2005 12:52'!implementationClass	^ MaHashIndex! !!MagmaCollection methodsFor: 'testing' stamp: 'cmm 12/7/2004 13:44'!includes: anObject	(changes includesObject: anObject) ifTrue: [ ^true ].	session isNil ifTrue: [ ^false ].	^(self occurrencesOf: anObject) > 0! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 2/1/2005 22:49'!indexNamed: attributeSymbol	^indexes		detect: [ :each | each attribute = attributeSymbol ]		ifNone: [ MagmaUserError signal: attributeSymbol , ' is not an indexed attribute' ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/18/2002 15:05'!indexes	^indexes! !!MagmaCollection methodsFor: 'enumerating' stamp: 'cmm 10/1/2004 14:43'!indexesDo: aBlock	indexes do: aBlock! !!MagmaCollection methodsFor: 'initializing' stamp: 'cmm 3/15/2005 23:31'!initialize	super initialize.	indexes _ OrderedCollection new! !!MagmaCollection methodsFor: 'initializing' stamp: 'cmm 3/17/2005 21:41'!initializeChanges	changes _ MagmaCollectionChanges collection: self! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/31/2006 12:50'!load: aMagmaCollection from: aMagmaCollectionReader makeDistinct: aBoolean 	aMagmaCollection changes reset.	changes additionsDo: 		[ : eachObject : eachHash | 		(aMagmaCollectionReader expression evaluate: eachObject) ifTrue: [ aMagmaCollection add: eachObject ] ].	changes removedDo: 		[ : eachObject : eachHash | 		(aMagmaCollectionReader expression evaluate: eachObject) ifTrue: [ aMagmaCollection remove: eachObject ] ].	session 		load: aMagmaCollection		from: aMagmaCollectionReader		makeDistinct: aBoolean! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:21'!lock	changes setLocked: true! !!MagmaCollection methodsFor: '*magma server' stamp: 'cmm 3/17/2005 21:31'!newManagerUsing: aMaObjectRepository	^ (MagmaCollectionManager		collection: self		repository: aMaObjectRepository)			oidOfIndexesCollection: (aMaObjectRepository session oidFor: self indexes) ;			yourself! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 12/7/2004 13:44'!occurrencesOf: anObject	| newOccurrences |	newOccurrences _ changes occurrencesOf: anObject.	(session isNil or:		[ (session isPersistent: anObject) not or: [ (session isPersistent: self) not ] ])			ifTrue:				[ ^newOccurrences ].	^(session		occurrencesOf: anObject		in: self) + newOccurrences! !!MagmaCollection methodsFor: 'accessing' stamp: 'brp 7/18/2006 20:11'!read: attributeSymbol	"Answers a MaLargeCollectionReader ordered on attributeSymbol"	^ self read: attributeSymbol descending: false! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 8/18/2006 00:19'!read: attributeSymbol descending: aBoolean	"Answers a MaLargeCollectionReader ordered on attributeSymbol"	| index reader |	index := self indexNamed: attributeSymbol.	reader := MagmaCollectionReader new		collection: self;		readStrategy: (session ifNotNil: [ session resetReadStrategy ]) ;		yourself.	reader		readIndex: index		fromHash: index lowestPossibleKey		toHash: index highestPossibleKey.	reader descending: aBoolean.	^ reader! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 7/30/2006 10:45'!refreshSegment: aMagmaCollectionReaderSegment where: aMaTerm pageSize: anInteger using: aMaReadStrategy loadObjects: aBoolean 	"Answer a MagmaCollectionSegment."	self isNewCollection 		ifTrue: 			[ changes 				refreshSegment: aMagmaCollectionReaderSegment				where: aMaTerm ]		ifFalse: 			[ "if refreshing the local 'segment' it will have its old page of objects, clear it out."			aMagmaCollectionReaderSegment initializeObjects.			session 				refreshSegment: aMagmaCollectionReaderSegment				of: self				where: aMaTerm				pageSize: anInteger				using: aMaReadStrategy				loadObjects: aBoolean ]! !!MagmaCollection methodsFor: 'add / remove' stamp: 'cmm 4/15/2005 16:18'!remove: anObject	changes		remove: anObject		at: (indexes collect: [ :each | each indexHashesFor: anObject ]).	self changed: #removed.	^ anObject! !!MagmaCollection methodsFor: 'indexing' stamp: 'cmm 5/31/2005 13:32'!removeIndexNamed: attributeSymbol	self lock.	changes removeIndexNamed: attributeSymbol.	indexes remove: (indexes detect: [ :each | each attribute = attributeSymbol ])! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:14'!size	^ session isNil		ifTrue:			[ changes deltaSize ]		ifFalse:			[ (session sizeOfLargeCollection: self) + changes deltaSize ]! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 11/16/2004 23:09'!species	^ Bag! !!MagmaCollection methodsFor: 'private' stamp: 'cmm 12/7/2004 13:22'!unlock	changes setLocked: false! !!MagmaCollection methodsFor: 'validating' stamp: 'cmm 2/1/2005 23:48'!validateCanAdd: anObject	(self canIndex: anObject) ifFalse: [		MagmaUserError signal:			anObject printString , ' cannot be added to ' , self printString ,			' because it does not support all of the indexable attributes.' ]! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 4/14/2006 15:32'!where: aBlock 	| reader |	reader _ MagmaCollectionReader new		collection: self ;		readStrategy: (session ifNotNil: [ session resetReadStrategy ]) ;		yourself.	aBlock value: reader.	^ reader normalize; yourself! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 8/8/2006 11:07'!where: aBlock distinct: makeDistinct sortBy: attributeSymbol descending: shouldDescend 	^ ((self where: aBlock)		sortBy: attributeSymbol makeDistinct: makeDistinct)		descending: shouldDescend ;		yourself! !!MagmaCollection methodsFor: 'accessing' stamp: 'cmm 8/7/2006 22:06'!where: aBlock distinct: makeDistinct sortedBy: attributeSymbol descending: shouldDescend 	| answer |	answer _ self 		where: aBlock		distinct: makeDistinct		sortBy: attributeSymbol		descending: shouldDescend.	[ answer sortComplete ] whileFalse: [ (Delay forMilliseconds: 400) wait ].	^ answer! !!MagmaSet commentStamp: '<historical>' prior: 0!Implement simple Set functionality for MagmaCollections.!!MagmaSet class methodsFor: 'create' stamp: 'cmm 7/18/2006 22:35'!equivalenceAttributes: anArray	"anArray specifies the attributes to optimize the lookup for equivalent objects."	^ self new		equivalenceAttributes: anArray ;		yourself! !!MagmaSet methodsFor: 'add / remove' stamp: 'cmm 2/2/2005 22:06'!add: anObject	self validateCanAdd: anObject.	changes		add: anObject		at: (indexes collect: [ :each | each indexHashesFor: anObject ]).	^ anObject! !!MagmaSet methodsFor: 'initializing' stamp: 'cmm 7/18/2006 21:41'!equivalenceAttributes: anArray 	"Optimize my searches for equivalence objects by specifying which of my indexes can be used to minimize the set of unique instances."	equivalenceAttributes _ anArray! !!MagmaSet methodsFor: 'testing' stamp: 'cmm 7/18/2006 21:43'!equivalentOf: anObject 	"Answer the object in me equivalent to anObject."	| reader |	equivalenceAttributes isEmpty ifTrue: 		[ MagmaUserError signal: 'MagmaSets are not practical without at least one equivalenceAttribute defined.' ].	(changes includesObject: anObject) ifTrue: [ ^ anObject ].	self isNewCollection ifTrue: [ ^ nil ].	(self canIndex: anObject) ifFalse: [ ^ nil ].	reader _ self where: 		[ : rdr | 		| nextTerm attr |		attr _ equivalenceAttributes first.		nextTerm _ rdr 			read: attr			at: (anObject perform: attr).		(equivalenceAttributes copyWithout: equivalenceAttributes first) do: [ : each | nextTerm & (rdr 					read: each					at: (anObject perform: each)) ] ].	^ reader 		detect: [ : each | each = anObject ]		ifNone: [ nil ]! !!MagmaSet methodsFor: 'testing' stamp: 'cmm 7/12/2006 23:48'!includes: anObject 	^ (self equivalentOf: anObject) notNil! !!MagmaSet methodsFor: 'initializing' stamp: 'cmm 8/16/2006 22:29'!initialize	super initialize.	equivalenceAttributes _ #()! !!MagmaSet methodsFor: 'add / remove' stamp: 'cmm 7/12/2006 23:48'!remove: anObject .	^ (self equivalentOf: anObject)		ifNotNilDo: [: equivalent | super remove: equivalent ]		ifNil: 			[ MagmaEquivalentObjectNotInCollection signal: anObject printString , ' is not in ' , self printString ]! !!MagmaSet methodsFor: 'validating' stamp: 'cmm 7/9/2006 23:18'!validateCanAdd: anObject 	(self includes: anObject) 		ifTrue: 			[ MagmaDuplicateObjectInCollection signal: anObject printString , ' cannot be added to ' , self printString ]		ifFalse: [ super validateCanAdd: anObject ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:05'!allSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 3/15/2005 23:09'!anyOne	^ self detect: [ : each | true ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!MagmaLargeCollection methodsFor: 'converting' stamp: 'brp 7/5/2005 10:05'!asArray	| all |	all := OrderedCollection new: self size.	self do: [ :each | all add: each ].	^ all asArray! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/17/2005 21:14'!canIndex: anObject	^ false! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/17/2005 20:57'!changes	^ changes! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum _ 0.	self do: [:each | (aBlock value: each) ifTrue: [sum _ sum + 1]].	^ sum! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val _ aBlock value: each) > maxValue ifTrue: [					maxElement _ each.					maxValue _ val]]			ifTrue: ["first element"				maxElement _ each.				maxValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:06'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val _ aBlock value: each) < minValue ifTrue: [					minElement _ each.					minValue _ val]]			ifTrue: ["first element"				minElement _ each.				minValue _ aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 7/16/2006 14:27'!do: oneArgBlock 	self 		slowlyDo: oneArgBlock		pageBoundariesDo: [  ]! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 7/17/2006 00:16'!enumerationPageSize	^ 500! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!errorNotFound: anObject	MagmaUserError signal: 'Object is not in the collection.'! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'brp 4/5/2005 10:52'!errorNotPersistent	MagmaUserError signal: 'Not supported for non-persistent collections.'! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 4/12/2005 17:26'!ifEmpty: aBlock	"Evaluate the block if I'm empty"	^ self isEmpty ifTrue: aBlock! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 15:22'!ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	^ self isEmpty ifTrue: emptyBlock ifFalse: [notEmptyBlock valueWithPossibleArgument: self]! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 15:23'!ifNotEmpty: aBlock	"Evaluate the given block unless the receiver is empty.      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	^self isEmpty ifFalse: [aBlock valueWithPossibleArgument: self].! !!MagmaLargeCollection methodsFor: 'indexes' stamp: 'cmm 3/16/2005 13:59'!indexesDo: aBlock	"Some large-collections do not require indexes.  Do nothing by default."! !!MagmaLargeCollection methodsFor: 'initialize' stamp: 'cmm 4/11/2005 14:20'!initialize	super initialize.	self initializeChanges.	changes beNewCollection! !!MagmaLargeCollection methodsFor: 'override' stamp: 'cmm 3/17/2005 21:43'!initializeChanges	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue _ thisValue.	self do: [:each | nextValue _ binaryBlock value: nextValue value: each].	^nextValue! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:07'!intersection: aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:each | aCollection includes: each]! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/15/2005 23:12'!isEmpty	^self size = 0! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'brp 4/5/2005 11:23'!isNewCollection	^ changes isNewCollection! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/28/2005 16:01'!maAllowsWriteBarrier 	"My changes are tracked through the MagmaLargeCollectionChanges mechanism."	^ false! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:12'!maDo: aBlock while: conditionBlock	conditionBlock value ifFalse: [ ^ self ].	self do:		[ : each |		aBlock value: each.		conditionBlock value ifFalse: [ ^ self ] ]! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/16/2005 12:37'!maIsLargeCollection	^ true! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/19/2005 10:16'!maTransientVariables 	"Large-collection changes are processed separately in the server, therefore they are stored separately in the commit-package, therefore, we mark them transient."	^ super maTransientVariables, #( 'session' 'changes' )! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/17/2005 21:29'!maWantsPostMaterialization	"Needed to initialize my changes."	^ true! !!MagmaLargeCollection methodsFor: '*magma server' stamp: 'cmm 3/16/2005 12:53'!newManagerUsing: aMagmaSession	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!noneSatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!MagmaLargeCollection methodsFor: 'testing' stamp: 'cmm 3/15/2005 23:26'!notEmpty	^self isEmpty not! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!reject: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:element | (aBlock value: element) == false]! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 4/29/2005 12:51'!segmentFromIndex: startIndex pageSize: anInteger	"Answer a MaCollectionSegment."	^ self		segmentFromIndex: startIndex		pageSize: anInteger		using: (session ifNotNil: [session resetReadStrategy])! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 7/30/2006 13:55'!segmentFromIndex: startIndex pageSize: anInteger using: aMaReadStrategy 	"Answer a MaCollectionSegment."	^ self isNewCollection 		ifTrue: [ changes localSegment ]		ifFalse: 			[ session 				upTo: anInteger				objectsIn: self				fromIndex: startIndex				using: aMaReadStrategy ]! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 3/15/2005 23:08'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:25'!session	^ session! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:25'!session: aMagmaSession	session _ aMagmaSession! !!MagmaLargeCollection methodsFor: 'private' stamp: 'cmm 3/15/2005 23:26'!setOid: anInteger	changes collectionOid: anInteger! !!MagmaLargeCollection methodsFor: 'accessing' stamp: 'cmm 4/13/2005 12:14'!size	self subclassResponsibility! !!MagmaLargeCollection methodsFor: 'enumerating (slow)' stamp: 'cmm 7/30/2006 21:58'!slowlyDo: oneArgBlock pageBoundariesDo: aBlock 	"Unlike other slowlyDo: methods, this method does not lock me, so while you can get a large 'sampling', if the collection is changed while I'm enumerating, there's no guarantee you'll reach every element."	| segment done index nextSignalTime |	done _ false.	index _ 1.	nextSignalTime _ Time millisecondClockValue + 5000.	self isNewCollection ifFalse: 		[ changes additionsDo: [ : eachObject : eachHashes | oneArgBlock value: eachObject ] ].	[ done ] whileFalse: 		[ segment _ self 			segmentFromIndex: index			pageSize: self enumerationPageSize.		segment objects do: 			[ : each | 			(changes hasRemoved: each) ifFalse: [ oneArgBlock value: each ].			Time millisecondClockValue > nextSignalTime ifTrue: 				[ MagmaNotification signal: (index - 1) printString , ' objects enumerated.'.				nextSignalTime _ Time millisecondClockValue + 5000 ].			aBlock value ].		index _ index + segment actualPageSize.		done _ segment atEnd ]! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 3/18/2005 13:30'!add: anObject at: indexOrKey	self added		at: indexOrKey		put: anObject! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 3/18/2005 14:02'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self additionsDo:		[ : eachIndex : eachObject |		(aMagmaSession isPersistent: eachObject) ifFalse: [ aMaCommitPackage addObject: eachObject ] ]! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 3/24/2005 17:36'!at: anIndex ifAbsent: aBlock	self hasAdditions ifFalse: [ ^ aBlock value ].	^ self added		at: anIndex		ifAbsent: aBlock! !!MagmaArrayChanges methodsFor: 'testing' stamp: 'cmm 3/20/2005 20:57'!isForMagmaArray	^ true! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 7/30/2006 14:10'!localSegment	"Populate a segment from the uncommitted changes."	| matching |	matching _ OrderedCollection new.	self additionsDo: [ : index : object | matching add: object ].	^ MagmaCollectionSegment new		lastKnownSize: matching size ;		objects: matching ;		startIndex: 1 ;		yourself! !!MagmaArrayChanges methodsFor: 'overriding' stamp: 'cmm 4/13/2005 12:13'!maxIndex	^ self hasAdditions		ifTrue: [ self added keys max ]		ifFalse: [ 0 ]! !!MagmaArrayChanges methodsFor: 'serializing' stamp: 'cmm 3/18/2005 13:47'!serializeAddedUsing: aMaObjectSerializer	| added |	self hasAdditions ifFalse: [ ^self ].	(added _ self added) keysAndValuesDo: 		[ : eachIndex : eachObject |		added			at: eachIndex			put: (aMaObjectSerializer oidFor: eachObject) ]! !!MagmaCollectionChanges commentStamp: '<historical>' prior: 0!This is a private class.  Applications should have no need to use this class directly.!!MagmaCollectionChanges methodsFor: 'added' stamp: 'cmm 3/16/2005 11:32'!add: anObject at: hashIndexValuesOrArrayIndex	| removed |	((removed _ self removed) includesKey: anObject)		ifTrue:			[ removed removeKey: anObject ]		ifFalse:			[ self added				at: anObject				put: hashIndexValuesOrArrayIndex ]! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 12/9/2002 20:19'!add: anObject at: indexHashValues toIndexForAttribute: aSymbol	(self newIndexValues		at: aSymbol		ifAbsentPut: [ OrderedCollection new ])			add: (				Association					key: indexHashValues					value: anObject)! !!MagmaCollectionChanges methodsFor: 'added indexes'!addIndex: aMaIndexDefinition	self hasRemovedIndexes		ifTrue:			[ (self removedIndexes includes: aMaIndexDefinition attribute)				ifTrue:					[ self removedIndexes remove: aMaIndexDefinition attribute ]				ifFalse:					[ self addedIndexes add: aMaIndexDefinition ] ]		ifFalse:			[ self addedIndexes add: aMaIndexDefinition ].	self appendIndexValuesFor: aMaIndexDefinition! !!MagmaCollectionChanges methodsFor: 'overriding' stamp: 'cmm 3/18/2005 14:01'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self additionsDo:		[ :eachObject :eachHashIndexValues |		(aMagmaSession isPersistent: eachObject) ifFalse: [ aMaCommitPackage addObject: eachObject ] ]! !!MagmaCollectionChanges methodsFor: 'added indexes'!addedIndexes	^changes		at: #addedIndexes		ifAbsentPut: [ OrderedCollection new ]! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 12/9/2002 20:21'!appendIndexValuesFor: aMaIndexDefinition	"An index has been added.  Since the server processes all added and removed indexes prior to all added and removed objects, we need to make sure additions and removals have hash-index values for all indexes."	self additionsDo:		[ :eachObject :eachCollection |		eachCollection add: (aMaIndexDefinition indexHashesFor: eachObject) ].	self removedDo:		[ :eachObject :eachCollection |		eachCollection add: (aMaIndexDefinition indexHashesFor: eachObject) ]! !!MagmaCollectionChanges methodsFor: 'changed keys'!changedKeySpecificationsDo: oneArgBlock	self hasChangedKeys ifFalse: [ ^self ].	self changedKeys do: oneArgBlock! !!MagmaCollectionChanges methodsFor: 'changed keys' stamp: 'cmm 11/15/2002 10:49'!changedKeys	"answer an OrderedCollection of MaChangedKeySpecification's."	^changes		at: #changedKeys		ifAbsentPut: [ OrderedCollection new ]! !!MagmaCollectionChanges methodsFor: 'accessing' stamp: 'cmm 6/6/2006 23:23'!deltaSize	| numberAdded numberRemoved |	numberAdded _ 0.	self additionsDo: [ : eachObject : eachHashIndexValues | numberAdded _ numberAdded + 1 ].	numberRemoved _ 0.	self removedDo: [ : eachObject : eachHashIndexValues | numberRemoved _ numberRemoved + 1 ].	^ numberAdded - numberRemoved! !!MagmaCollectionChanges methodsFor: 'testing'!hasAddedIndexes	^(changes includesKey: #addedIndexes) and: [ self addedIndexes notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing'!hasChangedKeys	^(changes includesKey: #changedKeys) and: [ self changedKeys notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/17/2005 22:01'!hasChanges	^ super hasChanges		or: [ self hasChangedKeys		or: [ self hasLockSpecified		or: [ self hasAddedIndexes		or: [ self hasNewIndexValues		or: [ self hasRemoved		or: [ self hasRemovedIndexes ] ] ] ] ] ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 8/21/2002 16:44'!hasLockSpecified	^changes includesKey: #lock! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 8/22/2002 14:00'!hasNewIndexValues	^changes includesKey: #newIndexValues! !!MagmaCollectionChanges methodsFor: 'testing'!hasRemoved	^(changes includesKey: #removed) and: [ self removed notEmpty ]! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 7/30/2006 21:51'!hasRemoved: anObject	^ self hasRemoved and: [self removed includesKey: anObject]! !!MagmaCollectionChanges methodsFor: 'testing'!hasRemovedIndexes	^(changes includesKey: #removedIndexes) and: [ self removedIndexes notEmpty ]! !!MagmaCollectionChanges methodsFor: 'testing' stamp: 'cmm 10/27/2002 21:34'!isLocked	^(changes includesKey: #lock) and: [ changes at: #lock ]! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 2/22/2005 12:48'!maTransientVariables 	^ super maTransientVariables, #( 'collection' )! !!MagmaCollectionChanges methodsFor: 'building' stamp: 'cmm 12/7/2002 12:18'!move: anObject from: oldHashValues to: newHashValues forIndexedAttribute: aSymbol	self changedKeys		add: (			MaChangedKeySpecification				object: anObject				attribute: aSymbol				oldHashValues: oldHashValues				newHashValues: newHashValues)! !!MagmaCollectionChanges methodsFor: 'added indexes' stamp: 'cmm 4/21/2002 23:10'!newIndexValues	"A dictionary of Dictionarys, (attribute Symbol -> (key->oid)...) used to	populate all new indexes being built in this transaction."	^changes		at: #newIndexValues		ifAbsentPut: [ Dictionary new ]! !!MagmaCollectionChanges methodsFor: 'added indexes'!newIndexValuesDo: aBlock	self hasNewIndexValues ifFalse: [ ^self ].	self newIndexValues do: aBlock! !!MagmaCollectionChanges methodsFor: 'accessing'!occurrencesOf: anObject	| numberAdded numberRemoved |	numberAdded _ 0.	self additionsDo:		[ :eachObject :eachHashIndexValues |		eachObject = anObject ifTrue: [ numberAdded _ numberAdded + 1 ] ].	numberRemoved _ 0.	self removedDo:		[ :eachObject :eachHashIndexValues |		eachObject = anObject ifTrue: [ numberRemoved _ numberRemoved + 1 ] ].	^numberAdded - numberRemoved! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 8/3/2006 19:22'!refreshSegment: aMagmaCollectionReaderSegment where: aMaTerm	aMagmaCollectionReaderSegment initializeObjects.	self additionsDo:		[ : eachObject : eachHashes |		"To be consistent with persistent readers, for each condition which satisfies the expression, the object is included."		(aMaTerm evaluationCount: eachObject) timesRepeat: [ aMagmaCollectionReaderSegment addObject: eachObject ] ].	aMagmaCollectionReaderSegment		startIndex: 1 ;		endIndex: aMagmaCollectionReaderSegment objects size ;		lastKnownSize: aMagmaCollectionReaderSegment objects size ;		yourself! !!MagmaCollectionChanges methodsFor: 'removed'!remove: anObject at: hashIndexesCollection	| added |	((added _ self added) includesKey: anObject)		ifTrue:			[ added removeKey: anObject ]		ifFalse:			[ self removed				at: anObject				put: hashIndexesCollection ]! !!MagmaCollectionChanges methodsFor: 'removed indexes' stamp: 'cmm 5/31/2005 13:32'!removeIndexNamed: attributeSymbol	self removeIndexValuesFor: (collection indexNamed: attributeSymbol).	(self hasAddedIndexes		and: [ self addedIndexes anySatisfy: [ :each | each attribute = attributeSymbol ] ])			ifTrue:				[ self addedIndexes					remove: (self addedIndexes 						detect: [ :each | each attribute = attributeSymbol ]						ifNone: [ MagmaSoftwareError signal: 'Apparent bug in MaLargeCollectionChanges>>removeIndexOn:' ]) ]			ifFalse:				[ self removedIndexes add: attributeSymbol ]! !!MagmaCollectionChanges methodsFor: 'private' stamp: 'cmm 12/7/2004 13:47'!removeIndexValuesFor: aMaIndexDefinition	"An index is being removed.  We need to make sure we remove	the hash index values to the objects that have already been added or	removed from the receiver."	| position |	position _ collection indexes indexOf: aMaIndexDefinition.	self additionsDo: [ :eachObject :eachCollection | eachCollection removeAt: position ].	self removedDo: [ :eachObject :eachCollection | eachCollection removeAt: position ]! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 2/1/2005 23:35'!removed	"Answer the dictionary of objects that have been removed in the local client, but not yet committed to the repository."	^ changes		at: #removed		ifAbsentPut: [ IdentityDictionary new ]! !!MagmaCollectionChanges methodsFor: 'removed'!removedDo: twoArgBlock	"The first argument is each object that has been added during the current	transaction, the second is a collection of hash-index values for each index."	self hasRemoved ifFalse: [ ^self ].	self removed keysAndValuesDo: twoArgBlock! !!MagmaCollectionChanges methodsFor: 'removed indexes'!removedIndexes	^changes		at: #removedIndexes		ifAbsentPut: [ OrderedCollection new ]! !!MagmaCollectionChanges methodsFor: 'removed indexes'!removedIndexesDo: oneArgBlock	self hasRemovedIndexes ifFalse: [ ^self ].	self removedIndexes do: oneArgBlock! !!MagmaCollectionChanges methodsFor: 'removed' stamp: 'cmm 8/6/2006 22:07'!removedOids	^ self hasRemoved 		ifTrue: [ self removed keys collect: [ : each | self session oidFor: each ] ]		ifFalse: 			[ #() ]! !!MagmaCollectionChanges methodsFor: '*magma server' stamp: 'cmm 3/16/2005 15:13'!requiresServerRefresh	^ super requiresServerRefresh		or: [ self hasAddedIndexes 		or: [ self hasRemovedIndexes ] ]! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/18/2005 13:42'!serializeAddedUsing: aMaObjectSerializer	| added |	self hasAdditions ifFalse: [ ^self ].	(added _ self added) copy keysAndValuesDo:		[ :eachObject :eachHashIndexValues |		added			at: (aMaObjectSerializer oidFor: eachObject)			put: eachHashIndexValues;			removeKey: eachObject ]! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 11/19/2002 22:39'!serializeChangedIndexValuesUsing: aMaObjectSerializer	self changedKeySpecificationsDo: [ :eachSpec | eachSpec serializeUsing: aMaObjectSerializer ]! !!MagmaCollectionChanges methodsFor: 'serializing'!serializeNewIndexValuesUsing: aMaObjectSerializer	self newIndexValuesDo:		[ :eachValues |		eachValues do:			[ :eachAssociation |			eachAssociation value: (aMaObjectSerializer oidFor: eachAssociation value) ] ]! !!MagmaCollectionChanges methodsFor: 'serializing'!serializeRemovedUsing: aMaObjectSerializer	| removed |	self hasRemoved ifFalse: [ ^self ].	(removed _ self removed) copy keysAndValuesDo:		[ :eachObject :eachHashIndexValues |		removed			at: (aMaObjectSerializer oidFor: eachObject)			put: eachHashIndexValues;			removeKey: eachObject ]! !!MagmaCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/17/2005 22:05'!serializeUsing: aMaObjectSerializer	super serializeUsing: aMaObjectSerializer.	self		serializeRemovedUsing: aMaObjectSerializer ;		serializeNewIndexValuesUsing: aMaObjectSerializer ;		serializeChangedIndexValuesUsing: aMaObjectSerializer! !!MagmaCollectionChanges methodsFor: 'building' stamp: 'cmm 8/22/2002 12:16'!setLocked: aBoolean	self hasLockSpecified		ifTrue:			[ self isLocked ~= aBoolean				ifTrue:					[ changes removeKey: #lock ] ]		ifFalse:			[ changes				at: #lock				put: aBoolean ]! !!MagmaLargeCollectionChanges class methodsFor: 'create' stamp: 'cmm 3/17/2005 21:42'!collection: aMagmaCollection	^self new collection: aMagmaCollection! !!MagmaLargeCollectionChanges methodsFor: 'override' stamp: 'cmm 3/18/2005 13:29'!add: anObject at: indexOrKey	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'override' stamp: 'cmm 3/18/2005 14:00'!addNewAdditionsTo: aMaCommitPackage using: aMagmaSession	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!added	"On the client, answers an IdentityDictionary whose key is the object to be added, value is a collection of its calculated hashIndex values.  On the server, the key is the oid of the object, not the object itself."	^ changes		at: #added		ifAbsentPut: [ IdentityDictionary new ]! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!additionsDo: twoArgBlock	"The first argument is each object that has been added during the current	transaction, the second is a collection of hash-index values for each index."	self hasAdditions ifFalse: [ ^self ].	self added keysAndValuesDo: twoArgBlock! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/16/2005 14:54'!beNewCollection	isNewCollection _ true! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!changes: aDictionary	changes _ aDictionary! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:54'!collection	^ collection! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collection: aMagmaLargeCollection	collection _ aMagmaLargeCollection! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collectionOid	^collectionOid! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:55'!collectionOid: anInteger	collectionOid _ anInteger! !!MagmaLargeCollectionChanges methodsFor: 'copying' stamp: 'cmm 3/28/2005 22:30'!copyForSerialization	| newChanges |	newChanges _ changes species new.	changes keysAndValuesDo:		[ :eachKey :eachValue |		newChanges			at: eachKey			put: eachValue copy ].	^self copy changes: newChanges! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/17/2005 23:10'!hasAddedIndexes	^ false! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 3/16/2005 14:56'!hasAdditions	^(changes includesKey: #added) and: [ self added notEmpty ]! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/17/2005 22:01'!hasChanges	^ self isNewCollection or: [ self hasAdditions ]! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'brp 4/6/2005 20:50'!hasRemoved	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/18/2005 11:02'!hasRemovedIndexes	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/16/2005 14:56'!includesObject: anObject	^self hasAdditions ifTrue: [ self added includesKey: anObject ] ifFalse: [ false ]! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/17/2005 21:48'!initialize	super initialize.	self reset! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/20/2005 20:57'!isForMagmaArray	^ false! !!MagmaLargeCollectionChanges methodsFor: 'testing' stamp: 'cmm 3/16/2005 15:10'!isNewCollection	^isNewCollection! !!MagmaLargeCollectionChanges methodsFor: 'reading' stamp: 'cmm 7/30/2006 13:55'!localSegment	"Populate a segment from the uncommitted changes."	| matching |	matching _ OrderedCollection new.	self additionsDo: [ : object : hashes | matching add: object ].	^ MagmaCollectionSegment new		lastKnownSize: matching size ;		objects: matching ;		startIndex: 1 ;		yourself! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/16/2005 15:11'!maTransientVariables 	^ super maTransientVariables, #( 'collection' )! !!MagmaLargeCollectionChanges methodsFor: 'actions' stamp: 'brp 4/6/2005 21:18'!removedDo: twoArgBlock	"The base class does not support removals, so do nothing."! !!MagmaLargeCollectionChanges methodsFor: '*magma server' stamp: 'cmm 3/16/2005 15:13'!requiresServerRefresh	^ self isNewCollection! !!MagmaLargeCollectionChanges methodsFor: 'initialize-release' stamp: 'cmm 3/16/2005 15:11'!reset	changes _ Dictionary new.	isNewCollection _ false! !!MagmaLargeCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/18/2005 13:42'!serializeAddedUsing: aMaObjectSerializer	self subclassResponsibility! !!MagmaLargeCollectionChanges methodsFor: 'serializing' stamp: 'cmm 3/17/2005 22:04'!serializeUsing: aMaObjectSerializer	self serializeAddedUsing: aMaObjectSerializer! !!MagmaLargeCollectionChanges methodsFor: 'accessing' stamp: 'cmm 8/6/2006 22:07'!session	^ collection session! !!MagmaLocation commentStamp: 'cmm 1/13/2005 10:43' prior: 0!I provide an objectified link to a Magma repository, local or remote, to use when you don't want to bother with its location details.!!MagmaLocalLocation class methodsFor: 'create' stamp: 'cmm 11/10/2005 20:39'!default	"This method is for Seaside."	self maMarked: 'otherPackageSupport'.	^ self path: (FileDirectory default fullNameFor: 'magma')! !!MagmaLocalLocation class methodsFor: 'create' stamp: 'cmm 9/24/2004 15:44'!path: aString	^ self new		path: aString ; 		yourself! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 4/10/2005 18:00'!= aMagmaLocalLocation 	aMagmaLocalLocation maOriginalClass = self species ifFalse: [^false].	^aMagmaLocalLocation path = self path! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'brp 7/10/2006 09:25'!fullPath	^ FileDirectory default fullNameFor: path! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 2/15/2005 13:00'!hash	^ self path hash! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'cmm 9/23/2004 14:41'!isLocal	^ true! !!MagmaLocalLocation methodsFor: 'printing' stamp: 'cmm 2/24/2005 12:06'!maPrintAbbreviatedOn: aStream	aStream nextPutAll: path! !!MagmaLocalLocation methodsFor: 'actions' stamp: 'brp 7/10/2006 09:27'!newSession	"For local, we have to determine whether the files are already in-use by another	local-connection.  If they are, create a new session sharing the original's	repositoryController, Otherwise open the files."	| sessionClass fullPath |	sessionClass := self sessionClass.	fullPath := self fullPath.	^ sessionClass connectedSessions		maDetect: [ :each | each pathName = fullPath ]		ifFound: [ :foundSession | 			sessionClass repositoryController: foundSession repositoryController ]		ifNone: [ sessionClass openLocal: fullPath ]! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'cmm 9/24/2004 12:28'!path	^ path! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'cmm 9/24/2004 12:28'!path: aString	path _ aString! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 10/24/2004 23:30'!description	^ String streamContents: [ : stream | self maPrintAbbreviatedOn: stream ]! !!MagmaLocation methodsFor: 'testing' stamp: 'cmm 9/23/2004 14:41'!isLocal	^ false! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 9/15/2004 21:55'!name	^ name! !!MagmaLocation methodsFor: 'accessing' stamp: 'cmm 9/15/2004 21:55'!name: anObject	"Set the value of name"	name _ anObject! !!MagmaLocation methodsFor: 'actions' stamp: 'cmm 1/13/2005 22:43'!newSession	self subclassResponsibility! !!MagmaLocation methodsFor: 'printing' stamp: 'brp 11/4/2005 12:04'!printOn: aStream	self maPrintAbbreviatedOn: aStream! !!MagmaLocation methodsFor: 'accessing' stamp: 'brp 11/1/2005 15:33'!sessionClass	^ self class environment at: #LavaSession ifAbsent: [MagmaSession]! !!MagmaRemoteLocation class methodsFor: 'create' stamp: 'cmm 11/10/2005 18:59'!default	"For Seaside support."	self maMarked: 'otherPackageSupport'.	^ self host: 'localhost' port: 1010! !!MagmaRemoteLocation class methodsFor: 'create' stamp: 'brp 11/4/2005 12:22'!host: hostName port: portInteger	^ self new		host: hostName;		port: portInteger! !!MagmaRemoteLocation class methodsFor: 'create' stamp: 'cmm 9/23/2004 15:26'!hostAddress: aByteArray port: portInteger	^ self new		hostAddress: aByteArray ;		port: portInteger ;		yourself! !!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 4/10/2005 18:00'!= aMagmaRemoteLocation 	aMagmaRemoteLocation maOriginalClass = self species ifFalse: [^false].	^self port = aMagmaRemoteLocation port 		and: [self hostAddress = aMagmaRemoteLocation hostAddress]! !!MagmaRemoteLocation methodsFor: 'testing' stamp: 'cmm 2/15/2005 13:02'!hash	^ self hostAddress hash bitXor: self port hash! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 11/10/2005 19:08'!host	"The host name of the computer at this location."	^ host ifNil: [ host := hostAddress maAsIpString ]! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 11/10/2005 19:08'!host: aString	"this is actually the host name."	host := aString! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'brp 11/4/2005 12:23'!hostAddress	"Answer the value of hostAddress"	^ hostAddress ifNil: [ hostAddress := NetNameResolver addressForName: self host]! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 9/23/2004 14:26'!hostAddress: anObject	"Set the value of hostAddress"	hostAddress _ anObject! !!MagmaRemoteLocation methodsFor: 'printing' stamp: 'brp 11/4/2005 12:03'!maPrintAbbreviatedOn: aStream	aStream		maPrint: host ;		nextPut: $:;		maPrint: port! !!MagmaRemoteLocation methodsFor: 'actions' stamp: 'brp 11/4/2005 12:23'!newSession	^ self sessionClass		hostAddress: self hostAddress		port: self port! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 9/23/2004 14:26'!port	"Answer the value of port"	^ port! !!MagmaRemoteLocation methodsFor: 'accessing' stamp: 'cmm 9/23/2004 14:26'!port: anObject	"Set the value of port"	port _ anObject! !!MagmaOfflineObject class methodsFor: 'create' stamp: 'cmm 1/13/2005 15:44'!needingMessage: aMessage	^ self new		waitingMessage: aMessage ;		yourself! !!MagmaOfflineObject methodsFor: 'testing' stamp: 'cmm 1/13/2005 16:11'!isMagmaOfflineObject	^ true! !!MagmaOfflineObject methodsFor: 'accessing' stamp: 'cmm 1/13/2005 16:54'!tryToConnect	self maMarked: 'dev'.."My first guess is we signal the ConnectToPeerMagma notification.."! !!MagmaOfflineObject methodsFor: 'accessing' stamp: 'cmm 1/13/2005 16:05'!waitingMessage	^ waitingMessage! !!MagmaOfflineObject methodsFor: 'initialize-release' stamp: 'cmm 1/13/2005 15:44'!waitingMessage: aMessage	waitingMessage _ aMessage! !!MagmaPreferences commentStamp: 'cmm 1/25/2003 17:49' prior: 0!Each MagmaSession initializes its own preferences.  Get an instance of my by sending #preferences to a MagmaSession.Debug and DebugProxies are global preferences.!!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 8/10/2002 18:09'!debug	^Debug! !!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 8/10/2002 18:10'!debug: aBoolean	Debug _ aBoolean! !!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 7/16/2002 00:24'!debugProxies	^DebugProxies! !!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 7/25/2002 22:31'!debugProxies: aBoolean	DebugProxies _ aBoolean! !!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 3/30/2003 12:54'!handStatus	^HandStatus! !!MagmaPreferences class methodsFor: 'accessing' stamp: 'cmm 3/30/2003 12:55'!handStatus: aBoolean	HandStatus _ aBoolean! !!MagmaPreferences class methodsFor: 'initializing' stamp: 'cmm 10/9/2004 22:32'!initialize	super initialize.	self 		debugProxies: false;		debug: false;		handStatus: true! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 3/27/2005 17:19'!allowWriteBarrier	^ attributes at: #allowWriteBarrier! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 3/27/2005 23:05'!allowWriteBarrier: aBoolean	self systemHasWriteBarrier ifFalse: [ MagmaEnvironmentError signal: 'WriteBarrier not loaded in the image, cannot turn it on.' ].	attributes		at: #allowWriteBarrier		put: aBoolean! !!MagmaPreferences methodsFor: 'initializing' stamp: 'cmm 4/10/2005 19:20'!initialize	super initialize.	attributes _ Dictionary new.	self 		refreshPersistentObjectsEvenWhenChangedOnlyByMe: false ;		signalProxyMaterializations: false ;		allowWriteBarrier: false! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 4/30/2004 00:32'!refreshPersistentObjectsEvenWhenChangedOnlyByMe	"When set to true, any persistent objects that were changed by this session will be reset to their persistent state."	^ attributes at: #refreshPersistentObjectsEvenWhenChangedOnlyByMe! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 4/30/2004 00:31'!refreshPersistentObjectsEvenWhenChangedOnlyByMe: aBoolean	attributes		at: #refreshPersistentObjectsEvenWhenChangedOnlyByMe		put: aBoolean! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 4/30/2004 00:32'!signalProxyMaterializations	"When set to true, every time a proxy is materialized, a MagmaProxyMaterialization notification is signaled.  This is useful during development for performance tuning specifically for optimizing your read strategies."	^ attributes at: #signalProxyMaterializations! !!MagmaPreferences methodsFor: 'accessing' stamp: 'cmm 4/30/2004 00:31'!signalProxyMaterializations: aBoolean	attributes		at: #signalProxyMaterializations		put: aBoolean! !!MagmaPreferences methodsFor: 'testing' stamp: 'cmm 3/27/2005 23:06'!systemHasWriteBarrier	^ Smalltalk hasClassNamed: #WriteBarrier! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 2/14/2005 13:47'!browseChangeSetNamed: nameString	"Opens a code-file browser on the change-set named nameString."	FileContentsBrowser browseStream: (self changeSetNamed: nameString)! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 2/14/2005 13:42'!browseClassNamed: nameSymbol	"Opens a code-file browser on the class named nameSymbol."	FileContentsBrowser browseStream: (self classNamed: nameSymbol)! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:12'!changeSetNamed: aString	^ changeSets		at: aString		ifAbsent: [ MagmaUserError signal: 'No change set named ', aString, ' found here.' ].! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 11/9/2004 12:25'!changeSetNames	changeSets keys asSortedCollection! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:17'!classNamed: aSymbol	^ classes		at: aSymbol		ifAbsent: [ MagmaUserError signal: 'No class named ', aSymbol, ' found here.' ].! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 11/9/2004 12:25'!classNames	^ classes keys asSortedCollection! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:52'!fileInChangeSetNamed: nameString	| stream |	stream _ self changeSetNamed: nameString.	stream reset.	ChangeSorter		newChangesFromStream: stream		named: nameString! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:17'!fileInClassNamed: nameString	| stream |	stream _ self classNamed: nameString.	stream reset.	stream fileInAnnouncing: 'loading class ', nameString, ' from Magma database.'! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:44'!fileOutChangeSet: aChangeSet	| stream |	stream _ ReadWriteStream on: String new.	aChangeSet fileOutOn: stream.	stream position: 0.	changeSets		at: aChangeSet name		put: stream! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:44'!fileOutClass: aClass	| stream |	stream _ ReadWriteStream on: String new.	aClass fileOutOn: stream.	stream position: 0.	classes		at: aClass name		put: stream! !!MagmaRepositoryCodeBase methodsFor: 'packages' stamp: 'cmm 11/4/2004 23:09'!includesVersionNamed: aString	"The Monticello UI uses this method."	^ packages anySatisfy: [ : each | each info name = aString ]! !!MagmaRepositoryCodeBase methodsFor: 'initialize-release' stamp: 'cmm 10/26/2004 22:29'!initialize	super initialize.	packages _ Dictionary new.	changeSets _ Dictionary new.	classes _ Dictionary new! !!MagmaRepositoryCodeBase methodsFor: 'change sets' stamp: 'cmm 10/26/2004 23:14'!installChangeSets	changeSets keysDo: [ :eachKey | self fileInChangeSetNamed: eachKey ]! !!MagmaRepositoryCodeBase methodsFor: 'class fileouts' stamp: 'cmm 10/26/2004 23:18'!installClasses	classes keysDo: [ :eachKey | self fileInClassNamed: eachKey ]! !!MagmaRepositoryCodeBase methodsFor: 'packages' stamp: 'cmm 11/2/2004 13:50'!packages	^ packages! !!MagmaRepositoryCodeBase methodsFor: 'packages' stamp: 'cmm 10/26/2004 23:38'!storeVersion: aMCVersion	"The Monticello UI uses this method."	packages		at: aMCVersion info		put: aMCVersion! !!MagmaRepositoryCodeBase methodsFor: 'packages' stamp: 'cmm 10/26/2004 23:38'!versionWithInfo: aMCVersionInfo ifAbsent: aBlock	"The Monticello UI uses this method."	^ packages		at: aMCVersionInfo		ifAbsent: aBlock! !!MagmaRepositoryCodeBase methodsFor: 'packages' stamp: 'cmm 10/26/2004 22:58'!versionsAvailableForPackage: aMCVersion	"The Monticello UI uses this method."	^ packages		select: [ : each | each package = aMCVersion ]		thenCollect: [ : each | each info ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 9/24/2004 17:00'!compress: sourcePath to: targetPath	(MagmaCompressor source: sourcePath) compressTo: targetPath! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'cmm 2/20/2005 16:29'!controllerOpenedOn: pathName	^ OpenControllers		maDetect: [ : each | each directory pathName = pathName ]		ifFound: [ : foundController | foundController ensureOpen ]		ifNone: [ nil ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 8/3/2006 22:32'!create: localNameOrFullyQualifiedPathString	"Creates a repository with an initial root of nil.  I #assureExistence of the localNameOrFullyQualifiedPathString."	| fd |	fd _ FileDirectory on: (FileDirectory default fullNameFor: localNameOrFullyQualifiedPathString).	self validateCanCreateIn: fd.	self new createRepositoryAt: fd! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 8/3/2006 22:33'!create: localOrfullyQualifiedPathString root: anObject	| session |	self create: localOrfullyQualifiedPathString.	session _ MagmaSession openLocal: localOrfullyQualifiedPathString.	session		connect: (MagmaUser id: 'system create:root:') ;		commit: [ session root: anObject ] ;		disconnect ;		closeRepository! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'kph 8/4/2006 01:26'!delete: localNameOrFullyQualifiedPathString	"Delete the just the files in fullyQualifiedPathString that are part of the Magma repository that resides there."	| fd |	fd _ FileDirectory on: (FileDirectory default fullNameFor: localNameOrFullyQualifiedPathString).	(fd exists and: [ fd fileExists: MaObjectFiler objectsFilename ]) ifFalse:		[ (MagmaNotification new messageText: fd pathName , ' does not exist, nothing to delete.') signal.		^ self ].	(self filesFor: fd pathName), { (MaRecoveryManager commitPackagesFilename) } do:		[ : each |			fd deleteFileNamed: each asString			ifAbsent: [ MagmaNotification signal: 'Couldn''t find ' , each asString ] ]! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 7/15/2005 12:39'!filesFor: directoryName	| controller |	controller _ self open: directoryName.	^ [ controller filenames ] ensure: [ controller close ]! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'cmm 6/14/2006 22:07'!generateKeysIndexIn: aFileDirectory for: sourceHashIndexFilename 	"Create a -keys index in aFileDirectory using sourceHashIndexFilename as the source."	| source target namePart targetName |	source _ MaHashIndex openNamed: (aFileDirectory fullNameFor: sourceHashIndexFilename).	[ namePart _ sourceHashIndexFilename 		copyFrom: 1		to: sourceHashIndexFilename size - 4.	targetName _ namePart , '-keys.hdx'.	target _ MaHashIndex 		createNamed: (aFileDirectory fullNameFor: targetName)		keySize: MaObjectBuffer oidSize		valueSize: source keySize		recordSize: source numberOfSlots.	[ source 		entriesFrom: 0		do: 			[ : eachRecord : bax : level | 			target 				add: (eachRecord keyAtByteArrayIndex: bax)				at: (eachRecord valueAtByteArrayIndex: bax) ]		until: [ : eachRecord : bax : level | false ] ] ensure: [ target close ] ] ensure: [ source close ]! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'cmm 6/14/2006 21:58'!generateKeysIndices: dir 	| hdxFiles |	hdxFiles _ dir fileNamesMatching: '*.hdx'.	hdxFiles do: 		[ : each | 		| namePart |		namePart _ each 			copyFrom: 1			to: each size - 4.		"is it an attribute index?"		(namePart anySatisfy: [ : e | e isLetter ]) ifTrue: 			[ 			self 				generateKeysIndexIn: dir				for: each.			dir 				rename: each				toBe: namePart , '-oids.hdx' ] ]! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 11/2/2004 14:38'!initialize	OpenControllers ifNotNil: [ OpenControllers do: [ : each | each close ] ].	OpenControllers _ Set new.	Smalltalk		addToStartUpList: self;		addToShutDownList: self! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 9/26/2004 19:21'!open: fullyQualifiedPathString	^ self new open: (FileDirectory on: fullyQualifiedPathString)! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'cmm 10/26/2004 12:48'!openedOn: fullyQualifiedPathString	| existingController |	^ (existingController _ self controllerOpenedOn: fullyQualifiedPathString)		ifNil: [ self open: fullyQualifiedPathString ]		ifNotNil: [ existingController ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'cmm 9/24/2004 13:01'!repositoryExistsIn: aFileDirectory	^ (aFileDirectory directoryEntryFor: MaObjectFiler objectsFilename) notNil! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 12/27/2004 23:16'!shutDown: aboutToQuit	super shutDown: aboutToQuit.	MagmaSession shutDown: aboutToQuit.	OpenControllers		do:			[ :each | 			[ MagmaNotification signal: 'closing Magma repository ', each pathName asString, '.  Will reopen on next startup.' ]				on: MagmaNotification				do: [ : noti | Transcript cr; show: noti messageText. noti pass ].			each primClose ]! !!MagmaRepositoryController class methodsFor: 'initializing' stamp: 'cmm 3/11/2005 14:58'!startUp: amResuming	super startUp: amResuming.	OpenControllers copy do: 		[ :each | 		[ [ each ensureOpen ]			on: MagmaNotification			do: [ : noti | Transcript cr; show: noti messageText. noti pass ] ]				on: MagmaEnvironmentError				do: 					[ : error | "not present anymore, remove from OpenControllers and resignal."					each close.					error pass ] ].	"Now that we're open, ensure any server-sockets that may need to restart can be."	MaServerSocket startUp: amResuming! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'cmm 5/1/2003 00:24'!systemSessionUserId	^'__system'! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'cmm 6/14/2006 21:45'!updateVersionIn: aFileDirectory from: currentVersion 	"Force update the filers version from currentVersion.  currentVersion is required to help catch mistakes, since the version is very important for operation."	| filer |	filer _ MaObjectFiler open: aFileDirectory.	[" filer version = currentVersion ifFalse: 		[ MagmaUserError signal: 'This repository is not already version ' , currentVersion asString ]."	filer version: currentVersion + 1 ] ensure: [ filer close ]! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'cmm 6/14/2006 22:58'!upgrade5To6: fullyQualifiedPathString 	"Upgrade legacy repository's from #magmaVersion 5 to 6.  It is always good advice to back up before running any conversion utility."	| dir |	dir _ FileDirectory on: fullyQualifiedPathString.	self 		updateVersionIn: dir from: 5 ;		generateKeysIndices: dir! !!MagmaRepositoryController class methodsFor: 'validation' stamp: 'cmm 9/24/2004 12:32'!validateCanCreateIn: aFileDirectory	"Magma databases do not share the same directory.  Not only would it be hard to identify which files go with which repository, some of the filenames are based on oids, which would not always be unique across repositories."	(aFileDirectory exists and: [ self repositoryExistsIn: aFileDirectory ])		ifTrue:			[ MagmaUserError signal: aFileDirectory pathName, ' already has a Magma repository in it.  A directory may contain only one Magma repository.' ]! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 4/21/2003 16:28'!averageObjectSize	^repository objectFileSize // self objectCount! !!MagmaRepositoryController methodsFor: 'utilities' stamp: 'cmm 5/24/2006 22:36'!backupTo: aFileDirectory 	"Backup the repository to aFileDirectory while the repository is open.  Make sure you have enough space.  All database requests will wait patiently until all files are backed up and then resume automatically."	aFileDirectory assureExistence.	self requestCritical: 		[ repository commitCritical: 			[ repository dbFilesDo: 				[ : eachTransactionalFileStream : eachFileNumber | 				eachTransactionalFileStream copyToDirectory: aFileDirectory ] ] ]! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 6/6/2005 13:35'!beReadOnly	self requestCritical: [ preferences beReadOnly ]! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 6/6/2005 13:35'!beReadWrite	self requestCritical: [ preferences beReadWrite ]! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 7/5/2005 20:16'!cacheFlushFrequency	^ preferences cacheFlushFrequency! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 7/5/2005 20:17'!cacheFlushFrequency: aBoolean	^ self requestCritical: [ preferences cacheFlushFrequency: aBoolean ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 10/24/2004 23:14'!close	OpenControllers remove: self ifAbsent: [ "do nothing" ].	self primClose! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/26/2004 21:54'!codeBaseByteArray	^Array		with: repository classDefinitionsByteArray		with: (serverSerializer serializeGraph: self definition codeBase) trimmedByteArray! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 1/16/2005 21:54'!connect	session connect: (MagmaUser id: self class systemSessionUserId).	repository initializeSpecialOidsList! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 6/23/2002 10:48'!connections	"Used for monitoring server status via some console gui."	self maMarked: 'dev'.! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/29/2004 00:22'!createRepositoryAt: aFileDirectory	| anchor |	directory _ aFileDirectory.	self		repository: (			MaObjectRepository				create: aFileDirectory				controller: self);		connect;		forceWrite:			(anchor _ MaRootAnchor new				definition: self definition ;				yourself).	repository filer		anchorOid: (self session oidFor: anchor);		classDefinitionsOid: (self session oidFor: self definition classDefinitions);		definitionOid: (self session oidFor: self definition).	self close! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 5/2/2004 20:40'!definition	"Answers a MagmaRepositoryDefinition"	^ session definition! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 9/24/2004 15:55'!directory	"Answer the directory in which my files reside."	"Note, this is the same FileDirectory that MaObjectFiler has.  It was necessary to duplicate this here to support the auto-reopen feature upon image restart."	^ directory! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 2/20/2005 16:31'!ensureOpen	self isOpen ifFalse: [ self open ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 6/9/2005 16:01'!filenames	^ { MaObjectFiler objectsFilename.  MaObjectFiler objectPointersFilename },	(repository largeCollectionManagers 		inject: OrderedCollection new		into:			[ : coll : each |			coll				addAll: each filenames ;				yourself ]),	(directory fileNames select: [ : each | each endsWith: '.images' ])! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 7/7/2005 23:21'!flushAggressively	^ preferences flushAggressively! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 7/5/2005 12:51'!flushAggressively: aBoolean	^ self requestCritical: [ preferences flushAggressively: aBoolean ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 5/30/2005 21:59'!forceWrite: anObject	"This is somewhat of a hacking method to enable us to write objects needed	for the repository to operate (i.e., commit transactions) during initial creation."	| commitPackage |	session begin.  "Begin a tran to allow the submitAll:for:.."	commitPackage _ MaCommitPackage new.	session serializer		serializeGraph: anObject		do: [ :eachObject | commitPackage addObject: eachObject ].	commitPackage copy serializeObjectsUsing: session.	commitPackage serializeObjectsUsing: session.	session		refreshViewUsing: (			repository				submitAll: commitPackage				for: session id				beginAnother: false) ;		decrementTransactionLevel! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 4/3/2003 23:00'!getDefinition	^session materializeObject: repository definitionByteArray! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 6/12/2006 13:01'!initialize	super initialize.	self initializeSession.	session initializeDefinition.	session definition addMinimumClassesForOdbmsUsing: self serverSerializer.	requestInterruptGuard _ Monitor new.	preferences _ MagmaServerPreferences new! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 3/27/2002 22:00'!initializeServerSerializer	"Why is this separate, 'serverSerializer' needed?  Because the session serializer requires a different traversalStrategy.  The serverSerializer needs to be able to fully serialize, to the ends of the graphs, the 'response' objects of various requests."	serverSerializer _ self session serializer copyWithNewBuffer initializeTraversalStrategy! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 1/16/2005 18:45'!initializeSession	session _ MagmaSession repositoryController: self.	self initializeServerSerializer! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 9/1/2003 19:40'!initializeSystemReadStrategy	repository initializeSystemReadStrategyUsing: self serverSerializer classIdManager! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 4/30/2003 22:07'!isOpen	^repository isOpen! !!MagmaRepositoryController methodsFor: 'preferences' stamp: 'cmm 6/6/2005 13:38'!isReadOnly	^ preferences isReadOnly! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 1/14/2005 16:05'!magmaId	^ self definition magmaId! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/10/2005 10:59'!materializeClassDefinitions	"This is needed because, when opening the repository, the default classes do not include MagmaRepositoryDefinition, which is delivered as part of any session-connection.  When the system-session attempts to connect, it tries to read the repository-definition but can't because it can't get a proper read-strategy for it."	[ session loadClassDefinitionsFrom: repository classDefinitionsByteArray ]		on: Error		do:			[ : err | MagmaCorruptionError signal: err messageText ]! !!MagmaRepositoryController methodsFor: 'unsupported' stamp: 'cmm 5/2/2004 20:40'!maximumNumberOfChallengers: anInteger 	self session 		commit: [ self definition maximumNumberOfChallengers: anInteger ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 5/14/2005 18:14'!newSessionFor: userIdString	^ self repository		newSessionFor: userIdString		numberOfChallengers: MagmaRepositoryDefinition defaultMaximumNumberOfChallengers! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/6/2005 13:21'!newTransactionFor: sessionId	preferences isReadOnly ifTrue:		[ MagmaUserError signal: 'This repository is set to read-only, commits are prohibited.' ].	^ repository newTransactionFor: sessionId! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 5/2/2003 14:56'!numberOfConnectedClients	^repository sessions size - 1! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 4/21/2003 15:55'!objectCount	"Answers how many objects have been committed to this repository.  Does not account for objects that have since been garbage colellected."	^repository objectCount! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 7/16/2005 16:57'!open	"This is called when restarting controllers during image restart."	| didRetry |	didRetry _ false.	[ self privateOpen: directory ]		on: MagmaCorruptionError		do: 			[ : err |			didRetry				ifTrue: [ self error: 'serious problem' ]				ifFalse:					[ MagmaWarning signal: 'Outage occurred while writing system-definitions!!  Will now attempt to repair.'.					repository primitiveRecover.					err retry ] ].	self openLargeCollections.	"Two-stage recovery.."	repository recoverIfNecessary.  "rollback"	repository recoverIfNecessary  "re-apply after-images."! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/6/2005 09:51'!open: aFileDirectory	directory _ aFileDirectory.	self open.	OpenControllers add: self. "<- we only do this for intentional opens, not image restarts"! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 3/16/2005 12:46'!openLargeCollection: aMagmaLargeCollection	repository openLargeCollectionIfNecessary: aMagmaLargeCollection! !!MagmaRepositoryController methodsFor: 'initializing' stamp: 'cmm 5/2/2004 20:40'!openLargeCollections	"Open all indexes for all large collections."	self definition allLargeCollections 		do: [ :each | self openLargeCollection: each ]! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 9/24/2004 15:13'!pathName	^ directory pathName! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 6/1/2005 16:11'!primClose	self requestCritical:		[ session ifNotNil: [ session disconnect ].		repository close ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 2/20/2005 16:27'!privateOpen: aFileDirectory	MagmaNotification signal: 'opening Magma repository ', self pathName.	self		initializeSession;		repository: (			MaObjectRepository				open: aFileDirectory				controller: self) ;		initializeSystemReadStrategy ;		materializeClassDefinitions ;		connect ;		refreshView "so more classes will be pulled from unusedDepths of the SystemReadStrategy"! !!MagmaRepositoryController methodsFor: 'client/server required methods' stamp: 'cmm 6/12/2006 13:01'!processRequest: aMaRepositoryRequest 	aMaRepositoryRequest repositoryController: self.	^ [ self requestCritical: [ aMaRepositoryRequest process ] ] 		on: MaError		do: 			[ : anError | 			(MagmaPreferences debug and: 				[ ({  MagmaCommitError. MagmaSessionLost  } includes: anError maOriginalClass) not and: [ anError isUserError not ] ]) ifTrue: [ self halt: anError messageText ].			anError ]! !!MagmaRepositoryController methodsFor: 'client/server required methods' stamp: 'cmm 8/6/2006 23:19'!protocol	"This is the protocol needed to talk to a magma server."	^ { 	"core"		LargePositiveInteger. MaSerializedGraphBuffer }, 		MaObjectBuffer allSubclasses asArray,	"various requests"		MagmaRepositoryRequest allSubclasses asArray,	"extra objects for some requests."		{ MaCommitPackage.  MaBasicReadStrategy.  MaReadStrategy },	"various results"		MagmaServerResult allSubclasses asArray,	"extra objects for results"		{ MagmaId. UUID. MaFailedCommitResult. MagmaClientConnection. MagmaCommitConflict. Fraction }, 	"query expressions"		MaTerm allSubclasses asArray, { MaQueryTrunk },	"MagmaCollections"		MagmaCollection withAllSubclasses asArray, { IdentityDictionary },	"indexes"		MagmaCollectionIndex allSubclasses asArray, 	"large-collection changes"		MagmaLargeCollectionChanges allSubclasses asArray,	{ "parts of MagmaCollectionChanges"		Association.  MaChangedKeySpecification },	"exceptions"		MaError allSubclasses asArray,	"for MaDateAndTimeIndex"		{ DateAndTime. Duration }! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 9/1/2003 19:21'!refreshView	self session abort.	repository systemReadStrategy makeReadyForUseUsing: session serializer classIdManager! !!MagmaRepositoryController methodsFor: 'private'!repository	^repository! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/31/2002 12:54'!repository: aMaObjectRepository	repository _ aMaObjectRepository.	aMaObjectRepository repositoryController: self! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 12/27/2002 15:55'!requestCritical: aBlock	"Coordinate access to all server elements."	^requestInterruptGuard critical: aBlock! !!MagmaRepositoryController methodsFor: 'private'!serverSerializer	"The serverSerializer is used for processing client requests.  It is also	used during administration and possibly needed during initial creation of a	repository."	^serverSerializer! !!MagmaRepositoryController methodsFor: 'private'!session	"The server-side session is needed for largeCollection updates to be	processed correctly.  When a client makes a change to a largeCollection, such	as adding or removing an index, the systemRoot change is reflected upon	the servers session refreshing its view of the database."	^session! !!MagmaRepositoryController methodsFor: 'accessing' stamp: 'cmm 4/3/2003 22:59'!sessionId	^session id! !!MagmaRepositoryController methodsFor: 'private' stamp: 'cmm 10/22/2002 23:18'!signalRequestGuard	requestInterruptGuard signal! !!MagmaRepositoryController methodsFor: 'client/server required methods' stamp: 'cmm 9/19/2004 22:08'!value: aMagmaRepositoryRequest	^ self processRequest: aMagmaRepositoryRequest! !!MagmaRepositoryController methodsFor: 'statistics' stamp: 'cmm 4/21/2003 16:02'!version	^repository version! !!MagmaRepositoryDefinition class methodsFor: 'as yet unclassified' stamp: 'cmm 1/16/2005 21:52'!defaultMaximumNumberOfChallengers	"defaultMaximumNumberOfChallengers is used to manage server resources.  Since all commit records against a session build-up in memory until the session crosses a transaction boundary (browse references to MaTransactionLog>>'challengingEntries').  For now, we use this simple default."	^ 1000! !!MagmaRepositoryDefinition methodsFor: 'large collections' stamp: 'cmm 3/16/2005 12:45'!addLargeCollection: aMagmaLargeCollection	^ allLargeCollections add: aMagmaLargeCollection! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 6/6/2004 23:56'!addMinimumClassesForOdbmsUsing: aMaObjectSerializer	"These are the minimum required classes for a client to communicate with the	repositoryController."	self minimumClassesToCreateRepository		do:			[ :each |			aMaObjectSerializer classIdManager addNewClass: (Smalltalk classNamed: each) ].	self classDefinitions: aMaObjectSerializer classIdManager classDefinitionsById! !!MagmaRepositoryDefinition methodsFor: 'large collections' stamp: 'cmm 5/29/2002 22:43'!allLargeCollections	^allLargeCollections! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 3/2/2005 12:20'!attributeNamed: aString	"Answer the user object placed at aString."	^ attributes at: aString! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 3/2/2005 12:19'!attributeNamed: aString put: anObject	"Objects required for user-extensions to Magma should be placed here."	attributes 		at: aString		put: anObject! !!MagmaRepositoryDefinition methodsFor: 'classes' stamp: 'cmm 8/21/2002 21:58'!classDefinitions	"Key = classId, value = anOrderedCollection of MaOdbmsClassDefinition's."	^classDefinitions! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 5/29/2002 22:43'!classDefinitions: aDictionary	classDefinitions _ aDictionary! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 6/4/2004 13:16'!classDefinitionsForId: anInteger	^ classDefinitions at: anInteger! !!MagmaRepositoryDefinition methodsFor: 'code base' stamp: 'cmm 10/26/2004 23:41'!codeBase	^ codeBase! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 3/6/2005 11:58'!initialize	super initialize.	self classDefinitions: Dictionary new.	allLargeCollections _ Set new.	codeBase _ MagmaRepositoryCodeBase new.	magmaId _ MagmaId new.	maximumNumberOfChallengers _ 1000.	attributes _ Dictionary new! !!MagmaRepositoryDefinition methodsFor: 'accessing' stamp: 'cmm 1/16/2005 22:20'!magmaId	^ magmaId! !!MagmaRepositoryDefinition methodsFor: 'settings' stamp: 'cmm 5/29/2002 22:43'!maximumNumberOfChallengers	"Answer the maximum number of commit entry's Magma should allow in each users session before that session will be terminated.  Commit entry's are records stored in the servers memory that record the objects changed by each user.  When a session is in a transaction, these entries 'pile up', consuming server memory.  Only when the client crosses a transaction boundary (i.e., begin, commit or abort) is the log for that session cleared."	^maximumNumberOfChallengers! !!MagmaRepositoryDefinition methodsFor: 'settings' stamp: 'cmm 5/29/2002 22:43'!maximumNumberOfChallengers: anInteger	maximumNumberOfChallengers _ anInteger! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 6/29/2004 23:52'!minimumClassesToCreateRepository	"We need Bag to properly prepare their permanent ReadStrategy's in MaBasicReadStrategy class.  In there, we set their readDepth to +1 because collections are almost always enumerated and it would perform poorly to materalize one at a time.  Blocks and CompiledMethods need to always be read full depth."	^#(	"Array and Set are not here because they are part of minimumClasses."	Collection"	CompiledMethod BlockContext    waiting for future version of Magma"	)! !!MagmaRepositoryDefinition methodsFor: 'code base' stamp: 'cmm 10/26/2004 12:57'!packageAt: aMCVersionInfo ifAbsent: aBlock	^ codeBase		at: aMCVersionInfo		ifAbsent: aBlock! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 6/7/2004 15:36'!removeClassWithId: anInteger	classDefinitions removeKey: anInteger! !!MagmaRepositoryDefinition methodsFor: 'private' stamp: 'cmm 3/16/2005 12:44'!removeCollection: aMagmaLargeCollection	allLargeCollections remove: aMagmaLargeCollection! !!MagmaRepositoryRequest commentStamp: 'cmm 1/25/2003 17:56' prior: 0!Superclass for all Magma request objects.!!MaAbortTransactionRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:07'!process	^ self repository abortTransactionFor: sessionId! !!MaAbstractReadRequest methodsFor: 'building' stamp: 'cmm 6/4/2006 20:11'!readStrategy	^ readStrategy ! !!MaAbstractReadRequest methodsFor: 'building' stamp: 'cmm 9/1/2003 23:25'!readStrategy: aMaReadStrategy	readStrategy _ aMaReadStrategy! !!MaAbstractReadRequest methodsFor: 'accessing' stamp: 'cmm 3/30/2003 12:59'!waitCursor	^Cursor read! !!MaAnchorRequest commentStamp: 'cmm 1/25/2003 17:59' prior: 0!I'm the request used when you ask for the root.  The "real" root is actually an instance of MaRootAnchor, which references your root (this provides service via the standard commit mechanism).!!MaAnchorRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:09'!process	^ self repository		readAnchorFor: sessionId		using: readStrategy! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/4/2006 20:11'!collectionOid	^ collectionOid! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:50'!collectionOid: anInteger	collectionOid _ anInteger! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/4/2006 20:11'!quantity	^ quantity! !!MaLargeCollectionSegmentRequest methodsFor: 'accessing'!quantity: anInteger	quantity _ anInteger! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 21:24'!exceptions	^exceptions! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 22:32'!exceptions: aSet	exceptions := aSet! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!expression	^expression! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!expression: aMaTerm	expression := aMaTerm! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 7/29/2006 18:23'!loadObjects	^loadObjects! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 7/29/2006 18:23'!loadObjects: aBoolean	loadObjects := aBoolean! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/4/2006 20:12'!process	^ self repository refreshSegmentIn: self! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!segment	^segment! !!MaRefreshSegmentRequest methodsFor: 'accessing' stamp: 'cmm 6/3/2006 15:50'!segment: aMagmaCollectionSegment	segment := aMagmaCollectionSegment! !!MaSegmentByIndexRequest methodsFor: 'building'!lowIndex: anInteger	lowIndex _ anInteger! !!MaSegmentByIndexRequest methodsFor: 'actions' stamp: 'brp 6/14/2006 10:50'!process	^ self repository		upTo: quantity		oidsFromIndex: lowIndex		inLargeCollection: collectionOid		using: readStrategy		forSession: sessionId! !!MaReadRequest commentStamp: 'cmm 1/25/2003 17:58' prior: 0!I'm a request to a Magma server for a bunch of needed object buffers, due to proxy materialization or whatever.!!MaReadRequest methodsFor: 'accessing'!oid	^oid! !!MaReadRequest methodsFor: 'building'!oid: anInteger	oid _ anInteger! !!MaReadRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:11'!process	^ self repository		read: oid		for: sessionId		using: readStrategy! !!MaCloseRepositoryRequest methodsFor: 'as yet unclassified' stamp: 'cmm 4/30/2003 23:40'!process	repositoryController		signalRequestGuard;		close! !!MaCloseRepositoryRequest methodsFor: 'as yet unclassified' stamp: 'cmm 12/31/2002 15:28'!requiresConnection	^false! !!MaDownloadCodeRequest methodsFor: 'as yet unclassified' stamp: 'cmm 10/26/2004 21:54'!process	^ repositoryController codeBaseByteArray! !!MaDownloadCodeRequest methodsFor: 'as yet unclassified' stamp: 'cmm 12/31/2002 15:26'!requiresConnection	^false! !!MaKeyIntervalInfoRequest commentStamp: '<historical>' prior: 0!This request is used to get sizes of sub-magmacollections, either with or withoutindex.!!MaKeyIntervalInfoRequest methodsFor: 'accessing'!attribute	^attribute! !!MaKeyIntervalInfoRequest methodsFor: 'building'!attribute: aSymbol	attribute _ aSymbol! !!MaKeyIntervalInfoRequest methodsFor: 'accessing'!highKey	^highKey! !!MaKeyIntervalInfoRequest methodsFor: 'building'!highKey: anInteger	highKey _ anInteger! !!MaKeyIntervalInfoRequest methodsFor: 'accessing'!lowKey	^lowKey! !!MaKeyIntervalInfoRequest methodsFor: 'building'!lowKey: anInteger	lowKey _ anInteger! !!MaKeyIntervalInfoRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:31'!process	^ self repository		numberOfEntriesFrom: lowKey		to: highKey		inLargeCollection: collectionOid		on: attribute! !!MaLargeCollectionSizeRequest methodsFor: 'building'!collectionOid: anInteger	collectionOid _ anInteger! !!MaLargeCollectionSizeRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:29'!process	^ self repository sizeOfLargeCollection: collectionOid! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:18'!collection	^collection! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:18'!collection: aMagmaCollection	collection := aMagmaCollection! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/2/2006 23:43'!distinct	^ distinct! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/2/2006 23:43'!distinct: aBoolean	distinct _ aBoolean! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/3/2006 12:55'!expression	^ expression! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 7/3/2006 12:55'!expression: aMagmaCollectionReader	expression := aMagmaCollectionReader! !!MaLoadFromReaderRequest methodsFor: '*magma server' stamp: 'cmm 7/3/2006 13:00'!process	^ self repository 		load: collection		using: expression		from: sourceCollectionOid		forSession: sessionId		distinct: distinct! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:50'!sourceCollectionOid	^sourceCollectionOid! !!MaLoadFromReaderRequest methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:51'!sourceCollectionOid: anInteger	sourceCollectionOid := anInteger! !!MaLoadProgressRequest methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:59'!collectionOid	^collectionOid! !!MaLoadProgressRequest methodsFor: 'accessing' stamp: 'cmm 7/26/2006 17:59'!collectionOid: anInteger	collectionOid := anInteger! !!MaLoadProgressRequest methodsFor: '*magma server' stamp: 'cmm 7/26/2006 20:26'!process	^ self repository fractionLoaded: collectionOid! !!MaReaderTrunkRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 18:34'!collectionOid: aMaTerm	collectionOid := aMaTerm! !!MaReaderTrunkRequest methodsFor: 'accessing' stamp: 'cmm 8/6/2006 18:33'!expression: aMaTerm	expression := aMaTerm! !!MaReaderTrunkRequest methodsFor: '*magma server' stamp: 'cmm 8/6/2006 18:29'!process	^ self repository 		getTrunkFor: collectionOid		expression: expression! !!MaRepositoryConnectionRequest methodsFor: 'accessing' stamp: 'cmm 12/30/2002 23:20'!magmaVersion	^magmaVersion! !!MaRepositoryConnectionRequest methodsFor: 'building' stamp: 'cmm 12/30/2002 23:20'!magmaVersion: anInteger	magmaVersion _ anInteger! !!MaRepositoryConnectionRequest methodsFor: 'actions' stamp: 'cmm 12/26/2004 22:37'!process	MagmaSession magmaVersion = magmaVersion		ifFalse:			[ MagmaUserError signal:				'This server is running Magma version ', MagmaSession magmaVersion printString, '.  You may not connect with version ', magmaVersion printString, ' of the client code.  You may be able to install the code using browseCode.' ].	^ repositoryController newSessionFor: userId! !!MaRepositoryConnectionRequest methodsFor: 'testing' stamp: 'cmm 12/31/2002 15:27'!requiresConnection	^false! !!MaRepositoryConnectionRequest methodsFor: 'building'!userId: aString	userId _ aString! !!MaRepositoryDisconnectRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:15'!process	self repository removeSessionFor: sessionId.	^ nil! !!MaTransactionRequest methodsFor: 'actions' stamp: 'cmm 12/17/2002 11:13'!process	^repositoryController newTransactionFor: sessionId! !!MaWriteRequest commentStamp: 'cmm 1/25/2003 17:55' prior: 0!I am the request object sent to a Magma server that commits changes to the database.!!MaWriteRequest methodsFor: 'building' stamp: 'cmm 4/21/2003 17:04'!beginAnother: aBoolean	beginAnother _ aBoolean! !!MaWriteRequest methodsFor: 'accessing'!package	^package! !!MaWriteRequest methodsFor: 'building'!package: aMaCommitPackage	package _ aMaCommitPackage! !!MaWriteRequest methodsFor: 'actions' stamp: 'cmm 5/14/2005 18:15'!process	^ self repository		submitAll: package		for: sessionId		beginAnother: beginAnother! !!MaWriteRequest methodsFor: 'accessing' stamp: 'cmm 3/30/2003 12:59'!waitCursor	^Cursor write! !!MagmaIdRequest methodsFor: 'as yet unclassified' stamp: 'cmm 1/14/2005 16:05'!process	^ repositoryController magmaId! !!MagmaIdRequest methodsFor: 'as yet unclassified' stamp: 'cmm 1/14/2005 15:32'!requiresConnection	^ false! !!MagmaPathNameRequest methodsFor: 'as yet unclassified' stamp: 'cmm 9/24/2004 15:13'!process	^ repositoryController pathName! !!MagmaPathNameRequest methodsFor: 'as yet unclassified' stamp: 'cmm 9/19/2004 22:58'!requiresConnection	^ false! !!MagmaRepositoryRequest methodsFor: 'actions'!process	"Any persistent objects returned by this should be materialized only by the sessions	serializer, not the repositoryLink's serializer because the sessions serializer is what	works with the transaction to mark it read so changes can be detected."	self subclassResponsibility! !!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 5/14/2005 18:07'!repository	^ repositoryController repository! !!MagmaRepositoryRequest methodsFor: 'building' stamp: 'cmm 7/5/2004 11:57'!repositoryController: aMagmaRepositoryController	repositoryController _ aMagmaRepositoryController! !!MagmaRepositoryRequest methodsFor: 'testing' stamp: 'cmm 12/31/2002 15:26'!requiresConnection	^true! !!MagmaRepositoryRequest methodsFor: 'private'!sessionId	^sessionId! !!MagmaRepositoryRequest methodsFor: 'accessing'!sessionId: anInteger	sessionId _ anInteger! !!MagmaRepositoryRequest methodsFor: 'accessing' stamp: 'cmm 10/11/2004 12:29'!waitCursor	^Cursor wait! !!MagmaServerPreferences class methodsFor: 'debugging' stamp: 'cmm 6/9/2005 21:42'!debugRecovery	^ DebugRecovery! !!MagmaServerPreferences class methodsFor: 'debugging' stamp: 'cmm 6/9/2005 21:42'!debugRecovery: aBoolean	DebugRecovery _ aBoolean! !!MagmaServerPreferences class methodsFor: 'debugging' stamp: 'cmm 6/9/2005 22:06'!initialize	self debugRecovery: false! !!MagmaServerPreferences methodsFor: 'security' stamp: 'cmm 6/6/2005 13:35'!beReadOnly	self 		setAttribute: #isReadOnly		to: true! !!MagmaServerPreferences methodsFor: 'security' stamp: 'cmm 6/6/2005 13:35'!beReadWrite	self 		setAttribute: #isReadOnly		to: false! !!MagmaServerPreferences methodsFor: 'recovery' stamp: 'cmm 7/18/2005 12:48'!cacheFlushFrequency	^ self		valueOfAttribute: #cacheFlushFrequency		ifAbsent: [ 5 "seconds" ]! !!MagmaServerPreferences methodsFor: 'recovery' stamp: 'cmm 7/5/2005 20:18'!cacheFlushFrequency: anInteger	self		setAttribute: #cacheFlushFrequency		to: anInteger! !!MagmaServerPreferences methodsFor: 'recovery' stamp: 'cmm 7/7/2005 23:21'!flushAggressively	^ self 		valueOfAttribute: #flushAggressively		ifAbsent: [ false ]! !!MagmaServerPreferences methodsFor: 'recovery' stamp: 'cmm 7/12/2005 13:10'!flushAggressively: aBoolean	self		setAttribute: #flushAggressively		to: aBoolean! !!MagmaServerPreferences methodsFor: 'initialize' stamp: 'cmm 6/6/2005 13:05'!initialize	super initialize.	attributes _ Dictionary new! !!MagmaServerPreferences methodsFor: 'security' stamp: 'cmm 6/6/2005 13:44'!isReadOnly	^ self 		valueOfAttribute: #isReadOnly		ifAbsent: [ false ]! !!MagmaServerPreferences methodsFor: 'private' stamp: 'cmm 6/6/2005 13:07'!setAttribute: attributeSymbol to: value	attributes		at: attributeSymbol		put: value! !!MagmaServerPreferences methodsFor: 'private' stamp: 'cmm 6/6/2005 13:09'!valueOfAttribute: attributeSymbol ifAbsent: aBlock	^ attributes 		at: attributeSymbol		ifAbsent: aBlock! !!MaReadResult class methodsFor: 'as yet unclassified' stamp: 'cmm 12/16/2002 21:18'!byteArray: aByteArray	^self new byteArray: aByteArray; yourself! !!MaReadResult methodsFor: 'accessing' stamp: 'cmm 12/16/2002 21:18'!byteArray	^byteArray! !!MaReadResult methodsFor: 'private' stamp: 'cmm 12/17/2002 00:49'!byteArray: aByteArray	byteArray _ aByteArray! !!MaReducedReaderResult methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:13'!collectionOid	^collectionOid! !!MaReducedReaderResult methodsFor: 'accessing' stamp: 'cmm 6/11/2006 21:13'!collectionOid: anInteger	collectionOid := anInteger! !!MaCommitResult commentStamp: '<historical>' prior: 0!This class is instantiated on the server and returned to the client.!!MaCommitResult methodsFor: 'converting' stamp: 'cmm 5/2/2005 22:20'!asFailedResult	^ MaFailedCommitResult new		serverNotifications: serverNotifications ;		permanentOids: self permanentOids ;		toBeRefreshed: toBeRefreshed ;		connection: connection ;		yourself! !!MaCommitResult methodsFor: 'building' stamp: 'cmm 10/10/2004 21:46'!changedObjectBuffers: aDictionary	changedObjectBuffers _ aDictionary! !!MaCommitResult methodsFor: 'testing'!hasConflicts	^false! !!MaCommitResult methodsFor: 'initializing' stamp: 'cmm 7/11/2005 12:56'!initialize	super initialize.	newObjectBuffers _ Dictionary new.	changedObjectBuffers _ Dictionary new! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 5/9/2005 22:47'!newObjectBuffers	^ newObjectBuffers! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:35'!permanentOids	"A Dictionary.  Key is the new-object oid, value is the permanent oid."	^ permanentOids! !!MaCommitResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:35'!permanentOids: aDictionary	"A Dictionary.  Key is the new-object oid, value is the permanent oid."	permanentOids _ aDictionary! !!MaCommitResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 15:03'!postTrimmedCopy	super postTrimmedCopy.	changedObjectBuffers _ nil! !!MaCommitResult methodsFor: 'building' stamp: 'cmm 5/9/2005 22:45'!recordNewObjectBuffer: aMaObjectBuffer	newObjectBuffers 		at: aMaObjectBuffer oid		put: aMaObjectBuffer! !!MaCommitResult methodsFor: 'actions' stamp: 'cmm 12/2/2004 13:36'!refresh: aMagmaSession	aMagmaSession assignPermanentOidsFrom: permanentOids.	super refresh: aMagmaSession.	aMagmaSession		recordObjects: newObjectBuffers ;		recordObjects: changedObjectBuffers! !!MaFailedCommitResult methodsFor: 'converting'!asFailedResult	^self! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 6/26/2002 22:16'!commitConflicts	^commitConflicts! !!MaFailedCommitResult methodsFor: 'accessing' stamp: 'cmm 11/25/2003 00:22'!conflictMessage	"This method demonstrates how the structure of a MaCommitResult might be utilized to	provide a message to an end-user."	| message |	message _ MaTextMessage new.	commitConflicts do:		[ :each |		message			append: each connection userId;			append: ' has committed changes to ';			appendProperlyPluralized: 'object'				for: each conflictingOids size;			append: ' with ';			appendProperlyPluralized: 'oid'				for: each conflictingOids size;			space;			appendAndedList: each conflictingOids;			append: '; ' ].	message append:		' while you were working on those same objects.  Please review and reapply your changes if necessary.'.	^message messageText! !!MaFailedCommitResult methodsFor: 'testing'!hasConflicts	^true! !!MaFailedCommitResult methodsFor: 'initializing' stamp: 'cmm 12/24/2002 15:42'!initialize	super initialize.	commitConflicts _ OrderedCollection new! !!MaFailedCommitResult methodsFor: 'building' stamp: 'cmm 6/26/2002 00:33'!populateConflictingObjectsFromOidsUsing: aMaObjectSerializer	commitConflicts do: [ :each | each initializeConflictingObjectsUsing: aMaObjectSerializer ]! !!MaFailedCommitResult methodsFor: 'building' stamp: 'cmm 10/15/2004 16:19'!recordObjectConflictWith: aMagmaClientConnection on: oidInteger	(commitConflicts		detect: [ : each | each conflictingConnection = aMagmaClientConnection ]		ifNone: [ commitConflicts add: (MagmaCommitConflict connection: aMagmaClientConnection) ])			addConflictingOid: oidInteger.	^ self! !!MaRefreshViewResult methodsFor: 'building' stamp: 'cmm 10/15/2004 16:54'!addToBeRefreshed: aDictionary	"aDictionary the containing the MaObjectBuffers that were committed by other sessions, keyed by their oid."	toBeRefreshed addAll: aDictionary"NOTE:  I've considered a performance improvement of adding just the entire aDictionary and then require clients to deal with an OrderedCollection of Dictionaries of MaObjectLinks but..  spinning aDictionary is really unavoidable because it would have to be serialized anyway.  Rebuilding those Dictionaries on the client-side is more expensive than just making an OrderedCollection."! !!MaRefreshViewResult methodsFor: 'initializing' stamp: 'cmm 7/16/2002 21:25'!connection	^connection! !!MaRefreshViewResult methodsFor: 'building' stamp: 'cmm 7/16/2002 21:22'!connection: aMagmaClientConnection	connection _ aMagmaClientConnection! !!MaRefreshViewResult methodsFor: 'initializing' stamp: 'cmm 6/20/2004 20:32'!initialize	super initialize.	self toBeRefreshed: (Dictionary new: 50)! !!MaRefreshViewResult methodsFor: 'accessing' stamp: 'cmm 12/2/2004 13:52'!permanentOids	^nil! !!MaRefreshViewResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 14:48'!postTrimmedCopy	super postTrimmedCopy.	connection _ nil.	toBeRefreshed _ nil! !!MaRefreshViewResult methodsFor: 'actions' stamp: 'cmm 2/18/2006 12:57'!refresh: aMagmaSession	aMagmaSession		refreshChangedObjects: toBeRefreshed! !!MaRefreshViewResult methodsFor: 'accessing'!sessionId	^self connection sessionId! !!MaRefreshViewResult methodsFor: 'building' stamp: 'cmm 10/8/2004 16:52'!toBeRefreshed: aDictionary	toBeRefreshed _ aDictionary! !!MaRefreshViewResult methodsFor: 'accessing'!userId	^self connection userId! !!MagmaLargeCollectionSegment commentStamp: 'cmm 12/1/2004 21:44' prior: 0!I represent a "page" of objects in a MagmaCollection.!!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 15:44'!adjustLastKnownSize: anInteger 	self lastKnownSize ifNotNil: [ self lastKnownSize: self lastKnownSize - anInteger ]! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/29/2006 15:45'!advanceEnd: count 	endIndex _ endIndex + count.	mergedCount _ mergedCount + count.	lastKnownSize ifNotNil: [ lastKnownSize _ lastKnownSize + count ]! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/29/2006 09:55'!advanceStart: count	startIndex _ startIndex + count.	self advanceEnd: count! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 7/20/2006 00:29'!atEnd	"Answer whether I contain the last element that satisfies the original expression."	^ trunkEnd isNil "empty" 	or: [ lastKnownSize notNil ]! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	"Answer the index within the large-collection or reader of the last element in the receivers objects collection."	^ endIndex! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex: anInteger	endIndex _ anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/7/2006 23:25'!highestKey	^highestKey! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/7/2006 23:25'!highestKey: anInteger	highestKey := anInteger! !!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 09:59'!initialize	super initialize.	highestKey _ 1 bitShift: 256.	self resetMergedCount! !!MagmaCollectionReaderSegment methodsFor: 'testing' stamp: 'cmm 7/10/2006 23:30'!isFitted	"Answer whether I've been loaded with a valid range by the server."	^ trunkEnd notNil! !!MagmaCollectionReaderSegment methodsFor: 'printing' stamp: 'cmm 8/2/2006 20:40'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	lastKnownSize ifNotNil: 		[ aStream			maPrint: ' of ' ;			maPrint: lastKnownSize ].	aStream		maPrint: ' ²' ;		maPrint: mergedCount! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/29/2006 09:55'!mergedCount	^ mergedCount! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/19/2006 10:44'!nextSegment	"In an empty MagmaCollection, we can't have any real segments, just one with no trunkEnd, so no need to try to get the 'next' one until we get our first valid one."	^ self isFitted 		ifTrue: 			[ (MagmaCollectionReaderSegment new)				startIndex: endIndex + 1 ;				trunkStart: trunkEnd + 1 ;				trunk: trunk ;				yourself ]		ifFalse: [ self ]! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 6/8/2006 12:47'!refreshFrom: anotherMagmaCollectionReaderSegment 	"I prefer this to become:.."	1 		to: self class instSize		do: 			[ : n | 			self 				instVarAt: n				put: (anotherMagmaCollectionReaderSegment instVarAt: n) ]! !!MagmaCollectionReaderSegment methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 09:56'!resetMergedCount	mergedCount _ 0! !!MagmaCollectionReaderSegment methodsFor: 'private' stamp: 'cmm 7/15/2006 15:14'!sortObjects: aMagmaCollectionIndex 	objects maIsSortedCollection ifFalse: 		[ objects _ objects asSortedCollection: aMagmaCollectionIndex ascendingSortBlock ]! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/5/2006 23:38'!trunk	^ trunk ! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 6/5/2006 23:38'!trunk: aMaQueryTrunk	trunk _ aMaQueryTrunk! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:32'!trunkEnd	"The query trunk can be accessed by logical index position.  Answer the end position within the trunk of this segment."	^ trunkEnd! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:31'!trunkEnd: anInteger 	trunkEnd _ anInteger! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:33'!trunkStart	"The query trunk can be accessed by logical index position.  Answer the start position within the trunk of this segment."	^ trunkStart! !!MagmaCollectionReaderSegment methodsFor: 'accessing' stamp: 'cmm 7/10/2006 23:31'!trunkStart: anInteger 	"of the query trunk"	trunkStart _ anInteger! !!MagmaCollectionSegment methodsFor: 'testing' stamp: 'cmm 6/6/2006 00:05'!atEnd	^ self endIndex = lastKnownSize! !!MagmaCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	^ startIndex + objects size - 1! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:02'!actualPageSize	^ self endIndex - startIndex + 1! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 5/31/2006 12:35'!addObject: anObject	objects add: anObject! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 7/8/2002 12:40'!at: anInteger	^objects at: anInteger - startIndex + 1! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 6/5/2006 23:25'!atEnd	self subclassResponsibility! !!MagmaLargeCollectionSegment methodsFor: '*magma server-private' stamp: 'cmm 4/12/2006 21:15'!collectBuffers: sessionId from: aMaObjectRepository using: aMaReadStrategy 	| readStrategy |	readStrategy _ aMaObjectRepository 		ensureReadStrategy: aMaReadStrategy		forSession: sessionId.	self objects: 		(self objects collect: 			[ : each | 			aMaObjectRepository 				byteArrayAt: each				using: readStrategy ])! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 6/6/2006 00:00'!endIndex	self subclassResponsibility ! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 6/6/2006 00:02'!includesIndex: anInteger 	"Answer whether logical anInteger-index falls within the range of indices currently covered by my 'objects'."	^ anInteger 		between: startIndex		and: self endIndex! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 7/4/2006 15:05'!includesObject: anObject	^ objects includes: anObject! !!MagmaLargeCollectionSegment methodsFor: 'initialize-release' stamp: 'cmm 6/4/2006 20:53'!initialize	super initialize.	self initializeObjects! !!MagmaLargeCollectionSegment methodsFor: 'initialize-release' stamp: 'cmm 6/4/2006 20:53'!initializeObjects	objects _ OrderedCollection new! !!MagmaLargeCollectionSegment methodsFor: 'testing' stamp: 'cmm 4/15/2005 10:05'!isEmpty	^ objects isEmpty! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 7/20/2006 00:21'!lastKnownSize	^ lastKnownSize! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 7/20/2006 00:22'!lastKnownSize: anInteger	lastKnownSize _ anInteger! !!MagmaLargeCollectionSegment methodsFor: 'printing' stamp: 'cmm 7/29/2006 18:13'!maPrintAbbreviatedOn: aStream 	super maPrintAbbreviatedOn: aStream.	aStream		space ;		maPrint: startIndex ;		maPrint: '..' ;		maPrint: self endIndex ! !!MagmaLargeCollectionSegment methodsFor: 'accessing'!objects	^objects! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 4/17/2005 22:11'!objects: aSequenceableCollection	objects _ aSequenceableCollection! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 6/9/2006 16:43'!removeObject: anObject 	objects 		remove: anObject		ifAbsent: [ "do nothing" ]! !!MagmaLargeCollectionSegment methodsFor: 'accessing' stamp: 'cmm 3/22/2005 10:20'!startIndex	"Answers the logical index within the range of indices applicable to my Readers specified range."	^ startIndex! !!MagmaLargeCollectionSegment methodsFor: 'building' stamp: 'cmm 6/4/2006 16:48'!startIndex: anInteger	"Set the index position within the result set."	startIndex _ anInteger! !!MagmaServerResult methodsFor: 'testing' stamp: 'cmm 1/28/2005 00:14'!hasServerNotifications	^ serverNotifications isEmptyOrNil not! !!MagmaServerResult methodsFor: 'testing' stamp: 'cmm 1/28/2005 00:15'!isMagmaServerResult	^ true! !!MagmaServerResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 14:23'!postTrimmedCopy	serverNotifications _ nil! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 21:53'!serverNotifications	^ serverNotifications! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 21:54'!serverNotifications: aDictionary	serverNotifications _ aDictionary! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 22:01'!shouldRefresh	"So many results do not need serverNotifications; therefore we do not keep a separate boolean variable for shouldRefresh that otherwise needs to be sent over the wire 1% of the time."	^ serverNotifications includesKey: #shouldRefresh! !!MagmaServerResult methodsFor: 'accessing' stamp: 'cmm 1/18/2005 21:54'!shouldRefresh: aBoolean	aBoolean ifTrue:		[ serverNotifications 			at: #shouldRefresh			put: true ]! !!MagmaServerResult methodsFor: 'copying' stamp: 'cmm 7/15/2005 14:23'!trimmedCopy	^ self copy postTrimmedCopy! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 21:49'!decrementRequestsQueued	requestsQueuedStat last: requestsQueuedStat last - 1! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 21:50'!decrementSocketsQueued	socketsQueuedStat last: socketsQueuedStat last - 1! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 21:47'!incrementRequestsQueued	requestsQueuedStat addValue: 1 + requestsQueuedStat last! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 21:47'!incrementSocketsQueued	socketsQueuedStat addValue: socketsQueuedStat last + 1! !!MagmaServerStatistics methodsFor: 'initializing' stamp: 'cmm 11/16/2004 21:50'!initialize	super initialize.	stopwatch _ MaStopwatch new.	socketsQueuedStat _ MaStat new last: 0.	requestsQueuedStat _ MaStat new last: 0.	requestSizeStat _ MaStat new last: 0.	requestProcessingTimeStat _ MaStat new last: 0.	responseSizeStat _ MaStat new last: 0! !!MagmaServerStatistics methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:29'!printOn: aStream	super printOn: aStream.	aStream		cr; tab;		nextPutAll: 'sockets queued: ';		maPrintAbbreviated: socketsQueuedStat;		cr; tab;		nextPutAll: 'requests queued:  ';		maPrintAbbreviated: requestsQueuedStat;		cr; tab;		nextPutAll: 'request sizes:  ';		maPrintAbbreviated: requestSizeStat;		cr; tab;		nextPutAll: 'request processing time:  ';		maPrintAbbreviated: requestProcessingTimeStat;		cr; tab;		nextPutAll: 'response sizes:  ';		maPrintAbbreviated: responseSizeStat! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 10:51'!recordRequestSize: anInteger	requestSizeStat addValue: anInteger! !!MagmaServerStatistics methodsFor: 'counting' stamp: 'cmm 11/16/2004 10:51'!recordResponseSize: anInteger	responseSizeStat addValue: anInteger! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 1/27/2004 16:20'!requestProcessingTimeStat	^requestProcessingTimeStat! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 1/27/2004 16:20'!requestSizeStat	^requestSizeStat! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 1/27/2004 16:20'!requestsQueuedStat	^requestsQueuedStat! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 1/27/2004 16:20'!responseSizeStat	^responseSizeStat! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 1/27/2004 16:20'!socketsQueuedStat	^socketsQueuedStat! !!MagmaServerStatistics methodsFor: 'actions' stamp: 'cmm 1/5/2003 22:57'!startRequestTimer	stopwatch reset; start! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 7/1/2004 00:34'!startTime	^ startTime! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 10/6/2002 23:23'!startTime: aMaCalendarTime	startTime _ aMaCalendarTime! !!MagmaServerStatistics methodsFor: 'actions' stamp: 'cmm 11/16/2004 10:52'!stopRequestTimer	stopwatch stop.	requestProcessingTimeStat addValue: stopwatch time! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 7/1/2004 00:34'!stopTime	^ stopTime! !!MagmaServerStatistics methodsFor: 'accessing' stamp: 'cmm 10/7/2002 00:33'!stopTime: aMaCalendarTime	stopTime _ aMaCalendarTime! !!MagmaSession commentStamp: 'cmm 2/25/2005 16:01' prior: 0!This is a clients primary interface to a Magma repository.!!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 7/18/2005 10:52'!cleanUp	"References to MagmaSessions get stuck in old MethodContext's, preventing garbage-collection.  Run this method and these instances will be cleaned."	| before after |	self disconnectAndCloseAllConnectedSessions.	Smalltalk garbageCollect.	before _ self instanceCount.	self allInstances do: [ : each | each becomeForward: nil copyHash: false ].	Smalltalk garbageCollect.	self allInstances do:		[ : each |		(PointerFinder pointersTo: each)			do:				[ : referencer | 				referencer class == MethodContext ifTrue: [ referencer receiver: nil ] ] ].	Smalltalk garbageCollect.	after _ self instanceCount.SystemNavigation default allObjectsDo: [ : e | ((e class inheritsFrom: Object) and: [ e isBehindWriteBarrier ]) ifTrue: [ Transcript cr; show: 'fixing ', e printString. e primitiveChangeClassTo: e class superclass basicNew ] ].	^ 'MagmaSession instances (before->after):  ', (before->after) printString! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 7/2/2004 12:58'!connectedSessions	^ ConnectedSessions! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 1/17/2005 14:53'!disconnectAndCloseAllConnectedSessions	ConnectedSessions ifNotNil:		[ ConnectedSessions copy do: [ : each | each disconnectAndClose ] ]! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 10/27/2004 12:23'!host: hostName port: anInteger	^ self		hostAddress: (NetNameResolver addressForName: hostName)		port: anInteger! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 12/26/2004 23:26'!hostAddress: aByteArray port: anInteger	^ self link:		(MaTcpRequestServerLink			hostAddress: aByteArray			port: anInteger)! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 10/27/2004 15:32'!initialize	self disconnectAndCloseAllConnectedSessions.	ConnectedSessions _ Set new.	Smalltalk		addToStartUpList: self;		addToShutDownList: self! !!MagmaSession class methodsFor: 'creation' stamp: 'cmm 12/26/2004 23:12'!link: aMaServerLink	^ self new		link: aMaServerLink ;		yourself! !!MagmaSession class methodsFor: 'accessing' stamp: 'cmm 9/11/2006 21:51'!magmaVersion	"Version 7 requires a new format for hash-index files (*.hdx) where we have added the 'control' field to each slot, to indicate whether the slot is occupied or free."	"Version 7 was never released, but I want to make sure we signal an error for any db created with 7 since its indexes should not be trusted.  Version 8 corrects a bug with version 7 removing an entry from a MaHashIndex that would leave the index inconsistent."	^ 8! !!MagmaSession class methodsFor: 'maui' stamp: 'cmm 1/26/2004 15:14'!mauiBasicApi	^#(hostAddress:port: openLocal:)! !!MagmaSession class methodsFor: '*magma server-private' stamp: 'cmm 2/8/2005 21:44'!newLocalLinkFor: aMagmaRepositoryController	^ MaLocalServerLink localRequestServer: (MaLocalRequestServer processor: aMagmaRepositoryController)! !!MagmaSession class methodsFor: '*magma server' stamp: 'cmm 10/26/2004 12:48'!openLocal: pathString	^ self repositoryController: (MagmaRepositoryController openedOn: pathString)! !!MagmaSession class methodsFor: '*magma server' stamp: 'cmm 12/26/2004 23:21'!repositoryController: aMagmaRepositoryController	"Use this constructor only for *additional* local connections, i.e., two or more sessions connected to the same local repository.  Use the same MagmaRepositoryController you used to create the original."	^ self link: (self newLocalLinkFor: aMagmaRepositoryController)! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 12/27/2004 23:16'!shutDown: aboutToQuit	super shutDown: aboutToQuit.	ConnectedSessions		do:			[ : each |			each isConnected				ifTrue:					[ each primDisconnect ] ]! !!MagmaSession class methodsFor: 'initializing' stamp: 'cmm 12/28/2004 10:57'!startUp: amResuming	super startUp: amResuming.	"We must ensure the servers are opened before we try to connect."	(Smalltalk hasClassNamed: #MagmaRepositoryController)		ifTrue:			[ (Smalltalk classNamed: #MagmaRepositoryController) startUp: amResuming ].	ConnectedSessions copy 		do:			[ :each |			[ each primConnect ]				on: MaEnvironmentError				do: [ : error | each disconnect ] ]! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 7/14/2005 21:43'!abort	"This guard is needed for when we initially connect to the repository because we can't abort before the connection is made."	self isConnected		ifTrue:			[ self 				dropStrongReferences ;				resetTransactionLevel.			preferences refreshPersistentObjectsEvenWhenChangedOnlyByMe				ifTrue: [ transaction restore ].			self refresh ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 3/16/2005 12:43'!addLargeCollection: aMagmaCollection	aMagmaCollection session ifNotNil: [ MagmaUserError signal: 'LargeCollections cannot be shared with other repositories.' ].	definition addLargeCollection: aMagmaCollection.	aMagmaCollection setOid: (self oidFor: aMagmaCollection).	transaction monitorLargeCollectionChanges: aMagmaCollection changes! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 7/18/2005 13:06'!allowWriteBarrier: aBoolean	| cleanUpNeeded |	transaction validateWriteBarrier: aBoolean.	cleanUpNeeded _ aBoolean not and: [ preferences allowWriteBarrier ].	preferences allowWriteBarrier: aBoolean.	cleanUpNeeded		ifTrue:			[ self cleanUpWriteBarrier ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/26/2004 23:01'!anchor	^ anchor		ifNil:			[ | anch |			anch _ self materializeAnchorFrom: 				(self submit:					(MaAnchorRequest new						readStrategy: self resetReadStrategy ;						yourself)).			"avoid the root getting garbage collected before we can capture the changes because the user wrote mySession commit: [ mySession root at: 'hello' put: 'world' ]."			anchor _ self inTransaction ifTrue: [ anch ] "otherwise, nil it out".			anch ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/16/2005 12:38'!assignPermanentOidsFrom: permanentOidsDictionary	permanentOidsDictionary ifNil: [ ^ self ].	permanentOidsDictionary keysAndValuesDo:		[ : eachTempOid : eachPermanentOid |		serializer			objectWithOid: eachTempOid			ifFound: 				[ : persistentObject | 				serializer					oidOf: persistentObject					is: eachPermanentOid.				persistentObject maIsLargeCollection ifTrue: [ persistentObject setOid: eachPermanentOid ] ]			ifAbsent: [ nil ] ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/18/2005 10:53'!becomeForward: anotherSession	"We hate to use become, but this time it seems the best approach.  When a session is disconnected (such as when saving the image), there may be objects in the image that still reference it such as proxies or a MagmaCollection.  When these objects are provoked, their session should reconnect automatically, but there may already be another MagmaSession instance connected to the same repository under the same id.  Under this case, we simply becomeForward: the stale session to the connected one.  (Hmm, maybe we should have two sessions).	But this is only one of the steps that is needed.  Because the newly connected session will have its own new instances of MagmaCollections, *my* MagmaCollections must each be individually becomed to the ones in the connected session, otherwise the new session will think they're new MagmaCollections even though they're not."	| needToRehash |	(anotherSession isKindOf: self class) ifFalse: [ ^ super becomeForward: anotherSession ].	needToRehash _ false.	definition allLargeCollections do:		[ : each |		anotherSession definition allLargeCollections			maDetect: [ : eachOther | each changes collectionOid = eachOther changes collectionOid ]			ifFound:				[ : foundOther | each becomeForward: foundOther.				needToRehash _ true ]			ifNone:				[ "This is probably a bad marriage..  Perhaps we should just stop."				MagmaNotification signal: 'No matching MagmaCollection with oid ', each changes collectionOid printString, ' in connected session.  Assuming this collection was dereferenced.' ] ].	needToRehash ifTrue: [ anotherSession serializer rehashOids ].	super becomeForward: anotherSession.	self class connectedSessions rehash! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 12/26/2004 23:09'!begin	| refreshViewResult |	self incrementTransactionLevel.	self inNestedTransaction ifTrue: [ ^ self ].	refreshViewResult _ self submit: MaTransactionRequest new.	preferences refreshPersistentObjectsEvenWhenChangedOnlyByMe		ifTrue:			[ transaction restore ].	self refreshViewUsing: refreshViewResult! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/23/2003 13:08'!cachedObjectCount	"Answers how many persistent objects from this repository are in memory.  Your program should be careful not to reference too-large object structures at a time, or these cache Dictionaries will become large and slower."	^serializer oidCount! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 5/8/2003 13:48'!cachedObjectCountByClass	^serializer cachedObjectCountByClass! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/18/2005 14:07'!canStubOut: anObject 	anObject maIsMutatingProxy ifTrue: [^false].	(self isPersistent: anObject) ifFalse: [^false].	anObject maOriginalClass = MaClassDefinition ifTrue: [^false].	anObject == serializer classIdManager classDefinitionsById 		ifTrue: [^false].	^ serializer classIdManager classDefinitionsById 		noneSatisfy: [ : eachCollection | eachCollection == anObject ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 1/5/2005 22:08'!cleanUp	self maMarked: 'hack'.	"MethodContexts seem to keep hold of their last execution state, causing MagmaSessions to not be able to be garbage collected, unless we clear out their receiver.  Why is this a problem?"		"Hmm..  Gonna comment this out until I understand it better.  It seems we could potentially nil out the receiver on a context that is part of the execution stack.Until I figure or someone can tell me, use my class-side method, MagmaSession cleanUp.""	(Smalltalk pointersTo: self)		do:			[ : referencer | 			referencer class == MethodContext ifTrue: [ referencer receiver: nil ] ].	Smalltalk garbageCollect"		"This is the prior method of cleaning proxies.  Very slow..""	MagmaNotification signal: 'Cleaning proxies, please wait...'.	Transcript cr; show: 'cleaning ', MaOdbmsProxy allInstances size printString, ' proxies..'.	MaOdbmsProxy allInstances do: [ : each | each session id = id ifTrue: [ each becomeForward: nil copyHash: false ] ]."! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 16:09'!cleanUpWriteBarrier	transaction cleanUpWriteBarrier.	serializer objectsDo:		[ : each |		(each isBehindWriteBarrier and: [ each writeBarrier == transaction ])			ifTrue:				[ transaction remove: each ] ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 12/26/2004 22:58'!closeRepository	self isLocal ifFalse: [ MaUserError signal: 'Only available during local connections.' ].	self isConnected ifTrue: [ self disconnect ].	self submit: MaCloseRepositoryRequest new! !!MagmaSession methodsFor: 'code base' stamp: 'cmm 10/26/2004 22:12'!codeBase	^ definition codeBase! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 4/21/2003 14:18'!commit	self commitAndBegin: false! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 12/26/2004 00:23'!commit: aBlock	| result |	self begin.	result _ aBlock value.	self commit.	^result! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 4/21/2003 14:22'!commitAndBegin	self commitAndBegin: true! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 7/12/2006 22:01'!commitAndBegin: aBoolean	"Calls submitAll:for:beginAnother:"	| commitPackage commitResult |	self isConnected ifFalse: [ MagmaUserError signal: 'Must connect before you can commit.' ].	self inNestedTransaction		ifTrue: 			[ "nested transaction commit, essentially does nothing"			self decrementTransactionLevel.			^ self ].	self inTransaction ifFalse: [ MagmaUserError signal: 'No transaction to commit.' ].	commitPackage _ self newCommitPackageFor: transaction.	[ [ self 		dropStrongReferences ;		resetTransactionLevel.	aBoolean ifTrue: [ self incrementTransactionLevel ].	commitResult _ 		self submit:			(MaWriteRequest new				package: commitPackage ;				beginAnother: aBoolean ;				yourself) ] ifCurtailed: [ self refreshDefinition ].			self resetMagmaCollectionChanges ]		on: MagmaCommitError		do:			[ :exception |			exception result populateConflictingObjectsFromOidsUsing: serializer.			self refreshViewUsing: exception result.			exception signal ].	(commitPackage hasNewIndexes or: [ commitPackage hasRemovedIndexes ])		ifTrue:			[ self				processNewAndRemovedIndexesIn: commitPackage				using: commitResult ]		ifFalse:			[ transaction resetCommitPackage.			self refreshViewUsing: commitResult]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 1/13/2005 23:57'!connect: aMagmaUser	self isConnected ifTrue: [ MagmaUserError signal: 'Already connected.' ].	user _ aMagmaUser.	self primConnect.	self isServerSession ifFalse: [ ConnectedSessions add: self ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 3/11/2005 13:21'!connectAs: aString	self connect: (MagmaUser id: aString)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:44'!decrementTransactionLevel	transactionLevel _ transactionLevel - 1! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 12/26/2004 23:32'!definition	"Answers the repository definition, a MagmaRepositoryDefinition."	^ definition! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 7/12/2005 13:38'!didChange: anObject	^ transaction didChange: anObject! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 5/1/2003 00:26'!disconnect	ConnectedSessions remove: self ifAbsent: [ "do nothing" ].	self primDisconnect! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 9/15/2004 22:18'!disconnectAndClose	self disconnect.	self isLocal ifTrue: [ self closeRepository ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/4/2005 16:31'!dropStrongReferences	anchor _ nil.	strongReferences _ OrderedCollection new! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/18/2005 10:53'!ensureConnected	"When stale proxies or MagmaCollections are provoked, ensure their session connects."	self isConnected		ifFalse:			[ MagmaNotification signal: 'Encountered disconnected session, looking for equivalent connection...'.			self class connectedSessions				maDetect:					[ : each | 					((each isSameRepositoryAs: self)					and:						[ each userId = self userId						or: [ each isLocal  "default to reuse, easier for users to understand"						or: [ each sharesAnyObjectsWith: self ] ] ]) ]				ifFound:					[ : foundSession |					MagmaNotification signal: 'Equivalent session found, connecting objects to use this one.'.					"A new session cannot be used, we must merge them."					self becomeForward: foundSession ]				ifNone:					[ MagmaNotification signal: 'no equivalent session found, reopening the stale session.'.					user ifNil:						[ user _ MagmaUserRequiredNotification requestUserFor: self.						user ifNil: [ MagmaUserError signal: 'A user to connect must be supplied.' ] ].					self connect: user ] ]! !!MagmaSession methodsFor: '*magma server' stamp: 'cmm 2/15/2005 10:51'!ensureOpen	self isLocal ifFalse: [ MagmaUserError signal: 'Only available for local connections.' ].	self isOpen ifFalse:		[ self link: (self class newLocalLinkFor: (MagmaRepositoryController openedOn: self pathName)) ]! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 1/21/2003 21:41'!finalizeOids	"Use this after you've agitated Squeaks garbage collector into finalizing the various identity dictionaries maintained by me.  May be useful for situations when your program creates a lot of garbage."	serializer finalizeOids.	transaction finalizeOids! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 8/6/2006 20:55'!fractionLoaded: aMagmaCollection 	^ self submit: (		(MaLoadProgressRequest new)			collectionOid: (self oidFor: aMagmaCollection) ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/26/2004 23:08'!getCode	"Answer the Dictionary of Streams that was manually installed in the server that can be browsed or filed-in to be able to connect to my repostory."	| code classesAndCode |	classesAndCode _ self submit: MaDownloadCodeRequest new.	self loadClassDefinitionsFrom: classesAndCode first.	code _ serializer materializeGraph: classesAndCode last.	^code! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 8/6/2006 20:54'!getTrunkFor: aMagmaCollection expression: aMaTerm	| request |	request _ MaReaderTrunkRequest new		collectionOid: (self oidFor: aMagmaCollection) ;		expression: aMaTerm ;		yourself.	^ self submit: request! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/26/2005 23:02'!handleClassModification: aModifiedClassDefinitionEvent	aModifiedClassDefinitionEvent isModified ifFalse: [ ^ self ].	aModifiedClassDefinitionEvent item isMeta ifTrue: [ ^ self ].	serializer handleClassModification: aModifiedClassDefinitionEvent.	readStrategy ifNotNil: [ self readStrategy makeReadyForUseUsing: serializer classIdManager ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/26/2005 00:05'!handleSpecialOidNotifications: aDictionary	"aDictionary is keyed by selector Symbols, with Sets of ByteArray's as values.  The selectors indicate what should be done with those ByteArray's once materialized."	| didRefresh |	didRefresh _ false.	"Must do classDefinitions Dictionary first."	(aDictionary includesKey: #refreshClassDefinitions)		ifTrue:			[ didRefresh _ true.			self refreshSpecialObjectsUsing: (aDictionary at: #refreshClassDefinitions) ].	"Now refresh individual OrderedCollections of MaClassDefinitions, each representing its own version."	(aDictionary includesKey: #refreshClassVersions)		ifTrue:			[ didRefresh _ true.			self refreshSpecialObjectsUsing: (aDictionary at: #refreshClassVersions) ].	(didRefresh and: [ self readStrategy notNil ]) ifTrue: [ self readStrategy makeReadyForUseUsing: serializer classIdManager ].! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 7/7/2005 22:50'!hasDefinition	^ definition notNil! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/5/2004 15:02'!hostAddress	^ self link hostAddress! !!MagmaSession methodsFor: 'private'!id	^id! !!MagmaSession methodsFor: 'private'!id: anInteger	id _ anInteger! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 12/26/2004 00:16'!inNestedTransaction	^ transactionLevel > 1! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 12/26/2004 00:20'!inTransaction	^ transactionLevel > 0! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:44'!incrementTransactionLevel	transactionLevel _ transactionLevel + 1! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/14/2005 21:44'!initialize	super initialize.	transaction _ MaTransaction session: self.	preferences _ MagmaPreferences new.	self		initializeSerializer ;		resetTransactionLevel ;		initializeMagmaNotifications ;		dropStrongReferences.	self id: nil! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 1/16/2005 19:02'!initializeDefinition	definition _ MagmaRepositoryDefinition new! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 2/25/2005 14:03'!initializeMagmaNotifications	self		when: #materializedFromMagma		send: #noteMaterialized:		to: self! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/29/2006 17:58'!initializeSerializer	serializer _ (MaObjectSerializer new)		toCreateProxies: 			[ : oid | 			MagmaMutatingProxy 				session: self				oid: oid ] ;		classIdManager: MagmaClassIdManager new ;		oidManager: MagmaOidManager new ;		yourself.	(serializer traversalStrategy)		traverseWhen: 			[ : path : parent : indexInteger | 			(path last 				maShouldTraverseWithPath: path				parent: parent				index: indexInteger) and: 				[ path size <= 2 or: 					[ "Because we're serializing an Array of only changed objects, we only need capture their first level, but don't forget the OC container is level 1."					MaOidCalculator isOidForNewObject: (self oidFor: path last) ] ] ] ;		valueWhen: 			[ : path : parent : index | 			(path last 				maShouldAppendWithPath: path				parent: parent				index: index) and: 				[ path size <= 2 or: [ MaOidCalculator isOidForNewObject: (self oidFor: path last) ] ] ].	(serializer preferences)		beforeSerializingAny: Morph			do: 				[ : aMorph | 				"(sigh) Morphs keep their own #updateableActionMap, the map used to hold event-listener definitions.  Before, we were setting up these listeners on *materialization*, but this was causing them to be marked dirty immediately.  Therefore, we go ahead and set these listeners up 'permanently' upon serialization."				aMorph wantsMagmaEvents ifTrue: 					[ aMorph 						when: #magmaAboutToRefresh						send: #aboutToRefreshFromMagma:						to: aMorph.	"aMagmaRefreshEvent"					aMorph 						when: #magmaRefreshed						send: #refreshedFromMagma:						to: aMorph	"aMagmaRefreshEvent" ] ] ;		afterMaterializingAny: #MagmaLargeCollection			do: 				[ : aMagmaCollection | 				aMagmaCollection					initializeChanges ;					setOid: (serializer oidFor: aMagmaCollection) ] ;		afterMaterializingAny: #MagmaCollectionReader			do: 				[ : aMagmaCollectionReader | 				aMagmaCollectionReader					fixUpExpression ;					setUpListener ;					refresh ]! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 1/26/2005 16:36'!initializeSystemChangeNotifications	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Modified		using: #handleClassModification:.	SystemChangeNotifier uniqueInstance		notify: serializer classIdManager		ofSystemChangesOfItem: #class		change: #Renamed		using: #handleClassRename:! !!MagmaSession methodsFor: 'connections'!isConnected	^self id notNil! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 12/26/2004 23:06'!isLocal	^ link isLocal! !!MagmaSession methodsFor: '*magma server' stamp: 'cmm 1/13/2005 18:01'!isOpen	^ self isRemote 	or: [ "local" self repositoryController isOpen ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 12/26/2004 23:33'!isPersistent: anObject	"Answer whether the repository I'm connected to has anObject stored in it."	^(self serializer hasOidFor: anObject) and: [ (MaOidCalculator isOidForNewObject: (self oidFor: anObject)) not ]! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 12/26/2004 23:08'!isRemote	^ self isLocal not! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/7/2005 23:35'!isSameRepositoryAs: anotherMagmaSession	^ anotherMagmaSession hasDefinition	and: [ definition magmaId = anotherMagmaSession definition magmaId ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 4/3/2003 23:09'!isServerSession	^id = 1! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/26/2004 23:00'!link	^ link! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/26/2004 23:59'!link: aMaServerLink	link _ aMaServerLink.	link timeoutSeconds:		(MagmaPreferences debug			ifTrue: [ 172800 "2 days" ]			ifFalse: [ 30 ])! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 12/26/2004 22:59'!linkInformation	^ link linkInformation! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 7/26/2006 23:24'!load: aMagmaCollection from: aMagmaCollectionReader makeDistinct: aBoolean	"Calls load:using:from:forSession:distinct:"	| reducedReaderResult |	reducedReaderResult _ self submit: 		(MaLoadFromReaderRequest new			collection: aMagmaCollection ;			expression: aMagmaCollectionReader expression ;			distinct: aBoolean ;			sourceCollectionOid: (self oidFor: aMagmaCollectionReader collection) ;			yourself).	serializer 		oidOf: aMagmaCollection		is: reducedReaderResult collectionOid.	"set it up as if it was created through normal transaction mechanism"	aMagmaCollection session: self.	transaction monitorLargeCollectionChanges: aMagmaCollection changes! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 6/23/2004 17:45'!loadClassDefinitionsFrom: aByteArray	serializer classDefinitions: (self materializeObject: aByteArray)! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 11/1/2004 12:29'!loadDefinitionFrom: aByteArray	definition _ self materializeObject: aByteArray! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 1/14/2005 15:13'!location	"Answer a new MagmaRepositoryLink that can be used later to access to this session without having to be concerned with directory-paths or ip addresses."	^ self isLocal		ifTrue:			[ MagmaLocalLocation path: self pathName ]		ifFalse:			[ MagmaRemoteLocation 				hostAddress: self hostAddress				port: self port ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 1/13/2005 14:37'!magmaId	^ definition magmaId! !!MagmaSession methodsFor: 'private' stamp: 'cmm 3/16/2005 12:45'!managesMagmaCollection: aMagmaLargeCollection	^ definition allLargeCollections includes: aMagmaLargeCollection! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/28/2005 00:17'!materializeAnchorFrom: aMaReadResult	^ self materializeObject: aMaReadResult byteArray! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/25/2005 14:30'!materializeObject: aByteArray	^ serializer		materializeGraph: aByteArray		do:			[ : eachObject : eachBuffer | 			eachObject wantsMagmaEvents ifTrue:				[ | event |				event _ (MagmaMaterializationEvent session: self)					object: eachObject ;					buffer: eachBuffer ;					yourself.				self					triggerEvent: #materializedFromMagma  "calls noteMaterialized:"					with: event ].			transaction 				markRead: eachObject				using: eachBuffer ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/17/2002 00:09'!materializeObjectsIn: aMaCollectionSegment	aMaCollectionSegment objects doWithIndex:		[ :eachBuffer :index |		aMaCollectionSegment objects			at: index			put: (self materializeObject: eachBuffer) ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 4/5/2005 20:28'!newCommitPackageFor: aMaTransaction	"It is possible to that we will serialize up to three times.  If we add a new LargeCollection that also adds instances of a new class, the first serialization will detect the new LargeCollection, the second notices the new classes, the third gets everything right.."	| commitPackage mustReserialize |	commitPackage _ aMaTransaction changedObjects.	mustReserialize _ commitPackage serializeObjectsUsing: self.	^ mustReserialize		ifTrue: [ self newCommitPackageFor: aMaTransaction ]		ifFalse: [ commitPackage ]! !!MagmaSession methodsFor: 'forwarding proxy''s (bookmarks)' stamp: 'cmm 2/1/2005 22:54'!newForwardingProxyFor: anObject	"Answer an object which will forward any messages to anObject.  This is useful if anObject must belong in a different repository than your objects which want to send messages to anObject."	(self isPersistent: anObject) ifFalse: [ MagmaUserError signal: 'Cannot make a forwarding proxy to a non-persistent object.' ].	^ MagmaForwardingProxy		session: self		oid: (self oidFor: anObject)! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 2/25/2005 14:33'!noteMaterialized: aMagmaMaterializationEvent	aMagmaMaterializationEvent object materializedFromMagma: aMagmaMaterializationEvent! !!MagmaSession methodsFor: 'large collections' stamp: 'cmm 4/7/2005 22:47'!noteOldKeysFor: anObject	"If anObject is in an indexed MagmaCollection and your program *is about to* change its keys, you must call this method or it will continue to be indexed under its old keys.  Emphasize, that you call this method *before* you change the keys, not after."	transaction ensureOldHashesCapturedFor: anObject! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 5/25/2005 12:52'!objectWithOid: anInteger ifAbsent: aBlock	^ serializer		objectWithOid: anInteger		ifAbsent:			[ [ self realObjectFor: anInteger ]				on: MagmaInvalidOid  "signaled in MaObjectFiler>>filePointerForOid:"				do: [ : exc | aBlock value ] ]! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 5/2/2005 22:18'!occurrencesOf: anObject in: aMagmaCollection	| oid |	^ self submit: (		MaKeyIntervalInfoRequest new			collectionOid: (self oidFor: aMagmaCollection) ;			attribute: nil ;			lowKey: (oid _ self oidFor: anObject) ;			highKey: oid ;			yourself)! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 2/1/2005 22:58'!oidFor: anObject	^ serializer oidFor: anObject! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 12/26/2004 22:44'!pathName	"Error if not local.  Check isLocal first."	self isLocal ifFalse: [ MaUserError signal: 'Only available during local connections.' ].	^ self submit: MagmaPathNameRequest new! !!MagmaSession methodsFor: 'connections' stamp: 'cmm 7/5/2004 15:02'!port	^ self link port! !!MagmaSession methodsFor: 'accessing'!preferences	^preferences! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 7/16/2002 00:17'!preferences: aMagmaPreferences	preferences _ aMagmaPreferences! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/18/2005 10:53'!primConnect	| resultArray |	self isConnected ifTrue: [ MagmaUserError signal: 'This session is already connected.' ].	self isLocal ifTrue: [ self ensureOpen ].	self hasDefinition ifTrue: [ self validateRemoteId ].	MagmaNotification signal: 'connecting to ', self linkInformation, ' as ', self userId, '...'.	link connect.	resultArray _		self submit:			(MaRepositoryConnectionRequest new				magmaVersion: self class magmaVersion ;				userId: self userId ;				yourself)."We digress from proper objectification of a session result only becausewe want to maintain a minimum set of classes necessary to acquire the classmap itself, for once we acqure that, we can do anything.  Prior to that, however,we are limited to the only the classes that are ''basic'' classes according to theMaDefaultClassIdManager."	self		id: (resultArray at: 1) ;		loadClassDefinitionsFrom: (resultArray at: 2) ;		loadDefinitionFrom: (resultArray at: 3).	self initializeSystemChangeNotifications.	MagmaNotification signal: 'connection established.'.	^self! !!MagmaSession methodsFor: 'initialize-release' stamp: 'cmm 7/9/2006 16:58'!primDisconnect	"Calls removeSessionFor:"	self isConnected		ifTrue:			[ MagmaNotification signal: 'disconnecting from ', self linkInformation.			[ self submit: MaRepositoryDisconnectRequest new ]				on: MagmaSessionLost, MagmaUserError, MaNetworkError				do: [ : error | "already disconnected, don't sweat it." ].			self				resetTransactionLevel ;				id: nil ;				cleanUp ].	SystemChangeNotifier uniqueInstance 		noMoreNotificationsFor: self ;		noMoreNotificationsFor: serializer classIdManager.	self 		cleanUpWriteBarrier ;		releaseActionMap.	Smalltalk garbageCollect! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/17/2006 00:28'!processNewAndRemovedIndexesIn: aMagmaCommitPackage using: aMaCommitResult 	| backupPackage |	backupPackage _ aMagmaCommitPackage copyWithNewLargeCollectionChanges.	transaction resetCommitPackage.	self refreshViewUsing: aMaCommitResult.	backupPackage newIndexesDo: 		[ : eachCollection : eachIndexes | 		| objectOidsAlreadyIndexed mcChanges |		mcChanges _ aMagmaCommitPackage largeCollectionChangesFor: eachCollection.		objectOidsAlreadyIndexed _ mcChanges added keys collect: 			[ : each | 			(MaOidCalculator isOidForNewObject: each) 				ifTrue: 					[ aMaCommitResult permanentOids 						at: each						ifAbsent: 							[ MagmaSoftwareError signal: 'error building index, expected to find permanent oid' ] ]				ifFalse: [ each ] ].		eachCollection 			buildIndexes: eachIndexes			ignoring: objectOidsAlreadyIndexed ].	backupPackage removedIndexesDo: [ : eachCollection : eachIndexes | eachCollection commitUnlock ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 14:28'!read: oid	^ self submit:		(MaReadRequest new  "calls read:for:using:"			oid: oid;			readStrategy: self resetReadStrategy;			yourself)! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 9/23/2004 15:59'!readStrategy	"Answers an object that defines how many levels deep to read when encountering various kinds of objects."	^ readStrategy! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 4/7/2005 16:31'!readStrategy: aMaReadStrategy	"Once the readStrategy is set, aMaReadStrategy is converted to use class ids.."	aMaReadStrategy isBasic		ifTrue:			[ "basic read-strategies are not allowed because they circumvent the systemReadStrategy in the server."			MagmaUserError signal: 'Basic read-strategies are not allowed, use a MaReadStrategy.' ].	readStrategy _ aMaReadStrategy makeReadyForUseUsing: serializer classIdManager! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 14:29'!realObjectFor: oid	| result |	result _ self read: oid.	result shouldRefresh "server will not give us true unless not in a transaction."		ifTrue: [ self abort ].	^ self materializeObject: result byteArray! !!MagmaSession methodsFor: 'private' stamp: 'cmm 10/10/2004 22:08'!recordObjects: aCollection	"aCollection of MaObjectBuffers."	aCollection do:		[ : each |		serializer			objectWithOid: each oid			ifFound:				[ :object |				transaction					markRead: object					using: each ]			ifAbsent: [ "do nothing"  nil ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/26/2004 21:59'!refresh	self refreshViewUsing: (self submit: MaAbortTransactionRequest new)! !!MagmaSession methodsFor: 'transactions' stamp: 'cmm 5/3/2005 14:30'!refresh: anObject	"Update anObject with the contents of the repository.  Use sparingly and with caution!!"	| readResult graph |	(self isPersistent: anObject) ifFalse: [ MagmaUserError signal: 'cannot refresh a non-persistent object.' ].	readResult _ self read: (self oidFor: anObject).	graph _ MaSerializedGraphBuffer byteArray: readResult byteArray.	self refreshObject:		((MagmaRefreshEvent session: self)			buffer: graph rootBuffer;			object: anObject ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/25/2005 14:15'!refreshChangedObjects: changedObjects	"changedObjects is a Dictionary of MaObjectBuffers that were written by other clients.  For each one that the receiver still knows its oid, set all of its instVars to the objects that map by its referenced oids.  If a referenced oid is not in the client, substitute with a proxy."	| refreshEvents |	"Some Morphs cannot be refreshed while they're stepping in the world; therefore we provide this hack to ensure we only update them 'offline'; e.g., we delete, refresh, then add them back at the same position and index as they were.  The events restoreData is used to capture this temporary information."	refreshEvents _ OrderedCollection new.	changedObjects do:		[ : eachObjectBuffer |  | object |		object _ serializer objectWithOid: eachObjectBuffer oid ifAbsent: [ nil ].		(object == nil or: [ object maIsMutatingProxy ]) ifFalse:			[ | event |			event _ (MagmaRefreshEvent session: self)				buffer: eachObjectBuffer ;				object: object ;				yourself.			self refreshObject: event.			object wantsMagmaEvents ifTrue: [ refreshEvents add: event ] ] ].	"We prefer to do the refresh in a 'post' fashion, so event handlers may count on the freshest data everywhere."	refreshEvents do:		[ : each | 		each object			triggerEvent: #magmaRefreshed "calls #refreshedFromMagma:"			with: each ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 14:48'!refreshClassDefinitions	"This for a very specific scenario.  If the user attempts to commit a new or changed class and the commit fails for any reason, their classMaps (both persistent and non-persistent) need to be restored to their state without all the new classes because, if they then try to commit some of those same new classes again, it will not detect the new addition to the classDefinitions."	self refresh: serializer classIdManager classDefinitionsById.	serializer classIdManager classDefinitionsById do:		[ : eachDefinitions | self refresh: eachDefinitions ].	serializer classIdManager rebuildTransientClassMaps! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 13:35'!refreshDefinition	"This for a very specific scenario.  If the user attempts to commit a new or changed class and the commit fails for any reason, their classMaps (both persistent and non-persistent) need to be restored to their state without all the new classes because, if they then try to commit some of those same new classes again, it will not detect the new addition to the classDefinitions."	self refresh: definition.	self		refreshClassDefinitions ;		refreshLargeCollections! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 13:35'!refreshLargeCollections	"This for a very specific scenario.  If the user attempts to commit a new large-collection and the commit fails for any reason, their large-collections need to be refreshed because, if they then try to commit some of those same new collections again, it will not detect the new addition to MagmaRepositoryDefinition>>allLargeCollections."	self refresh: definition allLargeCollections! !!MagmaSession methodsFor: 'private' stamp: 'cmm 5/3/2005 13:05'!refreshObject: aMagmaRefreshEvent	aMagmaRefreshEvent object wantsMagmaEvents		ifTrue:			[ aMagmaRefreshEvent object				triggerEvent: #magmaAboutToRefresh "calls #aboutToRefreshFromMagma:"				with: aMagmaRefreshEvent ].	aMagmaRefreshEvent buffer		refresh: aMagmaRefreshEvent object		using: self.	transaction		"We do this here instead of all the time in #markRead:using: because removeKey: is so slow."		ensureOldHashesCleanedFor: aMagmaRefreshEvent object ;				markRead: aMagmaRefreshEvent object		using: aMagmaRefreshEvent buffer! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 8/6/2006 22:08'!refreshSegment: aMagmaCollectionReaderSegment of: aMagmaCollection where: aMaTerm pageSize: anInteger using: aMaReadStrategy loadObjects: aBoolean 	"Calls refreshSegmentIn:"	| segment |	segment _ self submit: (		(MaRefreshSegmentRequest new)			quantity: anInteger ;			collectionOid: (self oidFor: aMagmaCollection) ;			segment: aMagmaCollectionReaderSegment ;			expression: aMaTerm ;			readStrategy: aMaReadStrategy ;			loadObjects: aBoolean ;			exceptions: aMagmaCollection changes removedOids ;			yourself).	"Since we say we 'refresh' let's do that instead of returning the new one."	aMagmaCollectionReaderSegment refreshFrom: segment.	self materializeObjectsIn: aMagmaCollectionReaderSegment! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/28/2004 15:47'!refreshSpecialObjectsUsing: aSetOfByteArrays	"each ByteArray is a graph buffer of either the entire classDefinitionsById, OR merely one of the OrderedCollections of the definitions for a particular id/class."	aSetOfByteArrays do: [ : each | self materializeObject: each ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 2/18/2006 12:58'!refreshViewUsing: aMaRefreshViewResult	"I have crossed a transaction boundary, either through abort, commit or begin."	aMaRefreshViewResult refresh: self.	serializer resetNewObjects.	"Q:  When do we reset the commitPackage?	A:  Definitely on every successful #commit.   For #begin and #abort, it matters whether refreshPersistentObjectsEvenWhenChangedOnlyByMe is set.  With its default value, false, we want to support the 'forgetting to begin' use-case; where a user makes some changes, realizes they hadn't started a transaction, so they just do a #begin, during which only the objects which were changed by others are refreshed, their own changes are preserved.  They can then press #commit and their changes will be saved.  This is actually a useful commit-strategy."	preferences refreshPersistentObjectsEvenWhenChangedOnlyByMe 		ifTrue:			[ transaction resetCommitPackage.			self resetMagmaCollectionChanges ]! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 1/14/2005 16:04'!remoteMagmaId	^ self submit: MagmaIdRequest new! !!MagmaSession methodsFor: '*magma server' stamp: 'cmm 1/13/2005 18:01'!repositoryController	^ link localRequestServer processor! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 10/10/2004 20:05'!resetMagmaCollectionChanges	transaction largeCollectionChanges do: [ :each | each reset ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/25/2005 14:48'!resetReadStrategy	"We allow the user to define read strategies 'specifications' for classes that may not even exist in the repository.  So, classes that aren't known yet are remembered by the strategy."	^ readStrategy		ifNil: [ nil ]		ifNotNil:			[ readStrategy isNew  "do we have new depth specifications?"				ifTrue:					[ | answer |					answer _ readStrategy copyWithoutSpecifications.					readStrategy hasUnusedDepths 						ifTrue: [ readStrategy beOld ]						ifFalse: [ readStrategy _ nil ].					answer ]				ifFalse:					[ nil ] ]! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/11/2004 13:55'!resetTransactionLevel	transactionLevel _ 0! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 12/28/2004 23:54'!root	"Every Magma repository has a single root object off which every other object directly or indirectly hangs.  This method answers it."	^self anchor root! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/28/2004 23:57'!root: anObject	anchor _ self anchor.	anchor root ifNotNil: [ Warning signal: 'Are you sure you want to wipe out the entire database for ', anObject printString, '?' ].	anchor root: anObject! !!MagmaSession methodsFor: 'private'!serializer	^serializer! !!MagmaSession methodsFor: 'private' stamp: 'cmm 12/29/2004 15:00'!sharesAnyObjectsWith: anotherMagmaSession	self == anotherMagmaSession ifTrue: [ ^ true ].	(self isSameRepositoryAs: anotherMagmaSession) ifFalse: [ ^ false ].	^ anotherMagmaSession serializer sharesAnyObjectsWith: anotherMagmaSession serializer! !!MagmaSession methodsFor: 'private' stamp: 'cmm 6/7/2005 12:50'!signalExceptionLike: anException 	| signalableError |	signalableError := anException maOriginalClass new 		copyAttributes:			(anException maOriginalClass allInstVarNames copyWithoutAll: #('signalContext' 'handlerContext' 'outerContext'))		from: anException.	"this is probably not necessary.."	signalableError signal! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/12/2006 21:55'!sizeOfLargeCollection: aMagmaCollection	"Calls sizeOfLargeCollection:"	self ensureConnected.  "Need this before we call oidFor:, below."	^ self submit:		(MaLargeCollectionSizeRequest new 			collectionOid: (self oidFor: aMagmaCollection) ;			yourself)! !!MagmaSession methodsFor: 'private' stamp: 'cmm 7/4/2005 16:35'!stronglyReference: anObject	strongReferences add: anObject! !!MagmaSession methodsFor: 'performance' stamp: 'cmm 2/21/2005 16:38'!stubOut: anObject	"Convert anObject to a proxy, potentially freeing the objects it references for garbage collection.  Useful for keeping memory consumption under control."	| oid |	(self canStubOut: anObject) ifFalse: [ ^ self ].		oid _ self oidFor: anObject.	transaction remove: anObject.	serializer cleanObject: anObject.	anObject		becomeForward:			(MagmaMutatingProxy				session: self				oid: oid)		copyHash: false! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/28/2005 00:16'!submit: aMagmaRepositoryRequest	"Submit aMagmaRepositoryRequest and answer the result.  This is a core method."	| result |	aMagmaRepositoryRequest requiresConnection ifTrue: [ self ensureConnected ].	aMagmaRepositoryRequest sessionId: id.	result _ MagmaPreferences handStatus		ifTrue:			[ aMagmaRepositoryRequest waitCursor showWhile: [ link submit: aMagmaRepositoryRequest ] ]		ifFalse: [ link submit: aMagmaRepositoryRequest ].	result maIsException ifTrue: [ self signalExceptionLike: result ].	(result isMagmaServerResult and: [ result hasServerNotifications ])		ifTrue:			[ self handleSpecialOidNotifications: result serverNotifications ].	^ result! !!MagmaSession methodsFor: 'private-magma collections' stamp: 'cmm 6/5/2006 22:29'!upTo: anInteger objectsIn: aMagmaCollection fromIndex: startIndex using: aMaReadStrategy	"Answer a MaCollectionSegment or aMaIndexedCollectionSegment.  Calls upTo:oidsFromIndex:inLargeCollection:using:forSession: "	| segmentResult |	segmentResult _		(self submit: (			MaSegmentByIndexRequest new				quantity: anInteger;				collectionOid: (self oidFor: aMagmaCollection) ;				lowIndex: startIndex ;				readStrategy: aMaReadStrategy ;				yourself)).	self materializeObjectsIn: segmentResult.	^ segmentResult! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 1/17/2005 14:33'!user	^ user! !!MagmaSession methodsFor: 'accessing' stamp: 'cmm 1/17/2005 14:33'!userId	^ self user id! !!MagmaSession methodsFor: 'private' stamp: 'cmm 1/14/2005 16:07'!validateRemoteId	"Ensure my id is the same as my repository's id.  I am used to reconnect after being disconnected during which time a new repository could have been created in the same location, which would render my objects with invalid oids."	self magmaId = self remoteMagmaId		ifFalse:			[ MagmaEnvironmentError signal: 'Cannot connect because the repository has been replaced.' ]! !!MagmaUser class methodsFor: 'create' stamp: 'cmm 1/15/2005 16:37'!id: aString	^ self new id: aString; yourself! !!MagmaUser methodsFor: 'initialize' stamp: 'cmm 1/15/2005 16:37'!id	^ id! !!MagmaUser methodsFor: 'initialize' stamp: 'cmm 1/15/2005 16:37'!id: aString	id _ aString! !!MagmaUser methodsFor: 'printing' stamp: 'cmm 1/17/2005 21:59'!maPrintAbbreviatedOn: aStream	self maPrintAttribute: #id on: aStream! !!MaObjectGraphTraversalStrategy methodsFor: 'private' stamp: 'cmm 5/2/2005 22:13'!initialize	super initialize.	valueWhenBlock := [:path :parent :instVarIndex | true].	traverseWhenBlock := [:path :parent :instVarIndex | true]! !!MaObjectGraphTraversalStrategy methodsFor: 'testing'!shouldTraverseIntoLastOf: path from: parent index: anInteger	^traverseWhenBlock		value: path		value: parent		value: anInteger! !!MaObjectGraphTraversalStrategy methodsFor: 'testing'!shouldValueLastOf: anOrderedCollection from: parentObject index: anInteger	^valueWhenBlock		value: anOrderedCollection		value: parentObject		value: anInteger! !!MaObjectGraphTraversalStrategy methodsFor: 'building'!traverseWhen: threeArgBlock	"The default traversal behavior is to traverse everything.  threeArgBlock	may be specified to restrict the default traversal (stepping into an objects	instance variables).  The first argument is an OrderedCollection of the	path of objects that lead to the current node, the second is the parent	of the current node (and second to last in the path), the last is the integer	index of the instVar of the current node."	traverseWhenBlock := threeArgBlock! !!MaObjectGraphTraversalStrategy methodsFor: 'building'!valueWhen: threeArgBlock	"The default behavior is to value every node once (the framework automatically	keeps track of where it has already been).   threeArgBlock takes the same arguments	as the other parameters of this class."	valueWhenBlock := threeArgBlock! !!MaOverrider commentStamp: '<historical>' prior: 0!I provide a list of objects a chance to handle a message and answer a non-nil before allowing the overridee a chance.  Primarily, I am intended to provide chain-of-responsibility for preferences.  A global preferences object is shared by most, but need to be selectively overridden.!!MaOverrider methodsFor: 'building' stamp: 'cmm 3/3/2004 22:45'!addOverrider: anObject	overriders add: anObject! !!MaOverrider methodsFor: 'private' stamp: 'cmm 3/3/2004 22:53'!doesNotUnderstand: aMessage	overriders do:		[ : each |		(each respondsTo: aMessage selector)			ifTrue: 				[ | answer |				answer _ aMessage sentTo: each.				answer ifNotNil: [ ^ answer ] ] ].	^ aMessage sentTo: self overridee! !!MaOverrider methodsFor: 'private' stamp: 'cmm 7/1/2004 10:50'!initialize	super initialize.	overriders := OrderedCollection new: 1! !!MaOverrider methodsFor: 'subclass responsibility' stamp: 'cmm 3/3/2004 22:54'!overridee	self subclassResponsibility! !!MaOverrider methodsFor: 'building' stamp: 'cmm 3/3/2004 22:45'!removeOverrider: anObject	overriders remove: anObject! !!MaSystemNavigationOverrider class methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2004 22:56'!initialize	OriginalSystemNavigation _ SystemNavigation default! !!MaSystemNavigationOverrider class methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2004 22:57'!unload	SystemNavigation maDefault: OriginalSystemNavigation ! !!MaSystemNavigationOverrider methodsFor: 'as yet unclassified' stamp: 'cmm 3/3/2004 22:56'!overridee	^ OriginalSystemNavigation! !!MaStopwatch class methodsFor: 'examples'!example1	|s|	s _ MaStopwatch new start.	(Delay forSeconds: 3) wait.	Transcript cr; show: s time printString.	s reset.	Transcript cr; show: s time printString.! !!MaStopwatch class methodsFor: 'instance creation'!new	^super new initialize! !!MaStopwatch methodsFor: 'private' stamp: 'cmm 10/30/2002 21:24'!beRunning	state _ #running! !!MaStopwatch methodsFor: 'private' stamp: 'cmm 10/30/2002 22:03'!beStopped	state _ #stopped! !!MaStopwatch methodsFor: 'private' stamp: 'cmm 5/2/2005 22:13'!initialize	super initialize.	self reset! !!MaStopwatch methodsFor: 'testing' stamp: 'cmm 10/30/2002 22:22'!isRunning	^state = #running! !!MaStopwatch methodsFor: 'testing'!isStarted	^self isRunning or: [ self time > 0 seconds ]! !!MaStopwatch methodsFor: 'testing' stamp: 'cmm 10/30/2002 22:22'!isStopped	^state = #stopped! !!MaStopwatch methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:32'!printOn: aStream	super printOn: aStream.	aStream nextPut: $ .	self time maPrintAbbreviatedOn: aStream! !!MaStopwatch methodsFor: 'actions' stamp: 'cmm 3/3/2004 12:59'!reset	self beStopped.	totalStoppedTime _ 0 maSeconds.	stoppedTime _ nil.	startTime _ nil! !!MaStopwatch methodsFor: 'actions' stamp: 'cmm 1/8/2003 23:53'!restart	self reset; start! !!MaStopwatch methodsFor: 'actions' stamp: 'cmm 3/3/2004 12:58'!start	self isRunning ifTrue: [ ^self ].	startTime		ifNil:			[ startTime _ MaCalendarTime now.			stoppedTime _ startTime.			totalStoppedTime _ 0 maSeconds ]		ifNotNil:			[ totalStoppedTime _ totalStoppedTime + MaCalendarTime now - stoppedTime ].	self beRunning! !!MaStopwatch methodsFor: 'accessing'!startTime	"The point in time which the receiver was started."	^startTime! !!MaStopwatch methodsFor: 'private'!state	^state! !!MaStopwatch methodsFor: 'actions' stamp: 'cmm 2/2/2003 11:41'!stop	self isRunning		ifTrue:			[ stoppedTime _ MaCalendarTime now.			self beStopped ].	^stoppedTime! !!MaStopwatch methodsFor: 'accessing' stamp: 'cmm 3/3/2004 12:58'!time	"Return an MaDuration representing the total time the stopwatch has run."	^self isRunning		ifTrue: [ MaCalendarTime now - startTime - totalStoppedTime ]		ifFalse:			[ startTime				ifNil: [ 0 maSeconds ]				ifNotNil: [ stoppedTime - startTime - totalStoppedTime ] ]! !!MaStopwatch methodsFor: 'private'!totalStoppedTime	^totalStoppedTime! !!MaStopwatch methodsFor: 'private'!totalStoppedTime: anInteger	"Set the totalStoppedTime to anInteger number of milliseconds."	totalStoppedTime _ anInteger! !!MaTimeInterval class methodsFor: 'creation' stamp: 'cmm 3/3/2004 13:17'!dayOf: aMaCalendarTime by: resolution	"Returns the calandar day surrounding aMaTimestamp."	| begin |	begin _ aMaCalendarTime truncateTo: 1 maDay.	^self		from: begin		to: begin + MaCalendarTime maDay - resolution		by: resolution! !!MaTimeInterval class methodsFor: 'creation'!from: fromTimeStamp to: toTimeStamp	^self new		from: fromTimeStamp;		to: toTimeStamp! !!MaTimeInterval class methodsFor: 'creation'!from: startTimeStamp to: endTimeStamp by: byTimeStamp	^self new		from: startTimeStamp;		to: endTimeStamp;		by: byTimeStamp! !!MaTimeInterval class methodsFor: 'creation' stamp: 'cmm 3/3/2004 13:14'!hourOf: aMaCalendarTime by: resolution	"Returns the calandar hour surrounding aMaCalendarTime."	| begin |	begin _ aMaCalendarTime truncateTo: 1 maHour.	^self		from: begin		to: begin + 1 maHour - resolution		by: resolution! !!MaTimeInterval methodsFor: 'accessing'!after: aMaTimeStamp	"Answer the first timeStamp 'included' in the receiver that is higher	than aMaTimeStamp"	^(aMaTimeStamp + (by // 2)) roundTo: by! !!MaTimeInterval methodsFor: 'accessing'!at: anInteger	^from + (by * anInteger)! !!MaTimeInterval methodsFor: 'improper'!at: anInteger put: anObject	self shouldNotImplement! !!MaTimeInterval methodsFor: 'accessing'!before: aMaTimeStamp	"Answer the timeStamp 'included' in the receiver that is the first	one lower than aMaTimeStamp"	^(aMaTimeStamp - (by / 2)) roundTo: by! !!MaTimeInterval methodsFor: 'private accessing'!by	^by! !!MaTimeInterval methodsFor: 'private building'!by: aMaTimeStamp	by _ aMaTimeStamp! !!MaTimeInterval methodsFor: 'accessing'!collect: aBlock	| answer index |	answer _ Array new: self size.	index _ 1.	self do:		[ :each |		answer			at: index			put: (aBlock value: each).		index _ index + 1 ].	^answer! !!MaTimeInterval methodsFor: 'actions'!do: aBlock	| element |	element _ from.	self size timesRepeat:		[ aBlock value: element.		element _ element + by ]! !!MaTimeInterval methodsFor: 'accessing'!duration	^to - from! !!MaTimeInterval methodsFor: 'accessing'!first	(to - from // by) >= 0		ifTrue:			[ ^from ]		ifFalse:			[ self error: self printString , ' is empty.' ]! !!MaTimeInterval methodsFor: 'private accessing'!from	^from! !!MaTimeInterval methodsFor: 'private building'!from: aMaTimeStamp	from _ aMaTimeStamp! !!MaTimeInterval methodsFor: 'accessing'!increment	^by! !!MaTimeInterval methodsFor: 'testing'!intersects: anInterval	"Return true if the receiver overlaps with anInterval."	^(self from		between: anInterval from		and: anInterval to)			or:				[ anInterval from					between: self from					and: self to ]! !!MaTimeInterval methodsFor: 'accessing'!last	| last |	(last _ to - from // by) >= 0		ifTrue:			[ ^from + (last * by) ]		ifFalse:			[ self error: self printString, ' is empty.' ]! !!MaTimeInterval methodsFor: 'testing'!maIntersects: anInterval 	"Return true if the receiver overlaps with anInterval."	^(self from between: anInterval from and: anInterval to) 		or: [anInterval from between: self from and: self to]! !!MaTimeInterval methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:33'!maPrintAbbreviatedOn: aStream	aStream		maPrintAbbreviated: from;		nextPutAll: ' to: ';		maPrintAbbreviated: to;		nextPutAll: ' by: ';		maPrintAbbreviated: by! !!MaTimeInterval methodsFor: 'printing' stamp: 'cmm 2/5/2003 16:33'!printOn: aStream	super printOn: aStream.	aStream space.	self maPrintAbbreviatedOn: aStream! !!MaTimeInterval methodsFor: 'accessing'!reject: aBlock	| answer index |	answer _ Array new: self size.	index _ 0.	self do:		[ :each |		(aBlock value: each)			ifFalse:				[ answer					at: (index _ index + 1)					put: each ] ].	^answer		copyFrom: 1		to: index! !!MaTimeInterval methodsFor: 'creation'!reverse	^self class		from: to		to: from		by: by! !!MaTimeInterval methodsFor: 'actions'!reverseDo: aBlock	| element selfSize |	element _ from + ((selfSize _ self size) - 1 * by).	selfSize timesRepeat:		[ aBlock value: element.		element _ element - by ]! !!MaTimeInterval methodsFor: 'accessing'!select: aBlock	| answer index |	answer _ Array new: self size.	index _ 0.	self do:		[ :each |		(aBlock value: each)			ifTrue:				[ answer					at: (index _ index + 1)					put: each ] ].	^answer		copyFrom: 1		to: index! !!MaTimeInterval methodsFor: 'accessing'!size	^self duration // by! !!MaTimeInterval methodsFor: 'private accessing'!to	^to! !!MaTimeInterval methodsFor: 'private building'!to: aMaTimeStamp	to _ aMaTimeStamp! !!Object class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ true! !!Object class methodsFor: '*ma object serialization' stamp: 'cmm 2/23/2005 14:54'!maLoadVariableObjectFrom: aMaVariableObjectBuffer	"This is the standard-case for building a skeleton of a variably-sized object."	| skeleton |	skeleton _ self basicNew: aMaVariableObjectBuffer objectInstSize - self instSize.	1		to: aMaVariableObjectBuffer objectInstSize		do:			[ : index |			skeleton				instVarAt: index				put: (aMaVariableObjectBuffer maInstVarAt: index) ].	^ skeleton! !!Object class methodsFor: '*ma object serialization' stamp: 'cmm 11/23/2004 12:47'!maMaterializeFrom: aMaByteObjectBuffer using: aMaObjectSerializer	"This is the standard-case for building a skeleton of a variable-byte-sized object."	^ aMaByteObjectBuffer asByteObject: self! !!Object methodsFor: '*magma client' stamp: 'cmm 1/13/2005 17:33'!asMagmaForwardingProxy	^ MagmaSession connectedSessions		maDetect: [ : each | each isPersistent: self ]		ifFound: [ : foundSession | foundSession newForwardingProxyFor: self ]		ifNone: [ MagmaUserError signal: 'Cannot create a forwarding proxy because I am not persistent in any connected session.' ]! !!Object methodsFor: '*writebarrier' stamp: 'avi 10/7/2004 03:13'!isBehindWriteBarrier	^ false ! !!Object methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:40'!isImmutableInMagma	"This is used to help determine whether I should be stored in Magma's 'readSet', which is used to track changes.  But changes to some objects, such as Symbols, Blocks, CompiledMethods or logically-referenced globals are not tracked.  Therefore, there is no reason to bloat the readSet (not to mention when refreshPersistentObjectsEvenWhenChangedOnlyByMe is true, it won't try to refresh the unrefreshable."	^ self maInstSize = 0! !!Object methodsFor: '*magma client' stamp: 'cmm 1/13/2005 16:11'!isMagmaOfflineObject	^ false! !!Object methodsFor: '*magma client' stamp: 'cmm 1/28/2005 00:16'!isMagmaServerResult	^ false! !!Object methodsFor: '*collections-btree' stamp: 'avi 5/1/2005 14:10'!isTreeSet	^ false! !!Object methodsFor: '*ma base additions' stamp: 'cmm 8/21/2004 15:53'!maAbbreviatedString	"This is intended to support two possible string representations for any object	instead of just one.  The normal one and this abbreivated one.  The normal one provides type-information, the abbreviation provides the identifier.  An abbreviated	provides a brevity that proves useful when looking at collections or	other 'container' type objects.	Suggested usage is to omit the objects type (e.g. class name) for printing abbreviated,	but include it for standard printOn:"	^ String streamContents: [ : stream | self maPrintAbbreviatedOn: stream ]! !!Object methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:41'!maAllowsWriteBarrier	"Override in subclasses, if desired."	^ self isImmutableInMagma not	and: [ self isBehindWriteBarrier not	and: [ self class canUncompact ] ]! !!Object methodsFor: '*ma object serialization' stamp: 'cmm 3/27/2006 17:03'!maEstablishPointerReferencesUsing: aMaObjectSerializer 	"I am currently loaded with oids of the objects that I should be referencing.  Now that objects for these oids are, themselves, materialized, I can now replace my referernces to oids wtih references to the real objects."	self maOriginalClass isPointers 		ifFalse: 			["don't need to do this."			^self].	1 		to: self maInstSize		do: 			[:instVarIndex | 			| oid |			oid _ self instVarAt: instVarIndex.			oid ifNotNil: 				["could be nil if different class def"				"we shouldn't need to worry about transient vars here because they would have been stored as nil."				self 					instVarAt: instVarIndex					put: (aMaObjectSerializer objectWithOid: oid)]]! !!Object methodsFor: '*ma traverse object graphs'!maGraphDo: threeArgBlock	self		maGraphWhere: [ :path :parent :index | true ]		do: threeArgBlock! !!Object methodsFor: '*ma traverse object graphs' stamp: 'cmm 12/2/2004 17:29'!maGraphDo: threeArgBlock using: anObjectTraversalStrategy	"Walk the receiver and all of its variables valuing threeArgBlock.  The first argument is an OrderedCollection of the objects leading to the current object, including the current object, the second argument is the parent of the current object (second to last in the path).  The third argument is the index or key object required to send instVarAt: to access the current object (except for Dictionaries, in which the key may not be an Integer.  All arguments are in their substituted form."	nil		maValueGraphNode: self 		index: 0		using: anObjectTraversalStrategy 		with: threeArgBlock		path: OrderedCollection new 		with: IdentitySet new! !!Object methodsFor: '*magma client' stamp: 'apg 4/25/2005 10:06'!maIsAssociation	^ false! !!Object methodsFor: '*magma client' stamp: 'cmm 4/10/2005 18:00'!maIsChangedFrom: aMaVariableObjectBuffer using: aMaObjectSerializer 	"I am variable."	aMaVariableObjectBuffer isPointers 		ifFalse: 			[MagmaSoftwareError signal: self maOriginalClass name 						, ' should implement maIsChangedFrom:using:.'].	1 to: self maInstSize		do: 			[:index | 			(index > self maOriginalClass instSize 				or: [(self maIsTransient: index) not]) 					ifTrue: 						[(aMaObjectSerializer oidFor: (self instVarAt: index)) 							~= (aMaVariableObjectBuffer maInstVarAt: index) ifTrue: [^true]]].	^false! !!Object methodsFor: '*ma exception handling' stamp: 'cmm 2/15/2002 00:02'!maIsException	^false! !!Object methodsFor: '*ma base additions' stamp: 'cmm 7/15/2006 15:12'!maIsSortedCollection	^ false! !!Object methodsFor: '*ma base additions' stamp: 'cmm 11/10/2005 22:07'!maMarked: aString	"This is a marker method used to indicate that we wish to come back and re-examine	code in the future for possible improvement.  For now, try to keep improvements categorized	via anEsAtom that we can Browse References to, if necessary.  The possibilities should be:		'ugly'		'performance'		'bug'		'dev'		'vmSpecific'		'releaseSpecific'		'otherPackageSupport'		'system override'		'deprecated'		'magic'		'debug'	A *comment* then should follow to provide more detail."	aString = 'delete' ifTrue: [ self halt: 'Oops..  looks like you still need this method.' ]! !!Object methodsFor: '*ma base additions' stamp: 'cmm 4/10/2005 18:00'!maOriginalClass	"Unfortunately, we don't have complete class-transparency with WriteBarrier.  #species isn't always the quite the thing needed.  In rare cases (browse my senders), my actual class is needed."	^self class! !!Object methodsFor: '*ma base additions' stamp: 'cm 12/29/2001 01:14'!maPrintAbbreviatedOn: aStream	"This is intended to support two possible string representations for any object	instead of just one.  The normal one and this abbreivated one.  An abbreviated	provides a brevity that proves useful when looking at collections or	other 'container' type objects.	Suggested usage is to omit the objects type (e.g. class name) for printing abbreviated,	but include it for standard printOn:"! !!Object methodsFor: '*ma base additions'!maPrintAttribute: aSymbol on: aStream	(self class allInstVarNames includes: aSymbol asString)		ifTrue:			[ self				maPrintInstVar: aSymbol				on: aStream ]		ifFalse:			[ self				maPrintSelector: aSymbol				on: aStream ]! !!Object methodsFor: '*ma base additions'!maPrintAttributes: arrayOfSymbols on: aStream	arrayOfSymbols do:		[ :each |		self			maPrintAttribute: each			on: aStream ]! !!Object methodsFor: '*ma base additions' stamp: 'cmm 12/19/2002 23:26'!maPrintInstVar: aSymbol on: aStream	| value |	aStream		cr;		tab;		nextPutAll: aSymbol;		nextPutAll: ' = '.	value := self instVarNamed: aSymbol asString.	(value isCollection and: [ value isString not ])		ifTrue:			[ value do:				[ :each |				aStream					maPrint: each;					space ] ]		ifFalse:			[ aStream maPrint: value ]! !!Object methodsFor: '*ma base additions' stamp: 'cmm 5/11/2003 22:16'!maPrintSelector: aSymbol on: aStream	| value |	aStream		cr;		tab;		nextPutAll: aSymbol;		nextPutAll: ' : '.	value :=		[ self perform: aSymbol ]			on: Error			do: [ :exc | exc return: '**invalid**' ].	(value isCollection and: [ value isString not ])		ifTrue:			[ value do:				[ :each |				aStream					maPrint: each;					space ] ]		ifFalse:			[ aStream maPrint: value ]! !!Object methodsFor: '*magma client' stamp: 'cmm 3/27/2006 17:04'!maRefreshTo: aMaVariableBuffer using: aMagmaSession 	"I am variable."	self maOriginalClass isBytes 		ifTrue: 			[self 				replaceFrom: 1				to: self size				with: aMaVariableBuffer asByteArray				startingAt: 1]		ifFalse: 			[ "I am pointers or words."			aMaVariableBuffer instVarsDoWithIndex: 				[ : eachOid : eachIndex | 				(self maIsTransient: eachIndex) 					ifFalse: 						[ self 							instVarAt: eachIndex							put: (aMagmaSession serializer objectWithOid: eachOid) ] ] ]! !!Object methodsFor: '*ma object serialization' stamp: 'cmm 1/16/2005 23:51'!maRequiresOwnBuffer	"Answers false if the receiver has a special oid to represent it, such as nil, true, false and other immutables do."	^ self class maInstancesRequireOwnBuffer! !!Object methodsFor: '*ma object serialization' stamp: 'cmm 4/10/2005 18:00'!maSerializationClass	"For WriteBarrier support."	^self maOriginalClass! !!Object methodsFor: '*ma base additions' stamp: 'cmm 7/24/2002 20:46'!maShallowCopy	^self shallowCopy! !!Object methodsFor: '*ma object serialization' stamp: 'cmm 2/13/2005 21:54'!maStreamVariablyInto: aMaVariableBuffer for: aMaObjectSerializer	"Put the receivers instance variables (both named and indexed) into aMaVariableObjectBuffer."	1		to: self maInstSize		do:			[ : index |			(self maIsTransient: index)				ifFalse:					[ aMaVariableBuffer						maInstVarAt: index						put: (aMaObjectSerializer oidFor: (self instVarAt: index)) ] ]! !!Object methodsFor: '*magma client' stamp: 'cmm 4/13/2005 13:37'!materializedFromMagma: aMagmaMaterializationEvent	"Sigh.  Instance-based event listeners are required for every instance, so here is an opportunity to register.  Another way to do this is to simply send 		myMagmaSession		when: #materializedFromMagma 		send: #yourMaterializationHandlerSelector:  (the arg is a MagmaMaterializationEvent)		to: yourObjectIf you use this method-based approach instead, be sure to call super."	"do nothing by default."! !!TSTreeNode class methodsFor: 'as yet unclassified' stamp: 'avi 9/22/2004 01:03'!key: aCharacter	^ self basicNew initializeWithKey: aCharacter! !!TSTreeNode methodsFor: 'private' stamp: 'avi 12/13/2004 13:02'!canBeCulled	^ self value isNil		and: [low isNil]		and: [equal isNil]		and: [high isNil]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 12/13/2004 13:02'!cullNode: aNode	low == aNode ifTrue: [^ low _ nil].	equal == aNode ifTrue: [^ equal _ nil].	high == aNode ifTrue: [^ high _ nil]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:00'!do: aBlock	self nodesDo: [:ea | ea value ifNotNilDo: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:03'!initializeWithKey: aCharacter	key _ aCharacter! !!TSTreeNode methodsFor: 'private' stamp: 'avi 12/13/2004 13:26'!lookupString: aString startingAt: i"inlined for performance""	self		lookupString: aString		startingAt: i		whenFound: [^ value]		whenNil: [:c | ^ nil]		recurseWith: [:node :j | ^ node lookupString: aString startingAt: j]"	| char |	char := aString at: i.	char = key		ifTrue:			[aString size = i				ifTrue: [^ value]				ifFalse: [^ equal ifNotNil: [equal lookupString: aString startingAt: i+1]]]		ifFalse:			[char < key				ifTrue: [^ low ifNotNil: [low lookupString: aString startingAt: i]]				ifFalse: [^ high ifNotNil: [high lookupString: aString startingAt: i]]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:41'!lookupString: aString startingAt: i insert: anObject	self		lookupString: aString		startingAt: i		whenFound: [self value: anObject]		whenNil: [:c | self newNodeWithKey: c]		recurseWith: [:node :j | node lookupString: aString startingAt: j insert: anObject]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:04'!lookupString: aString startingAt: i whenFound: foundBlock whenNil: nilBlock recurseWith: recurseBlock	| char |	char := aString at: i.	char = key		ifTrue:			[aString size = i				ifTrue: [foundBlock value]				ifFalse: [equal ifNil: [equal := nilBlock value: (aString at: i+1)].						 recurseBlock value: equal value: i+1]]		ifFalse:			[char < key				ifTrue: [low ifNil: [low := nilBlock value: char].						recurseBlock value: low value: i]				ifFalse: [high ifNil: [high := nilBlock value: char].						recurseBlock value: high value: i]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:04'!matchesForPrefix: aString startingAt: i do: aBlock	self		lookupString: aString		startingAt: i		whenFound: [value ifNotNil: [aBlock value: value].  equal ifNotNil: [equal do: aBlock]]		whenNil: [:c | ^ self]		recurseWith: [:n :j | n matchesForPrefix: aString startingAt: j do: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 10/20/2004 21:27'!matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock		| char d2 |	nodeBlock value: self.	d < 0 ifTrue: [^ self].		char := aString at: i.	(d > 0 or: [char < key])		ifTrue: [low ifNotNil: [low matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock]].			d2 := char = key ifTrue: [d] ifFalse: [d-1].	(i + d2 = aString size and: [value notNil]) ifTrue: [aBlock value: value].	equal ifNotNil: [equal matchesForString: aString startingAt: (i+1 min: aString size) distance: d2 do: aBlock nodesDo: nodeBlock].		(d > 0 or: [char > key])		ifTrue: [high ifNotNil: [high matchesForString: aString startingAt: i distance: d do: aBlock nodesDo: nodeBlock]]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:41'!newNodeWithKey: aCharacter	^ self class key: aCharacter! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 00:51'!nodesDo: aBlock	aBlock value: self.	low ifNotNil: [low nodesDo: aBlock].	equal ifNotNil: [equal nodesDo: aBlock].	high ifNotNil: [high nodesDo: aBlock]! !!TSTreeNode methodsFor: 'private' stamp: 'avi 12/13/2004 13:10'!removeString: aString startingAt: i	| val |	self		lookupString: aString		startingAt: i		whenFound: [val _ self value. self value: nil]		whenNil: [:c | ^ nil]		recurseWith:			[:node :j |			val _ node removeString: aString startingAt: j.			node canBeCulled ifTrue:				[self cullNode: node]].	^ val! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 00:51'!value	^ value! !!TSTreeNode methodsFor: 'private' stamp: 'avi 9/22/2004 01:41'!value: anObject	value _ anObject! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/10/2005 18:04'!installClassAccessorOverride	class 		compileSilently:'maOriginalClass	^ self class superclass'		classified: 'standard'! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/4/2005 14:24'!installInstVarAtPutOverride	self shouldOverrideInstVarAtPut ifTrue:		[ class compileSilently:			'instVarAt: aNumber put: anObject				| shouldSignal |				shouldSignal := (super instVarAt: aNumber) ~~ anObject.				shouldSignal ifTrue: [ self writeBarrier aboutToModify: self ].				super instVarAt: aNumber put: anObject.				shouldSignal ifTrue: [ self writeBarrier modified: self ]'				classified: 'standard' ]! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/3/2005 16:48'!installOverrideOf: aSymbol fields: anArray	class 		addSelectorSilently: aSymbol 		withMethod:			(MagmaWbMethodBuilder 				selector: aSymbol 				class: class 				fields: anArray) compiledMethod.	fieldsCache at: aSymbol put: anArray! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/10/2005 18:03'!installStandardOverrides	super installStandardOverrides.	self 		installClassAccessorOverride ;		installInstVarAtPutOverride! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/10/2005 19:55'!migrateFromTarget: oldSuperclass to: newSuperclass	| oldClass |self halt.	oldClass _ class.	"Was the immediate WriteBarrier superclass modified (or was it a superclass of that)?"	(oldClass superclass == newSuperclass)		ifTrue:			[ oldClass superclass: oldSuperclass.			class _ self createSubclassOf: newSuperclass.			class updateInstancesFrom: oldClass ]		ifFalse:			[ "Although my class refers to the proper superclass, it must be rebuilt because its format has changed and must now be updated."			class _ self createSubclassOf: oldClass superclass.			ClassBuilder new mutate: oldClass to: class"			self				updateInstancesOf: oldClass				to:  class" ]! !!MagmaWbClassBuilder methodsFor: 'as yet unclassified' stamp: 'cmm 4/4/2005 14:20'!shouldOverrideInstVarAtPut	^ self class isPointers! !!WBClassBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:11'!target: aClass barrier: aBarrier	^ self basicNew initializeWithTarget: aClass barrier: aBarrier! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:46'!allSelectorsDo: aBlock	((self targetClass withAllSuperclasses copyWithout: Object) copyWithout: ProtoObject) do:		[:cls |		cls selectors do: aBlock]! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:17'!barrierClass	^ class! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 12:01'!checkClassFormat: anEvent	((class format ~~ class superclass format) or: [anEvent areInstVarsModified]) ifTrue:		[self migrateFromTarget: anEvent oldItem to: anEvent itemClass]! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:28'!checkOverrideOf: aSymbol	| fields |	fields _ self targetClass fieldsWrittenToBySelector: aSymbol.	fields isEmpty 		ifTrue: [(class selectors includes: aSymbol)					ifTrue: [class removeSelectorSimply: aSymbol]]		ifFalse: [(fields = (fieldsCache at: aSymbol ifAbsent: []))					ifFalse: [self installOverrideOf: aSymbol fields: fields]]! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/23/2004 14:28'!createSubclassOf: aClass	| meta |	meta _ Metaclass new.	meta		superclass: aClass class		methodDictionary: MethodDictionary new		format: aClass class format.	class _ meta new.	class		superclass: aClass		methodDictionary: MethodDictionary new		format: aClass format.	class setName: aClass name, '*'.	^ class! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:11'!initializeWithTarget: aClass barrier: aBarrier	aClass ensureUncompact.	barrier _ aBarrier.	class _ self createSubclassOf: aClass.	fieldsCache _ Dictionary new.	self installOverrides.! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 13:37'!installAccessingOverrides	class addSelector: #writeBarrier withMethod:		(BytecodeGenerator new			numArgs: 0;			pushLiteral: (WeakArray with: barrier);			send: #first;			returnTop;			compiledMethod).	class compileSilently:		'species		|species|		species _ super species.		^ species = self class			ifTrue: [self class superclass]			ifFalse: [species]'		classified: 'accessing'! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 4/3/2005 01:26'!installAtPutOverrides	self shouldOverrideAtPut ifTrue:		[class compileSilently:			'at: aNumber put: anObject				| shouldSignal |				shouldSignal := (super at: aNumber) ~~ anObject.				super at: aNumber put: anObject.				shouldSignal ifTrue: [ self writeBarrier modified: self ]'				classified: 'standard']! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:46'!installFieldOverrides	| fields |	self allSelectorsDo:		[:ea |		fields _ self targetClass fieldsWrittenToBySelector: ea.		fields isEmpty ifFalse: [self installOverrideOf: ea fields: fields]]! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 17:27'!installGOODSOverrides	class class compileSilently: 'goodsClassName ^ self superclass name' classified: 'goods'! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:23'!installOverrideOf: aSymbol fields: anArray	class addSelectorSilently: aSymbol withMethod:		(WBMethodBuilder selector: aSymbol class: class fields: anArray)			compiledMethod.	fieldsCache at: aSymbol put: anArray! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 14:25'!installOverrides	self installStandardOverrides.	self installFieldOverrides.  ! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 17:26'!installStandardOverrides	self installAtPutOverrides.	self installTestingOverrides.	self installAccessingOverrides.	self installGOODSOverrides.! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:13'!installTestingOverrides	class		compileSilently: 'isBehindWriteBarrier ^ true'		classified: 'writebarrier'! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:05'!migrateFromTarget: oldSuperclass to: newSuperclass	| oldClass |	oldClass _ class.	oldClass superclass: oldSuperclass.	class _ self createSubclassOf: newSuperclass.	class updateInstancesFrom: oldClass! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:46'!rebuildMethods	self allSelectorsDo: [:ea | self checkOverrideOf: ea]! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:17'!shouldOverrideAtPut	^ class isVariable! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:06'!systemChanged: anEvent	anEvent itemKind = #method ifTrue:		[(anEvent isRemoved and: [class selectors includes: anEvent itemSelector])			ifTrue: [class removeSelectorSimply: anEvent itemSelector].		self checkOverrideOf: anEvent itemSelector].	anEvent itemKind = #class ifTrue:		[anEvent isModified ifTrue:			[self checkClassFormat: anEvent.			self rebuildMethods]].! !!WBClassBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 01:33'!targetClass	^ class superclass! !!MagmaWbMethodBuilder methodsFor: 'private' stamp: 'cmm 4/7/2005 12:26'!buildCompiledMethod"I was going to use this to try to capture index key-changes, but it turns out that is a flawed concept (see WhyNoChangedKeyAutoDetection.jpg).		Still, I decided to keep the code for preNotifying around since it might come in useful in the future."	^ super buildCompiledMethod"	generator _ BytecodeGenerator new numArgs: selector numArgs.	self generateStoreFields.	self generatePreNotification.	self generateCallSuper.	self generateCheckFields.	self generateReturn.	self generateNotification.	self generateReturn.	^ generator compiledMethod"! !!MagmaWbMethodBuilder methodsFor: 'private' stamp: 'cmm 4/3/2005 16:47'!generatePreNotification	generator label: #preNotify.	generator pushReceiver.	generator send: #writeBarrier.	generator pushReceiver.	generator send: #aboutToModify:! !!WBMethodBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:28'!initialize	Cache _ WeakIdentityKeyDictionary new.	WeakArray addWeakDependent: Cache! !!WBMethodBuilder class methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:51'!selector: aSymbol class: aClass fields: anArray	^ self basicNew		initializeWithSelector: aSymbol		class: aClass		fields: anArray! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:28'!buildCompiledMethod	generator _ BytecodeGenerator new numArgs: selector numArgs.	self generateStoreFields.	self generateCallSuper.	self generateCheckFields.	self generateReturn.	self generateNotification.	self generateReturn.	^ generator compiledMethod! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:28'!compiledMethod	^ Cache at: (class lookupSelector: selector) ifAbsentPut: [self buildCompiledMethod]! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:07'!generateCallSuper	generator pushReceiver.	1 to: selector numArgs do: [:i | generator pushTemp: i].	generator send: selector toSuperOf: class.	generator storePopTemp: self returnValueTemp! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:09'!generateCheckField: aNumber	generator pushInstVar: aNumber.	generator pushTemp: (self tempForField: aNumber).	generator send: #==.	generator if: false goto: #notify.! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:49'!generateCheckFields	fields do: [:i | self generateCheckField: i]! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:15'!generateNotification	generator label: #notify.	generator pushReceiver.	generator send: #writeBarrier.	generator pushReceiver.	generator send: #modified:! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:53'!generateReturn 	generator pushTemp: self returnValueTemp.	generator returnTop! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:43'!generateStoreField: aNumber	generator pushInstVar: aNumber.	generator storePopTemp: (self tempForField: aNumber)! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:42'!generateStoreFields	fields do: [:i | self generateStoreField: i]! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:51'!initializeWithSelector: aSymbol class: aClass fields: anArray	selector _ aSymbol.	class _ aClass.	fields _ anArray! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:48'!returnValueTemp	^ selector numArgs + fields size + 1! !!WBMethodBuilder methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 11:44'!tempForField: aNumber	^ selector numArgs + (fields indexOf: aNumber)! !!WBMock methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:21'!lazyX	^ x ifNil: [x _ 42]! !!WBMock methodsFor: 'tests' stamp: 'avi 10/7/2004 13:54'!x: n x _ n! !!WBMock methodsFor: 'tests' stamp: 'avi 10/7/2004 13:54'!y ^ y! !!WBMock methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 12:20'!y: anObject	y _ anObject! !!WriteBarrier commentStamp: '<historical>' prior: 0!A WriteBarrier provides a way to watch for changes to the state of individual objects.  Any objects that you #add: to a WriteBarrier will be modified in the following ways:- their class will be changed to be a new, anonymous subclass of whatever their class was before.  For example, if you #add: an Array to a WriteBarrier, it will now be of class "Array with write barrier", which is a subclass of Array (although it won't show up in "Array subclasses").- any methods that potentially modify instance variables will be overriden in this new class.  The overridden method stores the original values of the instance variable in temps, then calls the super method, and then compares the current inst var values with the originals.- If the instance variable values have changed, the WriteBarrier will be notified with a send to #modified:, with the object that was modified as the single argument.- For variably-sized classes, #at:put: is also overridden to provide the same notification.- the new class will override #isBehindWriteBarrier to return true, and will implement #writeBarrier to return the WriteBarrier instance.The default implementation of #modified: doesn't do anything.  DirtySetWriteBarrier is a subclass that overrides #modified: to maintain a set of objects that have recently changed.  You may wish to create your own subclass with an alternate implementation.Notes:- You can only add any given object to one WriteBarrier.  If you try to add it to a second one, you will get an error.- The classes of any objects you add to a WriteBarrier will be made uncompact.  For most compact classes (Array, String, Point, etc) the only effect this should have is to increase your image size by a few percent.  For some classes (CompiledMethod, MethodContext), the results are less predictable, and so adding them to a WriteBarrier is not supported.- Because it's special cased by the VM, sending #class to an object will return the special anonymous class.  However, sending #species will still return the normal class (or whatever #species would have returned normally).- The WriteBarrier is semi-permeable: if you want to modify an object directly without triggering notifications, you can use #instVarAt:put: and #basicAt:put:.!!DirtySetWriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:58'!clearDirtySet	dirty _ IdentitySet new! !!DirtySetWriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:58'!dirtySet	^ dirty copy! !!DirtySetWriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:58'!initialize	super initialize.	self clearDirtySet! !!DirtySetWriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:58'!isDirty: anObject	^ dirty includes: anObject! !!DirtySetWriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:58'!modified: anObject	dirty add: anObject! !!MaTransaction commentStamp: '<historical>' prior: 0!This class is private.  Applications should use the transaction control provided onMagmaSession.!!MaTransaction class methodsFor: 'creation'!session: aMagmaSession	^self new session: aMagmaSession! !!MaTransaction methodsFor: 'deprecated' stamp: 'cmm 4/7/2005 12:24'!aboutToModify: anObject	"This is called by WriteBarrier subclasses (#preNotify) which is generated by MagmaWbMethodBuilder>>#generatePreNotification.  I was going to use this to try to capture index key-changes, but it turns out that is a flawed concept (see WhyNoChangedKeyAutoDetection.jpg).		Still, I decided to keep the code for preNotifying around since it might come in useful in the future."! !!MaTransaction methodsFor: 'private' stamp: 'cmm 7/4/2005 16:18'!addChangesFromReadSet	| truncateds |	truncateds _ OrderedCollection new.	readSet keysAndValuesDo:		[ : eachCurrent : eachBuffer |  | didChange |		didChange _ self didChange: eachCurrent from: eachBuffer.		didChange			ifTrue:				[ (session serializer isTruncated: eachCurrent)					ifTrue: 						[ (truncateds ifNil: [ truncateds _ OrderedCollection new ]) add: eachCurrent ].				commitPackage addObject: eachCurrent ] ].	self warnOfTruncationsIn: truncateds! !!MaTransaction methodsFor: 'private' stamp: 'cmm 3/27/2005 17:02'!addLargeCollectionChangesTo: aMaCommitPackage	largeCollectionChanges do:		[ :each |		each hasChanges			ifTrue:				[ aMaCommitPackage					addLargeCollectionChanges: each					using: session ] ]! !!MaTransaction methodsFor: 'building' stamp: 'brp 12/22/2005 18:22'!captureOldHashesFor: anObject	largeCollectionChanges do:		[ :eachChanges |		(eachChanges collection canIndex: anObject)			ifTrue:				[ eachChanges collection indexes do:					[ :eachIndex | | oldKeys oldHashes |					oldKeys := potentialKeysChange 								at: anObject ifAbsentPut: [ IdentityDictionary new ].					oldHashes := oldKeys								at: eachIndex attribute ifAbsentPut: [ OrderedCollection new ].					oldHashes						add: { eachChanges. eachIndex. eachIndex indexHashesFor: anObject } ] ] ]! !!MaTransaction methodsFor: 'accessing' stamp: 'cmm 4/5/2005 21:31'!changedObjects	| preservedCommitPackage answer |	"this method must be non-destructive to the my commitPackage because it may be requested again."	preservedCommitPackage _ commitPackage copyWithNewLargeCollectionChanges.  "It should actually be ok to share its 'objects'."	self		addChangesFromReadSet ;  "another potential truncation warning"		recordPotentialKeyChanges ;		addLargeCollectionChangesTo: commitPackage.	answer _ commitPackage.	commitPackage _ preservedCommitPackage.	^ answer! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 5/3/2005 16:13'!cleanUpWriteBarrier	commitPackage objectsDo:		[ : each | 		(each isBehindWriteBarrier and: [ each writeBarrier == self ])			ifTrue:				[ self remove: each.				session isConnected ifTrue: [ session refresh: each ] ] ].	self resetCommitPackage! !!MaTransaction methodsFor: 'testing' stamp: 'cmm 7/12/2005 13:21'!didChange: anObject	^ self		didChange: anObject		from: (readSet at: anObject ifAbsent: [ ^ false ])! !!MaTransaction methodsFor: 'testing' stamp: 'brp 7/5/2005 09:26'!didChange: anObject from: aMaObjectBuffer	"Answer whether anObject has changed for this transaction."	^ (self useWriteBarrierOn: anObject) not		and: 		[ "The WriteBarrier will avoid the performance-penalty of this line."		aMaObjectBuffer 			isDifferent: anObject 			using: session serializer ]! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 4/6/2005 22:02'!ensureOldHashesCapturedFor: anObject	"What we need to do here is capture the before-keys of any object which, potentially belonging to a MagmaCollection, potentially changing its key by way of its instVars being changed so that we may, in modified: actually determine whether we should record the changed-key in my commitPackage."	(potentialKeysChange includesKey: anObject) ifTrue: [ ^ self ].	self captureOldHashesFor: anObject! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 5/3/2005 12:56'!ensureOldHashesCleanedFor: anObject	"What we need to do here is capture the before-keys of any object which, potentially belonging to a MagmaCollection, potentially changing its key by way of its instVars being changed so that we may, in modified: actually determine whether we should record the changed-key in my commitPackage."	potentialKeysChange 		removeKey: anObject		ifAbsent: [ "do nothing" ]! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 1/20/2003 22:30'!finalizeOids	readSet finalizeValues! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 9/21/2005 00:43'!initialize	super initialize.	readSet := WeakIdentityKeyDictionary new.	largeCollectionChanges := WeakSet new.	self resetCommitPackage! !!MaTransaction methodsFor: 'accessing'!largeCollectionChanges	^largeCollectionChanges! !!MaTransaction methodsFor: 'building' stamp: 'cmm 4/8/2005 12:40'!markRead: anObject using: aMaObjectBuffer	| useWriteBarrier |	anObject isImmutableInMagma ifTrue: [ "can't change, don't bother recording my state." ^ anObject ].		(useWriteBarrier _ self useWriteBarrierOn: anObject)		ifTrue:			[ self add: anObject.			commitPackage removeObject: anObject ].	(useWriteBarrier not	or: [ session preferences refreshPersistentObjectsEvenWhenChangedOnlyByMe ])		ifTrue:			[ self				persistentRepresentationOf: anObject				is: aMaObjectBuffer ].	anObject maIsLargeCollection 		ifTrue:			[ self monitorLargeCollectionChanges: anObject changes.			anObject session: session ].	^ anObject! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 4/4/2005 13:23'!modified: anObject	(session serializer isTruncated: anObject)		ifTrue:			[ self warnOfTruncationsIn: { anObject } ].	commitPackage addObject: anObject! !!MaTransaction methodsFor: 'building' stamp: 'cmm 3/16/2005 12:43'!monitorLargeCollectionChanges: aMaLargeCollectionChanges	largeCollectionChanges add: aMaLargeCollectionChanges! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 4/3/2005 16:42'!newBuilderForClass: aClass	MagmaNotification signal: 'Compiling anonymous subclass of ', aClass name.	^ MagmaWbClassBuilder		target: aClass 		barrier: self! !!MaTransaction methodsFor: 'private' stamp: 'cmm 10/8/2004 17:36'!persistentRepresentationOf: anObject is: aMaObjectBuffer	readSet		at: anObject		put: aMaObjectBuffer! !!MaTransaction methodsFor: 'building' stamp: 'brp 12/22/2005 18:32'!recordPotentialKeyChanges	potentialKeysChange keysAndValuesDo:		[ :eachObject :eachKeys |			eachKeys valuesDo: 				[ :eachHashes |					eachHashes do: 						[ :eachCio | "#( changes index, oldHash )"							self								recordPotentialKeyChangesFrom: eachCio last								of: eachObject								index: eachCio second								in: eachCio first ] ] ]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 4/7/2005 17:27'!recordPotentialKeyChangesFrom: oldHashValues of: anObject index: aMaIndexDefinition in: aMagmaCollectionChanges	| newHashValues |	anObject ifNil: [ ^ self ].	newHashValues _ aMaIndexDefinition indexHashesFor: anObject.	"If hash index value has changed."	(oldHashValues maConsistsOf: newHashValues)		ifFalse:			[ | common |			common _ oldHashValues intersection: newHashValues.			aMagmaCollectionChanges				move: anObject				from: (oldHashValues removeAll: common; yourself)				to: (newHashValues removeAll: common; yourself)				forIndexedAttribute: aMaIndexDefinition attribute ]! !!MaTransaction methodsFor: 'building' stamp: 'cmm 10/23/2002 21:20'!remove: anObject	readSet		removeKey: anObject		ifAbsent: [ "do nothing" ]! !!MaTransaction methodsFor: 'initializing' stamp: 'cmm 9/21/2005 00:43'!resetCommitPackage	commitPackage := MaCommitPackage new.	"potentialKeyChanges are only ever part of a single commit-package, so reset those too."	potentialKeysChange := WeakIdentityKeyDictionary new! !!MaTransaction methodsFor: 'actions' stamp: 'cmm 7/10/2006 12:21'!restore	"restore all changed objects to their state as read from the repository."	largeCollectionChanges do: [ : each | each initialize ].	readSet keysAndValuesDo:		[ : eachOriginal : eachBackup | 		eachBackup			refresh: eachOriginal			using: session ]! !!MaTransaction methodsFor: 'private'!session: aMagmaSession	session _ aMagmaSession! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 3/27/2005 22:47'!useWriteBarrierOn: anObject	^ anObject maAllowsWriteBarrier		and: [ session preferences allowWriteBarrier		and: 			[ "this only here for documentation purposes, we will never get here because classDefinitionsById is a Dictionary."			anObject ~~ session serializer classIdManager classDefinitionsById ] ]! !!MaTransaction methodsFor: 'writebarrier' stamp: 'cmm 3/27/2005 22:56'!validateWriteBarrier: aBoolean	"We can't allow them to stop using the writeBarrier in the middle of a transaction in which objects are already changed.."	aBoolean		ifFalse:			[ commitPackage objects notEmpty				ifTrue:					[ MagmaUserError signal: 'Cannot stop using writeBarrier in the middle of a transaction.' ] ]! !!MaTransaction methodsFor: 'private' stamp: 'cmm 4/10/2005 18:00'!warnOfTruncationsIn: aCollection 	aCollection isEmptyOrNil 		ifFalse: 			[MagmaTruncationWarning 				signal: (String streamContents: 							[:stream | 							stream nextPutAll: 'Your definition of '.							(aCollection collect: [:each | each maOriginalClass name]) asSet do: 									[:each | 									stream										nextPutAll: each;										nextPutAll: ', '].							stream 								nextPutAll: 'are missing instance variables present in the repository-version.  If you proceed with this commit, information in one or more of these instances will be lost.'])]! !!WriteBarrier methodsFor: 'public' stamp: 'avi 10/7/2004 03:14'!add: anObject	anObject isBehindWriteBarrier		ifTrue: [anObject writeBarrier = self ifFalse:					[self error: 'This object is already behind another write barrier.']]		ifFalse:			[anObject primitiveChangeClassTo:				(self barrierClassForClass: anObject class) basicNew]! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:25'!barrierClassForClass: aClass	^ (self builderForClass: aClass) barrierClass! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:22'!builderForClass: aClass	^ builders at: aClass ifAbsentPut: [self newBuilderForClass: aClass]! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 11:57'!initialize	builders _ WeakIdentityKeyDictionary new.	WeakArray addWeakDependent: builders.	self registerForNotifications ! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:45'!modified: anObject! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:11'!newBuilderForClass: aClass	^ WBClassBuilder target: aClass barrier: self! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/6/2004 13:40'!registerForNotifications	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #systemChanged:! !!WriteBarrier methodsFor: 'public' stamp: 'avi 10/7/2004 13:11'!remove: anObject	anObject isBehindWriteBarrier ifTrue:		[anObject writeBarrier == self ifFalse: [^ self error: 'This object is behind a different write barrier.'].		anObject primitiveChangeClassTo: anObject class superclass basicNew]! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 03:18'!storeOn: aStream	aStream nextPutAll: 'self writeBarrier'! !!WriteBarrier methodsFor: 'as yet unclassified' stamp: 'avi 10/7/2004 02:15'!systemChanged: anEvent	builders keysAndValuesDo:		[:class :builder |		(class withAllSuperclasses includes: anEvent itemClass) ifTrue:			[builder systemChanged: anEvent]]! !!WriteBarrier methodsFor: 'public' stamp: 'avi 10/6/2004 13:56'!unregister	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self! !!MaBaseAdditionsPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2003 00:05'!prerequisitePackages	^#('Ma exception handling')! !!MaBaseAdditionsPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/9/2005 19:27'!readmeText	^'I consist of just over 50 method extensions that all begin with the letters "ma".  These are methods that I needed for one or more of the other "Ma" frameworks, but felt it was general enough to be useful to other programs.'! !!MaClientServerPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/31/2003 00:20'!additionalFiles	^#('clientTest.ws' 'serverTest.ws')! !!MaClientServerPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 4/8/2004 23:13'!changesText	^ 'version 5:	updated for 3.6 and 3.7.  This version does not work with 3.5.version 4:	running servers now survive image restarts.  The network is initialized by MaClientSocket upon starting the image, allowing sockets to immediately reconnect upon image start up.version 3:  performance improvement  support for multiple clients in the same image connected to the same remote serverversion 2:  Should now support big and little endian machines simultaneously.version 1:  Initial public release.'! !!MaClientServerPackageInfo methodsFor: 'accessing' stamp: 'cmm 4/8/2004 23:11'!prerequisitePackages	^ #( 'Ma object serialization' )! !!MaClientServerPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2003 22:54'!readmeText	^'!!!!Ma client server!!!!IntroductionI can help you write a client-server program very easily.In the client-server model, a client sends a request to a server, the server processes the request and sends back a response.This framework provides two layers interoperation.  You choose which layer you want to use and then write two programs.  A client program that will send requests to a remote server, which is running the other program to process those requests.If you choose the lower layer, the "socket layer," you send ByteArray requests and receive ByteArray responses.  In the upper layer, the "object request layer" you send arbitrary request objects and get arbitrary objects as responses.  The "Ma object serialization" framework is used to convert the objects to ByteArrays which are sent and received for you using the socket layer.!!!!Using the Socket Layer!!Setting up the serverIf you just need to send and receive ByteArray''s, you write your server program any way you want.  Just keep in mind that, somewhere, you''re going to want to take-in a ByteArray as input and you must answer a ByteArray as the response.Then, to start the server:=	myServerSocket _ MaServerSocket new=		listenOn: 12345=		answer:=			[ :requestByteArray |=			... give requestByteArray to your server program ... ]MaServerSocket utilizes SharedQueue''s and background Processes to ensure that request processing is not held up by sending or receiving the ByteArray''s, which occurs entirely in the background.  The answer block is only ever evaluated for one client request at a time.When you''re done, be sure to shutdown the socket so resources are properly deallocated:=	myServerSocket shutdown!!Getting answers in the clientYour client program creates a MaClientSocket by specifying the ip address as numbers in a ByteArray:=	mySocket _ MaClientSocket hostAddress: #(192 168 1 1) port: 12345.No connections are made just from creating the socket.  That happens when you actually send the request:=	responseByteArray _ mySocket sendData: myRequestByteArrayThere''s also a sendData:startingAt:count:waitForReplyIn: method for maximum efficiency.  If the reply ByteArray you supply wasn''t large enough, you''ll get a bigger one.!!Socket EventsMaServerSocket knows about a "server", which defaults to a Server that does nothing (MaServer).  But you subclass MaServer and override some of its methods to learn when a socket is queued, a ByteArray request has been fully delivered, or sending a response, etc.  See MaServer for more information.!!!!Using the Object Request LayerIf you choose to use the object request layer, you send "request" objects and get back arbitrary response objects.  So you write your client and server programs the same except you don''t concern yourself with parsing ByteArrays anymore.!!Setting up the serverWhen you are ready to start your server program, instead of creating a MaServerSocket, you create a MaTcpRequestServer:=	myServer _ MaTcpRequestServer protocol: { MyRequestClass1. MyRequestClass2.  MyResponseClass1.  MyResponseClass2.  OrderedCollection.  Dictionary. "etc." }.What''s this?  Yes, you have to tell it all the classes that you''ll be sending and receiving, accounting for the full object-graph of your requests.  For example, if you have SubmitArticleRequest that has an Article object, you must include not only SubmitArticleRequest, Article and all the other kinds of objects that Article references, and what they reference, and so on.  You don''t however, need to ever specify String, ByteArray, Set, Symbol or Array.  Those are automatically part of every protocol.You may also optionally specify a MaServerConsole to receive events.  Subclass MaServerConsole and override one of its notification methods and it''ll be called if you:=	myServer _ console: myConsoleWhen you''re ready to start the server, you use processOn:do:=	myServer=		processOn: 12345=		do:=			[ :requestObject |=			... pass requestObject to your server program, which answers the response ... ]When you''re done, you need to shutdown to release operating system resources:=	myServer shutdown!!Setting up the clientYour client program creates a MaTcpRequestServerLink pointing to the server hostAddress and port is is listening:=	myLinkToServer _ MaTcpRequestServerLink=		hostAddress: #(192 168 1 1)=		port: 12345Before you can do anything, you have to connect.  This will ensure you have all the needed protocol in this client image (and throw an exception if you don''t).=	myLinkToServer connectTo balance network fluctuations against your patience, you may wish to override the default timeout period from 30 seconds:=	myLinkToServer timeoutSeconds: 30!!Getting answers in the clientNow that you''re connected, your client program can get answers from the server by:=	myLinkToServer submit: someRequestObjectRemember, someRequestObject will be a member of the protocol, as will the response you get back from calling submit:.That''s it!!  When you''re done, don''t forget to disconnect so as you release network resources back to the operating system.=	myLinkToServer disconnect'! !!MaObjectSerializationPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/29/2003 23:37'!prerequisitePackages	^#('Ma proxy support' 'Ma special collections' 'Ma traverse object graphs')! !!MaObjectSerializationPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2003 00:41'!readmeText	^'I am a general object serialization and materialization framework.  Currently, I convert objects to ByteArrays and back.  I am used by both the "Ma client server" and "Magma" packages.  I offer a lot of flexibility in the way objects are serialized and materialized, even to the way the object graphs are traversed during serialization (courtesy of "Ma object serialization").The major class is MaObjectSerializer, see it for more information.  It utilizes a MaDefaultOidManager, a MaDefaultClassIdManager, and a MaObjectGraphTraversalStrategy to create a MaSerializedGraphBuffer, the final object that wraps the ByteArray.'! !!MaSpecialCollectionsPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 12/29/2005 23:55'!readmeText	^'I provide several independent, special-purpose collection classes that seem to be generally useful.MaWeakIdentityKeyDictionary and MaWeakValueDictionary wrap a collection of their Smalltalk counterparts and keeps them all under 12-bits in size, thus minimizing the number of collisions due to Squeaks 12-bits identity hash.  These provide major improvement in the #removeKey: message.MaTree is one of my first attempts at a Smalltalk collection.  I never actually used it though I decided to keep it around.  It''s API compatible with the other collections.  To play with an example:	MaTree new		add: ''Great Grandma'';		add: ''Grandma'' asChildOf: ''Great Grandma'';		add: ''Mom'' asChildOf: ''Grandma'';		yourselfMaIntervalCollection is can efficiently track interval ranges and merge them when they get within their proximityThreshold.  This is useful for recording occupied space in a memory map, or perhaps grouping entities based on their proximity to each other.  Example:	(MaIntervalCollection proximityThreshold: 1)		addFrom: 5 to: 10;		addFrom: 15 to: 20;		addFrom: 25 to: 30;		addFrom: 21 to: 24;		yourselfMaLargeArrayOfNumbers is an auto-growing, never-shrinking array of numbers.  All numbers have the same number of bits available to represent them.  It maintains the collection in a single randomly-accessed file, and is therefore constrained by available disk space or the addressability of the file.	MaLargeArrayOfNumbers create: filenameString bitSize: 32.	myArray _ MaLargeArrayOfNumbers open: filenameString.	myArray		at: 10 put: 8734 ;		at: 11 put: 6199 ;		yourself	"be sure to #close it when you are done."MaHashIndex is another file-based, large-collection of uniformly-sized numbers.  It is much slower but more flexible than MaLargeArrayOfNumbers.  It allows pages between any two key ranges via:	#upTo: countInteger keysAndValuesFrom: lowKey to: highKey startingAt: indexand pages between any two absolute positions via:	#upTo: countInteger keysAndValuesFromIndex: lowIndexOther features are:	- supports key and value sizes from 16 to 256 bits	- supports duplicate keys	- includes test cases that demonstrate its capability and correctness	MaHashIndex 		create: fileNameString 		keySize: 64 		hashRecordSize: 10.	myIndex _ MaHashIndex open: filenameString.	myIndex		add: 8734 at: 10 ;		add: 1212 at: 10 ;  "duplicate key ok"		add: 6199 at: 11 ;		yourself.	"be sure to #close it when you are done."'! !!MaTimeObjectsPackageInfo methodsFor: 'accessing' stamp: 'cmm 3/21/2004 16:39'!prerequisitePackages	^ #( 'Ma base additions' )! !!MaTimeObjectsPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 4/2/2004 12:53'!readmeText	^'I can help you deal with aspects of time using a pleasant API.  The core domain class is MaCalendarTime, which can represent either a point on the Gregorian calendar, or a duration of Gregorian time (e.g., seconds, days, etc.).  MaCalendarTime is storage efficient, wrapping only a single Integer, and is precise to the millisecond.To get the current time, precise to the millisecond:	MaCalendarTime nowTo obtain a duration:	3 maMinutesA variety of arithmetic is supported:	3 maMinutes + 2 maSeconds	8 maHours // 2	(1 maHour + 27  maMinutes) roundTo: 30 maMinutes	MaCalendarTime now - 30 maDays	MaCalendarTime now - (MaCalendarTime fromString: ''1969/12/31 23:52:59.999'')*** MaStopwatch ***is the other cool domain class.  This is, literally, a stopwach just like you would use in real life.  I use it to time things, such as how long it has been since I last signaled a ProgressNotification, that way I can do them only ever five seconds or so.  Inspect this and play with it, it''s simple:	MaStopwatch new start'! !!MaTraverseObjectGraphsPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 1/30/2003 11:54'!prerequisitePackages	^#('Ma proxy support')! !!MagmaClientPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 3/15/2005 22:44'!changesText	^'1.0gamma8	- Live class evolution.  Developers can stay connected to Magma repositories while changing class-definitions and Magma will "do the right thing".	- Magma can now serve as a code-repository for individual classes, change sets and Monticello packages.  The Monticello UI can be used with Magma as the back-end.	- Support for many more classes such as BlockContexts, MethodContexts, CompiledMethods, Metaclasses (by reference), SortedCollections, WeakSets, billion-object Bags and Intervals, PluckedSounds, Speaker (i.e., Klatt) and other Variable-word classes are also supported.	- Nested transactions.  You can now have multiple-levels of transactions and only the outer-most one actually writes them all to the repository.	- Support for transient variables.  You can now specify named variables that you don''t want persisted in the repository.	- stale proxies from disconnected sessions, if provoked, will now try to find the new session and reconnect automatically.	- support for MagmaRepositoryLink objects that can be used to create a session to a local or remote repository without caring about the type of connection.	- MagmaCollection improvements.  New large collections, MagmaSet and MagmaDictionary, MagmaIdentityDictionary and MagmaArray.	- Better error handling.	- Lots of code trimmed.  An entire package, a couple of class-hierarchies, and roughly 100 extension methods to base-classes were cleaned out thanks to various refactorings.1.0gamma7	- Compatible with Squeak 3.7.	- Better support for Symbols (thanks to Brent Pinkney!!).	- fix for storing Exceptions in the repository (to accommodate changes in Squeak 3.6).	- New Date index type for MagmaCollections.	- New Float index type for MagmaCollections.	- MagmaSessions cleaned from MethodContext receivers, allowing full garbage collection (thanks to Giovanni!!).	- Critical bugs with MagmaCollections fixed and now pass the new, extra-stringent tests in the Tester package.1.0gamma6	- works with Squeak 3.6.  Doesn''t work with versions before 3.6.	- fixed issue with servers that were running when the image was saved (functionality implemented in 1.0gamma5).  Fixed similar bug for saving with open local repository connections.	- disconnect now cleans up the proxies for that session.  Please be patient, this can take a while if you have a lot.  Also now cleaning dynamic largeCollection attributes when disconnecting a session.	- fixed bug with creating repository using an unqualified file name.	- fixed an unnoticed reference to platform-specific code (ByteArray>>unsignedByteAt: uses FFI primitives).	- improved the internal system-read-strategy.1.0gamma5	- Servers and clients can now survive image restarts.	- added a new session preference (see MagmaPreferences), "signalProxyMaterialization" so you can capture MagmaNotifications and fine-tune your read strategies.	- Another performance improvement!!  ReadStrategies are now cached on the server, instead of in your MagmaSession, improving read-efficiency when using read strategies because the strategy-object no longer needs to be serialized and transported for every proxy materialization.  Additionally, ReadStrategies for classes that don''t exist in the repository are no longer dropped.  Instead, they are remembered until you put those classes into the repository.	- commit conflicts no longer provide the entire MagmaClientConnection object who conflicted with your session, just the userId.  This is due to the aforementioned cached readStrategy, no need to be sending that down on a commit conflict.	- Since we have eradicated the "root trap" we can make replacing the root consistent with other Magma changes.  A transaction is now required.	- several bug fixes.1.0gamma4Enhancements:	- A new MagmaSessionRequest notification provides a flexible, simple way to signal any session behavior, such as begin and commit from deep within domain classes without them needing to reference a MagmaSession.	- Support for Morphs.	- A new session preference is available.  When signalChangedNotifications is set to true, then, upon crossing of every transaction boundary, all objects in your image that were changed by other users will be sent #magmaChanged, the stub implemented on Object does nothing.	- A substantial performance improvement on commits.	- Tweaked default read-depth down to 2, from 3 seems to have	- MagmaSession>>commitAndBegin is a new method that allows you to commit your current transaction and begin a new one within a single call the server.  This can be used to further improve performance to "load scripts."	- Use MagmaSession>>cachedObjectCount to keep tabs on the how much of the persistent model is in memory, referenced by the program.  There are also new stats on the server side such as number of objects in the repository.	- A new MagmaPreferences global attribute, handStatus, now determines whether the Hand will change to the "write" cursor when committing, the "read" cursor when reading, and the "up" cursor when waiting on the server for anything else.  While mostly just a curiousity, it also allows eyeball-profiling of the time spent in the client vs. the server so you can assess whether your commits are appropriately sized.  - The "root trap" has been eradicated.  Your session will now reference the root every time you begin a transaction and dereferenced as soon as you commit or abort.  Since your transactions will presumably be short, there should be no problem with accumulating too much of the database in memory.Bug fixes:  - Fixed doesNotUnderstand: error with the MagmaRepository>>delete: utility method.  - Improved a bug with materializing proxy''s to Symbols.  It''s slower than other kinds of objects, but should work as long as you never try to materialize a system-needed selector such as #size or #yourself or #add:.  Due to a bug with Squeak''s becomeForward: primitive (the modification of the target objects hash bits), you must be sure to use ReadStrategies to ensure these Symbols NEVER get proxied, or the becomeForward: could lock up Squeak.  So, this includes the actionSelectors of your Morph''s.  For more information, see http://lists.squeakfoundation.org/pipermail/squeak-dev/2003-March/055383.html, or to demonstrate the problem for yourself, evaluate the following (be sure you have saved your image first!!):	String new becomeForward: #size1.0gamma3:  - MagmaCollections performance improvement  - Better support for multiple sessions in the same image, connected to the same remote repository1.0gamma2:  - minor bug fixes  - compatibility with Linux filenames / endianness1.0gamma:  - initial SqueakMap release'! !!MagmaClientPackageInfo methodsFor: 'accessing' stamp: 'cmm 4/2/2004 13:19'!prerequisitePackages	^ #( 'Ma client server' 'Ma dynamic instance variables' 'Ma time objects' )! !!MagmaClientPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 2/4/2003 18:11'!readmeText	^'This package lets you connect to servers hosting Magma databases.For more information:  http://minnow.cc.gatech.edu/squeak/2665'! !!MagmaServerPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 10/31/2004 23:42'!changesText	^'1.0gamma8	- removed "allowNewClasses" feature.  This will be handled with real security later.	- all administration functions are now either remote requests or no longer needed.	- support for first-class MagmaRepositoryCodeBase.1.0gamma7	- Compatible with Squeak 3.7.	- Better support for Symbols (thanks to Brent Pinkney!!).	- fix for storing Exceptions in the repository (to accommodate changes in Squeak 3.6).	- New Date index type for MagmaCollections.	- New Float index type for MagmaCollections.	- MagmaSessions cleaned from MethodContext receivers, allowing full garbage collection (thanks to Giovanni!!).	- Critical bugs with MagmaCollections fixed and now pass the new, extra-stringent tests in the Tester package.	1.0gamma6	- works with Squeak 3.6.  Doesn''t work with versions before 3.6.	- fixed issue with servers that were running when the image was saved (functionality implemented in 1.0gamma5).  Fixed similar bug for saving with open local repository connections.	- disconnect now cleans up the proxies for that session.  Please be patient, this can take a while if you have a lot.  Also now cleaning dynamic largeCollection attributes when disconnecting a session.	- fixed bug with creating repository using an unqualified file name.	- fixed an unnoticed reference to platform-specific code (ByteArray>>unsignedByteAt: uses FFI primitives).	- improved the internal system-read-strategy.1.0gamma5	- Servers and clients can now survive image restarts.	- added a new session preference (see MagmaPreferences), "signalProxyMaterialization" so you can capture MagmaNotifications and fine-tune your read strategies.	- Another performance improvement!!  ReadStrategies are now cached on the server, instead of in your MagmaSession, improving read-efficiency when using read strategies because the strategy-object no longer needs to be serialized and transported for every proxy materialization.  Additionally, ReadStrategies for classes that don''t exist in the repository are no longer dropped.  Instead, they are remembered until you put those classes into the repository.	- commit conflicts no longer provide the entire MagmaClientConnection object who conflicted with your session, just the userId.  This is due to the aforementioned cached readStrategy, no need to be sending that down on a commit conflict.	- Since we have eradicated the "root trap" we can make replacing the root consistent with other Magma changes.  A transaction is now required.	- several bug fixes.'! !!MagmaServerPackageInfo methodsFor: 'accessing' stamp: 'cmm 4/8/2004 21:30'!prerequisitePackages	^ #( 'Magma client' 'Ma time objects' )! !!MagmaServerPackageInfo methodsFor: 'as yet unclassified' stamp: 'cmm 2/4/2003 18:12'!readmeText	^'This package is used to host a Magma repository.  For more information visit http://minnow.cc.gatech.edu/squeak/2665.'! !!SystemNavigation class methodsFor: '*ma base additions' stamp: 'cmm 3/3/2004 22:57'!maDefault: aSystemNavigation	Default _ aSystemNavigation! !!SystemNavigation methodsFor: '*ma base additions' stamp: 'cmm 1/2/2005 23:31'!maAllMethodReferencesDo: aBlock	"Value aBlock for every method in the system."	Cursor execute showWhile:		[ self			allBehaviorsDo:				[ : class |				class selectorsDo:					[ : sel | 					aBlock value: (MethodReference class: class selector: sel) ] ] ]! !!ChangeSet class methodsFor: '*ma object serialization' stamp: 'cmm 8/22/2005 09:35'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"Materialize the association:  change set name -> the stream on which the change set was filed out.	Signal the incoming chang-set notification and, if the user has written code to override the defaultAction, it will be filed in the name isn't already in use."	| nameAndChangeSetAssociation changeSetName stream |	nameAndChangeSetAssociation := (aMaObjectSerializer materializeGraph: aByteArray).	changeSetName := nameAndChangeSetAssociation key.	stream := nameAndChangeSetAssociation value.	^ (MaIncomingChangeSetNotification signal: 'Is it ok to file-in ', changeSetName) == true "default to false if they return with a non-boolean."		ifTrue:			[ ChangeSorter				newChangesFromStream: stream				named: changeSetName ]		ifFalse: [ ChangeSorter existingOrNewChangeSetNamed: changeSetName ]! !!ChangeSet methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:33'!isImmutableInMagma	^ true! !!ChangeSet methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 21:43'!maAsStorageObject	"While we can store ChangeSets and their CompiledMethods directly, a logical representation (i.e., my fileOut) is probably better.  Therefore, we file out me to a stream and keep that along with my name.  My code will NOT be automatically filed-in on materialization."	| stream |	stream _ ReadWriteStream on: String new.	self fileOutOn: stream.	stream position: 0.	^ self name -> stream! !!ChangeSet methodsFor: '*ma object serialization' stamp: 'cmm 2/3/2005 17:29'!maUsesStandardStorage	^ false! !!DirectoryEntry methodsFor: '*ma time objects' stamp: 'cmm 3/11/2003 23:39'!maCreationTime	^MaCalendarTime fromSeconds: creationTime! !!DirectoryEntry methodsFor: '*ma time objects' stamp: 'cmm 3/11/2003 23:41'!maModificationTime	^MaCalendarTime fromSeconds: modificationTime! !!SharedQueue methodsFor: '*ma base additions' stamp: 'cmm 2/8/2005 23:34'!notEmpty	^ self isEmpty not! !!Bag methodsFor: '*ma base additions' stamp: 'cmm 12/19/2002 21:33'!maIncludesAll: aCollection	"Return true if the receiver includes all elements in aCollection.	If aCollection contains duplicate elements, the receiver must have	one for each of them."	| otherColl |	aCollection size > self size ifTrue: [ ^false ].	otherColl :=		aCollection size > 20			ifTrue: [ aCollection asBag ]			ifFalse: [ aCollection ].	otherColl do:		[ :each | (self occurrencesOf: each) < (otherColl occurrencesOf: each) ifTrue: [ ^false ] ].	^true! !!Bag methodsFor: '*ma base additions' stamp: 'cmm 10/23/2002 20:20'!maRemoveAll	"Efficiently removes all elements in the receiver."	self setContents: (self class contentsClass new: contents size)! !!Bag methodsFor: '*ma base additions' stamp: 'cmm 3/28/2005 21:57'!printOn: aStream	aStream		nextPutAll: (self class name first isVowel ifTrue: [ 'an ' ] "$NON-NLS$" ifFalse: [ 'a ' ]). "$NON-NLS$"	self species printOn: aStream.	contents keysAndValuesDo:		[ :eachKey :eachValue |		aStream			cr; tab;			nextPut: $(;			maPrint: eachValue;			nextPutAll: ') ';			maPrint: eachKey ]! !!False methodsFor: '*ma object serialization'!maOid	^MaOidCalculator oidForFalse! !!ContextPart class methodsFor: '*writebarrier' stamp: 'avi 10/7/2004 13:30'!canUncompact	^ false! !!ContextPart methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:35'!isImmutableInMagma	^ true! !!ContextPart methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !!Project methodsFor: '*ma object serialization' stamp: 'cmm 2/22/2005 12:49'!maTransientVariables	"Don't store or traverse these variables when serializing me."	^ super maTransientVariables, #('parentProject' 'nextProject' 'previousProject')! !!Project methodsFor: '*ma object serialization' stamp: 'cmm 11/26/2004 15:15'!maWantsPostMaterialization 	^ true! !!Project methodsFor: '*ma object serialization' stamp: 'cmm 2/11/2005 09:53'!maWantsPreSerialization	^ true! !!True methodsFor: '*ma object serialization'!maOid	^MaOidCalculator oidForTrue! !!SmallInteger class methodsFor: '*ma object serialization' stamp: 'cmm 6/11/2004 13:57'!maInstancesRequireOwnBuffer	^ false! !!SmallInteger class methodsFor: '*ma object serialization' stamp: 'cmm 6/2/2004 16:54'!maMaterializeFrom: aMaByteObjectBuffer using: aMaObjectSerializer	^MaOidCalculator		objectWithOid: aMaByteObjectBuffer oid		ifNone: [ self error: aMaByteObjectBuffer , ' is not a buffer for a SmallInteger.' ]! !!EToyProjectHistoryMorph class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:17'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	"It seems these ProjectHistoryMorphs are simply image-specific things, i.e., the history of whatever projects in the current image."	^ self new! !!EToyProjectHistoryMorph methodsFor: '*ma object serialization' stamp: 'cmm 2/17/2005 13:55'!maAsStorageObject 	^ String maEmpty! !!EToyProjectHistoryMorph methodsFor: '*ma object serialization' stamp: 'cmm 2/17/2005 13:55'!maUsesStandardStorage	^ false! !!WeakSet methodsFor: '*ma object serialization' stamp: 'cmm 12/1/2004 22:55'!maBufferInstSize	^ self slowSize! !!WeakSet methodsFor: '*ma object serialization' stamp: 'cmm 3/7/2005 14:43'!maStreamVariablyInto: aMaVariableObjectBuffer for: aMaObjectSerializer	"If a GC has happened since we set aMaVariableObjectBuffer's logicalSize then, upon materialization, it may try to load with 'garbage' oids because we load up to the number of logicalSize instVars (and the buffer would have garbage at those places).  Therefore, reset the logicalSize after populating."	super		maStreamVariablyInto: aMaVariableObjectBuffer		for: aMaObjectSerializer.	aMaVariableObjectBuffer physicalSize: (aMaVariableObjectBuffer physicalSizeFor: self)! !!SequenceableCollection methodsFor: '*ma base additions' stamp: 'cmm 12/30/2003 23:43'!maAfter: anObject ifError: aBlock	"A more-flexible substitute for after:ifAbsent: which, if anObject is the last object in me, errors out instead of calling the ifAbsent block.  This version does, making your code cleaner."	self last == anObject ifTrue: [ ^ aBlock value ].	^self		after: anObject		ifAbsent: aBlock! !!SequenceableCollection methodsFor: '*ma base additions' stamp: 'cmm 12/30/2003 23:44'!maBefore: anObject ifError: aBlock	"A more-flexible substitute for before:ifAbsent: which, if anObject is the last object in me, errors out instead of calling the ifAbsent block.  This version does, making your code cleaner."	self first == anObject ifTrue: [ ^ aBlock value ].	^self		before: anObject		ifAbsent: aBlock! !!SequenceableCollection methodsFor: '*ma base additions' stamp: 'cmm 5/18/2004 12:01'!maMatchesElementsOf: anotherCollection	"Answer whether the receiver points to equivalent objects as	anotherCollection and in the same order."	self == anotherCollection ifTrue: [ ^ true ].	self size = anotherCollection size ifFalse: [ ^false ].	self		with: anotherCollection		do: [ :eachInSelf :eachInOther | eachInSelf = eachInOther ifFalse: [ ^false ] ].	^true! !!SequenceableCollection methodsFor: '*ma base additions' stamp: 'brp 4/7/2005 09:14'!maMerge: aCollection sortBlock: sortBlock collectBlock: collectBlock	"Merge the receiver with aCollection"	| answer first last a b swap |	self isEmpty ifTrue: [^aCollection asOrderedCollection].	aCollection isEmpty ifTrue: [^self asOrderedCollection].	answer := OrderedCollection new: self size + aCollection size.	first := self readStream.	last := aCollection readStream.	a := first next.	b := last next.	[true] whileTrue: [		[(sortBlock value: a value: b) or: [(sortBlock value: b value: a) not]]			whileTrue: [				answer addLast: (collectBlock value: a).				first atEnd ifTrue: [					answer addLast: (collectBlock value: b).					last upToEnd do: [ :l | answer addLast: (collectBlock value: l)].					^ answer ].				a := first next ].		swap := first.		first := last.		last := swap.		swap := a.		a := b.		b := swap ]! !!ReadWriteStream methodsFor: '*magma client' stamp: 'cmm 5/3/2005 14:01'!maAllowsWriteBarrier	"Sigh..  We cannot allow this because I override #= and use my #class as part of that determination.  Therefore, a ReadWriteStream behind a WriteBarrier will report false against an equivalent not behind a WriteBarrier.  I wonder whether objects behind WriteBarriers can answer their original class and then require it to override and use #basicClass or something like that to get its WriteBarrier subclass."	^ false! !!ReadWriteStream methodsFor: '*magma server' stamp: 'cmm 5/31/2005 17:53'!maRead: someNumber bytesFromPosition: bufferPosition of: aByteArray atFilePosition: filePosition	^ self		position: filePosition ;		readInto: aByteArray		startingAt: bufferPosition		count: someNumber! !!ReadWriteStream methodsFor: '*magma server' stamp: 'cmm 5/7/2005 22:55'!maWrite: numberOfBytes bytesFromPosition: bufferPosition of: byteArray atFilePosition: filePosition	self position: filePosition.	self		next: numberOfBytes		putAll: byteArray		startingAt: bufferPosition! !!ReadWriteStream methodsFor: '*magma server' stamp: 'cmm 6/15/2005 15:15'!readInto: aByteArray startingAt: startIndex count: numberOfBytes	"Read n objects into the given collection.  Return the number of bytes read."	| count |	count _ 0.	[ count < numberOfBytes ]		whileTrue:			[ | byte |			byte _ self next.			byte				ifNil: [ ^ count ]				ifNotNil:					[ aByteArray						at: startIndex+count						put: byte ].			count _ count + 1 ].	^ count! !!PasteUpMorph class methodsFor: '*ma object serialization' stamp: 'cmm 11/23/2004 12:52'!maMaterializeFrom: aMaByteObjectBuffer using: aMaObjectSerializer	^ World! !!PasteUpMorph methodsFor: '*ma object serialization' stamp: 'cmm 2/22/2005 12:49'!maTransientVariables	^ super maTransientVariables, #('worldState')! !!PasteUpMorph methodsFor: '*ma object serialization' stamp: 'cmm 2/11/2005 12:51'!maWantsPreSerialization 	^ true! !!OrderedCollection methodsFor: '*ma base additions' stamp: 'cm 1/7/2002 16:25'!maAddAll: aSequenceableCollection afterIndex: integerIndex	aSequenceableCollection reverseDo: [:each | self add: each afterIndex: integerIndex ].	^aSequenceableCollection! !!OrderedCollection methodsFor: '*ma base additions' stamp: 'cmm 10/23/2002 20:33'!maRemoveAll	self setCollection: (Array new: self size)! !!MethodContext class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:15'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ (aMaObjectSerializer materializeGraph: aByteArray) asMethodContext! !!MethodContext methodsFor: '*ma object serialization' stamp: 'cmm 11/10/2004 12:02'!maAsStorageObject	^ MaMethodContextStorage newFor: self! !!Delay class methodsFor: '*ma time objects' stamp: 'cmm 12/19/2002 23:38'!for: aMaCalendarTime	"Example:		(Delay for: 10 seconds) wait"	^self forMilliseconds: aMaCalendarTime totalMilliseconds! !!Delay methodsFor: '*ma base additions' stamp: 'cmm 9/1/2004 22:25'!maReset	"If I am already waiting, start my wait back at the beginning.  If I'm not yet waiting, no effect."	resumptionTime _ Time millisecondClockValue + delayDuration! !!Exception methodsFor: '*ma exception handling' stamp: 'cmm 8/11/2002 23:35'!maIsException	^true! !!Exception methodsFor: '*ma object serialization' stamp: 'cmm 6/10/2005 11:24'!maTransientVariables 	^ super maTransientVariables, #( 'signalContext' 'handlerContext' 'outerContext' )! !!PseudoContext class methodsFor: '*writebarrier' stamp: 'avi 10/7/2004 13:30'!canUncompact	^ false! !!TranscriptStream class methodsFor: '*ma object serialization' stamp: 'cmm 5/2/2005 10:16'!maMaterializeFromGraph: aByteArray using: aMaObjectSerializer	^ Transcript! !!TranscriptStream methodsFor: '*magma client' stamp: 'cmm 4/8/2005 12:37'!isImmutableInMagma	^ true! !!TranscriptStream methodsFor: '*ma object serialization' stamp: 'cmm 12/19/2002 23:13'!maAsStorageObject	"We don't even need to store the name of this global.  It's class	gives it away."	^String maEmpty! !!TranscriptStream methodsFor: '*ma object serialization' stamp: 'cmm 11/29/2004 11:01'!maUsesStandardStorage	^ false! !"Ma exception handling"!"Ma base additions"!"Ma proxy support"!"Ma traverse object graphs"!"Ma object serialization"!"Ma time objects"!"WriteBarrier"!"Magma client"!"Magma server"!"Ma client server"!"Ma special collections"!"Collections-BTree"!!MagmaCompressor commentStamp: 'cmm 8/29/2002 22:35' prior: 35359087!I garbage collect a Magma repository and output a smaller file by eliminating buffers no longer referenced from the root buffer.I always create a new object file, but if you use compressAndRename, I'll rename the source files to 'old...' so you can get with using the compressed repository right away.If you don't want me to rename, just use #compressTo:.Oh, and I'm not meant to work while the files are on-line.  For that, use:	yourRepositoryController garbageCollect(Note:  a potential strategy for on-line GC would be to set a boolean flag indicating to the filer not to reuse buffers made available through grown objects, but rather to always add to the end.  During this time, a background thread can start reading from the root and build a new copy of the 'memory' map (the MaIntervalCollection).  Once it has accounted for every byte in the real memory map, we know the real one can be replaced with this new one.  Do a quick write of the new memory map and you're done!!)!!MagmaCompressor class methodsFor: 'creation' stamp: 'kph 10/5/2006 06:35' prior: 35360461!source: location	^self new sourceLocation: location! !!MagmaCompressor methodsFor: 'private' stamp: 'kph 10/5/2006 06:36' prior: 35363670!createOutput: location	MagmaRepositoryController create: location! !!MagmaCompressor methodsFor: 'private' stamp: 'kph 10/5/2006 06:37' prior: 35366974!openInput	inputController _ MagmaRepositoryController open: sourceLocation ! !!MagmaCompressor methodsFor: 'private' stamp: 'kph 10/5/2006 06:35' prior: 35367133!openOutput: location	outputController _ MagmaRepositoryController open: location! !!MagmaCompressor methodsFor: 'private' stamp: 'kph 10/5/2006 06:37' prior: 35367286!removeUnreferencedCollectionsAndClasses: location	| controller |	controller _ outputController privateOpen: location.	controller session commit:		[ controller definition classDefinitions copy			keysDo: 				[ :eachId |				(referencedClasses includes: eachId) ifFalse:					[ controller definition removeClassWithId: eachId ] ].		controller definition allLargeCollections copy do:			[ :eachCollection |			(referencedCollections includes: (controller session oidFor: eachCollection)) ifFalse:				[ controller definition removeCollection: eachCollection ] ] ].	controller close! !!MagmaCompressor methodsFor: 'initialize-release' stamp: 'kph 10/5/2006 06:36'!sourceLocation: location	sourceLocation _ location! !!MagmaFileTraverser methodsFor: 'private' stamp: 'kph 10/5/2006 06:31' prior: 35376666!open	"Use if you created with just a path, or if you know the MagmaRepositoryController needs opened.."	repositoryController _ MagmaRepositoryController open: (MagmaLocalLocation path: directory pathName)! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'kph 10/4/2006 14:40' prior: 35437622!controllerOpenedOn: location	^ OpenControllers		maDetect: [ : each | each directory pathName = location pathName ]		ifFound: [ : foundController | foundController ensureOpen ]		ifNone: [ nil ]! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'kph 10/4/2006 20:31' prior: 35437900!create: locationOrPath	"Creates a repository with an initial root of nil.  I #assureExistence of the location."	| aLocation |	aLocation := MagmaLocalLocation path: locationOrPath. 		self validateCanCreateIn: aLocation.	self new createRepositoryAt: aLocation! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'kph 10/4/2006 13:44' prior: 35438324!create: location root: anObject	| session |	self create: location.	session _ MagmaSession openLocal: location.	session		connect: (MagmaUser id: 'system create:root:') ;		commit: [ session root: anObject ] ;		disconnect ;		closeRepository! !!MagmaRepositoryController class methodsFor: 'utilities' stamp: 'kph 10/5/2006 21:45' prior: 35438728!delete: location	"Delete the just the files in fullyQualifiedPathString that are part of the Magma repository that resides there." 	(location isRepository) ifFalse:		[ (MagmaNotification new messageText: location pathName , ' does not exist, nothing to delete.') signal.		^ self ].	(self filesFor: location), { (MaRecoveryManager commitPackagesFilename) } do:		[ : each |			location directory deleteFileNamed: each asString			ifAbsent: [ MagmaNotification signal: 'Couldn''t find ' , each asString ] ]! !!MagmaRepositoryController class methodsFor: 'private' stamp: 'kph 10/4/2006 13:19' prior: 35441417!open: location	^ self new open: location! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'kph 8/24/2006 22:21'!openControllers^OpenControllers! !!MagmaRepositoryController class methodsFor: 'accessing' stamp: 'kph 10/4/2006 13:16' prior: 35441603!openedOn: location	| existingController  |	^ (existingController := self controllerOpenedOn:  location)		ifNil: [ self open: location ]		ifNotNil: [ existingController ].! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'kph 10/4/2006 14:15' prior: 35443273!updateVersionIn: location from: currentVersion 	"Force update the filers version from currentVersion.  currentVersion is required to help catch mistakes, since the version is very important for operation."	| filer |	filer _ MaObjectFiler open: location directory.	[" filer version = currentVersion ifFalse: 		[ MagmaUserError signal: 'This repository is not already version ' , currentVersion asString ]."	filer version: currentVersion + 1 ] ensure: [ filer close ]! !!MagmaRepositoryController class methodsFor: 'advanced' stamp: 'kph 10/5/2006 06:15' prior: 35443836!upgrade5To6: location 	"Upgrade legacy repository's from #magmaVersion 5 to 6.  It is always good advice to back up before running any conversion utility."	| aLocation |	aLocation := MagmaLocalLocation path: location. 	self 		updateVersionIn: aLocation from: 5 ;		generateKeysIndices: aLocation directory! !!MagmaRepositoryController class methodsFor: 'validation' stamp: 'kph 10/5/2006 21:46' prior: 35444227!validateCanCreateIn: location	"Magma databases do not share the same directory.  Not only would it be hard to identify which files go with which repository, some of the filenames are based on oids, which would not always be unique across repositories."	(location isRepository)		ifTrue:			[ MagmaUserError signal: location pathName, ' already has a Magma repository in it.  A directory may contain only one Magma repository.' ]! !!MagmaRepositoryController methodsFor: 'private' stamp: 'kph 10/4/2006 13:46' prior: 35446931!createRepositoryAt: location	| anchor |	directory _ location directory.	self		repository: (			MaObjectRepository				create: directory				controller: self);		connect;		forceWrite:			(anchor _ MaRootAnchor new				definition: self definition ;				yourself).	repository filer		anchorOid: (self session oidFor: anchor);		classDefinitionsOid: (self session oidFor: self definition classDefinitions);		definitionOid: (self session oidFor: self definition).	self close! !!MagmaRepositoryController methodsFor: 'private' stamp: 'kph 10/4/2006 13:21' prior: 35453618!open: location	directory _ location directory.	self open.	OpenControllers add: self. "<- we only do this for intentional opens, not image restarts"! !!MagmaSession class methodsFor: '*magma server' stamp: 'kph 10/4/2006 13:15' prior: 35496883!openLocal: location	^ self repositoryController: (MagmaRepositoryController openedOn: location)! !!MagmaSession methodsFor: '*magma server' stamp: 'kph 10/5/2006 07:22' prior: 35509335!ensureOpen	self isLocal ifFalse: [ MagmaUserError signal: 'Only available for local connections.' ].	self isOpen ifFalse:		[ self link: (self class newLocalLinkFor: (MagmaRepositoryController openedOn: (MagmaLocalLocation path: self pathName)) )]! !!MagmaServerConsole methodsFor: 'start / stop' stamp: 'kph 10/4/2006 13:36' prior: 35224843!open: pathNameOrLocation	controller _ MagmaRepositoryController open: (MagmaLocalLocation path: pathNameOrLocation)! !MagmaRepositoryController class removeSelector: #repositoryExistsIn:!MagmaCompressor removeSelector: #sourceDirectory:!"Magma server"!!MCLocalMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'kph 10/4/2006 13:39' prior: 34816201!creationTemplate	^ self name, ' path: ''< path'''! !!MagmaMutatingProxy methodsFor: 'printing' stamp: 'kph 9/22/2006 02:00'!asExplorerString	^ self printString! !!MagmaMutatingProxy methodsFor: 'testing' stamp: 'kph 9/26/2006 21:48'!isLiteral"hack to allow pointerfinder to work"^true! !!MagmaMutatingProxy methodsFor: 'printing' stamp: 'kph 9/22/2006 02:10' prior: 34841239!printOn: aStream	MagmaPreferences debugProxies  		ifTrue:			[ super printOn: aStream.					aStream nextPutAll: ('(',oid asString, '/',session id asString,')') ]		ifFalse:			[ self mutant printOn: aStream ]! !!MagmaLocalLocation class methodsFor: 'create' stamp: 'kph 10/4/2006 13:35' prior: 35425012!default	"This method is for Seaside."	self maMarked: 'otherPackageSupport'.	^ self path: 'magma'! !!MagmaLocalLocation class methodsFor: 'create' stamp: 'kph 10/4/2006 21:04' prior: 35425229!path: aStringOrLocation(aStringOrLocation isKindOf: self) ifTrue: [ ^ aStringOrLocation ].	^ self new		path: aStringOrLocation ; 		yourself! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 20:25'!base	^FileDirectory default  ! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 20:25'!directory	^ directory ifNil: [ directory :=  FileDirectory on: (self base fullNameFor: path) ]! !!MagmaLocalLocation methodsFor: 'testing' stamp: 'kph 10/5/2006 21:43'!isRepository^self directory exists and: [ self directory fileExists: MaObjectFiler objectsFilename ] ! !!MagmaLocalLocation methodsFor: 'actions' stamp: 'kph 10/4/2006 14:46' prior: 35426023!newSession  ^self sessionClass openLocal: self	 ! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 21:03' prior: 35426739!path: aString	path _ aString! !!MagmaLocalLocation methodsFor: 'accessing' stamp: 'kph 10/4/2006 14:39'!pathName^ self directory pathName! !MagmaLocalLocation removeSelector: #fullPath!"Magma client"!!WAMagmaReadStrategyDefault commentStamp: 'kph 9/19/2006 17:53' prior: 0!This class is a subclass of MaReadStrategy enabling specialisation of read strategy behaviour.Class methods build and set a specific read strategy for a magmaSession.The default building behaviour is for the root object of the repository to be read and be asked to contribute to the ReadStrategy which is an instance of this class. In this way applications that have their own bespoke root class can control the read strategy by implementing #buildStrategyOn:Alternative admin-user selectable (via seaside/config) read strategies may be supplied by providing subclasses to this class. These may override the default building behaviour if desired. They may also over-ride MaReadStrategy behaivour.In seaside the Session readStrategy is updated/rebuilt whenever there is a new seaside session, even when the MagmaSession and the repository is shared among sever seaside sessions.!!WAMagmaReadStrategyDefault class methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 03:20'!askRoot: root toBuildReadStrategyOn: theStrategy	(root respondsTo: #buildReadStrategyOn:) 		ifTrue: [ root buildReadStrategyOn: theStrategy ].! !!WAMagmaReadStrategyDefault class methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 05:56'!isLogger^false! !!WAMagmaReadStrategyDefault class methodsFor: 'as yet unclassified' stamp: 'kph 9/19/2006 17:47'!setStrategyFor: session| theStrategy |theStrategy := self new.self thisStrategyOn: theStrategy.self askRoot: session root toBuildReadStrategyOn: theStrategy.session readStrategy: theStrategy.^session! !!WAMagmaReadStrategyDefault class methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 02:16'!thisStrategyOn: strategy"subclasses may specialise this method"! !!WAMagmaReadStrategyDefault methodsFor: 'as yet unclassified' stamp: 'kph 10/4/2006 15:16'!depthArrayOfSize: arraySize default: value	^(Array new: arraySize) atAllPut: value; yourself! !!WAMagmaReadStrategyDefault methodsFor: 'nil' stamp: 'kph 9/19/2006 17:56'!forVariableNamed: aString onAny: aClass readToDepth: anInteger| specs |	(aClass allInstVarNames includes: aString)		ifFalse:			[ MagmaUserError signal: aString , ' is not an attribute of ' , aClass name ].	specs := depthSpecifications at: aClass ifAbsent: [ self onAny: aClass readToDepth: 0 ].specs value ifNil: [ specs value: (self depthDictionaryOfSize: aClass instSize) ].			specs value at: aString			put: anInteger! !!WAMagmaReadStrategyDefault methodsFor: 'as yet unclassified' stamp: 'kph 9/19/2006 17:56'!instVarMapFor: aMaClassDefinition	"Answer an Array with an instVarMap of aMaClassDefinition according to user-declared read depths."	| specifiedDepths answer |	(aMaClassDefinition isDefined	and: [ depthSpecifications includesKey: aMaClassDefinition classObject ])		ifTrue:			[ specifiedDepths _ depthSpecifications at: aMaClassDefinition classObject.			specifiedDepths value				ifNil: [ answer _ specifiedDepths key ]				ifNotNil:					[ answer _ self depthArrayOfSize: aMaClassDefinition namedInstSize default: specifiedDepths key.					specifiedDepths value keysAndValuesDo:						[ : eachInstVarName : eachDepth |						answer							at: (aMaClassDefinition allInstVarNames indexOf: eachInstVarName)							put: eachDepth ] ] ].	^ answer! !!WAMagmaReadStrategyDefault methodsFor: 'nil' stamp: 'kph 9/20/2006 15:24'!isLogged^self class isLogger! !!WAMagmaReadStrategyDefault methodsFor: 'as yet unclassified' stamp: 'kph 9/19/2006 17:56'!onAny: aClass readToDepth: anInteger	^depthSpecifications at: aClass ifAbsentPut: [ Association key: anInteger value: nil ].! !!WAMagmaReadStrategyDefault methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 23:01'!renderOn: htmlhtml text: ' minimumDepth: '; text: self minimumDepth; break.depthSpecifications keysAndValuesDo: [ :k :v |  html bold: k; text: ' : '; text: v; break ].! !!WAMagmaReadStrategyWithLogging class methodsFor: 'nil' stamp: 'kph 9/20/2006 05:56'!isLogger^true! !!WAMagmaReadStrategyWithLogging methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 14:46'!log^self logClass log! !!WAMagmaReadStrategyWithLogging methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 14:41'!logClass^WAMagmaLog ! !!WAMagmaReadStrategyWithLogging methodsFor: 'as yet unclassified' stamp: 'kph 9/22/2006 05:28'!signalBeginningToRead: oidInteger	|timeStamp |						timeStamp := Time millisecondClockValue.	self log entry: #readBegin context: thisContext! !!WAMagmaReadStrategyWithLogging methodsFor: 'as yet unclassified' stamp: 'kph 9/22/2006 05:24'!testRead: oid     wantedAt: currentDepth		   to: minDepth forAttribute: varIndexofClassWithId: classId	  version: classVersion"we log (lazily) by sending this method's context to the log, changing this method's args and  temporary variables may effect the Log's output"| newMinDepth timeStamp |							timeStamp := Time millisecondClockValue.newMinDepth :=  super testRead: oid wantedAt: currentDepth						to: minDepth						forAttribute: varIndex						ofClassWithId: classId						version: classVersion.self log entry: #testRead context: thisContext. 	^newMinDepth! !!MaObjectBuffer methodsFor: '*magma seaside' stamp: 'kph 9/20/2006 13:39' prior: 35039196!appendGraphUsing: aMaReadStrategy into: aMaSerializedGraphBuffer currentDepth: currentDepth minDepth: minDepth with: alreadyAppendedSet filer: aMaObjectFiler	1		to: self objectInstSize		do:			[ :varIndex | | oid |			(MaOidCalculator isOidForOptimizedObject: (oid _ self maInstVarAt: varIndex))				ifFalse:					[ | newMinDepth | 				(newMinDepth := aMaReadStrategy 						testRead: oid						wantedAt: currentDepth						to: minDepth						forAttribute: varIndex						ofClassWithId: self classId						version: self classVersion) ~= false ifTrue: [													self								appendGraphNode: oid								into: aMaSerializedGraphBuffer								using: aMaReadStrategy								currentDepth: currentDepth								minDepth: newMinDepth								with: alreadyAppendedSet								filer: aMaObjectFiler 							].					  ]		]! !!WAMagmaLocationAttribute methodsFor: 'as yet unclassified' stamp: 'brp 11/4/2005 10:00'!accept: aVisitor with: anObject	^ aVisitor visitMagmaLocationAttribute: self with: anObject! !!WAMagmaLocationAttribute methodsFor: 'as yet unclassified' stamp: 'brp 11/4/2005 12:13'!options	^ MagmaLocation subclasses! !!WAMagmaControlPanel commentStamp: 'kph 9/27/2006 03:47' prior: 0!Architecture:This control panel is made available as a plug-in to seaside/config application. The link 'magma' appears next to applications that have the preference #readStrategy. Since the seaside/config application session is not, nor should it be a MagmaSession, this control panel has to manage its own magmaSession. It does this by creating a psuedo seaside application, local to the control panel which has a magmaSession. It also registers for finalization in order to safely dispose of any the psuedo application and to disconnect the magmaSession.This control panel anticipates that each application using magma to have its own repository control/status panel class. The repository control/status panel is obtained and displayed as a sub-part of the MagmaControlPanel by sending the root object of the current repository #magmaControlPanelOn:  e.g.magmaSession root magmaControlPanelOn: magmaSession.If there is not a repository in place then the user is offered the option to create one. It searches for the repository control panels.  These are seaside-components which implement #magmaRootClass and #magmaRootDescription, sufficient information for the user to select a root object that is appropriate for their application.[to do]seasidehosting currently requires the user to manually create the repository directory in the filesystem.!!WAMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 9/30/2006 02:33'!editorActionsFor: anEntryPoint inEditor: anEditor| actions |actions := super editorActionsFor: anEntryPoint inEditor: anEditor. actions isEmpty ifTrue: [ ^ actions ].(anEntryPoint preferenceAt: #readStrategy) isLogger  ifTrue: [ 				actions add: ((Dictionary new)				at: #label put: 'view-log';				at: #action put: [ anEditor call: (WAMagmaLog log forApplication: anEntryPoint)  ];				yourself);				yourself.		actions add: ((Dictionary new)				at: #label put: 'clear-log';				at: #action put: [ anEditor call: (WAMagmaLog log forApplication: anEntryPoint) clear  ];				yourself);				yourself.].	^ actions! !!WAMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 10/7/2006 12:18'!initialize"self initialize"^super initialize! !!WAMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 9/30/2006 02:32'!label^ #magma! !!WAMagmaControlPanel methodsFor: 'all stats' stamp: 'kph 9/18/2006 04:18'!cachedObjectsByClassForSession: aSession^String streamContents: [ :stream |	stream nextPutAll: 'cachedObjectCountByClass: '.	aSession cachedObjectCountByClass 		do: [ :assoc |			stream nextPutAll: assoc printString.			stream nextPutAll: ' '; cr.		]]! !!WAMagmaControlPanel methodsFor: 'seaside framework' stamp: 'kph 8/14/2006 23:21'!children^ Array with: repositoryControlPanel! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 10/6/2006 12:00'!createRepository: repositoryClass	self psuedoAppSession unregistered.	psuedoAppSession := nil.	repositoryControlPanel := nil. MagmaRepositoryController create: self location root: repositoryClass new.! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 10/6/2006 11:41'!deleteRepository| message1 message2 |message1 := 'Are you sure that you want to delete repository: ', self location path.message2 := 'Go ahead and delete repository: ',  self location path.((self confirm: message1) and: [ self confirm: message2 ]) 	ifTrue: [ 		self psuedoAppSession expire.		psuedoAppSession := nil.		repositoryControlPanel := nil.		(MagmaRepositoryController controllerOpenedOn: self location) ifNotNilDo: [ :mc |  mc close ].		MagmaRepositoryController delete: self location.				].! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 9/4/2006 03:15'!doIt: aStringdoneIt := ( Compiler new evaluate: aString in: nil to: nil ) printString.! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 9/18/2006 02:58'!doneself psuedoAppSession expire.self answer! !!WAMagmaControlPanel methodsFor: 'finalization' stamp: 'kph 9/26/2006 22:11'!executor^ self class basicNew setExecutorsPsuedoAppSession: psuedoAppSession; yourself! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 9/18/2006 04:24'!explore: aMagmaSession  [ { aMagmaSession. aMagmaSession root } explore ] fork! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/23/2006 07:02'!explore: sessionId inController: mrc	self explore:(self findMagmaSessionWithId: sessionId inController: mrc)! !!WAMagmaControlPanel methodsFor: 'finalization' stamp: 'kph 9/26/2006 22:15'!finalizepsuedoAppSession ifNotNil: [	psuedoAppSession unregistered.]! !!WAMagmaControlPanel methodsFor: 'all stats' stamp: 'kph 9/20/2006 15:05'!findMagmaSessionWithId: id inController: mrc^MagmaSession allInstances detect: [ :ms | (ms id = id) and: [ ms link localRequestServer processor = mrc ] ] ifNone: [ nil ]! !!WAMagmaControlPanel methodsFor: 'testing' stamp: 'kph 9/5/2006 23:43'!hasScriptaculous	Smalltalk at: #SULibrary ifPresent: [ :class |		^ self session application libraries			includes: class ].	^ false! !!WAMagmaControlPanel methodsFor: 'initialization' stamp: 'kph 9/26/2006 22:05'!initializesuper initialize.self registerForFinalization.! !!WAMagmaControlPanel methodsFor: 'accessing' stamp: 'kph 9/18/2006 01:27'!location^ self application preferenceAt: #location! !!WAMagmaControlPanel methodsFor: 'accessing' stamp: 'kph 9/18/2006 02:59'!magmaSession^self psuedoAppSession magmaSession! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/18/2006 03:29'!magmaSession: aBlock ifAbsent: notThereBlockaBlock	on: MagmaEnvironmentError 	do: notThereBlock.  ! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 8/24/2006 02:38'!presentCreateRepositoryOptionsOn: html	html heading level: 3; with: [ html text:  'options:'].		html text: 'You may create a repository with one of the following root objects for this application.'.		html div class: 'repositories'; with: [ 			html table: [				((SystemNavigation default allImplementorsOf: #magmaRootClass) collect: [ :m | m actualClass soleInstance ])								do: [ :c | 						html tableRow: [ 					 			html tableData: [ html bold:  c magmaRootClass name ].								html tableData: [ html text:   c magmaRootDescription ].								html tableData: [ html submitButton callback: [ self createRepository: c magmaRootClass ]; text: 'Create'. ]						] 					]				]			].! !!WAMagmaControlPanel methodsFor: 'accessing' stamp: 'kph 9/18/2006 03:00'!psuedoAppSession^psuedoAppSession ifNil: [ 	psuedoAppSession := (application preferenceAt: #sessionClass) application: self application ]! !!WAMagmaControlPanel methodsFor: 'finalization' stamp: 'kph 9/26/2006 22:06'!registerForFinalizationself finalizationRegistry add: self executor: self executor.! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/20/2006 15:23'!renderApplicationStatusOn: html	self magmaSession. 	self renderLocationOn: html.	self location isLocal ifTrue: [  html text: '   '. 		html small: [ 			html anchor 				callback: [ self deleteRepository ]; 				title: 'delete the repository from disk';				text: '(delete)'. 		]	].	html break.	html bold: 'Persisted Objects Count: '.	html text: self magmaSession repositoryController objectCount.	html break.	html bold: 'Session Id: '.	html text: self magmaSession id.	html break.	html bold: 'Cached Object Count: '.	html text: self magmaSession cachedObjectCount.	html break.	html bold: 'ReadStrategy: '.	html text: self magmaSession readStrategy asString.	(self magmaSession readStrategy isLogged) ifTrue: [			html anchor callback: [ self call: (WAMagmaLog log forApplication: application)  ]; text: '(log)'.		].	html break.	html bold: 'Root Object: '.	html text: self magmaSession root asString.		html text: ' '.	html small: [ 		html anchor callback: [ self explore: self magmaSession ]; 			title: 'open explorer in squeak';			text: '(explore)'.			.	].! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/22/2006 00:54'!renderContentOn: html	html heading: 'Application: ', application name.html form: [	self magmaSession: [ self renderApplicationStatusOn: html.			html horizontalRule.			html render: self repositoryControlPanel.			html horizontalRule. 		] 		ifAbsent: [ :ex | self renderMagmaError: ex on: html ].	html break.	html submitButton on: #done of: self.	html horizontalRule.	html heading: 'Overall Magma Status'.	 	self renderMagmaPreferencesOn: html.	self renderStatsForAllRepositoriesOn: html.		self renderUtilsOn: html.].! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/4/2006 02:01'!renderEvaluatorOn: html	self		renderLabel: 'Text-Input'		control: [ :fid :mid |			html textInput				value: textInput;				callback: [ :value | textInput := value ].			html space.			html submitButton				onClick: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render: textInput ];					return: false);				text: 'Submit' ]		model: textInput		on: html! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/4/2006 02:13'!renderLabel: aString control: aBlock model: anObject on: html	| fid mid |	fid := mid := nil.	html div class: 'row'; with: [		html div class: 'label'; with: aString.		html div class: 'control'; with: [			html form				id: (fid := html nextId);				with: [ aBlock value: fid value: (mid := html nextId) ] ].		html div class: 'model'; id: mid; with: anObject.		html div class: 'clear' ]! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/18/2006 01:50'!renderLocationOn: html	self location isLocal 		ifTrue: [			html bold: 'Repository path setting: '.			html text: self location path. 		]		ifFalse: [ 			html bold: 'Repository remote host: '.			html text: self location host , ':' , self location port		].		! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/18/2006 01:48'!renderMagmaError: ex on: html	self renderLocationOn: html.	html break.	html bold: 'Error: ', ex messageText.	html break.	self location isLocal 		ifTrue: [ self renderPresentCreateRepositoryOptionsOn: html	] 		ifFalse: [ html text: 'Remote repository not available' ].! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 10/4/2006 14:20'!renderMagmaPreferencesOn: htmlhtml bold: 'debug proxies '.html checkbox title: 'print shows proxy'; on: #debugProxies of: MagmaPreferences.html bold: 'hand status '.html checkbox title: 'show wait cursor when submitting magma requests'; on: #handStatus of: MagmaPreferences.html bold: 'debug '.html checkbox title: 'onError Halt, and 2 day server link timeout'; on: #debug of: MagmaPreferences.! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/2/2006 01:36'!renderPresentCreateRepositoryOptionsOn: html	html heading level: 3; with: [ html text:  'options:'].		html text: 'You may create a repository with one of the following root objects for this application.'.		html div class: 'repositories'; with: [ 			html table: [				((SystemNavigation default allImplementorsOf: #magmaRootClass) collect: [ :m | m actualClass soleInstance ])								do: [ :c | 						html tableRow: [ 					 			html tableData: [ html bold:  c magmaRootClass name ].								html tableData: [ html text:   c magmaRootDescription ].								html tableData: [ html submitButton callback: [ self createRepository: c magmaRootClass ]; text: 'Create'. ]						] 					]				]			].! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/4/2006 03:16'!renderServerDoItOn: html	self		renderLabel: 'Server Do It'		control: [ :fid :mid |			html textInput				value: textInput;				callback: [ :value | self doIt: (textInput := value).  ].			html space.			html submitButton				onClick: (html updater					id: mid;					triggerForm: fid;					callback: [ :r | r render:textInput ];					return: false);				text: 'do it' ]		model: doneIt 		on: html! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/23/2006 06:59'!renderStatsForAllRepositoriesOn: html| mSession sessionId |html orderedList: [ 	MagmaRepositoryController openControllers do: [ :mrc |				html listItem: [			html bold: mrc objectCount.			html text: ' objects in repository: '.			 			html bold: mrc directory pathName.			html orderedList: [				mrc repository sessions do: [ :client |										mSession := self findMagmaSessionWithId: client sessionId inController: mrc.					html listItem: [						mSession ifNil: [ html text: 'session not found' ]							ifNotNil: [ 								html bold: 'session id: '.								html text: client sessionId printString.								html bold: ' cached objects: '.								html anchor callback: [ self showCachedObjectsByClassFor: client sessionId inController: mrc ]; 								text: mSession cachedObjectCount.							html text: ' '.							html small: [ html anchor callback: [ self explore: client sessionId inController: mrc ]; text: '(explore)' ].						]					].				]	 			].							"html tableData: [ html text: c numberOfConnectedClients asString ]."		].	].]	    ! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 10/4/2006 14:21'!renderUtilsOn: htmlhtml horizontalRule.html bold: 'Miscellaneous Utilities: '.html break.html submitButton callback: [ MagmaSession cleanUp.							  repositoryControlPanel := nil ]; text: 'MagmaSession cleanUp'.html break.html submitButton callback: [ WAMagmaSharedSession initialize. ]; title: 'New Sessions (Reloads ReadStrategies)';  text: 'Reset WAMagmaSharedSession'.html break.html submitButton callback: [ self saveImageSnapshot. self magmaSession begin ]; text: 'Save Server Image'.self hasScriptaculous ifTrue: [ html horizontalRule.  self renderServerDoItOn: html ].! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 8/10/2006 16:38'!rendererClass        ^ WARenderCanvas ! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/18/2006 04:41'!repositoryControlPanel| root |repositoryControlPanel ifNil: [	root := self magmaSession root.	(root respondsTo: #magmaControlPanelOn: ) 		ifTrue: [ repositoryControlPanel := root magmaControlPanelOn: self magmaSession ]].^repositoryControlPanel! !!WAMagmaControlPanel methodsFor: 'callback actions' stamp: 'kph 9/4/2006 01:43'!saveImageSnapshot SmalltalkImage current snapshot: true andQuit: false.! !!WAMagmaControlPanel methodsFor: 'finalization' stamp: 'kph 9/26/2006 22:05'!setExecutorsPsuedoAppSession: psapsuedoAppSession := psa! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 9/23/2006 07:00'!showCachedObjectsByClassFor:  sessionId inController: mrc self inform: (self cachedObjectsByClassForSession: (self findMagmaSessionWithId: sessionId inController: mrc))! !!WAMagmaControlPanel methodsFor: 'rendering' stamp: 'kph 8/11/2006 14:16'!style^ 'div.repositories table td {	border: 1px solid #888;'! !!WAConfigurationEditor methodsFor: '*magma seaside' stamp: 'kph 9/18/2006 01:31'!renderMagmaLocationAttribute: anAttribute on: html	| location |	location := configuration valueForAttribute: anAttribute.	html div id: 'location'; with: [		html table: [			location isLocal				ifTrue: [					html tableRow: [  						html tableData id: 'label'; with: 'path:'.						html tableData: [ html textInput on: #path of: location ]					]				] ifFalse: [					html tableRow: [  						html tableData id: 'label'; with: 'host'.						html tableData: [ html textInput on: #host of: location ]					].					html tableRow: [  						html tableData id: 'label'; with: 'port'.						html tableData: [ html textInput value: location port;								callback: [:v | location port: v asNumber] ]					].				]		]	].! !!WAConfigurationEditor methodsFor: '*magma seaside' stamp: 'kph 6/15/2006 20:33'!visitMagmaLocationAttribute: anAttribute with: html	| location |	location := configuration valueForAttribute: anAttribute. 	html select 		list: anAttribute options;		selected: location class;		beSubmitOnChange;		labels: [ :ea | ea name ];		callback: [ :item | 	(configuration valueAt: #location) class == item			ifFalse: [ configuration takeValue: item default forAttribute: anAttribute. ] 		];		yourself.	self renderMagmaLocationAttribute: anAttribute on: html.! !!MaBasicReadStrategy methodsFor: '*magma seaside' stamp: 'kph 9/20/2006 23:39'!signalBeginningToRead: oidInteger! !!MaBasicReadStrategy methodsFor: '*magma seaside' stamp: 'kph 9/20/2006 13:41'!testRead: oid wantedAt: currentDepth			to: minDepth			forAttribute: varIndex			ofClassWithId: classId			version: classVersion| newMinDepth |	currentDepth < (						newMinDepth _							(self 								depthOfAttribute: varIndex								onClassWithId: classId								version: classVersion) + currentDepth									max: minDepth)	ifFalse: [ newMinDepth := false ].^newMinDepth! !!WAMagmaLog class methodsFor: 'nil' stamp: 'kph 9/20/2006 16:08'!logLog ifNil: [ Log := self new ].^Log! !!WAMagmaLog class methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 05:16'!resetLog := nil.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 00:41'!classIdManager^classIdManager! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 01:53'!clearentries := OrderedCollection new: maxEntries.readCount := 0.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 05:57'!entries^entries! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/24/2006 03:50'!entry: type context: aContext entries size < maxEntries ifTrue: [ | context |context := entries add: aContext copy.context setSender: nil 		receiver: (type, ':i:on:') asSymbol		method: context method 		arguments: #()]	 ! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 22:18'!forApplication: anEntryPoint	| session |	  	session := ((anEntryPoint preferenceAt: #sessionClass) application: anEntryPoint) obtainMagmaSession.	readStrategy := session readStrategy.	serializer := session serializer.	classIdManager := serializer classIdManager. ! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 23:49'!formatterClass^WAMagmaLogEntryFormatter! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 23:17'!initializemaxEntries := 200.self clear.readStrategy := nil.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 22:43'!keyString^ 'n: [ms] (current/min/newMin) class-attribute = value'! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 05:18'!maxEntries^maxEntries! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 05:18'!maxEntries: nmaxEntries := n! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 23:22'!printIndex: i entry: context on: html"context expected forentryForReading: oid at: currentDepth to: minDepth attribute: varIndex ofClassId: classId version: classVersion "| theClass theAttributeName theValue out |firstTime ifNil: [ firstTime := context tempAt: 8 ].context isString ifTrue: [  html text: (i asString, ': ', context). html break. ^self ].classIdManager ifNil: [ ^html bold: '<<no class id manager available>>' ].theClass := classIdManager classForId: (context tempAt: 5) ifAbsent: [ ^self error: 'could not find class id' ].theAttributeName := theClass allInstVarNames at: (context tempAt: 4) ifAbsent: [  (context tempAt: 4) asString ].theValue := serializer objectWithOid: (context tempAt: 1).out :=  (String streamContents: [ :stream | stream 	nextPutAll: i asString;		nextPutAll: ': [';		nextPutAll: ((context tempAt: 8) - firstTime) asString;		nextPutAll: '] (';		nextPutAll: (context tempAt: 2) asString;		nextPut: $/;		nextPutAll: (context tempAt: 3) asString.(context tempAt: 7) ~= false ifTrue: [stream		nextPut: $/;		nextPutAll: (context tempAt: 7) asString ].stream		nextPutAll: ') ';		nextPutAll: theClass name;		nextPut: $-;		nextPutAll: theAttributeName;		nextPutAll: ' = ';		nextPutAll: (theValue printStringLimitedTo: 40);		yourself.	]).(context tempAt: 7) = false ifTrue: [ html text: out ] ifFalse: [ html bold: out ].html break.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 06:14'!readBegin: context i: entryIndex on: html | theValue |firstTime ifNil: [ firstTime := context at: 2 ].readCount := readCount + 1.html horizontalRule.theValue := serializer objectWithOid: (context at: 1 ).html bold: entryIndex asString, (' [', ((context at: 2) - firstTime) asString, '] Read(', readCount asString, ') '); text: (theValue printStringLimitedTo: 70) ; break.(readCount = 1) ifTrue: [ firstTime := nil ]. ! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 22:37'!refresh! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 03:10'!renderContentOn: html|   |html form: [	html bold: 'Magma Log '.	html text: 'entries: '.	html textInput on: #maxEntries of: self.	html submitButton on: #clear of: self.	html submitButton on: #refresh of: self.	html text: ' show read strategy'.	html checkbox  on: #showReadStrategy of: self.	html horizontalRule.	self showReadStrategy ifTrue: [ self renderReadStrategyOn: html. 					html horizontalRule. 				].].html text: self keyString; horizontalRule.firstTime := nil. self entries withIndexDo:  [ :context :entryIndex |  self perform: context receiver with: context with: entryIndex with: html ].html break.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 23:02'!renderReadStrategyOn: htmlreadStrategy ifNil: [ ^self ].html bold: 'Read strategy: '.readStrategy renderOn: html! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 15:09'!rendererClass^WARenderCanvas! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 02:30'!seaside: context i: entryIndex on: htmlfirstTime ifNil: [ firstTime := context at: 2 ].html bold: (entryIndex asString, ': [', ((context at: 2) - firstTime) asString, '] ', (context at: 1)).html break.! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 00:41'!serializer^serializer! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 03:09'!showReadStrategy^showReadStrategy ifNil: [ true ]! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 22:22'!showReadStrategy: boolshowReadStrategy := bool! !!WAMagmaLog methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 02:26'!testRead: context i: entryIndex on: html"context expected forentryForReading: oid at: currentDepth to: minDepth attribute: varIndex ofClassId: classId version: classVersion " | theClass theAttributeName theValue out |firstTime ifNil: [ firstTime := context tempAt: 8 ].classIdManager ifNil: [ ^html bold: '<<no class id manager available>>' ].theClass := classIdManager classForId: (context tempAt: 5) ifAbsent: [ ^self error: 'could not find class id' ].theAttributeName := theClass allInstVarNames at: (context tempAt: 4) ifAbsent: [  (context tempAt: 4) asString ].theValue := serializer objectWithOid: (context tempAt: 1).out :=  (String streamContents: [ :stream | stream 	nextPutAll: entryIndex asString;		nextPutAll: ': [';		nextPutAll: ((context tempAt: 8) - firstTime) asString;		nextPutAll: '] (';		nextPutAll: (context tempAt: 2) asString;		nextPut: $/;		nextPutAll: (context tempAt: 3) asString.(context tempAt: 7) ~= false ifTrue: [stream		nextPut: $/;		nextPutAll: (context tempAt: 7) asString ].stream		nextPutAll: ') ';		nextPutAll: theClass name;		nextPut: $-;		nextPutAll: theAttributeName;		nextPutAll: ' = ';		nextPutAll: (theValue printStringLimitedTo: 40);		yourself.	]).(context tempAt: 7) = false ifTrue: [ html text: out ] ifFalse: [ html bold: out ].html break ! !!MagmaLocation methodsFor: '*magma seaside' stamp: 'kph 9/9/2006 03:21'!newSessionAs: userName ^ self newSession connectAs: userName; yourself! !!MaObjectRepository methodsFor: '*magma seaside' stamp: 'kph 9/20/2006 23:38' prior: 35086883!graphBufferAt: oidInteger using: aMaReadStrategy	"Answers a MaSerializedGraphBuffer."	| answer rootBuffer |	answer _ MaSerializedGraphBuffer new: 400.	rootBuffer _ 		filer			appendObject: oidInteger			into: answer.	rootBuffer		appendGraphUsing: (aMaReadStrategy signalBeginningToRead: oidInteger)		into: answer		currentDepth: 1		minDepth: aMaReadStrategy minimumDepth		with: Set new		filer: filer.	^ answer! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'mmb 12/5/2005 09:17'!ancestors	^ Array with: (WARenderLoopConfiguration new)! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'kph 9/27/2006 03:46'!attributes    "Return the attributes specific to this configuration"	^ Array with: (WAMagmaLocationAttribute key: #location group: #magma)			 with: ((WAListAttribute key: #readStrategy group: #magma)						options: self readStrategyClasses; yourself ).! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'brp 11/4/2005 11:44'!location	^ MagmaLocalLocation default! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 14:10'!readStrategy ^ WAMagmaReadStrategyDefault ! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'kph 9/20/2006 14:12'!readStrategyClasses ^ WAMagmaReadStrategyDefault withAllSubclasses ! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 11:35'!repositoryPath	^ 'store'! !!WAMagmaConfiguration methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 11:24'!sessionClass	^ WAMagmaSession! !!MagmaLocalLocation methodsFor: '*magma seaside' stamp: 'kph 10/4/2006 14:39'!repositoryPath^self pathName! !!WAMagmaSession commentStamp: 'kph 9/29/2006 02:15' prior: 0!Experimental: the holder instVar is available to put a repository object(s) into for the duration of the session, in order to prevent realised objects from being garbage collected. When the session is unregistered the holder is set to nil releasing the object.!!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/9/2006 17:41'!commit: aBlock	self magmaSession commit: aBlock! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 02:15'!holder^holder! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 02:15'!holder: anObjectholder := anObject! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/9/2006 03:15'!location ^self application preferenceAt: #location.! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 06:11'!log: message	|timeStamp |								timeStamp := Time millisecondClockValue. ^self readStrategyClass isLogger ifTrue: [ WAMagmaLog log entry: 'seaside' context: thisContext ] ! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/17/2006 17:16'!magmaSession^ magmaSession ifNil: [ 	magmaSession := self obtainMagmaSession ]! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/21/2006 02:23'!obtainMagmaSessionself log: 'Obtaining MagmaSession'.^self readStrategyClass setStrategyFor: (self location newSessionAs: 'seaside').! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/17/2006 16:56'!readStrategyClass ^ self application preferenceAt: #readStrategy! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 8/11/2006 03:41'!repositoryPath	"This is a convenience method to get the repository directory path from Seaside"	^ self application preferenceAt: #repositoryPath! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 12:52'!root	^ self magmaSession root! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 04:19'!setMagmaSession: msmagmaSession := ms! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 05:00'!stubOut: anObject	self magmaSession stubOut: anObject! !!WAMagmaSession methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 21:23'!unregisteredholder := nil.magmaSession ifNotNil: [ magmaSession disconnect. magmaSession := nil ]! !!WAMagmaSharedSession commentStamp: 'kph 9/17/2006 02:42' prior: 0!WAMagmaSharedSession keeps one session per repository, and this is provided to each Seaside Session. i.e. each seaside session can access the database but needs to be aware that it may be sharing its view of the model with other seaside sessions.Pier has a model locking mechanism in place to prevent concurrent edits, and so will perform better with WAMagmaSharedSession than with a standard WAMagmaSession Since sharing the magma session avoids the overhead of connecting to the database at the beginning of every user session.Rules for use:Do not abort, you may ruin someone else's transaction.Ensure that commits are negotiated amongst the sharing users via locking. If one seaside session commits: while another is in mid transaction their changes will be lost. To use a shared session there should be one data model that manages commits: and aborts on behalf of all of its seaside session clients.!!CTMagmaSharedSession methodsFor: 'processing' stamp: 'lr 8/30/2006 12:04'!cometRequest: aRequest	^ (handlers		at: (aRequest fields			at: CTComet headerField			ifAbsent: [ ^ nil ])		ifAbsent: [ ^ nil ])			connect: aRequest! !!CTMagmaSharedSession methodsFor: 'processing' stamp: 'lr 7/12/2006 12:10'!incomingRequest: aRequest	aRequest responseStream		ifNil: [ self error: 'Streaming-server required.' ].	^ (aRequest fields includesKey: CTComet headerField)		ifTrue: [ self cometRequest: aRequest ]		ifFalse: [ super incomingRequest: aRequest ]! !!CTMagmaSharedSession methodsFor: 'initialization' stamp: 'lr 7/12/2006 11:02'!initializeWithApplication: anApplication	super initializeWithApplication: anApplication.	handlers := Dictionary new! !!CTMagmaSharedSession methodsFor: 'public' stamp: 'lr 8/30/2006 11:57'!registerPusher: aPusher context: aContext	| handler |	handler := CTHandler on: aPusher session: self context: aContext.	handlers at: handler id put: handler.	^ handler id! !!WAMagmaSharedSession class methodsFor: 'class initialization' stamp: 'kph 9/9/2006 03:32'!initializeMagmaSessions := Dictionary new.! !!WAMagmaSharedSession class methodsFor: 'class initialization' stamp: 'kph 9/19/2006 13:20'!magmaSessions^MagmaSessions"self magmaSessions"! !!WAMagmaSharedSession methodsFor: 'as yet unclassified' stamp: 'kph 9/17/2006 17:14'!magmaAbortOnRequest."dont for a shared session"! !!WAMagmaSharedSession methodsFor: 'as yet unclassified' stamp: 'kph 9/22/2006 16:39'!obtainMagmaSession| ms |ms := MagmaSessions at: (self location) ifAbsent: [ nil ].((ms isNil or: [ ms isOpen not ]) or: [ ms isConnected not]) 	ifTrue: [ ms := MagmaSessions at: self location put: super obtainMagmaSession ].^ms! !!WAMagmaSharedSession methodsFor: 'as yet unclassified' stamp: 'kph 9/24/2006 04:18'!unregistered	magmaSession ifNotNil: [ magmaSession := nil ]! !!UnixFileDirectory methodsFor: '*magma seaside' stamp: 'kph 9/1/2006 01:38' prior: 50414224!directoryExists: filenameOrPath    "Handles the special case of testing for the root dir: there isn't a    possibility to express the root dir as full pathname like '/foo'."    ^ filenameOrPath = '/'        or: [ filenameOrPath = self class default pathName        or: [ super directoryExists: filenameOrPath ] ]! !"Magma seaside"!!TestResourceMagma commentStamp: 'kph 10/10/2006 09:13' prior: 0!Provide magma as an SUnit TestResource. For information on this practice see:http://www.metaprog.com/ESUG/TestResources.pdfUse a magma database in ramdisk (location is hard wired in MagmaLocalRamdiskLocation-#base to /ramdisk)Although we could we do not create and delete the database from scratch every test run. If it is present we use it and apply #beEmpty.!!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:27'!beEmptyself initializeRoot: nil! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:24'!initializeRoot: rootObjectself session commit: [	[ self session root: rootObject ] on: Warning do: [ :e | e resume ].].^rootObject! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/5/2006 00:03'!isAvailable^session isOpen! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 22:22'!location^location! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 03:38'!session^session ! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 03:39'!setUp 	location := MagmaLocalRamdiskLocation default.	location isRepository ifFalse: [ MagmaRepositoryController create: location ].	session := location newSessionAs: 'sunit'.	self beEmpty.! !!TestResourceMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 03:22'!tearDown	self beEmpty.	session disconnectAndClose.	 	! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:01'!abort! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:01'!begin! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:01'!commit! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:01'!commit: aBlock	^aBlock value! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:01'!inTransaction	^false! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:24'!initializeRoot: rootObject^root := rootObject! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/7/2006 03:10'!location^self! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/7/2006 03:10'!newSessionAs: user^self! !!TestResourceMockMagma methodsFor: 'accessing' stamp: 'kph 10/6/2006 06:23'!root	"Answer the value of root"	^ root! !!TestResourceMockMagma methodsFor: 'accessing' stamp: 'kph 10/6/2006 06:23'!root: anObject	"Set the value of root"	root _ anObject! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:00'!session^self! !!TestResourceMockMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 06:21'!stubOut: a! !!MagmaLocalRamdiskLocation class methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 03:13'!default ^ self path: 'magma-testing'! !!MagmaLocalRamdiskLocation methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 03:24'!base^ FileDirectory on: '/ramdisk'! !!TestCaseUsingMagma class methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:26'!resources^Array with: (self useMock ifTrue: [ TestResourceMockMagma ] ifFalse: [ TestResourceMagma ])! !!TestCaseUsingMagma class methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:25'!useMock^ false! !!TestCaseUsingMagma methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 09:14'!magma^self class resources first current! !"Magma sunit"!!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'brp 10/28/2005 13:13' prior: 34258202!browse	"Read the entire Magma collection"	self displayItems: (self inventory read: #title)! !!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'cmm 11/2/2005 21:20'!hasOrders	^ self session root orders notEmpty! !!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'kph 6/16/2006 03:28' prior: 34259306!inventory	^ self session root inventory ! !!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'brp 7/7/2006 18:12' prior: 34259768!renderNavBarOn: html	html form: [		html bold: 'Search:'.		html space.		html textInput callback: [:v | self search: v]; value: '' ].	html anchor callback: [self browse]; text: 'Browse'.	self hasOrders ifTrue: [ 		html break. 		html anchor callback: [ self showOrders ]; text: 'Orders' ].	cart hasItems ifTrue:  [		html break.		html anchor callback: [self checkout]; text: 'Checkout']! !!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'kph 9/5/2006 12:20' prior: 34260235!search: aString	"This method demsontrates the complex query functionality Magma supports.	The first where clause uses doesNotUnderstand: to read the #title index in a very 	intuitive manner.	The second where cluase uses the more explicit but less terse method to read the	#keywords index."| result nextString |nextString := aString maAlphabeticalNext.result  := self inventory where: [ :each | each title between: aString and: nextString ]. result ifNotEmptyDo: [ : results | ^ self displayItems: results ]. result  := self inventory where:		[ :reader |			reader 				read: #keywords				from: aString				to: nextString ].result ifNotEmptyDo: [ : results | ^ self displayItems: results ].  ^main inform: 'No items match ', aString printString  				 ! !!WAStoreFillCart methodsFor: '*seaside-examples-store-magma' stamp: 'cmm 11/2/2005 21:13'!showOrders	self show: WAStoreOrderView new! !!WAStoreOrderView methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:31'!buildTable	table := WATableReport new		rowPeriod: 1;		rowColors: #('lightblue' 'white');		rows: self rows;		columns: {			WAReportColumn selector: #date title: 'Date'.			WAReportColumn selector: #name title: 'Name'.			WAReportColumn selector: #totalPrice title: 'Total Price'.		}! !!WAStoreOrderView methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:07'!children	^ Array with: table! !!WAStoreOrderView methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:07'!initialize	super initialize.	self buildTable! !!WAStoreOrderView methodsFor: 'as yet unclassified' stamp: 'cmm 11/2/2005 21:16'!renderContentOn: html	html form:		[ html heading: 'Orders' level: 3.		html render: table.		html submitButtonWithAction: [ self answer ] text: 'Done' ]! !!WAStoreOrderView methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:10'!rows	^ self session root orders read: #date! !!WAStoreRepositoryStatus commentStamp: 'kph 9/23/2006 15:53' prior: 0!This is an example showing how to provide a Seaside component as a control panel for a magma repository.- The component has class methods which give the user initialization options in the MagmaControlPanel- The repository root instance needs to implement #magmaControlPanelOn: aMagmaSession!!WAStoreRepositoryStatus class methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 19:04'!magmaRootClass^ WAStoreRepository ! !!WAStoreRepositoryStatus class methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 19:04'!magmaRootDescription ^'This class provides the root of a Magma repository to be used with the Seaside Store example.It replaces WAStoreInventory. It maintains two indexed MagmaCollections: inventory & orders.' ! !!WAStoreRepositoryStatus class methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 18:58'!on: magmaSession^ self new setMagmaSession: magmaSession; yourself! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 06:15'!initializeRepositorymagmaSession commit: [ magmaSession root initializeRepository ].! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/23/2006 15:54'!renderContentOn: htmlhtml heading level: 3; with: 'Store-Magma Example Control Panel'.magmaSession root inventory ifNil: [ self renderInitializationOptionsOn: html ] 			ifNotNil: [ self renderStatsOn: html ]! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 06:14'!renderInitializationOptionsOn: htmlhtml text: 'Repository has not yet been initialized. This example will be initialized with an example dataset.'.html break.html form: [ html submitButton callback: [ self initializeRepository  ] ; text: 'Initialize' ]! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 19:00'!renderStatsOn: htmlhtml heading level: 4 ; with: [ html text: 'StoreRepository' ].html bold: 'inventory: '. html text: magmaSession root inventory size asString.html break.html bold: 'orders:'.  html text: magmaSession root orders size asString.! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 18:51'!rendererClass^ WARenderCanvas! !!WAStoreRepositoryStatus methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 18:58'!setMagmaSession: msmagmaSession := ms! !!WAStoreItem methodsFor: '*seaside-examples-store-magma' stamp: 'cmm 11/1/2005 00:36'!keywords	^ (title substrings, description substrings) asSet! !!WAOrder commentStamp: '<historical>' prior: 0!WAStoreRepository maintains a collection of WAOrder instances indexed by Date.!!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:40'!billingAddress	^ billingAddress! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:39'!billingAddress: aWAStoreAddress 	billingAddress := aWAStoreAddress ! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:40'!cart	^ cart! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:40'!cart: aWAStoreCart 	^ cart := aWAStoreCart! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:53'!creditCard	^ creditCard! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:53'!creditCard: aWAStoreCreditCard	creditCard := aWAStoreCreditCard! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 14:01'!date	^ self dateAndTime asDate! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:38'!dateAndTime	^ dateAndTime ifNil: [ dateAndTime := DateAndTime now ]! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:58'!name	^ self shippingAddress name! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:28'!price	^ 5.4! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:39'!shippingAddress	^ shippingAddress! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 13:39'!shippingAddress: aWAStoreAddress 	shippingAddress := aWAStoreAddress ! !!WAOrder methodsFor: 'as yet unclassified' stamp: 'brp 11/1/2005 16:30'!totalPrice	^ self cart totalPrice! !!WAStoreRepository commentStamp: 'kph 9/5/2006 19:05' prior: 0!This class provides the root of a Magma repository to be used with the Seaside Store example.It replaces WAStoreInventory. It maintains two indexed MagmaCollections: inventory & orders.!!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'kph 9/17/2006 17:29'!buildReadStrategyOn: strategy"set the read strategy for this application"! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'cmm 11/1/2005 00:37'!initializeInventory	"Create the MagmaCollection and its indices"	inventory := MagmaCollection new		addIndex: ((MaSearchStringIndex attribute: #title) keySize: 128; yourself) ;		addIndex: ((MaKeywordIndex attribute: #keywords) keySize: 64; yourself) ;		yourself.	"Use the original class to populate the collection..."	WAStoreInventory new allItems do: [ :item | inventory add: item  ].! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 12:23'!initializeOrders	orders := MagmaCollection  new 		addIndex: ((MaSearchStringIndex attribute: #name) keySize: 128; yourself);		addIndex: (MaDateIndex attribute: #date);		yourself.! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 19:08'!initializeRepository	super initialize.	self 		initializeInventory; 		initializeOrders.	^self! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 12:09'!inventory	^ inventory! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'kph 9/5/2006 18:54'!magmaControlPanelOn: magmaSession"presents myself as a seaside component to be a UI to this repository. Since the seaside component and the repository are the same, and we do not wish to accidentally persist the session, we discard/ignore it here."^ WAStoreRepositoryStatus on: magmaSession! !!WAStoreRepository methodsFor: 'as yet unclassified' stamp: 'brp 10/28/2005 12:09'!orders	^ orders! !!WAStoreTask methodsFor: '*seaside-examples-store-magma' stamp: 'brp 11/4/2005 12:19' prior: 34269028!shipTo: shippingAddress billTo: billingAddress payWith: aCreditCard	"Store the order in Magma"	| order |	order := WAOrder new				cart: cart;				shippingAddress: shippingAddress;				billingAddress: billingAddress;				creditCard: aCreditCard;				yourself.	self session commit: [ self session root orders add: order ].! !!WAStore class methodsFor: '*seaside-examples-store-magma' stamp: 'brp 10/28/2005 11:30' prior: 34252168!initialize	| application |	application := self registerAsApplication: 'store'.	application configuration 		addAncestor: WAMagmaConfiguration new.	^ application! !!WAStore class methodsFor: '*seaside-examples-store-magma' stamp: 'brp 10/28/2005 11:40'!repositoryPath	^ WAMagmaConfiguration new valueAt: #repositoryPath! !!WAStore class methodsFor: '*seaside-examples-store-magma' stamp: 'kph 9/5/2006 19:33'!workspace	"WAStore workspace"'"----------------------------------------------------------------------------------------------------------------- Create the Magma repository in a local directory (manually) (seaside/config MagmaControlPanel provides a gui for this step).-----------------------------------------------------------------------------------------------------------------"MagmaRepositoryController create: ''magma'' root: (WAStoreRepository new initializeRepository)."----------------------------------------------------------------------------------------------------------------- Open the repository with a local session.-----------------------------------------------------------------------------------------------------------------" session := MagmaLocalLocation default newSession.  session connectAs: ''brp''."----------------------------------------------------------------------------------------------------------------- Explore the repository-----------------------------------------------------------------------------------------------------------------"session root explore.session root inventory size.			"40"session root orders size.				"0"session root inventory anyOne explore."----------------------------------------------------------------------------------------------------------------- Interrogate the inventory...-----------------------------------------------------------------------------------------------------------------"Transcript clear.session root inventory do: [ :x | Transcript show: x; cr ].(session root inventory where: [ :sushi | sushi title = ''Uni'' ]) do: [ :x | Transcript show: x; cr ].(session root inventory where: [ :sushi | sushi title between: ''Sake'' and: ''Tai'']) do: [ :x | Transcript show: x; cr ]."----------------------------------------------------------------------------------------------------------------- Close the repository.-----------------------------------------------------------------------------------------------------------------"session disconnectAndClose. session := nil. Smalltalk garbageCollect. MagmaSession allInstances. "should be #()""----------------------------------------------------------------------------------------------------------------- Initialise the WAStore application and start Comanche/Seaside-----------------------------------------------------------------------------------------------------------------"WAStore initialize.WAKom startOn: 8080."----------------------------------------------------------------------------------------------------------------- Once you have made an order via WAStore, you can connect to the repository via the controller managed by WAMagmaSession.-----------------------------------------------------------------------------------------------------------------"session := MagmaLocalLocation default newSession.session connectAs: ''brp''.session root orders size.(session root orders read: #date) anyOne.session disconnect. session := nil."----------------------------------------------------------------------------------------------------------------- Stop Comanche/Seaside-----------------------------------------------------------------------------------------------------------------"WAKom stop.MagmaRepositoryController initialize.  "closes all repositories.""----------------------------------------------------------------------------------------------------------------- Delete the repository.-----------------------------------------------------------------------------------------------------------------"WAStoreRepository delete.'	openInWorkspaceWithTitle: 'The Sushi Store: Seaside meets Magma'! !"Seaside-Examples-Store-Magma"!!String methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!lines	"Retrun a collection with the string-lines of the receiver."	^ Array streamContents: [ :output |		self readStream in: [ :input |			[ input atEnd ] whileFalse: [				output nextPut: (input upTo: Character cr).				input peek = Character lf					ifTrue: [ input next ] ] ] ]! !!String methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!matches: aString	aString isEmpty ifTrue: [ ^ true ].	^ (aString includesAnyOf: '*#')		ifTrue: [ aString match: self ]		ifFalse: [ self includesSubstring: aString caseSensitive: false ]! !!MAError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I represent a generic Magritte error.!!MAReadError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem reading serialized data.!!MAValidationError commentStamp: 'lr 5/17/2006 15:15' prior: 0!I am a generic validation error. I reference the description that caused the validation error.!!MAConditionError commentStamp: 'lr 5/30/2006 23:33' prior: 0!I am an error that is raised whenever a user-defined condition is failing.!!MAConditionError class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!on: aDescription explanation: aString	^ self new		setDescription: aDescription;		setExplanation: aString;		signal! !!MAConditionError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	^ explanation! !!MAConditionError methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setExplanation: aString	explanation := aString! !!MAConflictError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever there is an edit conflict.!!MAConflictError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	^ 'Input is conflicting with concurrent modification'! !!MAKindError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever a description is applied to the wrong type of data.!!MAKindError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	^ 'Invalid input given'! !!MAMultipleErrors commentStamp: 'lr 5/17/2006 15:18' prior: 0!I am an error that is raised whenever there are multiple validation rules failing.!!MAMultipleErrors class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:33'!on: aDescription errors: aCollection	^ self new		setDescription: aDescription;		setCollection: aCollection;		signal! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!collection	^ collection! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	^ 'Multiple errors'! !!MAMultipleErrors methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	self collection		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPut: Character cr ]! !!MAMultipleErrors methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderOn: html	html render: self label.	html unorderedList: [		self collection do: [ :each |			html listItem: each ] ]! !!MAMultipleErrors methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setCollection: aCollection	collection := aCollection! !!MARangeError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a described value is out of bounds.!!MARangeError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	| min max |	min := self tag toString: self tag min.	max := self tag toString: self tag max.	^ String streamContents: [ :stream |		stream nextPutAll: 'Input must be '.		self tag max isNil			ifTrue: [ stream nextPutAll: 'above '; nextPutAll: min ]			ifFalse: [				self tag min isNil					ifTrue: [ stream nextPutAll: 'below '; nextPutAll: max ]					ifFalse: [ stream nextPutAll: 'between '; nextPutAll: min; nextPutAll: ' and '; nextPutAll: max ] ] ]! !!MARequiredError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a required value is not supplied.!!MARequiredError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	^ 'Input is required but no input given'! !!MAValidationError class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!on: aDescription	^ self new		setDescription: aDescription;		signal! !!MAValidationError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!explanation	self subclassResponsibility! !!MAValidationError methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!hasLabel	^ self tag hasLabel! !!MAValidationError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ self tag label ifNil: [ self tag asString ]! !!MAValidationError methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	aStream nextPutAll: self label; nextPutAll: ': '; nextPutAll: self explanation! !!MAValidationError methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderOn: html	html render: self label; text: ': '; render: self explanation! !!MAValidationError methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setDescription: aDescription	self tag: aDescription! !!MAWriteError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem writing serialized data.!!MAConditionBuilder methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!doesNotUnderstand: aMessage	^ MASelectorCondition		selector: aMessage selector		arguments: (aMessage arguments			collect: #asCondition)! !!MAConditionBuilder methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isNil	^ MASelectorCondition selector: #isNil arguments: #()! !!MAProxyObject commentStamp: 'lr 5/17/2006 15:29' prior: 0!I represent an abstract proxy object, to be refined by my subclasses.!!MADynamicObject commentStamp: 'lr 5/29/2006 08:28' prior: 0!A dynamic object can be used for almost any property within Magritte that is not static but calculated dynamically. This is a shortcut to avoid having to build context sensitive descriptions manually over and over again, however there are a few drawbacks: - Some messages sent to this proxy, for example <code>#class</code> and <code>#value</code>, might not get resolved properly.- Raising an unhandled exception will not always open a debugger on your proxy, because tools are unable to properly work with the invalid object and might even crash your image.!!MADynamicObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!realSubject	^ super realSubject on: UnhandledError do: [ :err | nil ]! !!MAProxyObject class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!on: anObject	^ self basicNew realSubject: anObject! !!MAProxyObject methodsFor: 'copying' stamp: 'lr 5/17/2006 15:30'!copy	"It doesn't make sense to copy proxies in most cases, the real-subject needs to be looked up and will probably return a new instance on every call anyway."	^ self! !!MAProxyObject methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!doesNotUnderstand: aMessage	^ self realSubject		perform: aMessage selector		withArguments: aMessage arguments! !!MAProxyObject methodsFor: 'private' stamp: 'lr 5/17/2006 15:31'!isMorph	"Answer <code>false</code>, since I am no morph. Squeak is calling this method after image-startup and might lock if I do not answer to this message."	^ false! !!MAProxyObject methodsFor: 'testing' stamp: 'lr 5/17/2006 16:04'!isNil	"This method is required to properly return <code>true</code> if the <code>realSubject</code> is <code>nil</code>."	^ self realSubject isNil! !!MAProxyObject methodsFor: 'printing' stamp: 'lr 5/17/2006 15:30'!printOn: aStream	"Print the receiver on <code>aStream</code> but within square-brackets to show that it is a proxied instance."	aStream nextPut: $[; print: self realSubject; nextPut: $]! !!MAProxyObject methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printString	^ String streamContents: [ :stream | self printOn: stream ]! !!MAProxyObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!realSubject	^ realSubject! !!MAProxyObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!realSubject: anObject	realSubject := anObject! !!MAComponentDecoration methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!rendererClass	^ WARenderCanvas! !!MAContainerDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!buttons	self subclassResponsibility! !!MAContainerDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!default	^ self buttons first key! !!MAContainerDecoration methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isMultipart	^ self component isMultipart! !!MAContainerDecoration methodsFor: 'rendering' stamp: 'rjl 4/24/2006 07:18'!renderButtonsOn: html	html div		class: 'buttons';		with: [			self buttons do: [ :each |				html submitButton					accessKey: each value first;					on: each key of: self component;					text: each value ] ]! !!MAContainerDecoration methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	html form		multipart: self isMultipart;		defaultAction: [ self component perform: self default ];		with: [ self renderOwnerOn: html; renderButtonsOn: html ]! !!MAFormDecoration class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!buttons: aCollection	^ self new		addButtons: aCollection;		yourself! !!MAFormDecoration methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addButton: aSelector	self addButton: aSelector label: (self labelForSelector: aSelector)! !!MAFormDecoration methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addButton: aSelector label: aString	self buttons add: aSelector -> aString! !!MAFormDecoration methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addButtons: aCollection	aCollection do: [ :each |		each isVariableBinding			ifFalse: [ self addButton: each ]			ifTrue: [ self addButton: each key label: each value ] ]! !!MAFormDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!buttons	^ buttons! !!MAFormDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!buttons: aCollection	buttons := aCollection! !!MAFormDecoration methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!initialize	super initialize.	self buttons: OrderedCollection new! !!MASwitchDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!buttons	^ self component isReadonly		ifTrue: [ Array with: #edit -> 'Edit' ]		ifFalse: [ Array with: #save -> 'Save' with: #cancel -> 'Cancel' ]! !!MASwitchDecoration methodsFor: 'processing' stamp: 'lr 3/9/2006 11:34'!handleAnswer: anObject continueWith: aBlock	self component readonly: true.	super handleAnswer: anObject continueWith: aBlock! !!MAValidationDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!exception	^ exception! !!MAValidationDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!exception: anException	exception := anException! !!MAValidationDecoration methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:34'!exceptionSet	^ MAError! !!MAValidationDecoration methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!hasException	^ self exception notNil! !!MAValidationDecoration methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!processChildCallbacks: aStream	[ super processChildCallbacks: aStream ]		on: self exceptionSet		do: [ :err | self exception: err ]! !!MAValidationDecoration methodsFor: 'rendering' stamp: 'lr 3/21/2006 18:43'!renderContentOn: html	self hasException		ifTrue: [ self renderExceptionOn: html ].	self renderOwnerOn: html! !!MAValidationDecoration methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderExceptionOn: html	html div		class: 'validation';		with: self exception.	self exception: nil! !!BlockContext methodsFor: '*magritte-model-converting' stamp: 'lr 3/9/2006 11:31'!asCondition	"Convert the receiver to a condition, e.g. a parse tree representing the condition within the block. This is done by passing a proxy into the block and manually building a tree of conditions. This doesn't work for all code, but has the big advantage to make it fully serializeable."	^ self value: MAConditionBuilder new! !!Class methodsFor: '*magritte-model-configuration' stamp: 'lr 5/17/2006 15:47'!descriptionContainer	"Return the default description container."	^ MAPriorityContainer new		label: self label;		yourself! !!Class methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	"Answer a human-readable name of the receiving class. This implementation tries to be smart and return a nice label, unfortunately for a lot of classes this doesn't work well so subclasses might want to override this method and return soemthing more meaningfull to end-users."	| start input |	start := self name findFirst: [ :each | each isLowercase ].	input := (self name copyFrom: (1 max: start - 1) to: self name size)		readStream.	^ String streamContents: [ :stream |		[ input atEnd ] whileFalse: [			stream nextPut: input next.			(input atEnd or: [ input peek isLowercase ])				ifFalse: [ stream nextPut: Character space ] ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!asMultilineString	^ String streamContents: [ :stream |		self			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: Character cr ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!copyWithAll: aCollection	^ self copy		addAll: aCollection;		yourself! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!copyWithoutFirst: anObject	| done |	done := false.	^ self reject: [ :each |		each = anObject			and: [ done not ]			and: [ done := true ] ]! !!MAAdaptiveModelTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:35'!descriptions	^ self scaffolder description children! !!MAAdaptiveModelTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:35'!scaffolder	^ scaffolder! !!MAAdaptiveModelTest methodsFor: 'running' stamp: 'lr 5/17/2006 11:38'!setUp	scaffolder := MAAdaptiveModel new.	scaffolder description		add: (MAStringDescription null);		add: (MANumberDescription null).	scaffolder write: 'foo' using: self descriptions first.	scaffolder write: 123 using: self descriptions second! !!MAAdaptiveModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testRead	self assert: (self scaffolder readUsing: self descriptions first) = 'foo'.	self assert: (self scaffolder readUsing: self descriptions second) = 123! !!MAAdaptiveModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testWrite	self scaffolder write: 'bar' using: self descriptions first.	self scaffolder write: 321 using: self descriptions second.	self assert: (self scaffolder readUsing: self descriptions first) = 'bar'.	self assert: (self scaffolder readUsing: self descriptions second) = 321! !!MAConditionBuilderTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:34'!assertConditionFor: anObject	self assert: (condition value: anObject)! !!MAConditionBuilderTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!block: aBlock	condition := aBlock asCondition.	self assert: (condition isKindOf: MACondition)! !!MAConditionBuilderTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:34'!denyConditionFor: anObject	self deny: (condition value: anObject)! !!MAConditionBuilderTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testBeginsWith	self block: [ :v | v beginsWith: 'abc' ].	self assertConditionFor: 'abcd'.	self denyConditionFor: 'bcd'! !!MAConditionBuilderTest methodsFor: 'testing-numbers' stamp: 'lr 3/9/2006 11:34'!testBetweenAnd	self block: [ :v | v between: 3 and: 5 ].	self assertConditionFor: 5.	self denyConditionFor: 6! !!MAConditionBuilderTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testEndsWith	self block: [ :v | v endsWith: 'xyz' ].	self assertConditionFor: 'xyz'.	self denyConditionFor: 'xy'! !!MAConditionBuilderTest methodsFor: 'testing-equality' stamp: 'lr 3/9/2006 11:34'!testEqualsNil	self block: [ :v | v = nil ].	self assertConditionFor: nil.	self denyConditionFor: 0! !!MAConditionBuilderTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testIncludesSubstring	self block: [ :v | v includesSubstring: 'IJ' caseSensitive: false ].	self assertConditionFor: 'aijz'.	self denyConditionFor: 'aiz'! !!MAConditionBuilderTest methodsFor: 'testing-undefined' stamp: 'lr 3/9/2006 11:34'!testIsNil	self block: [ :v | v isNil ].	self assertConditionFor: nil.	self denyConditionFor: 0! !!MAConditionBuilderTest methodsFor: 'testing-usecase' stamp: 'lr 3/9/2006 11:34'!testMail	self block: [ :v | v matches: '#*@#*.#*' ].	self assertConditionFor: 'renggli@gmail.com'.	self denyConditionFor: 'renggliATgmail.com'! !!MAConditionBuilderTest methodsFor: 'testing-equality' stamp: 'lr 3/9/2006 11:34'!testNotEquals	self block: [ :v | v ~= nil ].	self denyConditionFor: nil.	self assertConditionFor: 0! !!MAConditionBuilderTest methodsFor: 'testing-undefined' stamp: 'lr 3/9/2006 11:34'!testNotNil	self block: [ :v | v notNil ].	self denyConditionFor: nil.	self assertConditionFor: 0! !!MAConditionBuilderTest methodsFor: 'testing-numbers' stamp: 'lr 3/9/2006 11:34'!testOutsideOf	self block: [ :v | (v < 3) | (v > 7) ].	self assertConditionFor: 2.	self assertConditionFor: 8.	self denyConditionFor: 5! !!MAConditionBuilderTest methodsFor: 'testing-usecase' stamp: 'lr 3/9/2006 11:34'!testSwissMail	self block: [ :v | (v matches: '#*@#*.#*') & (v endsWith: '.ch') ].	self assertConditionFor: 'lukas@gmail.ch'.	self denyConditionFor: 'lukas@gmail.com'! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 15:56'!descriptionContainer	^ super descriptionContainer label: 'mock'! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 15:58'!descriptionContainer: aDescription	^ aDescription propertyAt: #bar put: nil; yourself! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 15:58'!descriptionContainerFoo: aDescription	^ aDescription propertyAt: #foo put: nil; yourself! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 16:00'!descriptionDescription	^ MAStringDescription new label: 'foo'! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 16:00'!descriptionDescription: aDescription	^ aDescription propertyAt: #foo put: nil; yourself! !!MADescriptionBuilderTest class methodsFor: 'mock-descriptions' stamp: 'lr 5/17/2006 16:00'!descriptionDescriptionBar: aDescription	^ aDescription propertyAt: #bar put: nil; yourself! !!MADescriptionBuilderTest methodsFor: 'testing' stamp: 'lr 5/17/2006 15:59'!testContainer	self assert: self description label = 'mock'.	self assert: (self description hasProperty: #foo).	self assert: (self description hasProperty: #bar)! !!MADescriptionBuilderTest methodsFor: 'testing' stamp: 'lr 5/17/2006 16:01'!testDescription	self assert: self description size = 1.	self assert: self description children first label = 'foo'.	self assert: (self description children first hasProperty: #foo).	self assert: (self description children first hasProperty: #bar)! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testCalculated	| object dummy |	object := MADynamicObject on: [ Time millisecondClockValue ].	dummy := object yourself.	(Delay forMilliseconds: 2) wait.	self assert: dummy < object! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testCollection	| object |	object := MADynamicObject on: [ OrderedCollection with: 1 with: 2 ].	self assert: object size = 2.	self assert: object first = 1.	self assert: object second = 2.	object add: 3.	self assert: object size = 2.	self assert: object first = 1.	self assert: object second = 2! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testConstant	| object |	object := MADynamicObject on: [ self ].	self assert: object = self.	object := MADynamicObject on: [ 123 ].	self assert: object = 123! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testCopy	| object first second |	object := (MADynamicObject on: [ Time millisecondClockValue ])		copy.	first := object yourself.	(Delay forMilliseconds: 2) wait.	second := object yourself.	self assert: first < second! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testCounter	| object counter |	counter := nil.	object := MADynamicObject on: [		counter := counter isNil			ifTrue: [ 1 ]			ifFalse: [ counter := counter + 1 ] ].	self assert: object = 1.	self assert: object yourself = 2.	self assert: object yourself yourself = 3! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testDynamic	| object collection |	collection := nil.	object := MADynamicObject on: [		collection isNil			ifTrue: [ collection := OrderedCollection with: 1 with: 2 ]			ifFalse: [ collection ] ].	self assert: object size = 2.	self assert: object first = 1.	self assert: object second = 2.	object add: 3.	self assert: object size = 3.	self assert: object first = 1.	self assert: object second = 2.	self assert: object third = 3! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testException	| object |	object := MADynamicObject on: [ 1 / 0 ].	self should: [ object asString ] raise: ZeroDivide.	object := MADynamicObject on: [ Halt signal ].	self assert: object asString = 'nil'! !!MADynamicObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testNilOrNotNil	| object |	object := MADynamicObject on: [ 1 ].	self deny: object isNil.	self assert: object notNil.	object := MADynamicObject on: [ nil ].	self assert: object isNil.	self deny: object notNil! !!MAExtensionsTest methodsFor: 'testing-collection' stamp: 'lr 3/9/2006 11:34'!testCopyWithAll	| col res |	col := #( a b ).	res := col copyWithAll: #( c d ).	self assert: res = #( a b c d ).	self deny: col == res.	col := Set with: #a with: #b.	res := col copyWithAll: #( c d ).	self assert: res = (Set with: #a with: #b with: #c with: #d).	self deny: col == res! !!MAExtensionsTest methodsFor: 'testing-collection' stamp: 'lr 3/9/2006 11:34'!testCopyWithoutFirst	| col res |	col := #( a b a c ).	res := col copyWithoutFirst: #a.	self assert: res = #( b a c ).	self deny: col == res.	col := Set with: #a with: #b with: #c.	res := col copyWithoutFirst: #a.	self assert: res = (Set with: #b with: #c).	self deny: col == res! !!MAExtensionsTest methodsFor: 'testing-integer' stamp: 'lr 3/9/2006 11:34'!testFileSize	self assert: (1000) asFileSize = '1000 B'.	self assert: (1024) asFileSize = '1 KB'.	self assert: (1000 * 1000) asFileSize = '976 KB'.	self assert: (1024 * 1024) asFileSize = '1 MB'.	self assert: (1000 * 1000 * 1000) asFileSize = '953 MB'.	self assert: (1024 * 1024 * 1024) asFileSize = '1 GB'.	self assert: (1000 * 1000 * 1000 * 1000) asFileSize = '931 GB'.	self assert: (1024 * 1024 * 1024 * 1024) asFileSize = '1 TB'.	" etc "! !!MAExtensionsTest methodsFor: 'testing-string' stamp: 'lr 3/9/2006 11:34'!testMatches	self assert: ('' matches: '').	self assert: ('zort' matches: '').	self assert: ('zort' matches: 'o').	self assert: ('zort' matches: 'O').	self assert: ('zort' matches: '*').	self assert: ('mobaz' matches: '*baz').	self deny: ('mobazo' matches: '*baz').	self assert: ('mobazo' matches: '*baz*').	self deny: ('mozo' matches: '*baz*').	self assert: ('foozo' matches: 'foo*').	self deny: ('bozo' matches: 'foo*').	self assert: ('foo23baz' matches: 'foo*baz').	self assert: ('foobaz' matches: 'foo*baz').	self deny: ('foo23bazo' matches: 'foo*baz').	self assert: ('Foo' matches: 'foo').	self deny: ('foobazort' matches: 'foo*baz*zort').	self assert: ('foobazzort' matches: 'foo*baz*zort').	self assert: ('afoo3zortthenfoo3zort' matches: '*foo#zort').	self assert: ('afoodezortorfoo3zort' matches: '*foo*zort')! !!MAExtensionsTest methodsFor: 'testing-collection' stamp: 'lr 3/9/2006 11:34'!testMoveDown	| col |	col := Array with: 1 with: 2 with: 3.	self assert: (col moveDown: 1) = 2.	self assert: col = #( 2 1 3 ).	self assert: (col moveDown: 1) = 3.	self assert: col = #( 2 3 1 ).	self assert: (col moveDown: 1) = 3.	self assert: col = #( 2 3 1 ).	self assert: (col moveDown: 0) = 0.	self assert: col = #( 2 3 1 )! !!MAExtensionsTest methodsFor: 'testing-collection' stamp: 'lr 3/9/2006 11:34'!testMoveUp	| col |	col := Array with: 1 with: 2 with: 3.	self assert: (col moveUp: 3) = 2.	self assert: col = #( 1 3 2 ).	self assert: (col moveUp: 3) = 1.	self assert: col = #( 3 1 2 ).	self assert: (col moveUp: 3) = 1.	self assert: col = #( 3 1 2 ).	self assert: (col moveUp: 0) = 0.	self assert: col = #( 3 1 2 )! !!MAExtensionsTest methodsFor: 'testing-collection' stamp: 'lr 3/9/2006 11:34'!testReduce	self assert: ((1 to: 9) reduce: [ :a :b | a ]) = 1.	self assert: ((1 to: 9) reduce: [ :a :b | b ]) = 9.	self assert: ((1 to: 9) reduce: #+) = 45.	self assert: ((1 to: 9) reduce: [ :a :b | a + b ]) = 45.	self assert: ((1 to: 9) reduce: #*) = 362880.	self assert: ((1 to: 9) reduce: [ :a :b | a * b ]) = 362880.	self assert: (#('a' 'b' 'c') reduce: #,) = 'abc'.	self assert: (#('a' 'b' 'c') reduce: [ :a :b | a , ' ' , b ]) = 'a b c'.	self assert: (#('a' 'b' 'c') reduce: [ :a :b | b , ' ' , a ]) = 'c b a'! !!MAExtensionsTest methodsFor: 'testing-symbol' stamp: 'lr 3/9/2006 11:34'!testValue	self assert: (#yourself value: 'abc') = 'abc'.	self assert: (#reverse value: 'abc') = 'cba'! !!MAExtensionsTest methodsFor: 'testing-symbol' stamp: 'lr 3/9/2006 11:34'!testValueValue	self assert: (#+ value: 4 value: 2) = 6.	self assert: (#/ value: 4 value: 2) = 2! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testContents	| model |	model := MAFileModel new.	self assert: model contents isEmpty.	model contents: 'hello'.	self assert: model contents = 'hello'.	self assert: model size = 5! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testFilename	| model |	model := MAFileModel new.	self assert: model filename isEmpty.	self assert: model extension isEmpty.	model filename: 'test.txt'.	self assert: model filename = 'test.txt'.	self assert: model extension = 'txt'! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testIsEmpty	| model |	model := MAFileModel new.	self assert: model isEmpty.	model filename: 'foo.txt'.	self assert: model isEmpty.	model mimetype: 'text/plain'.	self assert: model isEmpty.	model contents: 'hello'.	self deny: model isEmpty! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetype	| model |	model := MAFileModel new.	self assert: model mimetype = 'application/octet-stream'.	self assert: model maintype = 'application'.	model filename: 'test.txt'.	self assert: model mimetype = 'text/plain'.	self assert: model maintype = 'text'.	model mimetype: 'text/html'.	self assert: model mimetype = 'text/html'.	self assert: model maintype = 'text'! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeApplication	| model |	model := MAFileModel new		mimetype: 'application/pdf';		yourself.	self assert: model isApplication.	self deny: model isAudio.	self deny: model isImage.	self deny: model isText.	self deny: model isVideo! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeAudio	| model |	model := MAFileModel new		mimetype: 'audio/mpeg';		yourself.	self deny: model isApplication.	self assert: model isAudio.	self deny: model isImage.	self deny: model isText.	self deny: model isVideo! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeDefault	| model |	model := MAFileModel new.	self assert: model isApplication.	self deny: model isAudio.	self deny: model isImage.	self deny: model isText.	self deny: model isVideo! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeImage	| model |	model := MAFileModel new		mimetype: 'image/png';		yourself.	self deny: model isApplication.	self deny: model isAudio.	self assert: model isImage.	self deny: model isText.	self deny: model isVideo! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeText	| model |	model := MAFileModel new		mimetype: 'text/xml';		yourself.	self deny: model isApplication.	self deny: model isAudio.	self deny: model isImage.	self assert: model isText.	self deny: model isVideo! !!MAFileModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testMimetypeVideo	| model |	model := MAFileModel new		mimetype: 'video/mpeg';		yourself.	self deny: model isApplication.	self deny: model isAudio.	self deny: model isImage.	self deny: model isText.	self assert: model isVideo! !!MAAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAAccessorTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!accessor	^ accessor! !!MAAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	self subclassResponsibility! !!MAAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAAccessor! !!MAAccessorTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!instance	^ accessor! !!MAAccessorTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:34'!setUp	super setUp.	accessor := self accessorInstance! !!MAAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self subclassResponsibility! !!MAAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self subclassResponsibility! !!MAAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsAccessor	self assert: self instance isAccessor! !!MAAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testRead	self subclassResponsibility! !!MAAccessorTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testStore	self assert: (self actualClass evaluatorClass		evaluate: self accessor storeString)			= self accessor! !!MAAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self subclassResponsibility! !!MAAccessorTest methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:34'!value	^ value! !!MAAccessorTest methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:34'!value: anObject	value := anObject! !!MABlockAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MABlockAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	^ self actualClass		read: [ :model | model value ]		write: [ :model :object | model value: object ]! !!MABlockAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MABlockAccessor! !!MABlockAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self assert: (self instance canRead: self).	self instance readBlock: nil.	self deny: (self instance canRead: self)! !!MABlockAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self assert: (self instance canWrite: nil).	self assert: (self instance canWrite: 123).	self assert: (self instance canWrite: self).	self instance writeBlock: nil.	self deny: (self instance canWrite: nil).	self deny: (self instance canWrite: 123).	self deny: (self instance canWrite: self)! !!MABlockAccessorTest methodsFor: 'testing' stamp: 'lr 6/15/2006 08:52'!testRead	self value: 123.	self assert: (self accessor read: self) = 123.	self value: '12'.	self assert: (self accessor read: self) = '12'! !!MABlockAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testReadBlock	self accessor readBlock: [ :model |		self assert: model = self. 123 ].	self assert: (self accessor read: self) = 123! !!MABlockAccessorTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testReferenceStream	"The class BlockContext is not serializeable, ignore this test."! !!MABlockAccessorTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testStore	"The class BlockContext is not serializeable, ignore this test."! !!MABlockAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self accessor write: 123 to: self.	self assert: self value = 123.	self accessor write: '123' to: self.	self assert: self value = '123'! !!MABlockAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWriteBlock	self accessor writeBlock: [ :model :object |		self assert: model = self.		self assert: object = 123 ].	self accessor write: 123 to: self! !!MAChainAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAChainAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	^ self actualClass selectors: #( holder contents value )! !!MAChainAccessorTest methodsFor: 'private' stamp: 'lr 5/15/2006 20:49'!actualClass	^ MAChainAccessor! !!MAChainAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!holder	^ ValueHolder new		contents: self;		yourself! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testAccessor	self accessor accessor: self.	self assert: self accessor accessor = self! !!MAChainAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self assert: (self accessor canRead: self).	self accessor next next readSelector: #zork.	self deny: (self accessor canRead: self)! !!MAChainAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self assert: (self accessor canWrite: self).	self accessor next next writeSelector: #zork.	self deny: (self accessor canWrite: self)! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 5/15/2006 20:51'!testKind	self assert: (self accessor class = MAChainAccessor).	self assert: (self accessor accessor class = MASelectorAccessor).	self assert: (self accessor next class = MAChainAccessor).	self assert: (self accessor next accessor class = MASelectorAccessor).	self assert: (self accessor next next class = MASelectorAccessor)! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testNext	self accessor next: self.	self assert: self accessor next = self! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testRead	self value: 123.	self assert: (self accessor read: self) = 123.	self value: '12'.	self assert: (self accessor read: self) = '12'! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testSelector	self assert: self accessor accessor selector = #holder.	self assert: self accessor next accessor selector = #contents.	self assert: self accessor next next selector = #value! !!MAChainAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self accessor write: 123 to: self.	self assert: self value = 123.	self accessor write: '123' to: self.	self assert: self value = '123'! !!MAContainerAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAContainerAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	^ self actualClass new! !!MAContainerAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAContainerAccessor! !!MAContainerAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self assert: (self accessor canRead: self)! !!MAContainerAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self deny: (self accessor canWrite: self)! !!MAContainerAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testRead	self assert: (self accessor read: 123) = 123! !!MAContainerAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self		should: [ self accessor write: 123 to: self ]		raise: Error.	self assert: self value isNil! !!MADictionaryAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MADictionaryAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	^ self actualClass key: #value! !!MADictionaryAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MADictionaryAccessor! !!MADictionaryAccessorTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!at: aKey	self assert: aKey = #value.	^ value! !!MADictionaryAccessorTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!at: aKey put: aValue	self assert: aKey = #value.	^ value := aValue! !!MADictionaryAccessorTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!includesKey: aKey	^ aKey = #value! !!MADictionaryAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self assert: (self accessor canRead: self).	self accessor key: #zork.	self deny: (self accessor canRead: self)! !!MADictionaryAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self assert: (self accessor canWrite: self)! !!MADictionaryAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testKey	self accessor key: #other.	self assert: self accessor key = #other! !!MADictionaryAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testRead	self value: 123.	self assert: (self accessor read: self) = 123.	self value: '12'.	self assert: (self accessor read: self) = '12'! !!MADictionaryAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self accessor write: 123 to: self.	self assert: self value = 123.	self accessor write: '123' to: self.	self assert: self value = '123'! !!MANullAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MANullAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!accessorInstance	^ self actualClass new! !!MANullAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MANullAccessor! !!MANullAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanRead	self deny: (self accessor canRead: self)! !!MANullAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testCanWrite	self deny: (self accessor canWrite: nil)! !!MANullAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testRead	self		should: [ self accessor read: self ]		raise: Error! !!MANullAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWrite	self		should: [ self accessor write: 123 to: self ]		raise: Error.	self assert: self value isNil! !!MAAutoSelectorAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAAutoSelectorAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAAutoSelectorAccessor! !!MAAutoSelectorAccessorTest methodsFor: 'running' stamp: 'lr 6/15/2006 08:58'!runCase	SystemChangeNotifier uniqueInstance doSilently: [ super runCase ]! !!MAAutoSelectorAccessorTest methodsFor: 'running' stamp: 'lr 3/21/2006 20:01'!tearDown	super tearDown.	" remove methods and category "	(self class organization listAtCategoryNamed: self accessor categoryName)		do: [ :each | self class removeSelector: each ].	self class organization removeCategory: self accessor categoryName.	" remove instance variables "	self class instVarNames		do: [ :each | self class removeInstVarName: each ]! !!MAAutoSelectorAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testReadFirst	self accessor selector: #foo.	self assert: (self accessor read: self) isNil.	self accessor write: 123 to: self.	self assert: (self accessor read: self) = 123! !!MAAutoSelectorAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testWriteFirst	self accessor selector: #foo.	self accessor write: 123 to: self.	self assert: (self accessor read: self) = 123! !!MASelectorAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MASelectorAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!accessorInstance	^ self actualClass selector: #value! !!MASelectorAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MASelectorAccessor! !!MASelectorAccessorTest methodsFor: 'accessing' stamp: 'lr 6/15/2006 08:52'!target	^ self! !!MASelectorAccessorTest methodsFor: 'testing-testing' stamp: 'lr 6/15/2006 08:53'!testCanRead	self assert: (self accessor canRead: self target).	self accessor readSelector: #zork.	self deny: (self accessor canRead: self target).	self accessor readSelector: nil.	self deny: (self accessor canRead: self target)! !!MASelectorAccessorTest methodsFor: 'testing-testing' stamp: 'lr 6/15/2006 08:53'!testCanWrite	self assert: (self accessor canWrite: self target).	self accessor writeSelector: #zork:.	self deny: (self accessor canWrite: self target).	self accessor writeSelector: nil.	self deny: (self accessor canWrite: self target)! !!MASelectorAccessorTest methodsFor: 'testing' stamp: 'lr 6/15/2006 08:52'!testRead	self target value: 123.	self assert: (self accessor read: self target) = 123.	self target value: '12'.	self assert: (self accessor read: self target) = '12'! !!MASelectorAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testReadSelector	self accessor readSelector: #contents.	self assert: self accessor selector = #contents.	self assert: self accessor readSelector = #contents.	self assert: self accessor writeSelector = #value:! !!MASelectorAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testSelector	self accessor selector: #contents.	self assert: self accessor selector = #contents.	self assert: self accessor readSelector = #contents.	self assert: self accessor writeSelector = #contents:! !!MASelectorAccessorTest methodsFor: 'testing' stamp: 'lr 6/15/2006 08:52'!testWrite	self accessor write: 123 to: self target.	self assert: self target value = 123.	self accessor write: '123' to: self target.	self assert: self target value = '123'! !!MASelectorAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testWriteSelector	self accessor writeSelector: #contents:.	self assert: self accessor selector = #value.	self assert: self accessor readSelector = #value.	self assert: self accessor writeSelector = #contents:! !!MAVariableAccessorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAVariableAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!accessorInstance	^ self actualClass name: 'value'! !!MAVariableAccessorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAVariableAccessor! !!MAVariableAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:35'!testCanRead	self assert: (self accessor canRead: self).	self accessor name: 'zork'.	self deny: (self accessor canRead: self)! !!MAVariableAccessorTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:35'!testCanWrite	self assert: (self accessor canWrite: self).	self accessor name: 'zork'.	self deny: (self accessor canWrite: self)! !!MAVariableAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testName	self accessor name: 'other'.	self assert: self accessor name = 'other'! !!MAVariableAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testRead	self value: 123.	self assert: (self accessor read: self) = 123.	self value: '12'.	self assert: (self accessor read: self) = '12'! !!MAVariableAccessorTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testWrite	self accessor write: 123 to: self.	self assert: self value = 123.	self accessor write: '123' to: self.	self assert: self value = '123'! !!MAAllConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAAllConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAAllCondition! !!MAAllConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testAll	self assert: (self condition & self true) class = MAAllCondition.	self assert: (self condition & self false) conditions first = self false! !!MAAllConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testBinary	self satisfies: self true & self true.	self fails: self true & self false.	self fails: self false & self true.	self fails: self false & self false! !!MAAllConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testEmpty	self satisfies: self condition! !!MAAllConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testUnary	self satisfies: self condition & self true.	self fails: self condition & self false! !!MAAnyConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAAnyConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAAnyCondition! !!MAAnyConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testAny	self assert: (self condition | self true) class = MAAnyCondition.	self assert: (self condition | self false) conditions first = self false! !!MAAnyConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testBinary	self satisfies: self true | self true.	self satisfies: self true | self false.	self satisfies: self false | self true.	self fails: self false | self false! !!MAAnyConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testEmpty	self fails: self condition! !!MAAnyConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testUnary	self satisfies: self condition | self true.	self fails: self condition | self false! !!MAComposedConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAComposedConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAComposedCondition! !!MAComposedConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testIsComposed	self assert: self condition isComposed! !!MANoneConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MANoneConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MANoneCondition! !!MANoneConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testBinary	self fails: self true !! self true.	self fails: self true !! self false.	self fails: self false !! self true.	self satisfies: self false !! self false! !!MANoneConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testEmpty	self satisfies: self condition! !!MANoneConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testNone	self assert: (self condition !! self true) class = MANoneCondition.	self assert: (self condition !! self false) conditions first = self false! !!MANoneConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testUnary	self fails: self condition !! self true.	self satisfies: self condition !! self false! !!MAConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MACondition! !!MAConditionTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!condition	^ condition! !!MAConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!conditionInstance	^ self actualClass new! !!MAConditionTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:34'!fails: aCondition	self deny: (aCondition value: self)! !!MAConditionTest methodsFor: 'constants' stamp: 'lr 3/9/2006 11:34'!false	^ MAFalseCondition new! !!MAConditionTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!instance	^ condition! !!MAConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!queryString	^ 'foo bar'! !!MAConditionTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:34'!satisfies: aCondition	self assert: (aCondition value: self)! !!MAConditionTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:34'!setUp	super setUp.	condition := self conditionInstance! !!MAConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testAll	self assert: (self condition & self true) class = MAAllCondition.	self assert: (self condition & self false) conditions first = self condition.	self assert: (self condition & self false) conditions second = self false! !!MAConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testAny	self assert: (self condition | self true) class = MAAnyCondition.	self assert: (self condition | self false) conditions first = self condition.	self assert: (self condition | self false) conditions second = self false! !!MAConditionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsComposed	self deny: self condition isComposed! !!MAConditionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsCondition	self assert: self instance isCondition! !!MAConditionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsConstant	self deny: self condition isConstant! !!MAConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testNone	self assert: (self condition !! self true) class = MANoneCondition.	self assert: (self condition !! self false) conditions first = self condition.	self assert: (self condition !! self false) conditions second = self false! !!MAConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testNot	self assert: self condition not class = MANoneCondition.	self assert: self condition not conditions first = self condition! !!MAConditionTest methodsFor: 'constants' stamp: 'lr 3/9/2006 11:34'!true	^ MATrueCondition new! !!MAConstantConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAConstantConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAConstantCondition! !!MAConstantConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testIsConstant	self assert: self condition isConstant! !!MAFalseConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAFalseConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAFalseCondition! !!MAFalseConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testAll	self assert: (self condition & self true) = self false.	self assert: (self condition & self false) = self false! !!MAFalseConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testAny	self assert: (self condition | self true) = self true.	self assert: (self condition | self false) = self false! !!MAFalseConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testFalse	self fails: self condition! !!MAFalseConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testNot	self assert: self condition not = self true! !!MATrueConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MATrueConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MATrueCondition! !!MATrueConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:35'!testAll	self assert: (self condition & self true) = self true.	self assert: (self condition & self false) = self false! !!MATrueConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:35'!testAny	self assert: (self condition | self true) = self true.	self assert: (self condition | self false) = self true! !!MATrueConditionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:35'!testNot	self assert: self condition not = self false! !!MATrueConditionTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testTrue	self satisfies: self condition! !!MAPluggableConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAPluggableConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MASelectorCondition! !!MASelectorConditionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MASelectorConditionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MASelectorCondition! !!MAContainerTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAContainerTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAContainer! !!MAContainerTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!child1	^ MAStringDescription selector: #child1 label: 'child1' priority: 1! !!MAContainerTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!child2	^ MANumberDescription selector: #child2 label: 'child2' priority: 2! !!MAContainerTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!child3	^ MAClassDescription selector: #child3 label: 'child3' priority: 3! !!MAContainerTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:34'!testAdd	self description add: self child1.	self assert: (self description size = 1).	self assert: (self description includes: self child1).	self description add: self child2.	self assert: (self description size = 2).	self assert: (self description includes: self child1).	self assert: (self description includes: self child2)! !!MAContainerTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:34'!testAddAll	self description		addAll: (Array with: self child1 with: self child2).	self assert: (self description size = 2).	self assert: (self description includes: self child1).	self assert: (self description includes: self child2)! !!MAContainerTest methodsFor: 'testing-converting' stamp: 'lr 3/9/2006 11:34'!testAsContainer	self assert: self description asContainer = self description.	self assert: self description asContainer == self description! !!MAContainerTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testChildren	self assert: self description children isCollection.	self assert: self description children isEmpty! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/21/2006 20:01'!testCollect	| collected |	self description add: self child1; add: self child2.	collected := self description collect: [ :each | each ].	self assert: self description = collected.	self deny: self description == collected.	collected := self description collect: [ :each | each copy ].	self assert: self description = collected.	self deny: self description == collected.	collected := self description collect: [ :each |		each copy			accessor: (MASelectorAccessor selector: #foo);			yourself ].	self deny: self description = collected.	self deny: self description == collected! !!MAContainerTest methodsFor: 'testing-operators' stamp: 'lr 3/21/2006 18:43'!testConcatenate	| concatenate |	concatenate := self child1 , self child2.	self assert: concatenate size = 2.	self assert: concatenate children first = self child1.	self assert: concatenate children second = self child2.	concatenate := self child1 , self child2 , self child3.	self assert: concatenate size = 3.	self assert: concatenate children first = self child1.	self assert: concatenate children second = self child2.	self assert: concatenate children third = self child3! !!MAContainerTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopy	self description add: self child1; add: self child2.	super testCopy.	self deny: self description copy children == self description children.	self assert: self description copy children first = self description children first.	self assert: self description copy children second = self description children second! !!MAContainerTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopyEmpty	self description add: self child1; add: self child2.	self assert: self description copyEmpty isEmpty! !!MAContainerTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopyFromTo	| copied |	self description add: self child1; add: self child2; add: self child3.	copied := self description copyFrom: 2 to: 3.	self assert: copied ~= self description.	self assert: copied size = 2.	self assert: copied children first = self child2.	self assert: copied children second = self child3! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testDetect	self description add: self child1.	self assert: (self description		detect: [ :each | self child1 = each ]) = self child1.	self should: [ self description		detect: [ :each | self child2 = each ] ] raise: Error! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testDetectIfNone	self description add: self child1.	self assert: (self description		detect: [ :each | self child1 = each ]		ifNone: [ 123 ]) = self child1.	self assert: (self description		detect: [ :each | self child2 = each ]		ifNone: [ 123 ]) = 123! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testDo	| collection |	collection := self description class defaultCollection.	self description add: self child1; add: self child2.	self description do: [ :each | collection add: each ].	self assert: (self description children hasEqualElements: collection)! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testDoSepratedBy	| collection |	collection := OrderedCollection new.	self description add: self child1; add: self child2.	self description		do: [ :each | collection add: each ]		separatedBy: [ collection add: nil ].	self assert: collection size = 3.	self assert: collection first = self child1.	self assert: collection second isNil.	self assert: collection third = self child2! !!MAContainerTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testEmpty	self assert: self description isEmpty.	self description add: self child1.	self deny: self description isEmpty! !!MAContainerTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testHasChildren	super testHasChildren.	self description add: self child1.	self assert: self description hasChildren! !!MAContainerTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIncludes	self deny: (self description includes: self child1).	self description add: self child1.	self assert: (self description includes: self child1)! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testInjectInto	self description add: self child1; add: self child2.	self assert: (self description		inject: 'start'		into: [ :result :each | result , ' ' , each label ]) = 'start child1 child2'! !!MAContainerTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testIntersection	| a b union |	a := self child1 , self child2.	b := self child2 , self child3.	union := a intersection: b.	self assert: (union size) = 1.	self deny: (union includes: self child1).	self assert: (union includes: self child2).	self deny: (union includes: self child3)! !!MAContainerTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsContainer	self assert: self description isContainer! !!MAContainerTest methodsFor: 'testing-moving' stamp: 'lr 3/9/2006 11:34'!testMoveDown	self description add: self child1; add: self child2.	self assert: self description children first = self child1.	self assert: self description children second = self child2.	self description moveDown: self child1.	self assert: self description children first = self child2.	self assert: self description children second = self child1.	self description moveDown: self child1.	self assert: self description children first = self child2.	self assert: self description children second = self child1! !!MAContainerTest methodsFor: 'testing-moving' stamp: 'lr 3/9/2006 11:34'!testMoveUp	self description add: self child1; add: self child2.	self assert: self description children first = self child1.	self assert: self description children second = self child2.	self description moveUp: self child2.	self assert: self description children first = self child2.	self assert: self description children second = self child1.	self description moveUp: self child2.	self assert: self description children first = self child2.	self assert: self description children second = self child1! !!MAContainerTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testNotEmpty	self deny: self description notEmpty.	self description add: self child1.	self assert: self description notEmpty! !!MAContainerTest methodsFor: 'testing-indentity' stamp: 'lr 3/9/2006 11:34'!testReferenceStream	| object |	self description add: self child1; add: self child2.	object := super testReferenceStream.	self assert: object children first = self child1.	self deny: object children first == self child1.	self assert: object children second = self child2.	self deny: object children second == self child2! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testReject	| rejected |	self description add: self child1; add: self child2.	rejected := self description reject: [ :each | false ].	self assert: self description = rejected.	rejected := self description reject: [ :each | true ].	self assert: rejected isEmpty! !!MAContainerTest methodsFor: 'testing-removing' stamp: 'lr 3/9/2006 11:34'!testRemove	self description add: self child1; add: self child2.	self description remove: self child1.	self assert: self description size = 1.	self deny: (self description includes: self child1).	self assert: (self description includes: self child2).	self description remove: self child2.	self assert: self description isEmpty! !!MAContainerTest methodsFor: 'testing-removing' stamp: 'lr 3/9/2006 11:34'!testRemoveAll	self description add: self child1; add: self child2.	self description removeAll.	self assert: self description isEmpty! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testSelect	| selected |	self description add: self child1; add: self child2.	selected := self description select: [ :each | true ].	self assert: self description = selected.	selected := self description select: [ :each | false ].	self assert: selected isEmpty! !!MAContainerTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testSize	self assert: self description size isZero.	self description add: self child1.	self assert: self description size = 1.	self description add: self child2.	self assert: self description size = 2.	self description add: self child3.	self assert: self description size = 3! !!MAContainerTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testUnion	| a b union |	a := self child1 , self child2.	b := self child2 , self child3.	union := a union: b.	self assert: (union size) = 3.	self assert: (union includes: self child1).	self assert: (union includes: self child2).	self assert: (union includes: self child3)! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testWithDo	self description add: self child1; add: self child2.	self description with: self description children		do: [ :first :second | self assert: first = second ]! !!MAContainerTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:34'!testWithIndexDo	self description add: self child1; add: self child2.	self description withIndexDo: [ :each :index |		index = 1			ifTrue: [ self assert: self child1 = each ]			ifFalse: [				index = 2					ifTrue: [ self assert: self child2 = each ]					ifFalse: [ self assert: false ] ] ]! !!MAPriorityContainerTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAPriorityContainerTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAPriorityContainer! !!MAPriorityContainerTest methodsFor: 'testing-moving' stamp: 'lr 3/9/2006 11:35'!testMoveDown	self should: [ super testMoveDown ] raise: Error! !!MAPriorityContainerTest methodsFor: 'testing-moving' stamp: 'lr 3/9/2006 11:35'!testMoveUp	self should: [ super testMoveUp ] raise: Error! !!MADescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MADescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!shouldInheritSelectors	^ true! !!MADescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MADescription! !!MADescriptionTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!description	^ description! !!MADescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!descriptionInstance	^ (self actualClass new)		accessor: MANullAccessor new;		yourself! !!MADescriptionTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!instance	^ description! !!MADescriptionTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:34'!setUp	super setUp.	description := self descriptionInstance! !!MADescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testAccessor	self description accessor: (MASelectorAccessor selector: #foo).	self assert: self description accessor selector = #foo! !!MADescriptionTest methodsFor: 'testing-converting' stamp: 'lr 3/9/2006 11:34'!testAsContainer	self subclassResponsibility! !!MADescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testComment	self description comment: 'bar'.	self assert: self description comment = 'bar'! !!MADescriptionTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopyAccessor	self assert: self description copy accessor = self description accessor.	self deny: self description copy accessor == self description accessor! !!MADescriptionTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testDictionaryKey	| dictionary |	dictionary := Dictionary new.	dictionary at: self instance put: 1.	self assert: (dictionary at: self instance) = 1.	dictionary at: self instance put: 2.	self assert: (dictionary at: self instance) = 2! !!MADescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testHasChildren	self deny: self description hasChildren! !!MADescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testHasComment	self description comment: nil.	self deny: self description hasComment.	self description comment: ''.	self deny: self description hasComment.	self description comment: 'comment'.	self assert:  self description hasComment! !!MADescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testHasLabel	self description label: nil.	self deny: self description hasLabel.	self description label: ''.	self deny: self description hasLabel.	self description label: 'label'.	self assert:  self description hasLabel! !!MADescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsContainer	self deny: self description isContainer! !!MADescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsDescription	self assert: self description isDescription! !!MADescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testLabel	self description label: 'foo'.	self assert: self description label = 'foo'! !!MADescriptionTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testPersistent	self description beEphemeral.	self deny: self description persistent.	self deny: self description isPersistent.	self description bePersistent.	self assert: self description persistent.	self assert: self description isPersistent! !!MADescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testPriority	self description priority: 123.	self assert: self description priority = 123! !!MADescriptionTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testReadonly	self description beReadonly.	self assert: self description readonly.	self assert: self description isReadonly.	self description beWriteable.	self deny: self description readonly.	self deny: self description isReadonly! !!MADescriptionTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testRequired	self description beRequired.	self assert: self description required.	self assert: self description isRequired.	self description beOptional.	self deny: self description required.	self deny: self description isRequired! !!MADescriptionTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testSetElement	| set |	set := Set new.	set add: self instance.	self assert: set size = 1.	self assert: (set includes: self instance).	set add: self instance.	self assert: set size = 1.	self assert: (set includes: self instance)! !!MADescriptionTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testVisible	self description beHidden.	self deny: self description visible.	self deny: self description isVisible.	self description beVisible.	self assert: self description visible.	self assert: self description isVisible! !!MABooleanDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MABooleanDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MABooleanDescription! !!MABooleanDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ true! !!MAClassDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAClassDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAClassDescription! !!MAClassDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ String! !!MAClassDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!shouldSkipStringTests	^ true! !!MAColorDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAColorDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAColorDescription! !!MAColorDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ Color blue! !!MAElementDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAElementDescription! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!emptyInstance	^ String new! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	self subclassResponsibility! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstanceString	^ MAStringWriter write: self includedInstance description: self descriptionInstance! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!invalidInstance	^ Object new! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!nullInstance	^ nil! !!MAElementDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!shouldSkipStringTests	^ false! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testAddCondition	self description		addCondition: [ :value | value isNil ] asCondition.	self assert: self description conditions size = 1.	self assert: self description conditions first key isCondition.	self assert: self description conditions first value isString! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testAddConditionLabelled	self description		addCondition: [ :value | value isNil ] asCondition		labelled: 'ist net nil'.	self assert: self description conditions size = 1.	self assert: self description conditions first key isCondition.	self assert: self description conditions first value = 'ist net nil'! !!MAElementDescriptionTest methodsFor: 'testing-converting' stamp: 'lr 3/9/2006 11:34'!testAsContainer	self assert: (self description asContainer size) = 1.	self assert: (self description asContainer includes: self description)! !!MAElementDescriptionTest methodsFor: 'testing-operators' stamp: 'lr 3/9/2006 11:34'!testConcatenation	| child1 child2 concatenate |	child1 := self description copy.	child2 := self description copy.	concatenate := child1 , child2.	self assert: concatenate size = 2.	self assert: concatenate children first = child1.	self assert: concatenate children second = child2.	concatenate := child1 , concatenate.	self assert: concatenate size = 3.	self assert: concatenate children first = child1.	self assert: concatenate children second = child1.	self assert: concatenate children third = child2! !!MAElementDescriptionTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopy	super testCopy.	self assert: self description copy default = self description default! !!MAElementDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testDefault	self description default: self includedInstance.	self assert: self description default = self includedInstance! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testFromString	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		fromString: self includedInstanceString)			= self includedInstance.	self assert: (self description		fromString: self includedInstanceString		reader: self description stringReader)			= self includedInstance.	self assert: (self description		fromString: self includedInstanceString		reader: self description stringReader new)			= self includedInstance! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testFromStringCollection	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		fromStringCollection: (Array			with: self includedInstanceString			with: self includedInstanceString))				= (Array					with: self includedInstance					with: self includedInstance).	self assert: (self description		fromStringCollection: (Array			with: self includedInstanceString			with: self includedInstanceString)		reader: self description stringReader)				= (Array					with: self includedInstance					with: self includedInstance)! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testFromStringEvaluated	self shouldSkipStringTests ifTrue: [ ^ self ].	[ [ self description fromString: 'Notification signal.' ]		on: Notification do: [ :ntf | self assert: false ] ]		on: Error do: [ :err ]! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testFromStringNull	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		fromString: self emptyInstance) isNil.	self assert: (self description		fromString: self emptyInstance		reader: self description stringReader) isNil.	self assert: (self description		fromString: self emptyInstance		reader: self description stringReader new) isNil! !!MAElementDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testKind	self assert: (self includedInstance isKindOf: self description kind)! !!MAElementDescriptionTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testSatisfied	self assert: (self description isSatisfiedBy: self includedInstance).	self assert: (self description isSatisfiedBy: self nullInstance).	self deny: (self description isSatisfiedBy: self invalidInstance)! !!MAElementDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testStringReader	| object |	self description stringReader: (object := MAStringReader new).	self assert: self description stringReader = object! !!MAElementDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testStringWriter	| object |	self description stringWriter: (object := MAStringWriter new).	self assert: self description stringWriter = object! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testToString	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		toString: self includedInstance)			= self includedInstanceString.	self assert: (self description		toString: self includedInstance		writer: self description stringWriter)			= self includedInstanceString.	self assert: (self description		toString: self includedInstance		writer: self description stringWriter new)			= self includedInstanceString! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testToStringCollection	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		toStringCollection: (Array			with: self includedInstance			with: self includedInstance))				= (Array					with: self includedInstanceString					with: self includedInstanceString).	self assert: (self description		toStringCollection: (Array			with: self includedInstance			with: self includedInstance)		writer: self description stringWriter)			= (Array				with: self includedInstanceString				with: self includedInstanceString)! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testToStringFromString	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		fromString: (self description			toString: self includedInstance))				= self includedInstance.	self assert: (self description		fromString: (self description			toString: self includedInstance			writer: self description stringWriter)		reader: self description stringReader)				= self includedInstance.	self assert: (self description		fromString: (self description			toString: self includedInstance			writer: self description stringWriter new)		reader: self description stringReader new)				= self includedInstance! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/21/2006 18:43'!testToStringNull	self shouldSkipStringTests ifTrue: [ ^ self ].	self assert: (self description		toString: self nullInstance)			= self description undefined.	self assert: (self description		toString: self nullInstance		writer: self description stringWriter)			= self description undefined.	self assert: (self description		toString: self nullInstance		writer: self description stringWriter new)			= self description undefined! !!MAElementDescriptionTest methodsFor: 'testing-strings' stamp: 'lr 3/9/2006 11:34'!testToStringUndefined	self shouldSkipStringTests ifTrue: [ ^ self ].	self description undefined: 'n/a'.	self assert: (self description		toString: self nullInstance)			= 'n/a'.	self assert: (self description		toString: self nullInstance		writer: self description stringWriter)			= 'n/a'.	self assert: (self description		toString: self nullInstance		writer: self description stringWriter new)			= 'n/a'! !!MAElementDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testUndefined	self description undefined: 'nop'.	self assert: self description undefined = 'nop'! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testValidate	self description beRequired.	self		shouldnt: [ self description validate: self includedInstance ]		raise: MAValidationError.	self		should: [ self description validate: self invalidInstance ]		raise: MAKindError.	self		should: [ self description validate: self nullInstance ]		raise: MARequiredError! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testValidateConditions	"This test might fail for MADateDescriptionTest, since there is a bug in Squeak."	self description		addCondition: [ :value | value = self includedInstance ] asCondition		labelled: 'included instance test'.	self		shouldnt: [ self description validateConditions: self includedInstance ]		raise: MAConditionError.	self		should: [ self description validateConditions: self invalidInstance ]		raise: MAConditionError.	self description		addCondition: [ :value | value = self invalidInstance ] asCondition		labelled: 'invalid instance test'.	self		should: [ self description validateConditions: self includedInstance ]		raise: MAConditionError.	self		should: [ self description validateConditions: self invalidInstance ]		raise: MAConditionError! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testValidateKind	self		should: [ self description validateKind: self invalidInstance ]		raise: MAKindError.	self		shouldnt: [ self description validateKind: self includedInstance ]		raise: MAKindError! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testValidateRequired	self description beOptional.	self		shouldnt: [ self description validateRequired: self nullInstance ]		raise: MARequiredError.	self		shouldnt: [ self description validateRequired: self includedInstance ]		raise: MARequiredError.	self description beRequired.	self		should: [ self description validateRequired: self nullInstance ]		raise: MARequiredError.	self		shouldnt: [ self description validateRequired: self includedInstance ]		raise: MARequiredError! !!MAElementDescriptionTest methodsFor: 'testing-validation' stamp: 'lr 3/9/2006 11:34'!testValidateSpecific	self		shouldnt: [ self description validateSpecific: self includedInstance ]		raise: MARequiredError! !!MAFileDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAFileDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAFileDescription! !!MAFileDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ MAFileModel new		contents: 'Lukas Renggli';		filename: 'author.txt';		yourself! !!MAFileDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!shouldSkipStringTests	^ true! !!MADateDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MADateDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MADateDescription! !!MADateDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ Date newDay: 11 month: 6 year: 1980! !!MADateDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!maxInstance	^ Date newDay: 12 month: 6 year: 1980! !!MADateDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!minInstance	^ Date newDay: 10 month: 6 year: 1980! !!MADurationDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MADurationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MADurationDescription! !!MADurationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ Duration days: 1 hours: 2 minutes: 3 seconds: 4! !!MADurationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!maxInstance	^ Duration days: 2 hours: 2 minutes: 3 seconds: 4! !!MADurationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!minInstance	^ Duration days: 0 hours: 2 minutes: 3 seconds: 4! !!MAMagnitudeDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAMagnitudeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAMagnitudeDescription! !!MAMagnitudeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!maxInstance	self subclassResponsibility! !!MAMagnitudeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!minInstance	self subclassResponsibility! !!MAMagnitudeDescriptionTest methodsFor: 'testing' stamp: 'lr 3/21/2006 20:01'!testInfToInf	self assert: self description min isNil.	self assert: self description max isNil.	self assert: (self description isSatisfiedBy: self minInstance).	self assert: (self description isSatisfiedBy: self includedInstance).	self assert: (self description isSatisfiedBy: self maxInstance)! !!MAMagnitudeDescriptionTest methodsFor: 'testing' stamp: 'lr 3/21/2006 20:01'!testInfToVal	self description max: self includedInstance.	self assert: self description min isNil.	self assert: self description max = self includedInstance.	self assert: (self description isSatisfiedBy: self minInstance).	self assert: (self description isSatisfiedBy: self includedInstance).	self deny: (self description isSatisfiedBy: self maxInstance)! !!MAMagnitudeDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testMax	self description max: self maxInstance.	self assert: self description max = self maxInstance! !!MAMagnitudeDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testMin	self description min: self minInstance.	self assert: self description min = self minInstance! !!MAMagnitudeDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testMinMax	self description min: self minInstance max: self maxInstance.	self assert: self description min = self minInstance.	self assert: self description max = self maxInstance! !!MAMagnitudeDescriptionTest methodsFor: 'testing' stamp: 'lr 3/21/2006 20:01'!testValToInf	self description min: self includedInstance.	self assert: self description min = self includedInstance.	self assert: self description max isNil.	self deny: (self description isSatisfiedBy: self minInstance).	self assert: (self description isSatisfiedBy: self includedInstance).	self assert: (self description isSatisfiedBy: self maxInstance)! !!MAMagnitudeDescriptionTest methodsFor: 'testing' stamp: 'lr 3/21/2006 20:01'!testValToVal	self description min: self includedInstance.	self description max: self includedInstance.	self assert: self description min = self includedInstance.	self assert: self description max = self includedInstance.	self deny: (self description isSatisfiedBy: self minInstance).	self assert: (self description isSatisfiedBy: self includedInstance).	self deny: (self description isSatisfiedBy: self maxInstance)! !!MANumberDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MANumberDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MANumberDescription! !!MANumberDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ 2.7182! !!MANumberDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!maxInstance	^ 3.1415! !!MANumberDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!minInstance	^ 1.6180! !!MATimeDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MATimeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MATimeDescription! !!MATimeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ Time hour: 11 minute: 33 second: 12! !!MATimeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!maxInstance	^ Time hour: 12 minute: 33 second: 12! !!MATimeDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!minInstance	^ Time hour: 10 minute: 33 second: 12! !!MATimeStampDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MATimeStampDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MATimeStampDescription! !!MATimeStampDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ TimeStamp year: 1980 month: 6 day: 11 hour: 11 minute: 38 second: 12! !!MATimeStampDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!maxInstance	^ TimeStamp year: 1980 month: 6 day: 12 hour: 11 minute: 38 second: 12! !!MATimeStampDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!minInstance	^ TimeStamp year: 1980 month: 6 day: 10 hour: 11 minute: 38 second: 12! !!MAMultipleOptionDescriptionTest class methodsFor: 'accessing-default' stamp: 'lr 3/9/2006 11:35'!defaultUnique	^ false! !!MAMultipleOptionDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAMultipleOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAMultipleOptionDescription! !!MAMultipleOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ self optionInstances copyFrom: 1 to: 2! !!MAMultipleOptionDescriptionTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testOrdered	self description beOrdered.	self assert: self description isOrdered.	self assert: self description ordered.	self description beUnordered.	self deny: self description isOrdered.	self deny: self description ordered! !!MAMultipleOptionDescriptionTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testSorted	self description beDistinct.	self assert: self description isDistinct.	self assert: self description distinct.	self description beIndefinite.	self deny: self description isDistinct.	self deny: self description distinct! !!MAOptionDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAOptionDescription! !!MAOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!optionInstances	^ Array with: 'foo' with: 'bar' with: 'zork'! !!MAOptionDescriptionTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:34'!setUp	super setUp.	self description options: self optionInstances! !!MAOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testAllOptions	self description beRequired; beSorted; options: #( c b a ).	self assert: self description allOptions = #( a b c ).	self description beRequired; beUnsorted; options: #( c b a ).	self assert: self description allOptions = #( c b a )! !!MAOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testAllOptionsWithExisting	self description beRequired; options: #( a b c ).	self assert: (self description allOptionsWith: #a) = #( a b c )! !!MAOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testAllOptionsWithNil	self description beRequired; options: #( a b c ).	self assert: (self description allOptionsWith: nil) = #( a b c )! !!MAOptionDescriptionTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopyOptions	self deny: self description copy options == self description options.	self assert: self description copy options = self description options! !!MAOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testOptions	self description options: #( a b c ).	self assert: self description options = #( a b c )! !!MAOptionDescriptionTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:35'!testSorted	self description beSorted.	self assert: self description isSorted.	self assert: self description sorted.	self description beUnsorted.	self deny: self description isSorted.	self deny: self description sorted! !!MASingleOptionDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MASingleOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MASingleOptionDescription! !!MASingleOptionDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ self optionInstances first! !!MASingleOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testAllOptionsOptional	self description beOptional; beSorted; options: #( c b a ).	self assert: self description allOptions = #( nil a b c ).	self description beOptional; beUnsorted; options: #( c b a ).	self assert: self description allOptions = #( nil c b a )! !!MASingleOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 5/5/2006 19:37'!testAllOptionsWithExtensible	self description beRequired; beUnsorted; beLimited; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( c d a ).	self description beRequired; beUnsorted; beExtensible; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( c d a b ).	self description beRequired; beSorted; beLimited; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( a c d ).	self description beRequired; beSorted; beExtensible; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( a b c d )! !!MASingleOptionDescriptionTest methodsFor: 'testing-accessing' stamp: 'lr 5/5/2006 19:26'!testAllOptionsWithOptional	self description beOptional; beSorted; beExtensible; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( nil a b c d ).	self description beOptional; beSorted; beLimited; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( nil a c d ).	self description beOptional; beUnsorted; beExtensible; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( nil c d a b ).	self description beOptional; beUnsorted; beLimited; options: #( c d a ).	self assert: (self description allOptionsWith: #b) = #( nil c d a )! !!MASingleOptionDescriptionTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:35'!testExtensible	self description beExtensible.	self assert: self description isExtensible.	self assert: self description extensible.	self description beLimited.	self deny: self description isExtensible.	self deny: self description extensible! !!MAReferenceDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAReferenceDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAReferenceDescription! !!MAReferenceDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!referenceInstance	^ MAStringDescription null! !!MAReferenceDescriptionTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:35'!setUp	super setUp.	self description reference: self referenceInstance! !!MAReferenceDescriptionTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:35'!testCopyReference	self assert: self description copy reference = self description reference.	self deny: self description copy reference == self description reference! !!MARelationDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MARelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MARelationDescription! !!MARelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!addressInstance1	^ MAMockAddress new		street: 'Philosophenweg 5';		plz: 3007; place: 'Bern';		yourself! !!MARelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!addressInstance2	^ MAMockAddress new		street: 'In der Au';		plz: 8765; place: 'Engi';		yourself! !!MARelationDescriptionTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:35'!setUp	super setUp.	self description classes: (Array with: MAMockAddress)! !!MARelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!shouldSkipStringTests	^ true! !!MARelationDescriptionTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:35'!testCopyClasses	self assert: self description copy classes = self description classes.	self deny: self description copy classes == self description classes! !!MAToManyRelationDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAToManyRelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAToManyRelationDescription! !!MAToManyRelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ Array with: self addressInstance1 with: self addressInstance2! !!MAToManyRelationDescriptionTest methodsFor: 'testing-properties' stamp: 'dc 4/18/2006 09:20'!testDefinitive	self description beDefinitive.	self assert: self description isDefinitive.	self assert: self description definitive.	self description beModifiable.	self deny: self description isDefinitive.	self deny: self description definitive! !!MAToManyRelationDescriptionTest methodsFor: 'testing-properties' stamp: 'dc 4/18/2006 09:17'!testOrdered	self description beOrdered.	self assert: self description isOrdered.	self assert: self description ordered.	self description beUnordered.	self deny: self description isOrdered.	self deny: self description ordered! !!MAToManyRelationDescriptionTest methodsFor: 'testing-properties' stamp: 'dc 4/18/2006 09:19'!testSorted	self description beSorted.	self assert: self description isSorted.	self assert: self description sorted.	self description beUnsorted.	self deny: self description isSorted.	self deny: self description sorted! !!MAToOneRelationDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAToOneRelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAToOneRelationDescription! !!MAToOneRelationDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ self addressInstance1! !!MATableDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MATableDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MATableDescription! !!MATableDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ MATableModel rows: 3 columns: 3 contents: #( '1' '2' '3' '2' '4' '6' '3' '6' '9' )! !!MATableDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!shouldSkipStringTests	^ true! !!MATokenDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MATokenDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MATokenDescription! !!MATokenDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ #( 'foo' 'bar' )! !!MAMemoDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAMemoDescription! !!MAMemoDescriptionTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testLineCount	self description lineCount: 123.	self assert: self description lineCount = 123! !!MAPasswordDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAPasswordDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAPasswordDescription! !!MAStringDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAStringDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAStringDescription! !!MAStringDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ 'Lukas Renggli'! !!MAStringDescriptionTest methodsFor: 'testing-accessing' stamp: 'rjl 4/26/2006 20:50'!testAutoCompleteWith	self description autoCompleteWith: #(Jimi da man).	self assert: self description autoCompleteWith = #(Jimi da man).! !!MASymbolDescriptionTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MASymbolDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MASymbolDescription! !!MASymbolDescriptionTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!includedInstance	^ #magritte! !!MACachedMementoTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MACachedMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MACachedMemento! !!MACachedMementoTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testCache	self assert: self memento cache size = self description size! !!MACachedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testCommit	self write: self includedInstance.	self assert: self read = self includedInstance.	self assert: self value = self nullInstance.	self assert: self memento hasChanged.	self memento commit.	self assert: self read = self includedInstance.	self assert: self value = self includedInstance.	self deny: self memento hasChanged! !!MACachedMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:34'!testRead	self assert: self read = self defaultInstance.	self value: self includedInstance.	self assert: self read = self defaultInstance! !!MACachedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testReset	self value: self defaultInstance.	self write: self includedInstance.	self assert: self memento hasChanged.	self memento reset.	self assert: self read = self defaultInstance.	self assert: self value = self defaultInstance.	self deny: self memento hasChanged! !!MACachedMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:34'!testWrite	self write: self includedInstance.	self assert: self read = self includedInstance.	self assert: self value = self nullInstance.	self write: self defaultInstance.	self assert: self read = self defaultInstance.	self assert: self value = self nullInstance! !!MACheckedMementoTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MACheckedMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MACheckedMemento! !!MACheckedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testConflictCommit	self write: self includedInstance.	self assert: self read = self includedInstance.	self assert: self memento hasChanged.	self deny: self memento hasConflict.	self value: self otherInstance.	self assert: self read = self includedInstance.	self assert: self memento hasChanged.	self assert: self memento hasConflict.	self memento commit.	self assert: self read = self includedInstance.	self assert: self value = self includedInstance.	self deny: self memento hasChanged.	self deny: self memento hasConflict! !!MACheckedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testConflictReset	self write: self includedInstance.	self assert: self read = self includedInstance.	self assert: self memento hasChanged.	self deny: self memento hasConflict.	self value: self otherInstance.	self assert: self read = self includedInstance.	self assert: self memento hasChanged.	self assert: self memento hasConflict.	self memento reset.	self assert: self read = self otherInstance.	self assert: self value = self otherInstance.	self deny: self memento hasChanged.	self deny: self memento hasConflict! !!MACheckedMementoTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testOriginal	self assert: self memento original size = self description size! !!MACheckedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testValidateConflictCommit	self write: self includedInstance.	self shouldnt: [ self memento validate ] raise: MAValidationError.	self value: self otherInstance.	self should: [ self memento validate ] raise: MAValidationError.	self memento commit.	self shouldnt: [ self memento validate ] raise: MAValidationError! !!MACheckedMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testValidateConflictReset	self write: self includedInstance.	self shouldnt: [ self memento validate ] raise: MAValidationError.	self value: self otherInstance.	self should: [ self memento validate ] raise: MAValidationError.	self memento reset.	self shouldnt: [ self memento validate ] raise: MAValidationError! !!MAMementoTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAMemento! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!defaultInstance	^ 'Lukas Renggli'! !!MAMementoTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!description	^ description! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!descriptionInstance	^ MAContainer with: ((MAStringDescription selector: #value)		default: self defaultInstance;		yourself)! !!MAMementoTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!descriptionValue	^ self description children first! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!includedInstance	^ 'Rene Magritte'! !!MAMementoTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!instance	^ memento! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!invalidInstance	^ 31415! !!MAMementoTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!memento	^ memento! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!mementoInstance	^ self actualClass model: self modelInstance! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!modelInstance	^ self! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!nullInstance	^ nil! !!MAMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!otherInstance	^ 'Ursula Freitag'! !!MAMementoTest methodsFor: 'accessing-memento' stamp: 'lr 3/9/2006 11:34'!read	^ self memento readUsing: self descriptionValue! !!MAMementoTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:34'!setUp	super setUp.	description := self descriptionInstance.	memento := self mementoInstance! !!MAMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testCommit	self subclassResponsibility! !!MAMementoTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testDescription	self assert: self memento description = self description.	self assert: self memento description = self descriptionInstance! !!MAMementoTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:34'!testModel	self assert: self memento model = self modelInstance! !!MAMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:34'!testRead	self subclassResponsibility! !!MAMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testReset	self subclassResponsibility! !!MAMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testValidateIncluded	self write: self includedInstance.	self shouldnt: [ self memento validate ] raise: MAValidationError! !!MAMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testValidateInvalid	self write: self invalidInstance.	self should: [ self memento validate ] raise: MAValidationError! !!MAMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:34'!testValidateRequired	self descriptionValue beRequired.	self write: self nullInstance.	self should: [ self memento validate ] raise: MAValidationError! !!MAMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:34'!testWrite	self subclassResponsibility! !!MAMementoTest methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:34'!value	^ value! !!MAMementoTest methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:34'!value: anObject	value := anObject! !!MAMementoTest methodsFor: 'accessing-memento' stamp: 'lr 3/9/2006 11:34'!write: anObject	self memento write: anObject using: self descriptionValue! !!MAStraitMementoTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ false! !!MAStraitMementoTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:35'!actualClass	^ MAStraitMemento! !!MAStraitMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:35'!testCommit	self write: self includedInstance.	self assert: self value = self includedInstance.	self assert: self read = self includedInstance.	self memento commit.	self assert: self value = self includedInstance.	self assert: self read = self includedInstance! !!MAStraitMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:35'!testRead	self assert: self read = self defaultInstance.	self value: self includedInstance.	self assert: self read = self includedInstance.	self value: self defaultInstance.	self assert: self read = self defaultInstance! !!MAStraitMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:35'!testReset	self write: self includedInstance.	self memento reset.	self assert: self read = self includedInstance! !!MAStraitMementoTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:35'!testValidateRequired! !!MAStraitMementoTest methodsFor: 'testing-basic' stamp: 'lr 3/9/2006 11:35'!testWrite	self write: self includedInstance.	self assert: self value = self includedInstance.	self write: self defaultInstance.	self assert: self value = self defaultInstance.	self write: self nullInstance.	self assert: self value = self nullInstance! !!MAObjectTest class methodsFor: 'building' stamp: 'lr 3/9/2006 11:35'!buildTestClassFor: aClass	" self buildTestClassFor: MAObject "	| thisName thisClass thisCategory parentClass |	thisName := (aClass name , 'Test') asSymbol.	(thisName beginsWith: 'MA')		ifFalse: [ ^ self ].	thisClass := MACompatibility classNamed: thisName.	thisCategory := 'Magritte-Tests-' , (aClass category copyAfterLast: $-).	parentClass := self = thisClass		ifTrue: [ self superclass ]		ifFalse: [ Smalltalk classNamed: (aClass superclass name , 'Test') asSymbol ].	thisClass := parentClass		subclass: thisName		instanceVariableNames: (thisClass isNil			ifFalse: [ thisClass instanceVariablesString ]			ifTrue: [ String new ])			classVariableNames: ''			poolDictionaries: ''			category: thisCategory.	thisClass		compile: 'actualClass	^ ' , aClass name		classified: #private.	thisClass class		compile: 'isAbstract	^ ' , aClass isAbstract asString		classified: #testing.	aClass subclassesDo: [ :each | self buildTestClassFor: each ]! !!MAObjectTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!isAbstract	^ true! !!MAObjectTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!shouldInheritSelectors	^ true! !!MAObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!actualClass	^ MAObject! !!MAObjectTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!instance	self subclassResponsibility! !!MAObjectTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopy	self assert: self instance = self instance copy.	self deny: self instance == self instance copy! !!MAObjectTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:34'!testCopyProperties	self assert: self instance properties = self instance copy properties.	self deny: self instance properties == self instance copy properties! !!MAObjectTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:34'!testEqual	self assert: self instance = self instance.	self assert: self instance = self instance copy.	self assert: self instance copy = self instance.	self deny: self instance = 123.	self deny: self instance = String new! !!MAObjectTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:34'!testHash	self assert: self instance hash isInteger.	self assert: self instance hash = self instance hash.	self assert: self instance hash = self instance copy hash! !!MAObjectTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsAccessor	self deny: self instance isAccessor! !!MAObjectTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsCondition	self deny: self instance isCondition! !!MAObjectTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:34'!testIsDescription	self deny: self instance isDescription! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testProperties	self assert: self instance properties notNil.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo put: #bar.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsent: [ nil ].	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsentPut: [ #bar ].	self instance instVarNamed: 'properties' put: nil.	self instance hasProperty: #foo.	self instance instVarNamed: 'properties' put: nil! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testPropertiesAt	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self should: [ self instance propertyAt: #bar ] raise: Error! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testPropertiesAtIfAbsent	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsent: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsent: [ 'baz' ]) = 'baz'! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testPropertiesAtIfAbsentPut	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsentPut: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsentPut: [ 'baz' ]) = 'baz'.	self assert: (self instance propertyAt: #bar) = 'baz'! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testPropertiesAtPut	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self instance propertyAt: #foo put: 'baz'.	self assert: (self instance propertyAt: #foo) = 'baz'! !!MAObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:34'!testPropertiesHas	self deny: (self instance hasProperty: #foo).	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance hasProperty: #foo).	self deny: (self instance hasProperty: #bar)! !!MAObjectTest methodsFor: 'testing-identity' stamp: 'lr 3/9/2006 11:34'!testReferenceStream	" This is an unfortunately non-portable test-method: the idea of this test is that every object should be serializeable and after restoring it, the objects should be still equal. "	| output input object |	" every instance should be serializeable "	output := MACompatibility referenceStream: ByteArray new writeStream.	output nextPut: self instance.	output close.	" read back the serialized instance "	input := MACompatibility referenceStream: output contents readStream.	object := input next.	" different object reference, but equal object "	self deny: self instance == object.	self assert: self instance = object.	" return the read in object (for addinal checks in subclasses) "	^ object! !!MAObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!testSanity	"If this test case fails, there is something wrong with the setup of the test-case."	self		assert: self actualClass isAbstract not		description: 'Unable to test abstract class.'.	self		assert: self instance class = self actualClass		description: 'Invalid test instance.'! !!MATableModelTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:35'!setUp	table := (MATableModel rows: 3 columns: 4)		collect: [ :row :col :value | row raisedTo: col ]! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/21/2006 20:04'!testAtAt	self assert: (table at: 1 at: 1) = 1.	self assert: (table at: 2 at: 3) = 8.	self assert: (table at: 3 at: 2) = 9.	self assert: (table at: 3 at: 4) = 81! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testAtAtAbsent	self should: [ table at: 0 at: 1 ] raise: Error.	self should: [ table at: 1 at: 0 ] raise: Error.	self should: [ table at: 4 at: 4 ] raise: Error.	self should: [ table at: 3 at: 5 ] raise: Error! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testAtAtPut	self assert: (table at: 1 at: 1 put: -1) = -1.	self assert: (table at: 2 at: 3 put: -8) = -8.	self assert: (table at: 3 at: 2 put: -9) = -9.	self assert: (table at: 3 at: 4 put: -81) = -81.	self assert: (table at: 1 at: 1) = -1.	self assert: (table at: 2 at: 3) = -8.	self assert: (table at: 3 at: 2) = -9.	self assert: (table at: 3 at: 4) = -81! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testAtAtPutAbsent	self should: [ table at: 0 at: 1 put: 0 ] raise: Error.	self should: [ table at: 1 at: 0 put: 0 ] raise: Error.	self should: [ table at: 4 at: 4 put: 0 ] raise: Error.	self should: [ table at: 3 at: 5 put: 0 ] raise: Error! !!MATableModelTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:35'!testCollect	table := table collect: [ :row :col :val | row + col + val ].	table do: [ :row :col :val | self assert: (row raisedTo: col) = (val - row - col) ]! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testContents	self assert: table contents = #( 1 1 1 1 2 4 8 16 3 9 27 81 )! !!MATableModelTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:35'!testCopy	self assert: table copy rowCount = table rowCount.	self assert: table copy columnCount = table columnCount.	self assert: table copy contents = table contents.	self deny: table copy contents == table contents! !!MATableModelTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:35'!testCopyEmpty	self assert: table copyEmpty rowCount = table rowCount.	self assert: table copyEmpty columnCount = table columnCount.	self assert: (table copyEmpty contents allSatisfy: [ :each | each isNil ])! !!MATableModelTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:35'!testCopyRowsColumns	self assert: (table copyRows: 1 columns: 2) rowCount = 1.	self assert: (table copyRows: 1 columns: 2) columnCount = 2.	self assert: (table copyRows: 1 columns: 2) contents = #(1 1).	self assert: (table copyRows: 4 columns: 3) rowCount = 4.	self assert: (table copyRows: 4 columns: 3) columnCount = 3.	self assert: (table copyRows: 4 columns: 3) contents = #(1 1 1 2 4 8 3 9 27 nil nil nil)! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testCoumnCount	self assert: table columnCount = 4! !!MATableModelTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:35'!testDo	table do: [ :row :col :val | self assert: (row raisedTo: col) = val ]! !!MATableModelTest methodsFor: 'testing-comparing' stamp: 'lr 3/21/2006 18:43'!testEqual	self assert: table = table.	self assert: table = table copy.	self assert: table copy = table.	self assert: table copy = table copy.	self deny: table = (table copy at: 1 at: 2 put: 3).	self deny: table = (table copyRows: 3 columns: 3).	self deny: table = (table copyRows: 4 columns: 4)! !!MATableModelTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:35'!testHash	self assert: table hash = table hash.	self assert: table hash = table copy hash.	self assert: table copy hash = table hash.	self assert: table copy hash = table copy hash! !!MATableModelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:35'!testRowCount	self assert: table rowCount = 3! !!MATableModelTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:35'!testSetup	self assert: table rowCount = 3.	self assert: table columnCount = 4.	self assert: table contents = #( 1 1 1 1 2 4 8 16 3 9 27 81 )! !!TestCase methodsFor: '*magritte-tests' stamp: 'lr 3/9/2006 11:34'!should: aBlock raise: anExceptionalEvent do: aOneArgumentBlock	self assert: ([ aBlock value. false ]		sunitOn: anExceptionalEvent		do: [ :ex |			aOneArgumentBlock value: ex.			ex sunitExitWith: true ])! !!MAContainerMorph methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addButtons	self addButtons: #( save cancel )! !!MAContainerMorph methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addButtons: anArray	morph := self rectangleMorph		vResizing: #shrinkWrap;		addMorphBack: self morph;		addMorphBack: (self barMorph: anArray);		yourself! !!MAContainerMorph methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addWindow	morph := self windowMorph		model: self;		vResizing: #shrinkWrap;		addMorph: (self morph layoutInset: 5 @ 5)			frame: (0 @ 0 corner: 1 @ 1);		yourself! !!MAContainerMorph methodsFor: 'answering' stamp: 'lr 3/9/2006 11:33'!answer: anObject	answer ifNotNil: [ answer value: anObject ].	self morph delete! !!MAContainerMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildChildren	^ Array streamContents: [ :stream |		self description do: [ :each |			each isVisible ifTrue: [				stream nextPut: (each morphClass					memento: self memento					description: each					parent: self) ] ] ]! !!MAContainerMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphView	| result |	result := self rectangleMorph		setBalloonText: self description comment;		listDirection: #topToBottom;		cellInset: 3;		yourself.	self children do: [ :each |		result addMorphBack: each morph ].	^ result! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!callInHand	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInHand; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!callInWorld	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInWorld; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!cancel	self reset; answer: nil! !!MAContainerMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ children! !!MAContainerMorph methodsFor: 'answering' stamp: 'lr 3/9/2006 11:33'!onAnswer: aBlock	answer := aBlock! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!openInHand	^ self morph openInHand! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!openInWorld	^ self morph openInWorld! !!MAContainerMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!save	[ self validate ]		on: MAValidationError		do: [ :err | ^ self inform: err asString ].	self commit; answer: self model! !!MAContainerMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setChildren: aCollection	children := aCollection! !!MAContainerMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	super setDescription: aDescription.	self setChildren: self buildChildren! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!waitUntilClosed	[ self morph world notNil ]		whileTrue: [ self morph outermostWorldMorph doOneCycle ]! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!memento: aMemento	^ self memento: aMemento description: aMemento description! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!memento: aMemento description: aDescription	^ self memento: aMemento description: aDescription parent: nil! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!memento: aMemento description: aDescription parent: aComponent	^ self new		setMemento: aMemento;		setDescription: aDescription;		setParent: aComponent;		yourself! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!barMorph: anArray	| bar |	bar := self rectangleMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		listCentering: #center;		wrapCentering: #bottomRight;		cellInset: self defaultSpacerSize;		yourself.	anArray do: [ :selector |		bar addMorphBack: (self buttonMorph: selector) ].	^ bar! !!MADescriptionMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorph	^ self description isReadonly		ifTrue: [ self buildMorphView ]		ifFalse: [ self buildMorphEditor ]! !!MADescriptionMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ self buildMorphView! !!MADescriptionMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphView	self subclassResponsibility! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!buttonMorph: aSelector	| button |	button := PluggableButtonMorph		on: self		getState: #buttonState		action: aSelector.	button		label: aSelector;		shortcutCharacter: aSelector first;		onColor: Color transparent offColor: Color white;		useRoundedCorners;		borderWidth: 2;		borderColor: #raised.	^ button! !!MADescriptionMorph methodsFor: 'old' stamp: 'lr 3/9/2006 11:33'!buttonState	^ true! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!commit	self memento commit! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultBackgroundColor	^ self description morphColor! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultSpacerSize	^ 5! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!description	^ description! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!memento	^ memento! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!model	^ self memento model! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!morph	^ morph ifNil: [ morph := self buildMorph ]! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!parent	^ parent! !!MADescriptionMorph methodsFor: 'old' stamp: 'lr 3/9/2006 11:33'!perform: selector orSendTo: otherTarget	^ (self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ otherTarget perform: selector ]! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!rectangleMorph	^ RectangleMorph new		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		yourself! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!reset	self memento reset! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!root	^ self parent isNil		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	description := aDescription! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setMemento: aMemento	memento := aMemento! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setParent: aMorph	parent := aMorph! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!stringMorph	^ StringMorph new! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!validate	"Flushes the cached state of some morphic elements (such as text-morphs) to the memento and then does the validation. I don't know of a better flush the morphic contents (happy flickering), probably morphic is just too limited to customize that easily or I am too dumb to find out."	self morph allMorphsDo: [ :each |		(each respondsTo: #accept)			ifTrue: [ each accept ] ].	self memento validate! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!windowMorph	^ SystemWindow labelled: self description label! !!MACheckboxMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ checkbox := ThreePhaseButtonMorph checkBox		target: self;		actionSelector: #toggle;		state: self state;		yourself! !!MACheckboxMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!checkbox	^ checkbox! !!MACheckboxMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!state	^ (self value ifNil: [ self description default ])		ifTrue: [ #on ] ifFalse: [ #off ]! !!MACheckboxMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!toggle	self value: self value not.	self checkbox state: self state! !!MAElementMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorph	| result |	result := self rectangleMorph		layoutInset: 1 @ 1;		listDirection: #leftToRight;		addMorphBack: self buildMorphLabel;		addMorphBack: super buildMorph;		yourself.	self description hasComment		ifTrue: [ result setBalloonText: self description comment ].	self description isRequired		ifTrue: [ result addMorphBack: self buildMorphRequired ].	^ result! !!MAElementMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphLabel	^ self stringMorph		contents: self description label , ':';		width: 100;		yourself! !!MAElementMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphRequired	^ self stringMorph		contents: ' *';		color: Color red;		yourself! !!MAElementMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphView	^ self stringMorph		contents: self string;		yourself! !!MAElementMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!string	^ self description toString: self value! !!MAElementMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!string: aString	| value |	value := [ self description fromString: aString asString ]		ifError: [ aString ].	self value: value; changed: #string! !!MAElementMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value	^ self memento readUsing: self description! !!MAElementMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value: anObject	self memento write: anObject using: self description.	self changed: #value! !!MAFileMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ self buttonMorph: #choose! !!MAFileMorph methodsFor: 'actions' stamp: 'lr 3/21/2006 19:57'!choose	| stream |	stream := FileList2 modalFileSelector.	stream isNil ifTrue: [ ^ self ].	stream binary.	self value: (self description kind new		contents: stream contents;		filename: stream localName)! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!options	^ self description allOptions! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!strings	^ self options collect: [ :each | self description reference toString: each ]! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ (PluggableListMorphOfMany on: self list: #strings primarySelection: #selected changePrimarySelection: #selected: listSelection: #selectionAt: changeListSelection: #selectionAt:put: menu: nil)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 2;		yourself! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected	^ selected ifNil: [ selected := 0 ]! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected: anInteger	selected := anInteger.	self changed: #selected! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selectionAt: anInteger	^ self value includes: (self options at: anInteger)! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selectionAt: anInteger put: aBoolean	| option |	option := self options at: anInteger.	self value: (aBoolean		ifTrue: [ self value copyWith: option ]		ifFalse: [ self value copyWithout: option ]).	self changed: #selected! !!MASingleSelectListMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ (PluggableListMorph on: self list: #strings selected: #selected changeSelected: #selected:)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 2;		yourself! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected	^ self options indexOf: self value! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected: anInteger	self value: (self options at: anInteger ifAbsent: [ nil ]).	self changed: #selected! !!MAMemoMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!annotation	^ self string! !!MAMemoMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	"The selector #annotation should be #string instead, but we use this one and dispatch since this prevents morphic to draw a thin red border around changed fields. Stupid hack, really, but doesn't work otherwise."	^ (PluggableTextMorph on: self text: #annotation accept: #string:)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 2;		yourself! !!MAPasswordMorph methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildMorphEditor	^ super buildMorphEditor		font: (StrikeFont passwordFontSize: 12);		yourself! !!MATextMorph methodsFor: 'private' stamp: 'lr 3/21/2006 18:43'!buildMorphEditor	^ super buildMorphEditor		hideScrollBarsIndefinitely: true;		acceptOnCR: true;		height: 20;		yourself! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!copyWithAll: aCollection	^ (self species new: self size + aCollection size)		replaceFrom: 1 to: self size with: self startingAt: 1;		replaceFrom: self size + 1 to: self size + aCollection size with: aCollection startingAt: 1;		yourself! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!moveDown: anObject	| first second |	first := self indexOf: anObject ifAbsent: [ ^ 0 ].	second := first < self size ifTrue: [ first + 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!moveUp: anObject	| first second |	first := self indexOf: anObject ifAbsent: [ ^ 0 ].	second := first > 1 ifTrue: [ first - 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!reduce: aBlock	| result |	result := self first.	2 to: self size do: [ :index |		result := aBlock			value: result			value: (self at: index) ].	^ result! !!MAAdaptiveModel commentStamp: 'lr 6/2/2006 00:30' prior: 0!I am an adaptive model referencing a dynamic description of myself and a dictionary mapping those descriptions to actual values.!!MAAdaptiveModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!description: aDescription	^ self new		description: aDescription;		yourself! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDescription	^ MAContainer new! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDictionary	^ Dictionary new! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:13'!description	"Answer the description of the receiver."	^ description! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:12'!description: aDescription	description := aDescription! !!MAAdaptiveModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!initialize	super initialize.	self description: self defaultDescription.	self values: self defaultDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 5/17/2006 14:15'!readUsing: aDescription	"Answer the actual value of <code>aDescription</code> within the receiver, <code>nil</code> if not present."	^ self values at: aDescription ifAbsent: [ nil ]! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:14'!values	"Answer a dictionary mapping description to actual values."	^ values! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:12'!values: aDictionary	values := aDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 5/17/2006 14:16'!write: anObject using: aDescription	"Set <code>anObject</code> to be that actual value of the receiver for <code>aDescription</code>."	self values at: aDescription put: anObject! !!MAActionColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultTitle	^ String new! !!MAActionColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultUseLinks	^ true! !!MAActionColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellContent: anObject on: html	self useLinks		ifTrue: [ self renderCellLinkContent: anObject on: html ]		ifFalse: [ self renderCellFormContent: anObject on: html ]! !!MAActionColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellFormContent: anObject on: html	self subclassResponsibility! !!MAActionColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellLinkContent: anObject  on: html	self subclassResponsibility! !!MAActionColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!useLinks	^ self propertyAt: #useLinks ifAbsent: [ self defaultUseLinks ]! !!MAActionColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!useLinks: aBoolean	self propertyAt: #useLinks put: aBoolean! !!MACommandColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addCommand: aBlock text: aString	self commands add: aBlock -> aString! !!MACommandColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addCommandOn: anObject selector: aSelector	self addCommandOn: anObject selector: aSelector text: aSelector allButLast asCapitalizedPhrase! !!MACommandColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!addCommandOn: anObject selector: aSelector text: aString	self addCommand: (MessageSend receiver: anObject selector: aSelector) text: aString! !!MACommandColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!commands	^ commands! !!MACommandColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!commands: aCollection	commands := aCollection! !!MACommandColumn methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!initialize	super initialize.	self commands: OrderedCollection new! !!MACommandColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellFormContent: anObject on: html	self commands		do: [ :each |			html				submitButtonWithAction: [ each key value: anObject ]				text: each value ]		separatedBy: [ html space ]! !!MACommandColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellLinkContent: anObject on: html	self commands		do: [ :each |			html anchor				callback: [ each key value: anObject ];				text: each value ]		separatedBy: [ html space ]! !!MACheckboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFormDeselected	^ ScriptingSystem formAtKey: #CheckBoxOff! !!MACheckboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFormSelected	^ ScriptingSystem formAtKey: #CheckBoxOn! !!MACheckboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSelection	^ Set new! !!MACheckboxColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!deselect: anObject	self selection remove: anObject ifAbsent: nil! !!MACheckboxColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isSelected: anObject	^ self selection includes: anObject! !!MACheckboxColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellFormContent: anObject on: html	html		checkboxWithValue: (self isSelected: anObject)		callback: [ :value | self select: anObject value: value ]! !!MACheckboxColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!select: anObject	self selection add: anObject! !!MAOptionboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFormDeselected	^ ScriptingSystem formDictionary  formAtKey: #RadioButtonOff! !!MAOptionboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFormSelected	^ ScriptingSystem formAtKey: #RadioButtonOn! !!MAOptionboxColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSelection	^ nil! !!MAOptionboxColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!deselect: anObject	self selection: nil! !!MAOptionboxColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isSelected: anObject	^ self selection == anObject! !!MAOptionboxColumn methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!radioGroupFor: html	"This is a very bad thing, you might never have seen in your own life. Very strange things might happen here, but for now it mostly does what we need."	| renderer |	renderer := self propertyAt: #radioGroupRenderer ifAbsentPut: nil.	^ renderer == html		ifTrue: [ self propertyAt: #radioGroupCallback ]		ifFalse: [			self propertyAt: #radioGroupRenderer put: html.			self propertyAt: #radioGroupCallback put: html radioGroup ]! !!MAOptionboxColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellFormContent: anObject on: html	html		radioButtonInGroup: (self radioGroupFor: html)		selected: (self isSelected: anObject)		callback: [ self select: anObject ]! !!MAOptionboxColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!select: anObject	self selection: anObject! !!MASelectionColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultFormDeselected	self subclassResponsibility! !!MASelectionColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultFormSelected	self subclassResponsibility! !!MASelectionColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultSelection	self subclassResponsibility! !!MASelectionColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!deselect: anObject	self subclassResponsibility! !!MASelectionColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!formDeselected	^ self propertyAt: #formDeselected ifAbsent: [ self defaultFormDeselected ]! !!MASelectionColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!formDeselected: aForm	^ self propertyAt: #formDeselected put: aForm! !!MASelectionColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!formSelected	^ self propertyAt: #formSelected ifAbsent: [ self defaultFormSelected ]! !!MASelectionColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!formSelected: aForm	^ self propertyAt: #formSelected put: aForm! !!MASelectionColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isSelected: anObject	self subclassResponsibility! !!MASelectionColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!refresh	super refresh.	self selection: self defaultSelection! !!MASelectionColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderCellLinkContent: anObject on: html	| selected |	selected := self isSelected: anObject.	html		anchorWithAction: [ self select: anObject value: selected not ]		do: [			html imageWithForm: (selected				ifTrue: [ self formSelected ]				ifFalse: [ self formDeselected ]) ]! !!MASelectionColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!select: anObject	self subclassResponsibility! !!MASelectionColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!select: anObject value: aBoolean	aBoolean		ifTrue: [ self select: anObject ]		ifFalse: [ self deselect: anObject ]! !!MASelectionColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!selection	selection isNil		ifTrue: [ self selection: self defaultSelection ].	^ selection! !!MASelectionColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!selection: anObject	selection := anObject! !!MAColumn class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:34'!descriptionComment	^ MAStringDescription selector: #comment label: 'Comment' priority: 200! !!MAColumn class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:34'!descriptionTitle	^ MAStringDescription selector: #title label: 'Title' priority: 100! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!cascade	^ self propertyAt: #cascade ifAbsent: [ self defaultCascade ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!cascade: anArray	self propertyAt: #cascade put: anArray! !!MAColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!column	^ self report cache collect: [ :each | self valueFor: each ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!comment	^ self propertyAt: #comment ifAbsent: [ self defaultComment ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!comment: aString	self propertyAt: #comment put: aString! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultCascade	^ #( yourself )! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComment	^ nil! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultDownArrow	^ ScriptingSystem formAtKey: #DownArrow! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFooter	^ nil! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultFormat	^ MessageSend receiver: self selector: #renderCellContent:on:! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'nl 7/6/2006 08:40'!defaultSorter		^[ :a :b |		| x y |		(x := self valueFor: a) isNil			or: [ (y := self valueFor: b) notNil				and: [ x <= y ] ] ]! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultTitle	^ self cascade first asCapitalizedPhrase! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultUpArrow	^ ScriptingSystem formAtKey: #UpArrow! !!MAColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultVisible	^ true! !!MAColumn methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:33'!exportContent: anObject index: aNumber on: aStream	aStream nextPutAll: (anObject asString collect: [ :each |		each isSeparator			ifTrue: [ Character space ]			ifFalse: [ each ] ])! !!MAColumn methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:33'!exportHeadOn: aStream	self title isNil		ifFalse: [ aStream nextPutAll: self title ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!footer	^ self propertyAt: #footer ifAbsent: [ self defaultFooter ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!footer: aBlock	self propertyAt: #footer put: aBlock! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!format	^ self propertyAt: #format ifAbsent: [ self defaultFormat ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!format: aBlock	self propertyAt: #format put: aBlock! !!MAColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!index	^ self report columns indexOf: self! !!MAColumn methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!initialize	super initialize.	properties := Dictionary new! !!MAColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isReversed	^ self report sortReversed! !!MAColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isSortable	^ self report sortEnabled		and: [ self sorter notNil ]! !!MAColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isSorted	^ self report sortColumn = self! !!MAColumn methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isVisible	^ self visible! !!MAColumn methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!properties	^ properties! !!MAColumn methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!propertyAt: aSymbol	^ self properties at: aSymbol! !!MAColumn methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!propertyAt: aSymbol ifAbsent: aBlock	^ self properties at: aSymbol ifAbsent: aBlock! !!MAColumn methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!propertyAt: aSymbol ifAbsentPut: aBlock	^ self properties at: aSymbol ifAbsentPut: aBlock! !!MAColumn methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!propertyAt: aSymbol put: anObject	^ self properties at: aSymbol put: anObject! !!MAColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!refresh! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCell: anObject on: html	html tableData with: [		self format in: [ :format |			format numArgs = 1				ifTrue: [ html render: (format value: anObject) ]				ifFalse: [					format numArgs = 2						ifTrue: [ format valueWithArguments: (Array with: anObject with: html) ]						ifFalse: [ self error: 'Invalid renderer block' ] ] ] ]! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellContent: anObject on: html	html render: (self valueFor: anObject)! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderFootCellOn: html	html tableData with: [ self renderFootContentOn: html ]! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderFootContentOn: html	self footer isNil		ifFalse: [ html render: self footer ]! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderHeadCellOn: html	html tableData		tooltip: self comment;		with: [			self isSortable				ifFalse: [ self renderHeadContentOn: html ]				ifTrue: [					html anchor						callback: [ self report sort: self ];						with: [							self renderHeadContentOn: html.							self renderHeadSorterOn: html ] ] ]! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderHeadContentOn: html	html render: self title! !!MAColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderHeadSorterOn: html	self isSorted ifTrue: [		html image form: (self isReversed			ifTrue: [ self report sortArrowUp ]			ifFalse: [ self report sortArrowDown ]) ]! !!MAColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!report	^ report! !!MAColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!selector: aSymbol	self cascade: (Array with: aSymbol)! !!MAColumn methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setReport: aReport	report := aReport! !!MAColumn methodsFor: 'actions' stamp: 'nl 7/6/2006 08:43'!sortRows: aCollection	| result |	result := SortedCollection new: aCollection size.	result		sortBlock: self sorter;		addAll: aCollection.	^ self isReversed		ifFalse: [ result ]		ifTrue: [ result reversed ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sorter	^ self propertyAt: #sorter ifAbsent: [ self defaultSorter ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sorter: aBlock	self propertyAt: #sorter put: aBlock! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!title	^ self propertyAt: #title ifAbsent: [ self defaultTitle ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!title: aString	self propertyAt: #title put: aString! !!MAColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!valueFor: aRow	^ self cascade		inject: aRow		into: [ :result :each | result perform: each ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!visible	^ self propertyAt: #visible ifAbsent: [ self defaultVisible ]! !!MAColumn methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !!MADescribedColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultCascade	self shouldNotImplement! !!MADescribedColumn methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultTitle	^ self description label! !!MADescribedColumn methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!description	^ description! !!MADescribedColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderCellContent: anObject on: html	html render: (self description toString: (self valueFor: anObject))! !!MADescribedColumn methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	description := aDescription! !!MADescribedColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!valueFor: aRow	^ (aRow readUsing: self description)		ifNil: [ self description default ]! !!MADescribedComponentColumn commentStamp: 'pmm 8/23/2006 09:43' prior: 0!This column uses the component of a description to render the cell value.!!MADescribedComponentColumn methodsFor: 'readme' stamp: 'pmm 8/23/2006 09:46'!NOW	" very experimental ... use only if you're willing to fix bugs	  this only works for readonly views without callbacks	  on the positive side: only one component per column is created "! !!MADescribedComponentColumn methodsFor: 'accessing' stamp: 'pmm 8/23/2006 09:47'!component	component isNil ifTrue: [		component := self description componentClass new			setDescription: self description;			yourself ].	^component! !!MADescribedComponentColumn methodsFor: 'rendering' stamp: 'pmm 8/23/2006 09:55'!renderCellContent: anObject on: html	self component setMemento: (anObject mementoClass			model: anObject			description: self description asContainer).	self component renderViewerOn: html! !!MAToggleColumn methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderCellContent: anObject on: html	(self valueFor: anObject) in: [ :value |		html anchor			callback: [ anObject write: value not using: self description ];			with: (self description toString: value) ]! !!MACompatibility commentStamp: 'lr 5/27/2006 17:07' prior: 0!I am providing all the platform compatibility code on my class side, so that porting to different Smalltalk dialects can concentrate in a single place.!!MACompatibility class methodsFor: 'user-interface' stamp: 'rjl 4/24/2006 21:12'!choose: aString from: aCollection	"Display aString to the user and let him choose any of the items in aCollection."	| index list|	list := aCollection asOrderedCollection .	index := PopUpMenu		withCaption: aString		chooseFrom: (list collect: [ :each | each asString ]).	^ index isZero		ifFalse: [ list at: index ]! !!MACompatibility class methodsFor: 'environment' stamp: 'lr 3/9/2006 11:32'!classNamed: aString	"Return the class named aString, nil if the class can't be found."	^ Smalltalk classNamed: aString! !!MACompatibility class methodsFor: 'user-interface' stamp: 'lr 3/9/2006 11:32'!confirm: aString	"Display aString to the user and let him confirm."	^ PopUpMenu confirm: aString! !!MACompatibility class methodsFor: 'user-interface' stamp: 'lr 3/9/2006 11:32'!inform: aString	"Display aString to the user."	^ PopUpMenu inform: aString! !!MACompatibility class methodsFor: 'user-interface' stamp: 'lr 3/9/2006 11:32'!openWorkspace: aContentsString titled: aTitleString	"Open a new wokspace with the contents aContentsString and the title aTitleString."	Workspace new		contents: aContentsString;		openLabel: aTitleString! !!MACompatibility class methodsFor: 'environment' stamp: 'lr 3/9/2006 11:32'!referenceStream: aReadWriteStream	"Return a stream instance to operate on aReadWriteStream being able to serialize and deserialize objects by sending #nextPut: and #next. Squeak: The implementation of ReferenceStream doesn't work well together with the default WriteStream implementaiton, therefor we have to change it on the fly."	^ ReferenceStream on: (aReadWriteStream class = WriteStream		ifTrue: [ RWBinaryOrTextStream on: aReadWriteStream contents ]		ifFalse: [ aReadWriteStream ])! !!MACompatibility class methodsFor: 'user-interface' stamp: 'lr 3/9/2006 11:32'!request: aString default: anObject	"Display aString and requests an input from the user, whereas anObject is the default value."	^ FillInTheBlankMorph		request: aString		initialAnswer: anObject		centerAt: ActiveHand cursorPoint		inWorld: ActiveWorld		onCancelReturn: nil! !!MACompatibility class methodsFor: 'environment' stamp: 'lr 3/9/2006 11:32'!uuid	"Answer a random object that is extremly likely to be unique over space and time."	^ UUID new! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'lr 3/27/2006 13:31'!default	^ Default! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'lr 3/27/2006 13:31'!default: aBuilder	Default := aBuilder! !!MADescriptionBuilder class methodsFor: 'building' stamp: 'lr 3/27/2006 13:29'!for: anObject	^ self default for: anObject! !!MADescriptionBuilder class methodsFor: 'initialization' stamp: 'lr 3/27/2006 17:21'!initialize	self default: MANamedBuilder new! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 13:54'!build: anObject	self subclassResponsibility! !!MADescriptionBuilder methodsFor: 'configuration' stamp: 'lr 5/17/2006 15:49'!containerSelector	^ #descriptionContainer! !!MADescriptionBuilder methodsFor: 'initialization' stamp: 'lr 3/27/2006 13:55'!finalize	super finalize.	self flush; unregister! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 13:41'!flush	cache := IdentityDictionary new! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'lr 3/27/2006 13:58'!for: anObject	^ cache at: anObject ifAbsentPut: [ self build: anObject ]! !!MADescriptionBuilder methodsFor: 'initialization' stamp: 'lr 3/27/2006 13:34'!initialize	super initialize.	self flush; register! !!MADescriptionBuilder methodsFor: 'events' stamp: 'lr 3/27/2006 13:55'!modified: anEvent	self flush! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 13:36'!register	SystemChangeNotifier uniqueInstance		notify: self ofSystemChangesOfItem: #method change: #Added using: #modified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #modified:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #modified:! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 14:45'!unregister	SystemChangeNotifier uniqueInstance		noMoreNotificationsFor: self! !!MANamedBuilder commentStamp: 'lr 5/17/2006 15:46' prior: 0!I dynamically build container descriptions from class-side methods using a simple naming convention for the selector names:# The method <code>#defaultContainer</code> is called to retrieve the container instance.# All the unary methods starting with the selector <code>#description</code> are called and should return a valid description to be added to the container.# All the keyword messages with one argument having a prefix of a method selected in step 2 will be called with the original description to further refine its definition.!!MANamedBuilder methodsFor: 'actions' stamp: 'lr 5/17/2006 15:50'!build: anObject	| selectors description |	selectors := anObject class allSelectors 		select: #isDescriptionSelector.	^ (selectors select: #isDescriptionDefinition)		inject: (self build: anObject for: self containerSelector in: selectors)		into: [ :result :each |			self containerSelector = each ifFalse: [				description := self build: anObject for: each in: selectors.				description isDescription					ifTrue: [ result add: description ] ].			result ]! !!MANamedBuilder methodsFor: 'actions' stamp: 'lr 4/10/2006 10:53'!build: anObject for: aSelector in: aCollection	^ (aCollection select: [ :each | each isDescriptionExtension: aSelector ])		inject: (anObject perform: aSelector)		into: [ :result :each | anObject perform: each with: result ]! !!MAPragmaBuilder commentStamp: 'lr 5/29/2006 09:24' prior: 0!I dynamically build container descriptions defined statically in classes using  all the methods being tagged with the pragmas <code>description</code> or <code>description:</code>. I only work with Smalltalk implementations that have a decent implementation of Pragmas, such as Squeak 3.9.!!MAPragmaBuilder methodsFor: 'actions' stamp: 'lr 5/17/2006 15:53'!build: anObject	| selectors |	selectors := Set new.	^ (Pragma allNamed: #description from: anObject class to: Object class)		inject: (self build: anObject for: self containerSelector in: selectors)		into: [ :container :pragma |			(selectors includes: pragma selector) ifFalse: [				selectors add: pragma selector.				container add: (self build: anObject from: pragma) ].			container ]! !!MAPragmaBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 16:22'!build: anObject from: aPragma	^ (Pragma allNamed: #description: from: anObject class to: Object class) reverse		inject: (anObject perform: aPragma selector)		into: [ :description :pragma |			aPragma selector = pragma arguments first				ifFalse: [ description ]				ifTrue: [ anObject perform: pragma selector with: description ] ]! !!MADistribution commentStamp: 'lr 6/2/2006 00:12' prior: 0!I am responsible for building a distribution and publishing a complete package on SqueakMap. All my settings, such as which packages I depend on, are defined on the class side and can be overridden to create different distributions based on Magritte.!!MADistribution class methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:33'!cleanCategories: aPackage	aPackage classesAndMetaClasses do: [ :each |		each organization			removeEmptyCategories;			sortCategories ]! !!MADistribution class methodsFor: 'utilities' stamp: 'lr 3/21/2006 20:03'!cleanSource: aPackage	| input output line |	aPackage methods do: [ :each |		input := each sourceCode asString			withBlanksTrimmed readStream.		output := String streamContents: [ :stream |			[ input atEnd ] whileFalse: [				line := input nextLine.				stream nextPutAll: (line					copyFrom: 1 to: (line						findLast: [ :c | c isSeparator not ])).				stream nextPut: Character cr ] ].		output := output allButLast.		(output last = $. and: [ (output at: output size - 1) ~= $$ ])			ifTrue: [ output := output allButLast ].		each sourceCode ~= output			ifTrue: [ each actualClass compile: output ] ]! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!license	"Return a string with the license of the package. This string shall not be removed or altered in any case."	^ 'The MIT LicenseCopyright (c) 2003-2006 Lukas Renggli, renggli at iam.unibe.chCopyright (c) 2003-2006 Software Composition GroupPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!package	"The SqueakMap package name."	^ 'Magritte'! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!packages	"Return a collection of package names that should be distributed and eventually installed."	^ #( ( 'DynamicBindings' '(Smalltalk includesKey: #WAComponent) or: [ PasteUpMorph confirm: ''Would you like to install Seaside?'' ]' )		 ( 'KomServices' 'Smalltalk includesKey: #DynamicBindings' )		 ( 'KomHttpServer' 'Smalltalk includesKey: #TcpService' )		 ( 'Seaside2' 'Smalltalk includesKey: #HttpService' )		 ( 'Scriptaculous' 'Smalltalk includesKey: #WAComponent' )		 ( 'Magritte-Model' )		 ( 'Magritte-Tests' 'Smalltalk includesKey: #TestCase' )		 ( 'Magritte-Morph' 'Smalltalk includesKey: #Morph' )		 ( 'Magritte-Seaside' 'Smalltalk includesKey: #WAComponent' ) )! !!MADistribution class methodsFor: 'execution' stamp: 'lr 3/9/2006 11:33'!postload	"This method will be automatically called after successful loading the distribution."	MACompatibility openWorkspace: self license titled: 'License'.	self registerRepository: 'http://mc.lukas-renggli.ch/magritte'! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!postscript	^ self name , ' postload.'! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!preamble	^ String new! !!MADistribution class methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!productName	^ String streamContents: [ :stream |		stream			nextPutAll: self package; space;			nextPutAll: self versionNumber ]! !!MADistribution class methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!registerRepository: aString	| repositoryGroup httpRespository |	repositoryGroup := Smalltalk classNamed: #MCRepositoryGroup.	httpRespository := Smalltalk classNamed: #MCHttpRepository.	(repositoryGroup notNil and: [ httpRespository notNil ]) ifTrue: [		repositoryGroup default			addRepository: ((httpRespository				location: aString				user: String new				password: String new)					creationTemplate: 'MCHttpRepository	location: ' , aString printString , '	user: ''''	password: ''''';				yourself) ]! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 6/30/2006 00:40'!version	"The first item is the product name, which should only contain lowercase letters. Then the version numbers are following, that are made up of three numbers. An optimal suffix alpha, beta, pre or rc follows. External packages or extensions might want to call this method to check the version required to run."	^ #( magritte 1 0 9 )! !!MADistribution class methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!versionName	^ self version first asString! !!MADistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!versionNote	"This is a string to be used as release-note in SqueakMap."	^ String new! !!MADistribution class methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!versionNumber	^ String streamContents: [ :output |		self version allButFirst readStream in: [ :input |			[ input atEnd or: [ input peek isString ] ]				whileFalse: [ output print: input next; nextPut: $. ].			output skip: -1.			input atEnd				ifFalse: [ output nextPut: $-; nextPutAll: input next ] ] ]! !!MADistribution class methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!versionString	^ String streamContents: [ :stream |		stream			nextPutAll: self versionName; nextPut: $-;			nextPutAll: self versionNumber ]! !!MADistribution methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addPackage: aPackage	(self preparedPackages includes: aPackage)		ifTrue: [ ^ self ].	self		addPackage: aPackage		workingCopy: (MCWorkingCopy registry			at: aPackage)! !!MADistribution methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addPackage: aPackage version: aVersion	| condition |	self zip		addString: (ByteArray streamContents: [ :stream |			aVersion fileOutOn: stream ])		as: aVersion fileName.	self addPreamble: (String streamContents: [ :stream |		condition := self class packages			detect: [ :each | aPackage name = each first ]			ifNone: [ Array with: aPackage name ].		condition size > 1			ifFalse: [ condition := condition copyWith: 'true' ].		stream			nextPut: $(; nextPutAll: condition second; nextPutAll: ') ifTrue: [ ';			nextPutAll: 'self fileInMonticelloZipVersionNamed: ';			print: aVersion fileName; nextPutAll: ' ].' ]).	self preparedPackages add: aPackage! !!MADistribution methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addPackage: aPackage workingCopy: aWorkingCopy	aWorkingCopy modified		ifTrue: [ self error: aPackage name , ' needs to be saved first.' ].	aWorkingCopy requiredPackages		do: [ :each | self addPackage: each ].	self		addPackage: aPackage		version: (MCVersion			package: aPackage			info: (aWorkingCopy ancestry				infoWithName: aWorkingCopy ancestors first name				message: self versionString)			snapshot: aPackage snapshot)! !!MADistribution methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addPostscript: aString	postscript := self postscriptString copyWithAll: aString , String cr! !!MADistribution methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addPreamble: aString	preamble := self preambleString copyWithAll: aString , String cr! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!basePackages	^ self class packages collect: [ :each | MCPackage named: each first ]! !!MADistribution methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!checkResult: aString	| result |	result := #( 'HTTP/1.1 201 ' 'HTTP/1.1 200 ' 'HTTP/1.0 201 ' 'HTTP/1.0 200 ')		anySatisfy: [ :each | aString beginsWith: each ].	result ifFalse: [ self error: aString ]! !!MADistribution methodsFor: 'building' stamp: 'lr 6/2/2006 00:10'!dump	"Dump the SAR archive to the file-system."	self zip writeToFileNamed: self filename! !!MADistribution methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!filename	^ self versionString , '.sar'! !!MADistribution methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!initialize	super initialize.	self basePackages		do: [ :each | self addPackage: each ]		displayingProgress: self versionString.	(self zip addString: self preambleString as: 'install/preamble')		desiredCompressionLevel: 9.	(self zip addString: self postscriptString as: 'install/postscript')		desiredCompressionLevel: 9! !!MADistribution methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!password	^ password ifNil: [ password := MACompatibility request: 'SqueakMap Password:' default: '' ]! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!postscriptString	^ postscript ifNil: [ postscript := self class postscript ]! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!preambleString	^ preamble ifNil: [ preamble := self class preamble ]! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!preparedPackages	^ prepared ifNil: [ prepared := Set new ]! !!MADistribution methodsFor: 'building' stamp: 'lr 6/2/2006 00:10'!publish	"Publish the package as a new release on SqueakMap."	| result |	result := HTTPSocket		httpPost: self squeakMapUrl , 'packagebyname/' , self class package , '/newrelease'		args: (Array			with: 'version' -> (Array with: self versionNumber)			with: 'note' -> (Array with: self versionNote)			with: 'downloadURL' -> (Array with: self upload)			with: 'name' -> (Array with: self versionName)			with: 'summary' -> (Array with: self versionString))		user: self username		passwd: self password.	(result contents includesSubString: self versionNumber)		ifFalse: [ self error: result contents ]! !!MADistribution methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!squeakMapUrl	^ 'http://map1.squeakfoundation.org/sm/'! !!MADistribution methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!upload	| result stream |	result := HTTPSocket		httpPut: (ByteArray streamContents: [ :s | self zip writeTo: s ])		to: self squeakMapUrl , 'upload/' , self filename		user: self username passwd: self password.	self checkResult: result.	stream := result readStream.	stream upToAll: 'http://'.	^ 'http://' , stream upToEnd! !!MADistribution methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!username	^ username ifNil: [ username := MACompatibility request: 'SqueakMap Username:' default: 'lr' ]! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!versionName	^ self class versionName! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!versionNote	^ self class versionNote! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!versionNumber	^ self class versionNumber! !!MADistribution methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!versionString	^ self class versionString! !!MADistribution methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!zip	^ zip ifNil: [ zip := ZipArchive new ]! !!MAFileModel commentStamp: 'lr 5/27/2006 17:09' prior: 0!I represent a file with filename, mimetype and contents within the Magritte framework.!!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMimeType	^ 'application/octet-stream'! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMimeTypes	^ #( 'ai' 'application/postscript' 'aif' 'audio/x-aiff' 'aifc' 'audio/x-aiff' 'aiff' 'audio/x-aiff' 'asc' 'text/plain' 'au' 'audio/basic' 'avi' 'video/x-msvideo' 'bcpio' 'application/x-bcpio' 'bin' 'application/octet-stream' 'c' 'text/plain' 'cc' 'text/plain' 'ccad' 'application/clariscad' 'cdf' 'application/x-netcdf' 'class' 'application/octet-stream' 'cpio' 'application/x-cpio' 'cpt' 'application/mac-compactpro' 'csh' 'application/x-csh' 'css' 'text/css' 'dcr' 'application/x-director' 'dir' 'application/x-director' 'dms' 'application/octet-stream' 'doc' 'application/msword' 'drw' 'application/drafting' 'dvi' 'application/x-dvi' 'dwg' 'application/acad' 'dxf' 'application/dxf' 'dxr' 'application/x-director' 'eps' 'application/postscript' 'etx' 'text/x-setext' 'exe' 'application/octet-stream' 'ez' 'application/andrew-inset' 'f' 'text/plain' 'f90' 'text/plain' 'fli' 'video/x-fli' 'gif' 'image/gif' 'gtar' 'application/x-gtar' 'gz' 'application/x-gzip' 'h' 'text/plain' 'hdf' 'application/x-hdf' 'hh' 'text/plain' 'hqx' 'application/mac-binhex40' 'htm' 'text/html' 'html' 'text/html' 'ice' 'x-conference/x-cooltalk' 'ief' 'image/ief' 'iges' 'model/iges' 'igs' 'model/iges' 'ips' 'application/x-ipscript' 'ipx' 'application/x-ipix' 'jpe' 'image/jpeg' 'jpeg' 'image/jpeg' 'jpg' 'image/jpeg' 'js' 'application/x-javascript' 'kar' 'audio/midi' 'latex' 'application/x-latex' 'lha' 'application/octet-stream' 'lsp' 'application/x-lisp' 'lzh' 'application/octet-stream' 'm' 'text/plain' 'man' 'application/x-troff-man' 'me' 'application/x-troff-me' 'mesh' 'model/mesh' 'mid' 'audio/midi' 'midi' 'audio/midi' 'mif' 'application/vnd.mif' 'mime' 'www/mime' 'mov' 'video/quicktime' 'movie' 'video/x-sgi-movie' 'mp2' 'audio/mpeg' 'mp3' 'audio/mpeg' 'mpe' 'video/mpeg' 'mpeg' 'video/mpeg' 'mpg' 'video/mpeg' 'mpga' 'audio/mpeg' 'ms' 'application/x-troff-ms' 'msh' 'model/mesh' 'nc' 'application/x-netcdf' 'oda' 'application/oda' 'pbm' 'image/x-portable-bitmap' 'pdb' 'chemical/x-pdb' 'pdf' 'application/pdf' 'pgm' 'image/x-portable-graymap' 'pgn' 'application/x-chess-pgn' 'png' 'image/png' 'pnm' 'image/x-portable-anymap' 'pot' 'application/mspowerpoint' 'ppm' 'image/x-portable-pixmap' 'pps' 'application/mspowerpoint' 'ppt' 'application/mspowerpoint' 'ppz' 'application/mspowerpoint' 'pre' 'application/x-freelance' 'prt' 'application/pro_eng' 'ps' 'application/postscript' 'qt' 'video/quicktime' 'ra' 'audio/x-realaudio' 'ram' 'audio/x-pn-realaudio' 'ras' 'image/cmu-raster' 'rgb' 'image/x-rgb' 'rm' 'audio/x-pn-realaudio' 'roff' 'application/x-troff' 'rpm' 'audio/x-pn-realaudio-plugin' 'rtf' 'text/rtf' 'rtx' 'text/richtext' 'scm' 'application/x-lotusscreencam' 'set' 'application/set' 'sgm' 'text/sgml' 'sgml' 'text/sgml' 'sh' 'application/x-sh' 'shar' 'application/x-shar' 'silo' 'model/mesh' 'sit' 'application/x-stuffit' 'skd' 'application/x-koan' 'skm' 'application/x-koan' 'skp' 'application/x-koan' 'skt' 'application/x-koan' 'smi' 'application/smil' 'smil' 'application/smil' 'snd' 'audio/basic' 'sol' 'application/solids' 'spl' 'application/x-futuresplash' 'src' 'application/x-wais-source' 'step' 'application/STEP' 'stl' 'application/SLA' 'stp' 'application/STEP' 'sv4cpio' 'application/x-sv4cpio' 'sv4crc' 'application/x-sv4crc' 'swf' 'application/x-shockwave-flash' 't' 'application/x-troff' 'tar' 'application/x-tar' 'tcl' 'application/x-tcl' 'tex' 'application/x-tex' 'texi' 'application/x-texinfo' 'texinfo' 'application/x-texinfo' 'tif' 'image/tiff' 'tiff' 'image/tiff' 'tr' 'application/x-troff' 'tsi' 'audio/TSP-audio' 'tsp' 'application/dsptype' 'tsv' 'text/tab-separated-values' 'txt' 'text/plain' 'unv' 'application/i-deas' 'ustar' 'application/x-ustar' 'vcd' 'application/x-cdlink' 'vda' 'application/vda' 'viv' 'video/vnd.vivo' 'vivo' 'video/vnd.vivo' 'vrml' 'model/vrml' 'wav' 'audio/x-wav' 'wrl' 'model/vrml' 'xbm' 'image/x-xbitmap' 'xlc' 'application/vnd.ms-excel' 'xll' 'application/vnd.ms-excel' 'xlm' 'application/vnd.ms-excel' 'xls' 'application/vnd.ms-excel' 'xlw' 'application/vnd.ms-excel' 'xml' 'text/xml' 'xpm' 'image/x-xpixmap' 'xwd' 'image/x-xwindowdump' 'xyz' 'chemical/x-pdb' 'zip' 'application/zip' )! !!MAFileModel class methodsFor: 'class initialization' stamp: 'lr 3/9/2006 11:33'!initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypeFor: aString	^ self mimetypes at: aString ifAbsent: [ self defaultMimeType ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypes	^ MimeTypes! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ self species = anObject species		and: [ self filename = anObject filename ]		and: [ self mimetype = anObject mimetype ]		and: [ self contents = anObject contents ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!contents	^ contents ifNil: [ ByteArray new ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!contents: aByteArray	contents := aByteArray! !!MAFileModel methodsFor: 'querying' stamp: 'lr 3/21/2006 19:56'!extension	"Answer the file-extension."	^ self filename copyAfterLast: $.! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!filename	^ filename ifNil: [ String new ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!filename: aString	filename := aString! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self filename hash bitXor: self mimetype hash! !!MAFileModel methodsFor: 'testing' stamp: 'lr 6/2/2006 00:16'!isApplication	"Return <code>true</code> if the mimetype of the receiver is application-data. This message will match types like: application/postscript, application/zip, application/pdf, etc."	^ self maintype = 'application'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 6/2/2006 00:16'!isAudio	"Return <code>true</code> if the mimetype of the receiver is audio-data. This message will match types like: audio/basic, audio/tone, audio/mpeg, etc."	^ self maintype = 'audio'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isEmpty	^ self size isZero! !!MAFileModel methodsFor: 'testing' stamp: 'lr 6/2/2006 00:16'!isImage	"Return <code>true</code> if the mimetype of the receiver is image-data. This message will match types like: image/jpeg, image/gif, image/png, image/tiff, etc."	^ self maintype = 'image'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 6/2/2006 00:16'!isText	"Return <code>true</code> if the mimetype of the receiver is text-data. This message will match types like: text/plain, text/html, text/sgml, text/css, text/xml, text/richtext, etc."	^ self maintype = 'text'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 6/2/2006 00:16'!isVideo	"Return <code>true</code> if the mimetype of the receiver is video-data. This message will match types like: video/mpeg, video/quicktime, etc."	^ self maintype = 'video'! !!MAFileModel methodsFor: 'querying' stamp: 'lr 3/9/2006 11:32'!maintype	"Answer the first part of the mime-type."	^ self mimetype copyUpTo: $/! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!mimetype	^ mimetype ifNil: [ self class mimetypeFor: self extension ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!mimetype: aString	mimetype := aString! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderImageOn: html	html image url: (self urlForFileOn: html)! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderMediaOn: html	(html tag: 'object')		attributeAt: 'src' put: (self urlForFileOn: html);		attributeAt: 'type' put: self mimetype! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderOn: html	self isText		ifTrue: [ ^ self renderTextOn: html ].	self isImage		ifTrue: [ ^ self renderImageOn: html ].	self isAudio | self isVideo		ifTrue: [ ^ self renderMediaOn: html ].	^ self renderUnknownOn: html! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderTextOn: html	| stream |	stream := self contents.	html preformatted with: [		html text: (stream next: 800).		stream atEnd			ifFalse: [ html text: '...' ] ]! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!renderUnknownOn: html	html anchor		url: (self urlForFileOn: html);		with: self filename! !!MAFileModel methodsFor: 'querying' stamp: 'lr 3/9/2006 11:32'!size	"Answer the size of the file."	^ self contents size! !!MAFileModel methodsFor: 'querying' stamp: 'lr 3/9/2006 11:32'!subtype	"Answer the second part of the mime-type."	^ self mimetype copyAfter: $/! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 3/9/2006 11:33'!urlForFileOn: html	^ html context		urlForDocument: self contents		mimeType: self mimetype		fileName: self filename! !!MAMockAddress class methodsFor: 'descriptions' stamp: 'lr 3/9/2006 11:35'!descriptionPlace	^ MAStringDescription auto: 'place'! !!MAMockAddress class methodsFor: 'descriptions' stamp: 'lr 3/9/2006 11:35'!descriptionPlz	^ MANumberDescription auto: 'plz'! !!MAMockAddress class methodsFor: 'descriptions' stamp: 'lr 3/9/2006 11:35'!descriptionStreet	^ MAStringDescription auto: 'street'! !!MAMockAddress methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:34'!= anObject	^ self species = anObject species		and: [ self street = anObject street ]		and: [ self plz = anObject plz ]		and: [ self place = anObject place ]! !!MAMockAddress methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:34'!hash	^ self street hash! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!place	^ place! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!place: anObject	place := anObject! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!plz	^ plz! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!plz: anObject	plz := anObject! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!street	^ street! !!MAMockAddress methodsFor: 'accessing-generated' stamp: 'lr 3/9/2006 11:34'!street: anObject	street := anObject! !!MAObject commentStamp: 'lr 5/17/2006 14:07' prior: 0!I provide functionality available to all Magritte objects. I implement a dictionary of properties, so that extensions can easily store additional data.!!MAAccessor commentStamp: 'lr 5/29/2006 10:10' prior: 0!I am the abstract superclass to all accessor strategies. Accessors are used to implement different ways of accessing (reading and writing) data from instances using a common protocol: data can be uniformly read and written using <code>#readFrom:</code> respectively <code>#write:to:</code>.!!MAAccessor methodsFor: 'testing' stamp: 'lr 5/29/2006 10:11'!canRead: aModel	"Test if <code>aModel</code> can be read."	^ true! !!MAAccessor methodsFor: 'testing' stamp: 'lr 5/29/2006 10:11'!canWrite: aModel	"Test if <code>aModel</code> can be written."	^ true! !!MAAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAccessor	^ true! !!MAAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!printOn: aStream	self storeOn: aStream! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/29/2006 10:05'!read: aModel	"Read from <code>aModel</code> using the access-strategy of the receiver."	self subclassResponsibility! !!MAAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!storeOn: aStream	aStream nextPutAll: self class name; nextPutAll: ' new'! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/29/2006 10:05'!write: anObject to: aModel	"Write <code>anObject</code> to <code>aModel</code> using the access-strategy of the receiver."	self subclassResponsibility! !!MABlockAccessor commentStamp: 'lr 2/12/2006 20:04' prior: 0!I am an access strategy defined by two block-closures. The read-block expects the model as its first argument and is used to retrieve a value. The write-block expects the model as its first and the value as its second argument and is used to write a value to the model.!!MABlockAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MABlockAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock	^ self new		readBlock: aReadBlock;		writeBlock: aWriteBlock;		yourself! !!MABlockAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!= anObject	^ super = anObject		and: [ self readBlock = anObject readBlock ]		and: [ self writeBlock = anObject writeBlock ]! !!MABlockAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!canRead: aModel	^ (super canRead: aModel)		and: [ self readBlock notNil ]! !!MABlockAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!canWrite: aModel	^ (super canWrite: aModel)		and: [ self writeBlock notNil ]! !!MABlockAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: (self readBlock hash bitXor: self writeBlock hash)! !!MABlockAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!read: aModel	^ self readBlock value: aModel! !!MABlockAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock	^ readBlock! !!MABlockAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock: aBlock	readBlock := aBlock! !!MABlockAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!storeBlock: aBlock on: aStream	aStream nextPutAll: aBlock decompile asString allButFirst allButLast! !!MABlockAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' read: '.	self storeBlock: self readBlock on: aStream.	aStream nextPutAll: ' write: '.	self storeBlock: self writeBlock on: aStream.	aStream nextPut: $)! !!MABlockAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!write: anObject to: aModel	self writeBlock value: aModel value: anObject! !!MABlockAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock	^ writeBlock! !!MABlockAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock: aBlock	writeBlock := aBlock! !!MAChainAccessor commentStamp: 'lr 6/2/2006 10:02' prior: 0!I am an access strategy used to chain two access strategies. To read and write a value the <code>accessor</code> is performed on the given model and the result is passed into the <code>next</code> accessor.!!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor next: aNextAccessor	^ self new		accessor: anAccessor;		next: aNextAccessor;		yourself! !!MAChainAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!selectors: anArray	^ anArray allButLast reverse		inject: (MASelectorAccessor selector: anArray last)		into: [ :next :accessor |			self				accessor: (MASelectorAccessor selector: accessor)				next: next ]! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]		and: [ self next = anObject next ]! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor	^ accessor! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor: anAccessor	accessor := anAccessor! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!canRead: aModel	^ (super canRead: aModel)		and: [ self accessor canRead: aModel ]		and: [ self next canRead: (self accessor read: aModel) ]! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!canWrite: aModel	^ (super canWrite: aModel)		and: [ self accessor canRead: aModel ]		and: [ self next canWrite: (self accessor read: aModel) ]! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: (self accessor hash bitXor: self next hash)! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!next	^ next! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!next: anAccessor	next := anAccessor! !!MAChainAccessor methodsFor: 'copying' stamp: 'lr 3/9/2006 11:31'!postCopy	super postCopy.	self accessor: self accessor copy.	self next: self next copy! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!read: aModel	^ self next read: (self accessor read: aModel)! !!MAChainAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' accessor: '; store: self accessor; nextPutAll: ' next: '; store: self next; nextPut: $)! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!write: anObject to: aModel	self next write: anObject to: (self accessor read: aModel)! !!MAContainerAccessor commentStamp: 'lr 2/12/2006 20:09' prior: 0!I am a read-only access strategy and I answer the model itself when being read.!!MAContainerAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAContainerAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canWrite: aModel	^ false! !!MAContainerAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel! !!MAContainerAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	self error: 'Not supposed to write to ' , aModel asString , '.'! !!MADictionaryAccessor commentStamp: 'lr 2/12/2006 20:11' prior: 0!I am an access strategy to be used on dictionaries. I use my <code>key</code> to read from and write to indexed collections.!!MADictionaryAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADictionaryAccessor class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:32'!key: aSymbol	^ self new		key: aSymbol;		yourself! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self key = anObject key ]! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canRead: aModel	^ (super canRead: aModel)		and: [ aModel includesKey: self key ]! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self key hash! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key	^ key! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key: aKey	key := aKey! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel at: self key! !!MADictionaryAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' key: '; store: self key; nextPut: $)! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel at: self key put: anObject! !!MANullAccessor commentStamp: 'lr 5/29/2006 09:21' prior: 0!I am a null access strategy and I should be neither read nor written. I am still comparable to other strategies by holding onto a unique-identifier.!!MANullAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANullAccessor class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:33'!new	^ self uuid: MACompatibility uuid! !!MANullAccessor class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:33'!uuid: anUUID	^ self basicNew		uuid: anUUID;		yourself! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self uuid = anObject uuid ]! !!MANullAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canRead: aModel	^ false! !!MANullAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canWrite: aModel	^ false! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self uuid hash! !!MANullAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	self shouldNotImplement! !!MANullAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' uuid: '; store: self uuid; nextPut: $)! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid	^ uuid! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid: anObject	uuid := anObject! !!MANullAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	self shouldNotImplement! !!MASelectorAccessor commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am the most common access strategy defined by a read- and a write-selector. I am mostly used together with standard getters and setters as usually defined by the accessing protocol. If there is only a read-selector specified, the write selector will be deduced automatically by adding a colon to the read-selector.!!MAAutoSelectorAccessor commentStamp: 'lr 6/2/2006 09:37' prior: 0!I am very similar to my super-class *MASelectorAccessor*, however I do create instance variables and accessor methods automatically if necessary. I am especially useful for prototyping. I never change existing accessor methods.!!MAAutoSelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!categoryName	^ #'accessing-generated'! !!MAAutoSelectorAccessor methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!createReadAccessor: aClass	(aClass selectors includes: self readSelector)		ifTrue: [ ^ self ].	aClass		compile: (String streamContents: [ :stream |			stream nextPutAll: self readSelector; cr.			stream tab; nextPutAll: '^ '; nextPutAll: self readSelector ])		classified: self categoryName! !!MAAutoSelectorAccessor methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!createVariable: aClass	(aClass allInstVarNames includes: self readSelector)		ifTrue: [ ^ self ].	aClass addInstVarName: self readSelector! !!MAAutoSelectorAccessor methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!createWriteAccessor: aClass	(aClass selectors includes: self writeSelector)		ifTrue: [ ^ self ].	aClass		compile: (String streamContents: [ :stream |			stream nextPutAll: self writeSelector; space; nextPutAll: 'anObject'; cr.			stream tab; nextPutAll: self readSelector; nextPutAll: ' := anObject' ])		classified: self categoryName! !!MAAutoSelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!read: aModel	(self canRead: aModel) ifFalse: [		self createVariable: aModel class.		self createReadAccessor: aModel class ].	^ super read: aModel! !!MAAutoSelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!write: anObject to: aModel	(self canWrite: aModel) ifFalse: [		self createVariable: aModel class.		self createWriteAccessor: aModel class ].	super write: anObject to: aModel! !!MASelectorAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aSelector	^ self read: aSelector write: nil! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aReadSelector write: aWriteSelector	^ self new		readSelector: aReadSelector;		writeSelector: aWriteSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!selector: aSelector	^ self new		selector: aSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: aSelector	^ self read: nil write: aSelector! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self readSelector = anObject readSelector ]		and: [ self writeSelector = anObject writeSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canRead: aModel	^ (super canRead: aModel)		and: [ self readSelector notNil ]		and: [ aModel respondsTo: self readSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canWrite: aModel	^ (super canWrite: aModel)		and: [ self writeSelector notNil ]		and: [ aModel respondsTo: self writeSelector ]! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^  super hash bitXor: (self readSelector hash bitXor: self writeSelector hash)! !!MASelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel perform: self readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector	^ readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector: aSelector	readSelector := aSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!selector	^ self readSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!selector: aSelector	self readSelector: aSelector asSymbol.	self writeSelector: (aSelector copyWith: $:) asSymbol! !!MASelectorAccessor methodsFor: 'printing' stamp: 'lr 3/21/2006 18:43'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' read: '; store: self readSelector; nextPutAll: ' write: '; store: self writeSelector; nextPut: $)! !!MASelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel perform: self writeSelector with: anObject! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector	^ writeSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector: aSelector	writeSelector := aSelector! !!MAVariableAccessor commentStamp: 'lr 5/27/2006 17:20' prior: 0!I am an access strategy that directly reads from and writes to instance variables. I strongly violate encapsulation and most of the time I should be replaced by an instance of *MASelectorAccessor*.!!MAVariableAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAVariableAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!name: aString	^ self new		name: aString;		yourself! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self name = anObject name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canRead: aModel	^ (super canRead: aModel)		and: [ aModel class allInstVarNames includes: self name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!canWrite: aModel	^ (super canWrite: aModel)		and: [ self canRead: aModel ]! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self name hash! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name	^ name! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name: aString	name := aString! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel instVarNamed: self name! !!MAVariableAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!storeOn: aStream	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' name: '; store: self name; nextPut: $)! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel instVarNamed: self name put: anObject! !!MACondition commentStamp: 'lr 5/17/2006 14:58' prior: 0!I am an abstract condition. To check if the condition is satisfied by a given model-object, send the message <code>#value:</code> to myself.!!MAComparator class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAComparator class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:32'!selector: aSelector values: aCollection	^ self new		setSelector: aSelector;		setValues: aCollection;		yourself! !!MAComparator methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!= anObject	^ super = anObject		and: [ self selector = anObject selector ]		and: [ self values = anObject values ]! !!MAComparator methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: self selector hash! !!MAComparator methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!selector	^ selector! !!MAComparator methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setSelector: aSelector	selector := aSelector! !!MAComparator methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setValues: aCollection	values := aCollection! !!MAComparator methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:31'!value: anObject	| receiverAndArguments |	receiverAndArguments := self values collect: [ :each |		each isAccessor			ifFalse: [ each ]			ifTrue: [				(each canRead: anObject)					ifFalse: [ ^ false ]					ifTrue: [ each read: anObject ] ] ].	^ receiverAndArguments first		perform: self selector		withArguments: receiverAndArguments allButFirst! !!MAComparator methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!values	^ values! !!MAAllCondition commentStamp: 'lr 5/17/2006 14:50' prior: 0!I am a condition that is satisfied if <emph>all</emph> of my child-conditions are satisfied.!!MAAllCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAAllCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:31'!& aCondition	^ self copyWith: aCondition! !!MAAllCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:31'!value: anObject	^ self conditions allSatisfy: [ :each | each value: anObject ]! !!MAAnyCondition commentStamp: 'lr 5/17/2006 14:50' prior: 0!I am a condition that is satisfied if <emph>any</emph> of my child-conditions are satisfied.!!MAAnyCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAAnyCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:31'!value: anObject	^ self conditions anySatisfy: [ :each | each value: anObject ]! !!MAAnyCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:31'!| aCondition	^ self copyWith: aCondition! !!MAComposedCondition class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!new	^ super new		setConditions: Array new;		yourself! !!MAComposedCondition class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!with: aRelation	^ self withAll: (Array with: aRelation)! !!MAComposedCondition class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!with: aFirstRelation with: aSecondRelation	^ self withAll: (Array with: aFirstRelation with: aSecondRelation)! !!MAComposedCondition class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!withAll: anArray	^ self new		setConditions: anArray;		yourself! !!MAComposedCondition methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!= anObject	^ super = anObject		and: [ self conditions = anObject conditions ]! !!MAComposedCondition methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!conditions	^ conditions! !!MAComposedCondition methodsFor: 'copying' stamp: 'lr 3/9/2006 11:31'!copyWith: aRelation	^ self class withAll: (self conditions copyWith: aRelation)! !!MAComposedCondition methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: self conditions hash! !!MAComposedCondition methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isComposed	^ true! !!MAComposedCondition methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setConditions: aCollection	conditions := aCollection! !!MANoneCondition commentStamp: 'lr 5/17/2006 14:50' prior: 0!I am a condition that is satisfied if <emph>none</emph> of my child-conditions are satisfied.!!MANoneCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANoneCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!!! aCondition	^ self copyWith: aCondition! !!MANoneCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:32'!value: anObject	^ self conditions noneSatisfy: [ :each | each value: anObject ]! !!MACondition methodsFor: 'operators-binary' stamp: 'lr 3/9/2006 11:32'!!! aCondition	^ MANoneCondition with: self with: aCondition! !!MACondition methodsFor: 'operators-binary' stamp: 'lr 5/17/2006 14:54'!& aCondition	"The resulting condition will require the receiver <emph>and</emph> <code>aCondition</code> to be satisfied."	^ MAAllCondition with: self with: aCondition! !!MACondition methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isComposed	^ false! !!MACondition methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isCondition	^ true! !!MACondition methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isConstant	^ false! !!MACondition methodsFor: 'operators-unary' stamp: 'lr 5/17/2006 14:54'!not	"Negates the receiving condition."	^ MANoneCondition with: self! !!MACondition methodsFor: 'evaluation' stamp: 'lr 3/9/2006 11:32'!numArgs	"Answer the number of arguments that must be used to evaluate this condition."	^ 1! !!MACondition methodsFor: 'evaluation' stamp: 'lr 5/17/2006 14:52'!value: anObject	"Evaluate the receiver with the argument anObject. Answer a <code>Boolean</code> telling if the condition is met for <code>anObject</code>."	self subclassResponsibility! !!MACondition methodsFor: 'operators-binary' stamp: 'lr 5/17/2006 14:54'!| aCondition	"The resulting condition will require the receiver <emph>or</emph> <code>aCondition</code> to be satisfied."	^ MAAnyCondition with: self with: aCondition! !!MAConstantCondition methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isConstant	^ true! !!MAFalseCondition commentStamp: 'lr 5/28/2006 18:45' prior: 0!I am a condition that is satisfied for <emph>no</emph> input. I always answer <code>false</code>.!!MAFalseCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAFalseCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!& aCondition	^ self! !!MAFalseCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!not	^ MATrueCondition new! !!MAFalseCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:32'!value: anObject	^ false! !!MAFalseCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!| aCondition	^ aCondition! !!MATrueCondition commentStamp: 'lr 5/28/2006 18:45' prior: 0!I am a condition that is satisfied for <emph>all</emph> input. I always answer <code>true</code>.!!MATrueCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATrueCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!& aCondition	^ aCondition! !!MATrueCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!not	^ MAFalseCondition new! !!MATrueCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:32'!value: anObject	^ true! !!MATrueCondition methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!| aCondition	^ self! !!MASelectorCondition commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am a condition that performs a specific selector on the model to test if a condition is satisfied or not.!!MASelectorCondition class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASelectorCondition class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!selector: aSelector arguments: aCollection	^ self new		setSelector: aSelector;		setArguments: aCollection;		yourself! !!MASelectorCondition methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!arguments	^ arguments! !!MASelectorCondition methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!selector	^ selector! !!MASelectorCondition methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setArguments: aCollection	arguments := aCollection! !!MASelectorCondition methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setSelector: aSelector	selector := aSelector! !!MASelectorCondition methodsFor: 'evaluating' stamp: 'lr 3/9/2006 11:32'!value: anObject	^ anObject perform: self selector withArguments: self arguments! !!MADescription commentStamp: 'lr 6/2/2006 09:35' prior: 0!I am the root of the description hierarchy in Magritte and I provide most of the basic properties available to all descriptions. If you would like to annotate your model with a description have a look at the different subclasses of myself.!!ExampleIf your model has an instance variable called <code>title</code> that should be used to store the title of the object, you could add the following description to your class:=MyModel class>>descriptionTitle=	^ (MAStringDescription auto: #title label: 'Title')=		beRequired;=		yourself.The selector <code>#title</code> is the name of the accessor method used by Magritte to retrieve the value from the model. In the above case Magritte creates the accessor method and the instance variable automatically, if necessary. The label is used to give the field a name and will be printed next to the input box if a visual GUI is created from this description.The write-accessor is automatically deduced by adding a colon to the read-selector, in this example <code>#title:</code>. You can specify your own accessor strategy using one of the subclasses of *MAAccessor*. If you have multiple description within the same object, the priority field is used to order them. Assign a low priority to have descriptions printed first.!!MAContainer commentStamp: 'lr 5/17/2006 14:20' prior: 0!I am a container holding a collection of descriptions, all instances of subclasses of *MAElementDescription*. I keep my children within an <code>OrderedCollection</code>, but I don't sort them according to their priority.I fully support the collection protocol: descriptions can be added and removed. Moreover I implement most enumeration methods, so that users are able to iterate (<code>do:</code>), filter (<code>select:</code>, <code>reject:</code>), transform (<code>collect:</code>), extract (<code>detect:</code>, <code>detect:ifNone:</code>), and test (<code>allSatisfy:</code>, <code>anySatisfy:</code>, <code>noneSatisfy:</code>) my elements.!!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultAccessor	^ MAContainerAccessor new! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultCollection	^ OrderedCollection new! !!MAContainer class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAContainerComponent! !!MAContainer class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentRenderer	^ MATableRenderer! !!MAContainer class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAContainerMorph! !!MAContainer class methodsFor: 'accessing-description' stamp: 'lr 9/1/2006 21:25'!descriptionChildren	^ (MAToManyRelationDescription accessor: (MASelectorAccessor read: #children write: #setChildren:) label: 'Elements' priority: 400 default: self defaultCollection)		classes: (MADynamicObject on: [ MAElementDescription withAllConcreteClasses ]);		beOrdered;		yourself! !!MAContainer class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionDefault	^ nil! !!MAContainer class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!with: aDescription	^ self new		add: aDescription;		yourself! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!MAContainer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitContainer: self! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!add: aDescription	self children add: aDescription! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addAll: aCollection	self children addAll: aCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!allSatisfy: aBlock	^ self children allSatisfy: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!anySatisfy: aBlock	^ self children anySatisfy: aBlock! !!MAContainer methodsFor: '*magritte-seaside-converting' stamp: 'lr 3/9/2006 11:33'!asComponentOn: anObject	^ self componentClass		memento: (anObject mementoClass			model: anObject			description: self)! !!MAContainer methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ self! !!MAContainer methodsFor: '*magritte-morph-converting' stamp: 'lr 3/9/2006 11:33'!asMorphOn: anObject	^ self morphClass		memento: (anObject mementoClass			model: anObject			description: self)! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex	^ self children at: anIndex! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex ifAbsent: aBlock	^ self children at: anIndex ifAbsent: aBlock! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!children	^ children! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!collect: aBlock	^ self copy		setChildren: (self children collect: aBlock);		yourself! !!MAContainer methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!componentRenderer	^ self propertyAt: #componentRenderer ifAbsent: [ self class defaultComponentRenderer ]! !!MAContainer methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!componentRenderer: aClass	self propertyAt: #componentRenderer put: aClass! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self copy		setChildren: self class defaultCollection;		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyFrom: aStartIndex to: anEndIndex	^ self copy		setChildren: (self children			copyFrom: aStartIndex			to: anEndIndex);		yourself! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock	^ self children detect: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock ifNone: anExceptionBlock	^ self children detect: aBlock ifNone: anExceptionBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock	self children do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock separatedBy: aSeparatorBlock	self children do: aBlock separatedBy: aSeparatorBlock! !!MAContainer methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!errorNotFound: aDescription	self error: aDescription class label , ' not found.'! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!hasChildren	^ self notEmpty! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self children hash! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!includes: aDescription	^ self children includes: aDescription! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!initialize	super initialize.	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!inject: anObject into: aBlock	^ self children inject: anObject into: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!intersection: aCollection	^ self copy		setChildren: (self children intersection: aCollection);		yourself! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isContainer	^ true! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isEmpty	^ self children isEmpty! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self children moveDown: aDescription! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self children moveUp: aDescription! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:08'!noneSatisfy: aBlock	^ self children noneSatisfy: aBlock! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!notEmpty	^ self children notEmpty! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setChildren: self children copy! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!reject: aBlock	^ self copy		setChildren: (self children reject: aBlock);		yourself! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!remove: aDescription	self children remove: aDescription ifAbsent: [ self errorNotFound: aDescription ]! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!removeAll	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!select: aBlock	^ self copy		setChildren: (self children select: aBlock);		yourself! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	children := aCollection! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!size	^ self children size! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!union: aContainer	^ self copy		addAll: (aContainer reject: [ :each | self includes: each ]);		yourself! !!MAContainer methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	| errors |	super validateSpecific: anObject.	errors := Array streamContents: [ :stream |		self do: [ :each |			each isVisible ifTrue: [				[ each validate: (anObject readUsing: each) ]					on: MAValidationError					do: [ :err | stream nextPut: err ] ] ] ].	errors isEmpty		ifFalse: [ MAMultipleErrors on: self errors: errors ]! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!with: aCollection do: aBlock	self children with: aCollection do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!withIndexDo: aBlock	self children withIndexDo: aBlock! !!MAPriorityContainer commentStamp: 'lr 2/12/2006 19:34' prior: 0!I am a container holding a collection of descriptions and I keep them sorted according to their priority.!!MAPriorityContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultCollection	^ SortedCollection new! !!MAPriorityContainer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitPriorityContainer: self! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!resort	self setChildren: self children copy! !!MAPriorityContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	super setChildren: aCollection asSortedCollection! !!MADescription class methodsFor: 'instance-creation-accessor' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor	^ self accessor: anAccessor label: self defaultLabel! !!MADescription class methodsFor: 'instance-creation-accessor' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor label: aString	^ self accessor: anAccessor label: aString priority: self defaultPriority! !!MADescription class methodsFor: 'instance-creation-accessor' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor label: aString priority: aNumber	^ self accessor: anAccessor label: aString priority: aNumber default: self defaultDefault! !!MADescription class methodsFor: 'instance-creation-accessor' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor label: aString priority: aNumber default: anObject	^ self new		accessor: anAccessor;		label: aString;		priority: aNumber;		default: anObject;		yourself! !!MADescription class methodsFor: 'instance-creation-auto' stamp: 'lr 3/9/2006 11:32'!auto: aSelector	^ self accessor: (MAAutoSelectorAccessor selector: aSelector)! !!MADescription class methodsFor: 'instance-creation-auto' stamp: 'lr 3/9/2006 11:32'!auto: aSelector label: aString	^ self accessor: (MAAutoSelectorAccessor selector: aSelector) label: aString! !!MADescription class methodsFor: 'instance-creation-auto' stamp: 'lr 3/9/2006 11:32'!auto: aSelector label: aString priority: aNumber	^ self accessor: (MAAutoSelectorAccessor selector: aSelector) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-auto' stamp: 'lr 3/9/2006 11:32'!auto: aSelector label: aString priority: aNumber default: anObject	^ self accessor: (MAAutoSelectorAccessor selector: aSelector) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultAccessor	^ MANullAccessor new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultComment	^ nil! !!MADescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClass	^ self defaultComponentClasses isEmpty		ifTrue: [ MAUndefinedComponent ]		ifFalse: [ self defaultComponentClasses first ]! !!MADescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAUndefinedComponent! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultConditions	^ Array new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultDefault	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultLabel	^ String new! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClass	^ self defaultMorphClasses notEmpty		ifTrue: [ self defaultMorphClasses first ]! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array new! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphColor	^ Color r: 0.151 g: 0.327 b: 0.720! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPersistent	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPriority	^ 0! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultReadonly	^ false! !!MADescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReportColumnClass	^ self defaultReportColumnClasses notEmpty		ifTrue: [ self defaultReportColumnClasses first ]! !!MADescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReportColumnClasses	^ Array with: MADescribedColumn! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultRequired	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringReader	^ MAStringReader! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringWriter	^ MAStringWriter! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultUndefined	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultVisible	^ true! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionComment	^ MAMemoDescription selector: #comment label: 'Comment' priority: 110 default: self defaultComment! !!MADescription class methodsFor: '*magritte-seaside-description' stamp: 'lr 3/9/2006 11:33'!descriptionComponentClass	^ (MASingleOptionDescription selector: #componentClass label: 'Component Class' priority: 1000)		reference: MAClassDescription new;		options: self defaultComponentClasses;		default: self defaultComponentClass;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionDefault	^ self isAbstract		ifFalse: [ self selector: #default label: 'Default' priority: 130 default: self defaultDefault ]! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionLabel	^ MAStringDescription selector: #label label: 'Label' priority: 100 default: self defaultLabel! !!MADescription class methodsFor: '*magritte-morph-description' stamp: 'lr 3/9/2006 11:33'!descriptionMorphClass	^ (MASingleOptionDescription selector: #morphClass label: 'Morph Class' priority: 2000)		reference: MAClassDescription new;		options: self defaultMorphClasses;		default: self defaultMorphClass;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2006 10:31'!descriptionName	^ (MAStringDescription selector: #name label: 'Kind' priority: 0)		beReadonly;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionPersistent	^ MABooleanDescription selector: #persistent label: 'Persistent' priority: 230 default: self defaultPersistent! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionPriority	^ (MANumberDescription selector: #priority label: 'Priority' priority: 130 default: self defaultPriority)		beRequired;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionReadonly	^ MABooleanDescription selector: #readonly label: 'Readonly' priority: 200 default: self defaultReadonly! !!MADescription class methodsFor: '*magritte-seaside-description' stamp: 'lr 3/9/2006 11:33'!descriptionReportColumnClass	^ (MASingleOptionDescription selector: #reportColumnClass label: 'Report Column Class' priority: 1010)		reference: MAClassDescription new;		options: self defaultReportColumnClasses;		default: self defaultReportColumnClass;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionRequired	^ MABooleanDescription selector: #required label: 'Required' priority: 220 default: self defaultRequired! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionStringReader	^ (MASingleOptionDescription selector: #stringReader label: 'String Reader' priority: 300 default: self defaultStringReader)		reference: MAClassDescription new;		options: (MADynamicObject on: [ self defaultStringReader withAllSubclasses ]);		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionStringWriter	^ (MASingleOptionDescription selector: #stringWriter label: 'String Writer' priority: 310 default: self defaultStringWriter)		reference: MAClassDescription new;		options: (MADynamicObject on: [ self defaultStringWriter withAllSubclasses ]);		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionUndefined	^ MAStringDescription selector: #undefined label: 'Undefined String' priority: 140 default: self defaultUndefined! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionVisible	^ MABooleanDescription selector: #visible label: 'Visible' priority: 210 default: self defaultVisible! !!MADescription class methodsFor: 'instance-creation-null' stamp: 'lr 3/9/2006 11:32'!null	^ self accessor: (MANullAccessor uuid: MACompatibility uuid)! !!MADescription class methodsFor: 'instance-creation-null' stamp: 'lr 3/9/2006 11:32'!null: anUuid	^ self accessor: (MANullAccessor uuid: anUuid)! !!MADescription class methodsFor: 'instance-creation-null' stamp: 'lr 3/9/2006 11:32'!null: anUuid label: aString	^ self accessor: (MANullAccessor uuid: anUuid) label: aString! !!MADescription class methodsFor: 'instance-creation-null' stamp: 'lr 3/9/2006 11:32'!null: anUuid label: aString priority: aNumber	^ self accessor: (MANullAccessor uuid: anUuid) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-null' stamp: 'lr 3/9/2006 11:32'!null: anUuid label: aString priority: aNumber default: anObject	^ self accessor: (MANullAccessor uuid: anUuid) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'instance-creation-block' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock	^ self accessor: (MABlockAccessor read: aReadBlock write: aWriteBlock)! !!MADescription class methodsFor: 'instance-creation-block' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock label: aString	^ self accessor: (MABlockAccessor read: aReadBlock write: aWriteBlock) label: aString! !!MADescription class methodsFor: 'instance-creation-block' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock label: aString priority: aNumber	^ self accessor: (MABlockAccessor read: aReadBlock write: aWriteBlock) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-block' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock label: aString priority: aNumber default: anObject	^ self accessor: (MABlockAccessor read: aReadBlock write: aWriteBlock) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'instance-creation-selector' stamp: 'lr 3/9/2006 11:32'!selector: aSelector	^ self accessor: (MASelectorAccessor selector: aSelector)! !!MADescription class methodsFor: 'instance-creation-selector' stamp: 'lr 3/9/2006 11:32'!selector: aSelector label: aString	^ self accessor: (MASelectorAccessor selector: aSelector) label: aString! !!MADescription class methodsFor: 'instance-creation-selector' stamp: 'lr 3/9/2006 11:32'!selector: aSelector label: aString priority: aNumber	^ self accessor: (MASelectorAccessor selector: aSelector) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-selector' stamp: 'lr 3/9/2006 11:32'!selector: aSelector label: aString priority: aNumber default: anObject	^ self accessor: (MASelectorAccessor selector: aSelector) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'instance-creation-cascade' stamp: 'lr 5/15/2006 20:48'!selectors: anArray	^ self accessor: (MAChainAccessor selectors: anArray)! !!MADescription class methodsFor: 'instance-creation-cascade' stamp: 'lr 5/15/2006 20:48'!selectors: anArray label: aString	^ self accessor: (MAChainAccessor selectors: anArray) label: aString! !!MADescription class methodsFor: 'instance-creation-cascade' stamp: 'lr 5/15/2006 20:48'!selectors: anArray label: aString priority: aNumber	^ self accessor: (MAChainAccessor selectors: anArray) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-cascade' stamp: 'lr 5/15/2006 20:48'!selectors: anArray label: aString priority: aNumber default: anObject	^ self accessor: (MAChainAccessor selectors: anArray) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'instance-creation-variable' stamp: 'lr 3/9/2006 11:32'!variable: aSymbol	^ self accessor: (MAVariableAccessor name: aSymbol)! !!MADescription class methodsFor: 'instance-creation-variable' stamp: 'lr 3/9/2006 11:32'!variable: aSymbol label: aString	^ self accessor: (MAVariableAccessor name: aSymbol) label: aString! !!MADescription class methodsFor: 'instance-creation-variable' stamp: 'lr 3/9/2006 11:32'!variable: aSymbol label: aString priority: aNumber	^ self accessor: (MAVariableAccessor name: aSymbol) label: aString priority: aNumber! !!MADescription class methodsFor: 'instance-creation-variable' stamp: 'lr 3/9/2006 11:32'!variable: aSymbol label: aString priority: aNumber default: anObject	^ self accessor: (MAVariableAccessor name: aSymbol) label: aString priority: aNumber default: anObject! !!MADescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!version	^ 1! !!MADescription methodsFor: 'operators' stamp: 'lr 5/27/2006 17:18'!, aDescription	"Concatenate the receiver and <code>aDescription</code> to one composed description. Answer a description container containing both descriptions."	^ self asContainer copy		addAll: aDescription asContainer;		yourself! !!MADescription methodsFor: 'operators' stamp: 'lr 5/27/2006 17:17'!<= anObject	"Answer whether the receiver should precede <code>anObject</code> in a priority container."	^ self priority <= anObject priority! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]! !!MADescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDescription: self! !!MADescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!accessor	"Answer the access-strategy of the model-value described by the receiver."	^ accessor ifNil: [ accessor := self class defaultAccessor ]! !!MADescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!accessor: anAccessor	accessor := anAccessor! !!MADescription methodsFor: 'validation' stamp: 'lr 3/9/2006 11:32'!addCondition: aCondition	self addCondition: aCondition labelled: aCondition asString! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:15'!addCondition: aCondition labelled: aString	"Add <code>aCondition</code> as an additional validation condition to the receiver and give it the label <code>aString</code>. The first argument is either a block-context, a composite of the subclasses of *MACondition*, or any other object that responds to <code>#value:</code> with <code>true</code> or <code>false</code>."	self conditions: (self conditions		copyWith: (Association			key: aCondition			value: aString))! !!MADescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	"Answer a description container of the receiver."	self subclassResponsibility! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beEphemeral	self persistent: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beHidden	self visible: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOptional	self required: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!bePersistent	self persistent: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beReadonly	self readonly: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beRequired	self required: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beVisible	self visible: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beWriteable	self readonly: false! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment	"Answer a comment or help-text giving a hint what this description is used for. GUIs that are built from this description might display it as a tool-tip."	^ self propertyAt: #comment ifAbsent: [ self class defaultComment ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment: aString	self propertyAt: #comment put: aString! !!MADescription methodsFor: 'accessing-configuration' stamp: 'lr 6/2/2006 08:50'!comparators	^ MATrueCondition new! !!MADescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!componentClass	^ self propertyAt: #componentClass ifAbsent: [ self class defaultComponentClass ]! !!MADescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!componentClass: aClass	^ self propertyAt: #componentClass put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!conditions	"Answer a collection of additional conditions that need to be fulfilled so that the described model is valid. Internally the collection associates conditions, that are either blocks or subclasses of *MACondition*, with an error string."	^ self propertyAt: #conditions ifAbsent: [ self class defaultConditions ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!conditions: anArray	self propertyAt: #conditions put: anArray! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!fromString: aString	"Answer an object being parsed from <code>aString</code>."	^ self fromString: aString reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!fromString: aString reader: aParser	"Answer an object being parsed from <code>aString</code> using <code>aParser</code>."	^ aParser read: aString readStream description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:16'!fromStringCollection: aCollection	"Answer a collection of objects being parsed from <code>aCollection</code> of strings."	^ self fromStringCollection: aCollection reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:16'!fromStringCollection: aCollection reader: aParser	"Answer a collection of objects being parsed from <code>aCollection</code> of strings using <code>aParser</code>."	^ aCollection collect: [ :each | self fromString: each reader: aParser ]! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:16'!hasChildren	"Answer <code>true</code> if the receiver has any child-descriptions. A description container usually has children."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:16'!hasComment	"Answer <code>true</code> if the the receiver has got a non empty comment."	^ self comment isEmptyOrNil not! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:16'!hasLabel	"Answer <code>true</code> if the the receiver has got a non empty label."	^ self label isEmptyOrNil not! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self accessor hash! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:16'!isContainer	"Answer <code>true</code> if the receiver is a description container."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:16'!isDescription	"Answer <code>true</code> if the receiver is a description."	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isPersistent	^ self persistent! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isReadonly	^ self readonly! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isRequired	^ self required! !!MADescription methodsFor: 'validation' stamp: 'lr 5/29/2006 10:10'!isSatisfiedBy: anObject	"Answer <code>true</code> if 	<code>anObject</code> is a valid instance of the receiver's description."	[ self validate: anObject ]		on: MAValidationError		do: [ :err | ^ false ].	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isVisible	^ self visible! !!MADescription methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!kind	"Answer the base-class (type) the receiver is describing. The default implementation answers the most generic class: Object, the root of the Smalltalk class hierarchy. Subclasses might refine this choice."	^ Object! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label	"Answer the label of the receiving description. The label is mostly used as an identifier that is printed next to the input field when building a GUI from the receiver."	^ self propertyAt: #label ifAbsent: [ self class defaultLabel ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label: aString	self propertyAt: #label put: aString! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphClass	^ self propertyAt: #morphClass ifAbsent: [ self class defaultMorphClass ]! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphClass: aClass	^ self propertyAt: #morphClass put: aClass! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphColor	^ self propertyAt: #morphColor ifAbsent: [ self class defaultMorphColor ]! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphColor: aColor	^ self propertyAt: #morphColor put: aColor! !!MADescription methodsFor: 'accessing-configuration' stamp: 'lr 4/10/2006 10:31'!name	"Answer the name of the description, a human-readable string describing the type."	^ self class label! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 5/29/2006 09:18'!persistent	"Answer <code>true</code> if the model described by the receiver is persistent."	^ self propertyAt: #persistent ifAbsent: [ self class defaultPersistent ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!persistent: aBoolean	self propertyAt: #persistent put: aBoolean! !!MADescription methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self accessor: self accessor copy! !!MADescription methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 5/29/2006 09:19'!priority	"Answer a number that is the priority of the receiving description. Priorities are used to give descriptions an explicit order by sorting them according to this number."	^ self propertyAt: #priority ifAbsent: [ self class defaultPriority ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!priority: aNumber	self propertyAt: #priority put: aNumber! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 6/2/2006 09:19'!readonly	"Answer <code>true</code> if the model described by the receiver is read-only."	^ self propertyAt: #readonly ifAbsent: [ self class defaultReadonly ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!readonly: aBoolean	self propertyAt: #readonly put: aBoolean! !!MADescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!reportColumnClass	^ self propertyAt: #reportColumnClass ifAbsent: [ self class defaultReportColumnClass ]! !!MADescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!reportColumnClass: aClass	^ self propertyAt: #reportColumnClass put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 6/2/2006 09:19'!required	"Answer <code>true</code> if the model described by the receiver is required, this is it cannot be <code>nil</code>."	^ self propertyAt: #required ifAbsent: [ self class defaultRequired ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!required: aBoolean	self propertyAt: #required put: aBoolean! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:07'!stringReader	"Answer a Visitor that can be used to parse the model described by the receiver from a string."	^ self propertyAt: #stringReader ifAbsent: [ self class defaultStringReader ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringReader: aClass	self propertyAt: #stringReader put: aClass! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:10'!stringWriter	"Answer a Visitor that can be used to convert the model described by the receiver to a string."	^ self propertyAt: #stringWriter ifAbsent: [ self class defaultStringWriter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringWriter: aClass	self propertyAt: #stringWriter put: aClass! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!toString: anObject	"Answer a string being formatted from <code>anObject</code>."	^ self toString: anObject writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> using <code>aFormatter</code>."	^ aFormatter write: anObject description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!toStringCollection: aCollection	"Answer a collection of strings being formatted from <code>aCollection</code>."	^ self toStringCollection: aCollection writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17'!toStringCollection: aCollection writer: aFormatter	"Answer a collection of strings being formatted from <code>aCollection</code> using <code>aFormatter</code>."	^ aCollection collect: [ :each | self toString: each writer: aFormatter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 08:59'!undefined	"Answer a string that is printed whenever the model described by the receiver is <code>nil</code>."	^ (self propertyAt: #undefined ifAbsent: [ self class defaultUndefined ])		ifNil: [ self class defaultUndefined ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!undefined: aString	self propertyAt: #undefined put: aString! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:16'!validate: anObject	"Validate <code>anObject</code> in the context of the describing-receiver, raises an error in case of a problem. If <code>anObject</code> is <code>nil</code> and not required, most tests will be skipped. Do not override this message, instead have a look at <code>#validateSpecific:</code> what is usually a better place to define the behaviour your description requires."	self validateRequired: anObject.	anObject isNil ifFalse: [		self			validateKind: anObject;			validateSpecific: anObject;			validateConditions: anObject ]! !!MADescription methodsFor: 'validation' stamp: 'lr 3/9/2006 11:32'!validate: anObject description: aDescription	[ aDescription validate: anObject ]		on: MAValidationError		do: [ :err | err setDescription: self; pass ]! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:15'!validateConditions: anObject	"Validate <code>anObject</code> to satisfy all its custom conditions."	self conditions do: [ :each |		(each key value: anObject)			ifFalse: [ MAConditionError on: self explanation: each value ] ]! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:15'!validateKind: anObject	"Validate <code>anObject</code> to be of the right kind."	(anObject isKindOf: self kind)		ifFalse: [ MAKindError on: self ]! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:15'!validateRequired: anObject	"Validate <code>anObject</code> not to be <code>nil</code> if it is required."	(self isRequired and: [ anObject isNil ])		ifTrue: [ MARequiredError on: self ]! !!MADescription methodsFor: 'validation' stamp: 'lr 5/27/2006 17:15'!validateSpecific: anObject	"Validate <code>anObject</code> to satisfy all its description specific validation rules. Subclasses mostly want to override this method."! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 6/2/2006 09:19'!visible	"Answer <code>true</code> if the model described by the receiver is visible, as an opposite to hidden."	^ self propertyAt: #visible ifAbsent: [ self class defaultVisible ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !!MAElementDescription commentStamp: '<historical>' prior: 0!I am an abstract description for all basic description types.!!MABooleanDescription commentStamp: 'lr 6/2/2006 00:48' prior: 0!I am a description of the Boolean values <code>true</code> and <code>false</code>. My visual representation could be a check-box.!!MABooleanDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MACheckboxComponent with: MASelectListComponent with: MARadioGroupComponent! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseString	^ self defaultFalseStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseStrings	^ #( 'false' 'f' 'no' 'n' '0' 'off' )! !!MABooleanDescription class methodsFor: '*magritte-morph-default' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MACheckboxMorph with: MASingleSelectListMorph! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueString	^ self defaultTrueStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueStrings	^ #( 'true' 't' 'yes' 'y' '1' 'on' )! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:32'!descriptionFalseString	^ MAStringDescription selector: #falseString label: 'False String' priority: 410 default: self defaultFalseString! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:32'!descriptionRequired	^ nil! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:32'!descriptionTrueString	^ MAStringDescription selector: #trueString label: 'True String' priority: 400 default: self defaultTrueString! !!MABooleanDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MABooleanDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Boolean'! !!MABooleanDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitBooleanDescription: self! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptions	^ self options! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptionsWith: anObject	^ self options! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!falseString	^ self propertyAt: #falseString ifAbsent: [ self class defaultFalseString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!falseString: aString	^ self propertyAt: #falseString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!falseStrings	^ self class defaultFalseStrings! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!isExtensible	^ false! !!MABooleanDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!kind	^ Boolean! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!options	^ Array with: false with: true! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!reference	^ self! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!trueString	^ self propertyAt: #trueString ifAbsent: [ self class defaultTrueString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!trueString: aString	^ self propertyAt: #trueString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!trueStrings	^ self class defaultTrueStrings! !!MAClassDescription commentStamp: '<historical>' prior: 0!I am a description of Smalltalk classes, possible values can be any of <code>Smalltalk allClasses</code>.!!MAClassDescription class methodsFor: '*magritte-seaside-accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextInputComponent! !!MAClassDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAClassDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Class'! !!MAClassDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitClassDescription: self! !!MAClassDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!kind	^ Class! !!MAColorDescription commentStamp: '<historical>' prior: 0!I am a description of colors, possible values are instances of <code>Color</code>. My visual representation could be a color-chooser.!!MAColorDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAColorComponent! !!MAColorDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAColorDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Color'! !!MAColorDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitColorDescription: self! !!MAColorDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!kind	^ Color! !!MAElementDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultAttributes	^ WAHtmlAttributes new! !!MAElementDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MATextMorph! !!MAElementDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitElementDescription: self! !!MAElementDescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ MAContainer with: self! !!MAElementDescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 4/10/2006 10:54'!attributes	^ self propertyAt: #attributes ifAbsentPut: [ self class defaultAttributes ]! !!MAElementDescription methodsFor: '*magritte-seaside-accessing' stamp: 'lr 3/9/2006 11:33'!attributes: aDictionary	^ self propertyAt: #attributes put: aDictionary! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default	^ self propertyAt: #default ifAbsent: [ self class defaultDefault ]! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default: anObject	self propertyAt: #default put: anObject! !!MAFileDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of files, their contents, filename and mime-type. Possible values include instances of *MAFileModel*. My visual representation could be a file-upload dialog.!!MAFileDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAFileUploadComponent! !!MAFileDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAFileMorph! !!MAFileDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAFileDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'File'! !!MAFileDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitFileDescription: self! !!MAFileDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ MAFileModel! !!MAMagnitudeDescription commentStamp: '<historical>' prior: 0!I am an abstract description for subclasses of <code>Magnitude</code>. The range of accepted values can be limited using the accessors <code>min:</code> and <code>max:</code>.!!MADateDescription commentStamp: '<historical>' prior: 0!I am a description of dates, possible values are instances of <code>Date</code>. My visual representation could be a date-picker.!!MADateDescription class methodsFor: '*magritte-seaside' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MADateInputComponent! !!MADateDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADateDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Date'! !!MADateDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDateDescription: self! !!MADateDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Date! !!MADurationDescription commentStamp: '<historical>' prior: 0!I am a description of durations, possible values are instances of <code>Duration</code>.!!MADurationDescription class methodsFor: '*magritte-seaside' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextInputComponent! !!MADurationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MADurationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Duration'! !!MADurationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDurationDescription: self! !!MADurationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Duration! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMax	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMin	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionMax	^ self selector: #max label: 'Maximum' priority: 410! !!MAMagnitudeDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionMin	^ self selector: #min label: 'Min' priority: 400! !!MAMagnitudeDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMagnitudeDescription: self! !!MAMagnitudeDescription methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!comparators	^ Array		with: (MAComparator			selector: #>			descriptions: (Array				with: (self class new label: 'greater than')))		with: (MAComparator			selector: #<			descriptions: (Array				with: (self class new label: 'less than')))		with: (MAComparator			selector: #between:and:			descriptions: (Array				with: (self class new label: 'between')				with: (self class new label: 'and')))! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isWithinRange: anObject	^ (self min isNil or: [ self min <= anObject ])		and: [ self max isNil or: [ self max >= anObject ] ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!max	^ self propertyAt: #max ifAbsent: [ self class defaultMax ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:19'!max: aMagnitudeOrNil	"Set the maximum for accepted values, or <code>nil</code> if open."	^ self propertyAt: #max put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!min	^ self propertyAt: #min ifAbsent: [ self class defaultMin ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:19'!min: aMagnitudeOrNil	"Set the minimum for accepted values, or <code>nil</code> if open."	^ self propertyAt: #min put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'conveniance' stamp: 'lr 6/2/2006 00:19'!min: aMinimumObject max: aMaximumObject	"Set the minimum and maximum of accepted values, or <code>nil</code> if open."	self min: aMinimumObject; max: aMaximumObject! !!MAMagnitudeDescription methodsFor: 'validation' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	(self isWithinRange: anObject)		ifFalse: [ MARangeError on: self ]! !!MANumberDescription commentStamp: 'lr 2/12/2006 19:36' prior: 0!I am a description of numbers, possible values are instances of <code>Number</code> and all its subclasses, including <code>Integer</code> and <code>Float</code>. My visual representation could be a number input-box or even a slider-control.!!MANumberDescription class methodsFor: '*magritte-seaside' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextInputComponent with: MARangeComponent! !!MANumberDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANumberDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Number'! !!MANumberDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitNumberDescription: self! !!MANumberDescription methodsFor: 'conveniance' stamp: 'lr 3/9/2006 11:32'!beInteger	self addCondition: [ :value | value isInteger ] asCondition labelled: 'No integer was entered'! !!MANumberDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Number! !!MATimeDescription commentStamp: '<historical>' prior: 0!I am a description of times, possible values are instances of <code>Time</code>. My visual representation could be a time-picker.!!MATimeDescription class methodsFor: '*magritte-seaside' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATimeInputComponent! !!MATimeDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Time'! !!MATimeDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTimeDescription: self! !!MATimeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Time! !!MATimeStampDescription commentStamp: '<historical>' prior: 0!I am a description of timestamps, possible values are instances of <code>TimeStamp</code>. My visual representation could be a date- and time-picker.!!MATimeStampDescription class methodsFor: '*magritte-seaside' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATimeStampInputComponent! !!MATimeStampDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeStampDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Timestamp'! !!MATimeStampDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTimeStampDescription: self! !!MATimeStampDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ TimeStamp! !!MAReferenceDescription commentStamp: 'lr 2/12/2006 19:38' prior: 0!I am an abstract superclass for descriptions holding onto another description.!!MAOptionDescription commentStamp: 'lr 6/2/2006 09:36' prior: 0!I am an abstract description of different options the user can choose from. My instance variable <code>options</code> references the options I am representing. The options can be sorted or unsorted.!!MAMultipleOptionDescription commentStamp: 'lr 2/12/2006 19:39' prior: 0!I am a description of multiple options, possible options are stored within the <code>options</code> field, possible values are instances of <code>Collection</code>. My visual representation could be a multi-select list or a group of check-boxes.!!MAMultipleOptionDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAMultiselectListComponent with: MACheckboxGroupComponent with: MAListCompositonComponent! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultDistinct	^ false! !!MAMultipleOptionDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAMultiSelectListMorph! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOrdered	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionDistinct	^ MABooleanDescription selector: #distinct label: 'Distinct' priority: 250 default: self defaultDistinct! !!MAMultipleOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionOrdered	^ MABooleanDescription selector: #ordered label: 'Ordered' priority: 260 default: self defaultOrdered! !!MAMultipleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Multiple-Option'! !!MAMultipleOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMultipleOptionDescription: self! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beDistinct	self distinct: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beIndefinite	self distinct: false! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOrdered	self ordered: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnordered	self ordered: false! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct	^ self propertyAt: #distinct ifAbsent: [ self class defaultDistinct ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct: aBoolean	self propertyAt: #distinct put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isDistinct	^ self distinct! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isOrdered	^ self ordered! !!MAMultipleOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Collection! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateKind: anObject	super validateKind: anObject.	(anObject allSatisfy: [ :each | self options includes: each ])		ifFalse: [ MAKindError on: self ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection ] and: [ anObject isEmpty ])		ifTrue: [ MARequiredError on: self ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	anObject do: [ :each | self validate: each description: self reference ]! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOptions	^ OrderedCollection new! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSorted	^ false! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionDefault	^ nil! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionOptions	^ MAMemoDescription selector: #optionsTextual label: 'Options' priority: 410 default: self defaultOptions! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionSorted	^ MABooleanDescription selector: #sorted label: 'Sorted' priority: 240 default: self defaultSorted! !!MAOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitOptionDescription: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allOptions	^ self prepareOptions: self options copy! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!allOptionsWith: anObject	^ self prepareOptions: ((self shouldNotInclude: anObject)		ifFalse: [ self options copyWith: anObject ]		ifTrue: [ self options copy ])! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beSorted	self sorted: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnsorted	self sorted: false! !!MAOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isSorted	^ self sorted! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options	^ options ifNil: [ options := self class defaultOptions ]! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options: anArray	options := anArray! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!optionsTextual	^ (self reference toStringCollection: self options)		asMultilineString! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!optionsTextual: aString	^ self options: (self reference fromStringCollection: aString lines)! !!MAOptionDescription methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self options: self options copy! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!prepareOptions: aCollection	^ aCollection asArray in: [ :result |		self isSorted			ifTrue: [ result sort: self sortBlock ]			ifFalse: [ result ] ]! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!shouldNotInclude: anObject	^ anObject isNil or: [ self options includes: anObject ]! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!sortBlock	^ [ :a :b | (self reference toString: a) caseInsensitiveLessOrEqual: (self reference toString: b) ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!sorted: aBoolean	^ self propertyAt: #sorted put: aBoolean! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!undefined: aString	super undefined: aString.	self reference isNil		ifFalse: [ self reference undefined: aString ]! !!MASingleOptionDescription commentStamp: 'lr 2/12/2006 19:40' prior: 0!I am a description of a single option, possible values are stored within the <code>options</code> field, but I might also be extensible so that the user can add its own option. My visual representation could be a drop-down list or a group of option-buttons.!!MASingleOptionDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MASelectListComponent with: MARadioGroupComponent! !!MASingleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultExtensible	^ false! !!MASingleOptionDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MASingleSelectListMorph! !!MASingleOptionDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:33'!descriptionExtensible	^ MABooleanDescription selector: #extensible label: 'Extensible' priority: 250 default: self defaultExtensible! !!MASingleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASingleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Single-Option'! !!MASingleOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitSingleOptionDescription: self! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beExtensible	self extensible: true! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beLimited	self extensible: false! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible	^ self propertyAt: #extensible ifAbsent: [ self class defaultExtensible ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible: aBoolean	self propertyAt: #extensible put: aBoolean! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isExtensible	^ self extensible! !!MASingleOptionDescription methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!prepareOptions: aCollection	^ self isRequired		ifTrue: [ super prepareOptions: aCollection ]		ifFalse: [			(super prepareOptions: aCollection)				copyWithFirst: nil ]! !!MASingleOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:32'!shouldNotInclude: anObject	^ self isExtensible not		or: [ super shouldNotInclude: anObject ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateKind: anObject	super validateKind: anObject.	(self isExtensible or: [ self options includes: anObject ])		ifFalse: [ MAKindError on: self ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	self validate: anObject description: self reference! !!MAReferenceDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ MAStringDescription new! !!MAReferenceDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionReference	^ (MAToOneRelationDescription selector: #reference label: 'Description' priority: 400)		classes: (MADynamicObject on: [ MADescription withAllConcreteClasses ]);		beRequired;		yourself! !!MAReferenceDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitReferenceDescription: self! !!MAReferenceDescription methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self reference: self reference copy! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference	^ reference ifNil: [ reference := self class defaultReference ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference: aDescription	reference := aDescription! !!MARelationDescription commentStamp: 'lr 6/2/2006 09:36' prior: 0!I am an abstract description for descriptions representing a relation. My instance variable <code>classes</code> references a collection of possible classes that I can relate to. If required the reference description will be automatically built from this list of classes.!!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultClasses	^ Set new! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ nil! !!MARelationDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionClasses	^ (MAMultipleOptionDescription selector: #classes label: 'Classes' priority: 400)		options: (MADynamicObject on: [ Smalltalk allClasses ]);		reference: MAClassDescription new;		yourself! !!MARelationDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionReference	^ super descriptionReference		classes: (MADynamicObject on: [ MAContainer withAllConcreteClasses ]);		beOptional;		yourself! !!MARelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitRelationDescription: self! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allClasses	^ (Array withAll: self classes)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes	^ classes ifNil: [ classes := self class defaultClasses ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes: aCollection	classes := aCollection! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/27/2006 17:20'!commonClass	"Answer a common superclass of the classes of the receiver. The algorithm is implemented to be as efficient as possible. The inner loop will be only executed the first few iterations."	| current |	self classes isEmpty		ifTrue: [ ^ self class descriptionContainer ].	current := self classes anyOne.	self classes do: [ :each |		[ each includesBehavior: current ]			whileFalse: [ current := current superclass ] ].	^ current! !!MARelationDescription methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self classes: self classes copy! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 6/2/2006 00:20'!reference	"The reference within a *MARelationDescription* is calculated automatically from all the classes of the receiver, if set to <code>nil</code>. By setting the reference to a *MAContainer* instance it is possible to customize the reference description."	^ super reference ifNil: [ self commonClass description ]! !!MAToManyRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-many relationship, possible values are instances of <code>Collection</code>.!!MAToManyRelationDescription class methodsFor: '*magritte-seaside-accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAOneToManyComponent! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 18:53'!defaultDefinitive	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/15/2006 15:02'!defaultOrdered	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 19:16'!defaultSorted	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'dc 4/16/2006 18:53'!descriptionDefinitive	^ MABooleanDescription selector: #definitive label: 'Definitive' priority: 265 default: self defaultDefinitive! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'dc 4/15/2006 15:02'!descriptionOrdered	^ MABooleanDescription selector: #ordered label: 'Ordered' priority: 260 default: self defaultOrdered! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'dc 4/16/2006 19:16'!descriptionSorted	^ MABooleanDescription selector: #sorted label: 'Sorted' priority: 240 default: self defaultSorted! !!MAToManyRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:m Relation'! !!MAToManyRelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitToManyRelationDescription: self! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:51'!beDefinitive	self definitive: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:56'!beModifiable	self definitive: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beOrdered	self ordered: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beSorted	self sorted: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beUnordered	self ordered: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beUnsorted	self sorted: false! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 18:50'!definitive	^ self propertyAt: #definitive ifAbsent: [ self class defaultDefinitive ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 18:51'!definitive: aBoolean	self propertyAt: #definitive put: aBoolean! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/16/2006 18:51'!isDefinitive	^ self definitive! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/15/2006 15:01'!isOrdered	^ self ordered! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/16/2006 19:15'!isSorted	^ self sorted! !!MAToManyRelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Collection! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 19:15'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 19:15'!sorted: aBoolean	^ self propertyAt: #sorted put: aBoolean! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateKind: anObject	super validateKind: anObject.	anObject do: [ :object |		(self classes anySatisfy: [ :class | object species = class ])			ifFalse: [ MAKindError on: self ] ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection ] and: [ anObject isEmpty ])		ifTrue: [ MARequiredError on: self ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	anObject do: [ :each | self validate: each description: each description ]! !!MAToOneRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-one relationship.!!MAToOneRelationDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MAExternalEditorComponent with: MAInternalEditorComponent! !!MAToOneRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToOneRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:1 Relation'! !!MAToOneRelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitToOneRelationDescription: self! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateKind: anObject	super validateKind: anObject.	(self classes anySatisfy: [ :class | anObject species = class ])		ifFalse: [ MAKindError on: self ]! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	self validate: anObject description: anObject description! !!MATableDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of tables, their cells and labels. I hold a reference to the description of my cells, that are all described using the same description. Possible values include instances of *MATableModel*.!!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultColumnLabels	^ OrderedCollection with: 'a' with: 'b' with: 'c'! !!MATableDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATableComponent! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultRowLabels	^ OrderedCollection with: '1' with: '2' with: '3'! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionColumnLabels	^ MAMemoDescription selector: #columnLabelsTextual label: 'Column Labels' priority: 250! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionDefault	^ nil! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionRequired	^ nil! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionRowLabels	^ MAMemoDescription selector: #rowLabelsTextual label: 'Row Labels' priority: 250! !!MATableDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATableDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Table'! !!MATableDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTableDescription: self! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	^ self columnLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels	^ self propertyAt: #columnLabels ifAbsent: [ self class defaultColumnLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels: aCollection	self propertyAt: #columnLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual	^ (MAStringDescription new toStringCollection: self columnLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual: aString	self columnLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ MATableModel! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	^ self rowLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels	^ self propertyAt: #rowLabels ifAbsent: [ self class defaultRowLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels: aCollection	self propertyAt: #rowLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual	^ (MAStringDescription new toStringCollection: self rowLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual: aString	self rowLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'validation' stamp: 'lr 3/9/2006 11:32'!validateSpecific: anObject	super validateSpecific: anObject.	(anObject rowCount ~= self rowCount		or: [ anObject columnCount ~= self columnCount ])			ifTrue: [ MAKindError on: self ].	anObject contents do: [ :each |		self validate: each description: self reference ]! !!MATokenDescription commentStamp: 'lr 2/12/2006 19:43' prior: 0!I am a description of tokens all described by the referenced description, possible values are instances of <code>SequenceableCollection</code>.!!MATokenDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextInputComponent! !!MATokenDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATokenDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Token'! !!MATokenDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTokenDescription: self! !!MATokenDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Array! !!MAStringDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of strings, possible values are instances of <code>String</code>. My visual representation could be a single line text-field. Use *MAMemoDescription* for multi-line strings.!!MAMemoDescription commentStamp: 'lr 2/12/2006 19:43' prior: 0!I am a description of multiline strings, possible values are instances of <code>String</code>. My visual representation could be a text-area field.!!MAMemoDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextAreaComponent! !!MAMemoDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultLineCount	^ 3! !!MAMemoDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAMemoMorph! !!MAMemoDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionLineCount	^ (MANumberDescription selector: #lineCount label: 'Number of Lines' priority: 400 default: self defaultLineCount)		beInteger; min: 1;		yourself! !!MAMemoDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Memo'! !!MAMemoDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMemoDescription: self! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!lineCount: anInteger	^ self propertyAt: #lineCount put: anInteger! !!MAPasswordDescription commentStamp: 'lr 2/12/2006 19:44' prior: 0!I am a description of a password string, possible values are instances of <code>String</code>. My visual representation could be a password field, where there are stars printed instead of the characters the user enters.!!MAPasswordDescription class methodsFor: '*magritte-seaside-default' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextPasswordComponent with: MATextInputComponent! !!MAPasswordDescription class methodsFor: '*magritte-morph-default' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAPasswordMorph! !!MAPasswordDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Password'! !!MAPasswordDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitPasswordDescription: self! !!MAPasswordDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isObfuscated: anObject	^ anObject notNil		and: [ anObject isString ]		and: [ anObject allSatisfy: [ :each | each = $* ] ]! !!MAPasswordDescription methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!obfuscated: anObject	^ String new: (self toString: anObject) size withAll: $*! !!MAStringDescription class methodsFor: '*magritte-seaside-defaults' stamp: 'lr 3/9/2006 11:33'!defaultComponentClasses	^ Array with: MATextInputComponent! !!MAStringDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStringDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'String'! !!MAStringDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitStringDescription: self! !!MAStringDescription methodsFor: 'accessing' stamp: 'rjl 4/26/2006 20:42'!autoCompleteWith	^self propertyAt: #autoCompleteWith ifAbsent: [ nil ]! !!MAStringDescription methodsFor: 'accessing' stamp: 'lr 5/5/2006 19:21'!autoCompleteWith: aCollection	self propertyAt: #autoCompleteWith put: aCollection! !!MAStringDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!comparators	^ Array		with: (MAComparator			selector: #includesSubString:			descriptions: (Array with: (MAStringDescription new label: 'contains')))		with: (MAComparator			selector: #beginsWith:			descriptions: (Array with: (MAStringDescription new label: 'begins with')))		with: (MAComparator			selector: #endsWith:			descriptions: (Array with: (MAStringDescription new label: 'ends with')))		with: (MAComparator			selector: #beginsWith:			descriptions: (Array with: (MAStringDescription new label: 'is')))! !!MAStringDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ String! !!MASymbolDescription commentStamp: '<historical>' prior: 0!I am a description of symbols, possible values are instances of <code>Symbol</code>.!!MASymbolDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Symbol'! !!MASymbolDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitSymbolDescription: self! !!MASymbolDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!kind	^ Symbol! !!MAMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I am an abstract memento. I reference a model I am working on and the description currently used to describe this model.!!MACachedMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I cache values being read and written without touching the model. When committing changes, the modifications will be propagated to the model all at once.!!MACachedMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MACachedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!cache	^ cache! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!commit	super commit.	self push: self cache.	self reset! !!MACachedMemento methodsFor: 'testing' stamp: 'lr 5/17/2006 15:11'!hasChanged	"Answer <code>true</code>, if the cached data is different to the data in the model."	^ self cache ~= self pullRaw! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	^ self cache at: aDescription! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setCache: self pull! !!MACachedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setCache: aDictionary	cache := aDictionary! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	self cache at: aDescription put: anObject! !!MACheckedMemento commentStamp: 'lr 5/17/2006 15:12' prior: 0!I cache values as my superclass and also remember the original values of the model at the time the cache is built. With this information I am able to detect edit conflicts and can prevent accidental loss of data by merging the changes.!!MACheckedMemento methodsFor: 'testing' stamp: 'lr 5/17/2006 15:09'!hasConflict	"Answer <code>true</code>, if there is an edit conflict."	^ self hasChanged and: [ self original ~= self pullRaw ]! !!MACheckedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!original	^ original! !!MACheckedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setOriginal: self pullRaw! !!MACheckedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setOriginal: aDictionary	original := aDictionary! !!MACheckedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!validate	self hasConflict		ifFalse: [ ^ super validate ].	self reset.	MAConflictError on: self description! !!MAMemento class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!model: aModel	^ self model: aModel description: aModel description! !!MAMemento class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!model: aModel description: aDescription	^ self new		setModel: aModel;		setDescription: aDescription;		reset; yourself! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!commit	"Commit the receiver into the model."! !!MAMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!description	^ description! !!MAMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!model	^ model! !!MAMemento methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' model: '; print: self model! !!MAMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!pull	"Utitlity method to pull the model into a dictionary mapping descriptions to values. nil values are replaced with the default ones of the model."	| result |	result := self pullRaw.	result keysAndValuesDo: [ :key :value |		value isNil			ifTrue: [ result at: key put: key default yourself ] ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!pullRaw	| result |	result := Dictionary new.	self description do: [ :each |		result at: each put: (self model			readUsing: each) ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!push: aDictionary	"Utitlity method to push a dictionary mapping descriptions to values into the model."	aDictionary keysAndValuesDo: [ :key :value |		key isReadonly ifFalse: [			self model				write: value				using: key ] ]! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!reset	"Reset the memento from the model."! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setDescription: aDescription	description := aDescription! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setModel: aModel	model := aModel! !!MAMemento methodsFor: 'actions' stamp: 'lr 5/29/2006 09:23'!validate	"Check if the data in the receiver would be valid if committed. In case of problems an exception is raised."	self description validate: self! !!MAStraitMemento commentStamp: 'lr 5/17/2006 15:02' prior: 0!I am a memento that forwards read- and write-access directly to the model. I can mostly be replaced with the model itself.!!MAStraitMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStraitMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!readUsing: aDescription	^ (self model readUsing: aDescription)		ifNil: [ aDescription default ]! !!MAStraitMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!write: anObject using: aDescription	self model write: anObject using: aDescription! !!MAObject class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ true! !!MAObject class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!new	"Create a new instance of the receiving class and checks if it is concrete."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAObject methodsFor: 'comparing' stamp: 'lr 5/17/2006 14:11'!= anObject	"Answer whether the receiver and the argument represent the same object. This default implementation checks if the species of the compared objects are the same, so that superclasses might call super before performing their own check. Also redefine the message <code>#hash</code> when redefining this message."	^ self species = anObject species! !!MAObject methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor! !!MAObject methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!errorPropertyNotFound: aSelector	self error: 'Property ' , aSelector , ' not found.'! !!MAObject methodsFor: 'testing' stamp: 'lr 5/28/2006 17:02'!hasProperty: aKey	"Test if the property <code>aKey</code> is defined within the receiver."	^ self properties includesKey: aKey! !!MAObject methodsFor: 'comparing' stamp: 'lr 5/17/2006 14:11'!hash	"Answer a SmallInteger whose value is related to the receiver's identity. Also redefine the message <code>#=</code> when redefining this message."	^ self species hash! !!MAObject methodsFor: 'copying' stamp: 'lr 5/29/2006 09:05'!postCopy	"This method is called whenever a shallow copy of the receiver is made. Redefine this method in subclasses to copy other fields as necessary. Never forget to call super, else class invariants might be violated."	super postCopy.	properties := properties copy! !!MAObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:10'!propertyAt: aKey	"Answer the value of the property <code>aKey</code>, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:10'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property <code>aKey</code>, or the result of <code>aBlock</code> if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:10'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property <code>aKey</code>, or if the property doesn't exist adds and answers the result of evaluating <code>aBlock</code>."	^ self properties at: aKey ifAbsentPut: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:10'!propertyAt: aKey put: aValue	"Adds or replaces the property <code>aKey</code> with <code>aValue</code>."	^ self properties at: aKey put: aValue! !!MATableModel commentStamp: 'lr 6/2/2006 00:43' prior: 0!I am a model class representing a table within the Magritte framework. Internally I store my cells within a flat array, however users may access data giving <emph>row</emph> and <emph>column</emph> coordinates with <code>#at:at:</code> and <code>#at:at:put:</code>. I can support reshaping myself, but of course this might lead to loss of data-cells.!!MATableModel class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount	^ self rows: aRowCount columns: aColumnCount contents: (Array new: aRowCount * aColumnCount)! !!MATableModel class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount contents: anArray	^ self new		setRowCount: aRowCount;		setColumnCount: aColumnCount;		setContents: anArray;		yourself! !!MATableModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= aTable	^ self species = aTable species		and: [ self rowCount = aTable rowCount ]		and: [ self columnCount = aTable columnCount ]		and: [ self contents = aTable contents ]! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: aRowIndex at: aColumnIndex	"Answer the contents of <code>aRowIndex</code> and <code>aColumnIndex</code>. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex! !!MATableModel methodsFor: 'accessing' stamp: 'lr 5/29/2006 10:07'!at: aRowIndex at: aColumnIndex put: aValue	"Set the contents of <code>aRowIndex</code> and <code>aColumnIndex</code> to <code>aValue</code>. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex put: aValue! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!checkAt: aRowIndex at: aColumnIndex	(aRowIndex between: 1 and: self rowCount)		ifFalse: [ self error: 'Row subscript out of range.' ].	(aColumnIndex between: 1 and: self columnCount)		ifFalse: [ self error: 'Column subscript out of range.' ]! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/9/2006 11:32'!collect: aBlock	^ self copyEmpty in: [ :table |		self do: [ :row :col :val |			table				at: row at: col				put: (aBlock value: row value: col value: val) ].		table ]! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	"Answer the column count of the table."	^ columnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!contents	^ contents! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self class rows: self rowCount columns: self columnCount! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyRows: aRowCount columns: aColumnCount	| table |	table := self class rows: aRowCount columns: aColumnCount.	1 to: (self rowCount min: aRowCount) do: [ :row |		1 to: (self columnCount min: aColumnCount) do: [ :col |			table				uncheckedAt: row at: col				put: (self uncheckedAt: row at: col) ] ].	^ table! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/9/2006 11:32'!do: aBlock	1 to: self rowCount do: [ :row |		1 to: self columnCount do: [ :col |			aBlock				value: row value: col				value: (self uncheckedAt: row at: col) ] ]! !!MATableModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self contents hash! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!indexAt: aRowIndex at: aColumnIndex	^ (aRowIndex - 1) * self columnCount + aColumnIndex! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!pointAt: anIndex	^ Point x: (anIndex - 1 // self columnCount + 1) y: (anIndex - 1 \\ self columnCount + 1)! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setContents: self contents copy! !!MATableModel methodsFor: 'operations' stamp: 'lr 5/27/2006 17:10'!reshapeRows: aRowCount columns: aColumnCount	"Change the size of the receiving table to <code>aRowCount</code> times <code>aColumnCount</code>, throwing away elements that are cut off and initializing empty cells with <code>nil</code>."	self setContents: (self copyRows: aRowCount columns: aColumnCount) contents.	self setRowCount: aRowCount; setColumnCount: aColumnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	"Answer the row count of the table."	^ rowCount! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setColumnCount: anInteger	columnCount := anInteger! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setContents: anArray	contents := anArray! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setRowCount: anInteger	rowCount := anInteger! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex)! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex put: aValue	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex) put: aValue! !!MAVisitor commentStamp: 'lr 5/17/2006 15:27' prior: 0!I am a visitor responsible to visit Magritte descriptions. I am an abstract class providing a default implementation for concrete visitors. The protocol I am implementing reflects the hierarchy of *MADescription* with its subclasses so that visiting a specific class automatically calls less specific implementations in case the specific implementation has been left out. The code was automatically created using code on my class-side.!!MAComponentRenderer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!component: aComponent on: aRenderer	^ self new component: aComponent on: aRenderer! !!MAComponentRenderer methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!class: aString for: aDescription	^ String streamContents: [ :stream |		stream nextPutAll: aString.		aDescription isReadonly			ifTrue: [ stream space; nextPutAll: 'readonly' ].		aDescription isRequired			ifTrue: [ stream space; nextPutAll: 'required' ] ]! !!MAComponentRenderer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:33'!component: aComponent on: aRenderer	self setComponent: aComponent; setRenderer: aRenderer.	self visit: aComponent description! !!MAComponentRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContainer: aDescription	self visitAll: (aDescription select: [ :each |		each isVisible			and: [ each componentClass notNil ] ])! !!MAComponentRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderControl: aDescription	html render: (component childAt: aDescription)! !!MAComponentRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderElement: aDescription	self renderLabel: aDescription.	self renderControl: aDescription! !!MAComponentRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderLabel: aDescription	aDescription hasLabel		ifTrue: [ html render: aDescription label; text: ':' ]! !!MAComponentRenderer methodsFor: 'initilization' stamp: 'lr 3/9/2006 11:33'!setComponent: aComponent	component := aComponent! !!MAComponentRenderer methodsFor: 'initilization' stamp: 'lr 3/9/2006 11:33'!setRenderer: aRenderer	html := aRenderer! !!MAComponentRenderer methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:33'!visitContainer: aDescription	self renderContainer: aDescription! !!MAComponentRenderer methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:33'!visitElementDescription: aDescription	self renderElement: aDescription! !!MACssRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContainer: aDescription	html div		class: (self class: 'container' for: aDescription);		with: [ super renderContainer: aDescription ]! !!MACssRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderControl: aDescription	html span		class: (self class: 'control' for: aDescription);		with: [ super renderControl: aDescription ]! !!MACssRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderElement: aDescription	html div		tooltip: aDescription comment;		class: (self class: 'element' for: aDescription);		with: [ super renderElement: aDescription ]! !!MACssRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderLabel: aDescription	html span		class: (self class: 'label' for: aDescription);		with: [ super renderLabel: aDescription ]! !!MATableRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderContainer: aDescription	html table		class: (self class: 'container' for: aDescription);		with: [ super renderContainer: aDescription ]! !!MATableRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderControl: aDescription	html tableData		class: (self class: 'control' for: aDescription);		with: [ super renderControl: aDescription ]! !!MATableRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderElement: aDescription	html tableRow		tooltip: aDescription comment;		class: (self class: 'element' for: aDescription);		with: [ super renderElement: aDescription ]! !!MATableRenderer methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderLabel: aDescription	html tableHeading		class: (self class: 'label' for: aDescription);		with: [ super renderLabel: aDescription ]! !!MABinaryReader class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:32'!read: aStream	^ self new read: aStream! !!MABinaryReader methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!next	self version: self stream next.	self version isInteger		ifFalse: [ self error: 'Invalid File Format.' ].	self stream next in: [ :description |		description isDescription			ifFalse: [ self error: 'Invalid File Description.' ].		description class version <= self version			ifFalse: [ self error: 'Invalid File Version.' ].		self visit: description ].	^ self object! !!MABinaryReader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!read: aStream	^ self stream: (MACompatibility referenceStream: aStream); next! !!MABinaryReader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!version	^ version! !!MABinaryReader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!version: aVersion	version := aVersion! !!MABinaryReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitContainer: aDescription	self object: (self stream next		ifNotNilDo: [ :class | class new ]).	self object isNil		ifTrue: [ ^ self ].	aDescription do: [ :each |		each isPersistent			ifTrue: [ self next ] ]! !!MABinaryReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitElementDescription: aDescription	self object write: self stream next using: aDescription! !!MABinaryReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitToOneRelationDescription: aDescription	| parent |	parent := self object.	[ parent write: self next using: aDescription ]		ensure: [ self object: parent ]! !!MAReader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aStream description: aDescription	^ self new read: aStream description: aDescription! !!MAReader methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!error: aString	MAReadError signal: aString! !!MAReader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!read: aStream description: aDescription	self		stream: aStream;		visit: aDescription.	^ self object! !!MAStringReader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!read: aStream description: aDescription	^ aStream atEnd		ifFalse: [ super read: aStream description: aDescription ]! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: aDescription	(aDescription trueString = self contents		or: [ aDescription trueStrings includes: self contents ])			ifTrue: [ ^ self object: true ].	(aDescription falseString = self contents		or: [ aDescription falseStrings includes: self contents ])			ifTrue: [ ^ self object: false ]! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: aDescription	self object: (aDescription kind fromString: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: anObject	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitElementDescription: aDescription	"This implementation can be very dangerous and might lead to a potential security hole, since the default implementation of #readFrom: in Object evaluates the expression to find its value. Most subclasses like Number, Date, Time, ... override this implementation, but some others (like Boolean) do not."	self object: (aDescription kind readFrom: self stream)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMultipleOptionDescription: aDescription	self object: (Array streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upToAll: ', ')) ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitRelationDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSingleOptionDescription: aDescription	self visit: aDescription reference! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: aDescription	self object: self contents! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSymbolDescription: aDescription	self object: self contents asSymbol! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTokenDescription: aDescription	self object: (aDescription kind streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upTo: $ )) ] ])! !!MAStreamingVisitor methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:32'!contents	^ self stream contents! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object	^ object! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object: anObject	object := anObject! !!MAStreamingVisitor methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!object: anObject during: aBlock	| previous |	previous := self object. self object: anObject.	aBlock ensure: [ self object: previous ]! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream	^ stream! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream: aStream	stream := aStream! !!MABinaryWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!defaultWriteStream	^ MACompatibility referenceStream: ByteArray new writeStream! !!MABinaryWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitContainer: aDescription	super visitContainer: aDescription.	self object isNil		ifTrue: [ ^ self stream nextPut: nil ].	self stream nextPut: self object class.	aDescription do: [ :each |		each isPersistent ifTrue: [			self				object: (self object readUsing: each)				during: [ self visit: each ] ] ]! !!MABinaryWriter methodsFor: 'visiting-description' stamp: 'lr 5/17/2006 11:48'!visitDescription: aDescription	self stream nextPut: aDescription class version; nextPut: aDescription! !!MABinaryWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitElementDescription: aDescription	super visitElementDescription: aDescription.	self stream nextPut: self object! !!MABinaryWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:31'!visitToOneRelationDescription: aDescription	self visitDescription: aDescription.	self visit: self object description! !!MAStringWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!defaultWriteStream	^ String new writeStream! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: aDescription	self stream nextPutAll: (self object		ifTrue: [ aDescription trueString ]		ifFalse: [ aDescription falseString ])! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self stream nextPutAll: self object label! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: aDescription	stream nextPut: $#.	stream nextPutAll: ((255 * self object red) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object green) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object blue) asInteger		printPaddedWith: $0 to: 2 base: 16)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: aDescription	aDescription do: [ :each |		each isVisible ifTrue: [			each stringWriter				write: (self object readUsing: each)				description: each to: stream.			^ self ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitElementDescription: aDescription	self stream nextPutAll: self object asString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self stream nextPutAll: self object filename! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMultipleOptionDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSingleOptionDescription: aDescription	self visit: aDescription reference! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: aDescription	self stream nextPutAll: self object! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTimeDescription: aDescription	self object print24: true showSeconds: true on: self stream! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTimeStampDescription: aDescription	self stream print: self object asDate; space.	self stream print: self object asTime! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToManyRelationDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: each description ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToOneRelationDescription: aDescription	self visit: self object description! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTokenDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPutAll: ' '  ]! !!MAStringWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription to: aStream	anObject isNil ifTrue: [ ^ aDescription undefined ].	^ super write: anObject description: aDescription to: aStream! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject	^ self new write: anObject! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription	^ self new write: anObject description: aDescription! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription to: aStream	^ self new write: anObject description: aDescription to: aStream! !!MAWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!defaultWriteStream	self subclassResponsibility! !!MAWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!error: aString	MAWriteError signal: aString! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject	^ self write: anObject description: anObject description! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription	^ self write: anObject description: aDescription to: self defaultWriteStream! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription to: aStream	self		object: anObject;		stream: aStream;		visit: aDescription.	^ self contents! !!MAVisitor class methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildVisitorHierarchyForClass: aClass selector: aBlock classified: aSelector	" self buildVisitorHierarchyForClass: MADescription selector: [ :class | 'visit' , (class name allButFirst: 2) , ':' ] classified: #'visiting-description' "	aClass withAllSubclassesDo: [ :class |		(class category beginsWith: 'Magritte') ifTrue: [			self				compile: (String streamContents: [ :stream |					stream nextPutAll: (aBlock value: class); nextPutAll: ' anObject'; cr.					class = aClass ifFalse: [						stream tab; nextPutAll: 'self '; nextPutAll: (aBlock value: class superclass); nextPutAll: ' anObject.' ] ])				classified: aSelector.			class				compile: (String streamContents: [ :stream |					stream nextPutAll: 'acceptMagritte: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: (aBlock value: class); nextPutAll: ' self.' ])				classified: #visiting ] ]! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 5/17/2006 15:27'!visit: anObject	"Visit <code>anObject</code> with the receiving visitor."	anObject acceptMagritte: self! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 5/29/2006 09:23'!visitAll: aCollection	"Visit all elements of <code>aCollection</code> with the receiving visitor."	aCollection do: [ :each | self visit: each ]! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDateDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDurationDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitElementDescription: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMagnitudeDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMemoDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMultipleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitNumberDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitOptionDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitPasswordDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitPriorityContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitReferenceDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitRelationDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitReportContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSingleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSymbolDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableReference: anObject	^ self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTimeStampDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToManyRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToOneRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTokenDescription: anObject	self visitReferenceDescription: anObject! !!Object class methodsFor: '*magritte-model-accessing' stamp: 'lr 3/27/2006 15:47'!description	^ MADescriptionBuilder for: self! !!Object methodsFor: '*magritte-seaside-converting' stamp: 'lr 3/9/2006 11:33'!asComponent	^ self description asComponentOn: self! !!Object methodsFor: '*magritte-model-converting' stamp: 'lr 3/9/2006 11:31'!asCondition	^ self! !!Object methodsFor: '*magritte-morph-converting' stamp: 'lr 3/9/2006 11:33' prior: 25750434!asMorph	^ self description asMorphOn: self! !!Object methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!description	"Return the description of the reciever. Subclasses might override this message to return instance-based descriptions."	^ self class description! !!Object methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!isAccessor	^ false! !!Object methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!isCondition	^ false! !!Object methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!isDescription	^ false! !!Object methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!mementoClass	"Return a class to be used to remember or cache the receiver, namely a memento object."	^ MACheckedMemento! !!Object methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!queryString	"Answer a computer readable string to be used for full text searches on the receiver. Subclasses might want to refine the default string that is built based on the descriptions of the reciever."	^ String streamContents: [ :stream |		self description			do: [ :each | stream nextPutAll: (each toString: (self readUsing: each)) ]			separatedBy: [ stream cr ] ]! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	"Dispatch the read-access to the receiver using the accessor of aDescription."	^ aDescription accessor read: self! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	"Dispatch the write-access to the receiver of anObject using the accessor of aDescription."	aDescription accessor write: anObject to: self! !!Symbol methodsFor: '*magritte-seaside' stamp: 'lr 8/14/2006 10:59'!fixTemps	^ self! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'lr 3/27/2006 17:44'!isDescriptionDefinition	"Answer wheter the receiver is a method selector following the naming conventions of a description definition."	^ self isDescriptionSelector		and: [ self isUnary ]! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'lr 3/27/2006 17:42'!isDescriptionExtension: aSelector	"Answer wheter the receiver is a method selector following the naming conventions of a description extension to aSelector."	^ self isDescriptionSelector		and: [ self numArgs = 1 		and: [ self beginsWith: aSelector ] ]! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'lr 3/27/2006 17:43'!isDescriptionSelector	"Answer wheter the receiver is a method selector following the naming conventions of a  description selector."	^ self ~= #description 		and: [ self beginsWith: #description ]! !!Symbol methodsFor: '*magritte-model-evaluating' stamp: 'lr 3/9/2006 11:31' prior: 31410566!value: anObject	^ anObject perform: self! !!Symbol methodsFor: '*magritte-model-evaluating' stamp: 'lr 3/9/2006 11:31'!value: anObject1 value: anObject2	^ anObject1 perform: self with: anObject2! !!UndefinedObject methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'n/a'! !!MAColorChooser commentStamp: '<historical>' prior: 0!MAColorComponent use me to display a beautiful palette!!MAColorChooser class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!color: aColor	^ self new		color: aColor;		yourself! !!MAColorChooser class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAColorChooser methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!cancel	self answer: nil! !!MAColorChooser methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!color	^ color! !!MAColorChooser methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!color: aColor	color := aColor! !!MAColorChooser methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!palette	^ Color colorPaletteForDepth: 16 extent: 200 @ 100! !!MAColorChooser methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	html image		"callback: [ :point | self answer: (self palette colorAt: point) ];"		form: self palette! !!MAColorChooser methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!save	self answer: self color! !!MAComponent class methodsFor: 'accessing' stamp: 'lr 8/14/2006 10:41'!description	^ MADescriptionBuilder for: self! !!MAComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ true! !!MAComponent class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:34'!new	"Create a new instance of the receiving component class and checks if it is not abstract."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAComponent class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:34'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAComponent class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:34'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!ajaxId	^ self ajaxId: String new! !!MAComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!ajaxId: aSymbol	^ String streamContents: [ :stream |		stream			nextPutAll: 'ajax';			nextPutAll: self class name;			print: self hash;			nextPutAll: aSymbol ]! !!MAComponent methodsFor: 'testing' stamp: 'lr 8/24/2006 23:31'!hasScriptaculous	Smalltalk at: #SULibrary ifPresent: [ :class |		^ self session application libraries			includes: class ].	^ false! !!MAComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isMultipart	^ self children anySatisfy: [ :each | each isMultipart ]! !!MAComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!rendererClass	^ WARenderCanvas! !!MADescriptionComponent commentStamp: '<historical>' prior: 0!I'm a seaside object which provides all the functions for my subclasses to display MADescription subclasses.!!MAContainerComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addForm	self addForm: #( save cancel )! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addForm: aCollection	self addDecoration: (MAFormDecoration buttons: aCollection)! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addSwitch	self addDecoration: MASwitchDecoration new.	self readonly: true! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addValidatedForm	self addForm; addValidation! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addValidatedForm: aCollection	self addForm: aCollection; addValidation! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addValidatedSwitch	self addSwitch; addValidation! !!MAContainerComponent methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addValidation	self addDecoration: MAValidationDecoration new! !!MAContainerComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildChildren	^ self description		inject: Dictionary new		into: [ :result :each |			each isVisible ifTrue: [				result at: each put: (each componentClass					memento: self memento description: each parent: self) ].			result ]! !!MAContainerComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!cancel	self reset; answer: nil! !!MAContainerComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!childAt: aDescription	^ children at: aDescription ifAbsent: [ nil ]! !!MAContainerComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ children values! !!MAContainerComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!edit	self readonly: false! !!MAContainerComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isReadonly	^ super isReadonly or: [ self readonly ]! !!MAContainerComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!readonly	^ readonly ifNil: [ readonly := false ]! !!MAContainerComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!readonly: aBoolean	readonly := aBoolean! !!MAContainerComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	self description componentRenderer		component: self on: html! !!MAContainerComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!save	self validate; commit; answer: self model! !!MAContainerComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setChildren: aDictionary	children := aDictionary! !!MAContainerComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	super setDescription: aDescription.	self setChildren: self buildChildren! !!MADescriptionComponent class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!memento: aMemento	^ self memento: aMemento description: aMemento description! !!MADescriptionComponent class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!memento: aMemento description: aDescription	^ self memento: aMemento description: aDescription parent: nil! !!MADescriptionComponent class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!memento: aMemento description: aDescription parent: aComponent	^ self new		setMemento: aMemento;		setDescription: aDescription;		setParent: aComponent;		yourself! !!MADescriptionComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!commit	self memento commit! !!MADescriptionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!description	^ description! !!MADescriptionComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!id	^ self class name asLowercase , self hash asString! !!MADescriptionComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isReadonly	^ self description isReadonly		or: [ self isRoot not		and: [ self parent isReadonly ] ]! !!MADescriptionComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isRoot	^ self parent isNil! !!MADescriptionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!memento	^ memento! !!MADescriptionComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!model	^ self memento model! !!MADescriptionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!parent	^ parent! !!MADescriptionComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!reset	self memento reset! !!MADescriptionComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!root	^ self isRoot		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!MADescriptionComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	description := aDescription! !!MADescriptionComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setMemento: aMemento	memento := aMemento! !!MADescriptionComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setParent: aComponent	parent := aComponent! !!MADescriptionComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!validate	self memento validate! !!MAElementComponent commentStamp: '<historical>' prior: 0!I provide a basic display for all subclasses of MAElementDescription (only for readonly descriptions). The object is just displayed as a string. For more complex behaviour, overried #renderViewerOn:. !!MACheckboxComponent commentStamp: '<historical>' prior: 0!I'm a seaside component used to display MABooleanDescription. If I'm writeable (readonly property of my description to false) I display a checkbox otherwise, I display a string: 'yes' if true, 'no' if false', '' if nil.!!MACheckboxComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MACheckboxComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MACheckboxComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	html label with: [		html checkbox			attributes: self attributes;			disabled: self isReadonly;			on: #value of: self.		html space; render: self description label ]! !!MAColorComponent commentStamp: '<historical>' prior: 0!Seaside component of MAColorDescription. I display a little box with the current selected color. If you click on the box, a beautiful palette will be displayed thanks to MAColorChooser.!!MAColorComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAColorComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!choose	self chooser: (MAColorChooser color: self value)! !!MAColorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!form	| form |	form := Form extent: self width @ self height depth: 32.	form getCanvas		drawPolygon: (Array with: 0 @ self height with: 0 @ 0 with: self width @ 0)			color: Color white borderWidth: 0 borderColor: Color white;		drawPolygon: (Array with: 0 @ self height with: self width @ self height with: self width @ 0)			color: Color black borderWidth: 0 borderColor: Color white;		fillRectangle: (0 @ 0 extent: self width @ self height)			color: self value.	^ form! !!MAColorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!height	^ 15! !!MAColorComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	html imageButton		attributes: self attributes;		callback: [ self choose ];		attributeAt: 'width' put: self width;		attributeAt: 'height' put: self height;		attributeAt: 'src' put: (html context urlForDocument: self form)! !!MAColorComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	html image form: self form! !!MAColorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value	^ super value ifNil: [ self description kind transparent ]! !!MAColorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!width	^ 30! !!MAElementComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!attributes	^ self description attributes copy! !!MAElementComponent methodsFor: 'calling' stamp: 'lr 3/9/2006 11:33'!chooser: aComponent	self chooser: aComponent titled: 'Edit ' , self description label! !!MAElementComponent methodsFor: 'calling' stamp: 'lr 3/9/2006 11:33'!chooser: aComponent titled: aString	| result |	result := self root call: (aComponent		addMessage: aString;		yourself).	result isNil		ifFalse: [ self value: result ]! !!MAElementComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!reference	^ self description reference! !!MAElementComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	self isReadonly		ifTrue: [ self renderViewerOn: html ]		ifFalse: [ self renderEditorOn: html ]! !!MAElementComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	self renderViewerOn: html! !!MAElementComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	html render: self string! !!MAElementComponent methodsFor: 'accessing-model' stamp: 'lr 3/27/2006 11:42'!string	^ self value isString		ifTrue: [ self value ]		ifFalse: [ self description toString: self value ]! !!MAElementComponent methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:33'!string: aString	| value |	value := [ self description fromString: aString ]		ifError: [ aString ].	self value: value! !!MAElementComponent methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:33'!value	^ self memento readUsing: self description! !!MAElementComponent methodsFor: 'accessing-model' stamp: 'lr 3/9/2006 11:33'!value: anObject	self memento write: anObject using: self description! !!MAFileUploadComponent commentStamp: '<historical>' prior: 0!I'm the MAFileDescription seaside component. With me user can upload files to the server. I provide a button for the user to browse their computer for files.!!MAFileUploadComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAFileUploadComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isMultipart	^ self value isNil or: [ self value isEmpty ]! !!MAFileUploadComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!remove	self value: nil! !!MAFileUploadComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	self isMultipart		ifTrue: [ self renderUploadOn: html ]		ifFalse: [ self renderRemoveOn: html ]! !!MAFileUploadComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderRemoveOn: html	self renderViewerOn: html.	html submitButton on: #remove of: self! !!MAFileUploadComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderUploadOn: html	html fileUpload		attributes: self attributes;		on: #upload of: self.	html submitButton		text: 'upload'! !!MAFileUploadComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	html render: self value! !!MAFileUploadComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!upload: aFile	self value: (aFile isNil ifFalse: [		self description kind new			contents: aFile contents;			filename: aFile fileName;			mimetype: aFile contentType;			yourself ])! !!MAMultipleSelectionComponent commentStamp: '<historical>' prior: 0!I provide basic functionalities for MAListCompositionComponent and MACheckboxGroupComponent.!!MACheckboxGroupComponent commentStamp: '<historical>' prior: 0!Use for MAMultipleSelectionComponent. I display as many checkboxes as my description has options. Another representation for the same description is MAListCompositionComponent.!!MACheckboxGroupComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MACheckboxGroupComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isDistinct	^ true! !!MACheckboxGroupComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	self description allOptions		do: [ :each |			html label: [				html checkbox					attributes: self attributes;					value: (self selectedList includes: each);					onTrue: [ self add: each ] onFalse: [ self remove: each ].				html space; text: (self reference toString: each) ] ]		separatedBy: [ html break ]! !!MAListCompositonComponent commentStamp: '<historical>' prior: 0!I'm, like MACheckboxComponent, a seaside component for MAMultipleSelectionDescription. I display two lists. In the first, all available options, in the other, what the user selected. 2 buttons in between to add and remove elements to/from the selected list. If the everything property is set, I display two more buttons to allow the user to add or remove all options in one click.!!MAListCompositonComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAListCompositonComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!add	self availableSelected isNil		ifTrue: [ ^ self ].	self add: self availableSelected.	self selectedSelected: self availableSelected.	self description isDistinct		ifTrue: [ self availableSelected: nil ]! !!MAListCompositonComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!availableList	^ self description isDistinct		ifFalse: [ super availableList ]		ifTrue: [ super availableList copyWithoutAll: self selectedList ]! !!MAListCompositonComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!availableSelected	^ availableSelected! !!MAListCompositonComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!availableSelected: anObject	availableSelected := anObject! !!MAListCompositonComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!moveDown	self selectedSelected isNil		ifFalse: [ self selectedList moveDown: self selectedSelected ]! !!MAListCompositonComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!moveUp	self selectedSelected isNil		ifFalse: [ self selectedList moveUp: self selectedSelected ]! !!MAListCompositonComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!remove	self selectedSelected isNil		ifTrue: [ ^ self ].	self remove: self selectedSelected.	self availableSelected: self selectedSelected.	self selectedSelected: nil! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:33'!renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | self reference toString: value ]! !!MAListCompositonComponent methodsFor: 'rendering-buttons' stamp: 'lr 3/9/2006 11:33'!renderEditorButtonAddOn: html	html submitButton		callback: [ self add ];		text: '>>'.	html break.	html submitButton		callback: [ self remove ];		text: '<<'! !!MAListCompositonComponent methodsFor: 'rendering-buttons' stamp: 'lr 3/9/2006 11:33'!renderEditorButtonOrderOn: html	html submitButton		callback: [ self moveUp ];		text: 'up'.	html break.	html submitButton		callback: [ self moveDown ];		text: 'down'! !!MAListCompositonComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	html table with: [		html tableRow with: [			html tableData				with: [ self renderEditorAvailableOn: html ].			html tableData				align: 'center';				with: [ self renderEditorButtonAddOn: html ].			html tableData				with: [ self renderEditorSelectedOn: html ].			self isOrdered ifTrue: [				html tableData					align: 'center';					with: [ self renderEditorButtonOrderOn: html ] ] ] ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:33'!renderEditorSelectedOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self selectedList;		selected: self selectedSelected;		callback: [ :value | self selectedSelected: value ];		labels: [ :value | self reference toString: value ]! !!MAListCompositonComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!selectedSelected	^ selectedSelected! !!MAListCompositonComponent methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!selectedSelected: anObject	selectedSelected := anObject! !!MAMultipleSelectionComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!add: anObject	(self isDistinct and: [ self value includes: anObject ])		ifFalse: [ self value: (self value copyWith: anObject) ]! !!MAMultipleSelectionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!availableList	^ self description allOptions! !!MAMultipleSelectionComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isDistinct	^ self description isDistinct! !!MAMultipleSelectionComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isOrdered	^ self description isOrdered		and: [ self value respondsTo: #moveUp: ]		and: [ self value respondsTo: #moveDown: ]! !!MAMultipleSelectionComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!remove: anObject	self value: (self isDistinct		ifTrue: [ self value copyWithout: anObject ]		ifFalse: [ self value copyWithoutFirst: anObject ])! !!MAMultipleSelectionComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	html unorderedList		list: self selectedList;		labels: [ :each | self reference toString: each ]! !!MAMultipleSelectionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selectedList	^ self value! !!MAMultipleSelectionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value	^ super value ifNil: [ self value: Array new. super value ]! !!MAMultiselectListComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAMultiselectListComponent methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isDistinct	^ true! !!MAMultiselectListComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	html select		attributes: self attributes;		beMultiple;		list: self availableList;		selected: self selectedList;		labels: [ :value | self reference toString: value ];		callback: [ :value | self value: value ]! !!MARangeComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MARangeComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!max	^ self description max ifNil: [ 100 ]! !!MARangeComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!min	^ self description min ifNil: [ -100 ]! !!MARangeComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!range	^ self max - self min! !!MARangeComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	html textInput		attributes: self attributes;		id: self id;		beRangeInput;		attributeAt: 'oninput' put: self updateScript;		attributeAt: 'min' put: 0;		attributeAt: 'max' put: 100;		on: #string of: self.	html span id: self id , 'v'.	html script: self updateScript! !!MARangeComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!updateScript	^ String streamContents: [ :stream |		stream			nextPutAll: 'document.getElementById('; print: self id , 'v';			nextPutAll: ').innerHTML = document.getElementById('; print: self id;			nextPutAll: ').value * ('; print: self range;			nextPutAll: ') / 100 + ('; print: self min;			nextPutAll: ');' ]! !!MARangeComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value	^ ((super value ifNil: [ 0 ]) - self min) * 100 / self range! !!MARangeComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!value: aNumber	super value: (aNumber ifNotNil: [ aNumber * self range / 100 + self min ])! !!MAOneToManyComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!add	| result |	result := self selected new.	result := self root call: (result asComponent		addMessage: 'Add ' , self selected label;		addValidatedForm;		yourself).	result isNil		ifFalse: [ self value: (self value copyWith: result); refresh ]! !!MAOneToManyComponent methodsFor: 'private' stamp: 'dc 4/16/2006 18:55'!buildCommands	commands := MACommandColumn new				setReport: self report.	self description isDefinitive 		ifFalse: [ commands					addCommandOn: self selector: #edit:;					addCommandOn: self selector: #remove:].	self description isOrdered		ifTrue: [ commands					addCommandOn: self selector: #up:;					addCommandOn: self selector: #down: ].	^ commands.									! !!MAOneToManyComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildReport	^ MAReport rows: self value description: self reference! !!MAOneToManyComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ Array with: self report! !!MAOneToManyComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!commands	^ commands ifNil: [ commands := self buildCommands ]! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'dc 4/15/2006 15:08'!down: anElement	self value moveDown: anElement! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!edit: anObject	self root call: (anObject asComponent		addMessage: 'Edit ' , self selected label;		addValidatedForm;		yourself).	self refresh! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!refresh	self report rows: self value! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!remove: anObject	self value: (self value copyWithout: anObject).	self refresh! !!MAOneToManyComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	self renderViewerOn: html.	self renderSelectListOn: html! !!MAOneToManyComponent methodsFor: 'rendering-buttons' stamp: 'lr 3/9/2006 11:33'!renderSelectButtonOn: html	html submitButton on: #add of: self! !!MAOneToManyComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	| columns |	columns := self report columns		copyWithout: self commands.	self report columns: (self isReadonly		ifFalse: [ columns copyWith: self commands ]		ifTrue: [ columns ]).	html render: self report! !!MAOneToManyComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!report	^ report ifNil: [ report := self buildReport ]! !!MAOneToManyComponent methodsFor: 'actions' stamp: 'dc 4/15/2006 15:08'!up: anElement	self value moveUp: anElement! !!MAExternalEditorComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAExternalEditorComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!create	self chooser: (self editorFor: self selected new)! !!MAExternalEditorComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!edit	self chooser: (self editorFor: self value)! !!MAExternalEditorComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderButtonsOn: html	html submitButton on: #remove of: self.	html submitButton on: #edit of: self! !!MAInternalEditorComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAInternalEditorComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildComponent	^ self value asComponent		setParent: self;		yourself! !!MAInternalEditorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ Array with: self component! !!MAInternalEditorComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!component	^ component ifNil: [ component := self buildComponent ]! !!MAInternalEditorComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!create	self value: self selected new.	component := nil! !!MAInternalEditorComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	super renderEditorOn: html.	html hiddenInput callback: [ self component commit ]! !!MAInternalEditorComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderViewerOn: html	html render: (self component		readonly: self isReadonly;		yourself)! !!MAOneToOneComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!create	self subclassResponsibility! !!MAOneToOneComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!remove	self value: nil! !!MAOneToOneComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderButtonsOn: html! !!MAOneToOneComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	self value isNil		ifTrue: [ self renderSelectListOn: html ]		ifFalse: [ self renderViewerOn: html; renderButtonsOn: html ]! !!MAOneToOneComponent methodsFor: 'rendering-tools' stamp: 'lr 3/9/2006 11:33'!renderSelectButtonOn: html	html submitButton on: #create of: self! !!MARelationComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!classes	^ self description classes! !!MARelationComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!editorFor: anObject	^ anObject asComponent		addValidatedForm;		yourself! !!MARelationComponent methodsFor: 'rendering-tools' stamp: 'lr 3/9/2006 11:33'!renderSelectButtonOn: html	self subclassResponsibility! !!MARelationComponent methodsFor: 'rendering-tools' stamp: 'lr 3/9/2006 11:33'!renderSelectListOn: html	self classes size > 1 ifTrue: [		html select			list: self classes;			selected: self selected;			callback: [ :value | self selected: value ];			labels: [ :value | value label ] ].	self classes notEmpty		ifTrue: [ self renderSelectButtonOn: html ]! !!MARelationComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected	^ selected ifNil: [ selected := self classes first ]! !!MARelationComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected: aClass	selected := aClass! !!MARadioGroupComponent commentStamp: '<historical>' prior: 0!I display a set of radio buttons to render MASingleSelectionDescription.!!MARadioGroupComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MARadioGroupComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	| group |	group := html radioGroup.	self options		do: [ :each |			html label: [				html radioButton					attributes: self attributes;					group: group;					selected: self value = each;					callback: [ self value: each ].				html space; text: (self reference toString: each) ] ]		separatedBy: [ html break ]! !!MASelectListComponent commentStamp: '<historical>' prior: 0!I display a simple list to allow the user to choose one element from the list. I am one of the two seaside components to render MASingleSelectionDescription.!!MASelectListComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MASelectListComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderEditorOn: html	html select		attributes: self attributes;		list: self options;		selected: self value;		callback: [ :value | self value: value ];		labels: [ :value | self reference toString: value ];		in: [ :tag |			self description isExtensible ifTrue: [				tag					otherLabel: '(other)'					otherCallback: [ :value | self value: (self reference fromString: value) ]					promptString: 'Please enter another element:' ] ]! !!MASingleSelectionComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!options	^ self description allOptionsWith: self value! !!MATableComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MATableComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!buildComponentTable	^ self descriptionTable collect: [ :row :col :each |		each componentClass			memento: self			description: each			parent: self ]! !!MATableComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!buildDataTable	^ MATableModel		rows: self description rowCount		columns: self description columnCount! !!MATableComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!buildDescriptionTable	^ self dataTable collect: [ :row :col :each |		self description reference copy			accessor: MANullAccessor new;			label: row asString , '/' , col asString;			propertyAt: #row put: row;			propertyAt: #column put: col;			yourself ]! !!MATableComponent methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:34'!children	^ self componentTable contents! !!MATableComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!componentTable	^ componentTable ifNil: [ componentTable := self buildComponentTable ]! !!MATableComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!dataTable	self value isNil		ifTrue: [ self value: self buildDataTable ]		ifFalse: [			(self value rowCount = self description rowCount				and: [ self value columnCount = self description columnCount ]) ifFalse: [					self value: (self value						copyRows: self description rowCount						columns: self description columnCount) ] ].	^ self value! !!MATableComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!descriptionTable	^ descriptionTable ifNil: [ descriptionTable := self buildDescriptionTable ]! !!MATableComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!readUsing: aDescription	^ self dataTable		at: (aDescription propertyAt: #row)		at: (aDescription propertyAt: #column)! !!MATableComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderViewerOn: html	html table: [		html tableRow: [			html tableHeading: nil.			self description columnLabels do: [ :each |				html tableHeading: each ] ].		self description rowLabels withIndexDo: [ :row :rindex |			html tableRow: [				html tableHeading: row.				self description columnLabels withIndexDo: [ :col :cindex |					html tableData: (self componentTable						uncheckedAt: rindex at: cindex) ] ] ] ]! !!MATableComponent methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!write: anObject using: aDescription	^ self dataTable		at: (aDescription propertyAt: #row)		at: (aDescription propertyAt: #column)		put: anObject! !!MATextAreaComponent commentStamp: '<historical>' prior: 0!I display an html text area for the magritte MATextAreaDescription.!!MATextAreaComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MATextAreaComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderEditorOn: html	html textArea		attributes: self attributes;		rows: self description lineCount;		on: #string of: self! !!MATextAreaComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderViewerOn: html	(self string findTokens: Character cr)		do: [ :each | html render: each ]		separatedBy: [ html break ]! !!MATextInputComponent commentStamp: '<historical>' prior: 0!I'm a simple input box for MAStringDescription.!!MADateInputComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!choose	| calendar |	calendar := WAMiniCalendar new.	calendar		date: ((self value notNil			and: [ self description isSatisfiedBy: self value ])				ifFalse: [ Date current ]				ifTrue: [ self value ]);		selectBlock: [ :value | calendar answer: value ];		canSelectBlock: [ :value | self description isSatisfiedBy: value ].	self chooser: calendar! !!MADateInputComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderEditorOn: html	super renderEditorOn: html.	html submitButton on: #choose of: self! !!MATextInputComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MATextInputComponent methodsFor: 'rendering' stamp: 'rjl 4/26/2006 22:36'!renderEditorOn: html 	| textInput divId|	textInput := (html textInput)		attributes: self attributes;		on: #string of: self;		yourself.	self hasScriptaculous and: [(self description respondsTo: #autoCompleteWith) ifTrue: [			self description autoCompleteWith ifNotNil: [				divId := html nextId.				textInput					onBlur: (html request triggerFormElement: textInput ensureId);					script: ((html autocomplete: divId) on: #renderListOn: of: self).				(html div)					id: divId;					class: 'autocomplete']]]! !!MATextInputComponent methodsFor: 'rendering' stamp: 'rjl 4/26/2006 22:32'!renderListOn: html 	| items matching |	items := (self description autoCompleteWith select: [:each | each asString includesSubString: self string]) asSortedCollection.	matching := items first: (items size min: 10).	html unorderedList list: matching! !!MATextInputComponent methodsFor: 'rendering' stamp: 'rjl 4/26/2006 21:02'!style	^'div.autocomplete {   position: absolute;   background-color: white;   border: 1px solid #888;   margin: 0px;   padding: 0px;   z-index: 1000;}div.autocomplete ul, div.autocomplete ul li {   list-style-type: none;   line-height: 1.7;   margin: 0px;   padding: 0px;}div.autocomplete ul li.selected {   background-color: #ffb;}'! !!MATimeInputComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!current	self value: Time current! !!MATimeInputComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderEditorOn: html	super renderEditorOn: html.	html submitButton on: #current of: self! !!MATimeStampInputComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!current	self value: TimeStamp current! !!MATimeStampInputComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderEditorOn: html	super renderEditorOn: html.	html submitButton on: #current of: self! !!MATextPasswordComponent commentStamp: '<historical>' prior: 0!Password seaside component, I display stars '*' instead of the text typed by the user. My description is MAPasswordDescription.!!MATextPasswordComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MATextPasswordComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderEditorOn: html	html passwordInput		attributes: self attributes;		on: #string of: self! !!MATextPasswordComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!string	^ String new: super string size withAll: $*! !!MATextPasswordComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!string: aString	self string = aString		ifFalse: [ super string: aString ]! !!MAUndefinedComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAUndefinedComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderContentOn: html	html span		style: 'color: red;';		with: 'Undefined Component'! !!MAReportComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAReportComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderContentOn: html	html table: [		self renderTableCaptionOn: html.		self renderTableSummaryOn: html.		self renderTableHeadOn: html.		self renderTableFootOn: html.		self renderTableBodyOn: html ]! !!MAReportComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:34'!renderTableBodyOn: html	html tag: 'tbody' do: [		self description showBody ifTrue: [			self value isEmptyOrNil				ifTrue: [ self renderTableEmptyOn: html ]				ifFalse: [ self renderTableContentOn: html ] ] ]! !!MAReportComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:34'!renderTableCaptionOn: html	self description caption ifNotNilDo: [ :value |		html			tag: 'caption'			do: self description caption ]! !!MAReportComponent methodsFor: 'rendering-content' stamp: 'lr 3/9/2006 11:34'!renderTableContentOn: html! !!MAReportComponent methodsFor: 'rendering-content' stamp: 'lr 3/9/2006 11:34'!renderTableEmptyOn: html! !!MAReportComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:34'!renderTableFootOn: html	html tag: 'tfoot' do: [		self description showFooter			ifTrue: [ self renderTableFooterOn: html ] ]! !!MAReportComponent methodsFor: 'rendering-content' stamp: 'lr 3/9/2006 11:34'!renderTableFooterOn: html! !!MAReportComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:34'!renderTableHeadOn: html	html tag: 'thead' do: [		self description showHeader			ifTrue: [ self renderTableHeaderOn: html ] ]! !!MAReportComponent methodsFor: 'rendering-content' stamp: 'lr 3/9/2006 11:34'!renderTableHeaderOn: html	html tableRow: [		self description do: [ :each |			each isVisible ifTrue: [				html tableData: each label ] ] ]! !!MAReportComponent methodsFor: 'rendering-parts' stamp: 'lr 3/9/2006 11:34'!renderTableSummaryOn: html	self description summary ifNotNilDo: [ :value |		html			tag: 'summary'			do: self description summary ]! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2000	^ MABooleanDescription selector: #showHeader label: 'Show Header' priority: 2000! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2100	^ MABooleanDescription selector: #showBody label: 'Show Body' priority: 2100! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2200	^ MAStringDescription selector: #tableEmpty label: 'Empty' priority: 2200! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2300	^ MABooleanDescription selector: #showFooter label: 'Show Footer' priority: 2300! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2400	^ MABooleanDescription selector: #showCaption label: 'Show Caption' priority: 2300! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2500	^ MAStringDescription selector: #tableCaption label: 'Caption' priority: 2500! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2600	^ MABooleanDescription selector: #showSummary label: 'Show Summary' priority: 2600! !!MAReport class methodsFor: 'accessing-description-table' stamp: 'lr 3/9/2006 11:34'!description2700	^ MAStringDescription selector: #tableSummary label: 'Summary' priority: 2700! !!MAReport class methodsFor: 'accessing-description-batch' stamp: 'lr 3/9/2006 11:34'!description4000	^ MABooleanDescription selector: #showBatch label: 'Show Batch' priority: 4000! !!MAReport class methodsFor: 'accessing-description-batch' stamp: 'lr 3/9/2006 11:34'!description4100	^ MANumberDescription selector: #batchSize label: 'Size' priority: 4100! !!MAReport class methodsFor: 'accessing-description-batch' stamp: 'lr 3/9/2006 11:34'!description4200	^ MABooleanDescription selector: #showBatchFirstLast label: 'Show First/Last' priority: 4200! !!MAReport class methodsFor: 'accessing-description-batch' stamp: 'lr 3/9/2006 11:34'!description4300	^ MABooleanDescription selector: #showBatchPreviousNext label: 'Show Previous/Next' priority: 4300! !!MAReport class methodsFor: 'accessing-description-batch' stamp: 'lr 3/9/2006 11:34'!description4400	^ MABooleanDescription selector: #showBatchPages label: 'Show Pages' priority: 4400! !!MAReport class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:34'!isAbstract	^ false! !!MAReport class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!rows: aCollection	^ self new		rows: aCollection;		yourself! !!MAReport class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:34'!rows: aCollection description: aDescription	| report |	report := self rows: aCollection.	aDescription asContainer do: [ :each |		report addColumnDescription: each ].	^ report! !!MAReport class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:34'!xxxexample	^ (self rows: (0 to: 255))		addColumn: (MAColumn new			selector: #yourself;			comment: 'the decimal number';			title: 'Dec';			yourself);		addColumn: (MAColumn new			selector: #yourself;			comment: 'the binary number';			title: 'Bin';			format: [ :value | (value printStringBase: 2) allButFirst: 2 ];			yourself);		addColumn: (MAColumn new			selector: #yourself;			comment: 'the octal number';			title: 'Oct';			format: [ :value | (value printStringBase: 8) allButFirst: 2 ];			yourself);		addColumn: (MAColumn new			selector: #yourself;			comment: 'the hexadecimal number';			title: 'Hex';			format: [ :value | (value printStringBase: 16) allButFirst: 3 ];			yourself);		addColumn: (MAColumn new			selector: #sin;			comment: 'the sinus';			title: 'Sinus';			yourself);		addColumn: (MAColumn new			selector: #cos;			comment: 'the cosinus';			title: 'Cosinus';			yourself);		addColumn: (MAColumn new			selector: #ln;			comment: 'the natural logarithm';			title: 'Logarithm';			yourself);		addColumn: (MAColumn new			selector: #exp;			comment: 'the exponential';			title: 'Exponential';			yourself);		yourself! !!MAReport methodsFor: 'readme' stamp: 'lr 3/9/2006 11:34'!NOW	" do not use ... this is unfinished, buggy and not working "! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:34'!addColumn: aColumn	columns := columns copyWith: aColumn.	^ aColumn setReport: self; yourself! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:33'!addColumnCascade: anArray	^ (self addColumn: MAColumn new)		cascade: anArray;		yourself! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:34'!addColumnDescription: aDescription	^ self addColumn: (aDescription reportColumnClass new		setDescription: aDescription;		yourself)! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:34'!addColumnSelector: aSelector	^ (self addColumn: MAColumn new)		selector: aSelector;		yourself! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!backtrackedAt: aSymbol	^ (self propertyAt: aSymbol)		contents! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!backtrackedAt: aSymbol ifAbsent: aBlock	^ (self propertyAt: aSymbol ifAbsent: [ ^ aBlock value ])		contents! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!backtrackedAt: aSymbol ifAbsentPut: aBlock	^ self		backtrackedAt: aSymbol		ifAbsent: [ self backtrackedAt: aSymbol put: aBlock value ]! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!backtrackedAt: aSymbol put: anObject	(self propertyAt: aSymbol ifAbsentPut: [ WAStateHolder new ])		contents: anObject.	^ anObject! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!batchEndIndex	^ self batchPage * self batchSize min: self cache size! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!batchMaxPages	^ (self cache size / self batchSize)		ceiling! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!batchPage	^ self backtrackedAt: #batchPage ifAbsentPut: [ self defaultBatchPage ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!batchPage: anInteger	self backtrackedAt: #batchPage put: anInteger! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!batchPageRange	^ self batchPageRangeStart to: self batchPageRangeEnd! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!batchPageRangeEnd	^ self batchMaxPages min: self batchPage + 9! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!batchPageRangeStart	^ self defaultBatchPage max: self batchPage - 9! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!batchSize	^ self propertyAt: #batchSize ifAbsentPut: [ self defaultBatchSize ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!batchSize: anInteger	self propertyAt: #batchSize put: anInteger! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:33'!batchStartIndex	^ (self batchPage - 1) * self batchSize + 1! !!MAReport methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!cache	"Return the cached rows of the receiver, these rows are filtered and sorted."	cache isNil ifTrue: [		self cache: (self			sortRows: (self				filterRows: self					rows)) ].	^ cache! !!MAReport methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!cache: aCollection	cache := aCollection! !!MAReport methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:34'!columns	^ columns! !!MAReport methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:34'!columns: aCollection	columns := aCollection! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultBatchPage	^ 1! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultBatchSize	^ 10! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultRowFilter	^ nil! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultRowPeriod	^ 1! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultRowStyles	^ Array with: 'odd' with: 'even'! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowBatch	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowBatchFirstLast	^ false! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowBatchPages	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowBatchPreviousNext	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowBody	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowCaption	^ false! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultShowFooter	^ false! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowHeader	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultShowSummary	^ false! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultSortArrowDown	^ ScriptingSystem formAtKey: #DownArrow! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultSortArrowUp	^ ScriptingSystem formAtKey: #UpArrow! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultSortColumn	^ nil! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSortEnabled	^ true! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSortReversed	^ false! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultTableCaption	^ nil! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultTableEmpty	^ 'The report is empty.'! !!MAReport methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:34'!defaultTableSummary	^ nil! !!MAReport methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:34'!export	^ String streamContents: [ :stream |		self exportOn: stream ]! !!MAReport methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:33'!exportBodyOn: aStream	self cache withIndexDo: [ :row :index |		self columns			do: [ :column |				column					exportContent: (column valueFor: row)					index: index on: aStream ]			separatedBy: [ aStream tab ].		aStream cr ]! !!MAReport methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:33'!exportHeaderOn: aStream	self columns		do: [ :each | each exportHeadOn: aStream ]		separatedBy: [ aStream tab ].	aStream cr! !!MAReport methodsFor: 'exporting' stamp: 'lr 3/9/2006 11:33'!exportOn: aStream	self showHeader		ifTrue: [ self exportHeaderOn: aStream ].	self showBody		ifTrue: [ self exportBodyOn: aStream ]! !!MAReport methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!filterRows: aCollection	^ self hasRowFilter		ifFalse: [ aCollection ]		ifTrue: [ aCollection select: self rowFilter ]! !!MAReport methodsFor: 'testing' stamp: 'pmm 7/27/2006 19:41'!hasMoreThanOnePage	^self batchSize < self cache size! !!MAReport methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!hasRowFilter	^ self rowFilter notNil! !!MAReport methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:34'!initialize	super initialize.	rows := columns := Array new.	properties := Dictionary new! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:33'!isOnFirstPage	^ self batchPage = 1! !!MAReport methodsFor: 'private-batch' stamp: 'lr 3/9/2006 11:34'!isOnLastPage	^ self batchPage = self batchMaxPages! !!MAReport methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isSorted	^ self sortColumn notNil! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:33'!moveDown: aColumn	| index |	index := self columns indexOf: aColumn ifAbsent: [ ^ self ].	self columns swap: index with: (index = self size		ifFalse:[ index + 1 ]		ifTrue: [ 1 ])! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:34'!moveUp: aColumn	| index |	index := self columns indexOf: aColumn ifAbsent: [ ^ self ].	self columns swap: index with: (index = 1		ifFalse:[ index - 1 ]		ifTrue: [ self size ])! !!MAReport methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!nextPage	self isOnLastPage		ifFalse: [ self batchPage: self batchPage + 1 ]! !!MAReport methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!previousPage	self isOnFirstPage		ifFalse: [ self batchPage: self batchPage - 1 ]! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!properties	^ properties! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!propertyAt: aSymbol	^ self properties at: aSymbol! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:33'!propertyAt: aSymbol ifAbsent: aBlock	^ self properties at: aSymbol ifAbsent: aBlock! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!propertyAt: aSymbol ifAbsentPut: aBlock	^ self properties at: aSymbol ifAbsentPut: aBlock! !!MAReport methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:34'!propertyAt: aSymbol put: anObject	^ self properties at: aSymbol put: anObject! !!MAReport methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!refresh	self cache: nil; batchPage: self defaultBatchPage.	self columns do: [ :each | each refresh ]! !!MAReport methodsFor: 'columns' stamp: 'lr 3/9/2006 11:33'!remove: aColumn	columns := columns copyWithout: aColumn! !!MAReport methodsFor: 'rendering-batch' stamp: 'lr 3/9/2006 11:34'!renderBatchFirstOn: html	self isOnFirstPage		ifFalse: [ html anchor callback: [ self batchPage: self defaultBatchPage ]; text: '|<' ]		ifTrue: [ html text: '|<' ].	html space! !!MAReport methodsFor: 'rendering-batch' stamp: 'lr 3/9/2006 11:34'!renderBatchItemsOn: html	self batchPageRangeStart > self defaultBatchPage		ifTrue: [ html text: '...'; space ].	self batchPageRange do: [ :index |		self batchPage = index			ifFalse: [ html anchor callback: [ self batchPage: index ]; text: index ]			ifTrue: [ html span class: 'current'; with: index ].		html space ].	self batchPageRangeEnd < self batchMaxPages		ifTrue: [ html text: '...'; space ]! !!MAReport methodsFor: 'rendering-batch' stamp: 'lr 3/9/2006 11:34'!renderBatchLastOn: html	self isOnLastPage		ifFalse: [ html anchor callback: [ self batchPage: self batchMaxPages ]; text: '>|' ]		ifTrue: [ html text: '>|' ]! !!MAReport methodsFor: 'rendering-batch' stamp: 'lr 3/9/2006 11:34'!renderBatchNextOn: html	self isOnLastPage		ifFalse: [ html anchor callback: [ self nextPage ]; text: '>>' ]		ifTrue: [ html text: '>>' ].	html space! !!MAReport methodsFor: 'rendering-batch' stamp: 'lr 3/9/2006 11:34'!renderBatchPreviousOn: html	self isOnFirstPage		ifFalse: [ html anchor callback: [ self previousPage ]; text: '<<' ]		ifTrue: [ html text: '<<' ].	html space! !!MAReport methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderContentOn: html	html table		id: self ajaxId; class: 'report';		with: [ self renderTableOn: html ]! !!MAReport methodsFor: 'rendering-table' stamp: 'pmm 7/27/2006 19:42'!renderTableBatchOn: html	self hasMoreThanOnePage ifTrue: [		html tableRow: [			html tableData				class: 'batch';				colSpan: self columns size;				with: [					self showBatchFirstLast						ifTrue: [ self renderBatchFirstOn: html ].					self showBatchPreviousNext						ifTrue: [ self renderBatchPreviousOn: html ].					self showBatchPages						ifTrue: [ self renderBatchItemsOn: html ].					self showBatchPreviousNext						ifTrue: [ self renderBatchNextOn: html ].					self showBatchFirstLast						ifTrue: [ self renderBatchLastOn: html ] ] ] ]! !!MAReport methodsFor: 'rendering-table' stamp: 'lr 3/9/2006 11:34'!renderTableBodyOn: html	self visible isEmpty		ifTrue: [			html tableRow				class: 'empty';				with: [					html tableData						colSpan: self columns size;						with: self tableEmpty ] ]		ifFalse: [			self visible withIndexDo: [ :row :index |				html tableRow					class: (self rowStyleForNumber: index);					with: [						self columns do: [ :col |							col renderCell: row on: html ] ] ] ]! !!MAReport methodsFor: 'rendering-table' stamp: 'lr 3/9/2006 11:34'!renderTableCaptionOn: html	(html tag: 'caption') with: self tableCaption! !!MAReport methodsFor: 'rendering-table' stamp: 'pmm 7/27/2006 19:46'!renderTableFootOn: html	html tableRow: [		self columns do: [ :each |			each renderFootCellOn: html ] ]! !!MAReport methodsFor: 'rendering-table' stamp: 'pmm 7/27/2006 19:46'!renderTableHeadOn: html	html tableRow: [		self columns do: [ :each |			each renderHeadCellOn: html ] ]! !!MAReport methodsFor: 'rendering' stamp: 'pmm 7/27/2006 19:45'!renderTableOn: html	self showCaption		ifTrue: [ self renderTableCaptionOn: html ].	self showSummary		ifTrue: [ self renderTableSummaryOn: html ].	html tableHead: [		self showHeader			ifTrue: [ self renderTableHeadOn: html ] ].			((self showBatch		and: [ self hasMoreThanOnePage ])		or: [ self showFooter ]) ifTrue: [			"we must not produce an empty tfoot element, this is not valid xhtml"			html tableFoot: [				self showFooter					ifTrue: [ self renderTableFootOn: html ].				self showBatch					ifTrue: [ self renderTableBatchOn: html ] ] ].		html tableBody: [		self showBody			ifTrue: [ self renderTableBodyOn: html ] ]! !!MAReport methodsFor: 'rendering-table' stamp: 'lr 3/9/2006 11:34'!renderTableSummaryOn: html	(html tag: 'summary') with: self tableSummary! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!rowFilter	^ self backtrackedAt: #rowFilter ifAbsentPut: [ self defaultRowFilter ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!rowFilter: aBlock	self backtrackedAt: #rowFilter put: aBlock.	self refresh! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!rowPeriod	^ self propertyAt: #rowPeriod ifAbsentPut: [ self defaultRowPeriod ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!rowPeriod: aNumber	self propertyAt: #rowPeriod put: aNumber! !!MAReport methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!rowStyleForNumber: aNumber	^ self rowStyles		at: ((aNumber - 1 // self rowPeriod) \\ self rowStyles size) + 1		ifAbsent: [ String new ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!rowStyles	^ self propertyAt: #rowStyles ifAbsentPut: [ self defaultRowStyles ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!rowStyles: aCollection	self propertyAt: #rowStyles put: aCollection! !!MAReport methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!rows	"Return the rows of the receiver."	^ rows ifNil: [ rows := Array new ]! !!MAReport methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!rows: aCollection	"Set the rows of the receiver."	rows = aCollection		ifTrue: [ ^ self ].	rows := aCollection.	self refresh! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatch	^ self propertyAt: #showBatch ifAbsentPut: [ self defaultShowBatch ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatch: aBoolean	self propertyAt: #showBatch put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatchFirstLast	^ self propertyAt: #showBatchFirstLast ifAbsentPut: [ self defaultShowBatchFirstLast ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatchFirstLast: aBoolean	self propertyAt: #showBatchFirstLast put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!showBatchPages	^ self propertyAt: #showBatchPages ifAbsentPut: [ self defaultShowBatchPages ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatchPages: aBoolean	self propertyAt: #showBatchPages put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatchPreviousNext	^ self propertyAt: #showBatchPreviousNext ifAbsentPut: [ self defaultShowBatchPreviousNext ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBatchPreviousNext: aBoolean	self propertyAt: #showBatchPreviousNext put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!showBody	^ self propertyAt: #showBody ifAbsentPut: [ self defaultShowBody ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showBody: aBoolean	self propertyAt: #showBody put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showCaption	^ self propertyAt: #showCaption ifAbsentPut: [ self defaultShowCaption ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showCaption: aBoolean	self propertyAt: #showCaption put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showFooter	^ self propertyAt: #showFooter ifAbsentPut: [ self defaultShowFooter ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showFooter: aBoolean	self propertyAt: #showFooter put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showHeader	^ self propertyAt: #showHeader ifAbsentPut: [ self defaultShowHeader ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showHeader: aBoolean	self propertyAt: #showHeader put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showSummary	^ self propertyAt: #showSummary ifAbsentPut: [ self defaultShowSummary ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!showSummary: aBoolean	self propertyAt: #showSummary put: aBoolean! !!MAReport methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!sort: aColumn	aColumn = self sortColumn		ifTrue: [			self sortReversed				ifFalse: [ self sortReversed: true ]				ifTrue: [ self sortColumn: nil; sortReversed: false ] ]		ifFalse: [ self sortColumn: aColumn; sortReversed: false ].	self refresh! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sortArrowDown	^ self propertyAt: #sortArrowDown ifAbsentPut: [ self defaultSortArrowDown ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!sortArrowDown: aForm	self propertyAt: #sortArrowDown put: aForm! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!sortArrowUp	^ self propertyAt: #sortArrowUp ifAbsentPut: [ self defaultSortArrowUp ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sortArrowUp: aForm	self propertyAt: #sortArrowUp put: aForm! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!sortColumn	^ self backtrackedAt: #sortColumn ifAbsentPut: [ self defaultSortColumn ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sortColumn: aColumn	self backtrackedAt: #sortColumn put: aColumn! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sortEnabled	^ self propertyAt: #sortEnabled ifAbsentPut: [ self defaultSortEnabled ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!sortEnabled: aBoolean	self propertyAt: #sortEnabled put: aBoolean! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!sortReversed	^ self backtrackedAt: #sortReversed ifAbsentPut: [ self defaultSortReversed ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!sortReversed: aBoolean	self backtrackedAt: #sortReversed put: aBoolean! !!MAReport methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!sortRows: aCollection	^ self isSorted		ifFalse: [ aCollection ]		ifTrue: [ self sortColumn sortRows: aCollection ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!tableCaption	^ self propertyAt: #tableCaption ifAbsentPut: [ self defaultTableCaption ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!tableCaption: aString	self propertyAt: #tableCaption put: aString! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!tableEmpty	^ self propertyAt: #tableEmpty ifAbsentPut: [ self defaultTableEmpty ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!tableEmpty: aString	self propertyAt: #tableEmpty put: aString! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:33'!tableSummary	^ self propertyAt: #tableSummary ifAbsentPut: [ self defaultTableSummary ]! !!MAReport methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:34'!tableSummary: aString	self propertyAt: #tableSummary put: aString! !!MAReport methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:34'!visible	^ self showBatch		ifFalse: [ self cache ]		ifTrue: [			self cache				copyFrom: self batchStartIndex				to: self batchEndIndex ]! !!MADescriptionEditor class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:34'!example	^ self new! !!MADescriptionEditor methodsFor: 'actions-items' stamp: 'lr 3/9/2006 11:33'!addDescription: aDescription	| element |	element := self call: (self		buildEditorFor: aDescription		titled: 'Add ' , aDescription class label).	element isNil ifTrue: [ ^ self ].	self description add: element.	self report refresh! !!MADescriptionEditor methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildReport	^ (MAReport rows: self description description: MAElementDescription description)		addColumn: (MAColumn new			cascade: #( description label );			title: 'Kind';			yourself);		addColumn: (MACommandColumn new			addCommandOn: self selector: #editDescription: text: 'edit';			addCommandOn: self selector: #moveUp: text: 'up';			addCommandOn: self selector: #moveDown: text: 'down';			addCommandOn: self selector: #removeDescription: text: 'remove';			yourself);		yourself! !!MADescriptionEditor methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultDescription	^ MAContainer new! !!MADescriptionEditor methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultDescriptionClasses	^ OrderedCollection new		add: MAStringDescription;		add: MAMemoDescription;		add: MASymbolDescription;		add: MAPasswordDescription;		add: nil;		add: MABooleanDescription;		add: MASingleOptionDescription;		add: MAMultipleOptionDescription;		add: MAToOneRelationDescription;		add: MAToManyRelationDescription;		add: nil;		add: MANumberDescription;		add: MADurationDescription;		add: MADateDescription;		add: MATimeDescription;		add: MATimeStampDescription;		add: nil;		add: MAColorDescription;		add: MATokenDescription;		add: nil;		add: MAFileDescription;		add: MAClassDescription;		add: MATableDescription;		yourself! !!MADescriptionEditor methodsFor: 'accessing-configuration' stamp: 'lr 5/17/2006 11:38'!defaultExampleInstance	^ MAAdaptiveModel description: self value description! !!MADescriptionEditor methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultReportInstance	^ (MAReport rows: self value description: MAElementDescription description)		addColumn: (MAColumn new			cascade: #( description label );			title: 'Kind';			yourself);		addColumn: (MACommandColumn new			addCommandOn: self selector: #editDescription: text: 'edit';			addCommandOn: self selector: #moveUp: text: 'up';			addCommandOn: self selector: #moveDown: text: 'down';			addCommandOn: self selector: #removeDescription: text: 'remove';			yourself);		yourself! !!MADescriptionEditor methodsFor: 'actions-items' stamp: 'lr 3/9/2006 11:33'!editDescription: aDescription	self call: (self		buildEditorFor: aDescription		titled: 'Edit ' , aDescription class label).	self report refresh! !!MADescriptionEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!example	example isNil		ifTrue: [ example := self defaultExampleInstance ].	^ example! !!MADescriptionEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!preview	self call: (self example asComponent		addMessage: self description label;		addValidatedForm;		yourself)! !!MADescriptionEditor methodsFor: 'actions-items' stamp: 'lr 3/9/2006 11:33'!removeDescription: aDescription	self description remove: aDescription.	self report refresh! !!MADescriptionEditor methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderButtonsOn: html	| selected |	selected := ValueHolder new.	html		selectFromList: self defaultDescriptionClasses		selected: self defaultDescriptionClasses first		callback: [ :class | selected contents: class ]		labels: [ :class |			class isNil				ifTrue: [ '--' ]				ifFalse: [ class label ] ].	html		submitButtonWithAction: [			selected contents ifNotNilDo: [ :class |				self addDescription: class new ] ]		text: 'Add'.	super renderButtonsOn: html! !!MAExampleEditor class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:34'!description: aDescription	^ self new		description: aDescription;		yourself! !!MAExampleEditor methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildEditorFor: anObject titled: aString	^ anObject asComponent		addValidatedForm;		addMessage: aString;		yourself! !!MAExampleEditor methodsFor: 'private' stamp: 'lr 3/9/2006 11:33'!buildReport	self subclassResponsibility! !!MAExampleEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!cancel	self answer: nil! !!MAExampleEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ Array with: self report! !!MAExampleEditor methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultDescription	self subclassResponsibility! !!MAExampleEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!description	^ description ifNil: [ description := self defaultDescription ]! !!MAExampleEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!description: aDescription	description := aDescription! !!MAExampleEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!edit	self call: (self		buildEditorFor: description		titled: 'Edit Container')! !!MAExampleEditor methodsFor: 'actions-items' stamp: 'lr 3/9/2006 11:33'!moveDown: aDescription	self description moveDown: aDescription.	self report refresh! !!MAExampleEditor methodsFor: 'actions-items' stamp: 'lr 3/9/2006 11:33'!moveUp: aDescription	self description moveUp: aDescription.	self report refresh! !!MAExampleEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!preview	self subclassResponsibility! !!MAExampleEditor methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderButtonsOn: html	html submitButtonOn: #edit of: self.	html submitButtonOn: #preview of: self! !!MAExampleEditor methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderChildrenOn: html	html render: self children! !!MAExampleEditor methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:33'!renderContentOn: html	self renderChildrenOn: html.	html form: [		self renderButtonsOn: html ]! !!MAExampleEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!report	^ report ifNil: [ report := self buildReport ]! !!MAExampleEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!save	self answer: self description! !!MAReportEditor class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:34'!xxxexample	^ self new! !!MAReportEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!addColumn: aColumn	self report addColumn: aColumn.	self refresh! !!MAReportEditor methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!buildColumns	^ (MAReport rows: self report columns)		addColumn: self visible;		addColumnDescription: MAColumn descriptionTitle;		addColumnDescription: MAColumn descriptionComment;		addColumn: (MACommandColumn new			addCommandOn: self selector: #moveUp: text: 'up';			addCommandOn: self selector: #moveDown: text: 'down';			addCommandOn: self selector: #remove: text: 'remove';			yourself);		yourself! !!MAReportEditor methodsFor: 'private' stamp: 'lr 3/9/2006 11:34'!buildVisible	^ MACheckboxColumn new		title: 'V';		comment: 'Visibility';		selection: (self report columns			select: [ :each | each isVisible ])			asSet;		yourself! !!MAReportEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!children	^ Array with: self columns! !!MAReportEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!columns	columns isNil		ifTrue: [ columns := self buildColumns ].	^ columns! !!MAReportEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!preview	self report		decorateWith: (WAWindowDecoration new			title: self report tableCaption;			yourself)		during: [ self call: self report ]! !!MAReportEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!refresh	self columns rows: self report columns! !!MAReportEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!remove: aColumn	self report remove: aColumn.	self refresh! !!MAReportEditor methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:34'!renderAddOn: html	| selected |	selected := ValueHolder new.	"html		selectFromList: self columns selected: nil		callback: [ :value | selected contents: value ]		labels: [ :value | value title ]."	html		submitButtonWithAction: [			selected contents ifNotNilDo: [ :value |				self addColumn: value copy ] ]		text: 'add'! !!MAReportEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!report	^ report! !!MAReportEditor methodsFor: 'actions' stamp: 'lr 3/9/2006 11:34'!save	 self answer: self report! !!MAReportEditor methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:34'!setReport: aReport	report := aReport copy! !!MAReportEditor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:34'!visible	visible isNil		ifTrue: [ visible := self buildVisible ].	^ visible! !!Integer methodsFor: '*magritte-model-converting' stamp: 'lr 3/9/2006 11:31'!asFileSize	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ ^ value asString , ' ' , each ] ]! !"Magritte-Model"!"Magritte-Tests"!"Magritte-Seaside"!"Magritte-Morph"!!MAColumn methodsFor: 'rendering' stamp: 'pmm 9/26/2006 19:28' prior: 35841070!renderHeadCellOn: html	html tableData		title: (self comment ifNil: ['']);		with: [			self isSortable				ifFalse: [ self renderHeadContentOn: html ]				ifTrue: [					html anchor						callback: [ self report sort: self ];						with: [							self renderHeadContentOn: html.							self renderHeadSorterOn: html ] ] ]! !!MARadioGroupComponent methodsFor: 'rendering' stamp: 'lr 9/28/2006 08:29' prior: 36052515!renderEditorOn: html	| group |	group := html radioGroup.	self options		do: [ :each |			html label: [				html radioButton					attributes: self attributes;					group: group;					selected: self value = each;					callback: [ self value: each ].				html space; text: (self description toString: each) ] ]		separatedBy: [ html break ]! !!MAFileModel methodsFor: '*magritte-seaside-rendering' stamp: 'lr 9/14/2006 14:42' prior: 35872692!renderTextOn: html	| stream |	stream := self contents readStream.	html preformatted with: [		html text: (stream next: 800).		stream atEnd			ifFalse: [ html text: '...' ] ]! !!MACheckboxGroupComponent methodsFor: 'rendering' stamp: 'lr 9/28/2006 14:21' prior: 36038411!renderEditorOn: html	self description allOptions		do: [ :each |			html label: [				html checkbox					attributes: self attributes;					value: (self selectedList includes: each);					onTrue: [ self add: each ] onFalse: [ self remove: each ].				html space; text: (self description toString: each) ] ]		separatedBy: [ html break ]! !!MATableRenderer methodsFor: 'rendering' stamp: 'pmm 9/26/2006 19:28' prior: 36002379!renderElement: aDescription	html tableRow		title: (aDescription comment ifNil: ['']);		class: (self class: 'element' for: aDescription);		with: [ super renderElement: aDescription ]! !!MAMultiselectListComponent methodsFor: 'rendering' stamp: 'lr 9/28/2006 14:21' prior: 36044416!renderEditorOn: html	html select		attributes: self attributes;		beMultiple;		list: self availableList;		selected: self selectedList;		labels: [ :value | self description toString: value ];		callback: [ :value | self value: value ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 9/28/2006 14:21' prior: 36040805!renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | self description toString: value ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 9/28/2006 14:21' prior: 36042188!renderEditorSelectedOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self selectedList;		selected: self selectedSelected;		callback: [ :value | self selectedSelected: value ];		labels: [ :value | self description toString: value ]! !!MASelectListComponent methodsFor: 'rendering' stamp: 'lr 9/28/2006 08:29' prior: 36053255!renderEditorOn: html	html select		attributes: self attributes;		list: self options;		selected: self value;		callback: [ :value | self value: value ];		labels: [ :value | self description toString: value ];		in: [ :tag |			self description isExtensible ifTrue: [				tag					otherLabel: '(other)'					otherCallback: [ :value | self value: (self description fromString: value) ]					promptString: 'Please enter another element:' ] ]! !!MACssRenderer methodsFor: 'rendering' stamp: 'pmm 9/26/2006 19:28' prior: 36001507!renderElement: aDescription	html div		title: (aDescription comment ifNil: ['']);		class: (self class: 'element' for: aDescription);		with: [ super renderElement: aDescription ]! !"Magritte-Seaside"!!WAUrl methodsFor: '*pier-seaside-mapping' stamp: 'lr 6/30/2006 00:11'!adaptToContext: aContext	path := aContext session application baseUrl path copy.	aContext structure parents allButFirst		do: [ :each | self path add: each name ].	aContext command isView		ifTrue: [ self addParameter: 'view' value: aContext command viewComponentClass name asString ].	self addParameter: 'command' value: aContext command class name asString.	self addParameter: '_n'! !!PRStructureComponent methodsFor: 'actions' stamp: 'lr 8/14/2006 10:25'!choose	| tree |	tree := WATree root: self context root path: self context structure parents.	tree		labelBlock: [ :structure | structure title ];		childrenBlock: [ :structure | structure enumerator contents ].	self chooser: tree! !!PRStructureComponent methodsFor: 'rendering' stamp: 'lr 3/27/2006 11:32'!renderEditorOn: html	super renderEditorOn: html.	html submitButton on: #choose of: self! !!MAVisitor methodsFor: '*pier-model-accessing' stamp: 'lr 3/9/2006 11:29'!context	^ PRCurrentContext value! !!MAVisitor methodsFor: '*pier-model-accessing' stamp: 'lr 3/9/2006 11:29'!context: aContext	PRCurrentContext value: aContext! !!MAVisitor methodsFor: '*pier-model-visiting-description' stamp: 'lr 3/9/2006 11:29'!visitStructureDescription: anObject	^ self visitElementDescription: anObject! !!PRCompatibility class methodsFor: 'development-tools' stamp: 'lr 3/9/2006 11:30'!compileFileNamed: aString into: aClass selector: aSelector	"Reads the file with the name aString and compile it into aClass>>aSelector returning the the contents as byte-array."	| input contents source |	input := FileDirectory default oldFileNamed: aString.	contents := [ input binary; contents ] ensure: [ input close ].	source := String streamContents: [ :stream |		stream nextPutAll: aSelector; cr.		stream tab; nextPut: $"; nextPutAll: self name; nextPutAll: ' compileFileNamed: '; print: aString; nextPutAll: ' into: '; print: aClass; nextPutAll: ' selector: '; print: aSelector; nextPut: $"; cr; cr.		stream tab; nextPutAll: '^ #('.		contents asByteArray			do: [ :element | element printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ') asByteArray.' ].	aClass compile: source classified: #'accessing-resources'! !!PRCompatibility class methodsFor: 'environment' stamp: 'lr 3/9/2006 11:30'!hashPassword: aString	"Answer a secure-hash value to be used to store and compare passwords in a save way."	^ SecureHashAlgorithm new hashMessage: aString! !!PRRecursionBlocker class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!do: aBlock else: aRecursionBlock	^ self value isNil		ifFalse: [ aRecursionBlock value ]		ifTrue: [ self use: self during: aBlock ]! !!PRAddCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRAddCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRAddCommand! !!PRAddCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testAddChild	| child |	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: (self structure childrenDecoration		includes: self command name).	child := self structure childrenDecoration		at: self command name.	self assert: child name = self command name.	self assert: child species = self command type! !!PRAddCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testAddConflict	self		shouldnt: [ self command execute ]		raise: PRConflictingNameError.	self		should: [ self command execute ]		raise: PRConflictingNameError		do: [ :ex | self assert: self command structure = ex structure ]! !!PRAddCommandTest methodsFor: 'testing-utilties' stamp: 'lr 3/9/2006 11:31'!testUniqueTitle	20 timesRepeat: [		self			shouldnt: [				self structure addChild: (PRPage named: (self command					uniqueName: 'foo' in: self structure)) ]			raise: PRConflictingNameError ].	#( 'foo' 'foo 2' 'foo 9' 'foo 10' 'foo 11' 'foo 20' ) do: [ :each |		self assert: (self structure childrenDecoration includes: each) ]! !!PRCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRCommand! !!PRCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualInstance	^ self actualClass context: self context! !!PRCommandTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!command	^ command ifNil: [ command := self actualInstance ]! !!PRCommandTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!context	^ context ifNil: [ context := self contextInstance ]! !!PRCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!contextInstance	^ PRContext kernel: self kernel structure: self structure! !!PRCommandTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ self command! !!PRCommandTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!kernel	^ kernel ifNil: [ kernel := self kernelInstance ]! !!PRCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!kernelInstance	^ PRKernel new		root: ((PRPage named: 'root')			addChild: (PRPage named: 'folder');			addChild: (self structure);			yourself);		yourself! !!PRCommandTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!structure	^ structure ifNil: [ structure := self structureInstance ]! !!PRCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!structureInstance	^ PRPage named: 'command'! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAnswer	self assert: self command answer isNil.	self command answer: self context.	self assert: self command answer = self context! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testContext	self assert: self command context notNil.	self command context: self context.	self assert: self command context = self context! !!PRCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsLogged	self assert: self command isLogged! !!PRCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsQuick	self deny: self command isQuick! !!PRCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsView	self deny: self command isView! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testKernel	self assert: self command kernel = self kernel! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testRoot	self assert: self command root = self kernel root! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testStructure	self assert: self command structure = self structure! !!PRCommandTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testTimestamp	| stamp |	self assert: self command timestamp isNil.	self command timestamp: (stamp := TimeStamp now).	self assert: self command timestamp = stamp! !!PRCommandTest methodsFor: 'testing-utilities' stamp: 'lr 9/25/2006 08:26'!testUniqueName	20 timesRepeat: [		self			shouldnt: [				self structure addChild: (PRPage named: (self command					uniqueName: 'foo' in: self structure)) ]			raise: PRConflictingNameError ].! !!PRCommandTest methodsFor: 'testing-utilities' stamp: 'lr 9/25/2006 08:29'!testUniqueNameDoesNotAddDecoration	self command uniqueName: 'foo' in: self structure.	self structure 		decorationOfClass: self structure childrenDecorationClass 		ifAbsent: [ ^ self ].	self assert: self structure hasChildren! !!PRCommandTest methodsFor: 'testing-validating' stamp: 'lr 3/21/2006 18:43'!testValidateChild	self		should: [			self command				validateChild: (PRPage named: 'folder')				in: self context root ]		raise: PRConflictingNameError		do: [ :ex | self assert: self context root = ex structure ].	self		shouldnt: [			self command				validateChild: (PRPage named: 'zork')				in: self context root ]		raise: PRConflictingNameError.	self		shouldnt: [			self command				validateChild: (self context root childrenDecoration at: 'folder')				in: self context root ]		raise: PRConflictingNameError! !!PRCommandTest methodsFor: 'testing-validating' stamp: 'lr 9/25/2006 08:31'!testValidateChildDoesNotAddDecoration	self command		validateChild: (PRPage named: 'zork')		in: self context root.	self structure		decorationOfClass: self structure childrenDecoration		ifAbsent: [ ^ self ].	self assert: self structure hasChildren! !!PRCommandTest methodsFor: 'testing-validating' stamp: 'lr 3/21/2006 18:43'!testValidateChildNamed	self		should: [			self command				validateChild: PRPage new				named: 'folder'				in: self context root ]		raise: PRConflictingNameError		do: [ :ex | self assert: self context root = ex structure ].	self		shouldnt: [			self command				validateChild: PRPage new				named: 'zork'				in: self context root ]		raise: PRConflictingNameError.	self		shouldnt: [			self command				validateChild: (self context root childrenDecoration					at: 'folder')				named: 'zork'				in: self context root ]		raise: PRConflictingNameError! !!PRCommandTest methodsFor: 'testing-validating' stamp: 'lr 3/9/2006 11:31'!testValidateName	self		shouldnt: [			self command				validateName: 'zork'				of: PRPage new				in: self context root ]		raise: PRConflictingNameError.	self		should: [			self command				validateName: 'folder'				of: PRPage new				in: self context root ]		raise: PRConflictingNameError		do: [ :ex | self assert: self context root = ex structure ].	self		shouldnt: [			self command				validateName: 'zork'				of: (self context root childrenDecoration at: 'folder')				in: self context root ]		raise: PRConflictingNameError.	self		shouldnt: [			self command				validateName: 'folder'				of: (self context root childrenDecoration at: 'folder')				in: self context root ]		raise: PRConflictingNameError! !!PRCommandTest methodsFor: 'testing-validating' stamp: 'lr 3/9/2006 11:31'!testValidateNesting	self		shouldnt: [			self command				validateNestingOf: self context root				in: PRPage new ]		raise: PRInvalidNestingError.	self		shouldnt: [			self command				validateNestingOf: PRPage new				in: self context root ]		raise: PRInvalidNestingError! !!PREditCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PREditCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PREditCommand! !!PREditCommandTest methodsFor: 'testing-title' stamp: 'lr 3/9/2006 11:31'!testTitleChanged	| title |	self command		write: (title := 'foo')		using: PRStructure descriptionTitle.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure title = title! !!PREditCommandTest methodsFor: 'testing-title' stamp: 'lr 3/9/2006 11:31'!testTitleInitialized	self assert: (self command readUsing: PRStructure descriptionTitle) = self structure title! !!PREditCommandTest methodsFor: 'testing-title' stamp: 'lr 3/9/2006 11:31'!testTitleUnchanged	| title |	title := self structure title.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure title = title! !!PREditFileCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PREditFileCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!structureInstance	^ PRFile named: 'command'! !!PREditFileCommandTest methodsFor: 'testing-file' stamp: 'lr 3/9/2006 11:31'!testFileChanged	| file |	self command		write: (file := MAFileModel new			contents: 'foobar';			filename: 'test.txt';			mimetype: 'text/plain';			yourself)		using: PRFile descriptionFile.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure file = file! !!PREditFileCommandTest methodsFor: 'testing-file' stamp: 'lr 3/9/2006 11:31'!testFileInitialized	self assert: (self command readUsing: PRFile descriptionFile) = self structure file! !!PREditFileCommandTest methodsFor: 'testing-file' stamp: 'lr 3/9/2006 11:31'!testFileUnchanged	| file |	file := self structure file.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure file = file! !!PREditPageCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PREditPageCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!structureInstance	^ PRPage named: 'command'! !!PREditPageCommandTest methodsFor: 'testing-contents' stamp: 'lr 3/9/2006 11:31'!testContentsChanged	| contents |	self command		write: (contents := '!!foo')		using: PRPage descriptionContents.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure contents = contents! !!PREditPageCommandTest methodsFor: 'testing-contents' stamp: 'lr 3/9/2006 11:31'!testContentsInitialized	self assert: (self command readUsing: PRPage descriptionContents) = self structure contents! !!PREditPageCommandTest methodsFor: 'testing-contents' stamp: 'lr 3/9/2006 11:31'!testContentsUnchanged	| contents |	contents := self structure contents.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure contents = contents! !!PRCopyCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRCopyCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRCopyCommand! !!PRCopyCommandTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:43'!testCopy	self command name: 'foo'.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: (self structure parent childrenDecoration		includes: 'foo').	self assert: (self structure parent childrenDecoration		at: 'foo') = self command answer structure! !!PRCopyCommandTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:43'!testCopyIntoChild	self command		name: 'foo';		target: self structure.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: (self structure childrenDecoration		includes: 'foo').	self assert: (self structure childrenDecoration		at: 'foo') = self command answer structure! !!PRCopyCommandTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:43'!testCopyIntoRoot	self command		name: 'foo';		target: self command root.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: (self command root childrenDecoration		includes: 'foo').	self assert: (self command root childrenDecoration		at: 'foo') = self command answer structure! !!PRCopyCommandTest methodsFor: 'testing' stamp: 'lr 4/10/2006 14:52'!testCopyTitle	self command name: 'foo'; execute.	self assert: (self structure title) = 'Command'.	self assert: (self structure parent childrenDecoration		at: 'foo') title = 'Foo'! !!PRCopyCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testInitialized	super testInitialized.	self assert: self structure name , ' copy' = self command name! !!PRLocationCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRLocationCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRLocationCommand! !!PRLocationCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testConflict	self command name: 'folder'.	self		should: [ self command execute ]		raise: PRConflictingNameError		do: [ :ex | self assert: self kernel root = ex structure ]! !!PRLocationCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testInitialized	self assert: self command target = self structure parent! !!PRMoveCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRMoveCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRMoveCommand! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testInitialized	super testInitialized.	self assert: self structure name = self command name! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testMove	self command target: self command root.	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: (self command root childrenDecoration		includes: self structure name)! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testMoveIntoChild	self command target: self structure.	self		should: [ self command execute ]		raise: PRInvalidNestingError.	self assert: (self structure parent childrenDecoration		includes: self structure name)! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testMoveIntoFolder	self command target: (self command root childrenDecoration		at: 'folder').	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self deny: (self command root childrenDecoration		includes: self structure name).	self assert: ((self command root childrenDecoration		at: 'folder') childrenDecoration			includes: self structure name)! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testRename	self command name: 'foo'.	self		shouldnt: [ self command execute ]		raise: PRConflictingNameError.	self deny: (self structure parent childrenDecoration		includes: 'command').	self assert: (self structure parent childrenDecoration		includes: 'foo')! !!PRMoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testRenameExisting	self command name: 'folder'.	self		should: [ self command execute ]		raise: PRConflictingNameError.	self assert: (self structure parent childrenDecoration		includes: 'command').	self assert: (self structure parent childrenDecoration		includes: 'folder')! !!PRRemoveCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRRemoveCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRRemoveCommand! !!PRRemoveCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsQuick	self assert: self command isQuick! !!PRRemoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testRemoveLeaf	self assert: (self kernel root childrenDecoration		includes: self structure name).	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure parent isNil.	self deny: (self kernel root childrenDecoration		includes: self structure name)! !!PRRemoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testRemoveNode	self structure		addChild: (PRPage named: 'foo');		addChild: (PRPage named: 'bar').	self assert: (self kernel root childrenDecoration		includes: self structure name).	self		shouldnt: [ self command execute ]		raise: PRStructureError.	self assert: self structure parent isNil.	self deny: (self kernel root childrenDecoration		includes: self structure name)! !!PRRemoveCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testRemoveRoot	context := self context		structure: self kernel root		command: self actualClass new.	self		should: [ self command ]		raise: Error! !!PRViewCommandTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRViewCommandTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRViewCommand! !!PRViewCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsLogged	self deny: self command isLogged! !!PRViewCommandTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsView	self assert: self command isView! !!PRViewCommandTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testSimple	self		should: [ self command execute ]		raise: Error! !!PRContextTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRContextTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRContext! !!PRContextTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!context	^ context ifNil: [ context := self contextInstance ]! !!PRContextTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ self context! !!PRContextTest methodsFor: 'testing-navigation' stamp: 'lr 3/9/2006 11:31'!testGotoCommand! !!PRContextTest methodsFor: 'testing-navigation' stamp: 'lr 3/9/2006 11:31'!testGotoStructure	| current currentStructure currentCommand next nextStructure |	currentStructure := self context structure.	currentCommand := self context command.	current := self context.	nextStructure := self context structure childrenDecoration at: 'folder'.	next := self context structure: nextStructure.	self deny: current = next.	self assert: current structure = currentStructure.	self assert: current command = currentCommand.	self assert: next structure = nextStructure.	self assert: next command isView! !!PRContextTest methodsFor: 'testing-navigation' stamp: 'lr 3/9/2006 11:31'!testGotoStructureCommand! !!PRContextTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testInitialState	self assert: self context structure = self context kernel root.	self assert: self context command isView! !!PRDecoratedTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRDecoratedTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRDecorated! !!PRDecoratedTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!decorationWithPriority: anInteger	^ PRMockDecoration new		priority: anInteger;		yourself! !!PRDecoratedTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:31'!testAddDecoration	| mock1 mock2 index1 index2 |	mock1 := self decorationWithPriority: 10.	mock2 := self decorationWithPriority: -5.	self assert: (self instance addDecoration: mock1) = mock1.	self assert: self instance = mock1 decorated.	self assert: (self instance decorations includes: mock1).	self assert: (self instance addDecoration: mock2) = mock2.	self assert: self instance = mock2 decorated.	self assert: (self instance decorations includes: mock2).	index1 := self instance decorations indexOf: mock1.	index2 := self instance decorations indexOf: mock2.	self assert: index1 > index2.	self should: [ self instance addDecoration: mock1 ] raise: Error.	self should: [ self instance addDecoration: mock2 ] raise: Error.	self assert: (self instance decorations includes: mock2).	self assert: (self instance decorations includes: mock2)! !!PRDecoratedTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:31'!testAddDecorationIfPresent	| mock1 mock2 index1 index2 |	mock1 := self decorationWithPriority: 10.	mock2 := self decorationWithPriority: -5.	self assert: (self instance		addDecoration: mock1		ifPresent: [ :value | self assert: false ]) = mock1.	self assert: self instance = mock1 decorated.	self assert: (self instance decorations includes: mock1).	self assert: (self instance		addDecoration: mock2		ifPresent: [ :value | self assert: false ]) = mock2.	self assert: self instance = mock2 decorated.	self assert: (self instance decorations includes: mock2).	index1 := self instance decorations indexOf: mock1.	index2 := self instance decorations indexOf: mock2.	self assert: index1 > index2.	self assert: (self instance		addDecoration: mock1		ifPresent: [ :value | nil ]) isNil.	self assert: (self instance		addDecoration: mock2		ifPresent: [ :value | nil ]) isNil.	self assert: (self instance decorations includes: mock1).	self assert: (self instance decorations includes: mock2)! !!PRDecoratedTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopyDecorations	| decoration copiedInstance copiedDecoration |	decoration := self instance addDecoration: (self decorationWithPriority: SmallInteger minVal).	copiedInstance := self instance copy.	copiedDecoration := copiedInstance decorations first.	self deny: self instance == copiedInstance.	self deny: decoration == copiedDecoration.	self assert: self instance decorations first = decoration.	self assert: self instance = decoration decorated.	self assert: copiedInstance decorations first = copiedDecoration.	self assert: copiedInstance = copiedDecoration decorated! !!PRDecoratedTest methodsFor: 'testing-querying' stamp: 'lr 3/9/2006 11:31'!testDecorationOfClass	| mock |	self should: [ self instance decorationOfClass: PRMockDecoration ] raise: Error.	self instance addDecoration: (mock := self decorationWithPriority: 1).	self assert: (self instance decorationOfClass: PRMockDecoration) = mock! !!PRDecoratedTest methodsFor: 'testing-querying' stamp: 'lr 3/9/2006 11:31'!testDecorationOfClassIfAbsent	| mock |	self assert: (self instance decorationOfClass: PRMockDecoration ifAbsent: [ nil ]) isNil.	self instance addDecoration: (mock := self decorationWithPriority: 1).	self assert: (self instance decorationOfClass: PRMockDecoration) = mock! !!PRDecoratedTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:31'!testDecorationsDo	| first second |	self instance		addDecoration: (first := self decorationWithPriority: SmallInteger minVal);		addDecoration: (second := self decorationWithPriority: SmallInteger maxVal).	self instance decorationsDo: [ :each |		(first notNil and: [ second notNil and: [ each = first ] ])			ifTrue: [ first := nil ].		(first isNil and: [ second notNil and: [ each = second ] ])			ifTrue: [ second := nil ] ].	self assert: first isNil.	self assert: second isNil! !!PRDecoratedTest methodsFor: 'testing-enumerating' stamp: 'lr 3/9/2006 11:31'!testDecorationsDoOwnerDo	| instance first second |	instance := self instance		addDecoration: (first := self decorationWithPriority: SmallInteger minVal);		addDecoration: (second := self decorationWithPriority: SmallInteger maxVal);		yourself.	self instance		decorationsDo: [ :each |			(first notNil and: [ instance notNil and: [ second notNil and: [ each = first ] ] ])				ifTrue: [ first := nil ].			(first isNil and: [ instance isNil and: [ second notNil and: [ each = second ] ] ])				ifTrue: [ second := nil ] ]		ownerDo: [ :each |			self assert: first isNil.			self assert: second notNil.			self assert: instance notNil.			instance := nil ].	self assert: first isNil.	self assert: second isNil.	self assert: instance isNil! !!PRDecoratedTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testInitialized	self assert: (self instance decorations isKindOf: Collection)! !!PRDecoratedTest methodsFor: 'testing-removing' stamp: 'lr 3/9/2006 11:31'!testRemoveDecoration	| mock1 mock2 |	self instance		addDecoration: (mock1 := self decorationWithPriority: 1);		addDecoration: (mock2 := self decorationWithPriority: 2).	self assert: (self instance removeDecoration: mock1) = mock1.	self deny: (self instance decorations includes: mock1).	self assert: (self instance decorations includes: mock2).	self assert: (self instance removeDecoration: mock2) = mock2.	self deny: (self instance decorations includes: mock1).	self deny: (self instance decorations includes: mock2).	self should: [ self instance removeDecoration: mock2 ] raise: Error! !!PRDecoratedTest methodsFor: 'testing-removing' stamp: 'lr 3/9/2006 11:31'!testRemoveDecorationIfAbsent| mock1 mock2 |	self instance		addDecoration: (mock1 := self decorationWithPriority: 1);		addDecoration: (mock2 := self decorationWithPriority: 2).	self assert: (self instance removeDecoration: mock1 ifAbsent: [ nil ]) = mock1.	self deny: (self instance decorations includes: mock1).	self assert: (self instance decorations includes: mock2).	self assert: (self instance removeDecoration: mock2 ifAbsent: [ nil ]) = mock2.	self deny: (self instance decorations includes: mock1).	self deny: (self instance decorations includes: mock2).	self assert: (self instance removeDecoration: mock2 ifAbsent: [ nil ]) isNil! !!PRFileTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRFileTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRFile! !!PRPageTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRPageTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRPage! !!PRPageTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualInstance	^ super actualInstance		contents: '!!A Title-A simple List-Element.';		yourself! !!PRPageTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testContents	self structure contents: nil.	self assert: self structure contents = ''.	self structure contents: ''.	self assert: self structure contents = ''.	self structure contents: 'Foo'.	self assert: self structure contents = 'Foo'! !!PRPageTest methodsFor: 'testing-fulltext' stamp: 'lr 3/9/2006 11:31'!testFullTextSearchCaseInsensitive	| matches |	matches := PRFullTextSearch from: self root find: 'title' caseSensitive: false.	self assert: (matches size = 1 and: [ matches first = self structure ]).	matches := PRFullTextSearch from: self root find: 'Title' caseSensitive: false.	self assert: (matches size = 1 and: [ matches first = self structure ]).	matches := PRFullTextSearch from: self root find: 'list-element' caseSensitive: false.	self assert: (matches size = 1 and: [ matches first = self structure ]).	matches := PRFullTextSearch from: self root find: 'List-Element' caseSensitive: false.	self assert: (matches size = 1 and: [ matches first = self structure ])! !!PRPageTest methodsFor: 'testing-fulltext' stamp: 'lr 3/9/2006 11:31'!testFullTextSearchCaseSensitive	| matches |	matches := PRFullTextSearch from: self root find: 'title' caseSensitive: true.	self assert: (matches size = 0).	matches := PRFullTextSearch from: self root find: 'Title' caseSensitive: true.	self assert: (matches size = 1 and: [ matches first = self structure ]).	matches := PRFullTextSearch from: self root find: 'list-element' caseSensitive: true.	self assert: (matches size = 0).	matches := PRFullTextSearch from: self root find: 'List-Element' caseSensitive: true.	self assert: (matches size = 1 and: [ matches first = self structure ])! !!PRStructureTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRStructureTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRStructure! !!PRStructureTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualInstance	^ self actualClass named: 'structure'! !!PRStructureTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!child	^ child! !!PRStructureTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!childInstance	^ PRPage named: 'child'! !!PRStructureTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:31'!enumerator: aVisitor gives: aCollection	| children |	children := aVisitor contents collect: #name.	self		assert: children asSet = aCollection asSet		description: children asString , ' should be ' , aCollection asString		resumable: true! !!PRStructureTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!folder	^ folder! !!PRStructureTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!folderInstance	^ PRPage named: 'folder'! !!PRStructureTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ structure! !!PRStructureTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!root	^ root! !!PRStructureTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!rootInstance	^ PRPage named: 'root'! !!PRStructureTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:31'!setUp	root := self rootInstance.	folder := self folderInstance.	child := self childInstance.	structure := self actualInstance.	self root addChild: self folder.	self folder addChild: self child.	self folder addChild: self structure! !!PRStructureTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!structure	^ structure! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testCanBeChildOf	PRStructure withAllConcreteClassesDo: [ :each |		self			shouldnt: [ self structure canBeChildOf: each new ]			raise: Error ]! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testCanBeParentOf	PRStructure withAllConcreteClassesDo: [ :each |		self			shouldnt: [ self structure canBeParentOf: each new ]			raise: Error ]! !!PRStructureTest methodsFor: 'testing-children' stamp: 'lr 3/9/2006 11:31'!testChildren	self enumerator: (self root enumerator) gives: #( 'folder' ).	self enumerator: (self root enumerator with) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all) gives: #( 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator with; all) gives: #( 'root' 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator hidden) gives: #( 'folder' ).	self enumerator: (self root enumerator with; hidden) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all; hidden) gives: #( 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator with; all; hidden) gives: #( 'root' 'folder' 'child' 'structure' )! !!PRStructureTest methodsFor: 'testing-children' stamp: 'lr 3/9/2006 11:31'!testChildrenHiddenFolder	self folder addDecoration: PRHider new.	self enumerator: (self root enumerator) gives: #( ).	self enumerator: (self root enumerator with) gives: #( 'root' ).	self enumerator: (self root enumerator all) gives: #( ).	self enumerator: (self root enumerator with; all) gives: #( 'root' ).	self enumerator: (self root enumerator hidden) gives: #( 'folder' ).	self enumerator: (self root enumerator with; hidden) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all; hidden) gives: #( 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator with; all; hidden) gives: #( 'root' 'folder' 'child' 'structure' )! !!PRStructureTest methodsFor: 'testing-children' stamp: 'lr 3/9/2006 11:31'!testChildrenHiddenRoot	self root addDecoration: PRHider new.	self enumerator: (self root enumerator) gives: #( ).	self enumerator: (self root enumerator with) gives: #( ).	self enumerator: (self root enumerator all) gives: #( ).	self enumerator: (self root enumerator with; all) gives: #( ).	self enumerator: (self root enumerator hidden) gives: #( 'folder' ).	self enumerator: (self root enumerator with; hidden) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all; hidden) gives: #( 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator with; all; hidden) gives: #( 'root' 'folder' 'child' 'structure' )! !!PRStructureTest methodsFor: 'testing-children' stamp: 'lr 3/9/2006 11:31'!testChildrenHiddenStructure	self structure addDecoration: PRHider new.	self enumerator: (self root enumerator) gives: #( 'folder' ).	self enumerator: (self root enumerator with) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all) gives: #( 'folder' 'child' ).	self enumerator: (self root enumerator with; all) gives: #( 'root' 'folder' 'child' ).	self enumerator: (self root enumerator hidden) gives: #( 'folder' ).	self enumerator: (self root enumerator with; hidden) gives: #( 'root' 'folder' ).	self enumerator: (self root enumerator all; hidden) gives: #( 'folder' 'child' 'structure' ).	self enumerator: (self root enumerator with; all; hidden) gives: #( 'root' 'folder' 'child' 'structure' )! !!PRStructureTest methodsFor: 'testing-copying' stamp: 'lr 3/21/2006 18:43'!testCopyChildren	| folderCopy childCopy structureCopy |	folderCopy := self folder copy.	childCopy := folderCopy childrenDecoration at: 'child'.	structureCopy := folderCopy childrenDecoration at: 'structure'.	self deny: self folder = folderCopy.	self deny: self child = childCopy.	self deny: self structure = structureCopy.	self assert: self folder parent = self root.	self assert: self child parent = self folder.	self assert: self structure parent = self folder.	self assert: folderCopy parent isNil.	self assert: childCopy parent = folderCopy.	self assert: structureCopy parent = folderCopy! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testHasChildren	self assert: self root hasChildren.	self assert: self folder hasChildren.	self deny: self child hasChildren.	self deny: self structure hasChildren! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testHasParent	self deny: self root hasParent.	self assert: self folder hasParent.	self assert: self child hasParent.	self assert: self structure hasParent! !!PRStructureTest methodsFor: 'testing-visitors' stamp: 'lr 3/9/2006 11:31'!testIncomingReferences! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/21/2006 18:43'!testIncompleteLookup	| lookup |	lookup := PRIncompletePathLookup		start: self root		path: '/folder/zork'.	self assert: lookup key = self folder.	self assert: lookup value = 'zork'.	lookup := PRIncompletePathLookup		start: self structure		path: '../structure/bar'.	self assert: lookup key = self structure.	self assert: lookup value = 'bar'! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testIncompleteLookupIgnored	| lookup |	lookup := PRIncompletePathLookup		start: self folder		path: '../folder/child/foo/bar'.	self assert: lookup key = self child.	self assert: lookup value = 'foo'.	lookup := PRIncompletePathLookup		start: self folder		path: 'foo/bar'.	self assert: lookup key = self folder.	self assert: lookup value = 'foo'! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/21/2006 18:43'!testIncompleteLookupTitle	| lookup |	lookup := PRIncompletePathLookup		start: self root		path: '/Folder/Zork'.	self assert: lookup key = self folder.	self assert: lookup value = 'Zork'.	lookup := PRIncompletePathLookup		start: self structure		path: '../Structure/Bar'.	self assert: lookup key = self structure.	self assert: lookup value = 'Bar'! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsAncestorOf	self assert: (self root isAncestorOf: self root).	self assert: (self root isAncestorOf: self folder).	self assert: (self root isAncestorOf: self child).	self assert: (self root isAncestorOf: self structure).	self deny: (self folder isAncestorOf: self root).	self assert: (self folder isAncestorOf: self folder).	self assert: (self folder isAncestorOf: self child).	self assert: (self folder isAncestorOf: self structure).	self deny: (self child isAncestorOf: self root).	self deny: (self child isAncestorOf: self folder).	self assert: (self child isAncestorOf: self child).	self deny: (self child isAncestorOf: self structure).	self deny: (self structure isAncestorOf: self root).	self deny: (self structure isAncestorOf: self folder).	self deny: (self structure isAncestorOf: self child).	self assert: (self structure isAncestorOf: self structure)! !!PRStructureTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsRoot	self assert: self root isRoot.	self deny: self folder isRoot.	self deny: self child isRoot.	self deny: self structure isRoot! !!PRStructureTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testLevel	self assert: self root level = 1.	self assert: self folder level = 2.	self assert: self child level = 3.	self assert: self structure level = 3! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupComposed	self assert: (PRPathLookup start: self child path: '../child/..') = self folder.	self assert: (PRPathLookup start: self child path: '../child/../') = self folder.	self assert: (PRPathLookup start: self child path: '../structure/..') = self folder.	self assert: (PRPathLookup start: self child path: '../structure/../') = self folder.	self assert: (PRPathLookup start: self child path: '../structure/../child') = self child.	self assert: (PRPathLookup start: self child path: '../structure/../child/') = self child.	self assert: (PRPathLookup start: self child path: '../structure/../structure') = self structure.	self assert: (PRPathLookup start: self child path: '../structure/../structure/') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 15:26'!testLookupComposedTitle	self assert: (PRPathLookup start: self child path: '../Child/..') = self folder.	self assert: (PRPathLookup start: self child path: '../Child/../') = self folder.	self assert: (PRPathLookup start: self child path: '../Structure/..') = self folder.	self assert: (PRPathLookup start: self child path: '../Structure/../') = self folder.	self assert: (PRPathLookup start: self child path: '../Structure/../child') = self child.	self assert: (PRPathLookup start: self child path: '../structure/../Child/') = self child.	self assert: (PRPathLookup start: self child path: '../Structure/../structure') = self structure.	self assert: (PRPathLookup start: self child path: '../structure/../Structure/') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupEmpty	self assert: (PRPathLookup start: self root path: '') = self root.	self assert: (PRPathLookup start: self folder path: '') = self folder.	self assert: (PRPathLookup start: self child path: '') = self child.	self assert: (PRPathLookup start: self structure path: '') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 15:25'!testLookupError	self should: [ PRPathLookup start: self root path: 'unknown' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'unknown/' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folDer' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'fOlder/' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/unknown' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/unknown/' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/unknown/unknown' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/unknown/unknown/' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/instance/unknown' ] raise: Error.	self should: [ PRPathLookup start: self root path: 'folder/instance/unknown/' ] raise: Error! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupParent	self assert: (PRPathLookup start: self root path: '..') = self root.	self assert: (PRPathLookup start: self root path: '../') = self root.	self assert: (PRPathLookup start: self folder path: '..') = self root.	self assert: (PRPathLookup start: self folder path: '../') = self root.	self assert: (PRPathLookup start: self child path: '..') = self folder.	self assert: (PRPathLookup start: self child path: '../') = self folder.	self assert: (PRPathLookup start: self structure path: '..') = self folder.	self assert: (PRPathLookup start: self structure path: '../') = self folder! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupParentParent	self assert: (PRPathLookup start: self root path: '../..') = self root.	self assert: (PRPathLookup start: self root path: '../../') = self root.	self assert: (PRPathLookup start: self folder path: '../..') = self root.	self assert: (PRPathLookup start: self folder path: '../../') = self root.	self assert: (PRPathLookup start: self child path: '../..') = self root.	self assert: (PRPathLookup start: self child path: '../../') = self root.	self assert: (PRPathLookup start: self structure path: '../..') = self root.	self assert: (PRPathLookup start: self structure path: '../..') = self root! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupParsing	self assert: (PRPathLookup new stream: 'abc' readStream; readNext) = 'abc'.	self assert: (PRPathLookup new stream: 'abc/' readStream; readNext) = 'abc'.	self assert: (PRPathLookup new stream: 'abc/def' readStream; readNext) = 'abc'.	self assert: (PRPathLookup new stream: 'abc/def/' readStream; readNext) = 'abc'.	self assert: (PRPathLookup new stream: 'abc' readStream; readNext; readNext) = ''.	self assert: (PRPathLookup new stream: 'abc/' readStream; readNext; readNext) = ''.	self assert: (PRPathLookup new stream: 'abc/def' readStream; readNext; readNext) = 'def'.	self assert: (PRPathLookup new stream: 'abc/def/' readStream; readNext; readNext) = 'def'! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupRelative	self assert: (PRPathLookup start: self structure path: '../structure') = self structure.	self assert: (PRPathLookup start: self structure path: '../structure/') = self structure.	self assert: (PRPathLookup start: self structure path: '../../folder') = self folder.	self assert: (PRPathLookup start: self structure path: '../../folder/') = self folder.	self assert: (PRPathLookup start: self structure path: '../../folder/structure') = self structure.	self assert: (PRPathLookup start: self structure path: '../../folder/structure/') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 15:24'!testLookupRelativeTitle	self assert: (PRPathLookup start: self structure path: '../Structure') = self structure.	self assert: (PRPathLookup start: self structure path: '../Structure/') = self structure.	self assert: (PRPathLookup start: self structure path: '../../Folder') = self folder.	self assert: (PRPathLookup start: self structure path: '../../Folder/') = self folder.	self assert: (PRPathLookup start: self structure path: '../../Folder/Structure') = self structure.	self assert: (PRPathLookup start: self structure path: '../../Folder/Structure/') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 11:31'!testLookupRoot	self assert: (PRPathLookup start: self root path: '/') = self root.	self assert: (PRPathLookup start: self root path: '/folder') = self folder.	self assert: (PRPathLookup start: self root path: '/folder/child') = self child.	self assert: (PRPathLookup start: self root path: '/folder/structure') = self structure.	self assert: (PRPathLookup start: self structure path: '/') = self root.	self assert: (PRPathLookup start: self structure path: '/folder') = self folder.	self assert: (PRPathLookup start: self structure path: '/folder/child') = self child.	self assert: (PRPathLookup start: self structure path: '/folder/structure') = self structure! !!PRStructureTest methodsFor: 'testing-lookup' stamp: 'lr 3/9/2006 15:24'!testLookupRootTitle	self assert: (PRPathLookup start: self root path: '/Folder') = self folder.	self assert: (PRPathLookup start: self root path: '/Folder/Child') = self child.	self assert: (PRPathLookup start: self root path: '/Folder/Structure') = self structure.	self assert: (PRPathLookup start: self structure path: '/Folder') = self folder.	self assert: (PRPathLookup start: self structure path: '/Folder/Child') = self child.	self assert: (PRPathLookup start: self structure path: '/Folder/Structure') = self structure! !!PRStructureTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self assert: self root name = 'root'.	self assert: self folder name = 'folder'.	self assert: self child name = 'child'.	self assert: self structure name = 'structure'! !!PRStructureTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testParent	self assert: self root parent = nil.	self assert: self folder parent = root.	self assert: self child parent = folder.	self assert: self structure parent = folder! !!PRStructureTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testParents	self assert: self root parents size = 1.	self assert: self root parents first = self root.	self assert: self folder parents size = 2.	self assert: self folder parents first = self root.	self assert: self folder parents second = self folder.	self assert: self child parents size = 3.	self assert: self child parents first = self root.	self assert: self child parents second = self folder.	self assert: self child parents third = self child.	self assert: self structure parents size = 3.	self assert: self structure parents first = self root.	self assert: self structure parents second = self folder.	self assert: self structure parents third = self structure! !!PRStructureTest methodsFor: 'testing-reference' stamp: 'lr 3/9/2006 11:31'!testReferenceEmpty	self assert: (PRPathReference from: self root to: self root) = '/'.	self assert: (PRPathReference from: self folder to: self folder) = ''.	self assert: (PRPathReference from: self child to: self child) = ''.	self assert: (PRPathReference from: self structure to: self structure) = ''! !!PRStructureTest methodsFor: 'testing-reference' stamp: 'lr 3/9/2006 11:31'!testReferenceError	self should: [ PRPathReference from: self root to: PRPage new ] raise: Error.	self should: [ PRPathReference from: self folder to: PRPage new ] raise: Error.	self should: [ PRPathReference from: self child to: PRPage new ] raise: Error.	self should: [ PRPathReference from: self structure to: PRPage new ] raise: Error.	self should: [ PRPathReference from: PRPage new to: self root  ] raise: Error.	self should: [ PRPathReference from: PRPage new to: self folder ] raise: Error.	self should: [ PRPathReference from: PRPage new to: self child ] raise: Error.	self should: [ PRPathReference from: PRPage new to: self structure ] raise: Error! !!PRStructureTest methodsFor: 'testing-reference' stamp: 'lr 3/9/2006 11:31'!testReferenceParent	self assert: (PRPathReference from: self folder to: self root) = '..'.	self assert: (PRPathReference from: self child to: self folder) = '..'.	self assert: (PRPathReference from: self structure to: self folder) = '..'.	self assert: (PRPathReference from: self child to: self root) = '../..'.	self assert: (PRPathReference from: self structure to: self root) = '../..'! !!PRStructureTest methodsFor: 'testing-reference' stamp: 'lr 3/9/2006 11:31'!testReferenceRelative	self assert: (PRPathReference from: self child to: self structure) = '../structure'.	self assert: (PRPathReference from: self structure to: self child) = '../child'! !!PRStructureTest methodsFor: 'testing-reference' stamp: 'lr 3/9/2006 11:31'!testReferenceRoot	self assert: (PRPathReference to: self root) = '/'.	self assert: (PRPathReference to: self folder) = '/folder'.	self assert: (PRPathReference to: self child) = '/folder/child'.	self assert: (PRPathReference to: self structure) = '/folder/structure'.	self assert: (PRPathReference from: self root to: self root) = '/'.	self assert: (PRPathReference from: self root to: self folder) = '/folder'.	self assert: (PRPathReference from: self root to: self child) = '/folder/child'.	self assert: (PRPathReference from: self root to: self structure) = '/folder/structure'! !!PRStructureTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testRoot	self assert: self root root = self root.	self assert: self folder root = self root.	self assert: self child root = self root.	self assert: self structure root = self root! !!PRChildrenTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRChildrenTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRChildren! !!PRChildrenTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!firstChildInstance	^ PRPage named: 'child1'! !!PRChildrenTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!secondChildInstance	^ PRPage named: 'child2'! !!PRChildrenTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:31'!testAdd	| child1 child2 |	child1 := self firstChildInstance.	self assert: (self decoration add: child1) = child1.	self assert: self decorated = child1 parent.	child2 := self secondChildInstance.	self assert: (self decoration add: child2) = child2.	self assert: self decorated = child2 parent! !!PRChildrenTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:31'!testAddInvalid	| plain empty duplicate parented |	self decoration add: self firstChildInstance.	plain := PRPage new.	empty := PRPage named: ''.	duplicate := PRPage named: self firstChildInstance name.	parented := self secondChildInstance		parent: self firstChildInstance;		yourself.	self should: [ self decoration add: plain ] raise: Error.	self should: [ self decoration add: empty ] raise: Error.	self should: [ self decoration add: duplicate ] raise: Error.	self should: [ self decoration add: parented ] raise: Error! !!PRChildrenTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAt	| child1 child2 |	self decoration		add: (child1 := self firstChildInstance);		add: (child2 := self secondChildInstance).	self assert: (self decoration at: child1 name) = child1.	self assert: (self decoration at: child2 name) = child2.	self should: [ self decoration at: 'zork' ] raise: Error! !!PRChildrenTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAtIfAbsent	| child1 child2 |	self decoration		add: (child1 := self firstChildInstance);		add: (child2 := self secondChildInstance).	self assert: (self decoration at: child1 name ifAbsent: [ nil ]) = child1.	self assert: (self decoration at: child2 name ifAbsent: [ nil ]) = child2.	self assert: (self decoration at: 'zork' ifAbsent: [ nil ]) isNil! !!PRChildrenTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAtIfPresent	| child1 child2 |	self decoration		add: (child1 := self firstChildInstance);		add: (child2 := self secondChildInstance).	self assert: (self decoration		at: child1 name		ifPresent: [ :val | val ]) = child1.	self assert: (self decoration		at: child2 name		ifPresent: [ :val | 'zork' ]) = 'zork'.	self assert: (self decoration		at: 'zork'		ifPresent: [ :val | self assert: false ]) isNil! !!PRChildrenTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testIncludes	| child1 child2 |	self decoration		add: (child1 := self firstChildInstance);		add: (child2 := self secondChildInstance).	self assert: (self decoration includes: child1 name).	self assert: (self decoration includes: child2 name).	self deny: (self decoration includes: 'zork')! !!PRChildrenTest methodsFor: 'testing-testing' stamp: 'lr 9/25/2006 08:20'!testIsEmpty	self assert: self decoration isEmpty.	self decoration add: self firstChildInstance.	self deny: self decoration isEmpty! !!PRChildrenTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:31'!testRemove	| child1 child2 |	self decoration		add: (child1 := self firstChildInstance);		add: (child2 := self secondChildInstance).	self assert: (self decoration remove: child1) = child1.	self assert: (self decoration remove: child2) = child2.	self assert: (self decoration isEmpty)! !!PRChildrenTest methodsFor: 'testing-actions' stamp: 'lr 3/9/2006 11:31'!testRemoveInvalid	self decoration add: self firstChildInstance.	self should: [ self decoration remove: self firstChildInstance ] raise: Error.	self should: [ self decoration remove: self secondChildInstance ] raise: Error! !!PRChildrenTest methodsFor: 'testing-actions' stamp: 'lr 9/25/2006 08:18'!testRemoveLast	"Tests that the children decoration is properly removed if the last child has been removed from the decoration."	| child |	self decoration		add: (child := self firstChildInstance).	self decoration		remove: child.	self decorated		decorationOfClass: self actualClass		ifAbsent: [ ^ self ].	self assert: false! !!PRDecorationTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRDecorationTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRDecoration! !!PRDecorationTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualInstance	^ self actualClass new! !!PRDecorationTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!decorated	^ decorated! !!PRDecorationTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!decoratedInstance	^ PRPage new! !!PRDecorationTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!decoration	^ decoration! !!PRDecorationTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ decoration! !!PRDecorationTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:31'!setUp	decorated := self decoratedInstance.	decoration := self actualInstance.	decorated addDecoration: decoration! !!PRDecorationTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopyDecorated	| ownerCopy decorationCopy |	ownerCopy := self decorated copy.	decorationCopy := ownerCopy decorations first.	self deny: self decorated == ownerCopy.	self deny: self decorated == decorationCopy.	self assert: self decorated decorations size = 1.	self assert: self decorated decorations first = self decoration.	self assert: self decorated = self decoration decorated.	self assert: ownerCopy decorations size = 1.	self assert: ownerCopy decorations first = decorationCopy.	self assert: ownerCopy = decorationCopy decorated! !!PRDecorationTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopyDecoration	| decorationCopy |	decorationCopy := self decoration copy.	self deny: self decoration == decorationCopy.	self assert: self decoration = decorationCopy.	self assert: self decoration decorated = self decorated.	self assert: decorationCopy decorated isNil! !!PRDecorationTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testDecorated	self assert: self decoration decorated = self decorated! !!PRDecorationTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testPriority	self assert: self decoration priority isNumber! !!PRDecorationTest methodsFor: 'testing-utilities' stamp: 'lr 9/25/2006 08:23'!testRemove	self decoration remove.	self assert: self decoration decorated isNil.	self decorated 		decorationOfClass: self actualClass		ifAbsent: [ ^ self ].	self assert: false! !!PRHiderTest class methodsFor: 'testing' stamp: 'lr 9/25/2006 08:21'!isAbstract	^ false! !!PRHiderTest methodsFor: 'as yet unclassified' stamp: 'lr 9/25/2006 08:21'!actualClass	^ PRHider! !!PRAnchorTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRAnchorTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRAnchor! !!PRAnchorTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualName	self deny: (self actualClass with: 'foo') = (self actualClass with: 'bar')! !!PRAnchorTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self instance name: 'zork'.	self assert: self instance name = 'zork'! !!PRAnchorTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := '@name'.	tree := PRDocument new		add: (PRAnchor with: 'name');		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRAnchorTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseMultiple	| wiki tree |	wiki := '@one@two@tree'.	tree := PRDocument new		add: (PRAnchor with: 'one');		add: (PRAnchor with: 'two');		add: PRParagraph new;		add: (PRAnchor with: 'tree');		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRAnchorTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpaces	| wiki tree |	wiki := '@one two'.	tree := PRDocument new		add: (PRAnchor with: 'one two');		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRAnchorTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWith	instance := self actualClass with: 'test'.	self assert: self instance name = 'test'! !!PRDocumentGroupTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRDocumentGroup! !!PRDocumentGroupTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:31'!testAdd	self instance add: self fooInstance.	self assert: self instance children size = 1.	self assert: self instance children first = self fooInstance.	self instance add: self barInstance.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance! !!PRDocumentGroupTest methodsFor: 'testing-adding' stamp: 'lr 3/9/2006 11:31'!testAddAll	self instance addAll: self foobarInstances.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance! !!PRDocumentGroupTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopyChildren	self instance addAll: self foobarInstances.	self assert: self instance children = self instance copy children.	self deny: self instance children == self instance copy children.	self instance children		with: self instance copy children		do: [ :a :b | self assert: a = b. self deny: a == b ]! !!PRDocumentGroupTest methodsFor: 'testing-testing' stamp: 'lr 3/20/2006 19:08'!testHasChildren	self deny: self instance hasChildren.	self instance add: self fooInstance.	self assert: self instance hasChildren! !!PRDocumentGroupTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self instance addAll: self foobarInstances.	self assert: self instance text = 'foobar'! !!PRDocumentGroupTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWith	instance := self actualClass with: self fooInstance.	self assert: instance children size = 1.	self assert: instance children first = self fooInstance! !!PRDocumentGroupTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWithAll	instance := self actualClass withAll: self foobarInstances.	self assert: instance children size = 2.	self assert: instance children first = self fooInstance.	self assert: instance children second = self barInstance! !!PRDocumentTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRDocumentTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRDocument! !!PRDocumentTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := String new.	tree := PRDocument new.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRHeaderTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRHeader! !!PRHeaderTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualLevel	self deny: (self actualClass new level: 1) = (self actualClass new level: 2)! !!PRHeaderTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self instance level: 3.	self assert: self instance level = 3! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel1	| wiki tree |	wiki := '!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 1;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel2	| wiki tree |	wiki := '!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel3	| wiki tree |	wiki := '!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 3;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel4	| wiki tree |	wiki := '!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 4;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel5	| wiki tree |	wiki := '!!!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 5;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLevel6	| wiki tree |	wiki := '!!!!!!!!!!!!foo'.	tree := PRDocument new		add: (PRHeader new			level: 6;			add: (PRText with: 'foo');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-parsing' stamp: 'lr 5/29/2006 09:12'!testParseNested	| wiki tree |	wiki := '!!!!Hello *Link*'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText with: 'Hello ');			add: (PRInternalLink new				reference: 'Link';				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHeaderTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWithAllLevel	instance := self actualClass withAll: self foobarInstances level: 3.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance.	self assert: self instance level = 3! !!PRHeaderTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWithLevel	instance := self actualClass with: self fooInstance level: 2.	self assert: self instance children size = 1.	self assert: self instance children first = self fooInstance.	self assert: self instance level = 2! !!PRExternalLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRExternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRExternalLink! !!PRExternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRExternalLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testUrl	self instance reference: 'http://www.lukas-renggli.ch'.	self assert: self instance url = 'http://www.lukas-renggli.ch'! !!PRIsbnLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRIsbnLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRIsbnLink! !!PRIsbnLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'isbn:1590594916'! !!PRIsbnLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testUrl	self instance reference: 'isbn:1590594916'.	self assert: self instance url = 'http://www.amazon.com/exec/obidos/ISBN=1590594916'! !!PRMailLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRMailLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRMailLink! !!PRMailLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'renggli@iam.unibe.ch'! !!PRMailLinkTest methodsFor: 'testing-accessing' stamp: 'lr 5/24/2006 11:14'!testUrl	self instance reference: 'renggli@iam.unibe.ch'.	self assert: (self instance url beginsWith: 'mailto:').	self assert: self instance url ~= 'mailto:renggli@iam.unibe.ch'! !!PRRfcLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRRfcLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRRfcLink! !!PRRfcLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'rfc:1896'! !!PRRfcLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testUrl	self instance reference: 'rfc:1896'.	self assert: self instance url = 'http://www.faqs.org/rfcs/rfc1896.html'! !!PRInternalLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRInternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRInternalLink! !!PRInternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'Page'! !!PRInternalLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAnchor	self instance anchor: 'zork'.	self assert: self instance anchor = 'zork'.	self assert: self instance hasAnchor! !!PRInternalLinkTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualAnchor	self deny: (self actualClass new anchor: 'foo'; yourself) = ((self actualClass new) anchor: 'bar'; yourself)! !!PRInternalLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseAnchored	| wiki tree |	wiki := '*' , self referenceString , '@Anchor*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRInternalLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseAnchoredEmbedded	| wiki tree |	wiki := '+' , self referenceString , '@Anchor+'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				embedded: true;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRInternalLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEverything	| wiki tree |	wiki := '*Alias>' , self referenceString , '@Anchor*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText with: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRInternalLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEverythingEmbedded	| wiki tree |	wiki := '+Alias>' , self referenceString , '@Anchor+'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText with: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				embedded: true;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRLink! !!PRLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	self subclassResponsibility! !!PRLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAlias	self deny: self instance hasAlias.	self instance add: self fooInstance.	self assert: self instance hasAlias.	self assert: self instance alias = 'foo'.	self instance add: self barInstance.	self assert: self instance hasAlias.	self assert: self instance alias = 'foobar'! !!PRLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAnchor	self deny: self instance hasAnchor! !!PRLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testEmbedded	self instance embedded: true.	self assert: self instance isEmbedded.	self instance embedded: false.	self deny: self instance isEmbedded! !!PRLinkTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualEmbedded	self deny: (self actualClass new embedded: false; yourself) = (self actualClass new embedded: true; yourself)! !!PRLinkTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualReference	self deny: (self actualClass new reference: 'foo'; yourself) = (self actualClass new reference: 'bar'; yourself)! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseAliased	| wiki tree |	wiki := '*Alias>' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText with: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := '*' , self referenceString , '*'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEasyness	| wiki1 wiki2 tree |	wiki1 := '**' , self referenceString.	wiki2 := '\*\*' , self referenceString.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '*');			yourself);		add: (PRParagraph new			add: (PRText with: '*' , self referenceString);			yourself);		yourself.	self assertParsing: wiki1 gives: tree.	self assertParsing: wiki2 gives: tree.	self assertVisiting: tree gives: wiki2! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEasynessEmbedded	| wiki1 wiki2 tree |	wiki1 := '++' , self referenceString.	wiki2 := '\+\+' , self referenceString.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '+');			yourself);		add: (PRParagraph new			add: (PRText with: '+' , self referenceString);			yourself);		yourself.	self assertParsing: wiki1 gives: tree.	self assertParsing: wiki2 gives: tree.	self assertVisiting: tree gives: wiki2! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEmbeddedAliased	| wiki tree |	wiki := '+Alias>' , self referenceString , '+'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText with: 'Alias');				reference: self referenceString;				embedded: true;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEmbeddedBasic	| wiki tree |	wiki := '+' , self referenceString , '+'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				embedded: true;				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEscaped	| wiki tree |	wiki := 'Star \*' , self referenceString , '\*Cross \+' , self referenceString , '\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Star *' , self referenceString , '*');			yourself);		add: (PRParagraph new			add: (PRText with: 'Cross +' , self referenceString , '+');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRLinkTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testReference	self instance reference: 'zork'.	self assert: self instance reference = 'zork'! !!PRListItemTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRListItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRListItem! !!PRListTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRList! !!PRListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!elementString	self subclassResponsibility! !!PRListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!listItemWithText: aString	^ PRListItem new		add: (PRText with: aString);		yourself! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseFlat	| wiki tree |	wiki := self elementString , '1st' , self elementString , '2nd' , self elementString , '3rd'.	tree := PRDocument new		add: (self actualClass new			add: (self listItemWithText: '1st');			add: (self listItemWithText: '2nd');			add: (self listItemWithText: '3rd');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseMixed	| wiki tree |	wiki := '#1#2-3'.	tree := PRDocument new		add: (PROrderedList new			add: (self listItemWithText: '1');			add: (self listItemWithText: '2');			yourself);		add: (PRUnorderedList new			add: (self listItemWithText: '3');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseMultiple	| wiki tree |	wiki := self elementString , '1st' , self elementString , '2nd'				, self elementString , '3rd'.	tree := (PRDocument new)				add: ((self actualClass new)							add: (self listItemWithText: '1st');							add: (self listItemWithText: '2nd');							yourself);				add: PRParagraph new;				add: ((self actualClass new)							add: (self listItemWithText: '3rd');							yourself);				yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseNested1	| wiki tree |	wiki := self elementString , '1' , self elementString , self elementString , '1.1' , self elementString , self elementString , '1.2'.	tree := PRDocument new		add: (self actualClass new			add: (PRListItem new				add: (PRText with: '1');				add: (self actualClass new					add: (self listItemWithText: '1.1');					add: (self listItemWithText: '1.2');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseNested2	| wiki tree |	wiki := self elementString , '1' , self elementString , self elementString , '1.1' , self elementString , self elementString , self elementString , '1.1.1'.	tree := PRDocument new		add: (self actualClass new			add: (PRListItem new				add: (PRText with: '1');				add: (self actualClass new					add: (PRListItem new						add: (PRText with: '1.1');						add: (self actualClass new							add: (self listItemWithText: '1.1.1');							yourself);						yourself);					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRListTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseNested3	| wiki tree |	wiki := self elementString , '1' , self elementString , '#1.1' , self elementString , '#1.2' , self elementString , '-1.3'.	tree := PRDocument new		add: (self actualClass new			add: (PRListItem new				add: (PRText with: '1');				add: (PROrderedList new					add: (self listItemWithText: '1.1');					add: (self listItemWithText: '1.2');					yourself);				add: (PRUnorderedList new					add: (self listItemWithText: '1.3');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PROrderedListTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PROrderedListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PROrderedList! !!PROrderedListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!elementString	^ '#'! !!PRUnorderedListTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRUnorderedListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRUnorderedList! !!PRUnorderedListTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!elementString	^ '-'! !!PRParagraphTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRParagraphTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRParagraph! !!PRParagraphTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRParagraphTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseClose	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.Nulla mattis elementum nulla. Duis pretium magna et sem. Phasellus blandit. Ut non dolor at pede auctor semper. Donec semper dignissim ipsum. Nunc ultrices dui id ligula. Pellentesque neque. Aenean placerat nunc ut diam. Vivamus luctus magna vel velit. Donec ultricies orci eget erat. Nulla elementum ligula non est.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.');			yourself);		add: (PRParagraph new			add: (PRText with: 'Nulla mattis elementum nulla. Duis pretium magna et sem. Phasellus blandit. Ut non dolor at pede auctor semper. Donec semper dignissim ipsum. Nunc ultrices dui id ligula. Pellentesque neque. Aenean placerat nunc ut diam. Vivamus luctus magna vel velit. Donec ultricies orci eget erat. Nulla elementum ligula non est.');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRParagraphTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpare	| wiki tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.Nulla mattis elementum nulla. Duis pretium magna et sem. Phasellus blandit. Ut non dolor at pede auctor semper. Donec semper dignissim ipsum. Nunc ultrices dui id ligula. Pellentesque neque. Aenean placerat nunc ut diam. Vivamus luctus magna vel velit. Donec ultricies orci eget erat. Nulla elementum ligula non est.'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna. Vestibulum turpis. Duis non mauris non sapien consectetuer vulputate. Duis quis pede. Nullam libero. Mauris ut turpis.');			yourself);		add: (PRParagraph new);		add: (PRParagraph new			add: (PRText with: 'Nulla mattis elementum nulla. Duis pretium magna et sem. Phasellus blandit. Ut non dolor at pede auctor semper. Donec semper dignissim ipsum. Nunc ultrices dui id ligula. Pellentesque neque. Aenean placerat nunc ut diam. Vivamus luctus magna vel velit. Donec ultricies orci eget erat. Nulla elementum ligula non est.');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRPreformattedTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRPreformattedTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRPreformatted! !!PRPreformattedTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := '=Line'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText with: 'Line');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRPreformattedTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseMultiple	| wiki tree |	wiki := '=line 1.1=line 1.2=line 2.1'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText with: 'line 1.1');			add: (PRText with: 'line 1.2');			yourself);		add: (PRParagraph new);		add: (PRPreformatted new			add: (PRText with: 'line 2.1');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRPreformattedTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpaces	| wiki tree |	wiki := '=   A line with 3 spaces=	A line with a tab'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText with: '   A line with 3 spaces');			add: (PRText with: '	A line with a tab');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRPreformattedTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpecials	| wiki tree |	wiki := '=|, {, }, *, *, [, ||, |{, |}, +, +'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText with: '|, {, }, *, *, [, ||, |{, |}, +, +');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableCellTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRTableCellTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRTableCell! !!PRTableCellTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testAlign	self instance align: #right.	self assert: self instance align = #right! !!PRTableCellTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedCenter	self instance beAlignedCenter.	self assert: self instance align = #center.	self assert: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedLeft	self instance beAlignedLeft.	self assert: self instance align = #left.	self deny: self instance isAlignedCenter.	self assert: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedRight	self instance beAlignedRight.	self assert: self instance align = #right.	self deny: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self assert: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualAlign	self deny: self actualClass new beAlignedRight				= self actualClass new beAlignedCenter.	self deny: self actualClass new beAlignedCenter				= self actualClass new beAlignedLeft! !!PRTableCellTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseAlign1	| wiki tree |	wiki := '|{left||center|}right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedLeft;					add: (PRText with: 'left');					yourself);				add: (PRTableCell new					beAlignedCenter;					add: (PRText with: 'center');					yourself);				add: (PRTableCell new					beAlignedRight;					add: (PRText with: 'right');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableCellTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseAlign2	| wiki tree |	wiki := '|}right|none|{left|none'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedRight;					add: (PRText with: 'right');					yourself);				add: (PRTableCell new					add: (PRText with: 'none');					yourself);				add: (PRTableCell new					beAlignedLeft;					add: (PRText with: 'left');					yourself);				add: (PRTableCell new					add: (PRText with: 'none');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableCellTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseEncoding	| wiki tree |	wiki := '|*link*|+embedded+|foo{}'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRInternalLink new						reference: 'link';						yourself);					yourself);				add: (PRTableCell new					add: (PRInternalLink new						reference: 'embedded';						embedded: true;						yourself);					yourself);				add: (PRTableCell new					add: (PRText with: 'foo{}');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableRowTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRTableRowTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRTableRow! !!PRTableRowTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testCount	self instance add: PRTableCell new.	self assert: self instance columnCount = 1.	self instance add: PRTableCell new.	self assert: self instance columnCount = 2! !!PRTableTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRTableTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRTable! !!PRTableTest methodsFor: 'testing-accessing' stamp: 'lr 3/21/2006 18:43'!testCount	self instance add: (PRTableRow new add: PRTableCell new; yourself).	self assert: self instance rowCount = 1; assert: self instance columnCount = 1.	self instance add: (PRTableRow new add: PRTableCell new; add: PRTableCell new; yourself).	self assert: self instance rowCount = 2; assert: self instance columnCount = 2.	self instance add: (PRTableRow new add: PRTableCell new; yourself).	self assert: self instance rowCount = 3; assert: self instance columnCount = 2! !!PRTableTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := '|cell'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'cell');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSquare	| wiki tree |	wiki := '|a11|a12|a21|a22'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'a11');					yourself);				add: (PRTableCell new					add: (PRText with: 'a12');					yourself);				yourself);			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'a21');					yourself);				add: (PRTableCell new					add: (PRText with: 'a22');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTableTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseTriangle	| wiki tree |	wiki := '|a11|a21|a22|a31|a32|a33'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'a11');					yourself);				yourself);			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'a21');					yourself);				add: (PRTableCell new					add: (PRText with: 'a22');					yourself);				yourself);			add: (PRTableRow new				add: (PRTableCell new					add: (PRText with: 'a31');					yourself);				add: (PRTableCell new					add: (PRText with: 'a32');					yourself);				add: (PRTableCell new					add: (PRText with: 'a33');					yourself);				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRDocumentItem! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualInstance	^ self actualClass new! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:31'!assertParsing: aString gives: anObject	self		assert: (PRDocumentParser parse: aString) = anObject		description: aString resumable: true! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:31'!assertVisiting: anObject gives: aString	self		assert: (PRDocumentWriter write: anObject) = aString		description: aString resumable: true! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!barInstance	^ PRText with: 'bar'! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!fooInstance	^ PRText with: 'foo'! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRDocumentItemTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ instance! !!PRDocumentItemTest methodsFor: 'running' stamp: 'lr 3/9/2006 11:31'!setUp	super setUp.	instance := self actualInstance! !!PRDocumentItemTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopy	self assert: self instance = self instance copy.	self assert: self instance hash = self instance copy hash.	self deny: self instance == self instance copy! !!PRDocumentItemTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqueal	self assert: self instance = self instance.	self assert: self instance = self actualInstance! !!PRDocumentItemTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEquealNil	self deny: self instance isNil! !!PRDocumentItemTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEquealOther	self deny: self instance = self fooInstance.	self deny: self instance = self barInstance! !!PRDocumentItemTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testHasChildren	self deny: self instance hasChildren! !!PRDocumentItemTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testHasOwner	self deny: self instance hasOwner! !!PRDocumentItemTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testHash	self assert: self instance hash = self instance copy hash! !!PRDocumentItemTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testOwner	self assert: self instance owner isNil! !!PRDocumentItemTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self assert: self instance text isString! !!PRHorizontalRuleTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRHorizontalRuleTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRHorizontalRule! !!PRHorizontalRuleTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := '_'.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHorizontalRuleTest methodsFor: 'testing-parsing' stamp: 'lr 3/20/2006 17:48'!testParseLink	| wiki tree |	wiki := '_ *link*'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '_ ');			add: (PRInternalLink new				reference: 'link';				yourself);			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHorizontalRuleTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseMultiple	| wiki tree |	wiki := '___'.	tree := PRDocument new		add: PRHorizontalRule new;		add: PRHorizontalRule new;		add: PRParagraph new;		add: PRHorizontalRule new;		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHorizontalRuleTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseParagraph	| wiki tree |	wiki := '_ is parsed as paragraph'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '_ is parsed as paragraph');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRHorizontalRuleTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpaces	| wiki tree |	wiki := '_       '.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self assertParsing: wiki gives: tree! !!PRTextTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRTextTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRText! !!PRTextTest methodsFor: 'testing-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualText	self deny: (self actualClass with: 'foo') = (self actualClass with: 'bar')! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testEscapeFirst	| wiki tree |	wiki := '\* text\+ text\= text\@ text\!! text\| text\# text\- text'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '* text');			yourself);		add: (PRParagraph new			add: (PRText with: '+ text');			yourself);		add: (PRParagraph new			add: (PRText with: '= text');			yourself);		add: (PRParagraph new			add: (PRText with: '@ text');			yourself);		add: (PRParagraph new			add: (PRText with: '!! text');			yourself);		add: (PRParagraph new			add: (PRText with: '| text');			yourself);		add: (PRParagraph new			add: (PRText with: '# text');			yourself);		add: (PRParagraph new			add: (PRText with: '- text');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testEscapeStrange	| wiki tree |	wiki := '< text> text'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '< text');			yourself);		add: (PRParagraph new			add: (PRText with: '> text');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testEscapeText	| wiki tree |	wiki := 'Text: \*\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Text: *+');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testEscapeWiki	| wiki tree |	wiki := 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseBasic	| wiki tree |	wiki := 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseHtml	| wiki tree |	wiki := '<strong>strong <emph>strong, emph</emph></strong>'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '<strong>strong <emph>strong, emph</emph></strong>');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseLatex	| wiki tree |	wiki := '\begin{foo}[bar]$zork$\end{foo}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '\begin{foo}[bar]$zork$\end{foo}');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseSpecial	| wiki tree |	wiki := '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: '????????????¬å???????????????¬ú??¬ü¬¬°¬¢¬£¬§¬·?¬ß?¬©¬¬´¬¨?¬Æ¬Ø¬¬±???¬µ¬¬??¬¬ª???¬ø¦Ä¦Å¦Ç¦É¦Ñ¦Ö¦Ü¦á¦à¦â¦ä¦ã¦å¦ç¦é¦è?¦ë¦í¦ì¦î¦ï¦ñ?¦ò¦ô¦ö¦õ¦ú??¦ü¦¦°¦¢¦£¦§¦·¦¶¦ß¦®¦©¦¦´¦¨¦¦Æ¦Ø?¦±¦¦¦¥¦µ¦¦¦¦¦¦ª¦º??');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-parsing' stamp: 'lr 3/9/2006 11:31'!testParseWiki	| wiki tree |	wiki := ' !!_#-|=]@:<>\*'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText with: ' !!_#-|=]@:<>*');			yourself);		yourself.	self assertParsing: wiki gives: tree.	self assertVisiting: tree gives: wiki! !!PRTextTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self instance text: 'zork'.	self assert: self instance text = 'zork'! !!PRTextTest methodsFor: 'testing-instantiation' stamp: 'lr 3/9/2006 11:31'!testWith	instance := self actualClass with: 'zork'.	self assert: self instance text = 'zork'! !!PRKernelTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PRKernelTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRKernel! !!PRKernelTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	^ self kernel! !!PRKernelTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!kernel	^ kernel ifNil: [ kernel := self kernelInstance ]! !!PRKernelTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:43'!testInitialState	self deny: self kernel mutex isNil.	self deny: self kernel name isNil.	self deny: self kernel persistency isNil.	self deny: self kernel root isNil! !!PRKernelTest methodsFor: 'testing-mutex' stamp: 'lr 3/9/2006 11:31'!testMutexError	"An error inside the critical section should properly unlock it for others to enter."	| marker |	marker := nil.	self		should: [ self kernel critical: [ Error signal ] ]		raise: Error.	self kernel critical: [ marker := 1 ].	self assert: marker = 1! !!PRKernelTest methodsFor: 'testing-mutex' stamp: 'lr 3/9/2006 11:31'!testMutexForked	"Two different processed are not allowed to be inside the critical section at once."	| in1 sem1 in2 sem2  |	in1 := false.	in2 := false.	sem1 := Semaphore new.	sem2 := Semaphore new.	[ self kernel critical: [ in1 := true. sem1 signal. sem2 wait ] ] fork.	[ self kernel critical: [ in2 := true. sem1 signal. sem2 wait ] ] fork.	sem1 wait.	self deny: in1 = in2.	sem2 signal.	sem1 wait.	self assert: in1 = in2.	sem2 signal! !!PRKernelTest methodsFor: 'testing-mutex' stamp: 'lr 3/9/2006 11:31'!testMutexNested	"Critical sections should be nestable to any level within one process."	| marker |	marker := nil.	self kernel critical: [		self kernel critical: [			marker := 1 ] ].	self assert: marker = 1.	self kernel critical: [		self kernel critical: [			self kernel critical: [				marker := 2 ] ] ].	self assert: marker = 2! !!PRKernelTest methodsFor: 'testing-mutex' stamp: 'lr 3/9/2006 11:31'!testMutexSimple	| marker |	marker := nil.	self kernel critical: [ marker := 1 ].	self assert: marker = 1! !!PRKernelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self kernel name: 'kernel'.	self assert: self kernel name = 'kernel'! !!PRKernelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testPersistency	| persistency |	self kernel persistency: (persistency := PRNullPersistency new).	self assert: self kernel persistency = persistency.	self assert: self kernel = persistency kernel! !!PRKernelTest methodsFor: 'testing-accessing' stamp: 'lr 3/9/2006 11:31'!testRoot	| structure |	self kernel root: (structure := PRPage new).	self assert: self kernel root = structure! !!PRObjectTest class methodsFor: 'building' stamp: 'lr 3/9/2006 11:31'!buildTestClassFor: aClass	" self buildTestClassFor: PRObject "	| thisName thisClass thisCategory parentClass |	thisName := (aClass name , 'Test') asSymbol.	(thisName beginsWith: 'PR')		ifFalse: [ ^ self ].	thisClass := MACompatibility classNamed: thisName.	thisCategory := 'Pier-Tests-' , (aClass category copyAfterLast: $-).	parentClass := self = thisClass		ifTrue: [ self superclass ]		ifFalse: [ Smalltalk classNamed: (aClass superclass name , 'Test') asSymbol ].	thisClass := parentClass		subclass: thisName		instanceVariableNames: (thisClass isNil			ifFalse: [ thisClass instanceVariablesString ]			ifTrue: [ String new ])			classVariableNames: ''			poolDictionaries: ''			category: thisCategory.	thisClass		compile: 'actualClass	^ ' , aClass name		classified: #private.	thisClass class		compile: 'isAbstract	^ ' , aClass isAbstract asString		classified: #testing.	aClass subclassesDo: [ :each | self buildTestClassFor: each ]! !!PRObjectTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ true! !!PRObjectTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!shouldInheritSelectors	^ true! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PRObject! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!contextInstance	^ PRContext kernel: self kernelInstance! !!PRObjectTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!instance	self subclassResponsibility! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!kernelInstance	^ PRKernel new		name: 'test';		root: self rootInstance;		persistency: self persistencyInstance;		yourself! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!persistencyInstance	^ PRNullPersistency new! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!rootInstance	^ (PRPage named: 'root')		addChild: ((PRPage named: 'folder')			addChild: (PRPage named: 'child');			addChild: (self structureInstance);			yourself);		yourself! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!structureInstance	^ PRPage named: 'structure'! !!PRObjectTest methodsFor: 'testing-copying' stamp: 'lr 3/9/2006 11:31'!testCopyProperties	self assert: self instance properties = self instance copy properties.	self deny: self instance properties == self instance copy properties! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testProperties	self assert: self instance properties notNil.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo put: #bar.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsent: [ nil ].	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsentPut: [ #bar ].	self instance instVarNamed: 'properties' put: nil.	self instance hasProperty: #foo.	self instance instVarNamed: 'properties' put: nil! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAt	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self should: [ self instance propertyAt: #bar ] raise: Error! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtIfAbsent	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsent: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsent: [ 'baz' ]) = 'baz'! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtIfAbsentPut	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsentPut: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsentPut: [ 'baz' ]) = 'baz'.	self assert: (self instance propertyAt: #bar) = 'baz'! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtPut	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self instance propertyAt: #foo put: 'baz'.	self assert: (self instance propertyAt: #foo) = 'baz'! !!PRObjectTest methodsFor: 'testing-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesHas	self deny: (self instance hasProperty: #foo).	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance hasProperty: #foo).	self deny: (self instance hasProperty: #bar)! !!PRObjectTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!testSanity	"If this test case fails, there is something wrong with the setup of the test-case."	self		assert: self actualClass isAbstract not		description: 'Unable to test abstract class.'.	self		assert: self instance class = self actualClass		description: 'Invalid test instance.'! !!PRUtilitiesTests methodsFor: 'testing-macro-expander' stamp: 'lr 3/9/2006 11:31'!testMacroInitialized	| expander |	expander := PRMacroExpander new.	self assert: expander character = $%.	self assert: expander default notNil.	self assert: expander table isEmpty! !!PRUtilitiesTests methodsFor: 'testing-macro-expander' stamp: 'lr 3/9/2006 11:31'!testMacroValue	| expander |	expander := PRMacroExpander new.	expander table		at: $1 put: [ '!!1' ];		at: $2 put: [ '!!2' ].	self assert: (expander value: '') = ''.	self assert: (expander value: 'xyz') = 'xyz'.	self assert: (expander value: '%1') = '!!1'.	self assert: (expander value: '%2') = '!!2'.	self assert: (expander value: '%1xy') = '!!1xy'.	self assert: (expander value: 'x%1y') = 'x!!1y'.	self assert: (expander value: 'xy%1') = 'xy!!1'.	self assert: (expander value: '%2xy') = '!!2xy'.	self assert: (expander value: 'x%2y') = 'x!!2y'.	self assert: (expander value: 'xy%2') = 'xy!!2'.	self assert: (expander value: '%1%2') = '!!1!!2'.	self assert: (expander value: 'x%1%2') = 'x!!1!!2'.	self assert: (expander value: 'x%1y%2') = 'x!!1y!!2'.	self assert: (expander value: 'x%1y%2z') = 'x!!1y!!2z'.	self assert: (expander value: '%%') = '%'.	self assert: (expander value: '%3') = '%3'! !!PRUtilitiesTests methodsFor: 'testing-macro-expander' stamp: 'lr 3/9/2006 11:31'!testMacroValueValue	| expander |	expander := PRMacroExpander new.	expander table		at: $1 put: [ :char | '!!' , char asString ];		at: $2 put: [ :char | '!!' , char asString ].	self assert: (expander value: '') = ''.	self assert: (expander value: 'xyz') = 'xyz'.	self assert: (expander value: '%1') = '!!1'.	self assert: (expander value: '%2') = '!!2'.	self assert: (expander value: '%1xy') = '!!1xy'.	self assert: (expander value: 'x%1y') = 'x!!1y'.	self assert: (expander value: 'xy%1') = 'xy!!1'.	self assert: (expander value: '%2xy') = '!!2xy'.	self assert: (expander value: 'x%2y') = 'x!!2y'.	self assert: (expander value: 'xy%2') = 'xy!!2'.	self assert: (expander value: '%1%2') = '!!1!!2'.	self assert: (expander value: 'x%1%2') = 'x!!1!!2'.	self assert: (expander value: 'x%1y%2') = 'x!!1y!!2'.	self assert: (expander value: 'x%1y%2z') = 'x!!1y!!2z'.	self assert: (expander value: '%%') = '%'.	self assert: (expander value: '%3') = '%3'! !!PRUtilitiesTests methodsFor: 'testing-macro-expander' stamp: 'lr 3/9/2006 11:31'!testMacroValueValueValue	| expander |	expander := PRMacroExpander new.	expander table		at: $1 put: [ :char :arg | arg , char asString ];		at: $2 put: [ :char :arg | arg , char asString ].	self assert: (expander value: '') = ''.	self assert: (expander value: 'xyz') = 'xyz'.	self assert: (expander value: '%1' value: '!!') = '!!1'.	self assert: (expander value: '%2' value: '!!') = '!!2'.	self assert: (expander value: '%1xy' value: '!!') = '!!1xy'.	self assert: (expander value: 'x%1y' value: '!!') = 'x!!1y'.	self assert: (expander value: 'xy%1' value: '!!') = 'xy!!1'.	self assert: (expander value: '%2xy' value: '!!') = '!!2xy'.	self assert: (expander value: 'x%2y' value: '!!') = 'x!!2y'.	self assert: (expander value: 'xy%2' value: '!!') = 'xy!!2'.	self assert: (expander value: '%1%2' value: '!!') = '!!1!!2'.	self assert: (expander value: 'x%1%2' value: '!!') = 'x!!1!!2'.	self assert: (expander value: 'x%1y%2' value: '!!') = 'x!!1y!!2'.	self assert: (expander value: 'x%1y%2z' value: '!!') = 'x!!1y!!2z'! !!PRVisitorTests methodsFor: 'running' stamp: 'lr 3/9/2006 11:31'!setUp	visitor := PRVisitor new! !!PRVisitorTests methodsFor: 'testing-escaper' stamp: 'lr 3/9/2006 11:31'!testEnsureEscape	| tag |	tag := nil.	self assert: (visitor withEscaper: [		[ true ]			ensure: [ tag := 1 ] ]).	self assert: tag = 1.	self assert: (visitor withEscaper: [		[ visitor escape: true ]			ensure: [ tag := 2 ] ]).	self assert: tag = 2! !!PRVisitorTests methodsFor: 'testing-escaper' stamp: 'lr 3/9/2006 11:31'!testEscaper	self assert: (visitor withEscaper: [ true ]).	self deny: (visitor withEscaper: [ false ]).	self assert: (visitor withEscaper: [ visitor escape: true. false ]).	self deny: (visitor withEscaper: [ visitor escape: false. true ])! !!PRVisitorTests methodsFor: 'testing-escaper' stamp: 'lr 3/9/2006 11:31'!testHasEscaper	self deny: visitor hasEscaper.	self assert: (visitor withEscaper: [ visitor hasEscaper ])! !!PRPierFrame class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!canBeRoot	^ true! !!PRPierFrame class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:30'!exampleBasic	"Pier can be easily used as a component within any Seaside application, this is just an example of a dumb wiki. To see this example browse to /seaside/examplebrowser and select the receiver class."	^ self on: (PRContext kernel: (PRKernel new		name: 'Pier';		root: (PRPage new			title: 'Pier Example';			contents: 'Pier can be easily used as a component within any Seaside application (maybe you should adapt the style-sheets), this is just an example of a dumb and non-persistent wiki.';			yourself)))! !!PRPierFrame class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:30'!exampleDocs	"Create a (static) Pier instance from all the comments in the source code of pier, a sort of poor mans documentation. It might take a while to get all the classes traversed and to parse the source."	^ self on: (PRContext kernel: (PRKernel new		name: 'Pier Docs';		root: (self pageForClass: PRObject);		yourself))! !!PRPierFrame class methodsFor: 'class initialization' stamp: 'lr 3/9/2006 11:30'!initialize	| kernel |	kernel := nil.	(PRCompatibility confirm: 'Would you like to create a Seaside application for Pier?') ifTrue: [		(PRKernel instances isEmpty or: [ PRCompatibility confirm: 'Would you like to create a new Pier kernel?' ]) ifTrue: [			(PRCompatibility request: 'Please enter the name of your Pier kernel:' default: PRDistribution productName)				ifNotNilDo: [ :value | kernel := PRKernel named: value ] ].		(PRKernel instances notEmpty and: [ kernel isNil ]) ifTrue: [			kernel := PRCompatibility choose: 'Select the Pier kernel you would like to use:' from: PRKernel instances ].		kernel notNil ifTrue: [			(PRCompatibility request: 'Enter the entry point:' default: 'pier') ifNotNilDo: [ :path |				PRCompatibility inform: 'Your Pier-Application is running on: ' , (self registerAsApplication: path kernel: kernel) baseUrl asString ] ] ]! !!PRPierFrame class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRPierFrame class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!on: aContext	"This contructor creates a new SmallWiki frame that can be used within any Seaside application. It doesn't require a special session class, since all the required state is hold in the context of the wiki itself."	^ self new		context: aContext;		yourself! !!PRPierFrame class methodsFor: 'examples' stamp: 'lr 3/9/2006 11:30'!pageForClass: aClass	| page |	page := PRPage new		title: aClass name;		contents: (String streamContents: [ :stream |			stream nextPutAll: '!!Class definition'; cr.			aClass definition				linesDo: [ :each | stream nextPut: $=; nextPutAll: each; cr ].			aClass hasComment ifTrue: [				stream nextPutAll: '!!Class comment'; cr.				stream nextPutAll: aClass comment; cr ] ]);		yourself.	aClass subclassesDo: [ :each | page addChild: (self pageForClass: each) ].	^ page! !!PRPierFrame class methodsFor: 'registration' stamp: 'lr 8/24/2006 23:21'!registerAsApplication: aString kernel: aKernel	| application |	application := self registerAsApplication: aString.	application configuration addAncestor: PRPierConfiguration new.	application libraries add: PRPierLibrary.	Smalltalk 		at: #SULibrary		ifPresent: [ :class | application libraries add: class ].	^ application		preferenceAt: #mainClass put: PRPierMain;		preferenceAt: #kernel put: aKernel;		yourself! !!PRPierFrame methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!children	^ self context components! !!PRPierFrame methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!childrenDo: aStream	self withContextDo: [ super childrenDo: aStream ]! !!PRPierFrame methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!context	^ context! !!PRPierFrame methodsFor: 'accessing' stamp: 'lr 10/17/2006 21:27'!context: aContext	aContext command 		ancestor: context.	context := aContext.	self update! !!PRPierFrame methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!environment	^ self context structure environment! !!PRPierFrame methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!initialRequest: aRequest	| component |	super initialRequest: aRequest.	self withContextDo: [		PROutgoingReferences start: self environment do: [ :each |			(component := each target isKindOf: PRComponent)				ifTrue: [ self context componentAt: each target ].			component not and: [ each isEmbedded ] ] ]! !!PRPierFrame methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	html div		class: 'frame';		with: [			self context renderer				start: self environment				in: self on: html ]! !!PRPierFrame methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!renderWithContext: aContext	self withContextDo: [ super renderWithContext: aContext ]! !!PRPierFrame methodsFor: 'updating' stamp: 'lr 3/9/2006 11:30'!update	self visiblePresentersDo: [ :each | each onChangeContext: self context ]! !!PRPierFrame methodsFor: 'updating' stamp: 'lr 3/9/2006 11:30'!updateRoot: aHtmlRoot	super updateRoot: aHtmlRoot.	aHtmlRoot docType: '<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'.	aHtmlRoot htmlAttributes at: 'xmlns' put: 'http://www.w3.org/1999/xhtml'.	aHtmlRoot addHeadElement: ((WAHtmlElement named: 'meta')		attributeAt: 'name' put: 'generator';		attributeAt: 'content' put: PRDistribution versionString;		yourself)! !!PRPierFrame methodsFor: 'updating' stamp: 'lr 3/9/2006 11:30'!updateUrl: anUrl	super updateUrl: anUrl.	anUrl adaptToContext: self context! !!PRPierFrame methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!withContextDo: aBlock	^ PRCurrentContext use: self during: aBlock! !!PRDefaultView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRDefaultView class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'View'! !!PRDefaultView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!name	^ self context structure title! !!PRDefaultView methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	"This check is required to make it possible to display /Environemnt/Contents and avoid uncotrolled recursion. We don't remeber the recursion within an i-var, because this doesn't work together with continuations that might escape from this context. This implementation is using the exception mechanism and is ways faster than searching the stack manually."	PRRecursionBlocker		do: [ self context renderer continue: self context structure in: self on: html ]		else: [ html render: 'Unable to fully display recursive composition.' ]! !!PRChangesView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRChangesView class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Changes'! !!PRChangesView methodsFor: 'private' stamp: 'rjl 5/11/2006 19:56'!buildList	^ Array streamContents: [ :stream |		self context kernel persistency			reverseDo: [ :each |				each command isEdit					ifTrue: [ stream nextPut: each] ]			for: self context structure ]! !!PRChangesView methodsFor: 'private' stamp: 'rjl 5/11/2006 19:59'!buildReport	^ super buildReport		addColumn: (MACommandColumn new			addCommand: [ :value | self apply: value command ] text: 'restore';			yourself);		yourself! !!PRHistoryView methodsFor: 'actions' stamp: 'rjl 5/11/2006 19:52'!apply: aCommand	aCommand execute! !!PRHistoryView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildDescription	^ PRContext description! !!PRHistoryView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildList	self subclassResponsibility! !!PRHistoryView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildReport	^ (MAReport rows: self buildList description: self buildDescription)		sortEnabled: false;		batchSize: 20;		yourself! !!PRHistoryView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!children	^ Array with: self report! !!PRHistoryView methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!open: aCommand	self context: (self context command: aCommand)! !!PRHistoryView methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	html render: self report! !!PRHistoryView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!report	^ report ifNil: [ report := self buildReport ]! !!PRLogView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRLogView class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Log'! !!PRLogView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildList	^ Array streamContents: [ :stream |		self context kernel persistency			reverseDo: [ :each | stream nextPut: each ]			for: self context structure ]! !!PRDownloadView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRDownloadView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	^ (super isValidIn: aContext) and: [ aContext structure isKindOf: PRFile ]! !!PRDownloadView class methodsFor: 'converting' stamp: 'lr 3/9/2006 11:30'!label	^ 'Download'! !!PRDownloadView methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: aRequest	self context structure file in: [ :file |		aRequest			contentType: file mimetype;			attachmentWithFileName: file filename;			nextPutAll: file contents ]! !!PRRawView methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWithContext: aRenderingContext	| response |	self renderContentOn: (response := WAResponse new).	self session returnResponse: response! !!PRWikiView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRWikiView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	^ (super isValidIn: aContext) and: [ aContext structure hasDocument ]! !!PRWikiView class methodsFor: 'converting' stamp: 'lr 3/9/2006 11:30'!label	^ 'Wiki'! !!PRWikiView methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: aRequest	aRequest contentType: 'text/wiki'.	PRDocumentWriter		write: self context structure document		to: aRequest stream! !!PRReportView class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRReportView class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Report'! !!PRReportView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildDescription	self structures isEmpty		ifTrue: [ ^ MAContainer new ].	^ (self structures		inject: self structures first description		into: [ :container :structure | container intersection: structure description ])			select: [ :each | each isVisible ]! !!PRReportView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildReport	^ MAReport rows: self structures description: self description! !!PRReportView methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildStructures	^ self context structure enumerator		all;		contents! !!PRReportView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!children	^ Array with: self report! !!PRReportView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!description	^ description ifNil: [ description := self buildDescription ]! !!PRReportView methodsFor: 'rendering' stamp: 'lr 3/21/2006 19:09'!renderContentOn: html	html render: self report! !!PRReportView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!report	^ report ifNil: [ report := self buildReport ]! !!PRReportView methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!structures	^ structures ifNil: [ structures := self buildStructures ]! !!PRViewComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	"Verify that a view as a meaning for the context aContext. Override this message, to add new tests, but do not forget to call this super implementation."	^ aContext structure isValidView: self in: aContext! !!PRViewComponent class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!on: aContext	^ self new		setContext: aContext;		yourself! !!PRViewComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!context	^ context! !!PRViewComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!name	^ self class label! !!PRViewComponent methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	html strong: self context! !!PRViewComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:30'!setContext: aContext	context := aContext! !!PRBoxWidget class methodsFor: 'accessing-defaults' stamp: 'lr 4/10/2006 11:18'!defaultCssClass	^ nil! !!PRBoxWidget class methodsFor: 'accessing-defaults' stamp: 'lr 4/10/2006 11:17'!defaultCssName	^ nil! !!PRBoxWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultTitle	^ self label! !!PRBoxWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionCssClass	^ MAStringDescription selector: #cssClass label: 'CSS Class' priority: 120 default: self defaultCssClass! !!PRBoxWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionCssName	^ MAStringDescription selector: #cssName label: 'CSS Name' priority: 110 default: self defaultCssName! !!PRBoxWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionTitle	^ MAStringDescription selector: #title label: 'Title' priority: 100 default: self defaultTitle! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!cssClass	^ self propertyAt: #cssClass ifAbsent: [ self class defaultCssClass ]! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!cssClass: aString	self propertyAt: #cssClass put: aString! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!cssName	^ self propertyAt: #cssName ifAbsent: [ self class defaultCssName ]! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!cssName: aString	self propertyAt: #cssName put: aString! !!PRBoxWidget methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isVisible	"Answer true if the receiver is visible. Some subclasses might want to override this message to hide the reciever in certain cases."	^ true! !!PRBoxWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	self isVisible		ifFalse: [ ^ self ].	html div		id: self cssName;		class: self cssClass;		with: [			self renderWidgetTitleOn: html.			super renderContentOn: html ]! !!PRBoxWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetTitleOn: html	self title isEmptyOrNil		ifFalse: [ html heading: (self expand: self title) ]! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!title	^ self propertyAt: #title ifAbsent: [ self class defaultTitle ]! !!PRBoxWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!title: aString	self propertyAt: #title put: aString! !!PRContentsWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'contents'! !!PRContentsWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultTitle	^ '%c'! !!PRContentsWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRContentsWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Contents'! !!PRContentsWidget methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!buildComponent: aContext	^ aContext command asComponent		onAnswer: [ :value | self onAnswerCommand: value ];		yourself! !!PRContentsWidget methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!children	^ Array with: self component! !!PRContentsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!component	^ component ifNil: [ component := self buildComponent: self context ]! !!PRContentsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!component: aComponent	component := aComponent! !!PRContentsWidget methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:30'!initialize	super initialize.	self session registerObjectForBacktracking: self! !!PRContentsWidget methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onAnswerCommand: aCommand	self context: (aCommand notNil		ifTrue: [ aCommand execute; answer ]		ifFalse: [ self context structure: self context structure ])! !!PRContentsWidget methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onChangeContext: aContext	super onChangeContext: aContext.	aContext command isQuick		ifTrue: [ self onAnswerCommand: aContext command ]		ifFalse: [ self component: (self buildComponent: aContext) ]! !!PRContentsWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	html render: self component! !!PRContentsWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!updateRoot: aHtmlRoot	super updateRoot: aHtmlRoot.	aHtmlRoot title: self context structure title! !!PRCommandsWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCommandClasses	^ (Array withAll: PRCommand withAllConcreteClasses)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!PRCommandsWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box commands'! !!PRCommandsWidget class methodsFor: 'accessing-description' stamp: 'rjl 4/24/2006 21:00'!descriptionCommandClasses	^ (MAMultipleOptionDescription selector: #commandClasses label: 'Command Classes' priority: 200)		options: (MADynamicObject on: [ self defaultCommandClasses ]);		componentClass: MAListCompositonComponent;		reference: MAClassDescription new;		beOrdered; beDistinct; beSorted;		yourself! !!PRCommandsWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRCommandsWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Commands'! !!PRCommandsWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!commandClasses	^ commandClasses ifNil: [ commandClasses := self class defaultCommandClasses ]! !!PRCommandsWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!commandClasses: aCollection	commandClasses := aCollection! !!PRCommandsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!items	| command |	^ Array streamContents: [ :stream |		self context commands in: [ :commands |			self commandClasses do: [ :class |				command := commands					detect: [ :each |						each = class							or: [ each inheritsFrom: class ] ]					ifNone: [ nil ].				command isNil					ifFalse: [ stream nextPut: command ] ] ] ]! !!PRCommandsWidget methodsFor: 'rendering' stamp: 'rjl 4/24/2006 07:07'!renderItem: aClass on: html	html anchor		accessKey: aClass accessKey;		goto: (self context			structure: self context structure			command: aClass new);		text: aClass shortLabel! !!PRCommandsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!selected	^ self context command class! !!PRHeaderWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCommandClasses	^ OrderedCollection		with: PRViewCommand		with: PREditCommand! !!PRHeaderWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'header'! !!PRHeaderWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultTitle	^ '%k'! !!PRHeaderWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Header'! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderLogoOn: html	html tableData class: 'logo'! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderSpacerOn: html	html tableData class: 'spacer'! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderTabsOn: html	self renderItems: self items reversed on: html! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderTitleOn: html	html tableData class: 'start'.	html tableData class: 'title'; with: (self expand: self title).	html tableData class: 'tabs'; with: [ self renderTabsOn: html ].	html tableData class: 'end'! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	html table		class: 'header';		with: [			self renderLogoOn: html.			self renderSpacerOn: html.			self renderTitleOn: html ]! !!PRHeaderWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetTitleOn: html! !!PRListWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!items	self subclassResponsibility! !!PRListWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderItem: anObject on: html	html render: anObject! !!PRListWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderItems: aCollection on: html	html unorderedList with: [		aCollection do: [ :each |			html listItem				class: (self selected = each ifTrue: [ 'active' ]);				with: [ self renderItem: each on: html ] ] ]! !!PRListWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	self renderItems: self items on: html! !!PRListWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!selected	self subclassResponsibility! !!PRChildrenWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box children'! !!PRChildrenWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRChildrenWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Children'! !!PRChildrenWidget methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isVisible	^ self context structure hasChildren! !!PRChildrenWidget methodsFor: 'accessing' stamp: 'lr 4/10/2006 15:14'!unfilteredItems	^ (self context enumerator: self context structure) contents! !!PRNavigationWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box navigation'! !!PRNavigationWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRNavigationWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Navigation'! !!PRNavigationWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderParents: aCollection on: html	html unorderedList: [		html listItem: [			self renderItem: aCollection first on: html.			(aCollection size = 1 or: [ aCollection size = 2 and: [ (aCollection last enumerator contents reject: [ :each | self isFiltered: each ]) isEmpty ] ])				ifTrue: [ self renderItems: aCollection first enumerator contents on: html ]				ifFalse: [ self renderParents: aCollection allButFirst on: html ] ] ]! !!PRNavigationWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	self renderParents: self context structure parents on: html! !!PRPathWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box path'! !!PRPathWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRPathWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Path'! !!PRPathWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!unfilteredItems	^ self context structure parents! !!PRReferencesWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box references'! !!PRReferencesWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRReferencesWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'References'! !!PRReferencesWidget methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isVisible	^ self items notEmpty! !!PRReferencesWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!unfilteredItems	^ (Array streamContents: [ :stream |		PRIncomingReferences			from: self context root			to: self context structure			do: [ :each | stream nextPut: each owner ] ])				asSet! !!PRSearchWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCaseSensitive	^ false! !!PRSearchWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box search'! !!PRSearchWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/17/2006 16:13'!defaultMaxItems	^ 10! !!PRSearchWidget class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:30'!descriptionCaseSensitive	^ MABooleanDescription selector: #caseSensitive label: 'Case Sensitive' priority: 300 default: self defaultCaseSensitive! !!PRSearchWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRSearchWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Search'! !!PRSearchWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!caseSensitive	^ self propertyAt: #caseSensitive ifAbsent: [ self class defaultCaseSensitive ]! !!PRSearchWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!caseSensitive: aBoolean	self propertyAt: #caseSensitive put: aBoolean! !!PRSearchWidget methodsFor: 'actions' stamp: 'lr 3/21/2006 18:43'!go	self items in: [ :items |		items notEmpty ifTrue: [			self context: (self context structure: items first) ] ]! !!PRSearchWidget methodsFor: 'rendering' stamp: 'lr 8/24/2006 23:29'!renderInputOn: html	html form: [		html textInput			beSearchInput;			id: (self ajaxId: #search);			value: self searchText;			callback: [ :value | self searchText: value ] ]! !!PRSearchWidget methodsFor: 'rendering' stamp: 'lr 8/24/2006 23:49'!renderWidgetOn: html	self renderInputOn: html.	self hasScriptaculous		ifTrue: [			html div script: (html autocompleter				element: (self ajaxId: #search);				onSelected: (html evaluator					triggerFormElement: (self ajaxId: #search);					callback: [ :s | s callback: [ self go ] ]);				callback: [ :r | self renderItems: self items on: r ]) ]		ifFalse: [ super renderWidgetOn: html ]! !!PRSearchWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!searchText	^ searchText ifNil: [ searchText := String new ]! !!PRSearchWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!searchText: aString	searchText := aString! !!PRSearchWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!unfilteredItems	^ PRFullTextSearch from: self context root find: self searchText caseSensitive: self caseSensitive! !!PRStructuresWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultFilter	^ Array new! !!PRStructuresWidget class methodsFor: 'accessing-defaults' stamp: 'lr 5/3/2006 17:28'!defaultLabel	^ self defaultLabels first! !!PRStructuresWidget class methodsFor: 'accessing-defaults' stamp: 'lr 5/3/2006 17:28'!defaultLabels	^ #( title name )! !!PRStructuresWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultMaxItems	^ 0! !!PRStructuresWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultShowIcons	^ true! !!PRStructuresWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionFilter	^ (MAMultipleOptionDescription selector: #filter label: 'Filter' priority: 210 default: self defaultFilter)		options: (MADynamicObject on: [ PRStructure withAllConcreteClasses ]);		componentClass: MACheckboxGroupComponent;		reference: MAClassDescription new;		beSorted;		yourself! !!PRStructuresWidget class methodsFor: 'accessing-description' stamp: 'lr 5/3/2006 17:29'!descriptionLabel	^ (MASingleOptionDescription selector: #label label: 'Label' priority: 200 default: self defaultLabel)		options: self defaultLabels;		beRequired; beSorted;		yourself! !!PRStructuresWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionMaxItems	^ (MANumberDescription selector: #maxItems label: 'Max Items' priority: 220 default: self defaultMaxItems)		beRequired;		beInteger;		min: 0;		yourself! !!PRStructuresWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionShowIcons	^ MABooleanDescription selector: #showIcons label: 'Show Icons' priority: 210 default: self defaultShowIcons! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!filter	^ self propertyAt: #filter ifAbsent: [ self class defaultFilter ]! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!filter: aCollection	self propertyAt: #filter put: aCollection! !!PRStructuresWidget methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isFiltered: aStructure	(self context structure: aStructure) isValid ifFalse: [ ^ true ].	^ self filter anySatisfy: [ :each | aStructure isKindOf: each ]! !!PRStructuresWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!items	| items |	items := self unfilteredItems asArray		reject: [ :each | self isFiltered: each ].	^ (self maxItems isZero not and: [ self maxItems < items size ])		ifTrue: [ items copyFrom: 1 to: self maxItems ]		ifFalse: [ items ]! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 5/3/2006 17:29'!label	^ self propertyAt: #label ifAbsent: [ self class defaultLabel ]! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 5/3/2006 17:30'!label: aSymbol	self propertyAt: #label put: aSymbol! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!maxItems	^ self propertyAt: #maxItems ifAbsent: [ self class defaultMaxItems ]! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!maxItems: aNumber	self propertyAt: #maxItems put: aNumber! !!PRStructuresWidget methodsFor: 'rendering' stamp: 'lr 5/3/2006 17:30'!renderItem: aStructure on: html	self showIcons ifTrue: [		html image			url: (html context				urlForDocument: aStructure icon				mimeType: 'image/png');			altText: aStructure class label ].	html anchor		class: (self selected = aStructure			ifTrue: [ 'active' ]);		goto: (self context structure: aStructure);		text: (aStructure perform: self label)! !!PRStructuresWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!selected	^ self context structure! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!showIcons	^ self propertyAt: #showIcons ifAbsent: [ self class defaultShowIcons ]! !!PRStructuresWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!showIcons: aBoolean	self propertyAt: #showIcons put: aBoolean! !!PRStructuresWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!unfilteredItems	^ self subclassResponsibility! !!PRTreeWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultAutoCollapse	^ true! !!PRTreeWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultAutoExpand	^ true! !!PRTreeWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box tree'! !!PRTreeWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionAutoCollapse	^ MABooleanDescription selector: #autoCollapse label: 'Auto Collapse' priority: 310 default: self defaultAutoCollapse! !!PRTreeWidget class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionAutoExpand	^ MABooleanDescription selector: #autoExpand label: 'Auto Expand' priority: 300 default: self defaultAutoExpand! !!PRTreeWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTreeWidget class methodsFor: 'converting' stamp: 'lr 3/9/2006 11:30'!label	^ 'Tree'! !!PRTreeWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!autoCollapse	^ self propertyAt: #autoCollapse ifAbsent: [ self class defaultAutoCollapse ]! !!PRTreeWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!autoCollapse: aBoolean	self propertyAt: #autoCollapse put: aBoolean! !!PRTreeWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!autoExpand	^ self propertyAt: #autoExpand ifAbsent: [ self class defaultAutoExpand ]! !!PRTreeWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!autoExpand: aBoolean	self propertyAt: #autoExpand put: aBoolean! !!PRTreeWidget methodsFor: 'private' stamp: 'lr 4/10/2006 15:15'!childrenOf: aStructure	^ (self context enumerator: aStructure)		contents reject: [ :each | self isFiltered: each ]! !!PRTreeWidget methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!collapseStructure: aStructure	expanded remove: aStructure ifAbsent: [ "should never happen" ]! !!PRTreeWidget methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!expandStructure: aStructure	expanded add: aStructure! !!PRTreeWidget methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:30'!initialize	super initialize.	self session registerObjectForBacktracking: (expanded := Set new)! !!PRTreeWidget methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isExpanded: aNode	^ expanded includes: aNode! !!PRTreeWidget methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onChangeContext: aContext	super onChangeContext: aContext.	self autoCollapse		ifTrue: [ expanded removeAll: expanded copy ].	self autoExpand		ifTrue: [ expanded addAll: aContext structure parents ]! !!PRTreeWidget methodsFor: 'rendering-items' stamp: 'lr 3/9/2006 11:30'!renderStructure: aStructure on: html	html listItem: [		self renderStructureButton: aStructure on: html.		self renderStructureLabel: aStructure on: html.		self renderStructureChildren: aStructure on: html ]! !!PRTreeWidget methodsFor: 'rendering-items' stamp: 'lr 3/9/2006 11:30'!renderStructureButton: aStructure on: html	| isExpanded |	html span		class: 'button';		with: [			(self childrenOf: aStructure) notEmpty ifTrue: [				isExpanded := self isExpanded: aStructure.				html anchor					callback: [						isExpanded							ifTrue: [ self collapseStructure: aStructure ]							ifFalse: [ self expandStructure: aStructure ] ];					with: (isExpanded						ifTrue: [ '-' ]						ifFalse: [ '+' ]) ] ]! !!PRTreeWidget methodsFor: 'rendering-items' stamp: 'lr 3/9/2006 11:30'!renderStructureChildren: aStructure on: html	| children |	(self isExpanded: aStructure)		ifFalse: [ ^ self ].	children := self childrenOf: aStructure.	children isEmpty ifTrue: [ ^ self ].	html unorderedList: [		children do: [ :each |			self renderStructure: each on: html ] ]! !!PRTreeWidget methodsFor: 'rendering-items' stamp: 'lr 3/9/2006 11:30'!renderStructureLabel: aStructure on: html	self renderItem: aStructure on: html! !!PRTreeWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	html unorderedList: [ self renderStructure: self context root on: html ]! !!PRTreeWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!unfilteredItems	self shouldNotImplement! !!PRViewsWidget class methodsFor: 'accessing-default' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box views'! !!PRViewsWidget class methodsFor: 'accessing-default' stamp: 'lr 3/9/2006 11:30'!defaultViewClasses	^ (Array withAll: PRViewComponent withAllConcreteClasses)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!PRViewsWidget class methodsFor: 'accessing-description' stamp: 'lr 5/3/2006 17:03'!descriptionCommandClasses	^ (MAMultipleOptionDescription selector: #viewClasses label: 'View Classes' priority: 200)		options: (MADynamicObject on: [ self defaultViewClasses ]);		componentClass: MAListCompositonComponent;		reference: MAClassDescription new;		beOrdered; beDistinct; beSorted;		yourself! !!PRViewsWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRViewsWidget class methodsFor: 'converting' stamp: 'lr 3/9/2006 11:30'!label	^ 'Views'! !!PRViewsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!items	| view |	^ Array streamContents: [ :stream |		self context views in: [ :views |			self viewClasses do: [ :class |				view := views					detect: [ :each | each = class ]					ifNone: [ nil ].				view isNil					ifFalse: [ stream nextPut: view ] ] ] ]! !!PRViewsWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderItem: aClass on: html	html anchor		goto: (self context			command: (PRViewCommand new				viewComponentClass: aClass;				yourself));		with: aClass label! !!PRViewsWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!selected	^ self context command isView		ifTrue: [ self context command viewComponent class ]! !!PRViewsWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!viewClasses	^ viewClasses ifNil: [ viewClasses := self class defaultViewClasses ]! !!PRViewsWidget methodsFor: 'accessing-settings' stamp: 'lr 3/9/2006 11:30'!viewClasses: aCollection	viewClasses := aCollection! !!PRTocWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultCssClass	^ 'box toc'! !!PRTocWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTocWidget class methodsFor: 'converting' stamp: 'lr 3/9/2006 11:30'!label	^ 'Table of Contents'! !!PRTocWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	PRTocRenderer new		start: self context structure document		in: self on: html! !!PRWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!context	^ context ifNil: [ context := super context ]! !!PRWidget methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!expand: aString	^ PRMacroExpander default value: aString value: self context! !!PRWidget methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onChangeContext: aContext	super onChangeContext: aContext.	context := aContext! !!PRWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!properties	properties isNil		ifTrue: [ properties := Dictionary new ].	^ properties! !!PRWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!propertyAt: aKey	^ self properties at: aKey! !!PRWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!propertyAt: aKey ifAbsent: aBlock	^ self properties at: aKey ifAbsent: aBlock! !!PRWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!propertyAt: aKey ifAbsentPut: aBlock	^ self properties at: aKey ifAbsentPut: aBlock! !!PRWidget methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:30'!propertyAt: aKey put: aValue	^ self properties at: aKey put: aValue! !!PRWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderContentOn: html	self renderWidgetOn: html! !!PRWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	self subclassResponsibility! !!PRXHtmlWidget class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:30'!defaultText	^ '<h1>%k</h1><h2>%c</h2>'! !!PRXHtmlWidget class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:30'!descriptionCommandClasses	^ MAMemoDescription selector: #text label: 'Text' priority: 100 default: self defaultText! !!PRXHtmlWidget class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRXHtmlWidget class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'XHtml'! !!PRXHtmlWidget methodsFor: 'rendering' stamp: 'lr 3/9/2006 11:30'!renderWidgetOn: html	html html: (self expand: self text)! !!PRXHtmlWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!text	^ text ifNil: [ text := self class defaultText ]! !!PRXHtmlWidget methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!text: aString	text := aString! !!PRDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!package	"The SqueakMap package name."	^ 'Pier'! !!PRDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!packages	^ #( ( 'Pier-Model' )		 ( 'Pier-Tests' 'Smalltalk includesKey: #TestCase' )		 ( 'Pier-Seaside' 'Smalltalk includesKey: #WAComponent' )		 ( 'Pier-OmniBrowser' 'Smalltalk includesKey: #OBBrowser' ) )! !!PRDistribution class methodsFor: 'execution' stamp: 'lr 3/9/2006 11:30'!postload	self registerRepository: 'http://mc.lukas-renggli.ch/pier'! !!PRDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!preamble	^ '(SMSqueakMap default packageWithName: ''Magritte'')	lastRelease install.' , String cr! !!PRDistribution class methodsFor: 'accessing' stamp: 'lr 6/30/2006 00:40'!version	"The first item is the product name, which should only contain lowercase letters. Then the version numbers are following, that are made up of three numbers. An optimal suffix alpha, beta, pre or rc follows. External packages or extensions might want to call this method to check the version required to run."	^ #( pier 1 0 5 alpha )! !!Object methodsFor: '*pier-model' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	self subclassResponsibility! !!Object methodsFor: '*pier-model' stamp: 'lr 3/9/2006 11:29'!acceptDecorated: aVisitor	self accept: aVisitor! !!PRMacroExpander class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!default	^ Default! !!PRMacroExpander class methodsFor: 'class initialization' stamp: 'lr 3/9/2006 11:30'!initialize	Default := self on: (Dictionary new		at: $c put: [ :char :context | context command name ];		" current command "		at: $r put: [ :char :context | context kernel root title ];		" current root structure "		at: $t put: [ :char :context | context structure title ];			" current structure "		at: $k put: [ :char :context | context kernel name ];			" current kernel name "		yourself)! !!PRMacroExpander class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!on: aDictionary	^ self new		table: aDictionary;		yourself! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!character	^ character! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!character: aCharacter	character := aCharacter! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!default	^ default! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!default: aBlock	default := aBlock! !!PRMacroExpander methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultCharacter	^ $%! !!PRMacroExpander methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultDefault	^ [ :char |		self character = char			ifTrue: [ String with: self character ]			ifFalse: [ String with: self character with: char ] ]! !!PRMacroExpander methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultTable	^ Dictionary new! !!PRMacroExpander methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!expand: aReadStream using: anArray	^ String streamContents: [ :writeStream |		[ aReadStream atEnd ] whileFalse: [			writeStream nextPutAll: (aReadStream upTo: self character).			aReadStream atEnd ifFalse: [				self					expand: aReadStream					using: anArray					to: writeStream ] ] ]! !!PRMacroExpander methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!expand: aReadStream using: anArray to: aWriteStream	| char block |	block := self table		at: (char := aReadStream next)		ifAbsent: [ self default ].	^ aWriteStream nextPutAll: (block		valueWithPossibleArgs: (anArray			copyWithFirst: char))! !!PRMacroExpander methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	self table: self defaultTable.	self character: self defaultCharacter.	self default: self defaultDefault! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!table	^ table! !!PRMacroExpander methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!table: aDictionary	table := aDictionary! !!PRMacroExpander methodsFor: 'evaluation' stamp: 'lr 3/9/2006 11:29'!value: aString	^ self value: aString withArguments: Array new! !!PRMacroExpander methodsFor: 'evaluation' stamp: 'lr 3/9/2006 11:29'!value: aString value: anObject	^ self value: aString withArguments: (Array with: anObject)! !!PRMacroExpander methodsFor: 'evaluation' stamp: 'lr 3/9/2006 11:29'!value: aString withArguments: anArray	^ self expand: aString readStream using: anArray! !!PRObject commentStamp: 'lr 5/28/2006 17:00' prior: 0!I am the root of objects within Pier. I hold a dictionary of properties, so that users can easily annotate me with new values. I am visitable.!!PRCommand commentStamp: 'lr 6/2/2006 11:42' prior: 0!I am an abstract superclass of the command pattern in Pier. All modifications to the model have to be done through subclasses of myself, else they do not get properly logged with the persistency mechanism. I hold the context in which the receiver is executed in the instance variable context. To modify the resulting context, create a copy of the current context and store it in the instance variable answer.The following event-handlers are called when executing an action in the given order. Do override these messages to customize the command, never override the other internal methods:- Override the message <code>#doValidate</code> to check the valid setup of the command and to raise exceptions in case any precondition isn't met. Speak here or forever have your peace!! Don't change the model in there.- Override the message <code>#doExecute</code> to execute the actual command. Do not raise exceptions in there, catch all the problems in <code>#doValidate</code>.- Override the message <code>#doPersistency</code> to save the command that has been just executed with the current persistency strategy. Most commands don't need to override this message and just stick with the default behavior.- Override the message <code>#doAnswer</code> to create the answer context. Most commands don't need to override this message and just stick with the default behavior.Do not play with funny jumpy things, such as resumable exceptions or continuations, inside the code of the command hierarchy or you will very likely run into severe problems.!!PRAddCommand commentStamp: '<historical>' prior: 0!I'm a command used to add new structures to your structures. My code is very interesting if you want to understand how Pier is designed.Type is the class (subclass of PRStructure) for which a new instance will be created.!!PRAddCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $a! !!PRAddCommand class methodsFor: 'accessing-description' stamp: 'lr 3/11/2006 17:40'!descriptionName	^ (MAStringDescription selector: #name label: 'Name' priority: 100)		beRequired;		yourself! !!PRAddCommand class methodsFor: 'accessing-description' stamp: 'lr 5/5/2006 19:07'!descriptionType	^ (MASingleOptionDescription selector: #type label: 'Type' priority: 110 default: PRPage)		options: (MADynamicObject on: [ self structureClasses ]);		reference: MAClassDescription new;		beRequired;		beSorted;		yourself! !!PRAddCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRAddCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Add'! !!PRAddCommand class methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!structureClasses	^ PRCurrentContext value in: [ :context |		PRStructure withAllConcreteClasses select: [ :each |			(context structure class canBeParentOf: each)				and: [ each canBeChildOf: context structure class ] ] ]! !!PRAddCommand methodsFor: 'private' stamp: 'lr 9/6/2006 13:29'!child	"Create a new structure of the selected species, a subclass of PRStructure. Set the title if necessary, else it will be generated automatically."	| child |	child := self type named: self name.	(self link notNil and: [ self link hasAlias ])		ifTrue: [ child title: self link alias ].	^ child! !!PRAddCommand methodsFor: 'events' stamp: 'lr 9/25/2006 08:07'!doExecute	"Create a new structure of requested type and add it to the children list of the current structure. If possible the following context will be set to an editor or a view onto the new structure."	| structure |	super doExecute.	self structure 		addChild: (structure := self child).	self answer: (self context		structure: structure		command: (structure editCommandClass notNil			ifTrue: [ structure editCommandClass ]			ifFalse: [ structure viewCommandClass ])				new)! !!PRAddCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doValidate	"Verify that the new structure can be added before launching #doExecute. Basically, the title must be unique."	super doValidate.	self validateChild: self child in: self structure! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 9/6/2006 13:14'!link	^ link! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 9/6/2006 13:14'!link: aLink	link := aLink! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name	^ name ifNil: [ name := self uniqueName: 'untitled' in: self structure ]! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name: aString	name := aString! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!type	^ type ifNil: [ type := PRPage ]! !!PRAddCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!type: aClass	type := aClass! !!PRChangeEnvironment class methodsFor: 'accessing-environments' stamp: 'lr 6/10/2006 10:16'!both	^ (PRPage named: 'environment')		addChild: ((PRComponent named: 'header')			componentClass: PRHeaderWidget;			yourself);		addChild: ((PRComponent named: 'views')			componentClass: PRViewsWidget;			yourself);		addChild: ((PRComponent named: 'commands')			componentClass: PRCommandsWidget;			yourself);		addChild: ((PRComponent named: 'tree')			componentClass: PRTreeWidget;			yourself);		addChild: ((PRComponent named: 'toc')			componentClass: PRTocWidget;			yourself);		addChild: ((PRComponent named: 'references')			componentClass: PRReferencesWidget;			yourself);		addChild: ((PRComponent named: 'search')			componentClass: PRSearchWidget;			yourself);		addChild: ((PRComponent named: 'main')			componentClass: PRContentsWidget;			yourself);		contents: '+header+<table class="body"><tr><td class="boxes">+views+<br />+commands+<br />+tree+</td><td class="spacer"></td><td class="main">+main+</td><td class="spacer"></td><td class="boxes">+toc+<br />+references+<br />+search+</tr></table>';		yourself! !!PRChangeEnvironment class methodsFor: 'accessing-descriptions' stamp: 'lr 8/14/2006 10:11'!descriptionEnvironment	^ (MASingleOptionDescription selector: #environment label: 'Template' priority: 100)		options: (MADynamicObject on: [ self environments ]);		undefined: '(inherit)';		yourself! !!PRChangeEnvironment class methodsFor: 'accessing' stamp: 'lr 8/14/2006 10:12'!environments	^ Array streamContents: [ :stream |		self class organization categories do: [ :each |			(each endsWith: #environments) ifTrue: [ 				stream nextPutAll: (self class organization					listAtCategoryNamed: each) ] ] ]! !!PRChangeEnvironment class methodsFor: 'testing' stamp: 'lr 6/10/2006 09:57'!isAbstract	^ false! !!PRChangeEnvironment class methodsFor: 'accessing' stamp: 'lr 6/10/2006 09:57'!label	^ 'Environment'! !!PRChangeEnvironment class methodsFor: 'accessing-environments' stamp: 'lr 6/10/2006 10:12'!left	^ (PRPage named: 'environment')		addChild: ((PRComponent named: 'header')			componentClass: PRHeaderWidget;			yourself);		addChild: ((PRComponent named: 'views')			componentClass: PRViewsWidget;			yourself);		addChild: ((PRComponent named: 'commands')			componentClass: PRCommandsWidget;			yourself);		addChild: ((PRComponent named: 'tree')			componentClass: PRTreeWidget;			yourself);		addChild: ((PRComponent named: 'main')			componentClass: PRContentsWidget;			yourself);		contents: '+header+<table class="body"><tr><td class="boxes">+views+<br />+commands+<br />+tree+</td><td class="spacer"></td><td class="main">+main+</td></tr></table>';		yourself! !!PRChangeEnvironment class methodsFor: 'accessing-environments' stamp: 'lr 6/10/2006 10:13'!right	^ (PRPage named: 'environment')		addChild: ((PRComponent named: 'header')			componentClass: PRHeaderWidget;			yourself);		addChild: ((PRComponent named: 'views')			componentClass: PRViewsWidget;			yourself);		addChild: ((PRComponent named: 'commands')			componentClass: PRCommandsWidget;			yourself);		addChild: ((PRComponent named: 'tree')			componentClass: PRTreeWidget;			yourself);		addChild: ((PRComponent named: 'main')			componentClass: PRContentsWidget;			yourself);		contents: '+header+<table class="body"><tr><td class="main">+main+</td><td class="spacer"></td><td class="boxes">+views+<br />+commands+<br />+tree+</td></tr></table>';		yourself! !!PRChangeEnvironment methodsFor: 'events' stamp: 'lr 9/25/2006 08:09'!doExecute	self structure childrenDecoration		at: self structure environmentSelector		ifPresent: [ :structure | 			self structure childrenDecoration				remove: structure ].	self environment ifNil: [ ^ self ].	self structure addChild: ((self class perform: self environment)		name: self structure environmentSelector;		addDecoration: PRHider new;		yourself)! !!PRChangeEnvironment methodsFor: 'accessing' stamp: 'lr 6/10/2006 09:55'!environment	^ environment! !!PRChangeEnvironment methodsFor: 'accessing' stamp: 'lr 6/10/2006 10:01'!environment: aSymbol	environment := aSymbol! !!PRCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:57'!accessKey	^ nil! !!PRCommand class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!context: aContext	(self isValidIn: aContext)		ifFalse: [ self error: self name , ' is not useable in the given context.' ].	^ self new		setContext: aContext;		yourself! !!PRCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	"Verify that a command as a meaning for the context aContext. Override this command to add new constraints that are static to the command."	^ aContext structure isValidCommand: self in: aContext! !!PRCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!shortLabel	^ self label! !!PRCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!structureClass	^ PRStructure! !!PRCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 10/17/2006 21:28'!ancestor: aContext	"Whenever a new context is activate the previous one is passed in here, maybe some commands want to restore the old one afterwards."! !!PRCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!answer	"Return a new context that should be activated after executing this action."	^ answer! !!PRCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!answer: aContext	"Set the resulting context of this command."	answer := aContext! !!PRCommand methodsFor: '*pier-seaside-converting' stamp: 'lr 3/9/2006 11:30'!asComponent	^ super asComponent		addValidatedForm;		yourself! !!PRCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!context	"Return the current context of the receiver."	^ context! !!PRCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!context: aContext	"Set the current context of the receiver."	context := aContext! !!PRCommand methodsFor: 'events' stamp: 'lr 5/27/2006 17:25'!doAnswer	"Override this message to create the answer context. Most commands don't need to override this message and just stick with the default behavior."	self answer isNil		ifTrue: [ self answer: (self context structure: self structure) ]! !!PRCommand methodsFor: 'events' stamp: 'lr 5/27/2006 17:25'!doExecute	"Override this message to execute the actual command. Do not raise exceptions in there, catch all the problems in <code>#doValidate</code>."! !!PRCommand methodsFor: 'events' stamp: 'lr 5/27/2006 17:25'!doPersistency	"Override this message to save the command-context that has been just executed with the current persistency strategy. Most commands don't need to override this message and just stick with the default behavior."	self context setTimestamp: TimeStamp now.	self kernel persistency log: self context! !!PRCommand methodsFor: 'events' stamp: 'lr 9/11/2006 10:54'!doValidate	"Override this message to check the valid setup of the command and to raise exceptions in case any precondition isn't met. Speak here or forever have your peace!! Don't change the model in there."	self structure validateCommand: self! !!PRCommand methodsFor: 'actions' stamp: 'lr 5/28/2006 18:18'!execute	"Execute the command of the receiver. To implement your action in the code of one of my subclasses. Never override this message, but instead have a look at the different template methods (<code>#doValidate</code>, <code>#doExecute</code>, <code>#doPersistency</code>, <code>#doAnswer</code>) available in the events protocol."	self isView		ifTrue: [ self shouldNotImplement ].	self kernel critical: [		self doValidate; doExecute.		self isLogged			ifTrue: [ self doPersistency ] ].	self doAnswer! !!PRCommand methodsFor: '*pier-seaside-testing' stamp: 'lr 4/19/2006 07:32'!isConfirmed	^ false! !!PRCommand methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isEdit	^ false! !!PRCommand methodsFor: 'testing' stamp: 'lr 5/27/2006 17:26'!isLogged	"Most commands are logged. This means they do modify the model and are therefore preserved in the history. However there are some that just display something or change the state of the current context and neither change the model nor need to be logged."	^ true! !!PRCommand methodsFor: 'testing' stamp: 'lr 5/27/2006 17:26'!isQuick	"Quick commands do not have a configuration interface (probably not even Magritte descriptions) and therefore should not be presented to the user but simply executed."	^ false! !!PRCommand methodsFor: 'testing' stamp: 'lr 5/27/2006 17:27'!isView	"Most commands are not a view. This means they override <code>#doExecute</code> to do something meaningful on the context or the model."	^ false! !!PRCommand methodsFor: 'accessing-delegated' stamp: 'lr 5/28/2006 21:10'!kernel	"Answer the kernel the receiver is working on."	^ self context kernel! !!PRCommand methodsFor: 'accessing-delegated' stamp: 'lr 3/9/2006 11:29'!name	^ self class label! !!PRCommand methodsFor: 'accessing-delegated' stamp: 'lr 3/9/2006 11:29'!root	^ self context kernel root! !!PRCommand methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setContext: aContext	context := aContext! !!PRCommand methodsFor: 'accessing-delegated' stamp: 'rjl 5/11/2006 22:36'!structure	^ self context structure! !!PRCommand methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:29'!timestamp	^ self propertyAt: #timestamp ifAbsent: [ nil ]! !!PRCommand methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:29'!timestamp: aTimestamp	self propertyAt: #timestamp put: aTimestamp! !!PRCommand methodsFor: 'private' stamp: 'lr 9/25/2006 08:05'!uniqueName: aString in: aStructure	"Answer an unique structure name with the prefix aString within the parent aStructure."	| index name |	(aStructure isNil or: [ aStructure hasChildren not ])		ifTrue: [ ^ aString ].	(aStructure childrenDecoration includes: aString)		ifFalse: [ ^ aString ].	index := 1.	[ aStructure childrenDecoration		includes: (name := aString , ' ' , (index := index + 1) asString) ]		whileTrue.	^ name! !!PRCommand methodsFor: 'validating' stamp: 'lr 5/29/2006 10:14'!validateChild: aChildStructure in: aStructure	"Make sure that <code>aChildStructure</code> can be added as child or replace an existing child in a <code>aStructure</code>."	self validateChild: aChildStructure named: aChildStructure name in: aStructure! !!PRCommand methodsFor: 'validating' stamp: 'lr 3/9/2006 11:29'!validateChild: aChildStructure named: aString in: aStructure	self validateName: aString of: aChildStructure in: aStructure.	self validateNestingOf: aChildStructure in: aStructure! !!PRCommand methodsFor: 'validating' stamp: 'lr 9/25/2006 08:34'!validateName: aString of: aChildStructure in: aStructure	"Make sure that <code>aChildStructure</code> with the title <code>aString</code> can be added as child or replace an existing child in a <code>aStructure</code>."	| child |	(aStructure isNil or: [ aStructure hasChildren not ])		ifTrue: [ ^ self ].	child := aStructure childrenDecoration		at: aString		ifAbsent: [ ^ self ].	child ~= aChildStructure		ifTrue: [ PRConflictingNameError in: aStructure title: aString ]! !!PRCommand methodsFor: 'validating' stamp: 'lr 5/29/2006 10:14'!validateNestingOf: aChildStructure in: aStructure	"Make sure that <code>aChildStructure</code> can be added as child to <code>aStructure</code> and that <code>aStructure</code> can have <code>aChildStructure</code> as a child."	aStructure isNil		ifTrue: [ ^ self ].	(aStructure canBeParentOf: aChildStructure)		ifFalse: [ PRInvalidNestingError of: aChildStructure in: aStructure ].	(aChildStructure canBeChildOf: aStructure)		ifFalse: [ PRInvalidNestingError of: aChildStructure in: aStructure ]! !!PRComponentSettings class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $p! !!PRComponentSettings class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRComponentSettings class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Settings'! !!PRComponentSettings class methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:30'!structureClass	^ PRComponent! !!PRComponentSettings methodsFor: 'accessing-delegated' stamp: 'lr 4/16/2006 10:21'!description	^ (self context componentAt: self structure) description! !!PRComponentSettings methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doAnswer	super doAnswer.	self context removeComponentAt: self structure! !!PRComponentSettings methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doExecute	super doExecute.	self structure settings: self settings! !!PRComponentSettings methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!readUsing: aDescription	^ self settings at: aDescription ifAbsent: [ aDescription default ]! !!PRComponentSettings methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!settings	^ settings ifNil: [ settings := self structure settings ]! !!PRComponentSettings methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!settings: aDictionary	settings := aDictionary! !!PRComponentSettings methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!write: anObject using: aDescription	self settings at: aDescription put: anObject! !!PREditCommand commentStamp: 'lr 8/29/2005 10:55' prior: 0!Abstract command to edit structures.!!PREditCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $e! !!PREditCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PREditCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Edit'! !!PREditCommand methodsFor: 'accessing' stamp: 'lr 5/24/2006 15:16'!description	^ self structure description select: [ :each | each isEditable ]! !!PREditCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doExecute	super doExecute.	self fields keysAndValuesDo: [ :desc :value | self structure write: value using: desc ]! !!PREditCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!fields	^ fields ifNil: [ fields := Dictionary new ]! !!PREditCommand methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isEdit	^ true! !!PREditCommand methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!readUsing: aDescription	^ (self description includes: aDescription)		ifFalse: [ super readUsing: aDescription ]		ifTrue: [			self fields				at: aDescription				ifAbsent: [ self structure readUsing: aDescription ] ]! !!PREditCommand methodsFor: 'private' stamp: 'rjl 5/11/2006 22:39'!write: anObject using: aDescription	"this guard clause prevents this command from blowing up the deserialization of commands in PRFilePersistency, which is currently buggy for some reason, will remove once I chase down the error. - rjl"	context ifNil:[^self].	^ (self description includes: aDescription)		ifFalse: [ super write: anObject using: aDescription ]		ifTrue: [ self fields at: aDescription put: anObject ]! !!PRCopyCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRCopyCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Copy'! !!PRCopyCommand methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultName	^ self uniqueName: self structure name , ' copy' in: self target! !!PRCopyCommand methodsFor: 'events' stamp: 'lr 4/10/2006 14:44'!doExecute	| structure |	super doExecute.	structure := self target childrenDecoration		add: (self structure copy			name: self name;			title: nil;			yourself).	PRIncomingReferences		from: structure		to: (structure enumerator			with; all; hidden;			contents)		do: [ :each | each update ].	self answer: (self context		structure: structure)! !!PRLocationCommand class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionName	^ (MAStringDescription selector: #name label: 'Name' priority: 110)		beRequired;		yourself! !!PRLocationCommand class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionTarget	^ (PRStructureDescription selector: #target label: 'Target' priority: 100)		beRequired;		yourself! !!PRLocationCommand methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultName	^ self structure name! !!PRLocationCommand methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:29'!defaultTarget	^ self structure parent! !!PRLocationCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doValidate	super doValidate.	self validateChild: self structure named: self name in: self target! !!PRLocationCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name	^ name ifNil: [ name := self defaultName ]! !!PRLocationCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name: aString	name := aString! !!PRLocationCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!target	^ target ifNil: [ target := self defaultTarget ]! !!PRLocationCommand methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!target: aStructure	target := aStructure! !!PRMoveCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $m! !!PRMoveCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRMoveCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	^ (super isValidIn: aContext)		and: [ aContext structure isRoot not ]! !!PRMoveCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Move'! !!PRMoveCommand methodsFor: 'events' stamp: 'lr 9/25/2006 08:09'!doExecute	super doExecute.	self structure name: self name.	self target 		addChild: self structure remove.	PRIncomingReferences		from: self kernel root		to: (self structure enumerator			with; all; hidden;			contents)		do: [ :each | each update ]! !!PRMoveCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doValidate	super doValidate.	(self structure isAncestorOf: self target)		ifTrue: [ PRInvalidNestingError of: self structure in: self target ]! !!PRRemoveCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $r! !!PRRemoveCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRRemoveCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidIn: aContext	^ (super isValidIn: aContext)		and: [ aContext structure isRoot not ]! !!PRRemoveCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Remove'! !!PRRemoveCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doExecute	super doExecute.	PRIncomingReferences		from: self kernel root		to: (self structure enumerator			with; all; hidden;			contents)		do: [ :each | each target: nil ].	self structure parent in: [ :parent |		self structure remove.		self answer: (self context			structure: parent) ]! !!PRRemoveCommand methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!doValidate	super doValidate.	self structure isRoot		ifTrue: [ self error: 'Unable to remove root node.' ]! !!PRRemoveCommand methodsFor: '*pier-seaside-testing' stamp: 'lr 4/19/2006 07:33'!isConfirmed	^ true! !!PRRemoveCommand methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isQuick	^ true! !!PRViewCommand class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $v! !!PRViewCommand class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRViewCommand class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'View'! !!PRViewCommand methodsFor: '*pier-seaside-converting' stamp: 'lr 3/9/2006 11:30'!asComponent	^ self viewComponent! !!PRViewCommand methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isLogged	^ false! !!PRViewCommand methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isView	^ true! !!PRViewCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!name	^ self viewComponent name! !!PRViewCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!viewComponent	^ self propertyAt: #viewComponent ifAbsentPut: [ self viewComponentClass on: self context ]! !!PRViewCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!viewComponent: aViewComponent	self propertyAt: #viewComponent put: aViewComponent! !!PRViewCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!viewComponentClass	^ self propertyAt: #viewComponentClass ifAbsentPut: [ self context structure viewComponentClass ]! !!PRViewCommand methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!viewComponentClass: aClass	self propertyAt: #viewComponentClass put: aClass! !!PRContext commentStamp: 'lr 6/1/2006 21:12' prior: 0!I am the context in which a user is browsing the system. I hold all the information any part of Pier might be interested in: the currently used kernel, the structure that is currently displayed, the command that is being executed and the user currently logged in.I am an immutable object. Users should never try to modify me. Instead use the modification methods that return a copy of myself.!!PRContext class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionCommand	^ (MAToOneRelationDescription accessor: (MASelectorAccessor read: #command write: #setCommand:) label: 'Command' priority: 20)		classes: (MADynamicObject on: [ PRCommand withAllConcreteClasses ]);		reference: PRCommand description;		yourself! !!PRContext class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionStructure	^ PRStructureDescription accessor: (MASelectorAccessor read: #structure write: #setStructure:) label: 'Structure' priority: 10! !!PRContext class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionTimestamp	^ MATimeStampDescription accessor: (MASelectorAccessor read: #timestamp write: #setTimestamp:) label: 'Timestamp'! !!PRContext class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRContext class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!kernel: aKernel	^ self kernel: aKernel structure: aKernel root! !!PRContext class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!kernel: aKernel structure: aStructure	^ self kernel: aKernel structure: aStructure command: aStructure viewCommandClass new! !!PRContext class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!kernel: aKernel structure: aStructure command: aCommand	^ self new		setKernel: aKernel;		setStructure: aStructure;		setCommand: aCommand;		yourself! !!PRContext methodsFor: '*pier-seaside-private' stamp: 'lr 3/9/2006 11:30'!buildComponentFor: aStructure	^ aStructure component		onChangeContext: self;		yourself! !!PRContext methodsFor: 'accessing' stamp: 'lr 4/10/2006 15:02'!command	"Answer the active command of this context."	^ command! !!PRContext methodsFor: 'navigation' stamp: 'lr 5/29/2006 10:12'!command: aCommand	"Create a copy of the current context with the current command replaced by <code>aCommand</code>."	^ self copy		setCommand: aCommand;		yourself! !!PRContext methodsFor: 'accessing-conveniance' stamp: 'lr 5/27/2006 17:28'!commands	"Answer a list of possible commands, dispatching through the command class."	^ PRCommand withAllConcreteClasses		select: [ :each | each isValidIn: self ]! !!PRContext methodsFor: '*pier-seaside-caching' stamp: 'lr 3/9/2006 11:30'!componentAt: aStructure	"Return the cached component of aStructure, if none is existing yet create a new one."	^ self componentDictionary at: aStructure ifAbsentPut: [ self buildComponentFor: aStructure ]! !!PRContext methodsFor: '*pier-seaside-private' stamp: 'lr 3/9/2006 11:30'!componentDictionary	^ self propertyAt: #components ifAbsentPut: [ Dictionary new ]! !!PRContext methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!components	^ self componentDictionary values! !!PRContext methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:04'!enumerator	"Answer a default structure enumerator for the current context."	^ enumerator! !!PRContext methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:12'!enumerator: aStructure	"Answer an enumerator on <code>aStructure</code>."	^ self enumerator structure: aStructure! !!PRContext methodsFor: 'testing' stamp: 'lr 5/28/2006 17:05'!isValid	"Answer <code>true</code> if the receiver is a valid context."	^ self isValidCommand: self command class! !!PRContext methodsFor: 'testing' stamp: 'lr 5/28/2006 17:05'!isValidCommand: aCommandClass	"Answer <code>true</code> if the receiver is a valid context with the current command replaced by <code>aCommandClass</code>."	^ aCommandClass isValidIn: self! !!PRContext methodsFor: 'accessing' stamp: 'lr 4/10/2006 15:01'!kernel	"Answer the underlying kernel of this context."	^ kernel! !!PRContext methodsFor: 'copying' stamp: 'lr 4/10/2006 15:17'!postCopy	super postCopy.	self setEnumerator: self enumerator copy.	self setTimestamp: nil! !!PRContext methodsFor: 'printing' stamp: 'lr 3/9/2006 11:29'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' stucture: '; print: self structure title.	aStream nextPutAll: ' command: '; print: self command class label! !!PRContext methodsFor: '*pier-seaside-caching' stamp: 'lr 3/9/2006 11:30'!removeComponentAt: aStructure	"Remove any cached component for aStructure."	^ self componentDictionary removeKey: aStructure ifAbsent: [ ]! !!PRContext methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!renderer	^ self propertyAt: #renderer ifAbsentPut: [ PRViewRenderer new ]! !!PRContext methodsFor: 'accessing-conveniance' stamp: 'lr 3/9/2006 11:29'!root	"Answer the current root node of the structure-tree."	^ self kernel root! !!PRContext methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!session	"Answer the cached seaside session, this is a short-cut to avoid to unnecessary lookups."	^ self propertyAt: #session ifAbsentPut: [ WACurrentSession value ]! !!PRContext methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setCommand: aCommand	command := aCommand.	command setContext: self! !!PRContext methodsFor: 'initialization' stamp: 'lr 4/10/2006 15:00'!setEnumerator: aVisitor	enumerator := aVisitor! !!PRContext methodsFor: 'initialization' stamp: 'lr 4/10/2006 15:13'!setKernel: aKernel	kernel := aKernel.	self setEnumerator: (PRChildrenVisitor on: self root)! !!PRContext methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setStructure: aStructure	structure := aStructure! !!PRContext methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setTimestamp: aTimestamp	timestamp := aTimestamp! !!PRContext methodsFor: 'accessing' stamp: 'lr 4/10/2006 15:02'!structure	"Answer the currently browsed structure of this context."	^ structure! !!PRContext methodsFor: 'navigation' stamp: 'lr 5/29/2006 10:12'!structure: aStructure	"Create a copy of the current context with the current structure replaced by <code>aStructure</code> and the current command replaced by the default view."	^ self structure: aStructure command: aStructure viewCommandClass new! !!PRContext methodsFor: 'navigation' stamp: 'lr 5/29/2006 10:13'!structure: aStructure command: aCommand	"Create a copy of the current context with the current structure replaced by <code>aStructure</code> and the current command by <code>aCommand</code>."	^ self copy		setStructure: aStructure;		setCommand: aCommand;		yourself! !!PRContext methodsFor: 'accessing-conveniance' stamp: 'lr 6/2/2006 00:21'!timestamp	"Answer the timestamp when this context was used to execute its command, <code>nil</code> if never executed."	^ timestamp! !!PRContext methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!views	"Answer a list of possible views, dispatching trough the command class."	^ PRViewComponent withAllConcreteClasses		select: [ :each | each isValidIn: self ]! !!PRDecorated commentStamp: 'lr 5/28/2006 17:43' prior: 0!I am an abstract decorated object. My decorations are subclasses of *PRDecoration*. I provide all the tools to add, remove, query and visit my decorations.!!PRDecorated methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitDecorated: self! !!PRDecorated methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!acceptDecorated: aVisitor	self		decorationsDo: [ :each | aVisitor visit: each ]		ownerDo: [ :each | super acceptDecorated: aVisitor ]! !!PRDecorated methodsFor: 'adding' stamp: 'lr 5/28/2006 17:37'!addDecoration: aDecoration	"Add <code>aDecoration</code> to the receiver. This message ensures that <code>aDecoration</code> is only added once and that the decorations remain properly sorted."	^ self		addDecoration: aDecoration		ifPresent: [ :value | self error: 'Decoration is already part of receiver.' ]! !!PRDecorated methodsFor: 'adding' stamp: 'lr 5/28/2006 17:38'!addDecoration: aDecoration ifPresent: aBlock	"Add <code>aDecoration</code> to the receiver. This message ensures that the decorations remain properly sorted and that there are no duplicates. In case <code>aDecoration</code> is already within the receiver, the existing decoration is passed into <code>aBlock</code>."	| decoration |	decoration := self decorations		detect: [ :each | aDecoration = each ]		ifNone: [ nil ].	^ decoration isNil		ifFalse: [ aBlock value: decoration ]		ifTrue: [			self setDecorations: (decorations				copyWith: (aDecoration					setDecorated: self;					yourself)) sort.			aDecoration ]! !!PRDecorated methodsFor: 'querying' stamp: 'lr 5/28/2006 17:40'!decorationOfClass: aClass	"Answer the first decoration of <code>aClass</code>, raise an error if none could be found."	^ self		decorationOfClass: aClass		ifAbsent: [ self error: 'Decoration not found.' ]! !!PRDecorated methodsFor: 'querying' stamp: 'lr 5/28/2006 17:41'!decorationOfClass: aClass ifAbsent: aBlock	"Answer the first decoration of <code>aClass</code>, evaluate <code>aBlock<code> if none could be found."	^ self decorations		detect: [ :each | aClass = each species ]		ifNone: aBlock! !!PRDecorated methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:37'!decorations	"Answer the sorted decorations of the receiver."	^ decorations! !!PRDecorated methodsFor: 'enumerating' stamp: 'lr 5/28/2006 17:39'!decorationsDo: aBlock	"Evaluate <code>aBlock</code> in the right order with each of the receiver's decorations as the argument."	self decorations do: aBlock! !!PRDecorated methodsFor: 'enumerating' stamp: 'lr 5/28/2006 17:39'!decorationsDo: aBlock ownerDo: anOwnerBlock	"Evaluate <code>aBlock</code> and <code>anOwnerBlock</code> in the right order with each of the receiver's decorations and the receiver as the argument."	self decorations do: [ :each |		each priority negative			ifTrue: [ aBlock value: each ] ].	anOwnerBlock value: self.	self decorations do: [ :each |		each priority positive			ifTrue: [ aBlock value: each ] ]! !!PRDecorated methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	self setDecorations: #()! !!PRDecorated methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	self setDecorations: (self decorations collect: [ :each |		each copy postCopyTo: self ])! !!PRDecorated methodsFor: 'removing' stamp: 'lr 5/28/2006 17:40'!removeDecoration: aDecoration	"Remove <code>aDecoration</code> from the receiver, an error is raised if <code>aDecoration</code> is not part of the receiver."	^ self		removeDecoration: aDecoration		ifAbsent: [ self error: 'Decoration is not part of receiver.' ]! !!PRDecorated methodsFor: 'removing' stamp: 'lr 5/28/2006 17:40'!removeDecoration: aDecoration ifAbsent: aBlock	"Remove <code>aDecoration</code> from the receiver, <code>aBlock</code> is evaluated if <code>aDecoration</code> is not part of the receiver."	| decoration |	decoration := self decorations		detect: [ :each | aDecoration = each ]		ifNone: [ ^ aBlock value ].	self setDecorations: (self decorations		copyWithout: (decoration			setDecorated: nil;			yourself)).	^ decoration! !!PRDecorated methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setDecorations: anArray	decorations := anArray! !!PRStructure commentStamp: 'lr 5/28/2006 17:41' prior: 0!I am an abstract structure, representing the model of a single page. I've got a name, that must be unique within the scope of my parent, and a title. A structure is identified with a path of structure names.!!PRComponent class methodsFor: 'accessing-description' stamp: 'lr 5/24/2006 15:16'!descriptionComponentClass	^ (MASingleOptionDescription selector: #componentClass label: 'Component Class' priority: 200)		options: (MADynamicObject on: [			Array streamContents: [ :stream |				PRWidget allSubclassesDo: [ :each |					each isAbstract						ifFalse: [ stream nextPut: each ] ].				WAComponent allSubclassesDo: [ :each |					each canBeRoot						ifTrue: [ stream nextPut: each ] ] ] ]);		reference: MAClassDescription new;		beRequired;		beEditable;		beSorted;		yourself! !!PRComponent class methodsFor: 'accessing-resources' stamp: 'lr 3/9/2006 11:30'!icon	"PRCompatibility compileFileNamed: 'icons/component.png' into: PRComponent class selector: #icon"	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 4 103 65 77 65 0 0 175 200 55 5 138 233 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 65 100 111 98 101 32 73 109 97 103 101 82 101 97 100 121 113 201 101 60 0 0 3 90 73 68 65 84 120 218 98 252 255 255 63 3 12 28 63 126 13 193 193 2 206 157 187 193 32 36 196 207 184 108 217 122 32 45 196 176 112 97 19 3 64 0 177 160 43 50 53 85 103 248 251 247 31 195 159 63 127 25 126 253 250 13 164 255 49 124 249 242 157 129 137 137 9 40 171 1 50 228 255 166 77 147 25 227 226 106 193 234 1 2 136 5 155 77 95 255 49 50 60 124 205 198 192 253 159 145 65 144 231 23 3 51 51 19 3 204 161 166 166 90 12 211 166 173 7 58 28 40 9 4 0 1 132 98 192 31 22 86 134 71 63 152 24 190 127 103 100 120 253 138 129 225 206 51 118 134 183 239 152 25 116 181 126 49 72 137 255 6 123 1 6 44 45 141 65 70 50 2 4 16 138 1 111 190 179 50 172 221 199 200 160 206 201 192 192 254 137 129 225 232 229 159 12 251 174 220 98 136 255 241 147 33 210 89 148 193 217 217 132 225 235 215 31 12 159 63 127 103 184 122 245 46 88 15 64 0 161 24 192 199 240 155 225 214 77 6 134 71 191 126 49 220 127 241 151 225 194 237 135 12 12 239 207 50 252 254 204 199 240 245 11 7 195 143 159 255 192 97 194 196 196 8 215 3 16 64 48 3 248 25 62 190 140 19 248 243 155 225 219 139 175 12 76 127 191 48 188 122 249 17 24 24 215 25 24 62 223 100 248 242 70 134 225 205 91 97 134 127 255 152 25 184 56 185 25 88 88 89 225 6 0 4 16 19 195 236 57 89 192 96 222 201 240 242 221 36 169 159 239 24 196 63 63 97 120 126 227 35 195 175 103 183 25 24 94 92 99 96 124 123 133 129 145 225 9 195 155 215 111 24 254 255 251 203 192 202 202 204 192 206 142 48 0 32 128 88 24 182 111 155 194 112 233 34 35 131 150 22 3 211 179 135 12 130 103 142 48 24 187 37 48 124 59 245 159 129 145 243 40 131 182 217 109 6 54 133 143 64 219 13 129 49 241 23 24 108 12 224 88 129 1 128 0 98 97 120 251 246 51 195 253 123 124 127 246 237 99 56 112 253 22 195 67 215 63 12 234 245 127 24 66 30 104 50 252 253 255 139 225 233 103 14 134 157 123 174 50 232 241 49 128 211 2 19 35 35 3 11 11 51 220 0 128 0 98 249 247 249 51 247 223 159 191 24 190 126 254 204 240 246 255 31 134 255 192 24 216 241 234 36 131 16 211 5 6 134 7 130 12 87 182 189 7 70 15 208 70 185 255 12 255 254 255 3 186 224 63 208 37 255 224 6 0 4 16 203 167 183 111 55 254 249 254 221 251 215 159 63 236 55 129 238 123 247 237 63 3 11 48 13 188 126 243 147 225 237 169 23 12 63 30 49 48 176 253 101 101 248 7 76 157 127 129 129 12 74 250 72 169 159 1 32 128 152 26 254 253 79 62 240 229 107 236 163 207 95 206 124 214 214 99 208 240 12 100 248 244 152 153 225 59 208 16 134 47 12 12 255 63 48 48 112 124 226 101 248 243 247 47 48 10 255 0 147 249 95 6 228 252 3 16 64 44 91 152 153 127 110 17 19 59 206 253 239 95 113 66 98 198 65 113 49 126 6 241 183 138 12 39 190 30 98 184 253 230 30 131 149 152 14 131 149 166 45 216 217 160 60 242 239 31 200 249 8 3 0 2 8 148 14 128 65 203 240 227 43 19 211 59 94 62 126 6 30 110 94 6 99 38 11 6 67 78 51 134 95 118 192 204 244 251 55 56 99 49 51 51 131 67 31 146 169 16 0 32 128 96 6 124 3 226 183 79 159 125 96 120 240 240 37 208 175 127 129 182 253 1 59 249 15 208 223 160 192 99 101 5 102 46 110 30 6 94 222 215 12 28 28 92 192 152 128 164 65 128 0 3 0 119 56 99 163 229 209 92 150 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray! !!PRComponent class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRComponent methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitComponent: self! !!PRComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!component	^ self componentClass ifNotNilDo: [ :class |		class new in: [ :component |			self settings keysAndValuesDo: [ :description :value |				component write: value using: description ].			component ] ]! !!PRComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!componentClass	^ componentClass ifNil: [ WAComponent ]! !!PRComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!componentClass: aComponentClass	componentClass := aComponentClass.	self reset; flush! !!PRComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!flush	PRCurrentContext value		ifNotNilDo: [ :context | context removeComponentAt: self ]! !!PRComponent methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:30'!initialize	super initialize.	self reset! !!PRComponent methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!reset	self settings: Dictionary new! !!PRComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!settings	^ settings! !!PRComponent methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!settings: aDictionary	settings := aDictionary! !!PRFile commentStamp: 'lr 6/2/2006 10:54' prior: 0!I represent a data container for images, videos, sound, pdf or zip files. I reference an instance of *MAFileModel*. The mime-type is used to determine how the given file is be displayed. As an example images and videos are attempted to be inlined into the resulting output, whereas zip-files are referenced as a link to allow downloading.!!PRFile class methodsFor: 'accessing-description' stamp: 'lr 5/24/2006 15:16'!descriptionFile	^ (MAFileDescription selector: #file label: 'File' priority: 200)		beEditable;		yourself! !!PRFile class methodsFor: 'accessing-resources' stamp: 'lr 3/9/2006 11:30'!icon	"PRCompatibility compileFileNamed: 'icons/file.png' into: PRFile class selector: #icon"	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 4 103 65 77 65 0 0 175 200 55 5 138 233 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 65 100 111 98 101 32 73 109 97 103 101 82 101 97 100 121 113 201 101 60 0 0 1 199 73 68 65 84 120 218 98 252 255 255 63 3 8 92 188 248 0 194 192 1 206 156 185 206 176 248 165 59 227 249 217 54 12 92 18 26 12 207 143 207 3 139 3 4 16 11 178 34 125 125 5 56 251 215 175 255 12 127 254 252 99 248 242 229 27 3 19 19 19 212 148 157 255 15 220 63 198 40 97 22 3 87 7 16 64 44 184 108 100 102 102 100 248 255 159 9 72 51 49 64 29 201 96 110 174 205 48 119 238 246 255 140 140 255 24 97 234 0 2 136 9 151 1 11 22 108 103 96 100 100 0 27 0 243 194 201 147 87 193 236 150 180 88 184 119 1 2 8 171 11 128 182 192 217 16 231 255 99 240 242 178 98 248 248 241 43 195 167 79 95 25 46 95 190 3 151 7 8 32 172 46 72 78 246 132 123 131 17 232 12 16 253 229 203 119 134 239 223 127 128 217 200 0 32 128 152 240 185 0 230 141 191 127 255 51 252 254 253 151 129 133 133 25 136 81 29 13 16 64 88 189 144 148 228 9 212 0 137 133 79 159 190 48 252 252 249 135 129 157 157 21 24 152 44 64 195 254 161 168 5 8 32 12 3 64 33 14 194 32 91 127 254 252 9 102 179 178 50 131 229 254 253 251 15 246 18 50 0 8 32 12 47 128 228 255 252 249 207 176 108 217 78 136 13 64 103 131 98 98 207 158 83 96 26 196 71 6 0 1 132 97 192 63 160 11 23 47 222 193 16 26 234 196 176 110 221 65 176 141 91 182 28 133 7 42 58 0 8 32 12 3 254 254 197 12 19 63 63 91 168 235 24 49 188 0 16 64 24 6 128 66 59 60 220 153 97 245 234 125 12 33 33 142 96 91 55 109 58 12 150 219 190 253 56 134 225 0 1 196 130 233 133 191 224 128 3 105 6 101 52 80 192 129 92 240 231 207 95 48 31 20 51 200 0 32 128 152 176 57 31 228 74 152 83 97 249 128 145 17 123 146 7 8 32 22 228 236 10 194 164 2 128 0 3 0 237 195 170 115 175 167 116 71 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray! !!PRFile class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRFile methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitFile: self! !!PRFile methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!contents	^ self file contents! !!PRFile methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!file	^ file! !!PRFile methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!file: aFile	file := aFile! !!PRFile methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!filename	^ self file filename! !!PRFile methodsFor: 'initialization' stamp: 'lr 3/12/2006 00:57'!initialize	super initialize.	self file: MAFileModel new! !!PRFile methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!mimetype	^ self file mimetype! !!PRFile methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	self file: self file copy! !!PRPage commentStamp: 'lr 6/1/2006 21:13' prior: 0!I am the most important class of the structure hierarchy. I reference a composite of documents modeling the contents of the page that the user entered using the Wiki syntax. When initializing the instance a default document will be created to make the user aware of the newly created page.!!PRPage class methodsFor: 'accessing-description' stamp: 'lr 5/24/2006 15:17'!descriptionContents	^ (MAMemoDescription selector: #contents label: 'Contents' priority: 200)		default: String new;		beEditable;		yourself! !!PRPage class methodsFor: '*pier-seaside-description' stamp: 'lr 4/10/2006 11:10'!descriptionContentsSeaside: aDescription	aDescription attributes at: 'class' put: 'wiki'.	^ aDescription! !!PRPage class methodsFor: 'accessing-resources' stamp: 'lr 3/9/2006 11:30'!icon	"PRCompatibility compileFileNamed: 'icons/page.png' into: PRPage class selector: #icon"	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 4 103 65 77 65 0 0 175 200 55 5 138 233 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 65 100 111 98 101 32 73 109 97 103 101 82 101 97 100 121 113 201 101 60 0 0 1 211 73 68 65 84 120 218 98 252 255 255 63 3 8 92 188 248 0 194 192 1 206 156 185 206 176 248 165 59 227 249 217 54 12 92 18 26 12 207 143 207 3 139 3 4 16 11 178 34 125 125 5 56 251 215 175 255 12 127 254 252 99 248 242 229 27 3 19 19 19 212 148 157 255 15 220 63 198 40 97 22 3 87 7 16 64 44 184 108 100 102 102 100 248 255 159 9 72 51 49 64 29 201 96 110 174 205 48 119 238 246 255 140 140 255 24 97 234 0 2 8 195 128 221 187 207 130 233 191 127 25 24 254 253 251 207 96 101 165 13 118 9 200 11 48 208 146 22 11 50 18 108 8 64 0 97 24 224 234 106 12 166 255 253 99 0 106 252 207 240 227 199 47 16 143 193 203 203 138 225 227 199 175 12 159 62 125 101 184 124 249 14 92 61 64 0 225 116 1 200 217 32 67 126 254 252 13 116 205 95 176 230 31 63 126 48 152 153 105 161 168 7 8 32 156 46 128 121 227 251 247 95 64 141 191 25 94 189 250 0 228 255 1 123 11 25 0 4 16 86 23 128 108 7 57 255 239 223 127 12 223 190 125 103 248 253 251 15 152 13 18 183 180 212 65 81 15 16 64 24 6 184 184 24 131 21 254 252 249 15 236 100 144 237 160 180 242 251 247 95 176 237 255 64 254 66 2 0 1 132 97 192 158 61 103 129 138 255 3 211 193 47 176 6 136 205 16 141 32 182 141 141 62 138 122 128 0 194 48 192 217 217 24 232 239 223 96 197 32 77 160 40 4 25 240 231 207 95 56 31 25 0 4 16 134 1 59 119 130 92 240 27 108 59 72 35 178 11 64 180 149 149 30 138 122 128 0 194 48 192 222 222 0 168 248 47 220 0 152 173 160 168 4 137 161 187 0 32 128 48 12 0 105 6 5 34 72 243 190 125 231 192 46 0 25 250 31 71 86 3 8 32 20 3 64 241 14 2 140 140 32 204 200 224 232 104 8 15 3 144 24 54 67 0 2 136 5 57 187 34 167 119 98 1 64 128 1 0 237 159 25 57 6 58 246 245 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray! !!PRPage class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRPage methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitPage: self! !!PRPage methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!contents	^ self rendererClass write: self document! !!PRPage methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!contents: aString	self document: (self parserClass		parse: (aString ifNil: [ String new ]))! !!PRPage methodsFor: 'accessing-configuration' stamp: 'lr 5/28/2006 17:35'!defaultDocument	"Answer the default document of the receiver."	^ PRDocument new		add: (PRParagraph new			add: (PRText with: 'Edit this page ...');			yourself);		yourself! !!PRPage methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:35'!document	"Answer the document of the receiver."	^ document! !!PRPage methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!document: aDocument	document := aDocument.	document owner: self! !!PRPage methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasDocument	^ self document notNil! !!PRPage methodsFor: 'initialize-release' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	self document: self defaultDocument! !!PRPage methodsFor: 'accessing-configuration' stamp: 'lr 5/29/2006 09:28'!parserClass	"Answer the default document parser for the receiver."	^ PRDocumentParser! !!PRPage methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	self document: self document copy! !!PRPage methodsFor: 'accessing-configuration' stamp: 'lr 5/28/2006 17:36'!rendererClass	"Answer the default document writer for the receiver."	^ PRDocumentWriter! !!PRStructure class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!canBeChildOf: aStructureClass	^ true! !!PRStructure class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!canBeParentOf: aStructureClass	^ true! !!PRStructure class methodsFor: 'accessing-private' stamp: 'lr 3/9/2006 11:30'!descriptionName	^ (MAStringDescription selector: #name label: 'Name')		beRequired;		yourself! !!PRStructure class methodsFor: 'accessing-private' stamp: 'lr 3/9/2006 11:30'!descriptionParent	^ (PRStructureDescription selector: #parent label: 'Parent')		beReadonly;		beHidden;		yourself! !!PRStructure class methodsFor: 'accessing-private' stamp: 'lr 3/9/2006 11:30'!descriptionRoot	^ (PRStructureDescription selector: #root label: 'Root')		beReadonly;		beHidden;		yourself! !!PRStructure class methodsFor: 'accessing-description' stamp: 'lr 5/24/2006 15:17'!descriptionTitle	^ (MAStringDescription selector: #title label: 'Title' priority: 100)		beRequired;		beEditable;		yourself! !!PRStructure class methodsFor: 'accessing-resources' stamp: 'lr 3/9/2006 11:30'!icon	"PRCompatibility compileFileNamed: 'icons/structure.png' into: PRStructure class selector: #icon"	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 4 103 65 77 65 0 0 175 200 55 5 138 233 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 65 100 111 98 101 32 73 109 97 103 101 82 101 97 100 121 113 201 101 60 0 0 2 37 73 68 65 84 120 218 98 252 255 255 63 3 12 28 191 252 252 150 152 32 151 212 191 127 255 126 194 196 254 1 241 207 223 12 12 95 190 253 230 184 123 239 193 241 55 175 94 196 50 179 176 62 231 224 17 96 152 53 161 145 1 32 128 88 24 144 128 16 31 187 160 146 52 31 55 144 201 13 19 3 25 255 5 104 220 211 87 95 25 52 212 149 157 95 240 243 108 188 125 235 110 8 208 226 71 32 121 128 0 98 66 54 224 31 3 38 96 4 41 2 170 98 98 100 98 224 102 101 96 112 177 210 52 213 214 209 220 10 20 87 5 185 30 32 128 152 24 136 0 172 204 64 39 113 177 49 188 253 252 141 225 220 245 199 64 87 49 233 176 113 112 111 255 207 240 223 0 32 128 136 50 128 17 104 29 23 59 51 131 136 160 0 195 251 15 191 24 94 189 249 204 192 196 202 161 252 247 207 159 104 128 0 98 33 198 0 102 160 1 204 64 87 176 0 9 94 62 78 6 54 14 118 134 95 127 89 24 254 255 251 207 2 16 64 68 25 240 11 24 11 239 62 253 100 248 244 229 59 208 59 44 12 44 156 64 111 253 99 1 57 237 63 64 0 17 52 224 235 47 160 230 207 191 25 126 254 250 195 192 206 206 202 192 194 194 2 142 25 166 63 140 96 175 1 4 16 11 33 205 95 127 128 188 192 204 192 201 198 202 240 155 233 31 195 159 191 127 129 54 51 49 252 7 233 6 2 128 0 194 105 192 239 255 144 52 192 202 10 114 41 80 3 3 72 233 31 160 94 70 112 212 254 254 7 49 0 32 128 112 26 240 31 26 112 255 128 137 227 63 48 174 88 88 24 25 254 3 5 25 129 113 207 8 180 29 102 16 64 0 97 141 70 144 205 240 20 206 8 118 49 3 72 57 200 37 204 64 205 76 64 54 51 35 68 43 64 0 225 52 0 57 37 66 146 232 127 48 227 223 255 255 40 106 1 2 8 197 11 76 200 201 151 17 226 13 80 50 6 198 28 80 43 35 208 59 44 12 255 88 254 0 213 49 131 99 1 4 0 2 8 197 128 223 176 120 7 217 5 180 232 15 16 255 253 15 241 14 136 13 12 66 134 191 12 172 16 23 2 117 50 177 176 49 2 4 16 138 1 139 22 44 157 184 117 227 74 105 14 14 174 223 184 188 4 230 253 7 165 74 54 142 7 183 47 157 6 8 48 0 76 143 160 230 112 21 24 41 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray! !!PRStructure class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!named: aString	^ self new		name: aString;		yourself! !!PRStructure methodsFor: 'comparing' stamp: 'lr 8/24/2006 22:46'!< aStructure	^ self title < aStructure title! !!PRStructure methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitStructure: self! !!PRStructure methodsFor: 'accessing-children' stamp: 'lr 5/28/2006 17:16'!addChild: aStructure	"Add <code>aStructure</code> as child to the receiver."	^ self childrenDecoration add: aStructure! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:19'!canBeChildOf: aStructure	"Answer <code>true</code> if the receiver can be a child of <code>aStructure</code>."	^ self class canBeChildOf: aStructure class! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:19'!canBeParentOf: aStructure	"Answer <code>true</code> if the receiver can be a parent of <code>aStructure</code>."	^ self class canBeParentOf: aStructure class! !!PRStructure methodsFor: 'decorations' stamp: 'lr 9/25/2006 08:13'!childrenDecoration	"Answer a decoration with the children of the receiver. If no children exist, an empty children decoration is added to the receiver. Don't call this method directly to avoid empty children decorations."	^ self		decorationOfClass: self childrenDecorationClass		ifAbsent: [ self addDecoration: self childrenDecorationClass new ]! !!PRStructure methodsFor: 'decorations' stamp: 'lr 3/9/2006 11:30'!childrenDecorationClass	^ PRChildren! !!PRStructure methodsFor: 'accessing-persistency' stamp: 'lr 5/28/2006 17:17'!creationTimestamp	"Answer the creation-timestamp or <code>nil</code>."	self kernel persistency		do: [ :each | ^ each timestamp ]		for: self.	^ nil! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!document	^ PRDocument new		add: (PRInternalLink new			embedded: true; target: self;			add: (PRText with: self title);			yourself);		yourself! !!PRStructure methodsFor: 'accessing-commands' stamp: 'lr 6/2/2006 09:20'!editCommandClass	"Answer an instance of the default edit command of the receiver."	^ PREditCommand! !!PRStructure methodsFor: 'accessing-children' stamp: 'lr 3/9/2006 11:30'!enumerator	"Answer an enumerator on the children of the receiver."	^ PRChildrenVisitor on: self! !!PRStructure methodsFor: '*pier-seaside-accessing' stamp: 'lr 9/25/2006 08:08'!environment	"Answer the (inherited) environment of the receiver, if none is available a default one is created."	self hasChildren ifTrue: [		self childrenDecoration			at: self environmentSelector			ifPresent: [ :value |  ^ value ] ].	^ self isRoot		ifFalse: [ self parent environment ]		ifTrue: [ self addChild: self environmentStructure ]! !!PRStructure methodsFor: '*pier-seaside-configuration' stamp: 'lr 3/9/2006 11:30'!environmentSelector	^ 'environment'! !!PRStructure methodsFor: '*pier-seaside-configuration' stamp: 'lr 4/10/2006 12:12'!environmentStructure	^ (PRPage named: 'environment')		addDecoration: PRHider new;		addChild: ((PRComponent named: 'header')			componentClass: PRHeaderWidget;			yourself);		addChild: ((PRComponent named: 'views')			componentClass: PRViewsWidget;			yourself);		addChild: ((PRComponent named: 'commands')			componentClass: PRCommandsWidget;			yourself);		addChild: ((PRComponent named: 'tree')			componentClass: PRTreeWidget;			yourself);		addChild: ((PRComponent named: 'main')			componentClass: PRContentsWidget;			yourself);		contents: '+header+<table class="body"><tr><td class="boxes">+views+<br />+commands+<br />+tree+</td><td class="spacer"></td><td class="main">+main+</td></tr></table>';		yourself! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:19'!hasChildren	"Answer <code>true</code> if the receiver has got children, they might not be visible however."	self enumerator hidden; do: [ :each | ^ true ].	^ false! !!PRStructure methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasDocument	^ false! !!PRStructure methodsFor: 'testing' stamp: 'lr 6/2/2006 11:08'!hasParent	"Answer <code>true</code> if the receiver has got a parent. This is the negation of <code>#isRoot</code>."	^ self parent notNil! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!icon	"Return the raw data of an icon representing the type of the receiver."	^ self class icon! !!PRStructure methodsFor: 'testing' stamp: 'lr 6/2/2006 11:09'!isAllowedCommand: aCommandClass in: aContext 	"Answer <code>true</code> if the receiver accepts <code>aCommandClass</code> as allowed in <code>aContext</code> on the receiver. If a command class is allowed is a security question and should therefore only depend on the permissions in the current context. The default implementation delegates the decision to the decorations of the receiver. Therefor this method should never be overridden by subclasses."	^ self decorations allSatisfy: [ :each |		each			isAllowedCommand: aCommandClass			in: aContext ]! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:23'!isAncestorOf: aStructure	"Answer <code>true</code> if the receiver is an ancestor of <code>aStructure</code>."	^ aStructure parents includes: self! !!PRStructure methodsFor: 'testing' stamp: 'lr 6/2/2006 11:13'!isApplyableCommand: aCommandClass in: aContext 	"Answer <code>true</code> if the receiver accepts <code>aCommandClass</code> as applyable in <code>aContext</code> on the receiver. If a command class is applyable or not is a question of saneness and compatibility, not of security. This method should be overridden by subclasses who want to forbid some commands."	^ self isKindOf: aCommandClass structureClass! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:28'!isRoot	"Answer <code>true</code> if the receiver is the root of the Pier model. This is the negation of <code>#hasParent</code>."	^ self parent isNil! !!PRStructure methodsFor: 'testing' stamp: 'lr 5/28/2006 17:30'!isValidCommand: aCommandClass in: aContext 	"Answer <code>true</code> if the receiver accepts to execute <code>aCommandClass</code> in <code>aContext</code>. This message is the combination of <code>#isApplyableCommand:in:</code> and <code>#isAllowedCommand:in:</code>. It should not be overridden."	^ (self isApplyableCommand: aCommandClass in: aContext)		and: [ self isAllowedCommand: aCommandClass in: aContext ]! !!PRStructure methodsFor: '*pier-seaside-testing' stamp: 'lr 3/9/2006 11:30'!isValidView: aComponentClass in: aContext	"Answer true if aComponentClass is a valid command in aContext."	^ true! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!kernel	"Answer the kernel of the receiver."	^ self root in: [ :root |		PRKernel instances			detect: [ :each | each root = root ]			ifNone: [ self error: self title , ' is not part of a kernel.' ] ]! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 6/2/2006 09:21'!level	"Answer the nesting level of the receiver."	^ self parents size! !!PRStructure methodsFor: 'accessing-persistency' stamp: 'lr 5/28/2006 17:17'!modificationTimestamp	"Answer the modification-timestamp or <code>nil</code>."	self kernel persistency		reverseDo: [ :each | ^ each timestamp ]		for: self.	^ nil! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!name	"Answer the name of the receiver. The name should be simple and only contain letters and numbers, since it is used as an identifier within restrictive protocols."	^ name! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!name: aString	name := aString! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!parent	"Answer the parent structure of the receiver."	^ parent! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!parent: aStructure	parent := aStructure! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 6/2/2006 09:22'!parents	"Answer an ordered collection of all the parents of the receiver up and including the receiver itself."	^ self isRoot		ifTrue: [ OrderedCollection with: self ]		ifFalse: [			self parent parents				addLast: self;				yourself ]! !!PRStructure methodsFor: 'copying' stamp: 'lr 3/9/2006 11:30'!postCopy	super postCopy.	self parent: nil! !!PRStructure methodsFor: 'copying' stamp: 'lr 3/9/2006 11:30'!postCopyTo: anObject	self parent: anObject! !!PRStructure methodsFor: 'printing' stamp: 'lr 3/9/2006 11:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!PRStructure methodsFor: 'actions' stamp: 'lr 6/2/2006 09:22'!remove	"Remove the receiver from the parent structure."	self parent childrenDecoration remove: self! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!root	"Answer the root structure of the receiver."	^ self isRoot		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!title	"Answer the title of the receiver, essentially the name but starting uppercase."	^ title ifNil: [ title := self name capitalized ]! !!PRStructure methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!title: aString	title := aString! !!PRStructure methodsFor: 'testing' stamp: 'lr 9/11/2006 10:56'!validateCommand: aCommand 	"Validates <code>Command</code> to be executed within the context of the reicever. Throw an exception if there is something wrong with the command."	self decorations do: [ :each | each validateCommand: aCommand ]! !!PRStructure methodsFor: 'accessing-commands' stamp: 'lr 6/2/2006 09:20'!viewCommandClass	"Answer the default view command of the receiver. Most likely you never need to change the default implementation."	^ PRViewCommand! !!PRStructure methodsFor: '*pier-seaside-configuration' stamp: 'lr 3/9/2006 11:30'!viewComponentClass	"Return the default view component class of the reciever."	^ PRDefaultView! !!PRDecoration commentStamp: 'lr 5/30/2006 19:16' prior: 0!I am an abstract decoration to add new behaviour and data to structures. Every decoration knows its owner, a subclass of *PRDecorated*. Decorations are considered to be equal if they are of the same species, but subclasses might want to refine this behaviour to be able to add multiple instances of the same class.Within the owner decorations are ordered according to their priority. Decorations with a negative priority are visited before the owner, decorations with a positive one after the owner.!!PRChildren commentStamp: 'lr 5/28/2006 17:47' prior: 0!I hold the children of the decorated object.!!PRChildren class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRChildren methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitChildren: self! !!PRChildren methodsFor: 'actions' stamp: 'lr 5/28/2006 17:49'!add: aStructure	"Add <code>aStructure</code> as a child to the receiver."	(self isValidChild: aStructure)		ifFalse: [ self error: 'Unable to add structure to ' , self decorated title , '.' ].	self children		at: aStructure name		put: (aStructure			parent: self decorated;			yourself).	self triggerStructureAdded: aStructure.	^ aStructure! !!PRChildren methodsFor: 'accessing-children' stamp: 'lr 5/28/2006 17:49'!at: aString	"Answer the child structure with the name <code>aString</code>, raise an error if the child can't be found."	^ self at: aString ifAbsent: [ self error: 'Child not found.' ]! !!PRChildren methodsFor: 'accessing-children' stamp: 'lr 5/28/2006 17:49'!at: aString ifAbsent: aBlock	"Answer the child structure with the name <code>aString</code>, evaluate <code>aBlock</code> if the child can't be found."	^ self children at: aString ifAbsent: aBlock! !!PRChildren methodsFor: 'accessing-children' stamp: 'lr 3/9/2006 11:29'!at: aString ifPresent: aBlock	^ self children at: aString ifPresent: aBlock! !!PRChildren methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!children	^ children! !!PRChildren methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:29'!childrenCollection	^ Dictionary new! !!PRChildren methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!do: aBlock	self children do: aBlock! !!PRChildren methodsFor: 'enumerating' stamp: 'lr 8/24/2006 22:47'!do: aBlock sorted: aSortBlock	(self children values sort: aSortBlock)		do: aBlock! !!PRChildren methodsFor: 'accessing-children' stamp: 'lr 3/9/2006 11:29'!includes: aString	^ self children includesKey: aString! !!PRChildren methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	self setChildren: self childrenCollection! !!PRChildren methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isEmpty	^ children isEmpty! !!PRChildren methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isValidChild: aStructure	^ aStructure name notNil		and: [ aStructure name notEmpty		and: [ aStructure parent isNil		and: [ (self includes: aStructure name) not		and: [ (self decorated canBeParentOf: aStructure)		and: [ (aStructure canBeChildOf: self decorated) ] ] ] ] ]! !!PRChildren methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopyTo: anObject	super postCopyTo: anObject.	self setChildren: self children copy.	self children keysAndValuesDo: [ :key :value |		self children at: key put: (value copy			postCopyTo: self decorated) ]! !!PRChildren methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!priority	^ 200! !!PRChildren methodsFor: 'actions' stamp: 'lr 9/24/2006 19:24'!remove: aStructure	"Remove <code>aStructure</code> from the receiver."	self children keysAndValuesDo: [ :key :value |		aStructure = value ifTrue: [			self children removeKey: key.			self triggerStructureRemoved: value.			self isEmpty ifTrue: [ self remove ].			^ value				parent: nil;				yourself ] ].	self error: 'Unable to remove structure from ' , self decorated title , '.'! !!PRChildren methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setChildren: aCollection	children := aCollection! !!PRChildren methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:47'!size	"Answer the number of children of the receiver."	^ self children size! !!PRChildren methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!triggerStructureAdded: aStructure	PRDecoration withAllConcreteClassesDo: [ :each | each onStructureAdded: aStructure ]! !!PRChildren methodsFor: 'events' stamp: 'lr 3/9/2006 11:29'!triggerStructureRemoved: aStructure	PRDecoration withAllConcreteClassesDo: [ :each | each onStructureRemoved: aStructure ]! !!PRDecoration class methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onStructureAdded: aStructure	"This event is called whenever a structure is added as a child to another structure."! !!PRDecoration class methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!onStructureRemoved: aStructure	"This event is called whenever a structure is removed as a child from another structure."! !!PRDecoration methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!<= aDecoration	^ self priority <= aDecoration priority! !!PRDecoration methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= aDecoration	^ self species = aDecoration species! !!PRDecoration methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitDecoration: self! !!PRDecoration methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:45'!decorated	"Answer the owner of the receiver, the decorated object."	^ decorated! !!PRDecoration methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ self species hash! !!PRDecoration methodsFor: 'testing' stamp: 'lr 5/29/2006 08:31'!isAllowedCommand: aCommandClass in: aContext 	"Answer <code>true</code> if the receiver allows one to execute <code>aCommandClass</code> in <code>aContext</code>. The default decoration is fine with all the commands, subclasses might restrict to a selected set of commands within a given context. This method might be overridden by decorations that want to control the security."	^ true! !!PRDecoration methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	self setDecorated: nil! !!PRDecoration methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopyTo: anObject	super postCopyTo: anObject.	self setDecorated: anObject! !!PRDecoration methodsFor: 'accessing' stamp: 'lr 5/29/2006 09:27'!priority	"The default priority returns a number that defines in witch order the visitors will traverse through decorated objects. Negative numbers are visited before the decorated objects, positive numbers afterwards."	^ self subclassResponsibility! !!PRDecoration methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:29'!remove	self decorated notNil		ifFalse: [ ^ self ].	self decorated		removeDecoration: self		ifAbsent: [ ]! !!PRDecoration methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setDecorated: aStructure	decorated := aStructure! !!PRDecoration methodsFor: 'testing' stamp: 'lr 9/11/2006 10:56'!validateCommand: aCommand 	"Validates <code>Command</code> to be executed within the context of the reicever."! !!PRHider commentStamp: 'lr 5/28/2006 17:48' prior: 0!I hide the decorated object.!!PRHider class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRHider methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitHider: self! !!PRHider methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!priority	^ -400! !!PRMockDecoration class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRMockDecoration methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= aDecoration	^ super = aDecoration		and: [ self priority = aDecoration priority ]! !!PRMockDecoration methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self priority hash! !!PRMockDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!priority	^ priority! !!PRMockDecoration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!priority: anInteger	priority := anInteger! !!PRDocumentItem commentStamp: 'lr 5/28/2006 20:30' prior: 0!I am an abstract superclass for the document hierarchy. My subclasses include all the basic elements to represent a document.!!PRAnchor commentStamp: 'lr 5/29/2006 09:30' prior: 0!I am an anchor within a document. I am used as a reference point within a large document.!!PRAnchor class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionName	^ MAStringDescription selector: #name label: 'Name'! !!PRAnchor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRAnchor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!with: aString	^ self new		name: aString;		yourself! !!PRAnchor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self name = anObject name ]! !!PRAnchor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitAnchor: self! !!PRAnchor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self name hash! !!PRAnchor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name	^ name! !!PRAnchor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name: aString	name := aString! !!PRDocumentGroup commentStamp: 'lr 5/28/2006 20:33' prior: 0!I am an abstract group of document items.!!PRDocument commentStamp: 'lr 5/28/2006 21:06' prior: 0!I am the root of a document composite.!!PRDocument class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRDocument methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitDocument: self! !!PRDocumentGroup class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionText	^ (MANumberDescription selector: #size label: 'Size')		beReadonly;		yourself! !!PRDocumentGroup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!with: aDocumentItem	^ self new		add: aDocumentItem;		yourself! !!PRDocumentGroup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!PRDocumentGroup methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!PRDocumentGroup methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitDocumentGroup: self! !!PRDocumentGroup methodsFor: 'adding' stamp: 'lr 3/20/2006 19:06'!add: aDocumentItem	self setChildren: (self children copyWith: aDocumentItem)! !!PRDocumentGroup methodsFor: 'adding' stamp: 'lr 3/20/2006 19:06'!addAll: aCollection	self setChildren: (self children copyWithAll: aCollection)! !!PRDocumentGroup methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:32'!children	"Answer the children of the receiver."	^ children! !!PRDocumentGroup methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasChildren	^ self children notEmpty! !!PRDocumentGroup methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self children hash! !!PRDocumentGroup methodsFor: 'initialization' stamp: 'lr 3/20/2006 19:06'!initialize	super initialize.	self setChildren: Array new! !!PRDocumentGroup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!owner: anObject	super owner: anObject.	self children do: [ :each | each owner: anObject ]! !!PRDocumentGroup methodsFor: 'copying' stamp: 'lr 3/20/2006 19:06'!postCopy	super postCopy.	self setChildren: (self children collect: #copy)! !!PRDocumentGroup methodsFor: 'initialization' stamp: 'lr 3/20/2006 19:06'!setChildren: aCollection	children := aCollection! !!PRDocumentGroup methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!size	^ self children size! !!PRDocumentGroup methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!text	^ String streamContents: [ :stream |		self children do: [ :each |			stream nextPutAll: each text ] ]! !!PRHeader commentStamp: 'lr 5/28/2006 20:34' prior: 0!I represent a header within a document. My level is a natural number.!!PRHeader class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionLevel	^ MANumberDescription selector: #level label: 'Level'! !!PRHeader class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRHeader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!with: anItem level: anInteger	^ (self with: anItem)		level: anInteger;		yourself! !!PRHeader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!withAll: aCollection level: anInteger	^ (self withAll: aCollection)		level: anInteger;		yourself! !!PRHeader methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self level = anObject level ]! !!PRHeader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitHeader: self! !!PRHeader methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self level hash! !!PRHeader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!level	^ level! !!PRHeader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!level: anInteger	level := anInteger! !!PRLink commentStamp: 'lr 5/28/2006 21:02' prior: 0!I am an abstract link built from an alias and a reference. The alias is the string representation that will be displayed to the user, whereas the reference is a string identifying the target. If there is no alias, the reference itself is displayed. Links can try to embed the referenced target into the containing document.!!Examples=*Reference*=+Alias>Embedded Reference*!!PRExternalLink commentStamp: 'lr 5/28/2006 20:41' prior: 0!I am an abstract external link with an URL (Uniform Resource Locator) as reference.!!PRExternalLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionUrl	^ (MAStringDescription selector: #url label: 'Url')		beReadonly! !!PRExternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRExternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ '*://*' match: aString! !!PRExternalLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	^ 40! !!PRExternalLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitExternalLink: self! !!PRExternalLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:41'!url	"Answer the URL the receiver is pointing to."	^ String streamContents: [ :stream |		stream			nextPutAll: self urlPrefix;			nextPutAll: self urlEntry;			nextPutAll: self urlPostfix ]! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlEntry	^ self reference! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPostfix	^ String new! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPrefix	^ String new! !!PRGoogleLink class methodsFor: 'testing' stamp: 'lr 9/4/2006 11:32'!isValidReference: aString	^ 'google:*' match: aString! !!PRGoogleLink class methodsFor: 'accessing' stamp: 'lr 9/4/2006 11:31'!priority	^ 20! !!PRGoogleLink methodsFor: 'accessing-dynamic' stamp: 'lr 9/4/2006 11:31'!urlEntry	^ super urlEntry copyAfter: $:! !!PRGoogleLink methodsFor: 'accessing-dynamic' stamp: 'lr 9/4/2006 11:30'!urlPrefix	^ 'http://www.google.com/search?q='! !!PRIsbnLink commentStamp: 'lr 5/28/2006 20:46' prior: 0!I am an external link pointing to an ISBN (International Standard Book Number).!!PRIsbnLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ 'isbn:*' match: aString! !!PRIsbnLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	^ 20! !!PRIsbnLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitIsbnLink: self! !!PRIsbnLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlEntry	^ super urlEntry copyAfter: $:! !!PRIsbnLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPrefix	^ 'http://www.amazon.com/exec/obidos/ISBN='! !!PRMailLink commentStamp: 'lr 6/2/2006 11:29' prior: 0!I am an external link pointing to a mail address. I encode my URL to prevent spam bots collecting the address.!!PRMailLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ '*@*.*' match: aString! !!PRMailLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	^ 10! !!PRMailLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitMailLink: self! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'lr 5/24/2006 11:12'!urlEntry	^ String streamContents: [ :stream |		super urlEntry do: [ :each |			2 atRandom = 1				ifTrue: [ stream nextPut: each ]				ifFalse: [ stream nextPut: $%; nextPutAll: ((each asciiValue printStringBase: 16)		padded: #left to: 2 with: $0) ] ] ]! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPrefix	^ 'mailto:'! !!PRRfcLink commentStamp: 'lr 5/28/2006 20:46' prior: 0!I am an external link pointing to a RFC (Request for Comments) document.!!PRRfcLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ 'rfc:*' match: aString! !!PRRfcLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	^ 30! !!PRRfcLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitRfcLink: self! !!PRRfcLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlEntry	^ super urlEntry copyAfter: $:! !!PRRfcLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPostfix	^ '.html'! !!PRRfcLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPrefix	^ 'http://www.faqs.org/rfcs/rfc'! !!PRInternalLink commentStamp: 'lr 5/28/2006 20:48' prior: 0!I am an internal link pointing to a structure within the current kernel. I reference my owning structure to be able to lookup the referenced structure. The referenced structure is cached in the instance variable <code>target</code>.!!PRInternalLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionAnchor	^ MAStringDescription selector: #anchor label: 'Anchor'! !!PRInternalLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionTarget	^ PRStructureDescription selector: #target label: 'Target'! !!PRInternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRInternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ true! !!PRInternalLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	^ 50! !!PRInternalLink class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!reference: aString	| index |	^ (index := aString indexOf: $@) isZero		ifTrue: [ super reference: aString ]		ifFalse: [			self new				reference: (aString copyFrom: 1 to: index - 1);				anchor: (aString copyFrom: index + 1 to: aString size);				yourself ]! !!PRInternalLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self anchor = anObject anchor ]! !!PRInternalLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitInternalLink: self! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:48'!anchor	"Answer an anchor string the receiver is pointing to."	^ anchor! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!anchor: aString	anchor := aString! !!PRInternalLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasAnchor	^ self anchor notNil! !!PRInternalLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self anchor hash! !!PRInternalLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isBroken	^ self target isNil! !!PRInternalLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isInternal	^ true! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!owner	^ owner! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!owner: anObject	super owner: (owner := anObject).	self refresh! !!PRInternalLink methodsFor: 'actions' stamp: 'lr 6/2/2006 00:21'!refresh	"This message will be sent by the structure whenever it is parsed and the references have to be set up. It simply starts a look-up in the owner using the reference-string. In case the reference is invalid the target will be set to <code>nil</code> and the receiver is in a broken-state."	self target: (PRPathLookup		start: self owner		path: self reference		onError: [ nil ])! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:48'!target	"Answer the referenced structure."	(target isNil and: [ self hasOwner ])		ifTrue: [ self refresh ].	^ target! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!target: aStructure	target := aStructure! !!PRInternalLink methodsFor: 'actions' stamp: 'lr 6/2/2006 11:23'!update	"This method will be sent to all the internal-links whenever the owner is renamed or moved to a different location in the structure tree. It automatically adjusts the receivers state, so that the reference still points to the right location and doesn't get broken."	self reference: (PRPathReference		from: self owner		to: self target)! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionAlias	^ (MAStringDescription selector: #alias label: 'Alias')		beReadonly;		yourself! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionHasAlias	^ (MABooleanDescription selector: #hasAlias label: 'Aliased')		beReadonly;		yourself! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionHasAnchor	^ (MABooleanDescription selector: #hasAnchor label: 'Anchored')		beReadonly;		yourself! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionIsBroken	^ (MABooleanDescription selector: #isBroken label: 'Broken')		beReadonly;		yourself! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionIsEmbedded	^ MABooleanDescription selector: #isEmbedded label: 'Embedded'! !!PRLink class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionReference	^ MAStringDescription selector: #reference label: 'Reference'! !!PRLink class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!fromString: aString	| classes |	classes := (self withAllConcreteClasses		select: [ :each | each isValidReference: aString ])		asSortedCollection: [ :a :b | a priority < b priority ].	^ classes first reference: aString! !!PRLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	self subclassResponsibility! !!PRLink class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!priority	self subclassResponsibility! !!PRLink class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!reference: aString	^ self new		reference: aString;		yourself! !!PRLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self reference = anObject reference ]		and: [ self embedded = anObject embedded ]! !!PRLink methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitLink: self! !!PRLink methodsFor: 'accessing-dynamic' stamp: 'lr 5/28/2006 20:39'!alias	"Answer the alias of the receiver or an empty string if none."	^ self text! !!PRLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:38'!embedded	"Answer <code>true</code> if the reference should be embedded."	^ embedded! !!PRLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!embedded: aBoolean	embedded := aBoolean! !!PRLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasAlias	^ self hasChildren! !!PRLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasAnchor	^ false! !!PRLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: (self reference hash bitXor: self embedded hash)! !!PRLink methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	self embedded: false! !!PRLink methodsFor: 'testing' stamp: 'lr 5/28/2006 20:49'!isBroken	"Answer <code>true</code> if the receiver is broken."	^ false! !!PRLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isEmbedded	^ self embedded! !!PRLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isInternal	^ false! !!PRLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:39'!reference	"Answer the reference of the receiver."	^ reference! !!PRLink methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!reference: aString	reference := aString! !!PRList commentStamp: 'lr 5/28/2006 20:55' prior: 0!I am an abstract list. My children are instances of *PRListItem*.!!PRList methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitList: self! !!PROrderedList commentStamp: 'lr 5/28/2006 20:53' prior: 0!I am an ordered list. I am typically used for numbered items.!!PROrderedList class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PROrderedList methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitOrderedList: self! !!PRUnorderedList commentStamp: 'lr 5/28/2006 20:53' prior: 0!I am an unordered list. I am typically used for unnumbered lists!!PRUnorderedList class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRUnorderedList methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitUnorderedList: self! !!PRListItem commentStamp: 'lr 6/2/2006 11:26' prior: 0!I am a item within a *PRList*.!!PRListItem class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRListItem methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitListItem: self! !!PRParagraph commentStamp: 'lr 5/28/2006 20:54' prior: 0!I am a paragraph of text.!!PRParagraph class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRParagraph methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitParagraph: self! !!PRPreformatted commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am preformatted text or source code. My children are instances of *PRText*.!!PRPreformatted class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRPreformatted methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitPreformatted: self! !!PRTable commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am a table. My children are instances of *PRTableRow*.!!PRTable class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionColumnCount	^ (MANumberDescription selector: #columnCount label: 'Column Count')		beReadonly;		yourself! !!PRTable class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionRowCount	^ (MANumberDescription selector: #rowCount label: 'Row Count')		beReadonly;		yourself! !!PRTable class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTable methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitTable: self! !!PRTable methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!columnCount	^ self children inject: 0 into: [ :max :row | max max: row columnCount ]! !!PRTable methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!rowCount	^ self children size! !!PRTableCell commentStamp: 'lr 5/28/2006 20:57' prior: 0!I am a cell of a table.!!PRTableCell class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionAlign	^ (MASingleOptionDescription selector: #align label: 'Align')		options: #( nil #left #center #right );		yourself! !!PRTableCell class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTableCell methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!= anObject	^ super = anObject		and: [ self align = anObject align ]! !!PRTableCell methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitTableCell: self! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!align	^ align! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!align: aSymbol	align := aSymbol! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedCenter	self align: #center! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedLeft	self align: #left! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedRight	self align: #right! !!PRTableCell methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!hash	^ super hash bitXor: self align hash! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAligned	^ self align notNil! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedCenter	^ self align = #center! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedLeft	^ self align = #left! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedRight	^ self align = #right! !!PRTableRow commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am a row of a table. My children are instances of *PRTableCell*.!!PRTableRow class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionColumnCount	^ (MANumberDescription selector: #columnCount label: 'Column Count')		beReadonly! !!PRTableRow class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTableRow methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitTableRow: self! !!PRTableRow methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!columnCount	^ self children size! !!PRDocumentItem class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionHasChildren	^ (MABooleanDescription selector: #hasChildren label: 'Has Children')		beReadonly;		yourself! !!PRDocumentItem class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionHasOwner	^ (MABooleanDescription selector: #hasOwner label: 'Has Owner')		beReadonly;		yourself! !!PRDocumentItem class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionOwner	^ (PRStructureDescription selector: #owner label: 'Owner')		beReadonly;		yourself! !!PRDocumentItem class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionText	^ (MAStringDescription selector: #text label: 'Text')		beReadonly;		yourself! !!PRDocumentItem methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ self species = anObject species! !!PRDocumentItem methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitDocumentItem: self! !!PRDocumentItem methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasChildren	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasOwner	^ self owner notNil! !!PRDocumentItem methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ self species hash! !!PRDocumentItem methodsFor: 'accessing' stamp: 'lr 6/2/2006 11:17'!owner	"Answer the object owning the receiver. The default implementation doesn't know about its owner and therefore always returns <code>nil</code>."	^ nil! !!PRDocumentItem methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:30'!owner: anObject! !!PRDocumentItem methodsFor: 'accessing-dynamic' stamp: 'lr 5/28/2006 20:31'!text	"Answer a string representation of the receiver."	^ String new! !!PRHorizontalRule commentStamp: 'lr 5/28/2006 20:57' prior: 0!I am a horizontal rule.!!PRHorizontalRule class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRHorizontalRule methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitHorizontalRule: self! !!PRText commentStamp: 'lr 5/28/2006 20:58' prior: 0!I am a plain text. I am the most important leaf node of the document composite.!!PRText class methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:30'!descriptionText	^ MAStringDescription selector: #text label: 'Text'! !!PRText class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRText class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!with: aString	^ self new		text: aString;		yourself! !!PRText methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!= anObject	^ super = anObject		and: [ self text = anObject text ]! !!PRText methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!accept: aVisitor	aVisitor visitText: self! !!PRText methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!hash	^ super hash bitXor: self text hash! !!PRText methodsFor: 'printing' stamp: 'lr 3/9/2006 11:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' text: '; print: self text! !!PRText methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:57'!text	"Answer the string the receiver is representing."	^ text! !!PRText methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!text: aString	text := aString! !!PRKernel commentStamp: 'lr 6/2/2006 10:33' prior: 0!I am the kernel of Pier. Several instances of myself might exist at the same time, but they all exist independently and don't share any data. I know the root structure and the persistency strategy of the whole data-model. Moreover I prevent any concurrent modifications to the model by providing a global mutex.!!PRKernel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!instanceNamed: aString	^ self instances detect: [ :each | each name = aString ]! !!PRKernel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!instances	^ Instances ifNil: [ Instances := Set new ]! !!PRKernel class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRKernel class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!named: aString	^ self instances add: (self new		name: aString;		yourself)! !!PRKernel class methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!reset	"This method is for development and testing purpose only, you should not call it directly unless you want to loose your wiki-kernels."	(PRCompatibility confirm: 'Are you sure to drop all kernel instances?')		ifTrue: [ Instances := nil ]! !!PRKernel methodsFor: 'conveniance' stamp: 'lr 3/9/2006 11:29'!critical: aBlock	^ self mutex critical: aBlock! !!PRKernel methodsFor: 'configuration' stamp: 'lr 9/25/2006 08:32'!defaultInfo	^ (PRPage named: 'information')		addChild: self defaultInfoIntroduction;		addChild: self defaultInfoSyntax;		addChild: self defaultInfoLicense;		contents: '-*Introduction>introduction*-*Syntax>syntax*-*License>license*';		yourself! !!PRKernel methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:29'!defaultInfoIntroduction	^ (PRPage named: 'introduction')		contents: 'The term <i>Wiki</i> usually means the collaborative software used to create, edit and manage hypertext pages on the web. A Wiki enables the users to author their documents using a simple markup language within their preferred web-browser.Translated from the Hawaiian language <i>Wiki wiki</i> means <i>fast</i> and that is exactly what the collaborative editing process of a WikiWiki Web is all about: Everybody should be able to create and update pages, without the need of user-name and password to login. However there are wiki vandals around that abuse the general public access and make it necessary to protect the content with security mechanism.!!ProblemThere are more than 150 Wiki implementations available and most of them are open source. There are even a few implementations available written in different Smalltalk dialects, so why did we create a new one?All the implementations we had a look at have major flaws in extensibility: they don''t provide a proper object oriented-design that is covered by unit tests. Moreover they all keep the content of the pages within strings, which makes it painful to render and search the wiki. These wikis haven''t been designed for extensibility!!The existing Smalltalk wikis are old and it seems that the developers don''t want to touch their running systems. Both, WikiWorks and SqueakWiki, have some of their domain code within external files, what makes the source hard to understand as it is not possible to use the editing and debugging facilities of the Smalltalk environment.!!SolutionAs stated, all the current wiki implementations have problems with extensibility and the design. Redoing the same mistakes is stupid, therefor we put together the following basic requirements and refinded them with the experience we made with the first version:-<b>Object-Oriented Design:</b> Pier provides a fully object oriented domain model. As an example, the content of the pages is parsed and stored as a tree of different entities representing text, links, tables, lists, etc.-<b>Extensibility:</b> Everything in Pier can be extended: page types, storage mechanism, actions, security mechanism, web-server, etc. Plug-ins can be shared within the community and loaded independently of each other into the system.-<b>Open Source:</b> Pier is released under the MIT license which grants unrestricted rights to copy, modify, and redistribute as long as the original copyright and license terms are retained.-<b>Test Suites:</b> Pier is heavily tested. There are more than 1000 unit tests included with the core of Pier. This makes it easy to change and verify the code and comes in extremely useful when porting Pier to other Smalltalk dialects or when writing extensions.';		yourself! !!PRKernel methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:29'!defaultInfoLicense	^ (PRPage named: 'license')		contents: '!!' , PRDistribution license;		yourself! !!PRKernel methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:29'!defaultInfoSyntax	^ (PRPage named: 'syntax')		contents: '!!ParagraphsAs carriage returns are preserved, simply add a newline to begin a new paragraph.!!HeadersA line starting with <code>!!</code>s becomes a header line.!!Horizontal LineA line starting with <code>_</code> (underline) becomes a horizontal line. This is often used to separate topics.!!ListsUsing lines starting with <code>#</code>s and <code>-</code>s, creates a list:-A block of lines, where each line starts with <code>-</code> is transformed into a bulleted list, where each line is an entry.-A block of lines, where each line starts with <code>#</code> is transformed into an ordered list, where each line is an entry.-Lists can be nested. Thus, a line starting with <code>#-</code> is an element of a bulleted list that is part of an ordered list.!!TablesTo create a table, start off the lines with <code>|</code> and separate the elements with <code>|</code>s. Each new line represents a new row of the table. The contents of cells can be aligned left, centered or aligned right by using <code>|{</code>, <code>||</code> or <code>|}</code> respectively.!!PreformattedTo create a preformatted section, begin each line with <code>=</code>. A preformatted section uses equally spaced text so that spacing is preserved.!!LinksTo create a link, put it between <code>\*</code>s. All links have the following form <code>\*reference\*</code> or <code>\*alias>reference\*</code>, where the reference is depending on the kind of link that is created. The contents of some links, e.g. links pointing to image-files, can be embedded into the current document by using <code>+</code>s: <code>\+reference\+</code>. However not all types of links support embedding and will quietly ignore it.!!!!Internal LinksIf a structure with the given title exists in the wiki (e.g. <code>\*Path\*</code>), a link to that item shows up when the page is saved. In case the path points to an non-existing structure, the user will be offered the possibility to create a new one when clicking on the link. The path can be any absolute or relative  reference within the wiki.!!!!External Links-If the link is an URL (e.g. <code>\*http://www.lukas-renggli.ch\*</code>), a link to the external page shows up.-If the link is an e-mail address (e.g. <code>\*renggli@iam.unibe.ch\*</code>), a link to mail that person shows up.-If the link is an ISBN number (e.g. <code>\*isbn:3446202102\*</code>), a link to the given book shows up.-If the link is an RFC number (e.g. <code>\*rfc:2616\*</code>), a link to the given RFC page shows up.!!HTMLUse any HTML anywhere you want. Some useful HTML tags are:-To make something <b>bold</b>, surround it by &lt;b&gt; and &lt;/b&gt;.-To make something <i>italic</i>, surround it by &lt;i&gt; and &lt;/i&gt;.-To make something <u>underlined</u>, surround it by &lt;u&gt; and &lt;/u&gt;.-To make text appear in a different color (like <font color="green">green</font>, <font color="red">red</font>, <font color="blue">blue </font>, <font color="grey">grey</font>, <font color="yellow">yellow</font>, or <font color="orange">orange</font>), use &lt;font color="<i>a color</i>"&gt; <i> some text </i> &lt;/font&gt;.';		yourself! !!PRKernel methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:29'!defaultName	^ PRDistribution package! !!PRKernel methodsFor: 'configuration' stamp: 'lr 9/25/2006 08:33'!defaultRoot	^ (PRPage named: 'pier')		addChild: self defaultInfo;		contents: 'Welcome to Pier (formerly called SmallWiki 2), the next generation of a fully extensible content management system implemented in Smalltalk. To read additional information, please consult the *information page>information*.';		yourself! !!PRKernel methodsFor: 'accessing-readonly' stamp: 'lr 5/29/2006 08:34'!mutex	"Return a mutex (an object that understands #critical:) to ensure that only one process is modifying the model at once. This is needed to make certain that the model remains in a consistent state. All write access must go through this mutex."	^ mutex ifNil: [ mutex := Monitor new ]! !!PRKernel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name	"Answer the name of the kernel."	^ name ifNil: [ name := self defaultName ]! !!PRKernel methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:10'!name: aString	name := aString! !!PRKernel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!persistency	"Answer the persistency strategy of the receiver."	^ persistency ifNil: [ persistency := PRNullPersistency new ]! !!PRKernel methodsFor: 'accessing' stamp: 'lr 9/27/2006 14:11'!persistency: aPersistency	persistency ifNotNil: [ persistency setKernel: nil ].	persistency := aPersistency setKernel: self! !!PRKernel methodsFor: 'printing' stamp: 'lr 3/9/2006 11:29'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!PRKernel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!root	"Answer the root structure of the kernel."	^ root ifNil: [ root := self defaultRoot ]! !!PRKernel methodsFor: 'accessing' stamp: 'lr 5/28/2006 17:10'!root: aStructure	root := aStructure! !!PRObject class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ true! !!PRObject class methodsFor: 'instance creation' stamp: 'lr 5/5/2006 19:19'!new	"Create a new instance of this class and checks if it isn't abstract."	self isAbstract ifTrue: [ self error: self name , ' is abstract.' ].	^ self basicNew initialize! !!PRObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:30'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!PRObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:30'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!PRObject methodsFor: 'visiting' stamp: 'lr 5/28/2006 17:04'!accept: aVisitor	"Dispatch to <code>aVisitor</code> depending on the receiver."! !!PRObject methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!errorPropertyNotFound: aSelector	self error: 'Property ' , aSelector , ' not found.'! !!PRObject methodsFor: 'testing' stamp: 'lr 5/28/2006 17:02'!hasProperty: aKey	"Test if the property <code>aKey</code> is defined within the receiver."	^ self properties includesKey: aKey! !!PRObject methodsFor: 'initialization' stamp: 'lr 5/5/2006 19:20'!initialize! !!PRObject methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	properties := properties copy! !!PRObject methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopyTo: anObject! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!propertyAt: aKey 	"Answer the value of the property <code>aKey</code>, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property <code>aKey</code>, or the result of <code>aBlock</code> if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property <code>aKey</code>, or if the property doesn't exist adds and answers the result of evaluating <code>aBlock</code>."	^ self properties at: aKey ifAbsentPut: aBlock! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!propertyAt: aKey put: aValue	"Adds or replaces the property <code>aKey</code> with <code>aValue</code>."	^ self properties at: aKey put: aValue! !!PRFilePersistency class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!on: aDirectory	^ self new		setDirectory: aDirectory;		yourself! !!PRFilePersistency methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!directory	^ directory ifNil: [ directory := FileDirectory default ]! !!PRFilePersistency methodsFor: 'enummerating' stamp: 'rjl 5/11/2006 22:35'!do: aBlock 	"There's a bug in deserialization that leaves commands with no fields or context, this causes an error which despite the ensure below, leaves the filestream open preventing any further use of that file, at which point fileNamed returns nil for all future calls. I'm returning self to prevent an error, the gc does eventually close the file and thigns start working again.  I think the bug is actually in the MABinaryWriter when it serializes the command"	| fileStream |	fileStream := self directory fileNamed: self logFilename.	fileStream ifNil: [^self].		[[fileStream atEnd] whileFalse: 			[aBlock value: ((MABinaryReader read: fileStream)						setKernel: self kernel;						yourself)]] 			ensure: [fileStream close]! !!PRFilePersistency methodsFor: 'actions' stamp: 'rjl 5/11/2006 22:47'!log: aContext	| fileStream referenceStream |	fileStream := self directory fileNamed: self logFilename.	[ referenceStream := MACompatibility referenceStream: fileStream setToEnd.		[ MABinaryWriter write: aContext description: aContext description to: referenceStream ]			ensure: [ referenceStream close ] ]		ensure: [ fileStream close ]! !!PRFilePersistency methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!logFilename	^ 'logs.obj'! !!PRFilePersistency methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setDirectory: aDirectory	directory := aDirectory! !!PRFilePersistency methodsFor: 'actions' stamp: 'rjl 5/11/2006 22:47'!snapshot	| fileStream referenceStream |	fileStream := self directory fileNamed: self snapshotFilename.	[ referenceStream := MACompatibility referenceStream: fileStream setToEnd.		[ referenceStream nextPut: self kernel ]			ensure: [ referenceStream close ] ]		ensure: [ fileStream close ]! !!PRFilePersistency methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!snapshotFilename	^ 'snapshots.obj'! !!PRImagePersistency methodsFor: 'enumerating' stamp: 'lr 9/27/2006 14:15'!do: aBlock 	"There is no history for now."! !!PRImagePersistency methodsFor: 'accessing' stamp: 'lr 9/29/2006 08:39'!duration	^ duration! !!PRImagePersistency methodsFor: 'accessing' stamp: 'lr 9/29/2006 08:39'!duration: aDuration	duration := aDuration! !!PRImagePersistency methodsFor: 'initialization' stamp: 'lr 9/29/2006 08:39'!initialize	super initialize.	duration := 1 hour! !!PRImagePersistency methodsFor: 'actions' stamp: 'lr 10/16/2006 11:32'!log: aContext	"Don't do any logging for now, just ensure that the snapshot process is properly triggered."	(process isNil or: [ process isTerminated ])		ifTrue: [ self start ]! !!PRImagePersistency methodsFor: 'private' stamp: 'lr 10/16/2006 11:33'!process	(Delay forDuration: self duration)		wait.	process := nil.	self snapshot! !!PRImagePersistency methodsFor: 'initialization' stamp: 'lr 10/16/2006 11:25'!setKernel: aKernel	super setKernel: aKernel.	self stop! !!PRImagePersistency methodsFor: 'actions' stamp: 'lr 10/16/2006 11:27'!snapshot	"Save the whole image for now."	Smalltalk at: #UnixProcess ifPresent: [ :class | 		(class thisOSProcess pid notNil 			and: [ class respondsTo: #saveImageInBackgroundNicely ])				ifTrue: [ ^ class saveImageInBackgroundNicely ] ].	SmalltalkImage current snapshot: true andQuit: false! !!PRImagePersistency methodsFor: 'actions-process' stamp: 'lr 10/16/2006 11:33'!start	process := [ self process ] 		forkAt: 10 named: 'pier'! !!PRImagePersistency methodsFor: 'actions-process' stamp: 'lr 9/27/2006 14:13'!stop	process ifNotNil: [ process terminate ].	process := nil! !!PRNullPersistency methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!do: aBlock! !!PRNullPersistency methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!log: aContext! !!PRNullPersistency methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!snapshot! !!PRPersistency methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!do: aBlock	"Evaluates aBlock in chronological order for every item in the history of the kernel."	self subclassResponsibility! !!PRPersistency methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!do: aBlock for: aStructure	"Evaluates aBlock in chronological order for every item in the history of aStructure. Subclasses might want to override the default implementation for efficiency."	self do: [ :each |		each structure = aStructure			ifTrue: [ aBlock value: each ] ]! !!PRPersistency methodsFor: 'conveniance' stamp: 'lr 3/9/2006 11:29'!history	^ Array streamContents: [ :stream |		self do: [ :each |			stream nextPut: each ] ]! !!PRPersistency methodsFor: 'conveniance' stamp: 'lr 3/9/2006 11:29'!historyFor: aStructure	^ Array streamContents: [ :stream |		self			do: [ :each | stream nextPut: each ]			for: aStructure ]! !!PRPersistency methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!kernel	^ kernel! !!PRPersistency methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!log: aContext	"Log a aContext in the history of the kernel."	self subclassResponsibility! !!PRPersistency methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!reverseDo: aBlock	"Evaluates aBlock in inverse chronological order for every item in the history of aStructure. Subclasses might want to override the default implementation for efficiency."	self history reverseDo: aBlock! !!PRPersistency methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:29'!reverseDo: aBlock for: aStructure	"Evaluates aBlock in inverse chronological order for every item in the history of aStructure. Subclasses might want to override the default implementation for efficiency."	(self historyFor: aStructure)		reverseDo: aBlock! !!PRPersistency methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setKernel: aKernel	kernel := aKernel! !!PRPersistency methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!snapshot	"Create a snapshot of the kernel."	self subclassResponsibility! !!PRVisitor commentStamp: 'lr 6/2/2006 11:55' prior: 0!I am an abstract visitor. I provide a default implementation of all visit messages that does not descend automatically into children of the visited graph. Subclasses should override all my messages in appropriate ways to visit the nodes they need.!!PRDocumentWriter commentStamp: 'lr 6/1/2006 21:17' prior: 0!I am a visitor being able to transform a composite of document-items back into the original Wiki string.!!Example=| document |=document := PRDocumentParser parse: '+Hello+ *World*'.=string := PRDocumentWriter write: document.=string inspect.!!PRDocumentWriter class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!write: anObject	^ self new write: anObject! !!PRDocumentWriter class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!write: anObject to: aStream	^ self new write: anObject to: aStream! !!PRDocumentWriter methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:29'!contents	^ stream contents! !!PRDocumentWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!defaultStream	^ String new writeStream! !!PRDocumentWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!nest: aCharacter do: aBlock	nesting := nesting copyWith: aCharacter.	aBlock ensure: [ nesting := nesting allButLast ]! !!PRDocumentWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!newLine	stream isEmpty		ifFalse: [ stream nextPut: Character cr ].	newline := true! !!PRDocumentWriter methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:29'!nextPut: aCharacter	stream nextPut: aCharacter.	newline := false! !!PRDocumentWriter methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:29'!nextPutAll: aString	stream nextPutAll: aString.	newline := false! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!start: anObject	newline := true.	nesting := String new.	super start: anObject! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!stream	^ stream! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!stream: aStream	stream := aStream! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitAnchor: anObject	self newLine; nextPut: $@; nextPutAll: anObject name! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitHeader: anObject	self newLine; nextPutAll: (String new: anObject level withAll: $!!).	super visitHeader: anObject! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitHorizontalRule: anObject	self newLine; nextPut: $_! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitLink: anObject	anObject isEmbedded		ifTrue: [ self nextPut: $+ ]		ifFalse: [ self nextPut: $* ].	anObject hasAlias ifTrue: [		super visitLink: anObject.		self nextPut: $> ].	self nextPutAll: anObject reference.	anObject hasAnchor ifTrue: [		self nextPut: $@.		self nextPutAll: anObject anchor ].	anObject isEmbedded		ifTrue: [ self nextPut: $+ ]		ifFalse: [ self nextPut: $* ]! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitListItem: anObject	newline ifFalse: [ self newLine ].	self nextPutAll: nesting.	super visitListItem: anObject! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitOrderedList: anObject	self newLine.	self nest: $# do: [ super visitOrderedList: anObject ]! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitParagraph: anObject	self newLine.	super visitParagraph: anObject! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitPreformatted: anObject	anObject children		do: [ :each | self newLine; nextPut: $=; nextPutAll: each text ]! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitTableCell: anObject	self nextPut: $|.	anObject isAligned ifTrue: [		anObject isAlignedLeft ifTrue: [ self nextPut: ${ ].		anObject isAlignedCenter ifTrue: [ self nextPut: $| ].		anObject isAlignedRight ifTrue: [ self nextPut: $} ] ].	super visitTableCell: anObject! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitTableRow: anObject	self newLine.	super visitTableRow: anObject! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 5/29/2006 09:31'!visitText: anObject	"Write out <code>anObject</code>'s text to the receivers output-stream and escape <code>$*</code> everywhere within. Also take care of the character escaping with <code>$=</code>, <code>$|</code>, <code>$!!</code>, <code>$#</code> and <code>$-</code> at the beginning of a line."	anObject text do: [ :each |		(each = $* or: each = $+ or: [ newline and: [ '=@|!!#-' includes: each ] ])			ifTrue: [ self nextPut: $\ ].		self nextPut: each ]! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitUnorderedList: anObject	self newLine.	self nest: $- do: [ super visitUnorderedList: anObject ]! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!write: anObject	^ self write: anObject to: self defaultStream! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!write: anObject to: aStream	^ self stream: aStream; start: anObject; contents! !!PRPath methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:29'!parent	^ '..'! !!PRPath methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:29'!separator	^ $/! !!PRPath methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!stream	^ stream! !!PRPath methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!stream: aStream	stream := aStream! !!PRPathLookup commentStamp: 'lr 5/28/2006 21:19' prior: 0!I am a visitor used to look up a given path. I am able to lookup absolute and relative paths, following the syntax of unix operating systems.!!Example=(PRPathLookup=	start: aStructure=	path: '/Information/Copyright/..')=		inspect!!PRIncompletePathLookup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!start: aStructure path: aString	| visitor |	visitor := self new		stream: aString readStream;		yourself.	^ Association		key: (visitor lookup: aStructure)		value: visitor pathElement! !!PRIncompletePathLookup methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!childNotFound: aStructure	self readNext; escape: aStructure! !!PRPathLookup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!start: aStructure path: aString	^ self new		stream: aString readStream;		lookup: aStructure! !!PRPathLookup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!start: aStructure path: aString onError: aBlock	^ [ self start: aStructure path: aString ]		on: Error		do: [ :error | aBlock value ]! !!PRPathLookup methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!childNotFound: aStructure	self error: 'Invalid path ' , self stream contents! !!PRPathLookup methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!lookup: aStructure	^ self withEscaper: [		self stream peek = self separator			ifTrue: [ self lookupRoot: aStructure ]			ifFalse: [ self lookupStart: aStructure ].		self childNotFound: aStructure ]! !!PRPathLookup methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!lookupRoot: aStructure	self stream next.	self visit: aStructure root! !!PRPathLookup methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!lookupStart: aStructure	self visit: aStructure! !!PRPathLookup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!pathElement	^ pathElement! !!PRPathLookup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!pathElement: aString	pathElement := aString! !!PRPathLookup methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!readNext	^ self stream upTo: self separator! !!PRPathLookup methodsFor: 'visiting-decorations' stamp: 'lr 5/29/2006 08:35'!visitChildren: anObject	"This method does the lookup of the next structure by checking for a child with that name, since this value is hashed it can be done efficiently. If the lookup by name fails, it tries to match the title by iterating through the children. If this fails as well, the message <code>#childNotFound:</code> is sent."	anObject		at: self pathElement		ifPresent: [ :value | ^ self visit: value ].	anObject do: [ :each |		self pathElement = each title			ifTrue: [ ^ self visit: each ] ].	self childNotFound: anObject decorated! !!PRPathLookup methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitStructure: aStructure	self stream atEnd		ifTrue: [ self escape: aStructure ].	self pathElement: self readNext.	self pathElement = self parent ifTrue: [		self visit: (aStructure isRoot			ifTrue: [ aStructure ]			ifFalse: [ aStructure parent ]) ].	aStructure hasChildren		ifFalse: [ self childNotFound: aStructure ]! !!PRPathReference commentStamp: 'lr 5/28/2006 21:19' prior: 0!I am a visitor used to print a short path from a structure to another one.!!Example=(PRPathReference=	from: aFirstStructure=	to: aSecondStructure)=		inspect!!PRPathReference class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!from: aFirstStructure to: aSecondStructure	^ self new		setSource: aFirstStructure;		setTarget: aSecondStructure;		reference! !!PRPathReference class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!to: aStructure	^ self from: aStructure root to: aStructure! !!PRPathReference methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	stream := WriteStream on: String new! !!PRPathReference methodsFor: 'actions' stamp: 'lr 3/9/2006 11:29'!reference	self source isRoot ifTrue: [ self writeSeparator ].	self source = self target ifTrue: [ ^ self stream contents ].	self sourceParents removeFirst = self targetParents removeFirst		ifFalse: [ self error: 'Unable to reference external wiki.' ].	[ self sourceParents notEmpty		and: [ self targetParents notEmpty		and: [ self sourceParents first = self targetParents first ] ] ] whileTrue: [			self sourceParents removeFirst.			self targetParents removeFirst ].	self sourceParents reverseDo: [ :each |		self writeParent; writeSeparator ].	self targetParents do: [ :each |		self visit: each; writeSeparator ].	^ self stream skip: -1; contents! !!PRPathReference methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setSource: aStructure	source := aStructure! !!PRPathReference methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:29'!setTarget: aStructure	target := aStructure! !!PRPathReference methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!source	^ source! !!PRPathReference methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!sourceParents	^ sourceParents ifNil: [ sourceParents := self source parents ]! !!PRPathReference methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!target	^ target! !!PRPathReference methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!targetParents	^ targetParents ifNil: [ targetParents := self target parents ]! !!PRPathReference methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitStructure: aStructure	stream nextPutAll: aStructure name! !!PRPathReference methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!writeParent	stream nextPutAll: self parent! !!PRPathReference methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!writeSeparator	stream nextPut: self separator! !!PRChildrenVisitor class methodsFor: 'instance creation' stamp: 'lr 4/10/2006 15:11'!on: aStructure	^ self new		setStructure: aStructure;		yourself! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!all	"Tell the receiver to visit structures recursively."	all := true! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!all: aBoolean	all := aBoolean! !!PRChildrenVisitor methodsFor: 'visiting' stamp: 'lr 8/24/2006 22:42'!contents	"Answer a collection of all elements that have been visited."	^ Array streamContents: [ :stream |		self do: [ :each | stream nextPut: each ] ]! !!PRChildrenVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!do: aBlock	"Evaluate aBlock for every structure visited by the receiver."	self block: aBlock; start: structure! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!hidden	"Tell the receiver to visit hidden structures."	hidden := true! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!hidden: aBoolean	hidden := aBoolean! !!PRChildrenVisitor methodsFor: 'initialization' stamp: 'lr 8/24/2006 22:45'!initialize	super initialize.	with := all := hidden := false.	sortBlock := [ :a :b | a < b ]! !!PRChildrenVisitor methodsFor: 'initialization' stamp: 'lr 4/10/2006 15:11'!setStructure: aStructure	structure := aStructure! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 8/24/2006 22:42'!sortBlock: aBlock	sortBlock := aBlock! !!PRChildrenVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!start: anObject	self withEscaper: [ super start: anObject ]! !!PRChildrenVisitor methodsFor: 'copying' stamp: 'lr 4/10/2006 15:11'!structure: aStructure	^ self copy setStructure: aStructure! !!PRChildrenVisitor methodsFor: 'visiting-decoration' stamp: 'lr 8/24/2006 22:44'!visitChildren: anObject	(all or: [ structure == anObject decorated ])		ifFalse: [ ^ self ].	anObject		do: [ :each |			self withEscaper: [				self visit: each ] ]		sorted: sortBlock! !!PRChildrenVisitor methodsFor: 'visiting-decoration' stamp: 'lr 3/9/2006 11:29'!visitHider: anObject	hidden ifFalse: [ self escape: anObject ]! !!PRChildrenVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitStructure: aStructure	(with or: [ structure ~~ aStructure ])		ifTrue: [ block value: aStructure ]! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!with	"Tell the receiver to visit the start structure as well."	with := true! !!PRChildrenVisitor methodsFor: 'setting' stamp: 'lr 3/9/2006 11:29'!with: aBoolean	with := aBoolean! !!PRFullTextSearch commentStamp: 'lr 5/28/2006 21:26' prior: 0!I am a pluggable visitor to quickly look for matching text in a subtree of structures.!!ExampleThe following example opens an inspector on all structures with the text <code>foo</code>:=(PRFullTextSearch =	from: aStructure=	find: 'foo'=	caseSensitive: false)=		inspect!!PRFullTextSearch class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!from: aStructure find: aString caseSensitive: aBoolean	^ Array streamContents: [ :stream |		self			from: aStructure			find: aString caseSensitive: aBoolean			do: [ :each | stream nextPut: each ] ]! !!PRFullTextSearch class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!from: aStructure find: aString caseSensitive: aBoolean do: aBlock	^ self new		block: aBlock;		searchText: aString;		caseSensitive: aBoolean;		start: aStructure;		yourself! !!PRFullTextSearch methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!caseSensitive	^ caseSensitive! !!PRFullTextSearch methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!caseSensitive: aBoolean	caseSensitive := aBoolean! !!PRFullTextSearch methodsFor: 'private' stamp: 'lr 3/9/2006 11:29'!check: aString in: aStructure	(lastMatch ~= aStructure and: [ aString includesSubstring: self searchText caseSensitive: self caseSensitive ])		ifTrue: [ self block value: (lastMatch := aStructure) ]! !!PRFullTextSearch methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!searchText	^ searchText! !!PRFullTextSearch methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!searchText: aString	searchText := aString! !!PRFullTextSearch methodsFor: 'visiting-decoration' stamp: 'lr 3/9/2006 11:29'!visitChildren: anObject	self visitAll: anObject children! !!PRFullTextSearch methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitPage: aStructure	super visitPage: aStructure.	self check: aStructure document text in: aStructure! !!PRFullTextSearch methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitStructure: aStructure! !!PRIncomingReferences commentStamp: 'lr 5/28/2006 21:24' prior: 0!I am a pluggable visitor to detect incoming references.!!ExampleThe following example opens inspectors on all instances of *PRInternalLink* that point <code>aStructure</code>:=PRIncomingReferences =	from: aRootStructure=	to: aStructure=	do: [ :each | each inspect ]!!PRIncomingReferences class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!from: aStructure to: aCollectionOrStructure do: aBlock	"Evaluates aBlock for every internal-link referencing on of the structures in aCollection starting at aStructure."	^ self new		block: aBlock;		structures: (aCollectionOrStructure isCollection			ifTrue: [ aCollectionOrStructure asSet ]			ifFalse: [ Set with: aCollectionOrStructure ]);		start: aStructure;		yourself! !!PRIncomingReferences methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!structures	^ structures! !!PRIncomingReferences methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!structures: aCollection	structures := aCollection! !!PRIncomingReferences methodsFor: 'visiting-decoration' stamp: 'lr 3/9/2006 11:29'!visitChildren: anObject	self visitAll: anObject children! !!PRIncomingReferences methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitInternalLink: anObject	(self structures includes: anObject target)		ifTrue: [ self block value: anObject ]! !!PRIncomingReferences methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitPage: anObject	super visitPage: anObject.	self visit: anObject document! !!PROutgoingReferences commentStamp: 'lr 5/28/2006 21:21' prior: 0!I am a pluggable visitor visiting and eventually following outgoing references. To do so I visit all the links of the page and evaluate my pluggable block for each of them, if the block answers <code>true</code> I follow the link and continue visiting the references of the target structure. I take care not to run into infinite recursion, so no structure will be visited more than once.!!ExampleThe following example opens an inspector on all the broken references that are seen when displaying <code>aStructure</code>:=PROutgoingReferences =	start: aStructure=	do: [ :each |=		each isBroken=			ifTrue: [ each inspect ].=		each isEmbedded ].!!PROutgoingReferences class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!start: aStructure do: aBlock	^ self new		block: aBlock;		start: aStructure! !!PROutgoingReferences methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:29'!start: anObject	seen := Set new.	super start: anObject! !!PROutgoingReferences methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:29'!visitInternalLink: anObject	((block value: anObject) not		or: [ anObject target isNil		or: [ seen includes: anObject target ] ])			ifFalse: [ self visit: anObject target ]! !!PROutgoingReferences methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitPage: anObject	super visitPage: anObject.	self visit: anObject document! !!PROutgoingReferences methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:29'!visitStructure: aStructure	seen add: aStructure! !!PRPluggableVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!block	^ block! !!PRPluggableVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!block: aBlock	block := aBlock! !!PRDeepRenderer methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!doesRemember: anObject	visited size to: 1 by: -1 do: [ :index |		(visited at: index) = anObject			ifTrue: [ ^ true ] ].	^ false! !!PRDeepRenderer methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!remember: anObject while: aBlock	visited addLast: anObject.	aBlock ensure: [ visited removeLast ]! !!PRDeepRenderer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!start: anObject	visited := OrderedCollection new.	super start: anObject! !!PRDeepRenderer methodsFor: 'visiting-links' stamp: 'lr 3/9/2006 11:30'!visitInternalLink: anObject	anObject isBroken		ifTrue: [ self visitInternalLinkBroken: anObject ]		ifFalse: [			anObject isEmbedded				ifFalse: [ self visitInternalLinkGoto: anObject ]				ifTrue: [					(self doesRemember: anObject target)						ifTrue: [ self visitInternalLinkGoto: anObject ]						ifFalse: [							self								remember: anObject target								while: [ self visitInternalLinkEmbed: anObject ] ] ] ]! !!PRDeepRenderer methodsFor: 'visiting-links' stamp: 'lr 3/9/2006 11:30'!visitInternalLinkBroken: anObject	self visitLink: anObject! !!PRDeepRenderer methodsFor: 'visiting-links' stamp: 'lr 3/9/2006 11:30'!visitInternalLinkEmbed: anObject	self visit: anObject target! !!PRDeepRenderer methodsFor: 'visiting-links' stamp: 'lr 3/9/2006 11:30'!visitInternalLinkGoto: anObject	self visitLink: anObject! !!PRDeepRenderer methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitStructure: anObject	self visit: anObject document! !!PRTocRenderer methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:30'!enable: aBoolean while: aBlock	| old |	old := enabled. enabled := aBoolean.	aBlock ensure: [ enabled := old ]! !!PRTocRenderer methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:30'!ifEnabledDo: aBlock	enabled ifTrue: [ aBlock value ]! !!PRTocRenderer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!level: anInteger	| value |	value := anInteger min: 6 max: 1.	value < current ifTrue: [		anInteger + 1 to: current do: [ :index |			counter at: index put: 0 ] ].	counter		at: (current := value)		put: (counter at: value) + 1! !!PRTocRenderer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!start: anObject	enabled := false. current := 1.	counter := Array new: 6 withAll: 0.	super start: anObject! !!PRTocRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitHeader: anObject	self level: anObject level.	(counter first: current)		do: [ :each | html render: each; text: '.' ].	html space.	html anchor		url: '#' , anObject hash asString;		with: [			self				enable: true				while: [ super visitHeader: anObject ] ].	html break! !!PRTocRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitText: anObject	self ifEnabledDo: [ html text: anObject text ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitAnchor: anObject	html anchor name: anObject name! !!PRViewRenderer methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitComponent: anObject	html render: (self context componentAt: anObject)! !!PRViewRenderer methodsFor: 'visiting-links' stamp: 'lr 6/30/2006 00:04'!visitExternalLink: anObject	html anchor		class: 'external';		url: anObject url;		with: [ self visitLink: anObject ]! !!PRViewRenderer methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitFile: anObject	| url |	anObject isText		ifTrue: [ html preformatted: anObject contents ]		ifFalse: [			url := html context				urlForDocument: anObject contents				mimeType: anObject mimetype				fileName: anObject filename.			anObject file isImage				ifTrue: [ html image url: url; altText: anObject title ]				ifFalse: [					anObject file isAudio | anObject file isVideo						ifTrue: [ (html tag: 'embed') attributeAt: 'url' put: url; with: anObject title ]						ifFalse: [ html anchor url: url; with: anObject title ] ] ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitHeader: anObject	html heading		level: (6 min: anObject level + 1);		with: [			html anchor name: anObject hash.			super visitHeader: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitHorizontalRule: anObject	html horizontalRule! !!PRViewRenderer methodsFor: 'visiting-links' stamp: 'lr 9/6/2006 13:13'!visitInternalLinkBroken: anObject	| lookup context |	lookup := PRIncompletePathLookup		start: self context structure		path: anObject reference.	context := self context		structure: lookup key		command: PRAddCommand new.	context command 		name: lookup value;		link: anObject.	html anchor		class: 'broken';		goto: context;		with: [ self visitLink: anObject ]! !!PRViewRenderer methodsFor: 'visiting-links' stamp: 'lr 6/30/2006 00:05'!visitInternalLinkGoto: anObject	html anchor		class: 'internal';		goto: (self context structure: anObject target);		with: [ self visitLink: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 9/6/2006 13:09'!visitLink: anObject	anObject hasAlias		ifTrue: [ super visitLink: anObject ]		ifFalse: [ html render: anObject reference ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitListItem: anObject	html listItem with: [ super visitListItem: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitOrderedList: anObject	html orderedList with: [ super visitOrderedList: anObject ]! !!PRViewRenderer methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitPage: anObject	self		remember: anObject		while: [ super visitPage: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 4/10/2006 09:43'!visitParagraph: anObject	html div class: 'paragraph'; with: [ super visitParagraph: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitPreformatted: anObject	html preformatted: [		self			visitAll: anObject children			separatedBy: [ html text: Character cr ] ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTable: anObject	html table with: [ super visitTable: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTableCell: anObject	html tableData		style: (String streamContents: [ :stream |			anObject align isNil ifFalse: [				stream					nextPutAll: 'text-align: ';					nextPutAll: anObject align ] ]);		with: [ super visitTableCell: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTableRow: anObject	html tableRow with: [ super visitTableRow: anObject ]! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitText: anObject	html html: anObject text! !!PRViewRenderer methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitUnorderedList: anObject	html unorderedList with: [ super visitUnorderedList: anObject ]! !!PRRenderer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!component	^ component! !!PRRenderer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!component: aComponent	component := aComponent! !!PRRenderer methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!context	^ PRCurrentContext value! !!PRRenderer methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:30'!context: aContext	PRCurrentContext value: aContext! !!PRRenderer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!continue: anObject in: aComponent on: aRenderer	| oldComponent oldRenderer |	oldComponent := self component.	oldRenderer := self renderer.	self component: aComponent.	self renderer: aRenderer.	[ self visit: anObject ] ensure: [		self component: oldComponent.		self renderer: oldRenderer ]! !!PRRenderer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!renderer	^ html! !!PRRenderer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!renderer: aRenderer	html := aRenderer! !!PRRenderer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!start: anObject in: aComponent on: aRenderer	self component: aComponent.	self renderer: aRenderer.	self start: anObject! !!PRVisitor class methodsFor: 'building' stamp: 'lr 3/9/2006 11:30'!buildVisitorHierarchyForClass: aClass selector: aSelectorBlock classified: aClassifiedBlock	" self buildVisitorHierarchyForClass: PRObject selector: [ :class | 'visit' , (class name allButFirst: 3) , ':' ] classified: [ :class | 'visiting-' , (class category copyAfterLast: $-) asLowercase ] "	aClass withAllSubclassesDo: [ :class |		(class category beginsWith: 'Pier-Model') ifTrue: [			(self selectors includes: (aSelectorBlock value: class)) ifFalse: [				self					compile: (String streamContents: [ :stream |						stream nextPutAll: (aSelectorBlock value: class); nextPutAll: ' anObject'; cr.						class = aClass ifFalse: [							stream tab; nextPutAll: 'self '; nextPutAll: (aSelectorBlock value: class superclass); nextPutAll: ' anObject.' ] ])					classified: (aClassifiedBlock value: class) ].			class				compile: (String streamContents: [ :stream |					stream nextPutAll: 'accept: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: (aSelectorBlock value: class); nextPutAll: ' self.' ])				classified: #visiting ] ]! !!PRVisitor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!visit: anObject	^ self new		start: anObject;		yourself! !!PRVisitor methodsFor: 'escaping' stamp: 'lr 3/9/2006 11:30'!escape: anObject	escaper value: anObject! !!PRVisitor methodsFor: 'escaping' stamp: 'lr 3/9/2006 11:30'!hasEscaper	^ escaper notNil! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!start: anObject	self visit: anObject! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visit: anObject	anObject acceptDecorated: self! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visitAll: aCollection	aCollection do: [ :each | self visit: each ]! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visitAll: aCollection separatedBy: aBlock	aCollection do: [ :each | self visit: each ] separatedBy: aBlock! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitAnchor: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitChildren: anObject	self visitDecoration: anObject! !!PRVisitor methodsFor: '*pier-seaside-visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitComponent: anObject	self visitStructure: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 5/28/2006 17:03'!visitDecorated: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 5/28/2006 17:03'!visitDecoration: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitDocument: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitDocumentGroup: anObject	self visitDocumentItem: anObject.	self visitAll: anObject children! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitExternalLink: anObject	self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitFile: anObject	self visitStructure: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitHeader: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitHider: anObject	self visitDecoration: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitHorizontalRule: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitInternalLink: anObject	self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitIsbnLink: anObject	self visitExternalLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitLink: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitList: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitListItem: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitMailLink: anObject	self visitExternalLink: anObject! !!PRVisitor methodsFor: 'visiting-core' stamp: 'lr 3/9/2006 11:30'!visitObject: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitOrderedList: anObject	self visitList: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitPage: anObject	self visitStructure: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitParagraph: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitPreformatted: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitRfcLink: anObject	self visitExternalLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitSmiley: anObject	self visitText: anObject! !!PRVisitor methodsFor: 'visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitStructure: anObject	self visitDecorated: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTable: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTableCell: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitTableRow: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitText: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/9/2006 11:30'!visitUnorderedList: anObject	self visitList: anObject! !!PRVisitor methodsFor: 'escaping' stamp: 'lr 3/9/2006 11:30'!withEscaper: aBlock	| old |	old := escaper.	escaper := [ :value | ^ value ].	^ aBlock ensure: [ escaper := old ]! !!WAPresenter methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!context	^ PRCurrentContext value! !!WAPresenter methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!context: aContext	PRCurrentContext value: aContext! !!WAPresenter methodsFor: '*pier-seaside-events' stamp: 'lr 3/9/2006 11:30'!onChangeContext: aContext	"Inform components about a new context that will be used from now on."! !!PRPierConfiguration methodsFor: 'attributes' stamp: 'lr 3/9/2006 11:30'!attributeKernel	^ (WAListAttribute key: #kernel group: #pier)		options: PRKernel instances;		yourself! !!PRPierConfiguration methodsFor: 'attributes' stamp: 'lr 3/9/2006 11:30'!attributeScriptaculous	^ WABooleanAttribute key: #scriptaculous group: #pier! !!PRPierConfiguration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!attributes	^ (self class selectors		select: [ :each | each ~= #attributes			and: [ each beginsWith: #attribute ] ])		collect: [ :each | self perform: each ]! !!PRPierConfiguration methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!scriptaculous	^ true! !!MAStringWriter methodsFor: '*pier-model-visiting-description' stamp: 'lr 3/9/2006 11:29'!visitStructureDescription: aDescription	stream nextPutAll: (PRPathReference to: self object)! !!WAAnchorTag methodsFor: '*pier-seaside-linking' stamp: 'lr 4/19/2006 07:40'!goto: aContext	"Initialize the receiver to properly activate aContext when being clicked. This includes a callback and a human-readable and bookmarkable url."	| actionUrl |	aContext isValid		ifFalse: [ ^ self class: 'protected'; url: '#' ].	aContext command isConfirmed		ifTrue: [ self onClick: 'return confirm(''Are you sure to perform the selected action: ' , aContext command name , '?'')' ].	actionUrl := canvas context actionUrl withParameter: (canvas callbacks		registerActionCallback: [ PRCurrentContext value: aContext ]).	self url: (actionUrl adaptToContext: aContext) displayString! !!WACounter class methodsFor: '*pier-seaside-accessing-description' stamp: 'lr 3/9/2006 11:30'!descriptionCount	^ (MANumberDescription selector: #count label: 'Count' priority: 200)		beRequired;		beInteger;		yourself! !!WACounter methodsFor: '*pier-seaside-accessing' stamp: 'lr 3/9/2006 11:30'!count: anInteger	count := anInteger! !!UndefinedObject methodsFor: '*pier-model' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	"do nothing"! !!PRCurrentContext commentStamp: 'lr 5/28/2006 17:06' prior: 0!I am a dynamic variable. I answer the current context when being raised.!!PRCurrentContext class methodsFor: 'utilities' stamp: 'lr 3/9/2006 11:30'!use: anObject during: aBlock	^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!PRCurrentContext class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!value	"This is the read accessor of the current context."	| result |	^ (result := self signal) notNil		ifTrue: [ result context ]! !!PRCurrentContext class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!value: aContext	"This is the write accessor of the current context."	self signal context: aContext! !!PRDocumentParser commentStamp: 'lr 6/1/2006 21:17' prior: 0!I am a parser that builds a composite of document-items from a Wiki string. I don't raise errors for invalid input, but instead try to build a parse tree that is as close to the source as possible. I am automatically generated from the Smalltalk Compiler Compiler (SmaCC), do not edit my code manually.!!Example=(PRDocumentParser parse: '!!Foo bar')=	explore!!PRDocumentParser class methodsFor: 'generated-comments' stamp: 'lr 6/5/2006 11:01'!parserDefinitionComment	"# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Document	: DocumentItems { #createDocument };DocumentItems	: #nothing	| DocumentItem	| DocumentItems <newline> DocumentItem	| DocumentItems BlankLine DocumentItem	| DocumentItems <newline>	| DocumentItems BlankLine ;BlankLine	: <blankline> { #addEmptyParagraph };DocumentItem	: HorizontalRule	| Header	| List	| Anchor	| Preformatted	| Table	| Paragraph ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #HorizontalRule	: <horizontalRule> { #addHorizontalRule }	| <horizontalRule> 'rule' Paragraph { self items last setChildren: (self createText: rule value) , self items last children };Header	: <header> 'header' ParagraphItems 'items' { self addHeader: items level: header value size } ;List	: <list> 'type' ParagraphItems 'items' { self addListItem: (PRListItem withAll: items) ofType: type value } ;Anchor	: <anchor> Line 'line' { self addAnchor: line } ;Preformatted	: <preformatted> Line 'line' { self addPreformatted: line } ;Table	: TableRow 'row' { self addTable: row } ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #TableRow	: TableCells 'cells' { PRTableRow withAll: cells } ;TableCells	: TableCell 'cell' { OrderedCollection with: cell }	| TableCells 'cells' TableCell 'cell' { cells add: cell; yourself } ;TableCell	: <tableleft> TableParagraphItems 'paragraph' { (PRTableCell withAll: paragraph) beAlignedLeft; yourself }	| <tablecenter> TableParagraphItems 'paragraph' { (PRTableCell withAll: paragraph) beAlignedCenter; yourself }	| <tableright> TableParagraphItems 'paragraph' { (PRTableCell withAll: paragraph) beAlignedRight; yourself }	| <table> TableParagraphItems 'paragraph' { (PRTableCell withAll: paragraph) } ;TableParagraphItems	: { OrderedCollection new }	| TableParagraphItems 'items' Text 'text' { self addAll: text to: items }	| TableParagraphItems 'items' Link 'link' { self add: link to: items }	| TableParagraphItems 'items' InternalTableParagraphText 'text' { self addAll: (self createText: text) to: items } ;InternalTableParagraphText	: <horizontalRule> { #stringValue: }	| <header> { #stringValue: }	| <list> { #stringValue: }	| <nonLinkStart> 'text' { String with: text value last }	| <anchor> { #stringValue: }	| <preformatted> { #stringValue: }	| <any> { #stringValue: } ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Paragraph	: ParagraphStart 'firstItem' ParagraphItems 'items' { self addParagraph: firstItem and: items } ;ParagraphStart	: Text { #liftFirstValue: }	| <nonLinkStart> 'string' { self createText: (String with: string value last) }	| Link	| <any> 'char' { self createText: char value } ;ParagraphItems	: { OrderedCollection new }	| ParagraphItems 'items' Text 'text' { self addAll: text to: items }	| ParagraphItems 'items' Link 'link' { self add: link to: items }	| ParagraphItems 'items' InternalTableParagraphText 'text' { self addAll: (self createText: text) to: items }	| ParagraphItems 'items' <tableleft> 'text' { self add: (PRText with: text value) to: items }	| ParagraphItems 'items' <tablecenter> 'text' { self add: (PRText with: text value) to: items }	| ParagraphItems 'items' <tableright> 'text' { self add: (PRText with: text value) to: items }	| ParagraphItems 'items' <table> 'text' { self add: (PRText with: text value) to: items } ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #Link	: <link> 'link' { self createLink: link value } ;Line	: { '' }	| Line 'line' InternalTableParagraphText 'text' { line , text }	| Line 'line' <tableleft> 'text' { line , text value }	| Line 'line' <tablecenter> 'text' { line , text value }	| Line 'line' <tableright> 'text' { line , text value }	| Line 'line' <table> 'text' { line , text value }	| Line 'line' <text> 'text' { line , text value }	| Line 'line' <link> 'link' { line , link value }  ;Text	: <text> 'text' { self createText: text value } ;"! !!PRDocumentParser class methodsFor: 'generated-accessing' stamp: 'lr 6/5/2006 11:01'!scannerClass	^PRDocumentScanner! !!PRDocumentParser class methodsFor: 'generated-starting states' stamp: 'lr 6/5/2006 11:01'!startingStateForDocument	^1! !!PRDocumentParser methodsFor: 'private-utilities' stamp: 'lr 3/9/2006 11:29'!add: anItem to: aCollection	(aCollection notEmpty and: [ anItem class = PRText and: [ aCollection last class = PRText ] ])		ifTrue: [ aCollection addAll: (self createText: aCollection removeLast text , anItem text) ]		ifFalse: [ aCollection add: anItem ].	^ aCollection! !!PRDocumentParser methodsFor: 'private-utilities' stamp: 'lr 3/9/2006 11:29'!addAll: aTextCollection to: aCollection	aTextCollection do: [ :each |		self add: each to: aCollection ].	^ aCollection! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addAnchor: aString	self items add: (PRAnchor with: aString)! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addEmptyParagraph	self items add: PRParagraph new! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addHeader: aCollection level: anInteger	self items add: (PRHeader withAll: aCollection level: anInteger)! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addHorizontalRule	self items add: PRHorizontalRule new! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addListItem: aListItem ofType: aString	^ self addListItem: aListItem to: items ofType: aString! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addListItem: aListItem to: aCollection ofType: aString	| list type |	type := self listTypeFor: aString.	(aCollection isEmpty or: [ aCollection last class ~= type ])		ifTrue: [ aCollection add: (type with: aListItem) ]		ifFalse: [			list := aCollection last.			aString size > 1				ifFalse: [ list add: aListItem ]				ifTrue: [					| newChildren listItem |					listItem := list children last.					newChildren := listItem children copy						asOrderedCollection.					self						addListItem: aListItem						to: newChildren						ofType: (aString copyFrom: 2 to: aString size).					newChildren size = listItem children size						ifFalse: [ listItem add: newChildren last ] ] ]! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addParagraph: aFirstCollection and: aSecondCollection	| collection |	collection := aFirstCollection asOrderedCollection.	self addAll: aSecondCollection to: collection.	self items add: (PRParagraph withAll: collection)! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addPreformatted: aString	| text |	text := PRText with: aString.	self lastDocumentClass = PRPreformatted		ifTrue: [ self lastDocumentItem add: text ]		ifFalse: [ self items add: (PRPreformatted with: text) ]! !!PRDocumentParser methodsFor: 'private-adding' stamp: 'lr 3/9/2006 11:29'!addTable: aTableRow	self lastDocumentClass = PRTable		ifTrue: [ self lastDocumentItem add: aTableRow ]		ifFalse: [ self items add: (PRTable with: aTableRow) ]! !!PRDocumentParser methodsFor: 'private-creating' stamp: 'lr 3/9/2006 11:29'!createDocument	^ PRDocument withAll: self items! !!PRDocumentParser methodsFor: 'private-creating' stamp: 'lr 3/9/2006 11:29'!createLink: aString	| string index alias link |	string := aString copyFrom: 2 to: aString size - 1.	index := string indexOf: $> ifAbsent: [ 0 ].	alias := nil.	index isZero ifFalse: [		alias := string copyFrom: 1 to: index - 1.		string := string copyFrom: index + 1 to: string size ].	link := (PRLink fromString: string)		addAll: (self createText: alias);		embedded: aString first = $+;		yourself.	^ link! !!PRDocumentParser methodsFor: 'private-creating' stamp: 'lr 5/29/2006 09:14'!createText: aString	^ aString isEmptyOrNil		ifTrue: [ Array new ]		ifFalse: [ Array with: (PRText with: aString) ]! !!PRDocumentParser methodsFor: 'initialize-release' stamp: 'lr 3/9/2006 11:29'!initialize	super initialize.	items := OrderedCollection new! !!PRDocumentParser methodsFor: 'private-accessing' stamp: 'lr 3/9/2006 11:29'!items	^ items! !!PRDocumentParser methodsFor: 'private-accessing' stamp: 'lr 3/9/2006 11:29'!lastDocumentClass	^ items isEmpty		ifTrue: [ nil ]		ifFalse: [ items last class ]! !!PRDocumentParser methodsFor: 'private-accessing' stamp: 'lr 3/9/2006 11:29'!lastDocumentItem	^ items isEmpty		ifTrue: [ nil ]		ifFalse: [ items last ]! !!PRDocumentParser methodsFor: 'private-utilities' stamp: 'lr 3/9/2006 11:29'!listTypeFor: aString	^ aString first = $#		ifTrue: [ PROrderedList ]		ifFalse: [ PRUnorderedList ]! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForAnchor1: nodes 	^ self addAnchor: (nodes at: 2)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForHeader1: nodes 	^ self addHeader: (nodes at: 2) level: (nodes at: 1) value size! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForHorizontalRule2: nodes 	^ self items last setChildren: (self createText: (nodes at: 1) value) 				, self items last children! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForInternalTableParagraphText4: nodes 	^ String with: (nodes at: 1) value last! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine1: nodes 	^ ''! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine2: nodes 	^ (nodes at: 1) , (nodes at: 2)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine3: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine4: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine5: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine6: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine7: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLine8: nodes 	^ (nodes at: 1) , (nodes at: 2) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForLink1: nodes 	^ self createLink: (nodes at: 1) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForList1: nodes 	^ self addListItem: (PRListItem withAll: (nodes at: 2))		ofType: (nodes at: 1) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraph1: nodes 	^ self addParagraph: (nodes at: 1) and: (nodes at: 2)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems1: nodes 	^ OrderedCollection new! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems2: nodes 	^ self addAll: (nodes at: 2) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems3: nodes 	^ self add: (nodes at: 2) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems4: nodes 	^ self addAll: (self createText: (nodes at: 2)) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems5: nodes 	^ self add: (PRText with: (nodes at: 2) value) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems6: nodes 	^ self add: (PRText with: (nodes at: 2) value) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems7: nodes 	^ self add: (PRText with: (nodes at: 2) value) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphItems8: nodes 	^ self add: (PRText with: (nodes at: 2) value) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphStart2: nodes 	^ self createText: (String with: (nodes at: 1) value last)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForParagraphStart4: nodes 	^ self createText: (nodes at: 1) value! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForPreformatted1: nodes 	^ self addPreformatted: (nodes at: 2)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTable1: nodes 	^ self addTable: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCell1: nodes 	^ (PRTableCell withAll: (nodes at: 2))		beAlignedLeft;		yourself! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCell2: nodes 	^ (PRTableCell withAll: (nodes at: 2))		beAlignedCenter;		yourself! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCell3: nodes 	^ (PRTableCell withAll: (nodes at: 2))		beAlignedRight;		yourself! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCell4: nodes 	^ PRTableCell withAll: (nodes at: 2)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCells1: nodes 	^ OrderedCollection with: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableCells2: nodes 	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableParagraphItems1: nodes 	^ OrderedCollection new! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableParagraphItems2: nodes 	^ self addAll: (nodes at: 2) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableParagraphItems3: nodes 	^ self add: (nodes at: 2) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableParagraphItems4: nodes 	^ self addAll: (self createText: (nodes at: 2)) to: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForTableRow1: nodes 	^ PRTableRow withAll: (nodes at: 1)! !!PRDocumentParser methodsFor: 'generated-reduction actions' stamp: 'lr 6/5/2006 11:01'!reduceActionForText1: nodes 	^ self createText: (nodes at: 1) value! !!PRDocumentParser methodsFor: 'generated-tables' stamp: 'lr 6/5/2006 11:01'!reduceTable	^#(#(16 1 #reduceActionForTable1:)#(17 0 #reduceActionForParagraphItems1:)#(17 2 #reduceActionForParagraphItems2:)#(17 2 #reduceActionForParagraphItems3:)#(17 2 #reduceActionForParagraphItems4:)#(17 2 #reduceActionForParagraphItems5:)#(17 2 #reduceActionForParagraphItems6:)#(17 2 #reduceActionForParagraphItems7:)#(17 2 #reduceActionForParagraphItems8:)#(18 2 #reduceActionForPreformatted1:)#(19 2 #reduceActionForAnchor1:)#(20 0 #reduceActionForLine1:)#(20 2 #reduceActionForLine2:)#(20 2 #reduceActionForLine3:)#(20 2 #reduceActionForLine4:)#(20 2 #reduceActionForLine5:)#(20 2 #reduceActionForLine6:)#(20 2 #reduceActionForLine7:)#(20 2 #reduceActionForLine8:)#(21 2 #reduceActionForList1:)#(22 1 #reduceActionForTableRow1:)#(23 1 #reduceActionForTableCells1:)#(23 2 #reduceActionForTableCells2:)#(24 2 #reduceActionForTableCell1:)#(24 2 #reduceActionForTableCell2:)#(24 2 #reduceActionForTableCell3:)#(24 2 #reduceActionForTableCell4:)#(25 2 #reduceActionForHeader1:)#(26 0 #reduceActionForTableParagraphItems1:)#(26 2 #reduceActionForTableParagraphItems2:)#(26 2 #reduceActionForTableParagraphItems3:)#(26 2 #reduceActionForTableParagraphItems4:)#(27 1 #addHorizontalRule)#(27 2 #reduceActionForHorizontalRule2:)#(28 1 #addEmptyParagraph)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(29 1 #reduceFor:)#(30 1 #reduceActionForText1:)#(31 1 #reduceActionForLink1:)#(32 1 #stringValue:)#(32 1 #stringValue:)#(32 1 #stringValue:)#(32 1 #reduceActionForInternalTableParagraphText4:)#(32 1 #stringValue:)#(32 1 #stringValue:)#(32 1 #stringValue:)#(33 1 #reduceFor:)#(34 2 #reduceActionForParagraph1:)#(35 1 #liftFirstValue:)#(35 1 #reduceActionForParagraphStart2:)#(35 1 #reduceFor:)#(35 1 #reduceActionForParagraphStart4:)#(36 1 #createDocument)#(37 0 #reduceFor:)#(37 1 #reduceFor:)#(37 3 #reduceFor:)#(37 3 #reduceFor:)#(37 2 #reduceFor:)#(37 2 #reduceFor:))! !!PRDocumentParser methodsFor: 'generated-tables' stamp: 'lr 6/5/2006 11:01'!transitionTable	^#(#(3 238 1 238 2 9 3 13 4 17 5 21 6 25 7 29 8 33 9 37 10 41 11 45 12 49 13 53 14 57 15 61 16 65 18 69 19 73 21 77 22 81 23 85 24 89 25 93 27 97 29 101 30 105 31 109 34 113 35 117 36 121 37 238 38)#(3 134 1 134 2 45 12 49 13 53 14 57 15 101 30 105 31 125 34 113 35 134 38)#(3 10 1 10 2 10 3 10 4 10 5 10 6 10 7 10 8 10 9 10 10 10 11 10 12 10 13 10 14 10 15 129 17 10 38)#(3 10 1 10 2 10 3 10 4 10 5 10 6 10 7 10 8 10 9 10 10 10 11 10 12 10 13 10 14 10 15 133 17 10 38)#(3 118 1 118 2 118 3 118 4 118 5 118 6 118 7 118 8 118 9 118 10 118 11 118 12 118 13 118 14 118 15 137 26 118 38)#(3 118 1 118 2 118 3 118 4 118 5 118 6 118 7 118 8 118 9 118 10 118 11 118 12 118 13 118 14 118 15 141 26 118 38)#(3 118 1 118 2 118 3 118 4 118 5 118 6 118 7 118 8 118 9 118 10 118 11 118 12 118 13 118 14 118 15 145 26 118 38)#(3 118 1 118 2 118 3 118 4 118 5 118 6 118 7 118 8 118 9 118 10 118 11 118 12 118 13 118 14 118 15 149 26 118 38)#(3 50 1 50 2 50 3 50 4 50 5 50 6 50 7 50 8 50 9 50 10 50 11 50 12 50 13 50 14 50 15 153 20 50 38)#(3 50 1 50 2 50 3 50 4 50 5 50 6 50 7 50 8 50 9 50 10 50 11 50 12 50 13 50 14 50 15 157 20 50 38)#(2 178 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 222 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 174 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 230 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 166 1 2 38)#(2 162 1 2 38)#(2 158 1 2 38)#(2 154 1 2 38)#(2 6 1 2 38)#(3 86 1 86 2 21 6 25 7 29 8 33 9 161 24 86 38)#(2 90 1 2 6 7 8 9 38)#(2 150 1 2 38)#(2 146 1 2 38)#(2 242 1 2 38)#(2 218 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 226 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 170 1 2 38)#(3 10 1 10 2 10 3 10 4 10 5 10 6 10 7 10 8 10 9 10 10 10 11 10 12 10 13 10 14 10 15 165 17 10 38)#(2 0 38)#(3 169 1 173 2 177 28 234 38)#(2 138 1 2 38)#(3 114 1 114 2 181 3 185 4 189 5 193 6 197 7 201 8 205 9 209 10 213 11 45 12 217 13 53 14 221 15 225 30 229 31 233 32 114 38)#(3 82 1 82 2 181 3 185 4 189 5 193 6 197 7 201 8 205 9 209 10 213 11 45 12 217 13 53 14 221 15 225 30 229 31 233 32 82 38)#(3 98 1 98 2 181 3 185 4 189 5 98 6 98 7 98 8 98 9 209 10 213 11 45 12 217 13 53 14 221 15 237 30 241 31 245 32 98 38)#(3 102 1 102 2 181 3 185 4 189 5 102 6 102 7 102 8 102 9 209 10 213 11 45 12 217 13 53 14 221 15 237 30 241 31 245 32 102 38)#(3 106 1 106 2 181 3 185 4 189 5 106 6 106 7 106 8 106 9 209 10 213 11 45 12 217 13 53 14 221 15 237 30 241 31 245 32 106 38)#(3 110 1 110 2 181 3 185 4 189 5 110 6 110 7 110 8 110 9 209 10 213 11 45 12 217 13 53 14 221 15 237 30 241 31 245 32 110 38)#(3 42 1 42 2 181 3 185 4 189 5 249 6 253 7 257 8 261 9 209 10 213 11 265 12 217 13 269 14 221 15 273 32 42 38)#(3 46 1 46 2 181 3 185 4 189 5 249 6 253 7 257 8 261 9 209 10 213 11 265 12 217 13 269 14 221 15 273 32 46 38)#(2 94 1 2 6 7 8 9 38)#(3 214 1 214 2 181 3 185 4 189 5 193 6 197 7 201 8 205 9 209 10 213 11 45 12 217 13 53 14 221 15 225 30 229 31 233 32 214 38)#(3 254 1 254 2 9 3 13 4 17 5 21 6 25 7 29 8 33 9 37 10 41 11 45 12 49 13 53 14 57 15 61 16 65 18 69 19 73 21 77 22 81 23 85 24 89 25 93 27 277 29 101 30 105 31 109 34 113 35 254 38)#(2 142 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(3 258 1 258 2 9 3 13 4 17 5 21 6 25 7 29 8 33 9 37 10 41 11 45 12 49 13 53 14 57 15 61 16 65 18 69 19 73 21 77 22 81 23 85 24 89 25 93 27 281 29 101 30 105 31 109 34 113 35 258 38)#(2 182 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 186 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 190 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 34 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 202 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 198 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 194 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 206 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 22 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 122 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 126 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 130 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 58 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 62 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 66 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 70 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 78 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 74 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 54 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 38)#(2 246 1 2 38)#(2 250 1 2 38))! !!WAEntryPoint methodsFor: '*pier-seaside' stamp: 'lr 3/9/2006 18:57'!name	| name |	name := self basePath copyAfterLast: $/.	name isEmpty ifTrue: [ name := self basePath ].	^ name! !!MAStringReader methodsFor: '*pier-model-visiting-description' stamp: 'lr 3/9/2006 11:29'!visitStructureDescription: aDescription	self object: (PRPathLookup		start: self context structure		path: self contents)! !!PRDocumentScanner class methodsFor: 'generated-comments' stamp: 'lr 6/5/2006 11:01'!scannerDefinitionComment	"# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #<newline>			: \r \n | \n | \r ;<blankline>			: <newline> <newline> ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #<horizontalRule>		: \_ [\ \t]* ;<header>				: \!!+ ;<list>				: [\#\-]+ ;<tableleft>			: \| \{ ;<tablecenter>		: \| \| ;<tableright>			: \| \} ;<table>				: \| ;<preformatted>		: \= ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #<alias>				: \> ;<anchor>			: \@ ;<linkText>			: [^\*\+\>\@\r\n]* ;<link>				: \* (<linkText> <alias>)? <linkText> (<anchor> <linkText>)? \*					| \+ (<linkText> <alias>)? <linkText> (<anchor> <linkText>)? \+ ;<nonLinkStart>		: \*\* | \+\+ | \\ [\*\+\=\@\!!\#\-\|] ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #<text>				: [^\r\n\|\*\+\!!\#\-\=\@\\]+ ;<any> 				: . ;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"! !!PRDocumentScanner methodsFor: 'generated-tokens' stamp: 'lr 6/5/2006 11:01'!emptySymbolTokenId	^38! !!PRDocumentScanner methodsFor: 'generated-tokens' stamp: 'lr 6/5/2006 11:01'!errorTokenId	^39! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scan1		[ self step.	currentCharacter <= Character tab or: 			[ (currentCharacter between: (Character value: 11) and: Character newPage) 				or: 					[ (currentCharacter between: (Character value: 14) and: $)) or: 							[ (currentCharacter between: $, and: $=) 								or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 			whileTrue.	currentCharacter == $* ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].	currentCharacter == $@ ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scan2		[ self step.	currentCharacter <= Character tab or: 			[ (currentCharacter between: (Character value: 11) and: Character newPage) 				or: 					[ (currentCharacter between: (Character value: 14) and: $)) or: 							[ (currentCharacter between: $, and: $=) 								or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 			whileTrue.	currentCharacter == $* ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].	^ self reportLastMatch! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scan3		[ self step.	currentCharacter <= Character tab or: 			[ (currentCharacter between: (Character value: 11) and: Character newPage) 				or: 					[ (currentCharacter between: (Character value: 14) and: $)) or: 							[ (currentCharacter between: $, and: $=) 								or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 			whileTrue.	currentCharacter == $+ ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].	currentCharacter == $@ ifTrue: [ ^ self scan4 ].	^ self reportLastMatch! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scan4		[ self step.	currentCharacter <= Character tab or: 			[ (currentCharacter between: (Character value: 11) and: Character newPage) 				or: 					[ (currentCharacter between: (Character value: 14) and: $)) or: 							[ (currentCharacter between: $, and: $=) 								or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 			whileTrue.	currentCharacter == $+ ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].	^ self reportLastMatch! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scan5	self recordMatch: #(2 ).	self step.	currentCharacter == Character lf 		ifTrue: [ ^ self recordAndReportMatch: #(2 ) ].	^ self reportLastMatch! !!PRDocumentScanner methodsFor: 'generated-scanner' stamp: 'lr 6/5/2006 11:01'!scanForToken	self step.	(currentCharacter <= Character tab or: 			[ (currentCharacter between: (Character value: 11) and: Character newPage) 				or: 					[ (currentCharacter between: (Character value: 14) and: Character space) 						or: 							[ currentCharacter == $" or: 									[ (currentCharacter between: $$ and: $)) or: 											[ currentCharacter == $, or: 													[ (currentCharacter between: $. and: $<) or: 															[ (currentCharacter between: $> and: $?) or: 																	[ (currentCharacter between: $A and: $[) or: 																			[ (currentCharacter between: $] and: $^) 																				or: [ (currentCharacter between: $` and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ] ]) 		ifTrue: 			[ self recordMatch: #(14 15 ).			self step.			(currentCharacter <= Character tab or: 					[ (currentCharacter between: (Character value: 11) and: Character newPage) 						or: 							[ (currentCharacter between: (Character value: 14) and: Character space) 								or: 									[ currentCharacter == $" or: 											[ (currentCharacter between: $$ and: $)) or: 													[ currentCharacter == $, or: 															[ (currentCharacter between: $. and: $<) or: 																	[ (currentCharacter between: $> and: $?) or: 																			[ (currentCharacter between: $A and: $[) 																				or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ]) 				ifTrue: 					[ 					[ self recordMatch: #(14 ).					self step.					currentCharacter <= Character tab or: 							[ (currentCharacter between: (Character value: 11) and: Character newPage) 								or: 									[ (currentCharacter between: (Character value: 14) and: Character space) 										or: 											[ currentCharacter == $" or: 													[ (currentCharacter between: $$ and: $)) or: 															[ currentCharacter == $, or: 																	[ (currentCharacter between: $. and: $<) or: 																			[ (currentCharacter between: $> and: $?) or: 																					[ (currentCharacter between: $A and: $[) 																						or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ] ] 							whileTrue.					^ self reportLastMatch ].			^ self reportLastMatch ].	(currentCharacter == $# or: [ currentCharacter == $- ]) 		ifTrue: 			[ self recordMatch: #(5 15 ).			self step.			(currentCharacter == $# or: [ currentCharacter == $- ]) 				ifTrue: 					[ 					[ self recordMatch: #(5 ).					self step.					currentCharacter == $# or: [ currentCharacter == $- ] ] 							whileTrue.					^ self reportLastMatch ].			^ self reportLastMatch ].	currentCharacter == Character lf 		ifTrue: 			[ self recordMatch: #(1 15 ).			self step.			currentCharacter == Character lf 				ifTrue: [ ^ self recordAndReportMatch: #(2 ) ].			currentCharacter == Character cr ifTrue: [ ^ self scan5 ].			^ self reportLastMatch ].	currentCharacter == Character cr 		ifTrue: 			[ self recordMatch: #(1 15 ).			self step.			currentCharacter == Character lf 				ifTrue: 					[ self recordMatch: #(1 2 ).					self step.					currentCharacter == Character lf 						ifTrue: [ ^ self recordAndReportMatch: #(2 ) ].					currentCharacter == Character cr ifTrue: [ ^ self scan5 ].					^ self reportLastMatch ].			currentCharacter == Character cr ifTrue: [ ^ self scan5 ].			^ self reportLastMatch ].	currentCharacter == $!! 		ifTrue: 			[ self recordMatch: #(4 15 ).			self step.			currentCharacter == $!! 				ifTrue: 					[ 					[ self recordMatch: #(4 ).					self step.					currentCharacter == $!! ] 							whileTrue.					^ self reportLastMatch ].			^ self reportLastMatch ].	currentCharacter == $* 		ifTrue: 			[ self recordMatch: #(15 ).			self step.			(currentCharacter <= Character tab or: 					[ (currentCharacter between: (Character value: 11) and: Character newPage) 						or: 							[ (currentCharacter between: (Character value: 14) and: $)) or: 									[ (currentCharacter between: $, and: $=) 										or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ]) 				ifTrue: 					[ 					[ self step.					currentCharacter <= Character tab or: 							[ (currentCharacter between: (Character value: 11) and: Character newPage) 								or: 									[ (currentCharacter between: (Character value: 14) and: $)) or: 											[ (currentCharacter between: $, and: $=) 												or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 							whileTrue.					currentCharacter == $* ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].					currentCharacter == $> ifTrue: [ ^ self scan1 ].					currentCharacter == $@ ifTrue: [ ^ self scan2 ].					^ self reportLastMatch ].			currentCharacter == $* ifTrue: [ ^ self recordAndReportMatch: #(12 13 ) ].			currentCharacter == $> ifTrue: [ ^ self scan1 ].			currentCharacter == $@ ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	currentCharacter == $+ 		ifTrue: 			[ self recordMatch: #(15 ).			self step.			(currentCharacter <= Character tab or: 					[ (currentCharacter between: (Character value: 11) and: Character newPage) 						or: 							[ (currentCharacter between: (Character value: 14) and: $)) or: 									[ (currentCharacter between: $, and: $=) 										or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ]) 				ifTrue: 					[ 					[ self step.					currentCharacter <= Character tab or: 							[ (currentCharacter between: (Character value: 11) and: Character newPage) 								or: 									[ (currentCharacter between: (Character value: 14) and: $)) or: 											[ (currentCharacter between: $, and: $=) 												or: [ currentCharacter == $? or: [ currentCharacter >= $A ] ] ] ] ] ] 							whileTrue.					currentCharacter == $+ ifTrue: [ ^ self recordAndReportMatch: #(12 ) ].					currentCharacter == $> ifTrue: [ ^ self scan3 ].					currentCharacter == $@ ifTrue: [ ^ self scan4 ].					^ self reportLastMatch ].			currentCharacter == $+ ifTrue: [ ^ self recordAndReportMatch: #(12 13 ) ].			currentCharacter == $> ifTrue: [ ^ self scan3 ].			currentCharacter == $@ ifTrue: [ ^ self scan4 ].			^ self reportLastMatch ].	currentCharacter == $= ifTrue: [ ^ self recordAndReportMatch: #(10 15 ) ].	currentCharacter == $@ ifTrue: [ ^ self recordAndReportMatch: #(11 15 ) ].	currentCharacter == $\ 		ifTrue: 			[ self recordMatch: #(15 ).			self step.			(currentCharacter == $!! or: 					[ currentCharacter == $# or: 							[ (currentCharacter between: $* and: $+) or: 									[ currentCharacter == $- or: 											[ currentCharacter == $= 												or: [ currentCharacter == $@ or: [ currentCharacter == $| ] ] ] ] ] ]) 				ifTrue: [ ^ self recordAndReportMatch: #(13 ) ].			^ self reportLastMatch ].	currentCharacter == $_ 		ifTrue: 			[ self recordMatch: #(3 14 15 ).			self step.			(currentCharacter <= Character backspace or: 					[ (currentCharacter between: (Character value: 11) and: Character newPage) 						or: 							[ (currentCharacter between: (Character value: 14) and: (Character value: 31)) 								or: 									[ currentCharacter == $" or: 											[ (currentCharacter between: $$ and: $)) or: 													[ currentCharacter == $, or: 															[ (currentCharacter between: $. and: $<) or: 																	[ (currentCharacter between: $> and: $?) or: 																			[ (currentCharacter between: $A and: $[) 																				or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ]) 				ifTrue: 					[ 					[ self recordMatch: #(14 ).					self step.					currentCharacter <= Character tab or: 							[ (currentCharacter between: (Character value: 11) and: Character newPage) 								or: 									[ (currentCharacter between: (Character value: 14) and: Character space) 										or: 											[ currentCharacter == $" or: 													[ (currentCharacter between: $$ and: $)) or: 															[ currentCharacter == $, or: 																	[ (currentCharacter between: $. and: $<) or: 																			[ (currentCharacter between: $> and: $?) or: 																					[ (currentCharacter between: $A and: $[) 																						or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ] ] 							whileTrue.					^ self reportLastMatch ].			(currentCharacter == Character tab 				or: [ currentCharacter == Character space ]) 					ifTrue: 						[ 						[ self recordMatch: #(3 14 ).						self step.						(currentCharacter <= Character backspace or: 								[ (currentCharacter between: (Character value: 11) and: Character newPage) 									or: 										[ (currentCharacter between: (Character value: 14) and: (Character value: 31)) 											or: 												[ currentCharacter == $" or: 														[ (currentCharacter between: $$ and: $)) or: 																[ currentCharacter == $, or: 																		[ (currentCharacter between: $. and: $<) or: 																				[ (currentCharacter between: $> and: $?) or: 																						[ (currentCharacter between: $A and: $[) 																							or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ]) 							ifTrue: 								[ 								[ self recordMatch: #(14 ).								self step.								currentCharacter <= Character tab or: 										[ (currentCharacter between: (Character value: 11) and: Character newPage) 											or: 												[ (currentCharacter between: (Character value: 14) and: Character space) 													or: 														[ currentCharacter == $" or: 																[ (currentCharacter between: $$ and: $)) or: 																		[ currentCharacter == $, or: 																				[ (currentCharacter between: $. and: $<) or: 																						[ (currentCharacter between: $> and: $?) or: 																								[ (currentCharacter between: $A and: $[) 																									or: [ (currentCharacter between: $] and: ${) or: [ currentCharacter >= $} ] ] ] ] ] ] ] ] ] ] ] 										whileTrue.								^ self reportLastMatch ].						currentCharacter == Character tab 							or: [ currentCharacter == Character space ] ] 								whileTrue.						^ self reportLastMatch ].			^ self reportLastMatch ].	currentCharacter == $| 		ifTrue: 			[ self recordMatch: #(9 15 ).			self step.			currentCharacter == ${ ifTrue: [ ^ self recordAndReportMatch: #(6 ) ].			currentCharacter == $| ifTrue: [ ^ self recordAndReportMatch: #(7 ) ].			currentCharacter == $} ifTrue: [ ^ self recordAndReportMatch: #(8 ) ].			^ self reportLastMatch ].	^ self reportLastMatch! !!MADescription methodsFor: '*pier-model' stamp: 'lr 5/24/2006 15:15'!beEditable	self propertyAt: #editable put: true! !!MADescription methodsFor: '*pier-model' stamp: 'lr 5/24/2006 15:15'!isEditable	^ self propertyAt: #editable ifAbsent: [ false ]! !!MABinaryWriter methodsFor: '*pier-model-visiting-description' stamp: 'lr 3/9/2006 11:29'!visitStructureDescription: aDescription	self visitDescription: aDescription.	stream nextPut: (PRPathReference to: self object)! !!PRStructureDescription class methodsFor: '*pier-seaside-defaults' stamp: 'lr 3/9/2006 11:30'!defaultComponentClasses	^ Array with: PRStructureComponent! !!PRStructureDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRStructureDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!label	^ 'Structure'! !!PRStructureDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!acceptMagritte: aVisitor	aVisitor visitStructureDescription: self! !!PRStructureDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!kind	^ PRStructure! !!Collection methodsFor: '*pier-model' stamp: 'lr 3/9/2006 11:29'!accept: aVisitor	aVisitor visitAll: self! !!PRConflictingNameError class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!in: aStructure title: aString	^ (self structure: aStructure)		signal: aString printString , ' conflicts in ' , aStructure title printString! !!PRInvalidNestingError class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!of: aChildStructure in: aParentStructure	^ (self structure: aParentStructure)		signal: aChildStructure title printString , ' can not be a child of ' , aParentStructure title printString! !!PRStructureError class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:30'!structure: aStructure	^ self new		setStructure: aStructure;		yourself! !!PRStructureError methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:30'!setStructure: aStructure	structure := aStructure! !!PRStructureError methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!structure	^ structure! !!PRPierMain methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!classFromRequest: aRequest name: aString base: aBaseClass	| class |	(class := PRCompatibility classNamed: (aRequest		at: aString ifAbsent: [ ^ nil ])) isNil			ifTrue: [ ^ nil ].	(class inheritsFrom: aBaseClass)		ifFalse: [ ^ nil ].	^ class! !!PRPierMain methodsFor: 'querying' stamp: 'lr 3/9/2006 11:30'!commandFrom: aRequest	| commandClass command viewClass |	commandClass := self classFromRequest: aRequest name: 'command' base: PRCommand.	(commandClass isNil or: [ commandClass isAbstract ])		ifTrue: [ commandClass := context structure viewCommandClass ].	(command := commandClass new) isView		ifFalse: [ ^ command ].	viewClass := self classFromRequest: aRequest name: 'view' base: PRViewComponent.	viewClass isNil		ifFalse: [ command viewComponentClass: viewClass ].	^ command! !!PRPierMain methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!context	^ context ifNil: [ context := PRContext kernel: self kernel ]! !!PRPierMain methodsFor: 'processing' stamp: 'lr 3/9/2006 11:30'!createRoot	^ self rootClass on: self context! !!PRPierMain methodsFor: 'accessing' stamp: 'lr 3/9/2006 18:52'!dispatcher	^ WADispatcher default! !!PRPierMain methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!kernel	^ self application preferenceAt: #kernel! !!PRPierMain methodsFor: 'processing' stamp: 'lr 3/9/2006 11:30'!start: aRequest	self context		setStructure: (self structureFrom: aRequest);		setCommand: (self commandFrom: aRequest).	self context isValid		ifFalse: [ context := nil ].	super start: aRequest! !!PRPierMain methodsFor: 'querying' stamp: 'lr 3/21/2006 18:43'!structureFrom: aRequest	| path |	path := aRequest url findTokens: $/.	path removeFirst = self dispatcher name		ifFalse: [ self error: 'Invalid Seaside dispatcher configuration' ].	(path notEmpty		and: [ path first = self application name		or: [ path first = (self dispatcher entryPoints keyAtValue: self application ifAbsent: [ nil ]) ] ])			ifTrue: [ path removeFirst ].	path := path		inject: String new		into: [ :result :each | result , '/' , each ].	^ PRPathLookup		start: self kernel root path: path		onError: [ self kernel root ]! !!PRPierLibrary methodsFor: 'accessing' stamp: 'lr 4/10/2006 10:46'!style	^ '@import "http://www.lukas-renggli.ch/smalltalk/pier/style/84/style.css";'! !!MABinaryReader methodsFor: '*pier-model-visiting-description' stamp: 'lr 3/9/2006 11:29'!visitStructureDescription: aDescription	self object		write: (PRPathLookup			start: self context root			path: self stream next			onError: [ nil ])		using: aDescription! !"Pier-Model"!"Pier-Seaside"!"Pier-Tests"!!PRStructure methodsFor: 'thumbnail' stamp: 'pmm 9/11/2006 23:48'!iconOrThumbnailOfSize: aNumberOrPoint 	"Answer an appropiate form to represent the receiver"	^(Form fromBinaryStream: self icon readStream) scaledIntoFormOfSize: aNumberOrPoint! !!PRStructure methodsFor: 'accessing-dynamic' stamp: 'kph 9/28/2006 21:12' prior: 36319837!kernel	"Answer the kernel of the receiver."	^ self root in: [ :root |		PRKernel instances			detect: [ :each | each realize root = root ]			ifNone: [ self error: self title , ' is not part of a kernel.' ] ]! !!PRCopyCommand methodsFor: 'events' stamp: 'kph 9/28/2006 20:06' prior: 36278982!doExecute	| structure |	super doExecute.	structure := self target childrenDecoration		add: (self structure copy			name: self name;			title: nil;			yourself).	PRIncomingReferences		from: structure		to: (structure enumerator			with; all; hidden;			contents)		do: [ :each | each update ].	self answer: (self context		structure: structure)! !!PRImagePersistency class methodsFor: 'nil' stamp: 'kph 10/4/2006 11:32'!isAbstract	^false! !!PRImagePersistency methodsFor: 'actions-process' stamp: 'kph 10/6/2006 10:49'!delay^ 60 * 60 ! !!PRInternalLink methodsFor: 'accessing' stamp: 'kph 9/28/2006 20:10' prior: 36344118!target: aStructure	target := aStructure.		self withPersistenceDo: [ :cache | cache internalLink: self ]! !!PRFilePersistency class methodsFor: 'instance-creation' stamp: 'kph 10/4/2006 11:32'!isAbstract	^false! !!PRFilePersistency methodsFor: 'translation' stamp: 'kph 10/1/2006 16:23'!exportTo: aPersistency(aPersistency respondsTo: #fromPRFilePersistency:) 	ifFalse: [ self error: 'exporting of PRFilePersistency not supported' ].^aPersistency fromPRFilePersistency: self ! !!PRFilePersistency methodsFor: 'translation' stamp: 'kph 9/30/2006 06:30'!fromPRPersistency: aPRPersistency^self! !!PRIncomingReferences class methodsFor: 'instance creation' stamp: 'kph 9/28/2006 03:54' prior: 36391804!from: aStructure to: aCollectionOrStructure do: aBlock	"Evaluates aBlock for every internal-link referencing one of the structures in aCollection starting at aStructure."	^ self new		block: aBlock;		structures: (aCollectionOrStructure isCollection			ifTrue: [ aCollectionOrStructure asSet ]			ifFalse: [ Set with: aCollectionOrStructure ]);		start: aStructure;		yourself! !!PRCommand methodsFor: 'actions' stamp: 'kph 9/28/2006 20:02' prior: 36270847!execute	"Execute the command of the receiver. To implement your action in the code of one of my subclasses. Never override this message, but instead have a look at the different template methods (<code>#doValidate</code>, <code>#doExecute</code>, <code>#doPersistency</code>, <code>#doAnswer</code>) available in the events protocol."	self isView		ifTrue: [ self shouldNotImplement ].	self kernel persistency doing: self critical: [		self doValidate; doExecute.		self isLogged			ifTrue: [ self doPersistency ] ].	self doAnswer! !!PRPersistency class methodsFor: 'testing' stamp: 'kph 10/4/2006 11:31'!isAbstract	^true! !!PRPersistency methodsFor: 'actions' stamp: 'kph 10/6/2006 04:10'!discarded 	"called when the user aborts changing persistency scheme"! !!PRPersistency methodsFor: 'actions' stamp: 'kph 8/5/2006 02:18'!doing: aCommand critical: aBlock	kernel critical: aBlock! !!PRPersistency methodsFor: 'translation' stamp: 'kph 10/6/2006 07:34'!exportTo: aPersistency  ^ (aPersistency fromPRPersistency: self).! !!PRPersistency methodsFor: 'translation' stamp: 'kph 9/30/2006 05:03'!exportToPRPersistency: aPRPersistency! !!PRPersistency methodsFor: 'translation' stamp: 'kph 9/30/2006 06:20'!fromPRPersistency: aPersistency ^self copySameFrom: aPersistency! !!PRPersistency methodsFor: 'accessing' stamp: 'kph 9/28/2006 20:04'!realizeKernel ^self kernel! !!PRPersistency methodsFor: 'utilities' stamp: 'kph 10/4/2006 11:15'!renameKernelTo: newName| okToRename |"although renaming a kernel is straightforward, using this api allows persistency mechanisms to maintain their integrity"okToRename := [ PRKernel instanceNamed: newName ] on: Error do: [ true ].okToRename == true ifTrue: [ self kernel name: newName ]					ifFalse: [ self error: 'name already exists in PRKernel instances' ]! !!PRPersistency methodsFor: 'initialization' stamp: 'kph 10/6/2006 21:29' prior: 36375132!setKernel: aKernel	"if the kernel we are persisting has no data, then we pass it the data that we do have"	(kernel notNil and: [ aKernel notNil  and: [ aKernel hasRoot not ] ]) 		ifTrue: [ aKernel root: kernel root ].	kernel := aKernel.! !!PRRemoveCommand methodsFor: 'events' stamp: 'kph 9/28/2006 20:05' prior: 36282132!doExecute	super doExecute.	PRIncomingReferences		from: self kernel root		to: (self structure enumerator			with; all; hidden;			contents)		do: [ :each | each target: nil ].	self structure parent in: [ :parent |		self structure remove.		self answer: (self context			structure: parent) ]! !!PRKernel methodsFor: 'accessing' stamp: 'kph 10/6/2006 21:03'!hasRoot^ root notNil! !!PRKernel methodsFor: 'accessing' stamp: 'kph 9/9/2006 04:32' prior: 36365551!persistency	"Answer the persistency strategy of the receiver."	 persistency ifNil: [ self persistency: PRNullPersistency new ]. ^persistency! !!PRKernel methodsFor: 'accessing' stamp: 'kph 9/28/2006 20:04'!realize^self persistency realizeKernel! !!PRNullPersistency class methodsFor: 'nil' stamp: 'kph 10/4/2006 11:32'!isAbstract	^false! !!PRNullPersistency methodsFor: 'enumerating' stamp: 'kph 9/30/2006 06:32'!fromPRFilePersistency: aFilePersistency^ self! !PRPathLookup class removeSelector: #start:path:!"Pier-Model"!!PRPierConfiguration methodsFor: 'attributes' stamp: 'kph 9/29/2006 05:33' prior: 36409678!attributeKernel 	^ (WAListAttribute key: #kernel group: #pier)		options: PRKernel instances ;		yourself! !!PRChangeEnvironment class methodsFor: 'accessing-environments' stamp: 'kph 9/24/2006 16:44' prior: 36265644!left	^ (PRPage named: 'environment') 		addChild: ((PRComponent named: 'header')			componentClass: PRHeaderWidget;			yourself);		addChild: ((PRComponent named: 'views')			componentClass: PRViewsWidget;			yourself);		addChild: ((PRComponent named: 'commands')			componentClass: PRCommandsWidget;			yourself);		addChild: ((PRComponent named: 'tree')			componentClass: PRTreeWidget;			yourself);		addChild: ((PRComponent named: 'main')			componentClass: PRContentsWidget;			yourself);		contents: '+header+<table class="body"><tr><td class="boxes">+views+<br />+commands+<br />+tree+</td><td class="spacer"></td><td class="main">+main+</td></tr></table>';		yourself! !!PRPierFrame methodsFor: 'accessing' stamp: 'kph 9/8/2006 15:49' prior: 36218509!context	^ context! !!PRPierMain class methodsFor: 'as yet unclassified' stamp: 'kph 10/3/2006 00:51'!isServingAllKernels^ false! !!PRPierMain methodsFor: 'accessing' stamp: 'kph 9/29/2006 06:06' prior: 36453132!context	^ context ifNil: [ context := PRContext kernel: self kernel ]! !!PRPierMain methodsFor: 'accessing' stamp: 'kph 9/29/2006 06:06' prior: 36453486!kernel	^(self application preferenceAt: #kernel) realize! !!PRPierMain methodsFor: 'querying' stamp: 'kph 9/29/2006 00:49'!pathFrom: aRequest 	| path | 	path := aRequest url findTokens: $/. 		path := (ReadStream on: path) upTo: self application name; upToEnd.	^path		inject: String new		into: [ :result :each | result , '/' , each ]. ! !!PRPierMain methodsFor: 'processing' stamp: 'kph 9/28/2006 20:26' prior: 36453603!start: aRequest	| path |	path := self pathFrom: aRequest.	self context		setStructure: (self structureAtPath: path);		setCommand: (self commandFrom: aRequest).	self context isValid		ifFalse: [ context := nil ].	super start: aRequest! !!PRPierMain methodsFor: 'accessing' stamp: 'kph 9/29/2006 01:29'!structureAtPath: aPath	^ PRCurrentContext use: self 	  	during: [ PRPathLookup			start: self kernel root 			path: aPath			onError: [ self kernel root ]		]	! !!PRPierMainAllKernels commentStamp: 'kph 9/29/2006 05:52' prior: 0!An alternative to PRPierMain which serves all kernels using the first element of the path to select which kernel to display. The application preference #kernelName is used as the default root if no path is specified.TODO: book markable urls do not work correctly.!!PRPierMainAllKernels methodsFor: 'accessing' stamp: 'kph 9/29/2006 06:08'!kernel	^ ([ PRKernel instanceNamed: kernelName ] on: Error do: [ super kernel ]) realize ! !!PRPierMainAllKernels methodsFor: 'querying' stamp: 'kph 9/29/2006 06:07'!pathFrom: aRequest 	| path | 	path := aRequest url findTokens: $/. 		path := (ReadStream on: path) upTo: self application name; upToEnd.	kernelName := path size > 0 ifTrue: [ path removeFirst ] ifFalse: [ super kernel name ].	^path		inject: String new		into: [ :result :each | result , '/' , each ]. ! !!PRPierControlPanel commentStamp: 'kph 10/3/2006 02:12' prior: 0!This class provides a seaside configuration tool for pier.!!PRPierControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 9/30/2006 03:04'!initialize 	super initialize ! !!PRPierControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 9/30/2006 02:30'!label^ #pier! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:13'!callWidget: widget  titled: title	PRCurrentContext use: self during: [ 		self call: (widget 	context;							addDecoration: (WAWindowDecoration new title: title);							yourself). 	] ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:06'!confirmSetPersistency  	| old new |		(old := self kernelBeingServed persistency class) = (new := newPersistency class) ifTrue: [ ^false ].	^ self confirm: ('Are you sure you want to replace ', old name , ' with ', new name)  ! !!PRPierControlPanel methodsFor: 'accessing' stamp: 'kph 10/3/2006 15:54'!context| kernel |kernel := self kernelBeingServed.^context := (PRContext kernel: kernel ) 				setUser: kernel adminUser;				yourself.	 	! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:12'!doDeleteKernel: aKernel	self	doubleConfirm: ('delete kernel: ', aKernel name)		thenDo: [ PRKernel instances remove: aKernel ] ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/4/2006 00:27'!doNewKernel	self newKernelName ifNotEmpty: [  		PRKernel instances detect: [ :k | k name = self name ] ifNone: [ PRKernel named: newKernelName ]. 	]! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:11'!doRenameKernel: aKernel	| newName |	newName := self call: (WAInputDialog new label: 'new name').	self usingAppSession: [ 		[ self kernelBeingServed persistency renameKernelTo: newName ] 			on: Error 			do: [ :e | self inform: 'Rename failed: ', e messageText ]. 	]. ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:10'!doSetKernelToServeTo: k	(k isKindOf: PRKernel)		ifTrue: [ application preferenceAt: #kernel put: k.				 application preferenceAt: #mainClass put: PRPierMain ]		ifFalse: [ application preferenceAt: #mainClass put: PRPierMainAllKernels ].! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:09'!doSetPersistency 	| kernel |	kernel := self kernelBeingServed.	self usingAppSession: [ 		[ 			newPersistency := kernel persistency exportTo: newPersistency		] 		on: Error 		do: [ :e | ^self error:  'Conversion failed: ', e messageText ].	].	(self confirm: 'Conversion succeeded, commit?') 		ifFalse: [ self usingAppSession: [ newPersistency discarded ]. ^self  ].	self usingAppSession: [  		kernel persistency: newPersistency.	].	"ensure no-one can use stale data"	self application clearHandlers! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/3/2006 15:07'!done^self answer! !!PRPierControlPanel methodsFor: 'utilities' stamp: 'kph 9/30/2006 03:24'!doubleConfirm: message thenDo: aBlock((self confirm: 'Are you sure you want to ', message) and: 	[ self confirm: 'Are you REALLY sure you want to ', message ])	ifTrue: [ 				^aBlock value.	].! !!PRPierControlPanel methodsFor: 'accessing' stamp: 'kph 10/4/2006 00:24'!initializeselections :=  Dictionary new.! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:02'!isApplicationServingAllKernels	^ (application preferenceAt: #mainClass) isServingAllKernels 			 ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:01'!kernelBeingServed	^ self isApplicationServingAllKernels 		ifTrue: [ 'All Kernels' ] 		ifFalse: [ application preferenceAt: #kernel ]. ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:17'!manageGroups	self callWidget: PUGroupsWidget new		titled: 'Groups for ', self kernelBeingServed asString! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:18'!managePasswords 	self callWidget: #PUChangePasswordWidget new			   titled: 'Change Password for user in ', self kernelBeingServed asString			 ! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:15'!manageSystem	self callWidget: PUSystemWidget new		titled: 'System'! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/19/2006 01:17'!manageUsers	self callWidget: PUUsersWidget new 		titled: 'Users for ', self kernelBeingServed asString! !!PRPierControlPanel methodsFor: 'accessing' stamp: 'kph 10/4/2006 00:25'!newKernelName^newKernelName ifNil: [ '' ]! !!PRPierControlPanel methodsFor: 'accessing' stamp: 'kph 10/4/2006 00:26'!newKernelName: aStringnewKernelName := aString! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/19/2006 01:02'!renderContentOn: htmlhtml form: [		self renderKernelSelectorOn: html.  		 	html break.		self isApplicationServingAllKernels ifFalse: [		self renderManageUsersOn: html.		html break.			self renderPersistencyOn: html.		html break.	].		self renderKernelsOn: html.	self renderMiscOn: html.	html horizontalRule. 	html submitButton on:#done of: self.].! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/3/2006 20:24'!renderKernelInstance: kernel on: html | |html tableData: [ html text: kernel name ].html tableData: [ 		html small: [ html anchor callback: [ self doDeleteKernel: kernel ] ; text: '(delete)' ] ]. html tableData: [ 	html text:  kernel persistency class.].  ! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/19/2006 01:02'!renderKernelSelectorOn: html | list |html heading level: 4; with: 'Serving:'.list := PRKernel instances asOrderedCollection.list add: 'All Kernels'.html select	selected: self kernelBeingServed;	list: list;	beSubmitOnChange;	callback: [ :k | self doSetKernelToServeTo: k ].self isApplicationServingAllKernels ifFalse: [ 	html space.		html small: [ 		html anchor callback: [ self doRenameKernel: self kernelBeingServed ];					text: '(rename)'.	]].! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/4/2006 00:26'!renderKernelsOn: htmlhtml heading level:4 ; with: 'Kernels:'.html table id: 'kernels'; with: [	PRKernel instances  do: [ :item | 		html tableRow: [			self renderKernelInstance: item on: html		].	].].html textInput size: 10;	 on: #newKernelName of: self. 	html submitButton callback: [ self doNewKernel ] ; text: 'New Kernel'.! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/19/2006 01:18'!renderManageUsersOn: html 	(self kernelBeingServed respondsTo: #users) ifFalse: [ ^self ].	html heading level: 4; with: 'Security:'.	html submitButton on: #manageUsers of: self.	html submitButton on: #manageGroups of: self.	html submitButton on: #managePasswords of: self.	  	! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/18/2006 12:53'!renderMiscOn: htmlSmalltalk at: #PUSystemWidget ifAbsent: [ ^self ].html heading level: 4; with: 'System:'.html submitButton on: #manageSystem of: self. 	  	! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/3/2006 02:00'!renderPRFilePersistency: persistency kernel: kernel on: html html text: ' directory: '.html textInput 	size: 25; 	value: persistency directory fullName;	callback: [ :v | persistency setDirectory: 			(FileDirectory on: (FileDirectory default fullNameFor: v)) ];	yourself.^true! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/3/2006 02:00'!renderPRImagePersistency: persistency kernel: kernel on: html html text: ' image: '.html text: SmalltalkImage current imageName.^true! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/4/2006 00:14'!renderPersistency: persistency kernel: kernel on: html| selector | persistency ifNil: [ ^false ].selector := ('render', persistency class name, ':kernel:on:') asSymbol.^(self respondsTo: selector) ifTrue: [ self perform: selector with: persistency with: kernel with: html ]	ifFalse: [ true ]  ! !!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/19/2006 01:07'!renderPersistencyOn: html | selected | self kernelBeingServed ifNil: [ ^self ].html heading level: 4; with: 'Persistency:'.selected :=  self kernelBeingServed persistency.html select 		list: (PRPersistency allSubclasses);		selected: (newPersistency ifNil: [ selected ]) class ;		callback: [ :chosenPersistencyClass | 			newPersistency := (chosenPersistencyClass = selected class) 				ifTrue: [ nil ]				ifFalse: [ chosenPersistencyClass new ]			];		beSubmitOnChange;		yourself.	  	(( selected class ~= newPersistency class)		and: [ self renderPersistency: newPersistency kernel: self kernelBeingServed on: html ]) 			ifTrue: [ 					html submitButton callback: [ self confirmSetPersistency ifTrue: [ self doSetPersistency ] ]; text: 'Migrate'.			].^true		 ! !!PRReferencesWidget methodsFor: 'accessing' stamp: 'kph 9/28/2006 20:05' prior: 36238364!unfilteredItems	^ (Array streamContents: [ :stream |		PRIncomingReferences			from: self context root			to: self context structure			do: [ :each | stream nextPut: each owner ] ])				asSet! !PRPierMain removeSelector: #structureFrom:!"Pier-Seaside"!!PRPersistencyTest commentStamp: 'kph 10/4/2006 19:56' prior: 0!For persistency tests we do not bypass PRKernel instances, instead we use kernels prefixed with '####'.!!PRFilePersistencyTest class methodsFor: 'testing' stamp: 'kph 10/5/2006 21:21'!isAbstract	^ false! !!PRFilePersistencyTest methodsFor: 'private' stamp: 'kph 10/5/2006 21:21'!actualClass	^ PRFilePersistency! !!PRImagePersistencyTest class methodsFor: 'testing' stamp: 'kph 10/5/2006 21:21'!isAbstract	^ false! !!PRImagePersistencyTest methodsFor: 'private' stamp: 'kph 10/5/2006 21:21'!actualClass	^ PRImagePersistency! !!PRNullPersistencyTest class methodsFor: 'testing' stamp: 'kph 10/5/2006 21:21'!isAbstract	^ false! !!PRNullPersistencyTest methodsFor: 'private' stamp: 'kph 10/5/2006 21:21'!actualClass	^ PRNullPersistency! !!PRPersistencyTest class methodsFor: 'testing' stamp: 'kph 10/5/2006 21:21'!isAbstract	^ true! !!PRPersistencyTest class methodsFor: 'nil' stamp: 'kph 10/4/2006 11:28'!shouldInheritSelectors^true! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/5/2006 21:21'!actualClass	^ PRPersistency! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/4/2006 20:07'!kernelNames^PRKernel instances collect: [ :k | k name ].! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/4/2006 20:04'!setUpkernel := PRKernel named: '####test'.! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/4/2006 20:03'!tearDownPRKernel instances removeAll: (PRKernel instances select: [ :k | k name beginsWith: '####' ]).! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/4/2006 20:19'!testRenameKernel	kernel persistency renameKernelTo: '####new'.	self assert: kernel name = '####new'.	self assert: (kernel == (PRKernel instanceNamed: '####new')).	self assert: (self kernelNames includes: '####new').	self deny: (self kernelNames includes: '####test'). ! !!PRPersistencyTest methodsFor: 'private' stamp: 'kph 10/4/2006 20:15'!testRenameKernelFailDueToNameTaken	| k | 	k := PRKernel named: '####new'.	self should: [ kernel persistency renameKernelTo: '####new' ] raise: Error.	self assert: (k == (PRKernel instanceNamed: '####new') ) ! !"Pier-Tests"!!PRPierControlPanel methodsFor: '*pier-magma' stamp: 'kph 10/8/2006 04:46'!deleteRepositoryKernel: kernelNameself doubleConfirm: ('delete kernel from the repository: ',  kernelName)	thenDo: [ 				self psuedoAppSession commit: [ self session pier removeKey: kernelName ]		].! !!PRPierControlPanel methodsFor: '*pier-magma' stamp: 'kph 10/8/2006 04:46'!renderPRMagmaPersistency: persistency kernel: kernel on: html| persistedKernel |"is database configured?" [ persistedKernel := self psuedoAppSession pier at: kernel name ifAbsent: [ false ] ]	on: Error 	do: [ 		html 	text: 'not yet configured to use Magma '.		html	anchor callback: [ self call: (self application configurationComponent) ];						text: '(configure)'. 		^false	].(persistedKernel = false) ifTrue: [ 	html text: 'Kernel not in repository, this kernel will be persisted'  ] ifFalse: [ 	html text: 'Kernel is already in the repository '.	html small: [ html anchor callback: [self deleteRepositoryKernel: kernel name ]; text: '(delete)' ].	html text: ' will use data from repository'.].^true! !!PRStructure methodsFor: '*pier-magma' stamp: 'kph 9/25/2006 04:20'!maPreserialize"ensure that there are no empty PRChildren persisted sincereading empties back in generates needless database realisations."| childrenDecoration | childrenDecoration := self decorationOfClass: self childrenDecorationClass ifAbsent: [ ^self ].childrenDecoration isEmpty ifTrue: [	self removeDecoration: childrenDecoration.].! !!PRStructure methodsFor: '*pier-magma' stamp: 'kph 9/25/2006 04:15'!maWantsPreSerialization 	^ true! !!PRMagmaRepository commentStamp: '<historical>' prior: 0!I am used as the root object in a magma repository. I am subclassed from PRObject so that I may have properties.----To Create Repository:There is a GUI provided in the Magma-seaside package which is available within seaside/config to create a repository.To manually create a repository directory called 'magma-pier' in the default directory:MagmaRepositoryController create: 'magma-pier' root: PRMagmaRepository new.Again there is a GUI available in the 'MagmaControlPanel' for persisting PRKernels.Manually we tell the default repository to persist an existing pier kernel referenced by its name like so.  | session |session := MagmaSession openLocal: 'magma-pier'.session connectAs: 'local-squeak'.session commit: [ PRMagmaRepository persist: (PRKernel instanceNamed: 'home').].session disconnectAndClose.The existing persistence structure is migrated into the magma repository. The framework for acheiving this is provided in the protocol 'translating'. Although at present this does nothing, it is here in order to allow PRMagmaPersistency to tweak the model that it it persisting. For example we may choose to use indexed MagmaCollections to store the history. The Pier framework need not be aware of any Magma specifics, hence the double dispatch of exportToMagma methods which refer back to Magma specific importFrom methods on PRMagmaPersistency. !!PRMagmaRepository class methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 02:51'!isAbstract^false! !!PRMagmaRepository methodsFor: 'configuration' stamp: 'kph 9/28/2006 03:35'!buildReadStrategyOn: strategy"set the read strategy for this application"strategy minimumDepth: 0;	"	forVariableNamed: 'store' onAny: PRMagmaRepository readToDepth: 2 ;"		forVariableNamed: 'kernel' onAny: PRImagePersistency readToDepth: 1;		onAny: PRKernel readToDepth: 1 ;		forVariableNamed: 'decorations' onAny: PRDecorated readToDepth: 1; 		forVariableNamed: 'title' onAny: PRStructure readToDepth: 1; 		forVariableNamed: 'children' onAny: PRChildren readToDepth: 			(self readPathSkeletonInOneHit ifTrue: [ 1 ] ifFalse: [ 0 ]);		onAny: PRDocumentItem readToDepth: 1; "reads all page items in one hit"		onAny: PRComponent readToDepth: 1;yourself.! !!PRMagmaRepository methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 05:24'!magmaControlPanelOn: magmaSession^PRMagmaControlPanel on: magmaSession! !!PRMagmaRepository methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 05:30'!persist: kernel  "we make a new kernel instance to go into the repository,we assign its persistency manager, and root structure.This process includes an opportunity to munge its model if neededor to import from another persistency scheme.Then we turn the image PRKernel into a stub which is used to obtain the persisted kernel via #realize."| persistedKernel | 	persistedKernel := PRKernel new name: kernel name; yourself.	persistedKernel persistency: ( kernel persistency exportToMagma: PRMagmaPersistency new ).	persistedKernel root: kernel root.	store at: kernel name put:  kernel persistency.	"stub out image kernel"	kernel persistency: PRMagmaPersistency new.	kernel root: nil.! !!PRMagmaRepository methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 10:24'!pier"note store is deprecated in favour of pier, this method aims to facilitate migration of earlier repositories"^pier ifNil: [ pier := store ifNil: [ Dictionary new ] ]! !!PRMagmaRepository methodsFor: 'configuration' stamp: 'kph 9/23/2006 16:03'!readPathSkeletonInOneHit"the path skeleton is all of the data needed to traverse the heirarchical path of the pier kernel - if this is set to false then each level down in the path traversal will be a separate object realisation - this may be desireable for small to medium sizred wiki's"^false! !!PRObject methodsFor: '*pier-magma' stamp: 'kph 9/14/2006 02:47'!magmaCopy^ self shallowCopy postMagmaCopy! !!PRObject methodsFor: '*pier-magma' stamp: 'kph 9/29/2006 01:00'!withPersistenceDo: aBlock| context |(context := PRCurrentContext value) ifNil: [ ^nil ].^ aBlock value: context kernel persistency.! !!PRMagmaPersistencyTest commentStamp: 'kph 10/6/2006 04:42' prior: 0!Testing PRMagmaPersistence with a real magma database via MagmaAsTestResource.Fixture is the kernel, persisted in the repository.!!PRMagmaPersistencyTest class methodsFor: 'testing' stamp: 'kph 10/4/2006 11:34'!isAbstract	^ false! !!PRMagmaPersistencyTest class methodsFor: 'testing' stamp: 'kph 10/6/2006 06:39'!resources^Array with: TestResourceMagma "^Array with: TestResourceMockMagma" ! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/5/2006 21:21'!actualClass	^ PRMagmaPersistency! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 22:24'!application^ self! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/7/2006 01:31'!fullyRealized: anObject ^self fullyRealized: anObject visited: Set new.! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/7/2006 02:33'!fullyRealized: anObject visited: aSet anObject ifNil: [ ^true ]. (aSet includes: anObject) ifTrue: [ ^true ].(anObject maIsMutatingProxy) ifTrue: [ ^false ].aSet add: anObject.1 to: anObject class instSize do: [ :n | (self fullyRealized: (anObject instVarAt: n) visited: aSet) ifFalse: [ ^false ] ].^true! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/10/2006 09:24'!initializeRepositoryrepository := self magma initializeRoot: PRMagmaRepository new.! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 06:20'!magma^self class resources first current! !!PRMagmaPersistencyTest methodsFor: 'application-stub' stamp: 'kph 10/6/2006 22:22'!preferenceAt: keykey == #location ifTrue: [ ^ self magma location ].! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 04:29'!runCaseWACurrentSession use: (self session) during: [ super runCase ].! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 04:30'!runCaseAsFailure: semaWACurrentSession use: (self session) during: [ super runCaseAsFailure: sema ].! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 22:16'!session ^session ifNil: [ 	session := (WAMagmaSession application: (self application)) setMagmaSession: (self magma session); yourself ]! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/7/2006 00:37'!setUp	super setUp. 	self initializeRepository.	kernel persistency: (kernel persistency exportTo: PRMagmaPersistency new).			self session stubOut: repository.	repository := nil.! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/6/2006 04:48'!tearDownsuper tearDown.! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/8/2006 04:44'!testFromPRNullPersistency"setUp begins with a kernel having PRNullPersistency exports it to PRMagmaPersistency"| p pier |pier := self session pier.p := pier at: '####test'.self assert: (p class == PRMagmaPersistency).self assert: (p kernel name = '####test').self assert: (kernel hasRoot not).self assert: p kernel root notNil.self assert: (kernel realize == p kernel).! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/11/2006 04:05'!testPathLookupCache| needle |needle := PRPathLookup			start: kernel realize root 			path: '/information/syntax'.self assert: ( needle title = 'Syntax' ).self assert: false.! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/8/2006 04:45'!testRenameKernel	super testRenameKernel.	self assert: (kernel realize == (self session pier at: '####new') kernel).	self assert: kernel realize name = '####new'.	self assert: (self session pier at: '####test' ifAbsent: [ true ]).! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/8/2006 04:45'!testRenameKernelFailDueToAlreadyPersisted		 	self session pier at: '####new' put: (PRKernel new name: '####new'; yourself).	self should: [ kernel persistency renameKernelTo: '####new' ] raise: Error. ! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/8/2006 04:45'!testRenameKernelFailDueToNameTaken	super testRenameKernelFailDueToNameTaken.	self shouldnt: [ self session pier at: '####test' ] raise: Error.	self should: [ self session pier at: '####new' ] raise: Error. ! !!PRMagmaPersistencyTest methodsFor: 'private' stamp: 'kph 10/8/2006 04:45'!testToPRNullPersistency | p pier | kernel persistency: (kernel persistency exportTo: PRNullPersistency new). pier := self session pier.p := pier at: '####test'.self assert: (p class == PRMagmaPersistency).self assert: (p kernel name = '####test').self assert: (kernel hasRoot).self assert: (kernel persistency class == PRNullPersistency).self assert: (kernel realize == kernel).self assert: (self fullyRealized: kernel). ! !!PRBackupToMagmaPersistency methodsFor: 'as yet unclassified' stamp: 'kph 10/11/2006 02:25'!initialize	super initialize.	duration := 2 minutes! !!PRBackupToMagmaPersistency methodsFor: 'as yet unclassified' stamp: 'kph 10/6/2006 10:33'!session| session |session := WACurrentSession value.(session respondsTo: #magmaSession) ifFalse: [ ^ self error: 'Application not configured to use Magma' ].^session! !!PRBackupToMagmaPersistency methodsFor: 'as yet unclassified' stamp: 'kph 10/11/2006 02:26'!setKernel: aKernel	super setKernel: aKernel.	aKernel ifNotNil: [ self snapshot ].! !!PRBackupToMagmaPersistency methodsFor: 'as yet unclassified' stamp: 'kph 10/11/2006 02:25'!snapshotchanged := false.self session commit: [ self session pier at: self kernel name put: self ].! !!PRMagmaControlPanel class methodsFor: 'repository init' stamp: 'kph 10/8/2006 04:34'!copy: kernelName to: repositoryPath"not tested!!""assuming that a kernel is available in memory, or online in another repository. deep copy this kernel into the new repository.e.g.PRMagmaRepository create: 'backup'.PRMagmaRepository copy: 'pier' to: 'backup'."|  kernel newKernel session |kernel := PRKernel instanceNamed: kernelName.session := self classMagmaSession openLocal:repositoryPath.session connectAs: 'copy'. kernel critical: [ newKernel := kernel veryDeepCopy ].session commit: [ session root pier at: newKernel name put: newKernel persistency].session disconnect ;		closeRepository" "! !!PRMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 01:56'!magmaRootClass^ PRMagmaRepository ! !!PRMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 9/9/2006 00:48'!magmaRootDescription^ 'The Pier Content Management System uses a PRMagmaRepository as a root object. This maintains a Dictionary of PRMagmaPersistency''s, and a Dictionary of properties'! !!PRMagmaControlPanel class methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 02:31'!on: magmaSession^self new	magmaSession: magmaSession;	yourself.! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 05:13'!deleteImageKernel: kself doubleConfirm: ('delete kernel: ', k name)	thenDo: [ PRKernel instances remove: k ] ! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 10/8/2006 04:41'!deleteRepositoryKernel: nameself doubleConfirm: ('delete kernel from the repository: ',  name)	thenDo: [ 				magmaSession commit: [ magmaSession pier removeKey: name ]		].! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 05:13'!doubleConfirm: message thenDo: aBlock((self confirm: 'Are you sure you want to ', message) and: 	[ self confirm: 'Are you REALLY sure you want to ', message ])	ifTrue: [ 				^aBlock value.	].! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 05:08'!loadKernel: name PRKernel instances detect: [ :k | k name = name ] ifNone: [ ^magmaSession root makeLocalStub: name ].self inform: 'Kernel named: ', name, ' already exists.'.! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 02:59'!magmaSession: msmagmaSession := ms! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/19/2006 18:03'!persist: kernelkernel critical: [ magmaSession commit: [ kernel root. magmaSession root persist: kernel ] ]! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 10/8/2006 04:34'!renderContentOn: htmlhtml heading level: 3; with: 'Pier-Magma Control Panel'.magmaSession ifNil: [ ^self renderNoMagmaSessionOn: html ].html table: [	html tableRow: [  	     html tableData: ["			self renderOn: html table: 'image' with: PRKernel instances using: [:item | self renderKernelInstance: item on: html ]."						html textInput size: 10;				 on: #text of: self. 			html submitButton callback: [ PRKernel named: self text ] ; text: 'new kernel'.		].		html tableData: [			self renderOn: html table: 'repository' with: self repository pier using: [:item | self renderRepository: item on: html ].		].	]]! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 10/7/2006 15:50'!renderKernelInstance: k on: htmlhtml tableData: [ html text: k name ].html tableData: [ 		html text: '(',k persistency name, ')'.].html tableData: [ 		html small: [ html anchor callback: [ self deleteImageKernel: k] ; text: '(delete)' ] ].html tableData: [ (k persistency class ~= PRMagmaPersistency) 	ifTrue: [		html submitButton callback: [ self persist: k ] ; text: 'Persist' 	]]! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/19/2006 13:24'!renderNoMagmaSessionOn: html html bold: 'No MagmaSession currently available'.! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 8/21/2006 04:54'!renderOn: html table: title with: items using: aBlockhtml table: [	html tableRow: [		html tableData: [		html tableHeading: [ html text: title ].].	].	items do: [ :item | 		html tableRow: [			 aBlock value: item  		].	].]! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 05:09'!renderRepository: aPersistency on: html| name |name := aPersistency kernel name.html tableData: [ html text: name   ].html tableData: [ 	PRKernel instances detect: [ :k | k name = name ] 	ifNone: [  		html submitButton callback: [self loadKernel: name ]; text: 'load'.	].	html small: [ html anchor callback: [self deleteRepositoryKernel: name ]; text: '(delete)' ].	]! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 8/21/2006 04:53'!rendererClass^ WARenderCanvas.! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 8/24/2006 03:00'!repository^magmaSession root! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/9/2006 14:20'!text^text! !!PRMagmaControlPanel methodsFor: 'as yet unclassified' stamp: 'kph 9/9/2006 14:21'!text:   aStringtext := aString! !!PRContext methodsFor: '*pier-magma' stamp: 'kph 9/14/2006 03:26'!maPreserialize"ensure that properties are always zapped before persisting"	properties := nil.! !!PRContext methodsFor: '*pier-magma' stamp: 'kph 9/14/2006 03:25'!maWantsPreSerialization 	^ true! !!PRContext methodsFor: '*pier-magma' stamp: 'kph 9/14/2006 03:27'!postMagmaCopy	properties := nil.	 	self setCommand: self command magmaCopy.! !!PRCommand methodsFor: '*pier-magma' stamp: 'kph 9/14/2006 02:28'!postMagmaCopy	answer ifNotNil: [ answer := answer magmaCopy ].! !!PRCachedPath class methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 10:58'!path: aString structure: aStructure^self new 	setFullPath: aString structure: aStructure; 	yourself.! !!PRCachedPath methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 10:58'!fullPath^fullPath! !!PRCachedPath methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 10:58'!setFullPath: aString structure: aStructurefullPath := aString.structure := aStructure.! !!PRCachedPath methodsFor: 'as yet unclassified' stamp: 'kph 10/10/2006 10:57'!structure^structure! !!PRKernel methodsFor: '*pier-magma' stamp: 'kph 9/24/2006 03:01'!maPreserialize"ensure that mutex is zapped before persisting, then at least it will be in a predictable state when relaised."	mutex := nil.! !!PRKernel methodsFor: '*pier-magma' stamp: 'kph 9/24/2006 03:02'!maWantsPreSerialization 	^ true! !!WAMagmaSession methodsFor: '*pier-magma' stamp: 'kph 9/15/2006 14:53'!magmaAbortOnRequest.magmaSession ifNotNil: [ magmaSession abort. ].! !!WAMagmaSession methodsFor: '*pier-magma' stamp: 'kph 10/8/2006 04:47'!pier^self magmaSession root pier! !!WAMagmaSession methodsFor: '*pier-magma' stamp: 'kph 9/15/2006 14:56'!responseForRequest: aRequest	self magmaAbortOnRequest.^super responseForRequest: aRequest! !!PRMagmaPersistency commentStamp: 'kph 9/14/2006 03:33' prior: 0!I am stored in the PRMagmaRepository as the base object for each PRKernel.I store the current #kernelI store a historical #snapshotI store a log of changes, a collection of #contexts, whose commands can be replayed to obtain a complete history.----In Pier, PRContext objects may cache #properties in relation to the current seaside display context session and components. Persisting these runtime non-model objects is not a good idea since they may include references to the current magma session which will break the persistency. To avoid this we send #magmaCopy to all instances of PRContext, before saving them into the log of #contexts. This also applies to the 'context's command's answer context'.If one of these persisted contexts is used and by chance has its properties repopulated, then PRContext-#maPreSerialize zaps #properties as well before the object would be serialised and persisted again. !!PRMagmaPersistency class methodsFor: 'as yet unclassified' stamp: 'kph 10/4/2006 11:36'!isAbstract^false! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/8/2006 04:41'!discarded  self session commit: [ self session pier removeKey: self kernel name ].! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 9/29/2006 06:18'!do: aBlock 	 contexts do: [ :each | aBlock value: (each setKernel: self kernel) ]! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 9/28/2006 20:40'!doing: aCommand critical: aBlock"this is the essential 'write' interface from pier to magma."self kernel critical: [ self session commit: aBlock ].! !!PRMagmaPersistency methodsFor: 'translation' stamp: 'kph 10/6/2006 09:48'!exportTo: aPRPersistency"at some point we need to realise the whole kernel into memory, at least,  possibly history too if the new class wants it if we do it"^aPRPersistency fromPRMagmaPersistency: self ! !!PRMagmaPersistency methodsFor: 'translation' stamp: 'kph 10/11/2006 03:58'!exportToPRPersistency: aPRPersistency"at some point we need to realise the whole kernel into memory, at least,  possibly history too if the new class wants it if we do it"	| persisted newKernel |	newKernel := (PRKernel new) name: self kernel name; yourself.	newKernel persistency: aPRPersistency. 	"obtain a copy of the real kernel from magma"	self usingReadAllMagmaSessionDo: [ :magmaSession |		persisted := magmaSession root pier at: self kernel name.		newKernel root: persisted kernel root.			].^aPRPersistency! !!PRMagmaPersistency methodsFor: 'translation' stamp: 'kph 10/8/2006 04:42'!fromPRPersistency: aPersistency| persistedKernel myName | 	myName := aPersistency kernel name.	self session root ifNil: [ 		self session commit: [ self session root: PRMagmaPersistency new ].	].	self session pier at: myName ifAbsent: [ 		persistedKernel := PRKernel new name: myName; yourself.		persistedKernel persistency: self.		persistedKernel root: aPersistency kernel root.		self session commit: [self session root pier at: myName put: self].	].	^ PRMagmaPersistency new setKernel: (PRKernel new name: myName)		 ! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/7/2006 02:40'!initializecontexts := OrderedCollection new.! !!PRMagmaPersistency methodsFor: 'cache' stamp: 'kph 9/29/2006 00:15'!internalLink: aLink"we are informed of an internal link so we may cache it" ! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 9/14/2006 02:11'!log: aContext	 contexts add: aContext magmaCopy ! !!PRMagmaPersistency methodsFor: 'cache' stamp: 'kph 9/29/2006 00:14'!pathLookup: aString startingAt: aStructure fallback: aBlock  ^nil! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/11/2006 03:46'!paths^paths ifNil: [ 	paths := MagmaCollection new addIndex:			((MaSearchStringIndex attribute: #fullPath) keySize: 128; yourself);			yourself.].! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/8/2006 04:42'!realizeKernel"I return the kernel instance from the repository under my kernel's name (my own kernel is likely to be a stub)" | persisted |persisted := self session 			pier at: (self kernel name) 			ifAbsent: [ self error: ('not found in database: ', self kernel name) ].^persisted kernel! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/8/2006 04:42'!renameKernelTo: newName	| oldName p pier okToRename |	oldName := self kernel name.	pier := self session pier.	(pier at: newName ifAbsent: [ true ]) ~= true 		ifTrue: [ self error: 'name already exists in persistent pier' ]. 	okToRename := [ PRKernel instanceNamed: newName ] on: Error do: [ true ].	okToRename == true ifFalse: [ self error: 'name already exists in PRKernel instances' ].	self session commit: [		p := pier at: newName put: (pier at: oldName). 		p kernel name: newName.		pier removeKey: oldName.			self kernel name: newName.	].! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 9/29/2006 06:19'!reverseDo: aBlock 	contexts reverseDo: [ :each | aBlock value: (each setKernel: self kernel) ]! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/6/2006 09:33'!session| session |session := WACurrentSession value.(session respondsTo: #magmaSession) ifFalse: [ ^ self error: 'Application not configured to use Magma' ].^session! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 10/6/2006 23:59'!setKernel: aKernel	"when we are removed from persistency nil out the kernel's root (it should be nil anyway)	so that the new persistency scheme will supply the kernel with data"	aKernel ifNil: [ 		kernel root: nil.	] ifNotNil: [			aKernel root: nil. "nil out the kernel's data since we have it persisted"	].		kernel := aKernel.! !!PRMagmaPersistency methodsFor: 'transactions' stamp: 'kph 9/29/2006 06:23'!snapshot	snapshot := self kernel veryDeepCopy.	contexts := OrderedCollection new! !!PRMagmaPersistency methodsFor: 'translation' stamp: 'kph 10/6/2006 07:21'!usingReadAllMagmaSessionDo: aBlock	 | newMagmaSession |	newMagmaSession := (self session application preferenceAt: #location) newSessionAs: 'pier'.								newMagmaSession readStrategy: (MaReadStrategy new onAny: PRKernel readToDepth: 9999).	[ aBlock value: newMagmaSession ] ensure: [ newMagmaSession disconnect ]. ! !!PRPersistency methodsFor: '*pier-magma' stamp: 'kph 9/30/2006 06:23'!fromPRMagmaPersistency: aMagmaPersistency ^aMagmaPersistency exportToPRPersistency: self  ! !!PRPersistency methodsFor: '*pier-magma' stamp: 'kph 9/29/2006 01:12'!internalLink: aLink"we are informed of an internal link so we may cache it" ! !!PRPersistency methodsFor: '*pier-magma' stamp: 'kph 9/29/2006 01:12'!pathLookup: aString startingAt: aStructure fallback: aBlock  ^nil! !!PRPathLookup class methodsFor: '*pier-magma' stamp: 'kph 9/28/2006 20:46'!noCacheStart: aStructure path: aString ^ self new stream: aString readStream;							lookup: aStructure.	 ! !!PRPathLookup class methodsFor: '*pier-magma' stamp: 'kph 9/28/2006 20:47'!start: aStructure path: aString^(aStructure withPersistenceDo: [ :cache | 	cache 	pathLookup: aString 			startingAt: aStructure 			fallback: [ self noCacheStart: aStructure path: aString ] ]) 				ifNil: [ self noCacheStart: aStructure path: aString ].	 ! !"Pier-Magma"!!PRStructure class methodsFor: '*pier-security' stamp: 'lr 3/9/2006 11:30'!descriptionGroup	^ (MAToOneRelationDescription selector: #group label: 'Group' priority: 120)		classes: (Array with: PUGroup);		yourself! !!PRStructure class methodsFor: '*pier-security' stamp: 'lr 3/9/2006 11:30'!descriptionOwner	^ (MAToOneRelationDescription selector: #owner label: 'Owner' priority: 110)		classes: (Array with: PUUser);		yourself! !!PRStructure methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!group	"Answer the owning-group of the file."	^ self securityDecoration ifNotNilDo: [ :value | value group ]! !!PRStructure methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!owner	"Answer the owning-user of the receiver."	^ self securityDecoration ifNotNilDo: [ :value | value owner ]! !!PRStructure methodsFor: '*pier-security-decorations' stamp: 'lr 3/9/2006 11:30'!securityDecoration	^ self		decorationOfClass: self securityDecorationClass		ifAbsent: [ self securityDecorationClass onStructureAdded: self ]! !!PRStructure methodsFor: '*pier-security-decorations' stamp: 'lr 3/9/2006 11:30'!securityDecorationClass	^ PUSecurity! !!PUGroup class methodsFor: 'accessing-defaults' stamp: 'lr 9/27/2006 11:22'!defaultUsers	^ PRCurrentContext value kernel users! !!PUGroup class methodsFor: 'accessing-description' stamp: 'lr 9/27/2006 11:36'!descriptionUsers	^ (MAMultipleOptionDescription selector: #users label: 'Users' priority: 200)		options: (MADynamicObject on: [ self defaultUsers ]);		componentClass: MAListCompositonComponent;		reference: (PUUser descriptionContainer			add: PUUser descriptionName;			yourself);		beDistinct;		yourself! !!PUGroup class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUGroup methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!includes: anUser	^ self users includes: anUser! !!PUGroup methodsFor: 'initialization' stamp: 'lr 9/27/2006 12:02'!initialize	super initialize.	users := Set new! !!PUGroup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!users	^ users! !!PUGroup methodsFor: 'accessing' stamp: 'lr 9/27/2006 11:42'!users: aCollection	(aCollection copyWithoutAll: self users) do: [ :user | 		(user groups includes: self)			ifFalse: [ user groups add: self ] ].	(self users copyWithoutAll: aCollection) do: [ :user |		(user groups includes: self)			ifTrue: [ user groups remove: self ] ].	users := aCollection asSet! !!PUMember class methodsFor: 'accessing-description' stamp: 'lr 9/27/2006 10:55'!descriptionName	^ (MAStringDescription selector: #name label: 'Name' priority: 100)		beReadonly;		beRequired;		yourself! !!PUMember class methodsFor: 'instance-creation' stamp: 'lr 3/9/2006 11:31'!named: aString	^ self new		setName: aString;		yourself! !!PUMember methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!= anObject	^ self class = anObject class		and: [ self name = anObject name ]! !!PUMember methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ self class hash bitXor: self name hash! !!PUMember methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!name	^ name! !!PUMember methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!PUMember methodsFor: 'initialize-release' stamp: 'lr 3/9/2006 11:31'!setName: aString	name := aString! !!PUUser class methodsFor: 'accessing-defaults' stamp: 'lr 9/27/2006 10:47'!defaultGroups	^ PRCurrentContext value kernel groups! !!PUUser class methodsFor: 'accessing-description' stamp: 'lr 9/27/2006 11:26'!descriptionGroups	^ (MAMultipleOptionDescription  selector: #groups label: 'Groups' priority: 300)		addCondition: [ :value | value notEmpty ] labelled: 'A user has to belong to at least one group';		options: (MADynamicObject on: [ self defaultGroups ]);		componentClass: MAListCompositonComponent;		reference: (PUGroup descriptionContainer			add: PUGroup descriptionName;			yourself);		beDistinct; 		beOrdered;		yourself! !!PUUser class methodsFor: 'accessing-description' stamp: 'lr 9/27/2006 10:41'!descriptionPassword	^ (MAPasswordDescription selector: #password label: 'Password' priority: 200)		beRequired;		yourself! !!PUUser class methodsFor: 'accessing-description' stamp: 'lr 9/27/2006 10:42'!descriptionSuperuser	^ MABooleanDescription selector: #superuser label: 'Superuser' priority: 400! !!PUUser class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUUser methodsFor: 'utilties' stamp: 'lr 9/27/2006 11:54'!addGroup: aGroup	(self groups includes: aGroup)		ifFalse: [ self groups add: aGroup ].	aGroup users add: self! !!PUUser methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!group	^ self groups first! !!PUUser methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!groups	^ groups! !!PUUser methodsFor: 'accessing-readonly' stamp: 'lr 9/27/2006 12:03'!groups: aCollection	self groups do: [ :each | each users remove: self ifAbsent: [ ] ].	aCollection do: [ :each | each users add: self ].	groups := aCollection asOrderedCollection! !!PUUser methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!initialize	super initialize.	groups := OrderedCollection new.	superuser := false! !!PUUser methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isSuperuser	^ self superuser! !!PUUser methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!password	^ String new: 10 withAll: $*! !!PUUser methodsFor: 'accessing' stamp: 'lr 5/17/2006 16:12'!password: aString	self password = aString ifTrue: [ ^ self ].	password := PRCompatibility hashPassword: aString! !!PUUser methodsFor: 'utilties' stamp: 'lr 3/9/2006 11:31'!removeGroup: aGroup	self groups remove: aGroup.	aGroup users remove: self! !!PUUser methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!superuser	^ superuser! !!PUUser methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!superuser: aBoolean	superuser := aBoolean! !!PUUser methodsFor: 'validating' stamp: 'lr 3/9/2006 11:31'!validatePassword: aString	^ aString isEmptyOrNil not		and: [ (PRCompatibility hashPassword: aString) = password ]! !!PUAddPermission methodsFor: 'comparing' stamp: 'lr 9/11/2006 10:17'!= anObject	^ super = anObject		and: [ self structure = anObject structure ]! !!PUAddPermission methodsFor: 'comparing' stamp: 'lr 9/11/2006 10:17'!hash	^ super hash bitXor: self structure hash! !!PUAddPermission methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:16'!label	^ super label , ' ' , self structure label! !!PUAddPermission methodsFor: 'initialization' stamp: 'lr 9/11/2006 10:15'!setStructure: aClass	structure := aClass! !!PUAddPermission methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:16'!structure	^ structure! !!PUPermission class methodsFor: 'accessing-description' stamp: 'lr 9/11/2006 10:40'!descriptionLabel	^ MAStringDescription selector: #label! !!PUPermission class methodsFor: 'testing' stamp: 'lr 9/11/2006 10:10'!isAbstract	^ false! !!PUPermission class methodsFor: 'instance-creation' stamp: 'lr 9/11/2006 10:15'!on: aClass	^ self new		setCommand: aClass;		yourself! !!PUPermission methodsFor: 'comparing' stamp: 'lr 9/11/2006 10:10'!= aCommand	^ self species = aCommand species		and: [ self command = aCommand command ]! !!PUPermission methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:09'!command	"Answer the command class this permission applies to."	^ command! !!PUPermission methodsFor: 'comparing' stamp: 'lr 9/11/2006 10:24'!hash	^ self command hash! !!PUPermission methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:13'!label	"Answer the label this command class is refered to in the user interface."	^ self command label! !!PUPermission methodsFor: 'printing' stamp: 'lr 9/11/2006 10:10'!printOn: aStream	aStream nextPutAll: self label! !!PUPermission methodsFor: 'initialization' stamp: 'lr 9/11/2006 09:56'!setCommand: aClass	command := aClass! !!PUPermission methodsFor: 'testing' stamp: 'lr 9/11/2006 10:59'!validCommand: aCommand	^ self command = aCommand species! !!PRAddCommand class methodsFor: '*pier-security' stamp: 'lr 9/11/2006 10:21'!permissions	^ PRStructure withAllConcreteClasses		collect: [ :each | (PUAddPermission on: self) setStructure: each ]! !!PRAddCommand methodsFor: '*pier-security' stamp: 'lr 9/11/2006 11:13'!permission	^ (PUAddPermission on: self class) setStructure: self type! !!PUSecurityWidget class methodsFor: 'accessing-defaults' stamp: 'lr 9/27/2006 12:22'!defaultCssClass	^ 'box security'! !!PUSecurityWidget class methodsFor: 'testing' stamp: 'lr 9/27/2006 12:16'!isAbstract	^ false! !!PUSecurityWidget class methodsFor: 'accessing' stamp: 'lr 10/11/2006 14:55'!label	^ 'Security Information'! !!PUSecurityWidget methodsFor: 'testing' stamp: 'lr 9/27/2006 12:17'!isVisible	^ self context user notNil! !!PUSecurityWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 12:21'!renderWidgetOn: html	html definitionList: [		html 			definitionTerm: 'User';			definitionData: self context user name.		html			definitionTerm: 'Groups';			definitionData: [				self context user groups					do: [ :each | html render: each name ]					separatedBy: [ html text: ', ' ] ] ]! !!PRWidget methodsFor: '*pier-security-testing' stamp: 'lr 9/27/2006 14:19'!isSuperuser	^ self context user notNil and: [ self context user isSuperuser ]! !!PUGroupsWidget class methodsFor: 'testing' stamp: 'lr 9/27/2006 10:30'!isAbstract	^ false! !!PUGroupsWidget class methodsFor: 'accessing' stamp: 'lr 10/11/2006 14:51'!label	^ 'System Groups'! !!PUGroupsWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:52'!memberClass	^ PUGroup! !!PUGroupsWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:54'!members	^ self context kernel groups! !!PUGroupsWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:32'!remove: aMember	aMember users isEmpty		ifFalse: [ ^ self inform: 'Remove all users before removing a group.' ].	super remove: aMember! !!PUMemberWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:13'!add: aString	| member |	aString isEmptyOrNil 		ifTrue: [ ^ self ].	self members do: [ :each |		each name = aString			ifTrue: [ ^ self inform: 'A member with the name ' , aString printString , ' already exists.' ] ].	member := self 		edit: (self memberClass named: aString)		title: 'Add'.	member ifNil: [ ^ self ].	self members add: member.	self refresh! !!PUMemberWidget methodsFor: 'private' stamp: 'lr 9/27/2006 11:04'!buildReport	| component |	component := MAReport		rows: self members asArray		description: self memberClass description.	self isSuperuser ifTrue: [		component addColumn: (MACommandColumn new			addCommandOn: self selector: #edit: text: 'edit';			addCommandOn: self selector: #remove: text: 'remove';			yourself) ].	^ component! !!PUMemberWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:58'!children	^ Array with: self report	! !!PUMemberWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:13'!edit: aMember	| member |	member := self edit: aMember title: 'Edit'.	member ifNotNil: [ self refresh ].	^ member! !!PUMemberWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 10:50'!edit: aMember title: aString	^ self call: (aMember asComponent		addMessage: aString;		addValidatedForm;		yourself)! !!PUMemberWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:51'!memberClass	self subclassResponsability! !!PUMemberWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:51'!members	self subclassResponsability! !!PUMemberWidget methodsFor: 'events' stamp: 'lr 9/27/2006 12:09'!onChangeContext: aContext	super onChangeContext: aContext.	aContext removeComponentAt: aContext structure! !!PUMemberWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:01'!refresh	self report rows: self members asArray! !!PUMemberWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:17'!remove: aMember	(self confirm: 'Are you sure to remove ' , aMember name printString , '?')		ifFalse: [ ^ nil ].	self members remove: aMember.	self refresh.	^ aMember! !!PUMemberWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 12:12'!renderAddOn: html	self isSuperuser		ifFalse: [ ^ self ].	html break.	html form: [		html textInput			callback: [ :value | self add: value ].		html submitButton			text: 'add' ]! !!PUMemberWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 10:59'!renderReportOn: html	html render: self report! !!PUMemberWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 11:01'!renderWidgetOn: html	self renderReportOn: html.	self renderAddOn: html! !!PUMemberWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:58'!report	^ report ifNil: [ report := self buildReport ]! !!PUUsersWidget class methodsFor: 'testing' stamp: 'lr 9/27/2006 10:30'!isAbstract	^ false! !!PUUsersWidget class methodsFor: 'accessing' stamp: 'lr 10/11/2006 14:51'!label	^ 'System Users'! !!PUUsersWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:52'!memberClass	^ PUUser! !!PUUsersWidget methodsFor: 'accessing' stamp: 'lr 9/27/2006 10:54'!members	^ self context kernel users! !!PUUsersWidget methodsFor: 'actions' stamp: 'lr 9/27/2006 11:16'!remove: aMember	(super remove: aMember)		ifNotNil: [ aMember groups: #() ]! !!PUSystemWidget class methodsFor: 'testing' stamp: 'lr 9/27/2006 14:18'!isAbstract	^ false! !!PUSystemWidget class methodsFor: 'accessing' stamp: 'lr 9/27/2006 14:18'!label	^ 'System'! !!PUSystemWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 14:21'!renderActionsOn: html	html form: [ 		html submitButton			callback: [ Smalltalk garbageCollect ];			text: 'Garbage Collect'.		html submitButton			callback: [ self context kernel persistency snapshot ];			text: 'Snapshot' ]! !!PUSystemWidget methodsFor: 'rendering' stamp: 'lr 9/27/2006 14:20'!renderWidgetOn: html	html preformatted: SeasidePlatformSupport vmStatisticsReportString.	self isSuperuser ifTrue: [ self renderActionsOn: html ]! !!PRCommandTest methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!adminGroup	^ self kernel adminGroup! !!PRCommandTest methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!adminUser	^ self kernel adminUser! !!PRCommandTest methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!bloggerGroup	^ self kernel groups		detect: [ :each | each name = 'blogger' ]		ifNone: [ self kernel groups add: self bloggerGroupInstance ]! !!PRCommandTest methodsFor: '*pier-security-private' stamp: 'lr 3/9/2006 11:30'!bloggerGroupInstance	^ PUGroup named: 'blogger'! !!PRCommandTest methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!bloggerUser	^ self kernel users		detect: [ :each | each name = 'james' ]		ifNone: [ self kernel users add: self bloggerUserInstance ]! !!PRCommandTest methodsFor: '*pier-security-private' stamp: 'lr 3/9/2006 11:30'!bloggerUserInstance	^ (PUUser named: 'james')		addGroup: self bloggerGroup;		password: 'bottom';		yourself! !!PUChangeGroupTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeGroupTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!actualClass	^ PUChangeGroup! !!PUChangeGroupTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!testGroup	self command		with: true; all: true; hidden: true;		group: self bloggerGroup.	self command execute.	self assert: self structure group = self bloggerGroup.	self assert: self hidden group = self bloggerGroup.	self assert: self child group = self bloggerGroup! !!PUChangeOtherTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeOtherTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!actualClass	^ PUChangeOther! !!PUChangeOwnerTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeOwnerTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!actualClass	^ PUChangeOwner! !!PUChangeOwnerTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!testOwner	self command		with: true; all: true; hidden: true;		owner: self bloggerUser.	self command execute.	self assert: self structure owner = self bloggerUser.	self assert: self hidden owner = self bloggerUser.	self assert: self child owner = self bloggerUser! !!PUChangeSecurityTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!actualClass	^ PUChangeSecurity! !!PUChangeSecurityTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!child	^ child ifNil: [ child := self childInstance ]! !!PUChangeSecurityTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!childInstance	^ PRPage named: 'child'! !!PUChangeSecurityTest methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!hidden	^ hidden ifNil: [ hidden := self hiddenInstance ]! !!PUChangeSecurityTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!hiddenInstance	^ (PRPage named: 'hidden')		addDecoration: PRHider new;		yourself! !!PUChangeSecurityTest methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:42'!permissions	^ Set new		addAll: PRAddCommand permissions;		addAll: PRRemoveCommand permissions;		yourself! !!PUChangeSecurityTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!structureInstance	^ super structureInstance		addChild: self child;		addChild: self hidden;		yourself! !!PUChangeSecurityTest methodsFor: 'testing-operations' stamp: 'lr 3/9/2006 11:30'!testOperationAdd	self command		with: true; all: true; hidden: true;		operator: #add; permissions: self permissions.	self command execute.	self assert: ((self command accessor read: self structure)		includesAllOf: self permissions).	self assert: ((self command accessor read: self hidden)		includesAllOf: self permissions).	self assert: ((self command accessor read: self child)		includesAllOf: self permissions)! !!PUChangeSecurityTest methodsFor: 'testing-operations' stamp: 'lr 3/9/2006 11:30'!testOperationRemove	self command		with: true; all: true; hidden: true;		operator: #remove; permissions: self permissions.	self command execute.	self deny: ((self command accessor read: self structure)		includesAnyOf: self permissions).	self deny: ((self command accessor read: self hidden)		includesAnyOf: self permissions).	self deny: ((self command accessor read: self child)		includesAnyOf: self permissions)! !!PUChangeSecurityTest methodsFor: 'testing-operations' stamp: 'lr 3/9/2006 11:30'!testOperationSet	self command		with: true; all: true; hidden: true;		operator: #set; permissions: self permissions.	self command execute.	self assert: (self command accessor read: self structure)		= self permissions.	self assert: (self command accessor read: self hidden)		= self permissions.	self assert: (self command accessor read: self child)		= self permissions! !!PUChangeSecurityTest methodsFor: 'testing-operations' stamp: 'lr 3/9/2006 11:30'!testOperationUnchanged	| structurePermission hiddenPermissions childPermissions |	structurePermission := (self command accessor read: self structure)		copy.	hiddenPermissions := (self command accessor read: self hidden)		copy.	childPermissions := (self command accessor read: self child)		copy.	self command		with: true; all: true; hidden: true;		operator: nil; permissions: self permissions.	self command execute.	self assert: (self command accessor		read: self structure) = structurePermission.	self assert: (self command accessor		read: self hidden) = hiddenPermissions.	self assert: (self command accessor		read: self child) = childPermissions! !!PULoginTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PULoginTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!actualClass	^ PULogin! !!PULoginTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:30'!testIsLogged	self deny: self command isLogged! !!PULoginTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:19'!testLoginAdmin	self assert: self command context user isNil.	self command		username: self adminUser name;		password: 'pier'.	self		shouldnt: [ self command execute ]		raise: PUInvalidLogin.	self assert: self command user = self adminUser.	self assert: self command answer user = self adminUser.	self assert: self command answer command class = PRViewCommand.	self assert: self command context user isNil! !!PULoginTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:19'!testLoginBlogger	self assert: self command context user isNil.	self command		username: self bloggerUser name;		password: 'bottom'.	self		shouldnt: [ self command execute ]		raise: PUInvalidLogin.	self assert: self command user = self bloggerUser.	self assert: self command answer user = self bloggerUser.	self assert: self command answer command class = PRViewCommand.	self assert: self command context user isNil! !!PULoginTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!testLoginInvalidPassword	self assert: self command context user isNil.	self command username: self bloggerUser name.	self should: [ self command execute ] raise: PUInvalidLogin.	self assert: self command context user isNil! !!PULoginTest methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!testLoginInvalidUsername	self assert: self command context user isNil.	self should: [ self command execute ] raise: PUInvalidLogin.	self assert: self command context user isNil! !!PULogoutTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PULogoutTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!actualClass	^ PULogout! !!PULogoutTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!contextInstance	^ super contextInstance user: self bloggerUser! !!PULogoutTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsLogged	self deny: self command isLogged! !!PULogoutTest methodsFor: 'testing-testing' stamp: 'lr 3/9/2006 11:31'!testIsQuick	self assert: self command isQuick! !!PULogoutTest methodsFor: 'testing' stamp: 'lr 3/21/2006 18:43'!testingLogout	self assert: self command context user = self bloggerUser.	self command execute.	self assert: self command answer user isNil.	self assert: self command answer command class = PRViewCommand.	self assert: self command context user = self bloggerUser! !!PUBrowseComponent class methodsFor: 'testing' stamp: 'lr 10/17/2006 07:15'!isAbstract	^ false! !!PUBrowseComponent class methodsFor: 'accessing' stamp: 'lr 10/17/2006 07:18'!label	^ 'Browse'! !!PUBrowseComponent methodsFor: 'querying' stamp: 'lr 10/17/2006 20:28'!browseContextTo: aStructure	| next |	next := self context structure: aStructure.	next command viewComponentClass: self class.	^ next! !!PUBrowseComponent methodsFor: 'configuration' stamp: 'lr 10/17/2006 07:20'!defaultPermissions	^ (Array streamContents: [ :stream |		PRCommand allSubclasses do: [ :each |			each isAbstract 				ifFalse: [ stream nextPutAll: each permissions ] ] ])		asSortedCollection: [ :a :b | a label < b label ]! !!PUBrowseComponent methodsFor: 'actions' stamp: 'lr 10/17/2006 20:56'!execute: aClass on: aStructure	| command |	command := aClass new.	(self context structure: aStructure command: command) isValid		ifFalse: [ ^ self inform: 'You are not authorized to execute: ' , command name , '.' ].	command isConfirmed ifTrue: [		(self confirm: 'Are you sure to perform the selected action: ' , command name , '?')			ifFalse: [ ^ self ] ].	command isQuick		ifFalse: [ command := self call: command asComponent ].	command ifNotNil: [ command execute ]	! !!PUBrowseComponent methodsFor: 'initialization' stamp: 'lr 10/17/2006 07:19'!initialize	super initialize.	permissions := self defaultPermissions! !!PUBrowseComponent methodsFor: 'accessing' stamp: 'lr 10/17/2006 07:20'!permissions	^ permissions! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 20:30'!renderContentOn: html	self renderPathOn: html.	self renderTableOn: html! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 21:00'!renderPathOn: html	html div: [		self structure parents do: [ :each |			html text: '/ '.			html anchor				attributeAt: 'title' put: each title;				goto: (self browseContextTo: each);				text: each name.			html space ] ].	html break! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 21:03'!renderPermissions: aStructure permissions: aCollection on: html	| current short |	current := self context structure: aStructure.	self permissions do: [ :each |		html code			attributeAt: 'title' put: each label;			with: [				short := (aCollection includes: each)					ifTrue: [ each label first asLowercase ]					ifFalse: [ $- ].				(each command isValidIn: current) 					ifFalse: [ html render: short ]					ifTrue: [						html anchor							callback: [ self execute: each command on: aStructure ];							text: short ] ] ]! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 20:31'!renderTableHeadOn: html	html tableRow: [		html tableHeading: 'owner mode'.		html tableHeading: 'group mode'.		html tableHeading: 'other mode'.		html tableHeading: 'owner'.		html tableHeading: 'group'.		html tableHeading: 'name' ]! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 20:30'!renderTableOn: html	html table: [		html tableHead: [			self renderTableHeadOn: html ].		html tableBody: [			self renderTableRow: self structure on: html.			self structure isRoot				ifFalse: [ self renderTableRow: self structure parent on: html ].			self structure enumerator hidden				do: [ :each | self renderTableRow: each on: html ] ] ]! !!PUBrowseComponent methodsFor: 'rendering' stamp: 'lr 10/17/2006 21:01'!renderTableRow: aStructure on: html	html tableRow attributeAt: 'title' put: aStructure title; with: [ 		html tableData: [ 			self				renderPermissions: aStructure				permissions: aStructure securityDecoration ownerPermissions				on: html ].		html tableData: [			self				renderPermissions: aStructure				permissions: aStructure securityDecoration groupPermissions				on: html ].		html tableData: [			self				renderPermissions: aStructure				permissions: aStructure securityDecoration otherPermissions				on: html ].		html tableData: (aStructure securityDecoration owner			ifNotNilDo: [ :each | each name ]).		html tableData: (aStructure securityDecoration group			ifNotNilDo: [ :each | each name ]).		html tableData: [			html anchor				goto: (self browseContextTo: aStructure);				text: (self structure parent = aStructure					ifTrue: [ '..' ]					ifFalse: [ 						self structure = aStructure							ifTrue: [ '.' ]							ifFalse: [ aStructure name ] ]) ] ]! !!PUBrowseComponent methodsFor: 'accessing' stamp: 'lr 10/17/2006 07:21'!structure	^ self context structure! !!PRVisitor methodsFor: '*pier-security-visiting-structure' stamp: 'lr 3/9/2006 11:30'!visitSecurity: anObject	self visitDecoration: anObject! !!PUMemberTest methodsFor: 'running' stamp: 'lr 9/27/2006 11:47'!setUp	group1 := PUGroup named: 'group 1'.	group2 := PUGroup named: 'group 2'.	user1 := PUUser named: 'user 1'.	user2 := PUUser named: 'user 2'.	user3 := PUUser named: 'user 3'! !!PUMemberTest methodsFor: 'testing' stamp: 'lr 9/27/2006 11:50'!testEqualitiy	self assert: group1 = group1.	self assert: group2 = group2.	self assert: user1 = user1.	self assert: user2 = user2.	self assert: user3 = user3.	self deny: group1 = group2.	self deny: group2 = group1.	self deny: user1 = user2.	self deny: user2 = user3.	self deny: user3 = user1.	self deny: group1 = user1.	self deny: group2 = user1.	self deny: user1 = group1.	self deny: user2 = group1.	self deny: user3 = group1! !!PUMemberTest methodsFor: 'testing-groups' stamp: 'lr 9/27/2006 12:01'!testGroupUsers	group1 users: (Array with: user1 with: user2).	self assert: group1 users = (Set with: user1 with: user2).	self assert: user1 groups = (OrderedCollection with: group1).	self assert: user2 groups = (OrderedCollection with: group1).	self assert: user3 groups = (OrderedCollection new).	group1 users: (Array with: user2 with: user3).	self assert: group1 users = (Set with: user2 with: user3).	self assert: user1 groups = (OrderedCollection new).	self assert: user2 groups = (OrderedCollection with: group1).	self assert: user3 groups = (OrderedCollection with: group1)! !!PUMemberTest methodsFor: 'testing' stamp: 'lr 9/27/2006 11:49'!testName	self assert: group1 name = 'group 1'.	self assert: group2 name = 'group 2'.	self assert: user1 name = 'user 1'.	self assert: user2 name = 'user 2'.	self assert: user3 name = 'user 3'! !!PUMemberTest methodsFor: 'testing-user' stamp: 'lr 9/27/2006 12:01'!testUserAddGroups	user1 addGroup: group1; addGroup: group2.	self assert: user1 group = group1.	self assert: user1 groups = (OrderedCollection with: group1 with: group2).	self assert: group1 users = (Set with: user1).	self assert: group2 users = (Set with: user1)! !!PUMemberTest methodsFor: 'testing-user' stamp: 'lr 9/27/2006 12:03'!testUserGroups	user1 groups: (Array with: group1 with: group2).	self assert: user1 groups = (OrderedCollection with: group1 with: group2).	self assert: group1 users = (Set with: user1).	self assert: group2 users = (Set with: user1).	user1 groups: (Array with: group1).	self assert: user1 groups = (OrderedCollection with: group1).	self assert: group1 users = (Set with: user1).	self assert: group2 users = (Set new)! !!PUMemberTest methodsFor: 'testing-user' stamp: 'lr 9/27/2006 11:53'!testUserPassword	user1 password: 'foo'.	self deny: user1 password = 'foo'! !!PUMemberTest methodsFor: 'testing-user' stamp: 'lr 9/27/2006 12:04'!testUserRemoveGroups	user1 addGroup: group1; addGroup: group2; removeGroup: group2.	self assert: user1 groups = (OrderedCollection with: group1).	self assert: group1 users = (Set with: user1).	self assert: group2 users = (Set new)! !!PUMemberTest methodsFor: 'testing-user' stamp: 'lr 9/27/2006 11:53'!testUserSuperuser	self deny: user1 superuser.	self deny: user1 isSuperuser.	user1 superuser: true.	self assert: user1 superuser.	self assert: user1 isSuperuser! !!PRContext methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!group	^ self user group! !!PRContext methodsFor: '*pier-security-testing' stamp: 'lr 3/9/2006 11:30'!isLoggedIn	^ self user notNil! !!PRContext methodsFor: '*pier-security-initialization' stamp: 'lr 4/10/2006 15:16'!setUser: aUser	self propertyAt: #user put: aUser.	self enumerator hidden: (aUser notNil and: [ aUser isSuperuser ])! !!PRContext methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!user	^ self propertyAt: #user ifAbsentPut: [ nil ]! !!PRContext methodsFor: '*pier-security-navigation' stamp: 'lr 3/9/2006 11:30'!user: anUser	"Create a copy of the current context with the current user replaced by anUser."	^ self copy		setUser: anUser;		yourself! !!PRCommand class methodsFor: '*pier-security' stamp: 'lr 9/11/2006 10:21'!permissions	"Answer a collection of permissions as defined by the receiver."	^ Array with: (PUPermission on: self)! !!PRCommand methodsFor: '*pier-security' stamp: 'lr 9/11/2006 11:12'!permission	"The permission required to make the receiver executable in the setup context. nil if no permission is required."	^ self class permissions isEmpty		ifFalse: [ self class permissions anyOne ]! !!PUChangeGroup class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $g! !!PUChangeGroup class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionGroup	^ (MASingleOptionDescription selector: #group label: 'Group' priority: 200)		comment: 'Changes the group ownership to the selected group.';		options: (MADynamicObject on: [ self groupInstances ]);		reference: PUGroup description;		undefined: '(unchanged)';		beSorted;		yourself! !!PUChangeGroup class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeGroup class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'Change Group'! !!PUChangeGroup methodsFor: 'configuration' stamp: 'lr 9/11/2006 10:36'!accessor	^ MAChainAccessor selectors: #( securityDecoration groupPermissions )! !!PUChangeGroup methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doExecuteFor: aStructure	self group notNil		ifTrue: [ aStructure securityDecoration group: self group ].	super doExecuteFor: aStructure! !!PUChangeGroup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!group	^ group ifNil: [ group := self structure group ]! !!PUChangeGroup methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!group: aGroup	group := aGroup! !!PUChangeOther class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $o! !!PUChangeOther class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeOther class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'Change Other'! !!PUChangeOther methodsFor: 'configuration' stamp: 'lr 9/11/2006 10:36'!accessor	^ MAChainAccessor selectors: #( securityDecoration otherPermissions )! !!PUChangeOwner class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionOwner	^ (MASingleOptionDescription selector: #owner label: 'Owner' priority: 200)		comment: 'Changes the ownership to the selected user.';		options: (MADynamicObject on: [ self userInstances ]);		reference: PUUser description;		undefined: '(unchanged)';		beSorted;		yourself! !!PUChangeOwner class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUChangeOwner class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'Change Owner'! !!PUChangeOwner methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:36'!accessor	^ MAChainAccessor selectors: #( securityDecoration ownerPermissions )! !!PUChangeOwner methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doExecuteFor: aStructure	self owner notNil		ifTrue: [ aStructure securityDecoration owner: self owner ].	super doExecuteFor: aStructure! !!PUChangeOwner methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!owner	^ owner ifNil: [ owner := self structure owner ]! !!PUChangeOwner methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!owner: anUser	owner := anUser! !!PUChangeSecurity class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:31'!defaultAll	^ true! !!PUChangeSecurity class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:31'!defaultHidden	^ true! !!PUChangeSecurity class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:31'!defaultOperator	^ self defaultOperators first! !!PUChangeSecurity class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:31'!defaultOperators	^ #( set add remove )! !!PUChangeSecurity class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:31'!defaultWith	^ true! !!PUChangeSecurity class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionAll	^ (MABooleanDescription selector: #all label: 'Recursive' priority: 110 default: self defaultAll)		comment: 'Apply changes recursively to all children.';		beRequired;		yourself! !!PUChangeSecurity class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionHidden	^ (MABooleanDescription selector: #hidden label: 'Hidden' priority: 120 default: self defaultHidden)		comment: 'Apply changes to hidden structures.';		beRequired;		yourself! !!PUChangeSecurity class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionOperator	^ (MASingleOptionDescription selector: #operator label: 'Operator' priority: 300 default: self defaultOperator)		comment: 'Defines if the permissions should remain unchanged, be set to the selected ones, or be added/removed from the current selection.';		reference: MASymbolDescription new;		options: self defaultOperators;		undefined: '(unchanged)';		yourself! !!PUChangeSecurity class methodsFor: 'accessing-description' stamp: 'lr 9/11/2006 10:37'!descriptionPermissions	^ (MAMultipleOptionDescription selector: #permissions label: 'Permissions' priority: 310)		comment: 'Defines the set of permissions used together with the selected operation.';		options: (MADynamicObject on: [ self permissionInstances ]);		reference: PUPermission description;		beSorted;		yourself! !!PUChangeSecurity class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionWith	^ (MABooleanDescription selector: #with label: 'Current' priority: 100 default: self defaultWith)		comment: 'Apply changes to the current structure.';		beRequired;		yourself! !!PUChangeSecurity class methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!groupInstances	^ PRCurrentContext value kernel groups! !!PUChangeSecurity class methodsFor: 'private' stamp: 'lr 9/11/2006 10:16'!permissionInstances	^ PRCommand withAllConcreteClasses gather: [ :each | each permissions ]! !!PUChangeSecurity class methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!userInstances	^ PRCurrentContext value kernel users! !!PUChangeSecurity methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!accessor	self subclassResponsibility! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!all	^ all ifNil: [ all := self class defaultAll ]! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!all: aBoolean	all := aBoolean! !!PUChangeSecurity methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doExecute	super doExecute.	self structure enumerator		with: self with; all: self all; hidden: self hidden;		do: [ :each | self doExecuteFor: each ]! !!PUChangeSecurity methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doExecuteFor: aStructure	"Apply the changes to aStructure. Override this method to further modify aStructure. This method is automatically called by #doExecute for all the requested structure."	self accessor		write: (self operator = #set			ifTrue: [ self permissions copy ]			ifFalse: [				self operator = #add					ifTrue: [						(self accessor read: aStructure)							copyWithAll: self permissions ]					ifFalse: [						self operator = #remove							ifTrue: [								(self accessor read: aStructure)									copyWithoutAll: self permissions ]							ifFalse: [ ^ self ] ] ])		to: aStructure! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!hidden	^ hidden ifNil: [ hidden := self class defaultHidden ]! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!hidden: aBoolean	hidden := aBoolean! !!PUChangeSecurity methodsFor: 'accessing-operation' stamp: 'lr 3/9/2006 11:30'!operator	^ operator! !!PUChangeSecurity methodsFor: 'accessing-operation' stamp: 'lr 3/9/2006 11:30'!operator: aSymbol	operator := aSymbol! !!PUChangeSecurity methodsFor: 'accessing-operation' stamp: 'lr 3/9/2006 11:30'!permissions	^ permissions ifNil: [ permissions := self accessor read: self structure ]! !!PUChangeSecurity methodsFor: 'accessing-operation' stamp: 'lr 3/9/2006 11:30'!permissions: aCollectionOfCommands	permissions := aCollectionOfCommands asSet! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!with	^ with ifNil: [ with := self class defaultWith ]! !!PUChangeSecurity methodsFor: 'accessing-scope' stamp: 'lr 3/9/2006 11:30'!with: aBoolean	with := aBoolean! !!PUChangeUser methodsFor: 'accessing' stamp: 'lr 10/17/2006 21:29'!ancestor: aContext	ancestor := aContext! !!PUChangeUser methodsFor: 'events' stamp: 'lr 10/17/2006 21:30'!doAnswer	ancestor isNil ifFalse: [ 		self answer: (self context 			structure: ancestor structure			command: ancestor command) ].	super doAnswer! !!PUChangeUser methodsFor: 'events' stamp: 'lr 9/24/2006 19:59'!doValidate! !!PULogin class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $l! !!PULogin class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionPassword	^ (MAPasswordDescription selector: #password label: 'Password' priority: 200)		beRequired;		yourself! !!PULogin class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:31'!descriptionUsername	^ (MAStringDescription selector: #username label: 'Username' priority: 100)		beRequired;		yourself! !!PULogin class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PULogin class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isValidIn: aContext	^ aContext isLoggedIn not! !!PULogin class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'Login'! !!PULogin class methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:14'!permissions	^ #()! !!PULogin methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doAnswer	super doAnswer.	self answer: (self answer user: self user)! !!PULogin methodsFor: 'events' stamp: 'lr 3/9/2006 11:30'!doValidate	super doValidate.	self user: (self kernel users		detect: [ :each |			each name = self username				and: [ each validatePassword: self password ] ]		ifNone: [ PUInvalidLogin signal: 'Invalid username or password.' ])! !!PULogin methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isLogged	^ false! !!PULogin methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!password	^ password ifNil: [ password := String new ]! !!PULogin methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!password: aString	password := aString! !!PULogin methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!user	^ user! !!PULogin methodsFor: 'private' stamp: 'lr 3/9/2006 11:30'!user: aUser	user := aUser! !!PULogin methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!username	^ username ifNil: [ username := String new ]! !!PULogin methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!username: aString	username := aString! !!PULogout class methodsFor: 'accessing' stamp: 'lr 5/3/2006 16:58'!accessKey	^ $l! !!PULogout class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PULogout class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isValidIn: aContext	^ aContext isLoggedIn! !!PULogout class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'Logout'! !!PULogout class methodsFor: 'accessing' stamp: 'lr 9/11/2006 10:14'!permissions	^ #()! !!PULogout methodsFor: 'events' stamp: 'lr 3/21/2006 18:08'!doAnswer	super doAnswer.	self answer: (self answer user: nil)! !!PULogout methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isLogged	^ false! !!PULogout methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isQuick	^ true! !!PUDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!package	"The SqueakMap package name."	^ 'Pier Unix Security'! !!PUDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!packages	^ #( ( 'Pier-Security' ) )! !!PUDistribution class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!preamble	^ '(SMSqueakMap default packageWithName: ''Pier'')	lastRelease install.' , String cr! !!PUDistribution class methodsFor: 'accessing' stamp: 'lr 6/30/2006 00:41'!version	"The first item is the product name, which should only contain lowercase letters. Then the version numbers are following, that are made up of three numbers. An optimal suffix alpha, beta, pre or rc follows. External packages or extensions might want to call this method to check the version required to run."	^ #( pierunixsecurity 1 0 3 alpha )! !!PRKernel methodsFor: '*pier-security-defaults' stamp: 'lr 9/27/2006 11:45'!adminGroup	^ self propertyAt: #adminGroup ifAbsentPut: [ PUGroup named: 'admin' ]! !!PRKernel methodsFor: '*pier-security-defaults' stamp: 'lr 9/27/2006 11:45'!adminUser	^ self propertyAt: #adminUser ifAbsentPut: [		(PUUser named: 'admin')			addGroup: self adminGroup;			password: 'pier';			superuser: true;			yourself ]! !!PRKernel methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!groups	^ self propertyAt: #groups ifAbsentPut: [ Set with: self adminGroup ]! !!PRKernel methodsFor: '*pier-security-accessing' stamp: 'lr 3/9/2006 11:30'!users	^ self propertyAt: #users ifAbsentPut: [ Set with: self adminUser ]! !!PUSecurity commentStamp: 'lr 12/20/2005 15:05' prior: 0!Every structure is owned by a specific user. The owner of an object comprises its user class. Permissions assigned to the user class only apply to that specific user. A structure is also assigned a group, which comprises its group class. Permissions assigned to the group class only apply to members of that group. Users who are not otherwise represented by the other two classes comprise a file's others class.The effective permissions that have applied to a specific user in relation to a file are determined in logical precedence. For example, the user who owns the file will have the effective permissions given to the user class regardless of those assigned to the group or others class.!!PUSecurity class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!isAbstract	^ false! !!PUSecurity class methodsFor: 'events' stamp: 'lr 3/9/2006 11:31'!onStructureAdded: aStructure	| decoration |	decoration := aStructure isRoot		ifTrue: [ aStructure securityDecorationClass new ]		ifFalse: [ aStructure parent securityDecoration copy ].	PRCurrentContext value ifNotNilDo: [ :context |		decoration			owner: context user;			group: (context user				ifNotNil: [ context user group ]) ].	^ aStructure		addDecoration: decoration		ifPresent: [ :value | value ]! !!PUSecurity methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!accept: aVisitor	aVisitor visitSecurity: self! !!PUSecurity methodsFor: 'testing' stamp: 'lr 9/11/2006 11:02'!allows: aCommandClass permissions: aCollection	^ aCollection anySatisfy: [ :each | each command = aCommandClass ]! !!PUSecurity methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!group	^ group! !!PUSecurity methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!group: aGroup	group := aGroup! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:28'!groupPermissions	^ groupPermissions ifNil: [ groupPermissions := self ownerPermissions copy ]! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:28'!groupPermissions: aSet	groupPermissions := aSet asSet! !!PUSecurity methodsFor: 'initialization' stamp: 'lr 9/11/2006 10:48'!initialize	super initialize.	self ownerPermissions; groupPermissions; otherPermissions! !!PUSecurity methodsFor: 'testing' stamp: 'lr 9/11/2006 11:02'!isAllowedCommand: aCommandClass in: aContext	(aContext user notNil and: [ aContext user isSuperuser ])		ifTrue: [ ^ true ].	(self owner = aContext user)		ifTrue: [ ^ self allows: aCommandClass permissions: self ownerPermissions ].	(self group notNil and: [ self group includes: aContext user ])		ifTrue: [ ^ self allows: aCommandClass permissions: self groupPermissions ].	^ self allows: aCommandClass permissions: self otherPermissions! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:29'!otherPermissions	^ otherPermissions ifNil: [ otherPermissions := Set withAll: PRViewCommand permissions ]! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:29'!otherPermissions: aSet	otherPermissions := aSet asSet! !!PUSecurity methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!owner	^ owner! !!PUSecurity methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!owner: anUser	owner := anUser! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:29'!ownerPermissions	^ ownerPermissions ifNil: [ ownerPermissions := PUChangeSecurity permissionInstances asSet ]! !!PUSecurity methodsFor: 'accessing-permissions' stamp: 'lr 9/11/2006 10:30'!ownerPermissions: aSet	ownerPermissions := aSet asSet! !!PUSecurity methodsFor: 'copying' stamp: 'lr 9/11/2006 10:30'!postCopy	super postCopy.	self ownerPermissions: self ownerPermissions copy.	self groupPermissions: self groupPermissions copy.	self otherPermissions: self otherPermissions copy! !!PUSecurity methodsFor: 'configuration' stamp: 'lr 3/9/2006 11:31'!priority	^ -200! !!PUSecurity methodsFor: 'testing' stamp: 'lr 9/11/2006 11:17'!validateCommand: aCommand	(aCommand context user notNil 		and: [ aCommand context user isSuperuser ])			ifTrue: [ ^ self ].	(self owner = aCommand context user 		and: [ self ownerPermissions includes: aCommand permission ])			ifTrue: [ ^ self ].	(self group notNil 		and: [ (self group includes: aCommand context user)		and: [ self groupPermissions includes: aCommand permission ] ])			ifTrue: [ ^ self ].	(self otherPermissions includes: aCommand permission)		ifTrue: [ ^ self ].	MAConditionError on: nil explanation: 'Insufficient permissions'! !"Pier-Security"!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. !----SNAPSHOT----an Array(20 October 2006 12:22:19 am) Squeak3.9-RC2-7064.1.image priorSource: 77689!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. WAKom startOn: 8080!!WADispatcher methodsFor: '*pier-scriptingapi' stamp: 'kph 9/15/2006 04:03'!allApplications| apps | apps := self entryPoints select: [ :ep | ep isApplication ].self entryPoints select: [ :ep | ep isDispatcher ] thenDo: [:ep | apps addAll: ep allApplications ].^apps ! !!PRModelScripter commentStamp: '<historical>' prior: 0!Implementing the same protocol as PRCommandScripter. PRModelScripter is simple programmatic interface to Pier which operates on the model directly.If you wish to use PRModelScripter to load a Magma persisted model then you have to provide the MagmaSession, manage transactions, and explicitly instanciate PRModelScripter on the persisted kernel instance obtained from '(aMagmaSession root store at: 'pier') kernel'. see #exampleMagmaUsage.(PRModelScripter onKernelNamed: 'pier') addPageAt: '/' name: 'testing123' contents: 'testing 1.2.3..'.(PRModelScripter onKernelNamed: 'pier') (PRTimingWrapper on: (PRModelScripter onKernelNamed: 'pier')) addPageAt: '/' name: 'testing123' contents: 'testing 1.2.3..'.(PRTimingWrapper on: (PRModelScripter onKernelNamed: 'pier')) removePageAt: '/testing123'.!!PRCommandScripter commentStamp: '<historical>' prior: 0!PRCommandScripter a simple programmatic interface to Pier, which uses the PRCommand mechanism to interface with the model. This means that all actions may be logged as if made through the Seaside interface. Logging can be turned on/off with #noLog #yesLog. If logging is disabled then the PRCommandScripter should be equivalent to PRModelScriptor but with an implementation more consistent with the end user experience (i.e. validation provided by PRCommands etc.). PRModelScriptor provides examples of how the Model may be used but PRCommandScriptor is the preferred interface to command functions. Note: Care is taken in the the PRCommandScripter API to explicitly ensure that an instance keeps no references to the model, or commands onto the model, in local instance varsiable. This is so as not to become a potential garbage collection inhibiting 'hard ref' to the model.!!PRCommandAppScripter commentStamp: '<historical>' prior: 0!PRCommandAppScripter provides a scripting interface which executes its commands in the context of a registered seaside application.The aim of this interface is to ensure that 'WACurrentSession value' returns a useful result when running scripts. PRMagmaPersistency uses 'WACurrentSession value', and command actions should result in the persistent store being updated just as when executed through the seaside user interface.usage:PRCommandAppScripter kernelNamed: 'pier'  searches for the first application whose configuration entry #kernelName matches the requested name. A session is created using the configuration settings of this application. caveat: if you have more than one application serving the same pier kernel with different preferences you have been warned. If no application is found, it will fallback to use any application that is serving all kernels (#mainClass is set to PRMainAllKernels). If you have more than one of these serving more than one repository then it will not check to ensure that it has the correct repository.PRCommandAppScripter onApp: 'st'explicitly gives entry point for the application in whose context the scripts are to be run. It is assumed that the value of #kernelName is valid. For an application using PRMainAllKernels, use #onApp:onKernelName: to explicitly target the required kernel.!!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/18/2006 02:54'!findAppServingAllKernels^WADispatcher default allApplications detect: [ :app |					(app preferenceAt: #mainClass) respondsTo: #isServingAllKernels ]			 ! !!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 05:39'!findAppServingKernel: requestedKernelName ifNone: notThereBlock^WADispatcher default allApplications detect: [ :app |					(app preferenceAt: #kernel) name = requestedKernelName ] 	ifNone: notThereBlock ! !!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 05:38'!onApp: entryPointName| application sessionClass kernel |application :=  WADispatcher default entryPointAt: entryPointName.sessionClass := application preferenceAt: #sessionClass.kernel  := application preferenceAt: #kernel.^self new	setSession: (sessionClass application: application); 	setKernel: kernel;	yourself! !!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 05:05'!onApp: entryPointName kernelNamed: kernelName| application sessionClass  |application :=  WADispatcher default entryPointAt: entryPointName.sessionClass := application preferenceAt: #sessionClass.^self new 	setSession: (sessionClass application: application); 	setKernel: (PRKernel instanceNamed: kernelName);	yourself! !!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 05:05'!onKernelNamed: requestedKernelName"find a registered seaside application serving the desired kernel and make a session using the settings of that application"| application sessionClass |application :=  self findAppServingKernel: requestedKernelName 					ifNone: [ self findAppServingAllKernels ].sessionClass := application preferenceAt: #sessionClass.^self new 	setSession: (sessionClass application: application); 	setKernel: (PRKernel instanceNamed: requestedKernelName);	yourself! !!PRCommandAppScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 05:40'!onSession: aSession^self new	setSession: aSession;	setKernel: (aSession application preferenceAt: #kernel);	yourself! !!PRCommandAppScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/16/2006 05:06'!executeCommand: aCommandWACurrentSession use: session during: [ super executeCommand: aCommand ].! !!PRCommandAppScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 20:03'!kernel^ WACurrentSession use: session during: [ kernel realize ].! !!PRCommandAppScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 05:08'!session^session! !!PRCommandAppScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 02:40'!setSession: aSessionsession := aSession! !!PRCommandAppScripter methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:59'!transaction: aBlock(self session respondsTo: #magmaSession) ifFalse: [ ^ aBlock value ].self session magmaSession stubOut: aBlock value! !!PRCommandScripter methodsFor: 'public api' stamp: 'kph 9/17/2006 02:18'!addPageAt: aPath name: aPageName| aCommand |"returns the new page added"aCommand := PRAddCommand context: (self contextOn: aPath).aCommand name: aPageName. self executeCommand: aCommand.^aCommand context structure childrenDecoration at: aCommand name  ! !!PRCommandScripter methodsFor: 'public api' stamp: 'kph 9/16/2006 05:05'!addPageAt: aPath name: aName contents: someContent| newPage aCommand |newPage := self addPageAt: aPath name: aName.aCommand := PREditCommand context: (self contextOn: newPage).aCommand 	write: someContent			using: PRPage descriptionContents.self executeCommand: aCommand.^newPage! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 21:28'!contextOn: aPathOrStructure ^ (PRContext kernel: self kernel structure: (self structureAt: aPathOrStructure))	user: self kernel adminUser.	 ! !!PRCommandScripter methodsFor: 'public api' stamp: 'kph 9/27/2006 20:42'!editPageAt: aPath contents: aBlockOrText| aCommand pageContents |"returns the new page added"aCommand := PREditCommand context: (self contextOn: aPath).pageContents := aBlockOrText isString 	ifTrue: [ aBlockOrText ]	ifFalse: [ aBlockOrText value: (aCommand readUsing: PRPage descriptionContents) ]. aCommand 	write: pageContents			using: PRPage descriptionContents.self executeCommand: aCommand.^aCommand context structure    ! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/16/2006 05:03'!executeCommand: aCommand.self isLogging ifTrue: [ aCommand execute ] ifFalse: [ self executeCommandWithoutLogging: aCommand ].! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 20:02'!executeCommandWithoutLogging: aCommand"code stolen from PRCommand and logging is commented out"	aCommand isView		ifTrue: [ aCommand shouldNotImplement ].	aCommand kernel persistency doing: aCommand critical: [		aCommand doValidate; doExecute.		"aCommand isLogged			ifTrue: [ aCommand doPersistency ]" ].	aCommand doAnswer! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 04:24'!isLogging^logging ifNil: [ false ]! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 01:44'!noLoglogging := false! !!PRCommandScripter methodsFor: 'public api' stamp: 'kph 9/17/2006 02:18'!removePageAt: aPath self executeCommand: (PRRemoveCommand context: (self contextOn: aPath))! !!PRCommandScripter methodsFor: 'public api' stamp: 'kph 9/27/2006 21:08'!viewPageAt: aPath  | aCommand pageContents |"returns the new page added"aCommand := PRViewCommand context: (self contextOn: aPath).pageContents := aCommand readUsing: PRPage descriptionContents. self executeCommand: aCommand. ^ pageContents  ! !!PRCommandScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 01:44'!yesLoglogging := true! !!PRModelScripter class methodsFor: 'as yet unclassified' stamp: 'kph 10/8/2006 04:46'!exampleMagmaUsage| magmaSession scripter |magmaSession := MagmaSession openLocal: 'magma-pier'.magmaSession connectAs: 'model-scripter'.scripter := PRModelScripter onKernel: (magmaSession pier at: 'Squeak') kernel.magmaSession commit: [	scripter addPageAt: '/' name: 'Testing PRModelScripter' contents: 'testing PRModelScripter... ok'.].magmaSession disconnectAndClose.! !!PRModelScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/14/2006 23:52'!onKernel: aKernel ^self new setKernel: aKernel ; yourself! !!PRModelScripter class methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 05:38'!onKernelNamed: aKernelName ^self onKernel: (PRKernel instanceNamed: aKernelName) realize.! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/16/2006 01:10'!addPageAt: aPath name: aName^(self structureAt: aPath) addChild: (PRPage named: aName)! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/16/2006 01:12'!addPageAt: aPath name: name contents: someContent^ (self addPageAt: aPath name: name) contents: someContent! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/27/2006 20:42'!editPageAt: aPath contents: aBlockOrText| structure pageContents |structure := self structureAt: aPath.pageContents := aBlockOrText isString 	ifTrue: [ aBlockOrText ]	ifFalse: [ aBlockOrText value: structure contents ].structure contents: pageContents.^structure! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/15/2006 02:11'!isLogging^false! !!PRModelScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 17:40'!kernel^ kernel! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/28/2006 19:43'!memory! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/15/2006 02:11'!noLog! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/16/2006 01:20'!removePageAt: aPath | aPage |aPage := self structureAt: aPath.aPage isRoot		ifTrue: [ self error: 'Unable to remove root node.' ].PRIncomingReferences		from: self kernel root		to: (aPage enumerator			with; all; hidden;			contents)		do: [ :each | each target: nil ].^ aPage remove! !!PRModelScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 02:41'!setKernel: aKernelkernel := aKernel! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/28/2006 19:38'!ssh! !!PRModelScripter methodsFor: 'as yet unclassified' stamp: 'kph 9/16/2006 00:47'!structureAt: aPathOrStructure^aPathOrStructure isString ifTrue: [ PRPathLookup start: self kernel root path: aPathOrStructure ]			   			  ifFalse: [ aPathOrStructure ].! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/29/2006 04:53'!to: name do: aBlock"compatibility with PRTimingWrapper"aBlock value! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/17/2006 04:45'!transaction: aBlock^aBlock value! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/27/2006 21:09'!viewPageAt: aPath   	^(self structureAt: aPath) contents ! !!PRModelScripter methodsFor: 'public api' stamp: 'kph 9/28/2006 00:03'!withTempPageDo: aMonadicBlock| tmpName |tmpName := 'tmp-', 100 atRandom asString.self addPageAt: '/' name: tmpName.[ aMonadicBlock value: ('/',tmpName) ] 	ensure: [ self removePageAt: tmpName ].! !!PRModelScripter methodsFor: 'compatibility' stamp: 'kph 9/15/2006 02:11'!yesLog! !!PRPierifyToPage commentStamp: '<historical>' prior: 0!Abstract class of classes designed to load data from a datasource #target: into a pier pageCan be used with any of the Scripter interface classesSee subclasses for usage examples!!PRPierifySmalltalkClass commentStamp: '<historical>' prior: 0!Example of how to use the scripting interface to import data. This class is instanciated with the data source as its target.(PRPierifySmalltalkClass target: ProtoObject) into: (PRCommandScripter onKernelNamed: 'Squeak' ).(PRModelScripter onKernelNamed: 'Squeak') removePageAt: 'ProtoObject'.To create a sizeable database see class methods #example...!!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:55'!exampleAllClasses| model count |count := 0.model := (PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak'))."Transcript show: model session magmaSession location; cr."model noLog. ProtoObject allSubclassesDo: [ :theClass | count := count + 1.Transcript show: count printString, ': ', theClass name; cr.[  (PRPierifySmalltalkClass target: theClass) into: model. (Delay forSeconds: self pace) wait.] on: PRConflictingNameError do: [ :e | Transcript show: theClass name, ' already exists'; cr. ].]. "self pace: 30.[ self exampleAllClasses ] forkAt: 15"! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:55'!exampleProtoObject| model |model := PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak').model noLog. ProtoObject in: [ :theClass | Transcript show: theClass name; cr.(PRPierifySmalltalkClass target: theClass) into: model ]."self exampleProtoObject"! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 04:38'!pace^Pace ifNil: [ 20 ].! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 04:38'!pace: tPace := t! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 01:17'!target: aClass  ^self new setTarget: aClass ; yourself! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 9/15/2006 03:43'!classDescriptionToWiki: streamstream nextPutAll: '!!Description'; cr.stream nextPutAll: target class comment ; cr. ! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 9/15/2006 00:13'!classSubclassesToWiki: stream.target subclassesDo: [ :sc | stream nextPutAll: '- *', sc name, '*'; cr ]  ! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 9/14/2006 23:56'!methodSelectors: methodDictionary toWiki: streammethodDictionary keysDo: [ :methodSelector | stream nextPutAll: '- *', methodSelector, '*'; cr ] ! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 9/15/2006 02:15'!pageContentsOn: stream  self classDescriptionToWiki: stream.stream nextPut: $_; cr.stream nextPutAll: '!!!!!!Subclasses'; cr.self classSubclassesToWiki: stream.stream nextPut: $_; cr.stream nextPutAll: '!!!!!!Instance Methods'; cr.self methodSelectors: target methodDictionary toWiki: stream.stream nextPutAll: '!!!!!!Class Methods'; cr.self methodSelectors: target class methodDictionary toWiki: stream. ! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 9/15/2006 04:31'!pageName^target name asString ! !!PRPierifySmalltalkClass methodsFor: 'page items' stamp: 'kph 10/10/2006 23:31'!parentPath^ ( target allSuperclasses reverse) joinUsing: $/ "(self target: ProtoObject) parentPath(self target: String) parentPath"! !!PRPierifyToPage methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 21:31'!into: aScripter aScripter addPageAt: (self parentPath) name: (self pageName) contents: (self pageContents).! !!PRPierifyToPage methodsFor: 'page items' stamp: 'kph 9/15/2006 00:09'!pageContents	^ String streamContents: [ :stream | self pageContentsOn: stream ].! !!PRPierifyToPage methodsFor: 'page items' stamp: 'kph 9/15/2006 00:11'!pageContentsOn: stream^ self subclassResponsibility! !!PRPierifyToPage methodsFor: 'page items' stamp: 'kph 9/15/2006 00:11'!pageName^ self subclassResponsibility! !!PRPierifyToPage methodsFor: 'page items' stamp: 'kph 9/15/2006 00:12'!parentPath^ self subclassResponsibility! !!PRPierifyToPage methodsFor: 'as yet unclassified' stamp: 'kph 9/15/2006 00:04'!setTarget: aDataSourcetarget := aDataSource! !!PRTimingWrapper commentStamp: 'kph 9/29/2006 04:53' prior: 0!The output specified by #on:reportTo: is sent as strings to a collection stream using #nextPut: If no output is specified then PRTimingWrapper uses itself whose implementation of #nextPut: defaults to the Transcript.usage:(PRTimingWrapper on: (PRModelScripter onKernelNamed: 'pier')) addPageAt: '/' name: 'testing123' contents: 'testing 1.2.3..'.(PRTimingWrapper on: (PRModelScripter onKernelNamed: 'pier')) removePageAt: '/testing123'.usage:| scripter |scripter := PRTimingWrapper on: (PRModelScripter onKernelNamed: 'pier').scripter memory.scripter to: 'add 1000 pages' do: [	1 to: 1000 do: [ :n | 		scripter quietly addPageAt: '/' name: ('testing-', n asString) contents: 'testing 1.2.3..'.	]].scripter memory.scripter to: 'remove 1000 pages' do: [ 	1 to: 1000 do: [ :n | 		scripter quietly removePageAt: ('/testing-', n asString).	]].Smalltalk garbageCollect.scripter memory.!!PRTimingWrapper class methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 18:47'!on: scripter | aNew |aNew := self new.^aNew setScripter: scripter; setOutput: aNew; yourself.! !!PRTimingWrapper class methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 18:43'!on: scripter reportTo: it ^self new setScripter: scripter; setOutput: it; yourself! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 21:35'!doesNotUnderstand: aMessage| result timed |timed := Time millisecondsToRun: [ result := aMessage sendTo: scripter].self isSsh ifFalse: [ self sendReport: (aMessage printStringLimitedTo: 80) duration: timed ].^result! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 17:53'!duration^duration! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 19:34'!isSshssh ifFalse: [ ^false ].ssh := false. ^ true.		! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 19:43'!memoryself nextPut: SmalltalkImage current vmStatisticsReportString! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 19:07'!nextPut: reportTranscript show: (report , String cr).! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 04:43'!quietlyssh := true.^self! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 19:28'!sendReport: aMessage duration: timingoutput nextPut: (timing asString, 'ms ', aMessage asString).! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 18:02'!setOutput: itoutput := it! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/28/2006 19:35'!setScripter: aScripterssh := false.scripter := aScripter! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:53'!sshssh := true.^self! !!PRTimingWrapper methodsFor: 'as yet unclassified' stamp: 'kph 9/29/2006 04:53'!to: aMessage do: aBlock| timed |timed := Time millisecondsToRun: aBlock.self sendReport: aMessage duration: timed.! !!PRPierPerformance commentStamp: 'kph 9/29/2006 04:19' prior: 0!PRPierPerformance is a component, so can be run through a web browser. It may also be used in the image with output to the transcript via:self runTestOnApp: 'pier'.self runTestOnApp: 'squeak'.!!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/27/2006 03:52'!canBeRoot^true! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/27/2006 07:02'!initialize	| application |	pusher := CTPusher new.	application := self registerAsApplication: 'pier-theatre'.	application preferenceAt: #sessionClass put: CTMagmaSharedSession.	application libraries add: SULibrary; add: CTLibrary.	application configuration addAncestor: PRPierConfiguration new.	application configuration addAncestor: WAMagmaConfiguration new.! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/29/2006 03:41'!pierScripterClass^PRCommandAppScripter! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/27/2006 17:16'!pusher	^ pusher! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/29/2006 05:05'!runTestOnApp: appName^self basicNew initialize;			  setScripter: (PRTimingWrapper on: (self pierScripterClass onApp: appName)); 			  runTest;				  yourself"self runTestOnApp: 'squeak'."! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 04:57'!beginAt: startdepth := 0.width := 0.path := start.pages := OrderedCollection new.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 05:08'!contentsWithLinks^ '-To go up *../level-', (depth - 1) asString, '*-to go down *level-' ,  (depth + 1) asString, '*ok.'! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 01:47'!depth^depth asInteger ifNil: [ self depthDefault ]! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 01:47'!depth: ddepth := d! !!PRPierPerformance methodsFor: 'settings' stamp: 'kph 9/28/2006 01:35'!depthDefault^5! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:38'!initialize	result := ValueHolder new contents: OrderedCollection new.	result addDependent: self.	depth := self depthDefault.  ! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 04:01'!nextDeep | name |depth := depth + 1.name := 'level-', self depth asString.path := path, '/', name.^name! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 18:19'!nextPut: timingReportself result add: timingReport.self result contentsChanged.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 04:05'!nextWide| name |width := width + 1.name := 'page-', width asString.^name! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 18:33'!output^ self useTranscript ifTrue: [ self scripter ] ifFalse: [ self ]! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:56'!path ^path ifNil: [ path := '/' ].! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/27/2006 17:16'!pusher^self class pusher! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 04:12'!renderContentOn: htmlhtml form: [ 	html anchor on: #runTest of: self.	html text: ' depth:'.	html textInput on: #depthTo of: self.	  	html heading with: 'Test Results:'.   	html paragraph: [		html div id: 'result'; with:  [			self result do: [ :r | html text: r; break ].		]	].].	"html script: (html comet		pusher: self pusher;		connect)"! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/27/2006 04:56'!rendererClass^WARenderCanvas! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 17:58'!reportScripterResult| out |out := self scripter report.self session log: out.result contents add: out.result contentsChanged.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/27/2006 19:46'!result^result contents! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 05:08'!runTestself scripter memory.self scripter withTempPageDo: [ :start |	self beginAt: start.	10 timesRepeat: [ pages add: (scripter addPageAt: path name: self nextDeep contents:  self contentsWithLinks) ].	10 timesRepeat: [ pages add: (scripter addPageAt: path name: self nextWide contents: 'testing 1.2.3...') ]. (Delay forSeconds: 60) wait.	pages reverseDo: [ :page | scripter removePageAt: page ]. ].Smalltalk garbageCollect.self scripter memory.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:38'!scripter^scripter ifNil: [ self scripterDefault ]! !!PRPierPerformance methodsFor: 'settings' stamp: 'kph 9/29/2006 03:42'!scripterDefault^PRTimingWrapper on: (self class pierScripterClass onSession: self session) reportTo: self output.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:38'!setScripter: aScripterscripter := aScripter ! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/28/2006 03:19'!test: name do: block| out |out := name, ' ', (Time millisecondsToRun: block) asString, 'ms'.self session log: out.result contents add: out.result contentsChanged.! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/27/2006 05:04'!testAdd! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:54'!toDepth^toDepth asInteger ifNil: [ self depthDefault ]! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/29/2006 03:54'!toDepth: dtoDepth := d! !!PRPierPerformance methodsFor: 'ui' stamp: 'kph 9/27/2006 18:28'!update: anAspectTranscript show: self result contents; cr.	self pusher javascript: (SUElement new		id: 'result';		update: self result contents)! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 10/20/2006 00:54' prior: 36573684!initialize	"| application |	pusher := CTPusher new.	application := self registerAsApplication: 'pier-theatre'.	application preferenceAt: #sessionClass put: CTMagmaSharedSession.	application libraries add: SULibrary; add: CTLibrary.	application configuration addAncestor: PRPierConfiguration new.	application configuration addAncestor: WAMagmaConfiguration new."! !!PRPierControlPanel methodsFor: 'actions' stamp: 'kph 10/20/2006 00:56' prior: 36464323!callWidget: widget  titled: title    PRCurrentContext use: self during: [        WARenderLoop new call: (widget            addDecoration: (WAWindowDecoration new                title: title;                yourself);            yourself) ]  ! !SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7063] on 19 October 2006 at 3:31:48 pm'!TestCase subclass: #SequenceableCollectionJoinSplitTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CollectionsTests-Sequenceable'!!BlockContext methodsFor: 'evaluating' stamp: 'kph 10/19/2006 14:33'!splitUp: aSequenceableCollection   ^ aSequenceableCollection split: self! !!Character methodsFor: 'converting' stamp: 'kph 10/19/2006 11:56'!useToJoin: aCollection	^ String streamContents: [ :stream |		aCollection			do: [ :each | stream nextPutAll: each asString ]			separatedBy: [ stream nextPut: self ] ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'kph 10/19/2006 15:07'!split: aBlock	| result position |	result := OrderedCollection new.	position := 1.	 	self withIndexDo: [ :element :idx | 		(aBlock value: element) ifTrue: [ result add: (self copyFrom: position to: idx - 1).										 position := idx + 1  ]	].	result add: (self copyFrom: position to: self size).		^ result! !!SequenceableCollection methodsFor: 'join-split' stamp: 'kph 10/19/2006 15:31'!joinUsing: joiner "joiner - character, string or sequenceable collection  returns collection of the same collection class as 'joiner', or a String " ^ joiner useToJoin: self! !!SequenceableCollection methodsFor: 'join-split' stamp: 'kph 10/19/2006 15:28'!joinUsing: joiner last: last  " #(1 2 3 4) joinUsing: ', ' last: 'and'. => '1, 2, 3 and 4 "^ last useToJoin: (Array with: (joiner useToJoin: (self allButLast)) with: self last).! !!SequenceableCollection methodsFor: 'join-split' stamp: 'kph 10/19/2006 15:31'!splitOn: splitter "splitter - can be a sub-sequence, or aBlock"^ splitter splitUp: self! !!SequenceableCollection methodsFor: 'join-split' stamp: 'kph 10/19/2006 12:00'!splitUp: aSequencableCollection	| result position oldPosition |	result := OrderedCollection new.	position := 1.	oldPosition := position.	position := aSequencableCollection indexOfSubCollection: self startingAt: position.	[ position > 0 ] whileTrue: [		result add: (aSequencableCollection copyFrom: oldPosition to: position - 1).		position := position + self size.		oldPosition := position.		position := aSequencableCollection indexOfSubCollection: self startingAt: position.	].	result add: (aSequencableCollection copyFrom: oldPosition to: aSequencableCollection size).	^ result! !!SequenceableCollection methodsFor: 'join-split' stamp: 'kph 10/19/2006 12:00'!useToJoin: aCollection	^ self class streamContents: [ :stream |		aCollection			do: [ :each | stream nextPut: each ]			separatedBy: [ stream nextPutAll: self ] ]! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:09'!array	^ #( 1 2 3 4 )! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:09'!arrayOfStrings	^ #( 'Squeak is modern' 'open source' 'highly portable' 'fast'  'full-featured' )! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:08'!eg	^ 'Now is the time for all good men to come to the aid of the party'.! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:03'!testJoinTokensUsingCharacter	self assert: ((self array joinUsing: $/) = '1/2/3/4')! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:03'!testJoinTokensUsingString	self assert: ((self array joinUsing: ', ') = '1, 2, 3, 4')! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:06'!testJoinUsingArray	| join | 		self assert: ((join := self array joinUsing: #(10 11)) = #(1 10 11 2 10 11 3 10 11 4)).	^ join! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:04'!testJoinUsingLastOnArray	self assert: ((self array joinUsing: ', ' last: ' and ') = '1, 2, 3 and 4')! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 12:04'!testJoinUsingLastOnArrayOfStrings	self assert: (		(self arrayOfStrings joinUsing: ', ' last: ' and ') = 		'Squeak is modern, open source, highly portable, fast and full-featured')! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 14:36'!testSplitArray	self assert: ((self testJoinUsingArray splitOn: #(10 11)) asArray = #( #(1) #(2) #(3) #(4)) )! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 15:15'!testSplitBlock	self assert: (('1,2.3-4' splitOn: [ :elem | ',.-' includes: elem ]) = #('1' '2' '3' '4') asOrderedCollection).	self assert: (('1234' splitOn: [ :elem | elem asCharacter isAlphaNumeric]) = #('' '' '' '' '') asOrderedCollection).	self assert: ((self array splitOn: [ :elem | elem \\ 2 = 0] ) = #(#(1) #(3) #()) asOrderedCollection).! !!SequenceableCollectionJoinSplitTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 14:36'!testSplitString	self assert: (((self eg splitOn: 'the') joinUsing: 'the') = self eg)! !!String methodsFor: 'converting' stamp: 'kph 10/19/2006 11:54'!useToJoin: aCollection	^ String streamContents: [ :stream | 		aCollection			do: [ :each | stream nextPutAll: each asString ]			separatedBy: [ stream nextPutAll: self ] ]! !----End fileIn of a stream----!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. lukas  install: 'Pier-ScriptingAPI'.mantis bug: 4874 fix: 'Join.3.cs'.!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. lukas  install: 'Pier-ScriptingAPI'.WAKom startOn: 8080NetNameResolver addressFromString: '1 2 3 4'.!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. lukas  install: 'Pier-ScriptingAPI'.WAKom startOn: 8080[ 100000 timesRepeat:[ NetNameResolver addressFromString: '1 2 3 4' ] ] timeToRun.!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7063] on 19 October 2006 at 4:08:03 pm'!TestCase subclass: #NetNameResolverTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'NetworkTests-Kernel'!!NetNameResolver class methodsFor: 'address string utils' stamp: 'kph 10/19/2006 16:03' prior: 25381449!addressFromString: addressString	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."		| result |	 result :=  [((addressString split: [ :item | '., ' includes: item ]) 			collect: [ :item | item asNumber ]) asByteArray ] on: Error do: [ :ex | ^nil ].			 result size = 4 ifFalse: [ ^nil ].		^ result! !!NetNameResolverTest methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 16:07'!testAddressFromString 	self assert: ((NetNameResolver addressFromString: '1.2.3.4') = #(1 2 3 4) asByteArray).	self assert: ((NetNameResolver addressFromString: '1,2,255,4') = #(1 2 255 4) asByteArray).	self assert: ((NetNameResolver addressFromString: '1 2 255 4') = #(1 2 255 4) asByteArray).		self assert: ((NetNameResolver addressFromString: '1 2 3 4 5') = nil).	self assert: ((NetNameResolver addressFromString: '-1 2 3 4') = nil).	self assert: ((NetNameResolver addressFromString: '1 256 3 4') = nil).! !NetNameResolver class removeSelector: #readDecimalByteFrom:!NetNameResolver class removeSelector: #readDecimalByteFrom:!----End fileIn of a stream----!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. lukas  install: 'Pier-ScriptingAPI'.mantis bug: 5252 fix: 'NetNameResolver-use-split.1.cs'.!SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All';       install: 'Magritte-Seaside'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. lukas  install: 'Pier-ScriptingAPI'.mantis bug: 5252 fix: 'NetNameResolver-use-split.1.cs'.WAKom startOn: 8080[ 100000 timesRepeat:[ NetNameResolver addressFromString: '1 2 3 4' ] ] timeToRun.!<error in printString: evaluate "options printString!<error in printString: evaluate "options printString!<error in printString: evaluate "options printString!<error in printString: evaluate "options printString!!MADescription methodsFor: 'strings' stamp: 'kph 10/20/2006 01:54' prior: 35936753!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> using <code>aFormatter</code>."	^ aFormatter write: (accessor read: anObject)  description: self! !renderCellContent: anObject on: html	html render: (self description toString: (self valueFor: anObject)!!MADescription methodsFor: 'strings' stamp: 'lr 5/27/2006 17:17' prior: 36595141!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> using <code>aFormatter</code>."	^ aFormatter write: anObject description: self! !!MAMultipleOptionDescription methodsFor: 'strings' stamp: 'kph 10/20/2006 02:07'!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> using <code>aFormatter</code>."	^ aFormatter write: (accessor read: anObject)  description: self! !!MAMultipleOptionDescription methodsFor: 'strings' stamp: 'kph 10/20/2006 02:08' prior: 36595796!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> options obtained via the accessor using <code>aFormatter</code>."	^ aFormatter write: (accessor read: anObject)  description: self! !!MAMultipleOptionDescription methodsFor: 'strings' stamp: 'kph 10/20/2006 02:09' prior: 36596095!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> multiple options obtained via <code>accessor</code> using <code>aFormatter</code>."	^ aFormatter write: (accessor read: anObject)  description: self! !!MAMultipleOptionDescription methodsFor: 'strings' stamp: 'kph 10/20/2006 02:09' prior: 36596428!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> multiple options	 obtained via <code>accessor</code> using <code>aFormatter</code>."	^ aFormatter write: (accessor read: anObject)  description: self! !renderCellContent: anObject on: html	html render: (self description toString: (self valueFor: anObject)!!MAMultipleOptionDescription methodsFor: 'strings' stamp: 'kph 10/20/2006 02:17' prior: 36596779!toString: anObject writer: aFormatter	"Answer a string being formatted from <code>anObject</code> multiple options	 obtained via <code>accessor</code> using <code>aFormatter</code>."	^ aFormatter write: " (accessor read: anObject)" anObject  description: self! !visitMultipleOptionDescription: aDescription	self object!!MAStringWriter methodsFor: 'visiting-description' stamp: 'kph 10/20/2006 02:24' prior: 36011356!visitMultipleOptionDescription: aDescription	(object readUsing: aDescription)		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !optionsOn: html	self isOptional ifTrue: 		[html option 			selected: selected isNil; 			callback: [callbackBlock value: nil];			with: optionalLabel].	list do: 		[:each | 		html option 			selected: (self isSelected: each); 			callback: [ self isMultiple				ifTrue: [ selected add: each ]				ifFalse: [ callbackBlock value: each ] ];			with: (self labelForOption: each)]			PRKernel instances!!PUMemberWidget methodsFor: 'private' stamp: 'kph 10/20/2006 02:38' prior: 36511834!buildReport	| component |		self halt.		component := MAReport		rows: self members asArray		description: self memberClass description.	self isSuperuser ifTrue: [		component addColumn: (MACommandColumn new			addCommandOn: self selector: #edit: text: 'edit';			addCommandOn: self selector: #remove: text: 'remove';			yourself) ].	^ component! !description	^ MADescriptionBuilder for: self!!PUMemberWidget methodsFor: 'private' stamp: 'lr 9/27/2006 11:04' prior: 36598369!buildReport	| component |	component := MAReport		rows: self members asArray		description: self memberClass description.	self isSuperuser ifTrue: [		component addColumn: (MACommandColumn new			addCommandOn: self selector: #edit: text: 'edit';			addCommandOn: self selector: #remove: text: 'remove';			yourself) ].	^ component! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'kph 10/20/2006 02:41' prior: 36597664!visitMultipleOptionDescription: aDescription	object  		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | value description!renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | value description toString: value!!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'kph 10/20/2006 02:50' prior: 36099215!renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | value description toString: value ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'kph 10/20/2006 02:52' prior: 36099604!renderEditorSelectedOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self selectedList;		selected: self selectedSelected;		callback: [ :value | self selectedSelected: value ];		labels: [ :value | value description toString: value ]! !!MADescribedColumn methodsFor: 'actions' stamp: 'kph 10/20/2006 02:59' prior: 35844023!valueFor: aRow	^ (aRow readUsing: aRow description)		ifNil: [ self description default ]! !!MADescribedColumn methodsFor: 'actions' stamp: 'kph 10/20/2006 03:00' prior: 36600901!valueFor: aRowself read. 	^ (aRow readUsing: aRow description)		ifNil: [ self description default ]! !!MADescribedColumn methodsFor: 'actions' stamp: 'kph 10/20/2006 03:00' prior: 36601083!valueFor: aRow  	^ (aRow readUsing: aRow description)		ifNil: [ self description default ]! !!MADescribedColumn methodsFor: 'actions' stamp: 'kph 10/20/2006 03:01' prior: 36601279!valueFor: aRow  	^ (aRow readUsing: self description)		ifNil: [ self description default ]! !valueFor: aRow  	^ (aRow readUsing: self description)!MAMultipleOptionDescription removeSelector: #toString:writer:!!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32' prior: 36599290!visitMultipleOptionDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MADescribedColumn methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33' prior: 36601464!valueFor: aRow	^ (aRow readUsing: self description)		ifNil: [ self description default ]! !"Magritte-Seaside"!"Magritte-Model"!----SNAPSHOT----an Array(20 October 2006 3:29:08 am) Squeak3.9-RC2-7064.2.image priorSource: 2996913!!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/20/2006 03:44' prior: 36566510!exampleAllClasses| model count |count := 0.model := (PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak'))."Transcript show: model session magmaSession location; cr."model noLog. ProtoObject allSubclassesDo: [ :theClass | count := count + 1.Transcript show: count printString, ': ', theClass name; cr.[  (PRPierifySmalltalkClass target: theClass) into: model. (Delay forSeconds: self pace) wait.] on: PRConflictingNameError do: [ :e | Transcript show: theClass name, ' already exists'; cr. ].]. "self pace: 0.[ self exampleAllClasses ] forkAt: 15"! !exampleAllClasses| model count |count := 0.model := (PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak'))."Transcript show: model session magmaSession location; cr."model noLog. ProtoObject allSubclassesDo: [ :theClass | count := count + 1.Transcript show: count printString, ': ', theClass name; cr.[  (PRPierifySmalltalkClass target: theClass) into: model. (Delay forSeconds: self pace) wait.] on: PRConflictingNameError do: [ :e | Transcript show: theClass name, ' already exists'; cr. ].]. "self pace: 0.[ self exampleAllClasses ] forkAt: 15!!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/20/2006 03:44' prior: 36567201!exampleProtoObject| model |model := PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Pier').model noLog. ProtoObject in: [ :theClass | Transcript show: theClass name; cr.(PRPierifySmalltalkClass target: theClass) into: model ]."self exampleProtoObject"! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/20/2006 03:44' prior: 36602404!exampleAllClasses| model count |count := 0.model := (PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Pier'))."Transcript show: model session magmaSession location; cr."model noLog. ProtoObject allSubclassesDo: [ :theClass | count := count + 1.Transcript show: count printString, ': ', theClass name; cr.[  (PRPierifySmalltalkClass target: theClass) into: model. (Delay forSeconds: self pace) wait.] on: PRConflictingNameError do: [ :e | Transcript show: theClass name, ' already exists'; cr. ].]. "self pace: 0.[ self exampleAllClasses ] forkAt: 15"! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/20/2006 03:45' prior: 36603702!exampleProtoObject| model |model := PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'pier').model noLog. ProtoObject in: [ :theClass | Transcript show: theClass name; cr.(PRPierifySmalltalkClass target: theClass) into: model ]."self exampleProtoObject"! !----SNAPSHOT----an Array(20 October 2006 3:46:15 am) Squeak3.9-RC2-7064.2.image priorSource: 3047756!Hints and Tips:This image is already running a single kernel. Configuring for Magma.in application configuration.1. Add WAMagmaConfiguration to configutations.2. Switch sessionClass to WAMagmaSharedSession3. Return to the config app and click the new 'magma'.4. Create RepositoryRoot selecting PRMagmaRepository (create)5. Return to config app and click the 'pier' link.6. Switch the kernel to the persistency scheme of your choice.Serving StyleSheet from the image using FileLibrary.evaluaterenggli := Installer repository: 'http://mc.lukas-renggli.ch/'.!How-To:This image is already running a single kernel. Configuring for Magma.in application configuration.1. Add WAMagmaConfiguration to configutations.2. Switch sessionClass to WAMagmaSharedSession3. Return to the config app and click the new 'magma'.4. Create RepositoryRoot selecting PRMagmaRepository (create)5. Return to config app and click the 'pier' link.6. Switch the kernel to the persistency scheme of your choice.Serving StyleSheet from the image using FileLibrary.1. evaluatesqueaksource := Installer repository: 'http://www.squeaksource.com'.!PRPierControlPanel removeSelector: #managePasswords!!PRPierControlPanel methodsFor: 'rendering' stamp: 'kph 10/20/2006 04:19' prior: 36470458!renderManageUsersOn: html 	(self kernelBeingServed respondsTo: #users) ifFalse: [ ^self ].	html heading level: 4; with: 'Security:'.	html submitButton on: #manageUsers of: self.	html submitButton on: #manageGroups of: self. 	  	! !"Pier-Seaside"!"Pier-Security"!----SNAPSHOT----an Array(20 October 2006 4:29:12 am) Squeak3.9-RC2-7064.2.image priorSource: 3050645!----SNAPSHOT----an Array(20 October 2006 4:41:04 am) Squeak3.9-RC2-7064-SMP.image priorSource: 3052319!----SNAPSHOT----an Array(20 October 2006 4:41:46 am) Squeak3.9-RC2-7064-SMP.image priorSource: 3052422!----SNAPSHOT----an Array(20 October 2006 4:46:31 am) Squeak3.9-RC2-7064-SMP.image priorSource: 3052527!----SNAPSHOT----an Array(20 October 2006 4:56:44 am) Squeak3.9-RC2-7064-SMP.image priorSource: 3052632!!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:55' prior: 36604093!exampleAllClasses| model count |count := 0.model := (PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak'))."Transcript show: model session magmaSession location; cr."model noLog. ProtoObject allSubclassesDo: [ :theClass | count := count + 1.Transcript show: count printString, ': ', theClass name; cr.[  (PRPierifySmalltalkClass target: theClass) into: model. (Delay forSeconds: self pace) wait.] on: PRConflictingNameError do: [ :e | Transcript show: theClass name, ' already exists'; cr. ].]. "self pace: 30.[ self exampleAllClasses ] forkAt: 15"! !!PRPierifySmalltalkClass class methodsFor: 'as yet unclassified' stamp: 'kph 10/19/2006 20:55' prior: 36604799!exampleProtoObject| model |model := PRTimingWrapper on: (PRCommandAppScripter onKernelNamed: 'Squeak').model noLog. ProtoObject in: [ :theClass | Transcript show: theClass name; cr.(PRPierifySmalltalkClass target: theClass) into: model ]."self exampleProtoObject"! !!PRPierPerformance class methodsFor: 'nil' stamp: 'kph 9/27/2006 07:02' prior: 36578850!initialize	| application |	pusher := CTPusher new.	application := self registerAsApplication: 'pier-theatre'.	application preferenceAt: #sessionClass put: CTMagmaSharedSession.	application libraries add: SULibrary; add: CTLibrary.	application configuration addAncestor: PRPierConfiguration new.	application configuration addAncestor: WAMagmaConfiguration new.! !----STARTUP----an Array(20 October 2006 10:54:36 am) as /media/hdb1/Squeak3.9-RC2-7063/Squeak3.9-RC2-7064-SMP.image!!MACheckboxGroupComponent methodsFor: 'rendering' stamp: 'lr 10/20/2006 11:08' prior: 36098159!renderEditorOn: html	self description allOptions		do: [ :each |			html label: [				html checkbox					attributes: self attributes;					value: (self selectedList includes: each);					onTrue: [ self add: each ] onFalse: [ self remove: each ].				html space; text: (self reference toString: each) ] ]		separatedBy: [ html break ]! !!MARadioGroupComponent methodsFor: 'rendering' stamp: 'lr 10/20/2006 11:08' prior: 36097439!renderEditorOn: html	| group |	group := html radioGroup.	self options		do: [ :each |			html label: [				html radioButton					attributes: self attributes;					group: group;					selected: self value = each;					callback: [ self value: each ].				html space; text: (self reference toString: each) ] ]		separatedBy: [ html break ]! !!MAMultiselectListComponent methodsFor: 'rendering' stamp: 'lr 10/20/2006 11:08' prior: 36098872!renderEditorOn: html	html select		attributes: self attributes;		beMultiple;		list: self availableList;		selected: self selectedList;		labels: [ :value | self reference toString: value ];		callback: [ :value | self value: value ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 10/20/2006 11:08' prior: 36600137!renderEditorAvailableOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self availableList;		selected: self availableSelected;		callback: [ :value | self availableSelected: value ];		labels: [ :value | self reference toString: value ]! !!MAListCompositonComponent methodsFor: 'rendering-parts' stamp: 'lr 10/20/2006 11:08' prior: 36600529!renderEditorSelectedOn: html	html select		attributes: self attributes;		size: 6; style: 'width: 150px';		list: self selectedList;		selected: self selectedSelected;		callback: [ :value | self selectedSelected: value ];		labels: [ :value | self reference toString: value ]! !!MASelectListComponent methodsFor: 'rendering' stamp: 'lr 10/20/2006 11:09' prior: 36099979!renderEditorOn: html	html select		attributes: self attributes;		list: self options;		selected: self value;		callback: [ :value | self value: value ];		labels: [ :value | self reference toString: value ];		in: [ :tag |			self description isExtensible ifTrue: [				tag					otherLabel: '(other)'					otherCallback: [ :value | self value: (self reference fromString: value) ]					promptString: 'Please enter another element:' ] ]! !"Magritte-Seaside"!"bootstrap Installer do-it this line first, then the rest of the script"SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All'!"bootstrap Installer do-it this line first, then the rest of the script"SMSqueakMap default loadUpdates installPackageNamed: 'Installer'.squeakmap := Installer squeakmap.squeaksource := Installer repository: 'http://www.squeaksource.com'.lukas := Installer repository: 'http://mc.lukas-renggli.ch/'.mantis := Installer mantis.mantis bug: 4874 fix: 'Join.3.cs'.squeakmap install: 'DynamicBindings'.squeakmap install: 'KomServices'.squeakmap install: 'KomHttpServer'.seaside := squeaksource project: 'Seaside'.seaside answer: '*administrator*' with: 'seaside';	    answer: '*password*' 	 with: 'admin'.seaside	install: 'Seaside2.6b1';		install: 'Scriptaculous-pmm.138'.          magma := squeaksource project: 'MagmaTester'.magma	install: 'MagmaServerLoader';		install: 'Magma server';		install: 'Magma client';		install: 'Magma seaside';		install: 'Magma sunit'.		magma	install: 'Seaside-Examples-Store-Magma'.lukas	answer: 'Would you like*' with: true;		answer: '*name of your Pier kernel*' with: 'Pier 1.0.5 SMP';		answer: '*entry point*' with: 'pier';		answer: '*Application*' with: true.		lukas	project: 'magritte';      	install: 'Magritte-All'.           lukas	project: 'pier';          install: 'Pier-All';          install: #('Pier-Model-kph' 'Pier-Model-sm');          install: 'Pier-Seaside'.lukas  install: 'Pier-Tests';	install: 'Pier-Magma'."optional"lukas  install: 'Pier-Security'. "optional"lukas  install: 'Pier-ScriptingAPI'.Utilities setAuthorInitials: ''!----SNAPSHOT----an Array(20 October 2006 11:07:53 am) Squeak3.9-RC2-7064-SMP.image priorSource: 3052737!