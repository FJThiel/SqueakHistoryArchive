'From Squeak3.10.1 of ''26 May 2008'' [latest update: #7175] on 26 May 2008 at 6:48:48 pm'!!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !!AbstractFont methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ false.! !!ActorState methodsFor: 'initialization' stamp: 'sw 5/13/1998 16:37'!initializeFor: aPlayer	| aNewDictionary |	owningPlayer := aPlayer.	instantiatedUserScriptsDictionary ifNil: [^ self].	aNewDictionary := IdentityDictionary new.	instantiatedUserScriptsDictionary associationsDo: 		[:assoc |			aNewDictionary at: assoc key put: (assoc value shallowCopy player: aPlayer)].	instantiatedUserScriptsDictionary := aNewDictionary.! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:44'!choosePenSize	| menu sz |	menu := CustomMenu new.	1 to: 10 do: [:w | menu add: w printString action: w].	sz := menu startUp.	sz ifNotNil: [penSize := sz]! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:35'!getPenColor	penColor ifNil: [penColor := self defaultPenColor].	^ penColor! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:43'!getPenSize	penSize ifNil: [penSize := self defaultPenSize].	^ penSize! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 18:07'!liftPen	penDown := false! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 14:58'!lowerPen	penDown := true! !!ActorState methodsFor: 'pen' stamp: 'sw 2/4/98 18:03'!penColor: aColor	penColor := aColor! !!ActorState methodsFor: 'pen' stamp: 'tk 10/4/2001 16:43'!setPenArrowheads: aBoolean	penArrowheads := aBoolean! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:51'!setPenColor: aColor	penColor := aColor! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:47'!setPenDown: aBoolean	penDown := aBoolean! !!ActorState methodsFor: 'pen' stamp: 'sw 4/22/1998 13:45'!setPenSize: aNumber	penSize := aNumber! !!ActorState methodsFor: 'pen' stamp: 'sw 4/16/2003 12:26'!trailStyle	"Answer the receiver's trailStyle.  For backward compatibility, if the old penArrowheads slot is in found to be set, use it as a guide for initialization"	^ trailStyle ifNil: [trailStyle := penArrowheads == true ifTrue: [#arrows] ifFalse: [#lines]]! !!ActorState methodsFor: 'pen' stamp: 'sw 3/11/2003 11:28'!trailStyle: aSymbol	"Set the trail style to the given symbol"	trailStyle := aSymbol! !!ActorState methodsFor: 'position' stamp: 'jm 4/24/1998 21:31'!fractionalPosition: aPoint	fractionalPosition := aPoint asFloatPoint.! !!ActorState methodsFor: 'script instantiations' stamp: 'sw 4/9/98 22:35'!instantiatedUserScriptsDictionary	instantiatedUserScriptsDictionary ifNil: [instantiatedUserScriptsDictionary := IdentityDictionary new].	^ instantiatedUserScriptsDictionary! !!AlignmentMorph methodsFor: '*eToys-initialization' stamp: 'ar 10/25/2000 17:53'!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder := Morph new extent: 16 @ 16; beTransparent.	downArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2@-2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseDown send: #upArrowHit to: aMorph.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseDown send: #downArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!AllPlayersTool methodsFor: 'initialization' stamp: 'sw 12/8/2004 11:12'!addHeaderRow	"Add the header morph at the top of the tool"	| aRow title aButton |	aRow := AlignmentMorph newRow.	aRow listCentering: #justified; color: Color transparent.	aButton := self tanOButton.	aButton actionSelector: #delete.	aRow addMorphFront: aButton.	aRow addMorphBack: (title := StringMorph contents: 'Gallery of Players' translated).	title setBalloonText: 'Double-click here to refresh the contents' translated.	title on: #doubleClick send: #reinvigorate to: self.	aRow addMorphBack: self helpButton.	self addMorphFront: aRow.! !!AllPlayersTool methodsFor: 'initialization' stamp: 'sw 7/28/2004 20:48'!initializeFor: aPresenter	"Initialize the receiver as a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the scope of the containing pasteup's presenter"	| placeHolder |	self color: Color brown muchLighter muchLighter; wrapCentering: #center; cellPositioning: #topCenter; vResizing: #shrinkWrap; hResizing: #shrinkWrap.	self useRoundedCorners.	self borderStyle: BorderStyle complexAltInset; borderWidth: 4; borderColor: (Color r: 0.452 g: 0.839 b: 1.0).  "Color fromUser"	self addHeaderRow.	placeHolder := Morph new beTransparent.	placeHolder extent: 200@1.	self addMorphBack: placeHolder.	ActiveWorld presenter reinvigoratePlayersTool: self ! !!AllPlayersTool methodsFor: 'menus' stamp: 'sw 7/28/2004 22:58'!presentHelp	"Sent when a Help button is hit; provide the user with some form of help for the tool at hand"	| aString aTextMorph |	aString := 'About the Gallery of PlayersClick on an object''s picture to reveal its location.Click on the turquoise eye to open the object''s viewer.Click on an object''s name to obtain a tile representing the object.   Double-click on the title ("Gallery of Players") to refresh the tool;this may allow you to see newly-added or newly-scripted objects.'.	aTextMorph :=  TextMorph new contents: aString translated.	aTextMorph useRoundedCorners; borderWidth: 3; borderColor: Color gray; margins: 3@3.	aTextMorph backgroundColor: Color blue muchLighter.	aTextMorph beAllFont: (StrikeFont familyName: #ComicBold size: 18);	 centered; lock.	AlignmentMorph new beTransparent		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		addMorphBack: aTextMorph;		openInHand! !!AllPlayersTool methodsFor: 'reinvigoration' stamp: 'sw 7/19/2004 16:37'!invigorateButton	"Answer a button that triggers reinvigoration"	| aButton |	aButton := IconicButton new target: self;		borderWidth: 0;		labelGraphic: (ScriptingSystem formAtKey: #Refresh);		color: Color transparent; 		actWhen: #buttonUp;		actionSelector: #reinvigorate;		yourself.	aButton setBalloonText: 'Click here to refresh the list of players'.	^ aButton! !!AllPlayersTool methodsFor: 'reinvigoration' stamp: 'sw 7/19/2004 16:17'!menuButton	"Answer a button that brings up a menu.  Useful when adding new features, but at present is between uses"	| aButton |	aButton := IconicButton new target: self;		borderWidth: 0;		labelGraphic: (ScriptingSystem formAtKey: #TinyMenu);		color: Color transparent; 		actWhen: #buttonDown;		actionSelector: #offerMenu;		yourself.	aButton setBalloonText: 'click here to get a menu with further options'.	^ aButton! !!AllScriptsTool methodsFor: 'initialization' stamp: 'dgd 9/19/2003 14:34'!addSecondLineOfControls	"Add the second line of controls"	| aRow outerButton aButton worldToUse |	aRow := AlignmentMorph newRow listCentering: #center; color: Color transparent.	outerButton := AlignmentMorph newRow.	outerButton wrapCentering: #center; cellPositioning: #leftCenter.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	outerButton addMorph: (aButton := UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleWhetherShowingOnlyActiveScripts;		getSelector: #showingOnlyActiveScripts.	outerButton addTransparentSpacerOfSize: (4@0).	outerButton addMorphBack: (StringMorph contents: 'tickers only' translated) lock.	outerButton setBalloonText: 'If checked, then only scripts that are paused or ticking will be shown' translated.	aRow addMorphBack: outerButton.	aRow addTransparentSpacerOfSize: 20@0.	aRow addMorphBack: self helpButton.	aRow addTransparentSpacerOfSize: 20@0.	outerButton := AlignmentMorph newRow.	outerButton wrapCentering: #center; cellPositioning: #leftCenter.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	outerButton addMorph: (aButton := UpdatingThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleWhetherShowingAllInstances;		getSelector: #showingAllInstances.	outerButton addTransparentSpacerOfSize: (4@0).	outerButton addMorphBack: (StringMorph contents: 'all instances' translated) lock.	outerButton setBalloonText: 'If checked, then entries for all instances will be shown, but if not checked, scripts for only one representative of each different kind of object will be shown.  Consult the help available by clicking on the purple ? for more information.' translated.	aRow addMorphBack: outerButton.	self addMorphBack: aRow.	worldToUse := self isInWorld ifTrue: [self world] ifFalse: [ActiveWorld].	worldToUse presenter reinvigorateAllScriptsTool: self.	self layoutChanged.! !!AllScriptsTool methodsFor: 'initialization' stamp: 'sw 12/8/2004 11:26'!initializeFor: ignored	"Initialize the receiver as a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the scope of the containing pasteup's presenter"	| aRow aButton |	showingOnlyActiveScripts := true.	showingAllInstances := true.	showingOnlyTopControls := true.	self color: Color brown muchLighter muchLighter; wrapCentering: #center; cellPositioning: #topCenter; vResizing: #shrinkWrap; hResizing: #shrinkWrap.	self useRoundedCorners.	self borderWidth: 4; borderColor: Color brown darker.	aRow := AlignmentMorph newRow.	aRow listCentering: #justified; color: Color transparent.	aButton := self tanOButton.	aButton actionSelector: #delete.	aRow addMorphFront: aButton.	aRow addMorphBack: ScriptingSystem scriptControlButtons.	aRow addMorphBack: self openUpButton.	self addMorphFront: aRow.! !!AllScriptsTool methodsFor: 'initialization' stamp: 'dgd 9/19/2003 14:35'!presentHelp	"Sent when a Help button is hit; provide the user with some form of help for the tool at hand"	| aString |	aString := 'This tool allows you to see all the scripts for all the objects in this project.Sometimes you are only interested in those scripts that are ticking, or that are *ready* to tick when you hit the GO button (which are said to be "paused.")Check "tickers only" if you only want to see such scripts -- i.e., scripts that are either paused or ticking.If "tickers only" is *not* checked, then all scripts will be shown, whatever their status.The other checkbox, labeled "all instances", only comes into play if you have created "multiple sibling instances" (good grief) of the same object, which share the same scripts; if you have such things, it is often convenient to see the scripts of just *one* such sibling, because it will take up less space and require less mindshare -- and note that you can control a script for an object *and* all its siblings from the menu of that one that you see, via menu items such as "propagate status to siblings".If "all instances" is checked, scripts for all sibling instances will be shown, whereas if "all instances" is *not* checked, only one of each group of siblings will be selected to have its scripts shown.But how do you get "multiple sibling instances" of the same object?  There are several ways:(1)  Use the "make a sibling instance" or the "make multiple siblings..." menu item in the halo menu of a scripted object(2)  Use the "copy" tile in a script.(3)  Request "give me a copy now" from the menu associated with the "copy" item in a ViewerIf you have on your screen multiple sibling instances of the same object, then you may or may want to see them all in the All Scripts tool, and that is what the "all instances" checkbox governs.Set "all instances" if you want a separate entry for each instance, asopposed to a single representative of that kind of object.Note that if you obtain a copy of an object by using the green halo handle, it will *not* be a sibling instance of the original.  It will in many ways seem to be, because it will start out its life having the same scripts as the original.  But it will then lead an independent life, so that changes to scripts of the original will not be reflected in it, and vice-versa.This is an important distinction, and an unavoidable one because people sometimes want the deep sharing of sibling instances and sometimes they clearly do not.  But the truly understandable description of these concepts and distinctions certainly lies *ahead* of us!!'.	(StringHolder new contents: aString translated)		openLabel: 'About the All Scripts tool' translated! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 12/8/2004 11:28'!openUpButton	"Answer a button whose action would be to open up the receiver or snap it back closed"	| aButton aForm |	aButton := IconicButton new borderWidth: 0.	aForm := ScriptingSystem formAtKey: #PowderBlueOpener.	aForm ifNil:		[aForm := Form extent: 13@22 depth: 16 fromArray: #( 0 0 12017 787558129 0 0 0 0 12017 787561309 995965789 787558129 0 0 0 787561309 995965789 995965789 995965789 787546112 0 12017 995965789 995965789 995965789 995965789 995962609 0 12017 995965789 995965789 995965789 995965789 995962609 0 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995950593 80733 995965789 995965789 787546112 787561309 995965789 65537 65537 80733 995965789 787546112 787561309 995950593 80733 995950593 80733 995965789 787546112 787561309 995950593 80733 995950593 80733 995965789 787546112 787561309 995950593 65537 65537 80733 995965789 787546112 787561309 995965789 65537 65537 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 787561309 995965789 995965789 995965789 995965789 995965789 787546112 12017 995965789 995965789 995965789 995965789 995962609 0 12017 995965789 995965789 995965789 995965789 995962609 0 0 787561309 995965789 995965789 995965789 787546112 0 0 12017 787561309 995965789 787558129 0 0 0 0 12017 787558129 0 0 0) offset: 0@0.		ScriptingSystem saveForm: aForm atKey: #PowderBlueOpener].	aButton labelGraphic: aForm.	aButton		target: self;		color: Color transparent;		actionSelector: #toggleWhetherShowingOnlyTopControls;		setBalloonText: 'open or close the lower portion that shows individual scripts' translated.	^ aButton! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/13/2001 19:43'!showingOnlyTopControls	"Answer whether the receiver is currently showing only the top controls" 	^ showingOnlyTopControls ifNil: [showingOnlyTopControls := true]! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingAllInstances	"Toggle whether the receiver is showing all instances or only one exemplar per uniclass"	showingAllInstances := showingAllInstances not.	self presenter reinvigorateAllScriptsTool: self! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingOnlyActiveScripts	"Toggle whether the receiver is showing only active scripts"	showingOnlyActiveScripts := showingOnlyActiveScripts not.	self presenter reinvigorateAllScriptsTool: self! !!AllScriptsTool methodsFor: 'toggles' stamp: 'sw 11/14/2001 00:32'!toggleWhetherShowingOnlyTopControls	"Toggle whether the receiver is showing only the stop/step/go line or the full whammy"	| aCenter |	showingOnlyTopControls := self showingOnlyTopControls not.	aCenter := self center x.	self showingOnlyTopControls		ifTrue:			[self removeAllButFirstSubmorph]		ifFalse:			[self addSecondLineOfControls.			self presenter reinvigorateAllScriptsTool: self].	WorldState addDeferredUIMessage:		[self center: (aCenter @ self center y)]	! !!AllScriptsTool class methodsFor: 'instance creation' stamp: 'sw 6/12/2001 11:52'!allScriptsToolForActiveWorld	"Launch an AllScriptsTool to view scripts of the active world"	| aTool |	aTool := self newColumn.	aTool initializeFor: ActiveWorld presenter.	^ aTool! !!AllScriptsTool class methodsFor: 'instance creation' stamp: 'sw 1/30/2001 23:06'!launchAllScriptsToolFor: aPresenter	"Launch an AllScriptsTool to view scripts of the given presenter"	| aTool |	aTool := self newColumn.	aTool initializeFor: aPresenter.	self currentHand attachMorph: aTool.	aPresenter associatedMorph world startSteppingSubmorphsOf: aTool! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'wiz 1/1/2007 20:21'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue		ifTrue: [^self].	self changed .	self image: (images at:	(imageIndex _ imageIndex \\ images size + 1)).	self changed . 	d _ (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!Arc methodsFor: 'accessing'!center: aPoint 	"Set aPoint to be the receiver's center."	center := aPoint! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger 	"The receiver is defined by a point at the center and a radius. The 	quadrant is not reset."	center := aPoint.	radius := anInteger! !!Arc methodsFor: 'accessing'!center: aPoint radius: anInteger quadrant: section 	"Set the receiver's quadrant to be the argument, section. The size of the 	receiver is defined by the center and its radius."	center := aPoint.	radius := anInteger.	quadrant := section! !!Arc methodsFor: 'accessing'!quadrant: section 	"Set the part of the circle represented by the receiver to be the argument, 	section."	quadrant := section! !!Arc methodsFor: 'accessing'!radius: anInteger 	"Set the receiver's radius to be the argument, anInteger."	radius := anInteger! !!Arc methodsFor: 'display box access'!computeBoundingBox	| aRectangle aPoint |	aRectangle := center - radius + form offset extent: form extent + (radius * 2) asPoint.	aPoint := center + form extent.	quadrant = 1 ifTrue: [^ aRectangle encompass: center x @ aPoint y].	quadrant = 2 ifTrue: [^ aRectangle encompass: aPoint x @ aPoint y].	quadrant = 3 ifTrue: [^ aRectangle encompass: aPoint x @ center y].	quadrant = 4 ifTrue: [^ aRectangle encompass: center x @ center y]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| nSegments line angle sin cos xn yn xn1 yn1 |	nSegments := 12.0.	line := Line new.	line form: self form.	angle := 90.0 / nSegments.	sin := (angle * (2 * Float pi / 360.0)) sin.	cos := (angle * (2 * Float pi / 360.0)) cos.	quadrant = 1		ifTrue: 			[xn := radius asFloat.			yn := 0.0].	quadrant = 2		ifTrue: 			[xn := 0.0.			yn := 0.0 - radius asFloat].	quadrant = 3		ifTrue: 			[xn := 0.0 - radius asFloat.			yn := 0.0].	quadrant = 4		ifTrue: 			[xn := 0.0.			yn := radius asFloat].	nSegments asInteger		timesRepeat: 			[xn1 := xn * cos + (yn * sin).			yn1 := yn * cos - (xn * sin).			line beginPoint: center + (xn asInteger @ yn asInteger).			line endPoint: center + (xn1 asInteger @ yn1 asInteger).			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			xn := xn1.			yn := yn1]! !!Arc methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newArc tempCenter |	newArc := Arc new.	tempCenter := aTransformation applyTo: self center.	newArc center: tempCenter x asInteger @ tempCenter y asInteger.	newArc quadrant: self quadrant.	newArc radius: (self radius * aTransformation scale x) asInteger.	newArc form: self form.	newArc		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Arc class methodsFor: 'examples'!example	"Click the button somewhere on the screen. The designated point will	be the center of an Arc with radius 50 in the 4th quadrant."	| anArc aForm |	aForm := Form extent: 1 @ 30.	"make a long thin Form for display"	aForm fillBlack.						"turn it black"	anArc := Arc new.	anArc form: aForm.					"set the form for display"	anArc radius: 50.0.	anArc center: Sensor waitButton.	anArc quadrant: 4.	anArc displayOn: Display.	Sensor waitButton	"Arc example"! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 5/7/2007 11:34'!openNewArchive	|  result |	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	self fileName: (result directory fullNameFor: result name).! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'edc 7/13/2006 17:46'!saveArchive	| result name |		name := FileDirectory  localNameFor: labelString .	self canSaveArchive ifFalse: [ ^self ].	result := FillInTheBlank		request: 'Name this zip '		initialAnswer:  name		centerAt: Display center.	result ifNil: [ ^self ].		(archive canWriteToFileNamed: result)		ifFalse: [ self inform: name, ' is used by one or more membersin your archive, and cannot be overwritten.Try writing to another file name'.			^self ].	[ archive writeToFileNamed: result ] on: Error do: [ :ex | self inform: ex description. ].	self setLabel: name asString.	self changed: #memberList	"in case CRC's and compressed sizes got set"! !!ArchiveViewer methodsFor: 'initialization' stamp: 'edc 11/23/2007 09:32'!createListHeadingUsingFont: font	| sm |	sm := StringMorph contents: ' order  uncomp   comp   CRC-32       date     time     file name'.	font ifNotNil: [ sm font: font ].	^(AlignmentMorph newColumn)		color: self defaultBackgroundColor;		addMorph: sm;		yourself.! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:32'!displayLineFor: aMember	| stream dateTime index |	index := self archive members indexOf: aMember.	stream := WriteStream on: (String new: 60).	dateTime := Time dateAndTimeFromSeconds: aMember lastModTime. 	stream	nextPutAll: (index printString padded: #left to: 4 with: $  );	space;		nextPutAll: (aMember uncompressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember compressedSize printString padded: #left to: 8 with: $  );		space; space;		nextPutAll: (aMember crc32String );		space; space.	dateTime first printOn: stream format: #(3 2 1 $- 2 1 2).	stream space; space.	dateTime second print24: true showSeconds: false on: stream.	stream space; space;		nextPutAll: (aMember fileName ).	^stream contents! !!ArchiveViewer methodsFor: 'member list' stamp: 'edc 11/23/2007 09:51'!memberMenu: menu shifted: shifted	| services |	menu		add: 'Comment archive' target: self selector: #commentArchive;		balloonTextForLastItem: 'Add a comment for the entire archive'.	self selectedMember ifNotNilDo: [ :member |		menu			addLine;			add: 'Inspect member' target: self selector: #inspectMember;			balloonTextForLastItem: 'Inspect the selected member';			add: 'Comment member' target: self selector: #commentMember;			balloonTextForLastItem: 'Add a comment for the selected member';			addLine;			add: 'member go up in order ' target: self selector: #upMember;			add: 'member go down in order ' target: self selector: #downMember;			add: 'select member order ' target: self selector: #toIndexPlace;			addLine.		services := FileList itemsForFile: member fileName.		menu addServices2: services for: self extraLines: #().	].	^menu! !!ArchiveViewer methodsFor: 'member operations' stamp: 'edc 7/13/2006 12:10'!addMember	| result local full |	self canAddMember ifFalse: [ ^self ].	result := FileList2 modalFileSelector .	result ifNil: [ ^self ].	local := result directory localNameFor: result name.	full := result directory fullNameFor: result name.		(archive addFile: full as: local)		desiredCompressionMethod: ZipArchive compressionDeflated.	self memberIndex: self members size.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:18'!downMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  + 1).	self archive members at: (memberIndex  +1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!toIndexPlace| index max temp |max := self archive members size.index :=0.[index := (FillInTheBlank		request: 'To which index '		initialAnswer:  '1'		centerAt: Display center) asInteger.		index between: 1 and: max] whileFalse.	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: index).	self archive members at: index put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer methodsFor: 'member order' stamp: 'edc 11/23/2007 09:57'!upMember| temp |	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: memberIndex  -1).	self archive members at: (memberIndex  -1) put: temp.	self memberIndex:  0.	self changed: #memberList.! !!ArchiveViewer class methodsFor: 'fileIn/Out' stamp: 'edc 6/26/2007 07:09'!services		^ Array 		with: self serviceAddToNewZip		with: self serviceOpenInZipViewer										! !!Array methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:08'!preMultiplyByMatrix: m	"Answer m+*self where m is a Matrix."	|s|	m columnCount = self size ifFalse: [self error: 'dimensions do not conform'].	^(1 to: m rowCount) collect: [:row |		s := 0.		1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].		s]! !!Array methodsFor: 'converting' stamp: 'ar 4/10/2005 18:03'!evalStrings	   "Allows you to construct literal arrays.    #(true false nil '5@6' 'Set new' '''text string''') evalStrings    gives an array with true, false, nil, a Point, a Set, and a String    instead of just a bunch of Symbols"    | it |    ^ self collect: [:each |        it := each.        each == #true ifTrue: [it := true].		      each == #false ifTrue: [it := false].        each == #nil ifTrue: [it := nil].        (each isString and:[each isSymbol not]) ifTrue: [			it := Compiler evaluate: each].        each class == Array ifTrue: [it := it evalStrings].        it]! !!Array methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:35'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am one of two shared global arrays, write a proxy instead."self == (TextConstants at: #DefaultTabsArray) ifTrue: [	dp := DiskProxy global: #TextConstants selector: #at: args: #(DefaultTabsArray).	refStrm replace: self with: dp.	^ dp].self == (TextConstants at: #DefaultMarginTabsArray) ifTrue: [	dp := DiskProxy global: #TextConstants selector: #at: args: #(DefaultMarginTabsArray).	refStrm replace: self with: dp.	^ dp].^ super objectForDataStream: refStrm! !!Array methodsFor: 'private' stamp: 'md 1/20/2006 16:53'!hasLiteralThorough: literal	"Answer true if literal is identical to any literal in this array, even if imbedded in further array structures or closure methods"	| lit |	1 to: self size do: [:index |		(lit := self at: index) == literal ifTrue: [^ true].		(lit hasLiteralThorough: literal) ifTrue: [^ true]].	^ false! !!Array methodsFor: 'private' stamp: 'sma 6/3/2000 21:39'!hasLiteral: literal	"Answer true if literal is identical to any literal in this array, even 	if imbedded in further array structure. This method is only intended 	for private use by CompiledMethod hasLiteralSymbol:"	| lit |	1 to: self size do: 		[:index | 		(lit := self at: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!Array methodsFor: 'private' stamp: 'md 3/1/2006 21:09'!hasLiteralSuchThat: testBlock	"Answer true if testBlock returns true for any literal in this array, even if imbedded in 	further Arrays or CompiledMethods.  This method is only intended for private use by 	CompiledMethod 	hasLiteralSuchThat:"	| lit |	1 to: self size do: [:index |		(testBlock value: (lit := self at: index)) ifTrue: [^ true].		(lit hasLiteralSuchThat: testBlock) ifTrue: [^ true]].	^ false! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWith: a	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 1.	array at: 1 put: a.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:15'!braceWith: a with: b 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 2.	array at: 1 put: a.	array at: 2 put: b.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 3.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c with: d	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array := self new: 4.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	array at: 4 put: d.	^ array! !!ArrayTest methodsFor: 'testing' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := Array new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!ArrayTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:40'!testAtWrap	|tabTest|	tabTest := #(5 6 8).	self assert:(tabTest atWrap: 2) = 6.	self assert:(tabTest atWrap:7) = 5.	self assert:( tabTest atWrap:5) = 6.	self assert:(tabTest atWrap:0)= 8.	self assert:(tabTest atWrap:1)= 5.	self assert:(tabTest atWrap:-2) = 5.! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'tk 3/7/2001 17:36'!swapHalves		"A normal switch in endianness (byte order in words) reverses the order of 4 bytes.  That is not correct for SoundBuffers, which use 2-bytes units.  If a normal switch has be done, this method corrects it further by swapping the two halves of the long word.	This method is only used for 16-bit quanities in SoundBuffer, ShortIntegerArray, etc."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack := Form new hackBits: self.	blt := (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "Exchange bytes 0&1 with 2&3"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:57'!isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSortedBy: [:a :b | a <= b]."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:index | 		elm := self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm := elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:58'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:index | 		elm := self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm := elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:28'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 := first.	i2 := middle + 1.	val1 := self at: i1.	val2 := self at: i2.	out := first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out := out + 1) put: val1.					val1 := self at: (i1 := i1 + 1)]			ifFalse: [dst at: (out := out + 1) put: val2.					i2 := i2 + 1.					i2 <= last ifTrue: [val2 := self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:26'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle := (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!ArrayedCollection methodsFor: 'private'!storeElementsFrom: firstIndex to: lastIndex on: aStream	| noneYet defaultElement arrayElement |	noneYet := true.	defaultElement := self defaultElement.	firstIndex to: lastIndex do: 		[:index | 		arrayElement := self at: index.		arrayElement = defaultElement			ifFalse: 				[noneYet					ifTrue: [noneYet := false]					ifFalse: [aStream nextPut: $;].				aStream nextPutAll: ' at: '.				aStream store: index.				aStream nextPutAll: ' put: '.				aStream store: arrayElement]].	^noneYet! !!ArrayedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newArray |	newArray := self new: aCollection size.	1 to: aCollection size do: [:i | newArray at: i put: (aCollection at: i)].	^ newArray"	Array newFrom: {1. 2. 3}	{1. 2. 3} as: Array	{1. 2. 3} as: ByteArray	{$c. $h. $r} as: String	{$c. $h. $r} as: Text"! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'ar 5/17/2001 19:50'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."	| len |	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].		"super may cause an error, but will not be called."	s next = 16r80 ifTrue:		["A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^ self error: 'not implemented'].	s skip: -1.	len := s nextInt32.	^ s nextWordsInto: (self basicNew: len)! !!ArrayedCollection class methodsFor: 'instance creation'!with: anObject 	"Answer a new instance of me, containing only anObject."	| newCollection |	newCollection := self new: 1.	newCollection at: 1 put: anObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject 	"Answer a new instance of me, containing firstObject and secondObject."	| newCollection |	newCollection := self new: 2.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection := self new: 3.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer a new instance of me, containing only the three arguments as	elements."	| newCollection |	newCollection := self new: 4.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of me, containing only the five arguments as	elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection := self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!AssignmentTileMorph methodsFor: 'code generation' stamp: 'sw 2/6/2002 01:25'!operatorForAssignmentSuffix: aString	"Answer the operator associated with the receiver, assumed to be one of the compound assignments"	| toTest |	toTest := aString asString.	#(	('Incr:'				'+')		('Decr:'				'-')		('Mult:'				'*'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"AssignmentTileMorph new operatorForAssignmentSuffix: 'Incr:'"! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:11'!computeOperatorOrExpression	"Compute the operator or expression to use, and set the wording correectly on the tile face"	| aSuffix wording anInterface getter doc |	operatorOrExpression := (assignmentRoot, assignmentSuffix) asSymbol.	aSuffix := self currentVocabulary translatedWordingFor:  assignmentSuffix.	getter := Utilities getterSelectorFor: assignmentRoot.	anInterface := self currentVocabulary methodInterfaceAt: getter ifAbsent: [Vocabulary eToyVocabulary methodInterfaceAt: getter ifAbsent: [nil]].	wording := anInterface ifNotNil: [anInterface wording] ifNil: [assignmentRoot copyWithout: $:].	(anInterface notNil and: [(doc := anInterface documentation) notNil])		ifTrue:			[self setBalloonText: doc].	operatorReadoutString := wording translated, ' ', aSuffix. 	self line1: operatorReadoutString.	self addArrowsIfAppropriate! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type := #operator.	assignmentSuffix := ':'! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'sw 1/17/1999 21:10'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self line1: (ScriptingSystem wordingForOperator: operatorOrExpression).	self addArrowsIfAppropriate; updateLiteralLabel! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'yo 1/1/2004 19:50'!setRoot: aString	"Establish the assignment root, and update the label on the tile"	assignmentRoot := aString.	self updateLiteralLabel! !!AssignmentTileMorph methodsFor: 'initialization' stamp: 'sw 2/16/98 01:12'!setRoot: aString dataType: aSymbol	assignmentRoot := aString.	assignmentSuffix := ':'.	dataType := aSymbol.	self updateLiteralLabel! !!Association methodsFor: 'accessing'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key := aKey.	value := anObject! !!Association methodsFor: 'accessing'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	value := anObject! !!Association methodsFor: 'objects from disk' stamp: 'tk 10/3/2000 13:03'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  If I am a known global, write a proxy that will hook up with the same resource in the destination system."	^ (Smalltalk associationAt: key ifAbsent: [nil]) == self 		ifTrue: [dp := DiskProxy global: #Smalltalk selector: #associationOrUndeclaredAt: 							args: (Array with: key).			refStrm replace: self with: dp.			dp]		ifFalse: [self]! !!AsyncFile methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 22:13'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name := fullFileName.	writeable := aBoolean.	semaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	fileHandle := self primOpen: name asVmPathName forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore := nil.		^ nil].! !!AttributedTextStream methodsFor: 'access' stamp: 'ar 10/16/2001 22:57'!currentAttributes: newAttributes	"set the current attributes"	(currentRun > 0 and:[currentAttributes ~= newAttributes]) ifTrue:[		attributeRuns nextPut: currentRun.		attributeValues nextPut: currentAttributes.		currentRun := 0.	].	currentAttributes := newAttributes.! !!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'ar 10/16/2001 22:39'!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text new: characters size.	"this is declared private, but it's exactly what I need, and it's declared as exactly what I want it to do...."	ans setString: characters contents  setRuns: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ar 10/16/2001 22:38'!nextPut: aChar	currentRun := currentRun + 1.	characters nextPut: aChar! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ar 10/16/2001 22:38'!nextPutAll: aString	"add an entire string with the same attributes"	currentRun := currentRun + aString size.	characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'private-initialization' stamp: 'ar 10/16/2001 22:40'!initialize	characters := WriteStream on: String new.	currentAttributes := OrderedCollection new.	currentRun := 0.	attributeValues := WriteStream on: (Array new: 50).	attributeRuns := WriteStream on: (Array new: 50).	! !!Bag methodsFor: 'accessing' stamp: 'tao 1/5/2000 18:25'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s := self size / 100.0. n := 0.	^ self sortedCounts asArray collect:		[:a | n := n + a key. (n / s roundTo: 0.1) -> a value]! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:35'!size	"Answer how many elements the receiver contains."	| tally |	tally := 0.	contents do: [:each | tally := tally + each].	^ tally! !!Bag methodsFor: 'accessing' stamp: 'sma 6/15/2000 17:00'!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	| counts |	counts := SortedCollection sortBlock: [:x :y | x >= y].	contents associationsDo:		[:assn |		counts add: (Association key: assn value value: assn key)].	^ counts! !!Bag methodsFor: 'accessing'!sortedElements	"Answer with a collection of elements with counts, sorted by element."	| elements |	elements := SortedCollection new.	contents associationsDo: [:assn | elements add: assn].	^elements! !!Bag methodsFor: 'removing' stamp: 'sma 5/12/2000 14:32'!remove: oldObject ifAbsent: exceptionBlock 	"Refer to the comment in Collection|remove:ifAbsent:."	| count |	count := contents at: oldObject ifAbsent: [^ exceptionBlock value].	count = 1		ifTrue: [contents removeKey: oldObject]		ifFalse: [contents at: oldObject put: count - 1].	^ oldObject! !!Bag methodsFor: 'private' stamp: 'sma 5/12/2000 14:49'!setContents: aDictionary	contents := aDictionary! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:34'!mimeDecode	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full byte stream of characters.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)) asCharacter.		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)) asCharacter.		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD) asCharacter.		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:39'!mimeDecodeToByteArray	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full ByteArray of 0-255 values.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) ifNil: [^ dataStream].		(nibB := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)).		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)).		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) ifNil: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD).		].	^ dataStream! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'ls 2/10/2001 13:26'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib lineLength |	phase1 := phase2 := false.	lineLength := 0.	[dataStream atEnd] whileFalse: [		lineLength >= 70 ifTrue: [ mimeStream cr.  lineLength := 0. ].		data := raw := dataStream next asInteger.		nib := (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase1 := true].		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib := (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase2 := true].		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib := (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib := (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1).		lineLength := lineLength + 4.].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'tk 12/9/97 13:21'!nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw := mimeStream next.	raw ifNil: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num := FromCharTable at: raw asciiValue + 1.	num ifNotNil: [^ num].	"else ignore space, return, tab, ..."	true] whileTrue.! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 2/19/2000 15:53'!decodeInteger: mimeString	| bytes sum |	"Decode the MIME string into an integer of any length"	bytes := (Base64MimeConverter mimeDecodeToBytes: 				(ReadStream on: mimeString)) contents.	sum := 0.	bytes reverseDo: [:by | sum := sum * 256 + by].	^ sum! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 2/21/2000 17:22'!encodeInteger: int	| strm |	"Encode an integer of any length and return the MIME string"	strm := ReadWriteStream on: (ByteArray new: int digitLength).	1 to: int digitLength do: [:ii | strm nextPut: (int digitAt: ii)].	strm reset.	^ ((self mimeEncode: strm) contents) copyUpTo: $=	"remove padding"! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:53'!initialize	FromCharTable := Array new: 256.	"nils"	ToCharTable := Array new: 64.	($A asciiValue to: $Z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind-1.		ToCharTable at: ind put: val asCharacter].	($a asciiValue to: $z asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25.		ToCharTable at: ind+26 put: val asCharacter].	($0 asciiValue to: $9 asciiValue) doWithIndex: [:val :ind | 		FromCharTable at: val+1 put: ind+25+26.		ToCharTable at: ind+26+26 put: val asCharacter].	FromCharTable at: $+ asciiValue + 1 put: 62.	ToCharTable at: 63 put: $+.	FromCharTable at: $/ asciiValue + 1 put: 63.	ToCharTable at: 64 put: $/.	! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/12/97 11:41'!mimeDecodeToBytes: aStream 	"Return a RWBinaryOrTextStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (RWBinaryOrTextStream on: (ByteArray new: aStream size * 3 // 4)).	me mimeDecodeToByteArray.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 13:01'!mimeDecodeToChars: aStream 	"Return a ReadWriteStream of the original String.  aStream has only 65 innocuous character values.  It is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (ReadWriteStream on: (String new: aStream size * 3 // 4)).	me mimeDecode.	me dataStream position: 0.	^ me dataStream! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'tk 12/9/97 12:28'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	aStream position: 0.	me := self new dataStream: aStream.	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream! !!BitEditor methodsFor: 'control defaults'!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color := 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint := (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint := view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor methodsFor: 'initialize-release'!release	super release.	squareForm release.	squareForm := nil! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:53'!getCurrentColor	| formExtent form c |	c := Color colorFromPixelValue: color depth: Display depth.	formExtent := 30@30" min: 10@ 10//(2+1@2)".  "compute this better"	form := Form extent: formExtent depth: Display depth.	form borderWidth: 5.	form border: form boundingBox width: 4 fillColor: Color white.	form fill: form boundingBox fillColor: c.	^form! !!BitEditor methodsFor: 'menu messages' stamp: 'BG 12/5/2003 13:21'!setColor: aColor 	"Set the color that the next edited dots of the model to be the argument,  	aSymbol. aSymbol can be any color changing message understood by a  	Form, such as white or black."	color := aColor pixelValueForDepth: Display depth.	squareForm fillColor: aColor.	self changed: #getCurrentColor! !!BitEditor methodsFor: 'menu messages' stamp: 'sma 3/15/2000 21:10'!setTransparentColor	squareForm fillColor: Color gray.	color := Color transparent! !!BitEditor methodsFor: 'view access'!view: aView	super view: aView.	scale := aView transformation scale.		scale := scale x rounded @ scale y rounded.	squareForm := Form extent: scale depth: aView model depth.	squareForm fillBlack! !!BitEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 14:48'!initialize	"The Bit Editor is the only controller to override the use of the blue	button with a different pop-up menu. Initialize this menu."	YellowButtonMenu := SelectionMenu		labels:'cancelacceptfile outtest'		lines: #(2 3)		selections: #(cancel accept fileOut test)	"BitEditor initialize"! !!BitEditor class methodsFor: 'examples'!magnifyOnScreen	"Bit editing of an area of the display screen. User designates a 	rectangular area that is magnified by 8 to allow individual screens dots to	be modified. red button is used to set a bit to black and yellow button is	used to set a bit to white. Editor is not scheduled in a view. Original	screen location is updated immediately. This is the same as FormEditor	magnify."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8 @ 8.	smallRect := Rectangle fromUser.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	tempRect := self locateMagnifiedView: smallForm scale: scaleFactor.	"show magnified form size until mouse is depressed"	self		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor	"BitEditor magnifyOnScreen."! !!BitEditor class methodsFor: 'examples'!magnifyWithSmall"	Also try:	BitEditor openOnForm:		(Form extent: 32@32 depth: Display depth)	BitEditor openOnForm:		((MaskedForm extent: 32@32 depth: Display depth)		withTransparentPixelValue: -1)"	"Open a BitEditor viewing an area on the screen which the user chooses"	| area form |	area := Rectangle fromUser.	area isNil ifTrue: [^ self].	form := Form fromDisplay: area.	self openOnForm: form	"BitEditor magnifyWithSmall."! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm 	"Create and schedule a BitEditor on the form aForm at its top left corner. 	Show the small and magnified view of aForm."	| scaleFactor |	scaleFactor := 8 @ 8.	^self openOnForm: aForm		at: (self locateMagnifiedView: aForm scale: scaleFactor) topLeft		scale: scaleFactor! !!BitEditor class methodsFor: 'instance creation'!openOnForm: aForm at: magnifiedLocation scale: scaleFactor 	"Create and schedule a BitEditor on the form aForm. Show the small and 	magnified view of aForm."	| aScheduledView |	aScheduledView := self				bitEdit: aForm				at: magnifiedLocation				scale: scaleFactor				remoteView: nil.	aScheduledView controller openDisplayAt:		aScheduledView displayBox topLeft + (aScheduledView displayBox extent / 2)! !!BitEditor class methodsFor: 'instance creation' stamp: 'sma 3/11/2000 11:29'!openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor	"Create and schedule a BitEditor on the form aForm. Show the magnified	view of aForm in a scheduled window."	| smallFormView bitEditor savedForm r |	smallFormView := FormView new model: aForm.	smallFormView align: smallFormView viewport topLeft with: formLocation.	bitEditor := self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.	savedForm := Form fromDisplay: (r := bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	savedForm displayOn: Display at: r topLeft.	bitEditor release.	smallFormView release.	"BitEditor magnifyOnScreen."! !!BitEditor class methodsFor: 'private' stamp: 'BG 12/4/2003 10:18'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView	"Create a BitEditor on aForm. That is, aForm is a small image that will 	change as a result of the BitEditor changing a second and magnified 	view of me. magnifiedFormLocation is where the magnified form is to be 	located on the screen. scaleFactor is the amount of magnification. This 	method implements a scheduled view containing both a small and 	magnified view of aForm. Upon accept, aForm is updated."	| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |	scaledFormView := FormHolderView new model: aForm.	scaledFormView scaleBy: scaleFactor.	bitEditor := self new.	scaledFormView controller: bitEditor.	bitEditor setColor: Color black.	topView := ColorSystemView new.	remoteView == nil ifTrue: [topView label: 'Bit Editor'].	topView borderWidth: 2.	topView addSubView: scaledFormView.	remoteView == nil		ifTrue:  "If no remote view, then provide a local view of the form"			[aFormView := FormView new model: scaledFormView workingForm.			aFormView controller: NoController new.			aForm height < 50				ifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 2]				ifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 2 bottom: 0].			topView addSubView: aFormView below: scaledFormView]		 ifFalse:  "Otherwise, the remote one should view the same form"			[remoteView model: scaledFormView workingForm].	lowerRightExtent := remoteView == nil			ifTrue:				[(scaledFormView viewport width - aFormView viewport width) @					(aFormView viewport height max: 50)]			ifFalse:				[scaledFormView viewport width @ 50].	menuView := self buildColorMenu: lowerRightExtent colorCount: 1.	menuView model: bitEditor.	menuView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	topView		addSubView: menuView		align: menuView viewport topRight		with: scaledFormView viewport bottomRight.	extent := scaledFormView viewport extent + (0 @ lowerRightExtent y)			+ (4 @ 4).  "+4 for borders"	topView minimumSize: extent.	topView maximumSize: extent.	topView translateBy: magnifiedFormLocation.	topView insideColor: Color white.	^topView! !!BitEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 13:40'!buildColorMenu: extent colorCount: nColors	"See BitEditor magnifyWithSmall."	| menuView form aSwitchView	 button formExtent highlightForm color leftOffset |	menuView := FormMenuView new.	menuView window: (0@0 corner: extent).	formExtent := 30@30 min: extent//(nColors*2+1@2).  "compute this better"	leftOffset := extent x-(nColors*2-1*formExtent x)//2.	highlightForm := Form extent: formExtent.	highlightForm borderWidth: 4.	1 to: nColors do: [:index | 		color := (nColors = 1			ifTrue: [#(black)]			ifFalse: [#(black gray)]) at: index.		form := Form extent: formExtent.		form fill: form boundingBox fillColor: (Color perform: color).		form borderWidth: 5.		form border: form boundingBox width: 4 fillColor: Color white.		button := Button new.		aSwitchView := PluggableButtonView			on: button			getState: #isOn			action: #turnOn			label: #getCurrentColor.		index = 1			ifTrue: [button onAction: [menuView model setColor: Color fromUser.									  aSwitchView label: menuView model getCurrentColor;									                  displayView					                     ]				    ]			ifFalse: [button onAction: [menuView model setTransparentColor]].		aSwitchView			shortcutCharacter: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index);			label: form;			window: (0@0 extent: form extent);			translateBy: (((index - 1) * 2 * form width) + leftOffset)@(form height // 2);			borderWidth: 1.		menuView addSubView: aSwitchView].	^ menuView! !!BlockClosure methodsFor: 'accessing' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: literal	"Answer true if literal is identical to any literal imbedded in my method"	method == literal ifTrue: [^ true].	^ method hasLiteralThorough: literal from: self! !!BlockClosure methodsFor: 'comparing' stamp: 'ms 8/8/2007 11:49'!= other	self class == other class ifFalse: [^ false].	self env = other env ifFalse: [^ false].	self method == other method ifTrue: [^true].	^ self method = other method! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:14'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.					"start up the watchdog"		self ensure:[							"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 5/9/2007 12:44'!exempleBlock	"BlockClosureTest>>#exempleBlock"	| b |	i := 21. 	j := 0.	b := #(1 2 3) .	b value.	^j! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 5/9/2007 11:47'!exempleClosure	"BlockClosureTest>>#exempleClosure"	(i:= i-1) > 0 		ifTrue: [j := j+1 . #(1 2 3) value.] 		ifFalse:[j]! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 8/8/2007 11:47'!exempleClosureEqual1	^3 + 7! !!BlockClosureTest methodsFor: 'utils' stamp: 'ms 8/8/2007 11:47'!exempleClosureEqual2	^3 + 7! !!BlockClosureTest methodsFor: 'running' stamp: 'ms 5/10/2007 11:27'!setUp	closure := BlockClosureTest >> #exempleClosure createBlock: self.	BlockClosureTest >> #exempleBlock literalAt: 2 put: closure.	BlockClosureTest >> #exempleClosure literalAt: 1 put: closure! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 5/10/2007 11:24'!testComparing	"self debug: #testComparing"		self shouldnt: [(BlockClosureTest>>#exempleBlock) = (BlockClosureTest>>#exempleBlock)] raise: Error.	self assert: (BlockClosureTest>>#exempleBlock) = (BlockClosureTest>>#exempleBlock).	self assert: ((BlockClosureTest>>#exempleBlock) valueWithReceiver: self arguments: #()) = 20! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 8/8/2007 11:48'!testComparingEqual		self assert: ((BlockClosureTest>>#exempleClosureEqual1) createBlock: self) 		= ((BlockClosureTest>>#exempleClosureEqual2)  createBlock: self).! !!BlockClosureTest methodsFor: 'tests' stamp: 'ms 5/10/2007 11:30'!testHasLiteral	"self debug: #testComparing"	self shouldnt: [closure hasLiteralThorough: #exemple]		raise: Error.	self assert: (closure hasLiteralThorough: #exemple) not! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:15'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34'!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37'!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !!BraceNode methodsFor: '*eToys-tiles' stamp: 'di 11/13/2000 21:17'!asMorphicSyntaxIn: parent	| row |	row := (parent addRow: #brace on: self) layoutInset: 1.	row addMorphBack: (StringMorph new contents: 		(String streamContents: [:aStream | self printOn: aStream indent: 0])).	^row! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!Button methodsFor: 'state'!turnOff	"Sets the state of the receiver to 'off'. The off action of the receiver is not  	executed."	on := false! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/9/2001 09:43'!actWhen: condition	(#(buttonDown mouseDown) includes: condition) ifTrue: [ actWhen := #mouseDown ].	(#(buttonUp mouseUp) includes: condition) ifTrue: [ actWhen := #mouseUp ].	(#(whilePressed mouseStillDown) includes: condition) ifTrue: [ actWhen := #mouseStillDown ].	self setEventHandlers: true.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 08:46'!actionSelector: aSymbolOrString	aSymbolOrString isEmptyOrNil ifTrue: [^actionSelector := nil].	aSymbolOrString = 'nil' ifTrue: [^actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/15/2001 09:35'!addTextToButton: aStringOrText	| tm existing |	existing := self currentTextMorphsInButton.	existing do: [ :x | x delete].	aStringOrText ifNil: [^self].	tm := TextMorph new contents: aStringOrText.	tm 		fullBounds;		lock;		align: tm center with: visibleMorph center;		setProperty: #textAddedByButtonProperties toValue: true;		setToAdhereToEdge: #center.	"maybe the user would like personal control here"	"visibleMorph extent: (tm extent * 1.5) rounded."	visibleMorph addMorphFront: tm.! !!ButtonProperties methodsFor: 'accessing'!arguments: aCollection	arguments := aCollection asArray copy.! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/15/2001 09:18'!currentLook	^currentLook ifNil: [currentLook := #normal]! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/14/2001 18:18'!currentTextInButton	| existing |	existing := self currentTextMorphsInButton.	existing isEmpty ifTrue: [^nil].	^existing first! !!ButtonProperties methodsFor: 'accessing' stamp: 'yo 11/30/2005 14:20'!establishEtoyLabelWording	"Set the label wording, unless it has already been manually edited"	| itsName |	self isTileScriptingElement ifFalse: [^self].	itsName := target externalName.	self addTextToButton: itsName, ' ', arguments first.	visibleMorph setBalloonText: 		('click to run the script "{1}" in player named "{2}"' translated format: {arguments first. itsName}).! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:15'!mouseDownHaloColor: x	mouseDownHaloColor := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:31'!mouseDownHaloWidth: x	mouseDownHaloWidth := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:16'!mouseOverHaloColor: x	mouseOverHaloColor := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 16:31'!mouseOverHaloWidth: x	mouseOverHaloWidth := x! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/14/2001 18:30'!stateCostumes	^stateCostumes ifNil: [stateCostumes := Dictionary new]! !!ButtonProperties methodsFor: 'accessing'!target: anObject	target := anObject! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/8/2001 15:43'!visibleMorph: x	visibleMorph ifNotNil: [self setEventHandlers: false].	visibleMorph := x.	visibleMorph ifNotNil: [self setEventHandlers: true].! !!ButtonProperties methodsFor: 'accessing' stamp: 'RAA 3/10/2001 13:59'!wantsRolloverIndicator: aBoolean	wantsRolloverIndicator := aBoolean.	wantsRolloverIndicator ifTrue: [		self setEventHandlers: true.	].! !!ButtonProperties methodsFor: 'copying' stamp: 'jm 7/28/97 11:52'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!ButtonProperties methodsFor: 'copying' stamp: 'tk 1/6/1999 17:55'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!ButtonProperties methodsFor: 'copying' stamp: 'RAA 3/16/2001 08:21'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		a Symbol""arguments := arguments.		All weakly copied"actWhen := actWhen veryDeepCopyWith: deepCopier."oldColor := oldColor veryDeepCopyWith: deepCopier."visibleMorph := visibleMorph.	"I guess this will have been copied already if needed"delayBetweenFirings := delayBetweenFirings.mouseDownHaloColor := mouseDownHaloColor.stateCostumes := stateCostumes veryDeepCopyWith: deepCopier.currentLook := currentLook.! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/8/2001 09:55'!delayBetweenFirings: millisecondsOrNil	delayBetweenFirings := millisecondsOrNil! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/15/2001 09:21'!displayCostume: aSymbol	self currentLook == aSymbol ifTrue: [^true].	self stateCostumes at: aSymbol ifPresent: [ :aForm |		currentLook := aSymbol.		visibleMorph wearCostume: aForm.		^true	].	^false! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 17:08'!doButtonAction: evt	| arity |	target ifNil: [^self].	actionSelector ifNil: [^self].	arguments ifNil: [arguments := #()].	Cursor normal showWhile: [		arity := actionSelector numArgs.		arity = arguments size ifTrue: [			target perform: actionSelector withArguments: arguments		].		arity = (arguments size + 1) ifTrue: [			target perform: actionSelector withArguments: {evt},arguments		].		arity = (arguments size + 2) ifTrue: [			target perform: actionSelector withArguments: {evt. visibleMorph},arguments		].	]! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/14/2001 19:01'!editButtonsScript: evt	"The user has touched my Scriptor halo-handle.  Bring up a Scriptor on the script of the button."	| cardsPasteUp cardsPlayer anEditor scriptSelector |	cardsPasteUp := self pasteUpMorph.	(cardsPlayer := cardsPasteUp assuredPlayer) assureUniClass.	scriptSelector := self figureOutScriptSelector.	scriptSelector ifNil: [		scriptSelector := cardsPasteUp scriptSelectorToTriggerFor: self.		anEditor := cardsPlayer newTextualScriptorFor: scriptSelector.		evt hand attachMorph: anEditor.		^self	].	(cardsPlayer class selectors includes: scriptSelector) ifTrue: [		anEditor := cardsPlayer scriptEditorFor: scriptSelector.		evt hand attachMorph: anEditor.		^self	].	"Method somehow got removed; I guess we start aftresh"	scriptSelector := nil.	^ self editButtonsScript! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/14/2001 18:40'!mouseDown: evt	self displayCostume: #mouseDown.	mouseDownTime := Time millisecondClockValue.	nextTimeToFire := nil.	delayBetweenFirings ifNotNil: [		nextTimeToFire := mouseDownTime + delayBetweenFirings.	].	self wantsRolloverIndicator ifTrue: [		visibleMorph 			addMouseActionIndicatorsWidth: mouseDownHaloWidth 			color: mouseDownHaloColor.	].	actWhen == #mouseDown ifFalse: [^self].	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	self doButtonAction: evt."=====	aMorph .	now := Time millisecondClockValue.	oldColor := color. 	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [	self updateVisualState: evt; refreshWorld].	dt := Time millisecondClockValue - now max: 0.	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait].	self mouseStillDown: evt.====="! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 08:57'!mouseStillDown: evt	(visibleMorph containsPoint: evt cursorPoint) ifFalse: [^self].	nextTimeToFire ifNil: [^self].	nextTimeToFire <= Time millisecondClockValue ifTrue: [		self doButtonAction: evt.		nextTimeToFire := Time millisecondClockValue + self delayBetweenFirings.		^self	].! !!ButtonProperties methodsFor: 'events' stamp: 'RAA 3/9/2001 12:27'!replaceVisibleMorph: aNewMorph	| old oldOwner oldText |	old := visibleMorph.	oldText := self currentTextInButton.	self visibleMorph: nil.	old buttonProperties: nil.	aNewMorph buttonProperties: self.	self visibleMorph: aNewMorph.	self addTextToButton: oldText.	oldOwner := old owner ifNil: [^self].	oldOwner replaceSubmorph: old by: aNewMorph.! !!ButtonProperties methodsFor: 'initialization' stamp: 'ar 3/17/2001 20:12'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target := target adaptedToWorld: aWorld.! !!ButtonProperties methodsFor: 'initialization' stamp: 'RAA 3/9/2001 09:47'!initialize	wantsRolloverIndicator := false.	delayBetweenFirings := nil.	mouseOverHaloWidth := 10.	mouseOverHaloColor := Color blue alpha: 0.3.	mouseDownHaloWidth := 15.	mouseDownHaloColor := Color blue alpha: 0.7.	arguments := #().! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/16/2005 20:58'!setActWhen	| selections |	selections := #(mouseDown mouseUp mouseStillDown).	actWhen := (SelectionMenu labels: (selections collect: [:t | t translated]) selections: selections)		startUpWithCaption: 'Choose one of the following conditions' translated! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/16/2005 20:53'!setActionSelector	| newSel |	newSel := FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!ButtonProperties methodsFor: 'menu' stamp: 'yo 3/14/2005 13:07'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!ButtonProperties methodsFor: 'menu'!setLabel	| newLabel |	newLabel := FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 17:29'!ellipticalButtonWithText: aStringOrText	| m prop |	m := EllipseMorph new.	prop := m ensuredButtonProperties.	prop		target: #(1 2 3);		actionSelector: #inspect;		actWhen: #mouseUp;		addTextToButton: aStringOrText;		wantsRolloverIndicator: true.	^m! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 08:31'!test1	| m prop |	m := EllipseMorph new.	prop := m ensuredButtonProperties.	prop		target: #(1 2 3);		actionSelector: #inspect;		actWhen: #mouseUp.	m openInWorld.! !!ButtonProperties class methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!test3	| m |	(m := self ellipticalButtonWithText: 'Hello world') openInWorld.	m ensuredButtonProperties		target: Beeper;		actionSelector: #beep;		delayBetweenFirings: 1000.! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index bigEndian: bool 	"Return a 64 bit float starting from the given byte index"	| w1 w2 dbl |	w1 := self unsignedLongAt: index bigEndian: bool.	w2 := self unsignedLongAt: index + 4 bigEndian: bool.	dbl := Float new: 2. 	bool		ifTrue: [dbl basicAt: 1 put: w1.			dbl basicAt: 2 put: w2]		ifFalse: [dbl basicAt: 1 put: w2.			dbl basicAt: 2 put: w1].	^ dbl! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index put: value bigEndian: bool 	"Store a 64 bit float starting from the given byte index"	| w1 w2 |	bool		ifTrue: [w1 := value basicAt: 1.			w2 := value basicAt: 2]		ifFalse: [w1 := value basicAt: 2.			w2 := value basicAt: 1]. 	self unsignedLongAt: index put: w1 bigEndian: bool.	self unsignedLongAt: index + 4 put: w2 bigEndian: bool.	^ value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	h = 0 ifFalse:[w := (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 8/2/2003 19:29'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b0 < 0 ifTrue:[b0 := 256 + b0].	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort := self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w := (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w := (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'zip archive' stamp: 'nk 8/21/2004 15:23'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!ByteArray class methodsFor: 'byte based hash' stamp: 'SqR 8/21/2002 16:21'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteString methodsFor: 'comparing' stamp: 'bf 8/31/2004 13:50'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!ByteString methodsFor: 'converting' stamp: 'yo 11/11/2002 12:20'!convertFromCompoundText	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := CompoundTextConverter new.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!ByteString methodsFor: 'converting' stamp: 'mir 7/20/2004 15:50'!convertFromSystemString	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := LanguageEnvironment defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		writeStream nextPut: (converter nextFromStream: readStream)].	^ writeStream contents! !!ByteString methodsFor: 'converting' stamp: 'ar 7/21/2007 21:51'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := self indexOfAnyOf: CSNonSeparators 							startingAt: end+1 ifAbsent: [ nil ].	beginning ~~ nil ] whileTrue: [		"find the end"		end := self indexOfAnyOf: CSSeparators 					startingAt: beginning ifAbsent: [ self size + 1 ].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!ByteString class methodsFor: 'primitives' stamp: 'yo 12/15/2005 13:44'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	self var: #string1 declareC: 'unsigned char *string1'.	self var: #string2 declareC: 'unsigned char *string2'.	self var: #order declareC: 'unsigned char *order'.	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:12'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'ar 2/3/2001 16:13'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'ar 9/28/2001 04:35'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	self var: #aHash declareC: 'int speciesHash'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/29/2001 22:44'!matchIndex	| tms |	"Index of one we are looking at, in the cards that matched the last search with this template."	tms := self class classPool at: #TemplateMatches ifAbsent: [^ 0].	^ (tms at: self ifAbsent: [#(0 0)]) second.! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/29/2001 22:47'!matchIndex: newPlace	| tms pair |	"One we are looking at, in cards that matched the last template search."	tms := self class classPool at: #TemplateMatches ifAbsent: [		self class addClassVarName: 'TemplateMatches'.		self class classPool at: #TemplateMatches put: IdentityDictionary new].	pair := tms at: self ifAbsent: [tms at: self put: (Array new: 2)].	pair at: 2 put: newPlace.	newPlace = 0 ifTrue: [^ self].	pair first ifNil: [^ self].	(costume valueOfProperty: #myStack ifAbsent: [^ self]) goToCard: 		((pair first "list") at: newPlace).	self changed: #matchIndex.	"update my selection"! !!CardPlayer methodsFor: 'as template' stamp: 'tk 5/31/2001 16:46'!matchNames	| list str ll tms stk crds |	"List of names of cards that matched the last template search."	tms := self class classPool at: #TemplateMatches ifAbsent: [^ #()].	list := (tms at: self ifAbsent: [#(#() 0)]) first.	stk := costume valueOfProperty: #myStack ifAbsent: [nil].	crds := stk ifNil: [#()] ifNotNil: [stk cards].	^ list collect: [:cd | 		str := ''.		(ll := cd allStringsAfter: nil) ifNotNil: [			str := ll inject: '' into: [:strr :this | strr, this]]. 		(str copyFrom: 1 to: (30 min: str size)), '...  (' , (crds indexOf: cd) printString, ')'].		"Maybe include a card title?"! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:42'!asKeys	| keys kk vd gotData |	"Take my fields, tokenize the text, and return as an array in the same order as variableDocks.  Simple background fields on the top level.  If no data, return nil."	keys := self class variableDocks copy.	gotData := false.	1 to: keys size do: [:ind |		kk := nil.		vd := self class variableDocks at: ind.		vd type == #text ifTrue: [			kk := (self perform: vd playerGetSelector) string					findTokens: Character separators.			kk isEmpty ifTrue: [kk := nil] ifFalse: [gotData := true]].		keys at: ind put: kk].	^ gotData ifTrue: [keys] ifFalse: [nil]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 10/13/2000 16:46'!commitCardPlayerData	"Transport data back from the morphs that may be holding it into the instance variables that must hold it when the receiver is not being viewed"	| prior |	self class variableDocks do:		[:aDock | aDock storeMorphDataInInstance: self].	prior := nil.	privateMorphs := OrderedCollection new.	self costume ifNotNil:		[self costume submorphs do:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[aMorph setProperty: #priorMorph toValue: prior.					privateMorphs add: aMorph.					aMorph delete].			prior := aMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'sw 11/14/2000 11:21'!commitCardPlayerDataFrom: aPlayfield	"Transport data back from the morphs that may be holding it into the instance variables that must hold it when the receiver is not being viewed"	| prior itsOrigin |	itsOrigin := aPlayfield topLeft.	self class variableDocks do:		[:aDock | aDock storeMorphDataInInstance: self].	prior := nil.	privateMorphs := OrderedCollection new.	self costume ifNotNil:		[self costume submorphs do:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[aMorph setProperty: #priorMorph toValue: prior.					privateMorphs add: aMorph.					aMorph delete.					aMorph position: (aMorph position - itsOrigin)].			prior := aMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'tk 1/16/2001 16:12'!installPrivateMorphsInto: aBackground	"The receiver is being installed as the current card in a given pasteup morph being used as a background.  Install the receiver's private morphs into that playfield"	| prior originToUse |	self flag: #deferred.  "not robust if the background is showing a list view"	privateMorphs ifNotNil: [privateMorphs do:		[:aMorph |			originToUse := aBackground topLeft.			prior := aMorph valueOfProperty: #priorMorph ifAbsent: [nil].			aMorph position: (aMorph position + originToUse).			(prior notNil and: [aBackground submorphs includes: prior])				ifTrue:					[aBackground addMorph: aMorph after: prior]				ifFalse:					[aBackground addMorphFront: aMorph].		aMorph removeProperty: #priorMorph]]! !!CardPlayer methodsFor: 'card data' stamp: 'tk 5/25/2001 17:02'!match: keys fields: docks	| longString |	"see if each key occurs in my corresponding text instance."	keys withIndexDo: [:kk :ind |		kk ifNotNil: [			longString := (self perform: (docks at: ind) playerGetSelector) string.			kk do: [:aKey |				((longString findString: aKey startingAt: 1 caseSensitive: false) > 0)					ifFalse: [^ false]]]]. 	"all keys must match"	^ true! !!CardPlayer methodsFor: 'scripts-kernel' stamp: 'svp 10/15/2001 14:44'!renameScript: oldSelector newSelector: newSelector	"Find all buttons that fire this script and tell them the new name"	| stack |	super renameScript: oldSelector newSelector: newSelector.	costume allMorphsDo: [:mm |		self retargetButton: mm oldSelector: oldSelector newSelector: newSelector].	stack := costume valueOfProperty: #myStack.	stack ifNotNil:		[stack cards do: [:cc |			cc privateMorphs do: [:pp | 				pp allMorphsDo: [:mm |					self retargetButton: mm oldSelector: oldSelector newSelector: newSelector]]]]! !!CardPlayer class methodsFor: 'slots' stamp: 'md 7/23/2006 15:13'!compileAccessorsFor: varName	"Compile instance-variable accessor methods for the given variable name"	| nameString |	nameString := varName asString capitalized.	self compileSilently: ('get', nameString, '	^ ', varName)		classified: 'access'.	self compileSilently: ('set', nameString, ': val	', varName, ' := val')		classified: 'access'! !!CardPlayer class methodsFor: 'slots' stamp: 'NS 1/30/2004 13:11'!removeAccessorsFor: varName	"Remove the instance-variable accessor methods associated with varName"	| nameString |	nameString := varName asString capitalized.	self removeSelectorSilently: ('get', nameString) asSymbol.	self removeSelectorSilently: ('set', nameString, ':') asSymbol! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'sw 12/6/2001 20:36'!resortInstanceVariables: newList	"Accept a new ordering for instance variables"	variableDocks := newList collect: [:aName | variableDocks detect: [:d | d variableName = aName]].	self setNewInstVarNames: newList asOrderedCollection.	self newVariableDocks: variableDocks.! !!CardPlayer class methodsFor: 'user-defined inst vars' stamp: 'tk 8/26/2001 16:58'!setNewInstVarNames: listOfStrings	"Make listOfStrings be the new list of instance variable names for the receiver"	| disappearing firstAppearing instVarString instVarList |	instVarList := self instVarNames asOrderedCollection.	disappearing := instVarList copy.	disappearing removeAllFoundIn: listOfStrings.	disappearing do:		[:oldName | 	self removeAccessorsFor: oldName].	firstAppearing := listOfStrings copy.	firstAppearing removeAllFoundIn: instVarList.	instVarString := String streamContents:		[:aStream | listOfStrings do: [:aString | aStream nextPutAll: aString; nextPut: $ ]].	superclass subclass: self name instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	firstAppearing do:		[:newName | self compileAccessorsFor: newName].! !!CardPlayer class methodsFor: 'variable docks' stamp: 'md 3/1/2006 09:17'!setSlotInfoFromVariableDocks	"Get the slotInfo fixed up after a change in background shape.  Those instance variables that are proactively added by the user will persist, whereas those that are automatically generated will be updated"	| aDock newInfo |		self slotInfo copy do:  "Remove old automatically-created slots"		[:aSlotInfo | (aDock := aSlotInfo variableDock) ifNotNil:			[slotInfo removeKey: aDock variableName]].	self variableDocks do:  [:dock | "Generate fresh slots from variable docks"			newInfo := SlotInformation new type: dock variableType.			newInfo variableDock: dock.			slotInfo at: dock variableName asSymbol put: newInfo]! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks	"Answer the list of variable docks in the receiver.  Initialize the variable-dock list if not already done."	variableDocks ifNil: [variableDocks := OrderedCollection new].	^ variableDocks! !!CardPlayer class methodsFor: 'variable docks' stamp: 'sw 10/13/2000 16:39'!variableDocks: dockList	"Set the variable-dock list as indicated"	variableDocks := dockList! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:10'!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:18'!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:17'!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:54'!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:22'!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 15:15'!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:55'!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:59'!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 12:57'!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/11/2007 14:49'!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'as yet unclassified' stamp: 'mtf 9/10/2007 10:14'!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:55'!categoryNameWhoseTranslatedWordingIs: aWording	"Answer the category name with the given wording"	| result |	result := self currentVocabulary categoryWhoseTranslatedWordingIs: aWording.	^ result		ifNotNil:			[result categoryName]		ifNil:			[aWording]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 10/30/2001 13:45'!categoryWording: aCategoryWording	"Make the category with the given wording be my current one."	| actualPane |	(actualPane := namePane renderedMorph) firstSubmorph contents: aCategoryWording; color: Color black.	actualPane extent: actualPane firstSubmorph extent.	self removeAllButFirstSubmorph. "that being the header"	self addAllMorphs:		((scriptedPlayer tilePhrasesForCategory: chosenCategorySymbol inViewer: self)).	self enforceTileColorPolicy.	self secreteCategorySymbol.	self world ifNotNil: [self world startSteppingSubmorphsOf: self].	self adjustColorsAndBordersWithin.	owner ifNotNil: [owner isStandardViewer ifTrue: [owner fitFlap]]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 3/2/2004 23:53'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList aMenu reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList collect:			[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aList size == 0 ifTrue: [aList add: ScriptingSystem nameForInstanceVariablesCategory translated].	aMenu := CustomMenu labels: aList lines: lineList selections: aList.	reply := aMenu startUpWithCaption: 'category' translated.	reply ifNil: [^ self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:49'!chosenCategorySymbol: aCategorySymbol	"Make the given category be my current one."	| aCategory wording |	chosenCategorySymbol := aCategorySymbol.	aCategory := self currentVocabulary categoryAt: chosenCategorySymbol.	wording := aCategory ifNil: [aCategorySymbol] ifNotNil: [aCategory wording].	self categoryWording: wording! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 2/23/2001 22:29'!currentCategory	"Answer the symbol representing the receiver's currently-selected category"	| current |	current := namePane renderedMorph firstSubmorph contents.	^ current ifNotNil: [current asSymbol] ifNil: [#basic]! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:57'!nextCategory	"Change the receiver to point at the category following the one currently seen"	| aList anIndex newIndex already aChoice |	aList := (scriptedPlayer categoriesForViewer: self) collect:		[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	already := self outerViewer ifNil: [#()] ifNotNil: [self outerViewer categoriesCurrentlyShowing].	anIndex := aList indexOf: self currentCategory ifAbsent: [0].	newIndex := anIndex = aList size		ifTrue:		[1]		ifFalse:		[anIndex + 1].	[already includes: (aChoice := aList at: newIndex)] whileTrue:		[newIndex := (newIndex \\ aList size) + 1].	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:53'!previousCategory	"Change the receiver to point at the category preceding the one currently seen"	| aList anIndex newIndex already aChoice |	aList := (scriptedPlayer categoriesForViewer: self) collect:		[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	already := self outerViewer ifNil: [#()] ifNotNil: [self outerViewer categoriesCurrentlyShowing].	anIndex := aList indexOf: self currentCategory ifAbsent: [aList size + 1].	newIndex := anIndex = 1		ifTrue:		[aList size]		ifFalse:		[anIndex - 1].	[already includes: (aChoice := aList at: newIndex)] whileTrue:		[newIndex := newIndex = 1 ifTrue: [aList size] ifFalse: [newIndex - 1]].	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 9/13/2001 19:50'!secreteCategorySymbol	"Set my chosenCategorySymbol by translating back from its representation in the namePane.  Answer the chosenCategorySymbol"	| aCategory |	aCategory := self currentVocabulary categoryWhoseTranslatedWordingIs: self currentCategory.	^ chosenCategorySymbol := aCategory		ifNotNil:			[aCategory categoryName]		ifNil:			[self currentCategory]! !!CategoryViewer methodsFor: 'categories' stamp: 'nk 9/2/2004 19:37'!showCategoriesFor: aSymbol	"Put up a pop-up list of categories in which aSymbol is filed; replace the receiver with a CategoryViewer for the one the user selects, if any"	| allCategories aVocabulary hits meths chosen |	aVocabulary := self currentVocabulary.	allCategories := scriptedPlayer categoriesForVocabulary: aVocabulary limitClass: ProtoObject.	hits := allCategories select:		[:aCategory | 			meths := aVocabulary allMethodsInCategory: aCategory forInstance: scriptedPlayer ofClass: scriptedPlayer class.			meths includes: aSymbol].	hits isEmpty ifTrue: [ ^self ].	chosen := (SelectionMenu selections: hits) startUp.	chosen isEmptyOrNil ifFalse:		[self outerViewer addCategoryViewerFor: chosen atEnd: true]	! !!CategoryViewer methodsFor: 'categories' stamp: 'sw 5/29/2001 11:41'!updateCategoryNameTo: aName	"Update the category name, because of a language change."	| actualPane |	(actualPane := namePane firstSubmorph) contents: aName; color: Color black.	namePane extent: actualPane extent.	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/25/2004 15:37'!addIsOverColorDetailTo: aRow	"Special-casee code for the boolean-valued phrase variously known as is-over-color or sees-color."	| clrTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  "spacer"	aRow addMorphBack: (clrTile := Color blue newTileMorphRepresentative)."The following commented-out code put a readout up; the readout was very nice, but was very consumptive of cpu time, which is why the is-over-color tile got removed from the viewer long ago.  Now is-over-color is reinstated to the viewer, minus the expensive readout...""	aRow addMorphBack: (AlignmentMorph new beTransparent).	readout := UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile := StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30"! !!CategoryViewer methodsFor: 'entries' stamp: 'md 11/14/2003 16:21'!addTouchesADetailTo: aRow	| clrTile |	aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	aRow addMorphBack: (clrTile := self tileForSelf).	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	"readout := UpdatingStringMorphWithArgument new			target: scriptedPlayer; getSelector: #seesColor:; growable: false; putSelector: nil;			argumentTarget: clrTile colorSwatch argumentGetSelector: #color.	readout useDefaultFormat.	aTile := StringReadoutTile new typeColor: Color lightGray lighter.	aTile addMorphBack: readout.	aRow addMorphBack: aTile.	aTile setLiteralTo: (scriptedPlayer seesColor: clrTile colorSwatch color) printString width: 30"! !!CategoryViewer methodsFor: 'entries' stamp: 'md 11/14/2003 16:20'!infoButtonFor: aScriptOrSlotSymbol	"Answer a fully-formed morph that will serve as the 'info button' alongside an entry corresponding to the given slot or script symbol.  If no such button is appropriate, answer a transparent graphic that fills the same space."	| aButton |	(self wantsRowMenuFor: aScriptOrSlotSymbol) ifFalse:		["Fill the space with sweet nothing, since there is no meaningful menu to offer"		aButton := RectangleMorph new beTransparent extent: (17@20).		aButton borderWidth: 0.		^ aButton].	aButton := IconicButton new labelGraphic: Cursor menu.	aButton target: scriptedPlayer;		actionSelector: #infoFor:inViewer:;		arguments: (Array with:aScriptOrSlotSymbol with: self);		color: Color transparent;		borderWidth: 0;		shedSelvedge;		actWhen: #buttonDown.	aButton setBalloonText: 'Press here to get a menu' translated.	^ aButton! !!CategoryViewer methodsFor: 'entries' stamp: 'yo 8/18/2005 10:37'!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString := aMethodInterface documentation.	aDocString = 'no help available' ifTrue: [aDocString := nil].	names := scriptedPlayer class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase := scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				(self isSpecialPatchReceiver: scriptedPlayer and: cmd) ifTrue: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Patch						argType: argType.				] ifFalse: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Player						argType: argType.				].				(self isSpecialPatchCase: scriptedPlayer and: cmd) ifTrue: [					argTile := (Vocabulary vocabularyForType: argType) defaultArgumentTileFor: scriptedPlayer.				] ifFalse: [					argTile := ScriptingSystem tileForArgType: argType.				].				(#(bounce: wrap:) includes: cmd) ifTrue:					["help for the embattled bj"					argTile setLiteral: 'silence'; updateLiteralLabel].				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString := (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentation].			aDocString ifNil:				[balloonTextSelector := #userScript]].	tileBearingHelp := universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector := #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script' translated].	universal ifFalse:		[selfTile := self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow := ViewerLine newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 2@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aPhrase on: #mouseEnter send: #addCommandFeedback to: aRow.	aPhrase on: #mouseLeave send: #removeHighlightFeedback to: aRow.	aPhrase on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		cmd numArgs == 0 ifTrue:			[aPhrase beTransparent.			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.			aRow addMorphBack: (stat := (inst := scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).			inst updateStatusMorph: stat]].	aRow beSticky; disableDragNDrop.	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'yo 3/7/2005 08:45'!phraseForVariableFrom: aMethodInterface	"Return a structure consisting of tiles and controls and a readout representing a 'variable' belonging to the player, complete with an appropriate readout when indicated.  Functions in both universalTiles mode and classic mode.  Slightly misnamed in that this path is used for any methodInterface that indicates an interesting resultType."	| anArrow slotName getterButton cover inner aRow doc setter tryer universal hotTileForSelf spacer buttonFont varName |	aRow := ViewerLine newRow		color: self color;		beSticky;		elementSymbol: (slotName := aMethodInterface selector);		wrapCentering: #center;		cellPositioning: #leftCenter.	(universal := scriptedPlayer isUniversalTiles) ifFalse:		[buttonFont := Preferences standardEToysFont.			aRow addMorphBack: (Morph new color: self color;					 extent: (((buttonFont widthOfString: '!!') + 8) @ (buttonFont height + 6));					 yourself)].  "spacer"	aRow addMorphBack: (self infoButtonFor: slotName).	aRow addMorphBack: (Morph new color: self color; extent: 0@10).  " vertical spacer"	universal		ifTrue:			[inner := scriptedPlayer universalTilesForGetterOf: aMethodInterface.			cover := Morph new color: Color transparent.			cover extent: inner fullBounds extent.			(getterButton := cover copy) addMorph: cover; addMorphBack: inner.			cover on: #mouseDown send: #makeUniversalTilesGetter:event:from: 					to: self withValue: aMethodInterface.			aRow addMorphFront:  (tryer := ScriptingSystem tryButtonFor: inner).			tryer color: tryer color lighter lighter]		ifFalse:			[hotTileForSelf := self tileForSelf bePossessive.			hotTileForSelf  on: #mouseDown send: #makeGetter:event:from:				to: self				withValue: (Array with: aMethodInterface selector with: aMethodInterface resultType).			aRow addMorphBack: hotTileForSelf.			aRow addMorphBack: (spacer := Morph new color: self color; extent: 2@10).			spacer on: #mouseEnter send: #addGetterFeedback to: aRow.			spacer on: #mouseLeave send: #removeHighlightFeedback to: aRow.			spacer on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.			spacer  on: #mouseDown send: #makeGetter:event:from:				to: self				withValue: (Array with: aMethodInterface selector with: aMethodInterface resultType).			hotTileForSelf on: #mouseEnter send: #addGetterFeedback to: aRow.			hotTileForSelf on: #mouseLeave send: #removeHighlightFeedback to: aRow.			hotTileForSelf on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.			getterButton := self getterButtonFor: aMethodInterface selector type: aMethodInterface resultType].	aRow addMorphBack: getterButton.	getterButton on: #mouseEnter send: #addGetterFeedback to: aRow.	getterButton on: #mouseLeave send: #removeHighlightFeedback to: aRow.	getterButton on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(doc := aMethodInterface documentation) ifNotNil:		[getterButton setBalloonText: doc].	(scriptedPlayer slotInfo includesKey: (varName := Utilities inherentSelectorForGetter: slotName)) "user slot"		ifTrue:			["aRow addTransparentSpacerOfSize: 3@0.			aRow addMorphBack: (self slotTypeMenuButtonFor: varName)"].	universal ifFalse:		[(slotName == #seesColor:) ifTrue:			[self addIsOverColorDetailTo: aRow.			^ aRow].		(slotName == #touchesA:) ifTrue:			[self addTouchesADetailTo: aRow.			^ aRow].		(slotName == #overlaps: or: [ slotName == #overlapsAny:]) ifTrue:			[self addOverlapsDetailTo: aRow.			^ aRow]].	aRow addMorphBack: (AlignmentMorph new beTransparent).  "flexible spacer"	(setter := aMethodInterface companionSetterSelector) ifNotNil:		[aRow addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		anArrow := universal 			ifTrue: [self arrowSetterButton: #newMakeSetterFromInterface:evt:from:  						args: aMethodInterface]			ifFalse: [self arrowSetterButton: #makeSetter:from:forPart:						args: (Array with: slotName with: aMethodInterface resultType)].		anArrow beTransparent.		universal ifFalse:			[anArrow on: #mouseEnter send: #addSetterFeedback to: aRow.			anArrow on: #mouseLeave send: #removeHighlightFeedback to: aRow.			anArrow on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow].		aRow addMorphBack: anArrow].	(#(color:sees: playerSeeingColor copy touchesA: overlaps: getTurtleAt: getTurtleOf:) includes: slotName) ifFalse: 		[(universal and: [slotName == #seesColor:]) ifFalse:			[aMethodInterface wantsReadoutInViewer ifTrue: 				[aRow addMorphBack: (self readoutFor: slotName type: aMethodInterface resultType readOnly: setter isNil getSelector: aMethodInterface selector putSelector: setter)]]].	anArrow ifNotNil: [anArrow step].	^ aRow! !!CategoryViewer methodsFor: 'entries' stamp: 'sw 7/4/2004 01:09'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Answer a readout morph for the given part"	| readout delta |	readout := (Vocabulary vocabularyForType: partType) updatingTileForTarget: scriptedPlayer partName: partName getter: getSelector setter: putSelector.	(partType == #Number) ifTrue:		[(delta := scriptedPlayer arrowDeltaFor: getSelector) = 1			ifFalse:				[readout setProperty: #arrowDelta toValue: delta].		scriptedPlayer setFloatPrecisionFor: readout updatingStringMorph].	readout step.	^ readout! !!CategoryViewer methodsFor: 'entries' stamp: 'nk 10/14/2004 10:54'!wantsRowMenuFor: aSymbol	"Answer whether a viewer row for the given symbol should have a menu button on it"	| elementType |	true ifTrue: [^ true].  "To allow show categories item.  So someday this method can be removed, and its sender can stop sending it..."	elementType := scriptedPlayer elementTypeFor: aSymbol vocabulary: self currentVocabulary.	(elementType == #systemScript) ifTrue: [^ false].	((elementType == #systemSlot) and:		[#(color:sees: touchesA: overlaps: overlapsAny:) includes: aSymbol]) ifTrue: [^ false].	^ true! !!CategoryViewer methodsFor: 'e-toy support' stamp: 'sw 9/13/2001 19:16'!adoptVocabulary: aVocabulary	"Adopt the given vocabulary as the one used in this viewer."	| aCategory |	chosenCategorySymbol ifNil: [^ self delete].	aCategory := aVocabulary categoryAt: chosenCategorySymbol.	aCategory ifNil: [self delete] ifNotNil: [self updateCategoryNameTo: aCategory wording].	super adoptVocabulary: aVocabulary! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'dgd 9/1/2003 13:51'!arrowSetterButton: sel args: argArray	| m |	m := RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m setBalloonText: 'drag from here to obtain an assignment phrase.' translated.	m on: #mouseDown send: sel		to: self		withValue: argArray.	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'dgd 9/1/2003 13:51'!arrowSetterButtonFor: partName type: partType	| m |	m := RectangleMorph new		color: (ScriptingSystem colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 0.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m setBalloonText: 'drag from here to obtain an assignment phrase.' translated.	m on: #mouseDown send: #makeSetter:event:from:		to: self		withValue: (Array with: partName with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 9/27/2001 04:23'!getterButtonFor: getterSelector type: partType	"Answer a classic-tiles getter button for a part of the given name"	| m inherent wording |	m := TileMorph new adoptVocabulary: self currentVocabulary.	inherent := Utilities inherentSelectorForGetter: getterSelector.	wording := (scriptedPlayer slotInfo includesKey: inherent)		ifTrue: [inherent]		ifFalse: [self currentVocabulary tileWordingForSelector: getterSelector].	m setOperator: getterSelector andUseWording: wording.	m typeColor: (ScriptingSystem colorForType: partType).	m on: #mouseDown send: #makeGetter:event:from:		to: self		withValue: (Array with: getterSelector with: partType).	^ m! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'yo 3/24/2005 13:12'!getterTilesFor: getterSelector type: aType 	"Answer classic getter for the given name/type"	"aPhrase := nil, assumed"	| selfTile selector aPhrase |	(#(#color:sees: #colorSees) includes: getterSelector) 		ifTrue: [aPhrase := self colorSeesPhrase].	(#(#getPatchValueIn:) includes: getterSelector)		ifTrue: [aPhrase := self patchValuePhrase].	(#(#getRedComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #red].	(#(#getGreenComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #green].	(#(#getBlueComponentIn:) includes: getterSelector)		ifTrue: [aPhrase := self colorComponentPhraseFor: #blue].	(#(#getUphillIn:) includes: getterSelector)		ifTrue: [aPhrase := self patchUphillPhrase].	(#(#bounceOn:) includes: getterSelector)		ifTrue: [aPhrase := self bounceOnPhrase].	(#(#bounceOn:color: #bounceOnColor:) includes: getterSelector)		ifTrue: [aPhrase := self bounceOnColorPhrase].	(getterSelector = #getDistanceTo:)		ifTrue: [aPhrase := self distanceToPhrase].	(getterSelector = #getAngleTo:)		ifTrue: [aPhrase := self angleToPhrase].	(getterSelector = #getTurtleOf:)		ifTrue: [aPhrase := self turtleOfPhrase].	(#(#seesColor: #isOverColor) includes: getterSelector) 		ifTrue: [aPhrase := self seesColorPhrase].	(#(#overlaps: #overlaps) includes: getterSelector) 		ifTrue: [aPhrase := self overlapsPhrase].	(#(#overlapsAny: #overlapsAny) includes: getterSelector) 		ifTrue: [aPhrase := self overlapsAnyPhrase].	(#(#touchesA: #touchesA) includes: getterSelector) 		ifTrue: [aPhrase := self touchesAPhrase].	aPhrase ifNil: 			[aPhrase := PhraseTileMorph new setSlotRefOperator: getterSelector asSymbol						type: aType].	selfTile := self tileForSelf bePossessive.	selfTile position: aPhrase firstSubmorph position.	aPhrase firstSubmorph addMorph: selfTile.	selector := aPhrase submorphs second.	(#(#getPatchValueIn: getUphillIn:) includes: getterSelector) ifFalse: [		(Vocabulary vocabularyNamed: aType capitalized) 			ifNotNilDo: [:aVocab | aVocab wantsSuffixArrow ifTrue: [selector addSuffixArrow]].	].	selector updateLiteralLabel.	aPhrase enforceTileColorPolicy.	^aPhrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 4/6/2001 00:59'!makeGetter: args event: evt from: aMorph	"Hand the user tiles representing a classic getter on the slot represented by aMorph"	| tiles |	tiles := self getterTilesFor: args first type: args second.	owner		ifNotNil:	[self primaryHand attachMorph: tiles]		ifNil: 		[^ tiles]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'yo 8/10/2005 17:29'!makeSetterForColorComponent: selectorAndTypePair componentName: componentName event: evt from: aMorph 	| argType m argTile selfTile argValue actualGetter |	argType := selectorAndTypePair second.	componentName = #red ifTrue: [actualGetter := #setRedComponentIn:].	componentName = #green ifTrue: [actualGetter := #setGreenComponentIn:].	componentName = #blue ifTrue: [actualGetter := #setBlueComponentIn:].	m := PhraseTileMorph new 				setColorComponentRoot: actualGetter				componentName: componentName				type: #command				rcvrType: #Patch				argType: argType				vocabulary: self currentVocabulary.	argValue := self scriptedPlayer 				perform: selectorAndTypePair first asSymbol with: nil.	(argValue isKindOf: Player) 		ifTrue: [argTile := argValue tileReferringToSelf]		ifFalse: 			[argTile := ScriptingSystem tileForArgType: argType.			(argType == #Number and: [argValue isNumber]) 				ifTrue: 					[(scriptedPlayer decimalPlacesForGetter: actualGetter) 						ifNotNilDo: [:places | (argTile findA: UpdatingStringMorph) decimalPlaces: places]].			argTile				setLiteral: argValue;				updateLiteralLabel].	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile := self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	m enforceTileColorPolicy.	m submorphs second setPatchDefaultTo: scriptedPlayer defaultPatchPlayer.	m openInHand! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'RAA 4/6/2001 13:28'!makeUniversalTilesGetter: aMethodInterface event: evt from: aMorph	"Button in viewer performs this to make a universal-tiles getter and attach it to hand."	| newTiles |	newTiles := self newGetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	newTiles setProperty: #beScript toValue: true.	owner		ifNotNil:			[ActiveHand attachMorph: newTiles.			newTiles align: newTiles topLeft with: evt hand position + (7@14)]		ifNil:			[^ newTiles]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'nk 10/14/2004 10:53'!newGetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a getter on this property.  Record who self is."	| ms argTile argArray |	ms := MessageSend receiver: aPlayer selector: aMethodInterface selector arguments: #().	"Handle three idiosyncratic cases..."	aMethodInterface selector == #color:sees: ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		argArray := Array with: argTile colorSwatch color with: argTile colorSwatch color copy. 		ms arguments: argArray].	aMethodInterface selector == #seesColor: ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		ms arguments: (Array with: argTile colorSwatch color)].	(#(touchesA: overlaps: overlapsAny:) includes: aMethodInterface selector) ifTrue:		[argTile := ScriptingSystem tileForArgType: #Player.		ms arguments: (Array with: argTile actualObject)].	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'ar 3/17/2001 14:17'!newMakeSetter: aSpec event: evt from: aMorph	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m := self newTilesFor: scriptedPlayer setter: aSpec.	owner ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m].! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'RAA 4/6/2001 13:28'!newMakeSetterFromInterface: aMethodInterface evt: evt from: aMorph 	"Button in viewer performs this to make a new style tile and attach to hand."	| m |	m := self newSetterTilesFor: scriptedPlayer methodInterface: aMethodInterface.	m setProperty: #beScript toValue: true.	owner		ifNotNil: [self primaryHand attachMorph: m.			m align: m topLeft with: evt hand position + (7@14)]		ifNil: [^ m]! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'tk 9/30/2001 11:20'!newSetterTilesFor: aPlayer methodInterface: aMethodInterface	"Return universal tiles for a setter on this property.  Record who self is."	| ms argValue makeSelfGlobal phrase |	argValue := aPlayer perform: aMethodInterface selector.	ms := MessageSend receiver: aPlayer 		selector: aMethodInterface companionSetterSelector 		arguments: (Array with: argValue).	makeSelfGlobal := aPlayer class officialClass ~~ CardPlayer.	phrase := ms asTilesIn: aPlayer class globalNames: makeSelfGlobal.			"For CardPlayers, use 'self'.  For others, name it, and use its name."	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: aPlayer].	^ phrase! !!CategoryViewer methodsFor: 'get/set slots' stamp: 'sw 11/16/2001 14:44'!newTilesFor: aPlayer setter: aSpec	| ms  argValue |	"Return universal tiles for a getter on this property.  Record who self is."	argValue := aPlayer perform: (Utilities getterSelectorFor: aSpec second asSymbol).	ms := MessageSend receiver: aPlayer selector: aSpec ninth arguments: (Array with: argValue).	^ ms asTilesIn: aPlayer class globalNames: (aPlayer class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!CategoryViewer methodsFor: 'header pane' stamp: 'sw 8/31/2004 14:01'!addHeaderMorph	"Add the header at the top of the viewer, with a control for choosing the category, etc."	| header aButton |	header := AlignmentMorph newRow color: self color; wrapCentering: #center; cellPositioning: #leftCenter.	aButton := self tanOButton.	header addMorph: aButton.	aButton actionSelector: #delete;		setBalloonText: 'remove this pane from the screendon''t worry -- nothing will be lost!!.' translated.	self maybeAddArrowsTo: header.	header beSticky.	self addMorph: header.	self addNamePaneTo: header.	chosenCategorySymbol := #basic! !!CategoryViewer methodsFor: 'header pane' stamp: 'dgd 9/1/2003 13:47'!maybeAddArrowsTo: header	"Maybe add up/down arrows to the header"	| wrpr |	header addTransparentSpacerOfSize: 5@5.	header addUpDownArrowsFor: self.	(wrpr := header submorphs last) submorphs second setBalloonText: 'previous category' translated.		wrpr submorphs first  setBalloonText: 'next category' translated! !!CategoryViewer methodsFor: 'initialization' stamp: 'dgd 8/16/2004 21:51'!initializeFor: aPlayer categoryChoice: aChoice	"Initialize the receiver to be associated with the player and category specified"	self listDirection: #topToBottom;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 1;		beSticky.	self color: Color green muchLighter muchLighter.	scriptedPlayer := aPlayer.	self addHeaderMorph.	self chooseCategoryWhoseTranslatedWordingIs: aChoice! !!CategoryViewer methodsFor: 'macpal' stamp: 'sw 5/4/2001 05:24'!currentVocabulary	"Answer the vocabulary currently installed in the viewer.  The outer StandardViewer object holds this information."	| outerViewer |	^  (outerViewer := self outerViewer)		ifNotNil:			[outerViewer currentVocabulary]		ifNil:			[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!CategoryViewer methodsFor: 'support' stamp: 'yo 9/28/2004 18:24'!booleanPhraseForBounceOnColorOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setBounceOnColorOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 9/27/2004 15:00'!booleanPhraseForBounceOnOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setBounceOnOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/17/2004 10:02'!booleanPhraseForGetAngleToOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setAngleToOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 10/13/2004 01:39'!booleanPhraseForGetColorComponentOfType: retrieverType componentName: componentName retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setGetColorComponentOperator: retrieverOp componentName: componentName type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 18:45'!booleanPhraseForGetDistanceToOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setDistanceToOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 16:38'!booleanPhraseForGetPatchValueOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setGetPixelOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 10/9/2004 10:39'!booleanPhraseForGetTurtleAtOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setTurtleAtOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 3/7/2005 08:41'!booleanPhraseForGetTurtleOfOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setTurtleOfOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	"getterPhrase submorphs second setTurtleDefaultTo: scriptedPlayer."	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 6/15/2004 16:39'!booleanPhraseForGetUpHillOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setUpHillOperator: retrieverOp type: retrieverType rcvrType: #Player argType: nil.	getterPhrase submorphs third delete.	getterPhrase submorphs second setSlotRefOperator: retrieverOp.	getterPhrase submorphs second setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	"self halt."	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'sw 9/27/2001 13:28'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel := (Vocabulary vocabularyForType:  retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase :=  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #Player.	getterPhrase submorphs last setSlotRefOperator: retrieverOp.	getterPhrase submorphs first changeTableLayout.	receiverTile := aPlayer tileToRefer bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile := ScriptingSystem tileForArgType: retrieverType.	"comes with arrows"	outerPhrase submorphs last addMorph: finalTile.	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!CategoryViewer methodsFor: 'support' stamp: 'yo 3/24/2005 11:18'!booleanPhraseFromPhrase: phrase	"Answer, if possible, a boolean-valued phrase derived from the phrase provided"	|  retrieverOp retrieverTile |	(phrase isKindOf: ParameterTile) ifTrue: [^ phrase booleanComparatorPhrase].	phrase isBoolean ifTrue: [^ phrase].	((scriptedPlayer respondsTo: #costume) 		and:[scriptedPlayer costume isInWorld not]) ifTrue: [^ Array new].	((retrieverTile := phrase submorphs last) isKindOf: TileMorph) ifFalse: [^ phrase].	retrieverOp := retrieverTile operatorOrExpression.	(Vocabulary vocabularyForType: phrase resultType)		affordsCoercionToBoolean ifTrue: [			retrieverOp =  #getPatchValueIn: ifTrue: [				^ self booleanPhraseForGetPatchValueOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getRedComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #red  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getGreenComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #green  retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp =  #getBlueComponentIn: ifTrue: [				^ self booleanPhraseForGetColorComponentOfType: phrase resultType componentName: #blue retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getUphillIn: ifTrue: [				^ self booleanPhraseForGetUpHillOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getDistanceTo: ifTrue: [				^ self booleanPhraseForGetDistanceToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getAngleTo: ifTrue: [				^ self booleanPhraseForGetAngleToOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #bounceOn: ifTrue: [				^ self booleanPhraseForBounceOnOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			(retrieverOp = #bounceOn:color: or: [retrieverOp = #bounceOnColor:]) ifTrue: [				^ self booleanPhraseForBounceOnColorOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getTurtleAt: ifTrue: [				^ self booleanPhraseForGetTurtleAtOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			retrieverOp = #getTurtleOf: ifTrue: [				^ self booleanPhraseForGetTurtleOfOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.			].			^ self booleanPhraseForRetrieverOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject.		].	^ phrase! !!CategoryViewer methodsFor: 'support' stamp: 'sw 3/1/1999 11:57'!invisiblySetPlayer: aPlayer	scriptedPlayer := aPlayer! !!CategoryViewer methodsFor: 'support' stamp: 'sw 8/6/2001 19:42'!limitClass	"Answer the receiver's limitClass"	| outer |	^ (outer := self outerViewer)		ifNotNil:			[outer limitClass]		ifNil:			[ProtoObject]! !!ChangeHooksTest methodsFor: 'Running' stamp: 'rej 9/29/2007 10:24'!tearDown	super tearDown.	self removeGeneratedTestClasses.	ChangeSet newChanges: previousChangeSet.	ChangesOrganizer removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:33'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 		[1 to: changeList size do:			[:i | aChange := changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass := aChange methodClass) notNil				and: [ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'pk 10/17/2006 09:34'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream := WriteStream on: (String new: 200).	(all := ChangesOrganizer allChangeSets copy) do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index := (UIManager default chooseFrom: (aStream contents substrings)).	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26'!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21'!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !!ChangeSetCategory methodsFor: 'miscellaneous' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector with: aChangeSet].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet] ! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:34'!changeSetList	"Answer the list of change-set names in the category"	| aChangeSet |	self reconstituteList.	keysInOrder size == 0 ifTrue:		["don't tolerate emptiness, because ChangeSorters gag when they have no change-set selected"		aChangeSet := ChangesOrganizer assuredChangeSetNamed: 'New Changes'.		self elementAt: aChangeSet name put: aChangeSet].	^ keysInOrder reversed! !!ChangeSetCategory methodsFor: 'queries' stamp: 'pk 10/17/2006 09:35'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector with: aChangeSet! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fileOutAllChangeSets	"File out all the nonempty change sets in the current category, suppressing the checks for slips that might otherwise ensue.  Obtain user confirmation before undertaking this possibly prodigious task."	| aList |	aList := self elementsInOrder select:		[:aChangeSet  | aChangeSet isEmpty not].	aList size == 0 ifTrue: [^ self inform: 'sorry, all the change sets in this category are empty'].	(self confirm: 'This will result in filing out ', aList size printString, ' change set(s)Are you certain you want to do this?') ifFalse: [^ self].	Preferences setFlag: #checkForSlips toValue: false during: 		[ChangesOrganizer fileOutChangeSetsNamed: (aList collect: [:m | m name]) asSortedArray]! !!ChangeSetCategory methodsFor: 'services' stamp: 'pk 10/17/2006 09:34'!fillAggregateChangeSet	"Create a change-set named Aggregate and pour into it all the changes in all the change-sets of the currently-selected category"	| aggChangeSet |	aggChangeSet :=  ChangesOrganizer assuredChangeSetNamed: #Aggregate.	aggChangeSet clear.	aggChangeSet setPreambleToSay: '"Change Set:		AggregateCreated at ', Time now printString, ' on ', Date today printString, ' by combining all the changes in all the change sets in the category ', categoryName printString, '"'.	(self elementsInOrder copyWithout: aggChangeSet) do:		[:aChangeSet  | aggChangeSet assimilateAllChangesFoundIn: aChangeSet].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup] ! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!includesChangeSet: aChangeSet	"Answer whether the receiver includes aChangeSet in its retrieval list"	^ ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet } , parameters! !!ChangeSetCategoryWithParameters methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:36'!reconstituteList	"Clear out the receiver's elements and rebuild them"	| newMembers |	"First determine newMembers and check if they have not changed..."	newMembers := ChangesOrganizer allChangeSets select:		[:aChangeSet | ChangesOrganizer perform: membershipSelector withArguments: { aChangeSet }, parameters].	(newMembers collect: [:cs | cs name]) = keysInOrder ifTrue: [^ self  "all current"].	"Things have changed.  Need to recompute the whole category"	self clear.	newMembers do:		[:aChangeSet | self fasterElementAt: aChangeSet name asSymbol put: aChangeSet]! !!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSorter methodsFor: 'access' stamp: 'pk 10/17/2006 09:37'!showChangeSetNamed: aName	self showChangeSet: (ChangesOrganizer changeSetNamed: aName) ! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:37'!annotationForPackageforSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing 	information about the given selector and class"	"requestList"| aCategory |aClass ifNil: [ ^nil] .aSelector ifNil: [ aClass theNonMetaClass category asString ] .aSelector ifNotNil: [ aCategory := aClass organization categoryOfElement: aSelector.(aCategory notNil and: [ aCategory first = $* ]) 	ifTrue: [^ aCategory asString]] .	"Ok. So the selector catagory does not indicate our package. We defer to the class catagory"^ aClass theNonMetaClass category asString.	! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!beginNote"return the string at the beginning of item annotation"^' {'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 16:56'!endNote"return the string at the beginning of item annotation"^'}'! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:21'!noteString: aString^ self beginNote , aString asString , self endNote! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/3/2007 15:39'!packageNoteForClass: aClass selector: aSelector "return the category name that represents the package name for aClass>>aSelector.when selector is nil or in a normal catagory return "| package |package := (self annotationForPackageforSelector: aSelector			ofClass: aClass) ifNil: ['<class was deleted???>'] .^ self noteString: package! !!ChangeSorter methodsFor: 'annotation' stamp: 'wiz 2/1/2007 17:17'!withoutItemAnnotation: aStringOrNil"return the current item without the package annotation we added on"| endItemIndex |aStringOrNil ifNil: [^nil] .( endItemIndex := aStringOrNil findString: self beginNote) = 0	ifTrue: [^ aStringOrNil ] .^ aStringOrNil first: endItemIndex - 1! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList |	aList := myChangeSet 		messageListForChangesWhich: [ :aClass :aSelector |			(ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector) size > 1		]		ifNone: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet 		openMessageList: aList 		name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!changeSetCategories	^ ChangesOrganizer changeSetCategories! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats aMenu result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats := self changeSetCategories elementsInOrder.	aMenu := SelectionMenu		labels: (cats collect: [:cat | cat categoryName])		selections: cats.	result := aMenu startUp.	result ifNotNil:		[changeSetCategory := result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:48'!chooseChangeSetCategoryInMorphic	"Present the user with a list of change-set-categories and let her choose one.  In this morphic variant, we include balloon help"	|  aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Choose the category ofchange sets to show inthis Change Sorter(red = current choice)'.	self changeSetCategories elementsInOrder do:		[:aCategory |			aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.			aCategory == changeSetCategory ifTrue:				[aMenu lastItem color: Color red].			aMenu balloonTextForLastItem: aCategory documentation].	aMenu popUpInWorld! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically := self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen := (SelectionMenu selections: changeSetsSortedAlphabetically)			startUp.	chosen ifNil: [^ self].	self showChangeSet: (ChangesOrganizer changeSetNamed: chosen)! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategory	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory |	catName := UIManager default request: 'Please give the new category a name' initialAnswer: ''.	catName isEmptyOrNil ifTrue: [^ self].	catName := catName asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := StaticChangeSetCategory new categoryName: catName.	self changeSetCategories elementAt: catName put: aCategory.	aCategory addChangeSet: myChangeSet.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!makeNewCategoryShowingClassChanges	"Create a new, static change-set category, which will be populated entirely by change sets that have been manually placed in it"	| catName aCategory clsName |	clsName := self selectedClass ifNotNil: [self selectedClass name ] ifNil: [''].	clsName := UIManager default request: 'Which class?' initialAnswer: clsName.	clsName isEmptyOrNil ifTrue: [^ self].	catName := ('Changes to ', clsName) asSymbol.	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	aCategory := ChangeSetCategoryWithParameters new categoryName: catName.	aCategory membershipSelector: #changeSet:containsClass: ; parameters: { clsName }.	self changeSetCategories elementAt: catName put: aCategory.	aCategory reconstituteList.	self showChangeSetCategory: aCategory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!removeCategory	"Remove the current category"	| itsName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only remove manually-added categories.'].	(self confirm: 'Really remove the change-set-categorynamed ', (itsName := changeSetCategory categoryName), '?') ifFalse: [^ self].	self changeSetCategories removeElementAt: itsName.	self setDefaultChangeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:36'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first, and if doPrompt is true, get the user to confirm his intentions first."	| message aName changeSetNumber msg |	aName := myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message := 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	doPrompt ifTrue:		[msg := myChangeSet hasPreamble			ifTrue:				[myChangeSet hasPostscript					ifTrue:						['a preamble and a postscript']					ifFalse:						['a preamble']]			ifFalse:				[myChangeSet hasPostscript					ifTrue:						['a postscript']					ifFalse:						['']].		msg isEmpty ifFalse:			[(self confirm: 'Caution!!  This change set has', msg, ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]]].	"Go ahead and remove the change set"	changeSetNumber := myChangeSet name initialIntegerOrNil.	changeSetNumber ifNotNil: [SystemVersion current unregisterUpdate: changeSetNumber].	ChangesOrganizer removeChangeSet: myChangeSet.	self showChangeSet: ChangeSet current.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!renameCategory	"Obtain a new name for the category and, if acceptable, apply it"	| catName oldName |	self changeSetCategory acceptsManualAdditions ifFalse:		[^ self inform: 'sorry, you can only rename manually-added categories.'].	catName := UIManager default request: 'Please give the new category a name' initialAnswer:  (oldName := changeSetCategory categoryName).	catName isEmptyOrNil ifTrue: [^ self].	(catName := catName asSymbol) = oldName ifTrue: [^ self inform: 'no change.'].	(self changeSetCategories includesKey: catName) ifTrue:		[^ self inform: 'Sorry, there is already a category of that name'].	changeSetCategory categoryName: catName.	self changeSetCategories removeElementAt: oldName.	self changeSetCategories elementAt: catName put: changeSetCategory.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:49'!showCategoriesOfChangeSet	"Show a list of all the categories in which the selected change-set occurs at the moment.  Install the one the user chooses, if any."	| aMenu |	Smalltalk isMorphic		ifFalse:			[self inform:'Only available in morphic, right now, sorry.It would not take much to make thisalso work in mvc, so if you areinclined to do that, thanks in advance...']		ifTrue:			[aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Categories whichcontain change set"', myChangeSet name, '"'.			self changeSetCategories elementsInOrder do:				[:aCategory |					(aCategory includesChangeSet: myChangeSet)						ifTrue:							[aMenu add: aCategory categoryName target: self selector: #showChangeSetCategory: argument: aCategory.						aCategory == changeSetCategory ifTrue:							[aMenu lastItem color: Color red]].						aMenu balloonTextForLastItem: aCategory documentation].				aMenu popUpInWorld]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'pk 10/17/2006 09:37'!showChangeSetCategory: aChangeSetCategory	"Show the given change-set category"		changeSetCategory := aChangeSetCategory.	self changed: #changeSetList.	(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].	self changed: #relabel! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:14'!basicClassList	"Computed.  View should try to preserve selections, even though index changes"	^ myChangeSet ifNotNil: [myChangeSet changedClassNames] ifNil: [OrderedCollection new]! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:35'!classList	"return the classlist with package note appended."		^ self basicClassList collect: [: each | 		each asString, (self packageNoteForClass: (Smalltalk classNamed: each) selector: nil) ] .! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:37'!fileOutClass	"this is a hack!!!! makes a new change set, called the class name, adds author initials to try to make a unique change set name, files it out and removes it. kfr 16 june 2000" 	| aSet |	"File out the selected class set."     aSet := self class newChangeSet: (self withoutItemAnnotation: currentClassName).	aSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	aSet fileOut.	self class removeChangeSet: aSet.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'class list' stamp: 'wiz 2/3/2007 01:38'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: (self withoutItemAnnotation: currentClassName).		currentClassName := nil.		currentSelector := nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'code pane' stamp: 'wiz 2/3/2007 01:34'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType | 	self clearUserEditFlag.	currentClassName ifNil: [^ contents := myChangeSet preambleString ifNil: ['']].	class := self selectedClassOrMetaClass.	(sel := self selectedMessageName) == nil		ifFalse: [changeType := (myChangeSet atSelector: (sel := sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents := 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents := 'Added then removed (see versions)'].			class ifNil: [^ contents := 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents := 'Method was added, but cannot be found!!'].			contents := class sourceCodeAt: sel.			(#(prettyPrint colorPrint prettyDiffs) includes: contentsSymbol) ifTrue:				[contents :=  class prettyPrinterClass					format: contents in: class notifying: nil contentsSymbol: contentsSymbol].			self showingAnyKindOfDiffs				ifTrue: [contents := self diffFromPriorSourceFor: contents].			^ contents := contents asText makeSelectorBoldIn: class]		ifTrue: [strm := WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents := strm contents].! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:13'!basicMessageList 	| probe newSelectors className |	currentClassName ifNil: [^ #()].	className := (self withoutItemAnnotation: currentClassName) .	probe := (className endsWith: ' class')		ifTrue: [className]		ifFalse: [className asSymbol].	newSelectors := myChangeSet selectorsInClass: probe.	(newSelectors includes: (self selectedMessageName)) 		ifFalse: [currentSelector := nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other := (parent other: self) changeSet.		cls := self selectedClassOrMetaClass.		sel := self selectedMessageName.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:32'!messageList 	| thisClass |	(thisClass := self selectedClassOrMetaClass) ifNil: [^ #() ] .	^self basicMessageList collect: [ :each |		each asString , (self packageNoteForClass: thisClass selector: each) ] .! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 7/22/2007 22:13'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^self].	self okToChange ifFalse: [^Beeper beep].	currentSelector ifNotNil: 			[other := (parent other: self) changeSet.			other == myChangeSet ifTrue: [^Beeper  beep].			cls := self selectedClassOrMetaClass.			sel := self selectedMessageName.			other 				absorbMethod: sel				class: cls				from: myChangeSet.			(parent other: self) showChangeSet: other.			self forget	"removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'wiz 2/3/2007 01:33'!selectedMessageName	currentSelector ifNil: [^ nil].	^ (self withoutItemAnnotation: currentSelector) asSymbol! !!ChangeSorter methodsFor: 'toolbuilder' stamp: 'wiz 2/1/2007 15:37'!buildWith: builder	"		ToolBuilder open: ChangeSorter.	"	|  windowSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec label: 'Change Sorter'.	windowSpec model: self.	windowSpec children: OrderedCollection new.	self buildWith: builder in: windowSpec rect: (0@0 extent: 1@1).	^builder build: windowSpec! !!ChangeSorter methodsFor: 'traits' stamp: 'wiz 2/3/2007 01:34'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName tName className |	currentClassName ifNil: [^ nil].	className := (self withoutItemAnnotation: currentClassName) .	(className endsWith: ' class')		ifTrue: [cName _ (className copyFrom: 1 to: className size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	(currentClassName endsWith: ' classTrait')		ifTrue: [tName _ (className copyFrom: 1 to: className size-11) asSymbol.				^ (Smalltalk at: tName ifAbsent: [^nil]) classTrait].	cName _ className asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !!ChangeSorter commentStamp: '<historical>' prior: 0!I display a ChangeSet.  Two of me are in a DualChangeSorter.!!ChangeSorter class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:10'!initialize	"ChangeSorter initialize"	FileList registerFileReader: self.	self registerInFlapsRegistry.! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 08:59'!allChangeSetNames	^ ChangesOrganizer allChangeSetNames! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:00'!allChangeSets	^ ChangesOrganizer allChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!allChangeSetsWithClass: class selector: selector	^ ChangesOrganizer allChangeSetsWithClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:19'!assuredChangeSetNamed: aName	^ ChangesOrganizer assuredChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!basicNewChangeSet: newName	^ ChangesOrganizer basicNewChangeSet: newName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAdditions: aChangeSet	^ ChangesOrganizer belongsInAdditions: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInAll: aChangeSet	^ ChangesOrganizer belongsInAll: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:03'!belongsInMyInitials: aChangeSet	^ ChangesOrganizer belongsInMyInitials: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	^ ChangesOrganizer belongsInNumbered: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:04'!belongsInProjectChangeSets: aChangeSet	^ ChangesOrganizer belongsInProjectChangeSets: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInProjectsInRelease:  aChangeSet	^ ChangesOrganizer belongsInProjectsInRelease:  aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:06'!belongsInRecentUpdates: aChangeSet	^ ChangesOrganizer belongsInRecentUpdates: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!buildAggregateChangeSet	^ ChangesOrganizer buildAggregateChangeSet	! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSet: aChangeSet containsClass: aClass	^ ChangesOrganizer changeSet: aChangeSet containsClass: aClass! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetCategoryNamed: aName	^ ChangesOrganizer changeSetCategoryNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetNamed: aName	^ ChangesOrganizer changeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:07'!changeSetNamesInReleaseImage	^ ChangesOrganizer changeSetNamesInReleaseImage! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:08'!changeSetNamesInThreeOh	^ ChangesOrganizer changeSetNamesInThreeOh! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:12'!changeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer changeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:20'!countOfChangeSetsWithClass: aClass andSelector: aSelector	^ ChangesOrganizer countOfChangeSetsWithClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!deleteChangeSetsNumberedLowerThan: anInteger	^ ChangesOrganizer deleteChangeSetsNumberedLowerThan: anInteger! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	^ ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!existingOrNewChangeSetNamed: aName	^ ChangesOrganizer existingOrNewChangeSetNamed: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:23'!fileOutChangeSetsNamed: nameList	^ ChangesOrganizer fileOutChangeSetsNamed: nameList! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!gatherChangeSets	^ ChangesOrganizer gatherChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!highestNumberedChangeSet	^ ChangesOrganizer highestNumberedChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:10'!initializeChangeSetCategories	^ ChangesOrganizer initializeChangeSetCategories! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:13'!mostRecentChangeSetWithChangeForClass: class selector: selector	^ ChangesOrganizer mostRecentChangeSetWithChangeForClass: class selector: selector! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:01'!newChangeSet	^ ChangesOrganizer newChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangeSet: aName	^ ChangesOrganizer newChangeSet: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:02'!newChangesFromStream: aStream named: aName	^ ChangesOrganizer newChangesFromStream: aStream named: aName! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:11'!noteChangeSetsInRelease	^ ChangesOrganizer noteChangeSetsInRelease! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:14'!promoteToTop: aChangeSet	^ ChangesOrganizer promoteToTop: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:21'!recentUpdateMarker	^ ChangesOrganizer recentUpdateMarker! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!recentUpdateMarker: aNumber	^ ChangesOrganizer recentUpdateMarker: aNumber! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'asm 4/10/2003 12:42'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(ChangeSorter			prototypicalToolWindow		'Change Set'			'A tool that allows you to view and manipulate all the code changes in a single change set')						forFlapNamed: 'Tools']! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:16'!removeChangeSet: aChangeSet	^ ChangesOrganizer removeChangeSet: aChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeChangeSetsNamedSuchThat: nameBlock	^ ChangesOrganizer removeChangeSetsNamedSuchThat: nameBlock! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:17'!removeEmptyUnnamedChangeSets	^ ChangesOrganizer removeEmptyUnnamedChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!reorderChangeSets	^ ChangesOrganizer reorderChangeSets! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'pk 10/17/2006 09:22'!secondaryChangeSet	^ ChangesOrganizer secondaryChangeSet! !!ChangeSorter class methodsFor: 'deprecated' stamp: 'ar 9/27/2005 19:56'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangeSorter class methodsFor: 'browse' stamp: 'sd 11/20/2005 21:28'!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits index |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ self inform: class name, '.', selector , 'is not in any change set'].	index := hits size == 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'browse' stamp: 'sd 11/20/2005 21:28'!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits index |	hits := self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ self inform: aSelector , 'is not in any change set'].	index := hits size == 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSetBrowser new myChangeSet: (hits at: index)) open"ChangeSorter browseChangeSetsWithSelector: #clearPenTrails"! !!ChangeSorter class methodsFor: 'browse' stamp: 'sw 6/13/2001 00:56'!prototypicalToolWindow	"Answer a window representing a prototypical instance of the receiver"	^ self new morphicWindow applyModelExtent! !!ChangesOrganizer commentStamp: 'pk 10/17/2006 09:25' prior: 0!Changes organizer!!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetNames	^ self allChangeSets collect: [:c | c name]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSets	"Return the list of all current ChangeSets"	^ChangeSet allChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetNamed: aName	"Return the change set of the given name, or nil if none found.  1/22/96 sw"	^ChangeSet named: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!changeSetsNamedSuchThat: nameBlock	^ChangeSet changeSetsNamedSuchThat: nameBlock! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!existingOrNewChangeSetNamed: aName	^ChangeSet existingOrNewChangeSetNamed: aName! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!gatherChangeSets		"ChangeSorter gatherChangeSets"	^ChangeSet gatherChangeSets! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (ChangeSet allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangesOrganizer class methodsFor: 'enumerating' stamp: 'pk 2/6/2006 09:49'!promoteToTop: aChangeSet	"Make aChangeSet the first in the list from now on"	^ChangeSet promoteToTop: aChangeSet! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self changeSetNamed: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSorter buildAggregateChangeSet"	! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!countOfChangeSetsWithClass: aClass andSelector: aSelector	"Answer how many change sets record a change for the given class and selector"	^ (self allChangeSetsWithClass: aClass selector: aSelector) size! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!doesAnyChangeSetHaveClass: aClass andSelector: aSelector	"Answer whether any known change set bears a change for the given class and selector"	^ (self countOfChangeSetsWithClass: aClass andSelector: aSelector) > 0! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker	"Answer the number representing the threshold of what counts as 'recent' for an update number.  This allow you to use the RecentUpdates category in a ChangeSorter to advantage"	^ RecentUpdateMarker ifNil: [RecentUpdateMarker := 0]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!recentUpdateMarker: aNumber	"Set the recent update marker as indicated"	^ RecentUpdateMarker := aNumber! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!reorderChangeSets	"Change the order of the change sets to something more convenient:		First come the project changesets that come with the release.  These are mostly empty.		Next come all numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	"ChangeSorter reorderChangeSets"	| newHead newMid newTail |	newHead := OrderedCollection new.	newMid := OrderedCollection new.	newTail := OrderedCollection new.	ChangeSet allChangeSets do:		[:aChangeSet |			(self belongsInProjectsInRelease: aChangeSet)				ifTrue:					[newHead add: aChangeSet]				ifFalse:					[(self belongsInNumbered: aChangeSet)						ifTrue:							[newMid add: aChangeSet]						ifFalse:							[newTail add: aChangeSet]]].	ChangeSet allChangeSets: newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangesOrganizer class methodsFor: 'services' stamp: 'pk 2/6/2006 09:49'!secondaryChangeSet	^ChangeSet secondaryChangeSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!basicNewChangeSet: newName	^ChangeSet basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[ChangeSet  newChanges: newSet].	^ newSet! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!ChangesOrganizer class methodsFor: 'adding' stamp: 'pk 2/6/2006 09:49'!newChangesFromStream: aStream named: aName	^ChangeSet newChangesFromStream: aStream named: aName! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAdditions: aChangeSet	"Answer whether a change set belongs in the Additions category, which is fed by all change sets that are neither numbered nor in the initial release"	^ (((self belongsInProjectsInRelease: aChangeSet) or:		[self belongsInNumbered: aChangeSet])) not! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInAll: aChangeSet	"Answer whether a change set belongs in the All category"	^ true ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInMyInitials: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet name endsWith: ('-', Utilities authorInitials)! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 09:04'!belongsInNumbered: aChangeSet	"Answer whether a change set belongs in the Numbered category. "	^  aChangeSet name startsWithDigit! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectChangeSets: aChangeSet	"Answer whether a change set belongs in the MyInitials category. "	^ aChangeSet belongsToAProject! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInProjectsInRelease:  aChangeSet	"Answer whether a change set belongs in the ProjectsInRelease category.  You can hand-tweak this to suit your working style.  This just covers the space of project names in the 2.9, 3.0, and 3.1a systems"	| aString |	^ ((aString := aChangeSet name) beginsWith: 'Play With Me') or: [self changeSetNamesInReleaseImage includes: aString]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!belongsInRecentUpdates: aChangeSet	"Answer whether a change set belongs in the RecentUpdates category."	^ aChangeSet name startsWithDigit and:			[aChangeSet name asInteger >= self recentUpdateMarker]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetCategoryNamed: aName	"Answer the changeSetCategory of the given name, or nil if none"	^ ChangeSetCategories elementAt: aName asSymbol ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInReleaseImage	"Answer a list of names of project change sets that come pre-shipped in the latest sytem release.  On the brink of shipping a new release, call 'ChangeSorter noteChangeSetsInRelease'  "	^ ChangeSetNamesInRelease ifNil:		[ChangeSetNamesInRelease := self changeSetNamesInThreeOh]! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!changeSetNamesInThreeOh	"Hard-coded: answer a list of names of project change sets that came pre-shipped in Squeak 3.0"	^ #('The Worlds of Squeak' 'Fun with Morphic' 'Games' 'Fun With Music' 'Building with Squeak' 'Squeak and the Internet' 'Squeak in 3D' 'More About Sound' ) ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 10/17/2006 10:03'!initialize	"Initialize the class variables"	ChangeSetCategories ifNil:		[self initializeChangeSetCategories].	RecentUpdateMarker := 0.! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!initializeChangeSetCategories	"Initialize the set of change-set categories"	"ChangeSorter initializeChangeSetCategories"	| aCategory |	ChangeSetCategories := ElementCategory new categoryName: #ChangeSetCategories.	aCategory := ChangeSetCategory new categoryName: #All.	aCategory membershipSelector: #belongsInAll:.	aCategory documentation: 'All change sets known to the system'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Additions.	aCategory membershipSelector: #belongsInAdditions:.	aCategory documentation: 'All unnumbered change sets except those representing projects in the system as initially released.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #MyInitials.	aCategory membershipSelector: #belongsInMyInitials:.	aCategory documentation: 'All change sets whose names end with the current author''s initials.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #Numbered.	aCategory membershipSelector: #belongsInNumbered:.	aCategory documentation: 'All change sets whose names start with a digit -- normally these will be the official updates to the system.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectChangeSets.	aCategory membershipSelector: #belongsInProjectChangeSets:.	aCategory documentation: 'All change sets that are currently associated with projects present in the system right now.'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #ProjectsInRelease.	aCategory membershipSelector: #belongsInProjectsInRelease:.	aCategory documentation: 'All change sets belonging to projects that were shipped in the initial release of this version of Squeak'.	ChangeSetCategories addCategoryItem: aCategory.	aCategory := ChangeSetCategory new categoryName: #RecentUpdates.	aCategory membershipSelector: #belongsInRecentUpdates:.	aCategory documentation: 'Updates whose numbers are at or beyond the number I have designated as the earliest one to qualify as Recent'.	ChangeSetCategories addCategoryItem: aCategory.	ChangeSetCategories elementsInOrder do: [:anElem | anElem reconstituteList] ! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!noteChangeSetsInRelease	"Freshly compute what the change sets in the release are; to be called manually just before a release"	ChangeSetNamesInRelease := (Project allProjects collect: [:p | p name]) asSet asOrderedCollection."ChangeSorter noteChangeSetsInRelease"! !!ChangesOrganizer class methodsFor: 'class initialization' stamp: 'pk 2/6/2006 09:49'!unload	"Unload the receiver from global registries"	self environment at: #FileList ifPresent: [:cl |	cl unregisterFileReader: self].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!deleteChangeSetsNumberedLowerThan: anInteger	"Delete all changes sets whose names start with integers smaller than anInteger"	self removeChangeSetsNamedSuchThat:		[:aName | aName first isDigit and: [aName initialIntegerOrNil < anInteger]].	"ChangesOrganizer deleteChangeSetsNumberedLowerThan: (ChangeSorter highestNumberedChangeSet name initialIntegerOrNil - 500)"! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	^ChangeSet removeChangeSet: aChangeSet! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeChangeSetsNamedSuchThat: nameBlock	(self changeSetsNamedSuchThat: nameBlock)		do: [:cs | self removeChangeSet: cs]! !!ChangesOrganizer class methodsFor: 'removing' stamp: 'pk 2/6/2006 09:49'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangesOrganizer class methodsFor: 'utilities' stamp: 'pk 2/6/2006 09:49'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | (aChangeSet := self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:35'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."	| v |	v := self charCode.	(((8r101 <= v and: [v <= 8r132]) or: [16rC0 <= v and: [v <= 16rD6]]) or: [16rD8 <= v and: [v <= 16rDE]])		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 21:51'!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset := EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self charCode].	table := charset ucsTable.	table isNil ifTrue: [^ 16rFFFD].	v := table at: self charCode + 1.	v = -1 ifTrue: [^ 16rFFFD].	^ v.! !!Character methodsFor: 'converting' stamp: 'ar 4/9/2005 22:25'!asUnicodeChar	"@@@ FIXME: Make this use asUnicode and move it to its lonely sender @@@"	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	charset := EncodedCharSet charsetAt: self leadingChar.	charset isCharset ifFalse: [^ self].	table := charset ucsTable.	table isNil ifTrue: [^ Character value: 16rFFFD].	v := table at: self charCode + 1.	v = -1 ifTrue: [^ Character value: 16rFFFD].	^ Character leadingChar: charset unicodeLeadingChar code: v.! !!Character methodsFor: 'converting' stamp: 'yo 8/16/2004 11:34'!asUppercase	"If the receiver is lowercase, answer its matching uppercase Character."	"A tentative implementation.  Eventually this should consult the Unicode table."		| v |	v := self charCode.	(((8r141 <= v and: [v <= 8r172]) or: [16rE0 <= v and: [v <= 16rF6]]) or: [16rF8 <= v and: [v <= 16rFE]])		ifTrue: [^ Character value: value - 8r40]		ifFalse: [^ self]! !!Character methodsFor: 'converting' stamp: 'yo 8/11/2003 21:18'!basicSqueakToIso	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'converting' stamp: 'ar 4/10/2005 16:05'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	| asciiValue |	value < 128 ifTrue: [^ self].	value > 255 ifTrue: [^ self].	asciiValue := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 255 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 253 254 ) at: self asciiValue - 127.	^ Character value: asciiValue.! !!Character methodsFor: 'printing' stamp: 'lr 1/3/2007 19:30'!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	(value between: 33 and: 255)		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!Character methodsFor: 'private' stamp: 'ar 4/9/2005 22:18'!setValue: newValue	value ifNotNil:[^self error:'Characters are immutable'].	value := newValue.! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'wiz 4/9/2006 20:30'!nbsp	"non-breakable space. Latin1 encoding common usage."	^ Character value: 160! !!Character class methodsFor: 'instance creation'!digitValue: x 	"Answer the Character whose digit value is x. For example, answer $9 for 	x=9, $0 for x=0, $A for x=10, $Z for x=35."	| index |	index := x asInteger.	^CharacterTable at: 		(index < 10			ifTrue: [48 + index]			ifFalse: [55 + index])		+ 1! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!add: aCharacter	"I automatically become a WideCharacterSet if you add a wide character to myself"		aCharacter asciiValue >= 256		ifTrue: [| wide |			wide := WideCharacterSet new.			wide addAll: self.			wide add: aCharacter.			self become: wide.			^aCharacter].	map at: aCharacter asciiValue + 1 put: 1.	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:09'!includes: aCharacter	aCharacter asciiValue >= 256		ifTrue: ["Guard against wide characters"			^false].	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:20'!remove: aCharacter	aCharacter asciiValue >= 256		ifFalse: ["Guard against wide characters"			map at: aCharacter asciiValue + 1 put: 0].	^aCharacter! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:02'!size	^map sum! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:28'!byteComplement	"return a character set containing precisely the single byte characters the receiver does not"		| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map := ByteArray new: 256 withAll: 0.! !!CharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 23:22'!wideCharacterMap	"used for comparing with WideCharacterSet"		| wide |	wide := WideCharacterSet new.	wide addAll: self.	^wide wideCharacterMap! !!CharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:23'!hasWideCharacters	^false! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set := self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection := self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set := self empty.	set addAll: Character separators.	^set! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:19'!= anObject	"Implementation note: we do not test if equal to a WideCharacterSet,	because it is unlikely that WideCharacterSet is as complete as self"		^self class == anObject class and: [		absent = anObject complement ]! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 3/23/2007 02:16'!hash	^absent hash bitXOr: self class hash! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!add: aCharacter	"a character is present if not absent"		(absent includes: aCharacter) ifTrue: [absent remove: aCharacter].	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:11'!do: aBlock	"evaluate aBlock with each character in the set.	don't do it, there are too many..."	self shouldNotImplement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:07'!includes: aCharacter	^(absent includes: aCharacter) not! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!reject: aBlock	"Implementation note: rejecting present is selecting absent"		^(absent select: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:06'!remove: aCharacter	"This means a character is absent from myself"		^absent add: aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:15'!select: aBlock	"Implementation note: selecting present is rejecting absent"		^(absent reject: aBlock) complement! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 3/23/2007 02:10'!size	"Is this 2**32-absent size ?"		^self shouldNotImplement! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 3/23/2007 02:21'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^absent byteArrayMap collect: [:i | 1 - i]! !!CharacterSetComplement methodsFor: 'converting' stamp: 'nice 3/23/2007 02:08'!complement	"return a character set containing precisely the characters the receiver does not"		^absent copy! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 3/23/2007 02:25'!complement: aCharacterSet	"initialize with the complement"		absent := aCharacterSet! !!CharacterSetComplement methodsFor: 'testing' stamp: 'nice 3/23/2007 02:12'!hasWideCharacters	"This is a guess that absent is not holding each and every possible wideCharacter..."		^true! !!CharacterSetComplement commentStamp: 'nice 3/23/2007 02:27' prior: 0!CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)instance variables:	absent <CharacterSet> contains character that are not in the set (i.e. my complement)!!CharacterSetComplement class methodsFor: 'instance creation' stamp: 'nice 3/23/2007 02:25'!of: aCharacterSet	"answer the complement of aCharacterSet"		^ super new complement: aCharacterSet! !!Circle class methodsFor: 'examples'!exampleOne 	"Click any button somewhere on the screen. The point will be the center	of the circcle of radius 150."	| aCircle aForm |	aForm := Form extent: 1@30.	aForm fillBlack.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display		"Circle exampleOne"! !!Circle class methodsFor: 'examples'!exampleTwo	"Designate a rectangular area that should be used as the brush for	displaying the circle. Click any button at a point on the screen which	will be the center location for the circle. The curve will be displayed	with a long black form."	| aCircle aForm |	aForm := Form fromUser.	aCircle := Circle new.	aCircle form: aForm.	aCircle radius: 150.	aCircle center: Sensor waitButton.	aCircle displayOn: Display at: 0 @ 0 rule: Form reverse 	 "Circle exampleTwo"! !!CircleMorph methodsFor: 'parts bin' stamp: 'wiz 1/5/2007 16:23'!initialize	^super initialize		extent: 40@40;		color: Color green lighter;		yourself! !!CircleMorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testCircleInstance"""self run: #testCircleInstance" | circ |self assert: (circ := CircleMorph initializedInstance) extent = circ extent x asPoint! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30'!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20'!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'pk 5/13/2007 14:16'!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangesOrganizer removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21'!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05'!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08'!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13'!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:07'!clearInterpreter	interpreter := nil.! !!Clipboard methodsFor: 'accessing' stamp: 'edc 5/8/2007 17:04'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| string decodedString |	string := self primitiveClipboardText withSqueakLineEndings.	(string isEmpty			or: [string = contents asString])		ifTrue: [^ contents].	decodedString := self interpreter fromSystemClipboard: string.	^ decodedString = contents asString 		ifTrue: [contents]		ifFalse: [decodedString asText].! !!Clipboard methodsFor: 'accessing' stamp: 'yo 8/11/2003 19:12'!clipboardText: text 	| string |	string := text asString.	self noteRecentClipping: text asText.	contents := text asText.	string := self interpreter toSystemClipboard: string.	self primitiveClipboardText: string.! !!Clipboard methodsFor: 'accessing' stamp: 'mir 7/20/2004 15:44'!setInterpreter	interpreter := LanguageEnvironment defaultClipboardInterpreter.	interpreter ifNil: [		"Should never be reached, but just in case."		interpreter := NoConversionClipboardInterpreter new].! !!Clipboard methodsFor: 'initialize' stamp: 'ar 1/15/2001 18:34'!initialize	contents := '' asText.	recent := OrderedCollection new.! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:33'!default	^Default ifNil:[Default := self new].! !!Clipboard class methodsFor: 'accessing' stamp: 'ar 1/15/2001 18:48'!default: aClipboard	"So that clients can switch between different default clipboards"	Default := aClipboard.! !!CodeHolder methodsFor: 'annotation' stamp: 'pk 10/17/2006 09:38'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'controls' stamp: 'dtl 1/28/2007 09:17'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as written')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')(colorPrint		toggleColorPrint				colorPrintString				'colorPrint'			'the method source in a standard text format with colors to distinguish structural parts') -(showDiffs		toggleRegularDiffing		showingRegularDiffsString	'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'nk 4/28/2004 10:14'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow := self containingWindow)		ifNil: [self error: 'hamna dirisha'].	tileScriptor := ((aSelector := self selectedMessageName) isNil					or: [(aClass := self selectedClassOrMetaClass whichClassIncludesSelector: aSelector) isNil])				ifTrue: [PluggableTileScriptorMorph new]				ifFalse: [source := aClass sourceCodeAt: aSelector.					tree := Compiler new								parse: source								in: aClass								notifying: nil.					(syn := tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.					syn inAPluggableScrollPane].	codePane := aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBars].	codePane		ifNil: [codePane := aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod := aClass				ifNotNil: [aClass compiledMethodAt: aSelector].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'rhi 1/4/2002 11:15'!showTiles: aBoolean	"Set the showingTiles as indicated.  The fact that there are initially no senders of this reflects that fact that initially this trait is only directly settable through the UI; later there may be senders, such as if one wanted to set a system up so that all newly-opened browsers showed tiles rather than text."	aBoolean		ifTrue:			[contentsSymbol := #tiles]		ifFalse:			[contentsSymbol == #tiles ifTrue: [contentsSymbol := #source]].	self setContentsToForceRefetch.	self changed: #contents! !!CodeHolder methodsFor: '*eToys-tiles' stamp: 'sw 2/14/2001 15:27'!toggleShowingTiles	"Toggle whether tiles should be shown in the code pane"	self okToChange ifTrue:		[self showingTiles			ifTrue:				[contentsSymbol := #source.				self setContentsToForceRefetch.				self installTextualCodingPane.				self contentsChanged]			ifFalse:				[contentsSymbol := #tiles.				self installTilesForSelection.				self changed: #tiles]]! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:34'!size	"Answer how many elements the receiver contains."	| tally |	tally := 0.	self do: [:each | tally := tally + 1].	^ tally! !!Collection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:36'!hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size <= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array := Array new: self size.	index := 0.	self do: [:each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array := ByteArray new: self size.	index := 0.	self do: [:each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'LC 6/18/2001 18:46'!asSkipList: aSortBlock 	"Answer a SkipList whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| skipList |	skipList := SortedCollection new: self size.	skipList sortBlock: aSortBlock.	skipList addAll: self.	^ skipList! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:46'!asSortedCollection: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection := SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'converting' stamp: 'hg 12/26/2001 23:53'!topologicallySortedUsing: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver, but topologically sorted. The topological order is defined 	by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection := SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	self do: [:each | aSortedCollection addLast: each].	"avoids sorting"	^ aSortedCollection sortTopologically! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:45'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!count: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| sum |	sum := 0.	self do: [:each | (aBlock value: each) ifTrue: [sum := sum + 1]].	^ sum! !!Collection methodsFor: 'enumerating'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue val |	self do: [:each | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!Collection methodsFor: 'enumerating'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue val |	self do: [:each | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!Collection methodsFor: 'enumerating'!detectSum: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Return the sum of the answers."	| sum |	sum := 0.	self do: [:each | 		sum := (aBlock value: each) + sum].  	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:57'!do: elementBlock separatedBy: separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| beforeFirst | 	beforeFirst := true.	self do:		[:each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!Collection methodsFor: 'enumerating' stamp: 'dvf 6/10/2000 18:32'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result key |	result := PluggableDictionary integerDictionary.	self do: 		[:e | 		key := keyBlock value: e.		(result includesKey: key)			ifFalse: [result at: key put: OrderedCollection new].		(result at: key)			add: e].	^ result := result select: selectBlock! !!Collection methodsFor: 'enumerating'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!Collection methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Collection methodsFor: 'math functions' stamp: 'TAG 11/6/1998 16:02'!sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample := self anyOne.	sum := self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'printing' stamp: 'gk 1/14/2005 08:27'!asStringOn: aStream delimiter: delimString last: lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'.	Uses #asString instead of #print:	Note: Feel free to improve the code to detect the last element."	| n sz |	n := 1.	sz := self size.	self do: [:elem |		n := n + 1.		aStream nextPutAll: elem asString]	separatedBy: [		aStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]! !!Collection methodsFor: 'printing' stamp: 'fbs 1/14/2005 10:54'!printOn: aStream delimiter: delimString last: lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'	Note: Feel free to improve the code to detect the last element."	| n sz |	n := 1.	sz := self size.	self do: [:elem |		n := n + 1.		aStream print: elem]	separatedBy: [		n = sz			ifTrue: [aStream print: lastDelimString]			ifFalse: [aStream print: delimString]]! !!Collection methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet := true.	self do: 		[:each | 		noneYet			ifTrue: [noneYet := false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' add: '.		aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Collection methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| tally |	tally := 0.	self do: [:each | anObject = each ifTrue: [tally := tally + 1]].	^tally! !!Collection methodsFor: 'private'!toBraceStack: itsSize 	"Push receiver's elements onto the stack of thisContext sender.  Error if receiver does	 not have itsSize elements or if receiver is unordered.	 Do not call directly: this is called by {a. b} := ... constructs."	self size ~= itsSize ifTrue:		[self error: 'Trying to store ', self size printString,					' values into ', itsSize printString, ' variables.'].	thisContext sender push: itsSize fromIndexable: self! !!Collection class methodsFor: 'private' stamp: 'lr 11/4/2003 12:07'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking := Random new.	MutexForPicking := Semaphore forMutualExclusion! !!CollectionTest methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!testPrintingArrayWithMetaclass	self assert: {Array class} printString = '{Array class}'! !!Color methodsFor: 'html' stamp: 'hmm 11/1/2006 23:28'!printHtmlString	"answer a string whose characters are the html representation  	of the receiver"	^ ((self red * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self green * 255) asInteger printStringBase: 16 length: 2 padded: true)	, ((self blue * 255) asInteger printStringBase: 16 length: 2 padded: true)! !!ColorSeerTile methodsFor: 'initialization' stamp: 'mir 7/12/2004 20:23'!initialize"initialize the state of the receiver"	| m1 m2 desiredW wording |	super initialize.""	self removeAllMorphs.	"get rid of the parts of a regular Color tile"	type := #operator.	operatorOrExpression := #color:sees:.	wording := (Vocabulary eToyVocabulary				methodInterfaceAt: operatorOrExpression				ifAbsent: []) wording.	m1 := StringMorph contents: wording font: ScriptingSystem fontForTiles.	m2 := Morph new extent: 12 @ 8;								color: (Color						r: 0.8						g: 0						b: 0).	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth)			@ self class defaultH.	m1 position: bounds center x - (m1 width // 2) @ (bounds top + 5).	m2 position: bounds center x - (m2 width // 2) + 3 @ (bounds top + 8).	self addMorph: m1;		 addMorphFront: m2.	colorSwatch := m2! !!ColorSeerTile methodsFor: 'initialization' stamp: 'mir 7/15/2004 15:20'!updateWordingToMatchVocabulary	"The current vocabulary has changed; change the wording on my face, if appropriate"	| aMethodInterface |	aMethodInterface := self currentVocabulary methodInterfaceAt: operatorOrExpression ifAbsent: [Vocabulary eToyVocabulary methodInterfaceAt: operatorOrExpression ifAbsent: [^ self]].	self labelMorph contents: aMethodInterface wording.	self setBalloonText: aMethodInterface helpMessage.! !!ColorSwatch methodsFor: 'as yet unclassified' stamp: 'sw 7/13/1999 13:39'!argument: arg	argument := arg! !!ColorSwatch methodsFor: 'setting' stamp: 'sw 3/23/2001 12:12'!setTargetColor: aColor	"Set the target color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents := aColor.		target perform: self putSelector withArguments: (Array with: argument with: aColor)]! !!ColorTileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize"initialize the state of the receiver"	super initialize.""	type := #literal.	self addColorSwatch! !!ColorTileMorph methodsFor: 'initialization' stamp: 'yo 7/2/2004 17:33'!updateWordingToMatchVocabulary	| stringMorph |	stringMorph := submorphs detect: [:morph | morph class == StringMorph] ifNone: [^ self].	stringMorph contents: 'color' translated.! !!ColorTileMorph methodsFor: 'other' stamp: 'yo 7/2/2004 17:33'!addColorSwatch	| m1 m2 desiredW |	m1 := StringMorph contents: 'color' translated font: ScriptingSystem fontForTiles.	m2 := Morph new extent: 12@8; color: (Color r: 0.8 g: 0 b: 0).	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	m2 position: (bounds center x - (m2 width // 2)) @ (m1 bottom - 1).	self addMorph: m1; addMorph: m2.	colorSwatch := m2! !!CommandTilesMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:13'!initialize	super initialize.	self wrapCentering: #center; cellPositioning: #leftCenter.	self hResizing: #shrinkWrap.	borderWidth := 0.	self layoutInset: 0.	self extent: 5@5.  "will grow to fit"! !!CommandTilesMorph methodsFor: 'initialization' stamp: 'sw 1/29/98 18:32'!setMorph: aMorph	playerScripted := aMorph playerScripted! !!CommandTilesMorph methodsFor: 'miscellaneous'!tileRows	^ Array with: self submorphs! !!CommandTilesMorph commentStamp: '<historical>' prior: 0!An entire Smalltalk statement in tiles.  A line of code.!!CompiledMethod methodsFor: 'literals' stamp: 'ms 5/10/2007 11:21'!hasLiteralThorough: aLiteral from: aBlock	"Answer true if any literal in this method is literal, even if embedded in array structure or within its pragmas."	| literal |	self pragmas do: [ :pragma |		(pragma hasLiteral: aLiteral) ifTrue: [ ^ true ] ].	2 to: self numLiterals + 1 do: [ :index | 		literal := self objectAt: index.		literal == aLiteral  ifTrue: [ ^ true ].		literal == aBlock ifFalse:[ (literal hasLiteralThorough: aLiteral) ifTrue: [ ^ true ]] ].	^ false.! !!Compiler methodsFor: 'error handling' stamp: 'stephaneducassse 11/5/2005 16:39'!interactive	"this version of the method is necessary to load code from MC else the interactive mode is one. 	This method is really bad since it links the compiler package with the Tools	one. The solution would be to have a real SyntaxError exception belonging to the 	compiler package and not a subclass of StringHolder - sd Nov 2005"	"the code submitted by PlusTools is ideally the one that should be used	interactive	      ^requestor ~~ nil "		^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:47'!compiledMethodFor: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result _ self				compiledMethodFor: aString 				in: aContext 				to: aReceiver 				notifying: nil				ifFail: [^#Failed] 				logged: false.	^ result! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:48'!compiledMethodFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].		logFlag ifTrue: [SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^ method.! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29'!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!CompoundTileMorph methodsFor: 'code generation' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows := scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r := rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'tk 2/28/2001 21:25'!mouseDown: evt 	"Pretend we picked up the tile and then put it down for a trial  	positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss guyToTake |"	self isPartsDonor ifTrue:[		dup := self duplicate.		evt hand attachMorph: dup.		dup position: evt position.		^self].	submorphs isEmpty 			never true		ifTrue: [^ self]."	(ed := self enclosingEditor) ifNil: [^evt hand grabMorph: self].	guyToTake := self.	owner class == TilePadMorph		ifTrue: ["picking me out of another phrase"			(ss := submorphs first) class == TilePadMorph				ifTrue: [ss := ss submorphs first].			guyToTake :=  ss veryDeepCopy].	evt hand grabMorph: guyToTake.	ed startStepping.	ed mouseEnterDragging: evt.	ed setProperty: #justPickedUpPhrase toValue: true.! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'jm 10/18/97 21:03'!mouseEnter: evt	"Resume drop-tracking in enclosing editor"	| ed |	(ed := self enclosingEditor) ifNotNil:		[ed mouseLeave: evt]! !!CompoundTileMorph methodsFor: 'event handling' stamp: 'jm 10/18/97 21:02'!mouseLeave: evt	"Resume drop-tracking in enclosing editor"	| ed |	(ed := self enclosingEditor) ifNotNil:		[ed mouseEnter: evt]! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'sw 7/22/2004 00:13'!initialize	"initialize the state of the receiver"	| r stringMorph |	super initialize.	self layoutInset: 2.	self listDirection: #topToBottom.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap; cellInset: (0 @ 1); minCellSize: (200@14).	"NB: hResizing gets reset to #spaceFill below, after the standalone structure is created"	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r setProperty: #demandsBoolean toValue: true.	r addMorphBack: (Morph new color: color;			 extent: 2 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'Test' translated.	stringMorph name: 'Test'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (testPart := BooleanScriptEditor new borderWidth: 0;					 layoutInset: 1).	testPart color: Color transparent.	testPart hResizing: #spaceFill.	self addMorphBack: r.	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 30 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'Yes' translated.	stringMorph name: 'Yes'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (yesPart := ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	yesPart hResizing: #spaceFill.	yesPart color: Color transparent.	self addMorphBack: r.	r := AlignmentMorph newRow color: color;				 layoutInset: 0.	r addMorphBack: (Morph new color: color;			 extent: 35 @ 5).	"spacer"	stringMorph := StringMorph new contents: 'No' translated.	stringMorph name: 'No'.	r addMorphBack: stringMorph.	r addMorphBack: (Morph new color: color;			 extent: 5 @ 5).	"spacer"	r addMorphBack: (noPart := ScriptEditorMorph new borderWidth: 0;					 layoutInset: 2).	noPart hResizing: #spaceFill.	noPart color: Color transparent.	self addMorphBack: r.	self bounds: self fullBounds.	self updateWordingToMatchVocabulary. 	self hResizing:#spaceFill! !!CompoundTileMorph methodsFor: 'initialization' stamp: 'nk 10/8/2004 11:56'!updateWordingToMatchVocabulary	| labels |	labels := OrderedCollection new.	self submorphs do: [:submorph |		submorph submorphs do: [:subsubmorph |			subsubmorph class == StringMorph ifTrue: [labels add: subsubmorph]]].	labels do: [:label | label knownName ifNotNilDo: [ :nm | label acceptValue: nm translated ]]! !!CompoundTileMorph methodsFor: 'miscellaneous' stamp: 'di 5/6/1998 21:10'!tile: tile isOnLineAfter: previousTile	"Return true if the given tile is not on the same line at the previous tile or if the previous tile is nil."	| tileRow previousRow |	previousTile ifNil: [^ true].	tileRow := tile owner.	[tileRow isMemberOf: AlignmentMorph]		whileFalse: [tileRow := tileRow owner].  "find the owning row"	previousRow := previousTile owner.	[previousRow isMemberOf: AlignmentMorph]		whileFalse: [previousRow := previousRow owner].  "find the owning row"	^ tileRow ~~ previousRow! !!CompoundTileMorph methodsFor: 'mouse'!targetPartFor: aMorph	"Return the row into which the given morph should be inserted."	| centerY |	centerY := aMorph fullBounds center y.	(Array with: testPart with: yesPart with: noPart) do: [:m |		(centerY <= m bounds bottom) ifTrue: [^ m]].	^ noPart! !!ContextPart methodsFor: 'private' stamp: 'dik 9/3/2007 13:00'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"					(primitiveIndex = 19) ifTrue:[		ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 186 ifTrue: [ "closure value"		| m |		m _ receiver method.		arguments size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: arguments			receiver: receiver			class: receiver class].	primitiveIndex = 187 ifTrue: [ "closure valueWithArguments:"		| m args |		m _ receiver method.		args _ arguments first.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	primitiveIndex = 188 ifTrue: [ "object withArgs:executeMethod:"		| m args |		args _ arguments first.		m _ arguments second.		args size = m numArgs ifFalse: [^ PrimitiveFailToken].		^ self activateMethod: m			withArgs: args			receiver: receiver			class: receiver class].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController := aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess := 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'accessing'!activeControllerNoTerminate: aController andProcess: aProcess	"Set aController to be the currently active controller and aProcess to be 	the the process that handles controller scheduling activities in the 	system. This message differs from activeController:andProcess: in that it 	does not send controlTerminate to the currently active controller."	self inActiveControllerProcess		ifTrue: 			[aController~~nil				ifTrue: [(scheduledControllers includes: aController)							ifTrue: [self promote: aController]							ifFalse: [self error: 'Old controller not scheduled']].			activeController := aController.			activeController == nil				ifFalse: [activeController controlInitialize].			activeControllerProcess := aProcess.			activeControllerProcess resume]		ifFalse: 			[self error: 'New active controller process must be set from old one'] ! !!ControlManager methodsFor: 'accessing'!noteNewTop	newTopClicked := true! !!ControlManager methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:06'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view := (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view displayOn: ((BitBlt current toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!ControlManager methodsFor: 'initialize-release'!initialize	"Initialize the receiver to refer to only the background controller."	| screenView |	screenController := ScreenController new.	screenView := FormView new.	screenView model: (InfiniteForm with: Color gray) controller: screenController.	screenView window: Display boundingBox.	scheduledControllers := OrderedCollection with: screenController! !!ControlManager methodsFor: 'initialize-release'!release 	"Refer to the comment in Object|release."	scheduledControllers == nil		ifFalse: 			[scheduledControllers 				do: [:controller | (controller isKindOf: Controller)								ifTrue: [controller view release]								ifFalse: [controller release]].			scheduledControllers := nil]! !!ControlManager methodsFor: 'scheduling'!activateTranscript	"There is known to be a Transcript open in the current project; activate it.  2/5/96 sw"	| itsController |	itsController := scheduledControllers detect:			[:controller | controller model == Transcript]		ifNone:			[^ self].	self activeController: itsController.	(activeController view labelDisplayBox			intersect: Display boundingBox) area < 200				ifTrue: [activeController move].	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:50'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'dtl 4/6/2005 23:20'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController preemptedProcess |	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	preemptedProcess == activeControllerProcess		ifFalse: [(suspendingList := preemptedProcess suspendingList) == nil				ifTrue: [preemptedProcess suspend]				ifFalse: [suspendingList remove: preemptedProcess.						preemptedProcess offList]].	(suspendingList := activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController :=		(Debugger			openInterrupt: labelString			onProcess: preemptedProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'RAA 7/7/2000 09:22'!resetActiveController	"When saving a morphic project whose parent is mvc, we need to set this up first"	activeController := nil.	activeControllerProcess := Processor activeProcess.! !!ControlManager methodsFor: 'scheduling'!searchForActiveController	"Find a scheduled controller that wants control and give control to it. If 	none wants control, then see if the System Menu has been requested."	| aController |	activeController := nil.	activeControllerProcess := Processor activeProcess.	self activeController: self nextActiveController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling' stamp: 'rbb 2/18/2005 10:52'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: (labels findTokens: Character cr) asArray).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!ControlManager methodsFor: 'private'!nextActiveController	"Answer the controller that would like control.  	If there was a click outside the active window, it's the top window	that now has the mouse, otherwise it's just the top window."	(newTopClicked notNil and: [newTopClicked])		ifTrue: [newTopClicked := false.				^ scheduledControllers 					detect: [:aController | aController isControlWanted]					ifNone: [scheduledControllers first]]		ifFalse: [^ scheduledControllers first]! !!Controller methodsFor: 'basic control sequence' stamp: 'RAA 1/30/2001 19:06'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime := Time millisecondClockValue.			wait := lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait <= MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							(Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime := Time millisecondClockValue.! !!Controller methodsFor: 'control defaults'!controlToNextLevel	"Pass control to the next control level (that is, to the Controller of a 	subView of the receiver's view) if possible. The receiver finds the 	subView (if any) of its view whose inset display box (see 	View|insetDisplayBox) contains the sensor's cursor point. The Controller 	of this subView is then given control if it answers true in response to 	the message Controller|isControlWanted."	| aView |	aView := view subViewWantingControl.	aView ~~ nil ifTrue: [aView controller startUp]! !!Controller methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	sensor := InputSensor default! !!Controller methodsFor: 'initialize-release'!release	"Breaks the cycle between the receiver and its view. It is usually not 	necessary to send release provided the receiver's view has been properly 	released independently."	model := nil.	view ~~ nil		ifTrue: 			[view controller: nil.			view := nil]! !!Controller methodsFor: 'model access'!model: aModel 	"Controller|model: and Controller|view: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: so that the receiver's model and view links can be set 	up by the view."	model := aModel! !!Controller methodsFor: 'sensor access'!sensor: aSensor	"Set the receiver's sensor to aSensor."	sensor := aSensor! !!Controller methodsFor: 'view access'!view: aView 	"Controller|view: and Controller|model: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: and the receiver's model and view links are set up 	automatically by the view."	view := aView! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse := milliseconds ifNotNil: [ milliseconds rounded ].! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'apb 2/15/2007 15:22'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002) beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!CurveFitter methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| pa pb k s p1 p2 p3 line |	line := Line new.	line form: self form.	collectionOfPoints size < 3 ifTrue: [self error: 'Curve must have three points'].	p1 := self firstPoint.	p2 := self secondPoint.	p3 := self thirdPoint.	s := Path new.	s add: p1.	pa := p2 - p1.	pb := p3 - p2.	k := 5 max: pa x abs + pa y abs + pb x abs + pb y abs // 20.	"k is a guess as to how many line segments to use to approximate 	the curve."	1 to: k do: 		[:i | 		s add: pa * i // k + p1 * (k - i) + (pb * (i - 1) // k + p2 * (i - 1)) // (k - 1)].	s add: p3.	1 to: s size - 1 do: 		[:i | 		line beginPoint: (s at: i).		line endPoint: (s at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!CurveFitter methodsFor: 'displaying' stamp: '6/9/97 10:16 di'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| transformedPath newCurveFitter |	transformedPath := aTransformation applyTo: self.	newCurveFitter := CurveFitter new.	newCurveFitter firstPoint: transformedPath firstPoint.	newCurveFitter secondPoint: transformedPath secondPoint.	newCurveFitter thirdPoint: transformedPath thirdPoint.	newCurveFitter form: self form.	newCurveFitter		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!CurveFitter class methodsFor: 'examples' stamp: '6/9/97 10:16 di'!example	"Designate three locations on the screen by clicking any button. The	curve determined by the points will be displayed with a long black form."	| aCurveFitter aForm |  	aForm := Form extent: 1@30.			"make a long thin Form for display "	aForm fillBlack.							"turn it black"	aCurveFitter := CurveFitter new.	aCurveFitter form: aForm.						"set the form for display"				"collect three Points and show them on the dispaly"	aCurveFitter firstPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter firstPoint.	aCurveFitter secondPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter secondPoint.	aCurveFitter thirdPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aCurveFitter thirdPoint.	aCurveFitter displayOn: Display					"display the CurveFitter"	"CurveFitter example"! !!CurveFitter class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 3.	newSelf add: 0@0.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!arguments	"Answer my arguments, initializing them to an empty collection if they're found to be nil."	^ arguments ifNil: [arguments := OrderedCollection new]! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!targets	"Answer my targets, initializing them to an empty collection if found to be nil"	^ targets ifNil: [targets := OrderedCollection new]! !!CustomMenu methodsFor: 'construction' stamp: 'dhhi 9/14/2000 22:39'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	aString ifNil: [^ self addLine].	s := String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.! !!CustomMenu methodsFor: 'construction'!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider := selections size.		dividers addLast: lastDivider].! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'yo 8/28/2002 22:34'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList findTokens: String cr]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sumim 2/10/2002 01:26'!initialize	labels := OrderedCollection new.	selections := OrderedCollection new.	dividers := OrderedCollection new.	lastDivider := 0.	targets := OrderedCollection new.	arguments := OrderedCollection new	! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title := aTitle! !!CustomMenu methodsFor: 'invocation' stamp: 'jm 11/17/97 16:54'!invokeOn: targetObject defaultSelection: defaultSelection	"Invoke the menu with the given default selection (i.e. one of my 'action' symbols). Answer the 'action' selector associated with the menu item chosen by the user or nil if none is chosen."	| sel |	sel := self startUp: defaultSelection.	sel = nil ifFalse: [		sel numArgs = 0			ifTrue: [^ targetObject perform: sel]			ifFalse: [^ targetObject perform: sel with: nil]].	^ nil! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 11/16/2002 23:45'!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector := self startUp) ifNotNil:		[anIndex := self selection.		recipient := ((targets := self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs == 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!CustomMenu methodsFor: 'private' stamp: 'sw 12/10/1999 11:21'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream := WriteStream on: (String new).	labels do: [:label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: MenuStyle defaultFont		lines: dividers! !!CustomMenu methodsFor: 'private' stamp: 'di 4/14/1999 21:28'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i := selections indexOf: action ifAbsent: [^ self].	marker ifNil: [self computeForm].	marker := marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection := i.! !!CustomMenu class methodsFor: 'example' stamp: 'sw 11/8/1999 17:27'!example	"CustomMenu example"	| menu |	menu := CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples"NB:  The following is equivalent to the above, but uses the compact #fromArray: consruct:	(CustomMenu fromArray:		#(	('apples'		apples)			('oranges'		oranges)			-			-			('peaches'		peaches)			-			('pears'			pears)			-))				startUp: #apples"! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!bypass	"Return my reference as is."	^self reference! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!forbidden	self error: 'Forbidden reference usage'! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:01'!include	"Return my expanded value."	^value ifNil: [SAXWarning signal: 'XML undefined entity ' , name printString]! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:06'!includedInLiteral	"Return my expanded value."	^self include! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!reference	"Return my reference as is."	^self class leadIn , self name , ';'! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/4/2002 19:40'!name	^name! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name _ aString asSymbol! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata	^ndata! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata _ aString! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:54'!value	^value! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value _ aString! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/16/2000 21:23'!registerIn: aParser	aParser entity: self name put: self! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 1/15/2002 15:08'!valueForContext: aContext	^self perform: (self class behaviorForContext: aContext)! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:14'!behaviorForContext: aContext	^self contextBehavior at: aContext! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:15'!contextBehavior	^contextBehavior! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'&'! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDEntityDeclaration class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 20:13'!name: aString value: aValueString	^self new		name: aString;		value: aValueString! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!includePE	"Return my expanded value."	^self include! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 23:21'!notRecognized	SAXMalformedException signal: 'Malformed entity.'! !!DTDParameterEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/28/2000 17:26'!registerIn: aParser	aParser parameterEntity: self name put: self! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!DTDParameterEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'%'! !!DataType methodsFor: '*eToys-tiles' stamp: 'sw 1/4/2005 00:45'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	"Answer, for classic tiles, an updating readout tile for a part with the receiver's type, with the given getter and setter"	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none #nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: getter;		target: aTarget;		growable: true;		minimumWidth: 24;		putSelector: actualSetter.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs == 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	^ aTile! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 4/13/2006 10:21'!asUTC	^ offset isZero		ifTrue: [self]		ifFalse: [self utcOffset: 0]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 00:55'!asDuration	"Answer the duration since midnight."	^ Duration seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o.! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 22:59'!normalize: i ticks: ticks base: base	| tick div quo rem |	tick := ticks at: i.	div := tick digitDiv: base neg: tick negative.	quo := (div at: 1) normalize.	rem := (div at: 2) normalize.	rem < 0 ifTrue: [ quo := quo - 1. rem := base + rem ].	ticks at: (i-1) put: ((ticks at: i-1) + quo).	ticks at: i put: rem! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 23:01'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	self normalize: 3 ticks: ticks base: NanosInSecond.	self normalize: 2 ticks: ticks base: SecondsInDay.	jdn	_ ticks at: 1.	seconds	_ ticks at: 2.	nanos := ticks at: 3.	offset := utcOffset! !!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 0!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!!DateAndTime class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 00:49'!clockPrecision	"One nanosecond precision"	^ Duration seconds: 0 nanoSeconds: 1! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'KLC 5/9/2008 20:13'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick _  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'gk 8/31/2006 01:00'!fromSeconds: seconds	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"	^ self basicNew ticks: (Array with: SqueakEpoch with: seconds with: 0) offset: self localOffset! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/11/2006 21:13'!millisecondClockValue	^ self clock millisecondClockValue! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'kph 12/9/2006 23:46'!totalSeconds	^ self clock totalSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 6/13/2007 23:07'!localOffset	"Answer the duration we are offset from UTC"	^ LocalOffset ifNil:[ LocalOffset := self localTimeZone offset ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 10/20/2007 13:56'!milliSecondsSinceMidnight		| msm msClock |		msClock := self millisecondClockValue. 	(msClock < LastMilliSeconds) 		ifTrue:[ "rolled over" MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[ msm := msClock + MilliSecondOffset. 	 (msm >= 86400000) ] 		whileTrue: [ "next day" 			LastTick := -1.			DaysSinceEpoch := DaysSinceEpoch + 1. 			MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	((LastTick = -1) and: [		(Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: 								(self clock totalSeconds)) days ~= DaysSinceEpoch ]) 		ifTrue: 				[  self initializeOffsets. 				 ^ self milliSecondsSinceMidnight ].		^msm! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/19/2006 15:01'!readFrom: aStream	| bc year month day hour minute second nanos offset buffer ch |	aStream peek = $- ifTrue: [ aStream next. bc _ -1] ifFalse: [bc _ 1].	year _ (aStream upTo: $-) asInteger * bc.	month _ (aStream upTo: $-) asInteger.	day _ (aStream upTo: $T) asInteger.	hour _ (aStream upTo: $:) asInteger. 	buffer _ '00:' copy. ch _ nil.	minute _ WriteStream on: buffer.	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ minute nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $: ].	minute _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '00.' copy.	second _ WriteStream on: buffer.	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch _ second nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $. ].	second _ ((ReadStream on: buffer) upTo: ch) asInteger.	buffer _ '000000000+' copy.	(ch = $.) ifTrue: [ 		nanos _ WriteStream on: buffer.		[ aStream atEnd | ((ch := aStream next) = $+) | (ch = $-) ]			whileFalse: [ nanos nextPut: ch. ].		(ch isNil or: [ch isDigit]) ifTrue: [ ch _ $+ ].	].	nanos _ buffer asInteger.	aStream atEnd		ifTrue: [ offset _ self localOffset ]		ifFalse:		 	[offset _ Duration fromString: (ch asString, '0:', aStream upToEnd).			(offset = self localOffset) ifTrue: [ offset _ self localOffset ]].	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond:  nanos		offset: offset.	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtMilliSeconds: milliSecondsSinceMidnight	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun.    "! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/11/2006 20:36'!todayAtNanoSeconds: nanoSecondsSinceMidnight	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'clock provider' stamp: 'kph 12/11/2006 20:14'!clock 	 "the provider of real time seconds/milliseconds."	^ ClockProvider ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/13/2007 23:05'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LocalOffset := nil.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true.! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 6/16/2007 06:51'!initializeOffsets 	| epochianSeconds secondsSinceMidnight nowSecs  |	  	LastTick := 0.  	nowSecs :=  self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue. 	epochianSeconds := Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: nowSecs.	DaysSinceEpoch := epochianSeconds days.	secondsSinceMidnight := (epochianSeconds - (Duration days: DaysSinceEpoch hours: 0 minutes: 0 seconds: 0)) asSeconds.  	MilliSecondOffset := (secondsSinceMidnight * 1000 - LastMilliSeconds).	LocalOffset := nil.  ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'kph 12/13/2006 21:46'!startUp: resuming 	resuming ifFalse: [^ self].		[ self initializeOffsets ] fork.	! !!DateAndTime class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone _ TimeZone default ]! !!DateAndTime class methodsFor: 'accessing' stamp: 'nk 3/30/2004 09:53'!localTimeZone: aTimeZone	"Set the local time zone"	"	DateAndTime localTimeZone: (TimeZone offset:  0 hours name: 'Universal Time' abbreviation: 'UTC').	DateAndTime localTimeZone: (TimeZone offset: -8 hours name: 'Pacific Standard Time' abbreviation: 'PST').	"	LocalTimeZone := aTimeZone! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'KLC 5/9/2008 20:37'!testPrecision	"Verify that the clock is returning a value with accuracy of better than 1 second.  For now it seems sufficient to get two values and verify they are not the same."	self		assert: (DateAndTime now ~= DateAndTime now)! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'kph 12/19/2006 15:04'!testReadFromself assert: ('-1199-01-05T20:33:14.321-05:00' asDateAndTime printString = '-1199-01-05T20:33:14.321-05:00').self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').self assert: (' 2002-05-16T17:20' asDateAndTime printString = '2002-05-16T17:20:00+00:00').self assert: ('2002-05-16T17:20:45' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34').self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00').self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3').  	 ! !!Debugger methodsFor: 'accessing' stamp: 'al 7/29/2004 14:37'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be  	updated. In this case, the retrieved information is the method of the  	selected context."	| selector classOfMethod category h ctxt originalClassOfMethod |	contextStackIndex = 0		ifTrue: [^ false].	self selectedContext isExecutingBlock		ifTrue: [h := self selectedContext finalBlockHome.			h				ifNil: [self inform: 'Method not found for block, can''t edit'.					^ false].			(self confirm: 'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: h]				ifFalse: [^ false]].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	selector == self selectedMessageName		ifFalse: [self inform: 'can''t change selector'.			^ false].	originalClassOfMethod := classOfMethod traitOrClassOfSelector: selector.	selector := originalClassOfMethod				compile: aText				classified: category				notifying: aController.	selector		ifNil: [^ false].	"compile cancelled"	contents := aText.	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext ifFalse: [		self inform: 'Method saved, but current context unchangedbecause of unwind error. Click OK to see error'.	] ifTrue: [		interruptedProcess			restartTopWith: (classOfMethod compiledMethodAt: selector);		 	stepToSendOrReturn.		contextVariablesInspector object: nil.		theMethodNode := Preferences browseWithPrettyPrint			ifTrue: [ctxt methodNodeFormattedAndDecorated: Preferences colorWhenPrettyPrinting]			ifFalse: [ctxt methodNode].		sourceMap := theMethodNode sourceMap.		tempNames := theMethodNode tempNames.	].	self resetContext: ctxt.	^ true! !!Debugger methodsFor: 'context stack menu' stamp: 'sd 11/20/2005 21:27'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window contentTop extentToUse |	self expandStack.	window := (PreDebugWindow labelled: label) model: self.	contentTop := 0.25.	extentToUse := 450 @ 156. "nice and wide to show plenty of the error msg"	window addMorph: (self buttonRowForPreDebugWindow: window)				frame: (0@0 corner: 1 @ contentTop).	Preferences eToyFriendly | messageString notNil		ifFalse:			[notifyPane := PluggableListMorph on: self list: #contextStackList				selected: #contextStackIndex changeSelected: #debugAt:				menu: nil keystroke: nil]		ifTrue:			[notifyPane := PluggableTextMorph on: self text: nil accept: nil				readSelection: nil menu: #debugProceedMenu:.			notifyPane editString: (self preDebugNotifierContentsFrom: messageString);				askBeforeDiscardingEdits: false].	window addMorph: notifyPane frame: (0@contentTop corner: 1@1).	"window deleteCloseBox.		chickened out by commenting the above line out, sw 8/14/2000 12:54"	window setBalloonTextForCloseBox.	^ window openInWorldExtent: extentToUse! !!Debugger methodsFor: 'initialize' stamp: 'ab 3/23/2005 14:03'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list _ #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')		('Tally'			tally				'time in milliseconds to execute')).	Preferences restartAlsoProceeds ifTrue:		[list _ list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!Debugger methodsFor: 'controls' stamp: 'md 2/24/2006 15:44'!addOptionalButtonsTo: window at: fractions plus: verticalOffset 	"Add button panes to the window. A row of custom	debugger-specific buttons (Proceed, Restart, etc.) is always	added, and if optionalButtons is in force, then the standard	code-tool buttons are also added. Answer the verticalOffset	plus the height added."	| delta buttons anOffset |	anOffset := (Preferences optionalButtons					and: [Preferences extraDebuggerButtons])				ifTrue: [super						addOptionalButtonsTo: window						at: fractions						plus: verticalOffset]				ifFalse: [verticalOffset].	delta := self defaultButtonPaneHeight.	buttons := self customButtonRow.	buttons color: Color white; borderWidth: 0.	window		addMorph: buttons		fullFrame: (LayoutFrame				fractions: fractions				offsets: (0 @ anOffset corner: 0 @ (anOffset + delta - 1))).	^ anOffset + delta! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getSelectedText	| m interval text |	m := self getTextMorphWithSelection.	interval := m selectionInterval.	text := m text.	^ text copyFrom: interval first to: interval last	! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 14:17'!getTextMorphWithSelection	"This is extremely ugly... We I need to get a reference of the code pane, which is not easily accessible"	^ (self dependents select: [:m| m isKindOf: PluggableTextMorph]) 		detect: [:m| m selectionInterval first > 1] ifNone: [nil]! !!Debugger methodsFor: 'tally support' stamp: 'ab 5/22/2007 13:35'!tally	self getTextMorphWithSelection ifNotNilDo: [:o| o tallyIt] ifNil: [Beeper beep]! !!Delay methodsFor: 'delaying' stamp: 'ar 8/30/2007 19:32'!wait	"Schedule this Delay, then wait on its semaphore. The current process will be suspended for the amount of time specified when this Delay was created."	self schedule.	[delaySemaphore wait] ifCurtailed:[self unschedule].! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn	"Answer whether this delay is currently scheduled, e.g., being waited on"	^beingWaitedOn! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 21:49'!beingWaitedOn: aBool	"Indicate whether this delay is currently scheduled, e.g., being waited on"	beingWaitedOn := aBool! !!Delay methodsFor: 'public' stamp: 'ar 7/10/2007 20:56'!delayDuration	^delayDuration! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:24'!activate	"Private!! Make the receiver the Delay to be awoken when the next timer interrupt occurs. This method should only be called from a block protected by the AccessProtect semaphore."	TimerEventLoop ifNotNil:[^nil].	ActiveDelay := self.	ActiveDelayStartTime := Time millisecondClockValue.	ActiveDelayStartTime > resumptionTime ifTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.			ActiveDelayStartTime := nil.		] ifFalse:[SuspendedDelays removeFirst activate].	] ifFalse:[		TimingSemaphore initSignals.		Delay primSignal: TimingSemaphore atMilliseconds: resumptionTime.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55'!schedule	"Private!! Schedule this Delay, but return immediately rather than waiting. The receiver's semaphore will be signalled when its delay duration has elapsed."	beingWaitedOn ifTrue: [self error: 'This Delay has already been scheduled.'].	TimerEventLoop ifNotNil:[^self scheduleEvent].	AccessProtect critical: [		beingWaitedOn := true.		resumptionTime := Time millisecondClockValue + delayDuration.		ActiveDelay == nil			ifTrue: [self activate]			ifFalse: [				resumptionTime < ActiveDelay resumptionTime					ifTrue: [						SuspendedDelays add: ActiveDelay.						self activate]					ifFalse: [SuspendedDelays add: self]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 22:33'!scheduleEvent	"Schedule this delay"	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:55'!unschedule	"Unschedule this Delay. Do nothing if it wasn't scheduled."	| done |	TimerEventLoop ifNotNil:[^self unscheduleEvent].	AccessProtect critical: [		done := false.		[done] whileFalse:			[SuspendedDelays remove: self ifAbsent: [done := true]].		ActiveDelay == self ifTrue: [			SuspendedDelays isEmpty				ifTrue: [					ActiveDelay := nil.					ActiveDelayStartTime := nil]				ifFalse: [					SuspendedDelays removeFirst activate]]].! !!Delay methodsFor: 'private' stamp: 'ar 7/10/2007 21:56'!unscheduleEvent	AccessProtect critical:[		FinishedDelay := self.		TimingSemaphore signal.	].! !!Delay commentStamp: 'stephaneducasse 10/1/2005 21:07' prior: 0!I am the main way that a process may pause for some amount of time.  The simplest usage is like this:	(Delay forSeconds: 5) wait.An instance of Delay responds to the message 'wait' by suspending the caller's process for a certain amount of time. The duration of the pause is specified when the Delay is created with the message forMilliseconds: or forSeconds:. A Delay can be used again when the current wait has finished. For example, a clock process might repeatedly wait on a one-second Delay.The maximum delay is (SmallInteger maxVal // 2) milliseconds, or about six days. A delay in progress when an image snapshot is saved is resumed when the snapshot is re-started. Delays work across millisecond clock roll-overs.For a more complex example, see  #testDelayOf:for:rect: .A word of advice:This is THE highest priority code which is run in Squeak, in other words it is time-critical. The speed of this code is critical for accurate responses, it is critical for network services, it affects every last part of the system.In short: Don't fix it if it ain't broken!! This code isn't supposed to be beautiful, it's supposed to be fast!! The reason for duplicating code is to make it fast. The reason for not using ifNil:[]ifNotNil:[] is that the compiler may not inline those. Since the effect of changes are VERY hard to predict it is best to leave things as they are for now unless there is an actual need to change anything!!Delay class methodsFor: 'timer process' stamp: 'ar 8/24/2007 12:36'!handleTimerEvent	"Handle a timer event; which can be either:		- a schedule request (ScheduledDelay notNil)		- an unschedule request (FinishedDelay notNil)		- a timer signal (not explicitly specified)	We check for timer expiry every time we get a signal."	| nowTick nextTick |	"Wait until there is work to do."	TimingSemaphore wait.	"Process any schedule requests"	ScheduledDelay ifNotNil:[		"Schedule the given delay"		self scheduleDelay: ScheduledDelay.		ScheduledDelay := nil.	].	"Process any unschedule requests"	FinishedDelay ifNotNil:[		self unscheduleDelay: FinishedDelay.		FinishedDelay := nil.	].	"Check for clock wrap-around."	nowTick := Time millisecondClockValue.	nowTick < ActiveDelayStartTime ifTrue: [		"clock wrapped"		self saveResumptionTimes.		self restoreResumptionTimes.	].	ActiveDelayStartTime := nowTick.	"Signal any expired delays"	[ActiveDelay notNil and:[nowTick >= ActiveDelay resumptionTime]] whileTrue:[		ActiveDelay signalWaitingProcess.		SuspendedDelays isEmpty 			ifTrue: [ActiveDelay := nil] 			ifFalse:[ActiveDelay := SuspendedDelays removeFirst].	].	"And signal when the next request is due. We sleep at most 1sec here	as a soft busy-loop so that we don't accidentally miss signals."	nextTick := nowTick + 1000.	ActiveDelay ifNotNil:[nextTick := nextTick min: ActiveDelay resumptionTime].	nextTick := nextTick min: SmallInteger maxVal.	"Since we have processed all outstanding requests, reset the timing semaphore so	that only new work will wake us up again. Do this RIGHT BEFORE setting the next	wakeup call from the VM because it is only signaled once so we mustn't miss it."	TimingSemaphore initSignals.	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.	"This last test is necessary for the obscure case that the msecs clock rolls over	after nowTick has been computed (unlikely but not impossible). In this case we'd	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets	scheduled (which may not be any time soon). In any case, since handling the	condition is easy, let's just deal with it"	Time millisecondClockValue < nowTick ifTrue:[TimingSemaphore signal]. "retry"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 09:04'!runTimerEventLoop	"Run the timer event loop."	[		[RunTimerEventLoop] whileTrue: [self handleTimerEvent]	] on: Error do:[:ex|		"Clear out the process so it does't get killed"		TimerEventLoop := nil.		"Launch the old-style interrupt watcher"		self startTimerInterruptWatcher.		"And pass the exception on"		ex pass.	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!scheduleDelay: aDelay	"Private. Schedule this Delay."	aDelay beingWaitedOn: true.	ActiveDelay ifNil:[		ActiveDelay := aDelay	] ifNotNil:[		aDelay resumptionTime < ActiveDelay resumptionTime ifTrue:[			SuspendedDelays add: ActiveDelay.			ActiveDelay := aDelay.		] ifFalse: [SuspendedDelays add: aDelay].	].! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/11/2007 10:18'!startTimerEventLoop	"Start the timer event loop"	"Delay startTimerEventLoop"	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	AccessProtect := Semaphore forMutualExclusion.	ActiveDelayStartTime := Time millisecondClockValue.	SuspendedDelays := 		Heap withAll: (SuspendedDelays ifNil:[#()])			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	TimingSemaphore := Semaphore new.	RunTimerEventLoop := true.	TimerEventLoop := [self runTimerEventLoop] newProcess.	TimerEventLoop priority: Processor timingPriority.	TimerEventLoop resume.	TimingSemaphore signal. "get going"! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 22:32'!startTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	| p |	self stopTimerEventLoop.	self stopTimerInterruptWatcher.	TimingSemaphore := Semaphore new.	AccessProtect := Semaphore forMutualExclusion.	SuspendedDelays := 		SortedCollection sortBlock: 			[:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	ActiveDelay := nil.	p := [self timerInterruptWatcher] newProcess.	p priority: Processor timingPriority.	p resume.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:26'!stopTimerEventLoop	"Stop the timer event loop"	RunTimerEventLoop := false.	TimingSemaphore signal.	TimerEventLoop := nil.! !!Delay class methodsFor: 'timer process' stamp: 'ar 7/10/2007 21:32'!stopTimerInterruptWatcher	"Reset the class variables that keep track of active Delays and re-start the timer interrupt watcher process. Any currently scheduled delays are forgotten."	"Delay startTimerInterruptWatcher"	self primSignal: nil atMilliseconds: 0.	TimingSemaphore ifNotNil:[TimingSemaphore terminateProcess].! !!Delay class methodsFor: 'timer process' stamp: 'ar 8/30/2007 19:59'!unscheduleDelay: aDelay	"Private. Unschedule this Delay."	aDelay beingWaitedOn ifFalse:[^self].	ActiveDelay == aDelay ifTrue: [		SuspendedDelays isEmpty ifTrue:[			ActiveDelay := nil.		] ifFalse: [			ActiveDelay := SuspendedDelays removeFirst.		]	] ifFalse:[		SuspendedDelays remove: aDelay ifAbsent: [].	].	aDelay beingWaitedOn: false.! !!Delay class methodsFor: 'class initialization' stamp: 'ar 7/11/2007 18:16'!initialize	"Delay initialize"	self startTimerEventLoop.! !!Dictionary methodsFor: 'accessing'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	nil == assoc ifTrue: [ ^ aBlock value ].	^ assoc! !!Dictionary methodsFor: 'accessing' stamp: 'tk 4/9/1999 10:22'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	| existing |	^ self associationAt: aKey ifAbsent: [		(Undeclared includesKey: aKey)			ifTrue: 				[existing := Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!Dictionary methodsFor: 'accessing' stamp: 'dvf 9/17/2003 16:03'!associations	"Answer a Collection containing the receiver's associations."	| out |	out := WriteStream on: (Array new: self size).	self associationsDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:59'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc := array at: (self findElementOrNil: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'accessing' stamp: 'di 3/7/2001 15:29'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	v isInMemory ifFalse: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'jm 5/15/1998 07:20'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:00'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!Dictionary methodsFor: 'accessing'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Dictionary methodsFor: 'accessing' stamp: 'sma 6/18/2000 12:56'!keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys := SortedCollection new: self size.	sortedKeys sortBlock:		[:x :y |  "Should really be use <obj, string, num> compareSafely..."		((x isString and: [y isString])			or: [x isNumber and: [y isNumber]])			ifTrue: [x < y]			ifFalse: [x class == y class				ifTrue: [x printString < y printString]				ifFalse: [x class name < y class name]]].	self keysDo: [:each | sortedKeys addLast: each].	^ sortedKeys reSort! !!Dictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 07:28'!values	"Answer a Collection containing the receiver's values."	| out |	out := WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'adding'!add: anAssociation	| index element |	index := self findElementOrNil: anAssociation key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Dictionary methodsFor: 'enumerating' stamp: 'dtl 2/17/2003 09:40'!associationsSelect: aBlock 	"Evaluate aBlock with each of my associations as the argument. Collect	into a new dictionary, only those associations for which aBlock evaluates	to true."	| newCollection |	newCollection := self species new.	self associationsDo: 		[:each | 		(aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Dictionary methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Dictionary methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a	new dictionary, only those associations for which aBlock evaluates to	true."	| newCollection |	newCollection := self species new.	self associationsDo: 		[:each | 		(aBlock value: each value) ifTrue: [newCollection add: each]].	^newCollection! !!Dictionary methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet := true.	self associationsDo: 			[:each | 			noneYet				ifTrue: [noneYet := false]				ifFalse: [aStream nextPut: $;].			aStream nextPutAll: ' add: '.			aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Dictionary methodsFor: 'removing' stamp: 'di 4/4/2000 11:47'!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals := OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc key value: assoc value)			ifTrue: [removals add: assoc key]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'removing'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index assoc |	index := self findElementOrNil: key.	assoc := array at: index.	assoc == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ assoc value! !!Dictionary methodsFor: 'testing'!occurrencesOf: anObject 	"Answer how many of the receiver's elements are equal to anObject."	| count |	count := 0.	self do: [:each | anObject = each ifTrue: [count := count + 1]].	^count! !!Dictionary methodsFor: 'user interface' stamp: 'hg 10/3/2001 20:47'!explorerContents	| contents |		contents := OrderedCollection new.	self keysSortedSafely do: [:key |		contents add: (ObjectExplorerWrapper			with: (self at: key)			name: (key printString contractTo: 32)			model: self)].	^contents! !!Dictionary methodsFor: 'private'!keyAt: index	"May be overridden by subclasses so that fixCollisions will work"	| assn |	assn := array at: index.	assn == nil ifTrue: [^ nil]				ifFalse: [^ assn key]! !!Dictionary methodsFor: 'private'!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.  9/7/96 tk"	array at: (self findElementOrNil: anObject key) put: anObject.	tally := tally + 1! !!Dictionary methodsFor: 'private'!rehash	"Smalltalk rehash."	| newSelf |	newSelf := self species new: self size.	self associationsDo: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!Dictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:42'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary class methodsFor: 'instance creation'!newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}	{1->#a. 2->#b. 3->#c} as: NewDictionary	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}	{1->#a. 2->#b. 1->#c} as: NewDictionary"! !!DisplayTextView methodsFor: 'accessing'!centered	centered := true.	self centerText! !!DisplayTextView methodsFor: 'accessing'!fillColor: aForm 	"Set aForm to be the mask used when displaying the receiver's model."	mask := aForm! !!DisplayTextView methodsFor: 'accessing'!rule: anInteger 	"Set anInteger to be the rule used when displaying the receiver's model."	rule := anInteger! !!DisplayTextView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	centered := false! !!DisplayTextView methodsFor: 'model access'!model: aDisplayText 	"Refer to the comment in View|model:."	super model: aDisplayText.	editParagraph := model asParagraph.	self centerText! !!DisplayTextView methodsFor: 'private'!positionText	| box |	box := (self displayBox insetBy: 6@6) origin extent: editParagraph boundingBox extent.	editParagraph wrappingBox: box clippingBox: box.	self centerText! !!DisplayTextView class methodsFor: 'examples'!example2		"Create a standarad system view with two parts, one editable, the other not."	| topView aDisplayTextView |	topView := StandardSystemView new.	topView label: 'Text Editor'.	aDisplayTextView := self new model: 'test string label' asDisplayText.	aDisplayTextView controller: NoController new.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	topView addSubView: aDisplayTextView.	aDisplayTextView := self new model: 'test string' asDisplayText.	aDisplayTextView window: (0 @ 0 extent: 100 @ 100).	aDisplayTextView borderWidth: 2.	topView		addSubView: aDisplayTextView		align: aDisplayTextView viewport topLeft		with: topView lastSubView viewport topRight.	topView controller open	"DisplayTextView example2"! !!DisplayTextView class methodsFor: 'examples'!example3		"Create a passive view of some text on the screen."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 2.	view display.	view release	"DisplayTextView example3"! !!DisplayTextView class methodsFor: 'examples'!example4		"Create four passive views of some text on the screen with fat borders."	| view |	view:= self new model: 'this is a test of one lineand the second line' asDisplayText.	view translateBy: 100@100.		view borderWidth: 5.	view display.	3 timesRepeat: [view translateBy: 100@100. view display].	view release	"DisplayTextView example4"! !!DrawErrorMorph methodsFor: 'drawing' stamp: 'ar 4/2/1999 12:13'!drawOn: aCanvas	aCanvas error:'DrawErrorMorph drawOn: invoked'! !!DrawErrorMorph methodsFor: 'printing' stamp: 'ar 4/2/1999 12:15'!printOn: aStream	"Indirectly invokes an error during stepping in an Inspector"	aStream error:'DrawErrorMorph>>printOn: invoked'! !!DrawErrorMorph commentStamp: '<historical>' prior: 0!This morph simply invokes errors during drawing and stepping.!!Duration methodsFor: 'ansi protocol' stamp: 'gk 8/30/2006 23:42'!days	"Answer the number of days the receiver represents."	^ seconds quo: SecondsInDay! !!Duration methodsFor: 'ansi protocol' stamp: 'KLC 5/12/2008 13:42'!seconds	"Answer the number of seconds the receiver represents."	^seconds rem: SecondsInMinute! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 4/13/2006 10:20'!isZero	^ seconds = 0 and: [ nanos = 0 ]! !!Duration methodsFor: 'private' stamp: 'gk 8/31/2006 01:33'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Duration class"	seconds _ secondCount.	nanos _ nanoCount rounded! !!Duration methodsFor: 'private' stamp: 'gk 8/30/2006 23:41'!ticks	"Answer an array {days. seconds. nanoSeconds}. Used by DateAndTime and Time."	| days |	days _ self days.	^ Array 		with: days		with: seconds - (days * SecondsInDay)		with: nanos! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 01:09'!days: days hours: hours minutes: minutes seconds: seconds	^ self days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/30/2006 23:18'!days: days seconds: seconds	^ self basicNew seconds: days * SecondsInDay + seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 01:34'!seconds: seconds	^ self seconds: seconds nanoSeconds: 0! !!Duration class methodsFor: 'ansi protocol' stamp: 'gk 8/31/2006 00:09'!zero	^ self basicNew seconds: 0 nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:25'!days: aNumber	^ self seconds: aNumber * SecondsInDay nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:26'!days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos	 	^ self seconds: ((days * SecondsInDay) 						+ (hours * SecondsInHour)							+ (minutes * SecondsInMinute) 								+ seconds)		nanoSeconds: nanos! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:07'!fromString: aString	^ self readFrom: (ReadStream on: aString)! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:26'!hours: aNumber	^ self seconds: aNumber * SecondsInHour nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:35'!milliSeconds: milliCount	"Since seconds is 0 we can call the instance directly."	^ self basicNew seconds: 0 nanoSeconds: milliCount * NanosInMillisecond! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:27'!minutes: aNumber	^ self seconds: aNumber * SecondsInMinute nanoSeconds: 0! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:30'!nanoSeconds: nanos	"This method is slow. If you have nanos less than 10^6 you should use #seconds:nanoSeconds: instead."	| quo |	quo _ nanos quo: NanosInSecond.	^ self basicNew		seconds: quo		nanoSeconds: nanos - (quo * NanosInSecond)! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:32'!seconds: seconds nanoSeconds: nanos	^ self basicNew		seconds: seconds truncated		nanoSeconds: seconds fractionPart * NanosInSecond + nanos! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 23:20'!weeks: aNumber	^ self days: (aNumber * 7) seconds: 0! !!DurationTest methodsFor: 'testing' stamp: 'KLC 5/12/2008 13:41'!testSeconds	self assert: aDuration seconds =   4.	self assert: (Duration  nanoSeconds: 2) seconds = 0.	self assert: (Duration nanoSeconds: 999999999) seconds = 0.	self assert: (Duration nanoSeconds: 1000000001) seconds = 1.	self assert: (Duration  seconds: 2) seconds = 2.		self assert: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = 4.	self deny: (Duration  days: 1 hours: 2 minutes: 3 seconds:4) seconds = (1*24*60*60+(2*60*60)+(3*60)+4).	! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	self field: aSymbol is: f.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 05:57'!commResult: anArrayOfAssociations	| aDictionary |	aDictionary := Dictionary new.	anArrayOfAssociations do: [ :each | aDictionary add: each].	resultQueue nextPut: aDictionary! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:33'!editEvent: anEvent for: aMorph	| answer |	(aMorph bounds containsPoint: anEvent cursorPoint) ifFalse: [^self].	answer := FillInTheBlankMorph		request: 'Enter a new ',aMorph balloonText		initialAnswer: aMorph contents.	answer isEmptyOrNil ifTrue: [^self].	aMorph contents: answer! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!flashIndicator: aSymbol	| now |	now := Time millisecondClockValue.	(LastFlashTime notNil and: [(Time millisecondClockValue - now) abs < 500]) ifTrue: [^self].	LastFlashTime := now.	self trulyFlashIndicator: aSymbol! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 16:42'!handleResult: aDictionary	| m |	aDictionary at: #commFlash ifPresent: [ :ignore | ^self flashIndicator: #communicating].	self resetIndicator: #communicating.	m := aDictionary at: #message ifAbsent: ['unknown message'].	m = 'OK' ifTrue: [^self].	self reportError: m! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 17:32'!indicatorFieldNamed: aSymbol color: aColor help: helpString	| f col |	f := EllipseMorph new		extent: 10@10;		color: aColor;		setBalloonText: helpString.	self field: aSymbol is: f.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/9/2000 08:18'!resetIndicator: aSymbol	| indicator firstColor |	indicator := fields at: aSymbol ifAbsent: [^self].	firstColor := indicator 		valueOfProperty: #firstColor		ifAbsent: [^self].	indicator color: firstColor.	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/8/2000 18:35'!textEntryFieldNamed: aSymbol with: aString help: helpString	| f col |	f := (StringMorph new contents: aString)		setBalloonText: helpString;		on: #mouseUp send: #editEvent:for: to: self.	self field: aSymbol is: f.	col := (self inAColumn: {f}) color: Color white; hResizing: #shrinkWrap.	^col! !!EToyCommunicatorMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 10:05'!trulyFlashIndicator: aSymbol	| indicator firstColor |	indicator := fields at: aSymbol ifAbsent: [^self].	firstColor := indicator 		valueOfProperty: #firstColor		ifAbsent: [			indicator setProperty: #firstColor toValue: indicator color.			indicator color		].	indicator color: (indicator color = firstColor ifTrue: [Color white] ifFalse: [firstColor]).	self world displayWorldSafely.! !!EToyCommunicatorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:32'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;	 hResizing: #shrinkWrap.	resultQueue := SharedQueue new.	fields := Dictionary new.	self useRoundedCorners! !!EToyCommunicatorMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/10/2000 10:14'!step	| state |	[resultQueue isEmpty] whileFalse: [		self handleResult: resultQueue next	].	(state := self valueOfProperty: #flashingState ifAbsent: [0]) > 0 ifTrue: [		self borderColor: (			(self valueOfProperty: #flashingColors ifAbsent: [{Color green. Color red}]) atWrap: state		).		self setProperty: #flashingState toValue: state + 1	].! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 7/17/2000 16:13'!instanceReport	"for cleaning up Alan's demo""EToySenderMorph instanceReport"	| answer resp |	Smalltalk garbageCollect.	answer := self allInstances collect: [ :each |		{			each.			[each ipAddress] on: Error do: [ 'no ipAddress'].			each owner 					ifNil: ['* no owner *'] 					ifNotNil: [each owner innocuousName,' ',each owner printString].			each world ifNil: ['-----no project-----'] ifNotNil: [each world project name].		}	].	resp := (PopUpMenu labels: 'IP Address\Project\Owner' withCRs) startUpWithCaption: 					'Sorted by'.	resp = 1 ifTrue: [		^(answer asSortedCollection: [ :a :b | a second <= b second]) asArray explore	].	resp = 2 ifTrue: [		^(answer asSortedCollection: [ :a :b | a fourth <= b fourth]) asArray explore	].	resp = 3 ifTrue: [		^(answer asSortedCollection: [ :a :b | a third <= b third]) asArray explore	].	answer explore! !!EToyGenericDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:54'!initialize	"initialize the state of the receiver"super initialize.""	namedFields := Dictionary new.		self rebuild! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:57'!genericMenu: aMenu	| menu |	currentSelection ifNil: [		aMenu add: '*nothing selected*' target: self selector: #yourself.		^aMenu	].	menu := DumberMenuMorph new defaultTarget: self.	menu 		add: 'expand all below me' target: self selector: #expandAllBelow;		add: 'addChild' target: self selector: #addChild;		add: 'delete' target: self  selector: #deleteSelectedItem.	^ menu! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 10:36'!inAWindow	| window  |	window := (SystemWindow labelled: 'HText') model: self.	window 		addMorph: self notInAWindow		frame: (0@0 corner: 1@1).     ^ window! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:43'!notInAWindow	| listMorph |	(listMorph := EToyHierarchicalTextMorph 		on: self		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyHierarchicalTextGizmo methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 00:40'!topNode: aTextNode	topNode := aTextNode! !!EToyHierarchicalTextMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 02:08'!adjustSubmorphPositions	| p h w |	p := 0@0.	w := self width.	scroller submorphsDo: [ :each |		h := each position: p andWidth: w.		p := p + (0@h)	].	self 		changed;		layoutChanged;		setScrollDeltas.! !!EToyHierarchicalTextMorph methodsFor: 'geometry' stamp: 'RAA 7/30/2000 01:50'!extent: aPoint	| wasDifferent |	wasDifferent := self extent ~= aPoint.	super extent: aPoint.	wasDifferent ifTrue: [self adjustSubmorphPositions].! !!EToyHierarchicalTextMorph methodsFor: 'selection' stamp: 'RAA 7/30/2000 10:05'!selectedMorph: aMorph	selectedMorph == aMorph ifTrue: [^self].	self unhighlightSelection.	selectedMorph := aMorph.	self highlightSelection! !!EToyHierarchicalTextMorph class methodsFor: 'instance creation' stamp: 'RAA 8/8/2000 14:34'!new	| listMorph model |	model := EToyHierarchicalTextGizmo new 		topNode: EToyTextNode newNode.	(listMorph := EToyHierarchicalTextMorph 		on: model		list: #getList		selected: #getCurrentSelection		changeSelected: #noteNewSelection:		menu: #genericMenu:		keystroke: nil).	listMorph autoDeselect: false.     ^ listMorph! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'ar 2/23/2001 20:56'!copyOutDetails	| newDetails |	newDetails := Dictionary new.	self fieldToDetailsMappings do: [ :each |		namedFields at: each first ifPresent: [ :field |			newDetails at: each second put: field contents string		].	].	namedFields at: 'projectname' ifPresent: [ :field |		newDetails at: 'projectname' put: field contents string withBlanksTrimmed.	].	^newDetails! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 12:45'!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	projectDetails := theProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new]! !!EToyProjectDetailsMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 11:08'!projectDetails: aDictionary	projectDetails := aDictionary.! !!EToyProjectDetailsMorph methodsFor: 'initialization' stamp: 'dgd 11/3/2004 17:55'!rebuild	| bottomButtons |	self removeAllMorphs.	self addARow: {		self			lockedString: 'Please describe this project' translated			font: Preferences standardEToysTitleFont.	}.	self addARow: {self space }.	self addARow: {		self rightLockedString: 'Name:' translated.		self inAColumnForText: {self fieldForProjectName}	}.	self expandedFormat ifTrue: [		self fieldToDetailsMappings do: [ :each |			self addARow: {				self rightLockedString: each third translated.				self inAColumnForText: {(self genericTextFieldNamed: each first) height: each fourth}			}.		].	].	self addARow: {self space }.	bottomButtons := self expandedFormat		ifTrue: [ { self okButton. self cancelButton } ]		ifFalse: [ { self okButton. self expandButton. self cancelButton } ].	self addARow: bottomButtons.	self fillInDetails.! !!EToyProjectDetailsMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 15:52'!getFullInfoFor: aProject ifValid: aBlock expandedFormat: expandedFormat	| me |	(me := self basicNew)		expandedFormat: expandedFormat;		project: aProject		actionBlock: [ :x | 			aProject world setProperty: #ProjectDetails toValue: x.			x at: 'projectname' ifPresent: [ :newName | 				aProject renameTo: newName.			].			me delete.			aBlock value.		];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 9/28/2000 13:53'!closeMyFlapIfAny	| myFlap allTabs myTab myWorld |	myWorld := self world.	myFlap := self nearestOwnerThat: [ :each | each isFlap].	myFlap ifNil: [^self].	allTabs := myWorld submorphs select: [ :each | each isFlapTab].	myTab := allTabs detect: [ :each | each referent == myFlap] ifNone: [^self].	myTab hideFlap.	myWorld displayWorldSafely.	! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/16/2000 12:02'!jumpToProject	| selection |	selection := (Project buildJumpToMenu: CustomMenu new) startUp.	self closeMyFlapIfAny.	Project jumpToSelection: selection! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/27/2000 22:47'!mouseMove: evt in: aMorph	| start tuple project url pvm |	start := aMorph valueOfProperty: #mouseDownPoint ifAbsent: [^self].	(start dist: evt cursorPoint) abs < 5 ifTrue: [^self].	aMorph removeProperty: #mouseDownPoint.	evt hand hasSubmorphs ifTrue: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^self].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [		^evt hand attachMorph: (ProjectViewMorph on: project).	].	url := tuple third.	url isEmptyOrNil ifTrue: [^self].	pvm := ProjectViewMorph new.	pvm		project: (DiskProxy global: #Project selector: #namedUrl: args: {url});		lastProjectThumbnail: tuple second.	evt hand attachMorph: pvm.! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!mouseUp: evt in: aMorph	| tuple project url |	(aMorph boundsInWorld containsPoint: evt cursorPoint) ifFalse: [^self].	tuple := aMorph valueOfProperty: #projectParametersTuple ifAbsent: [^Beeper beep].	project := tuple fourth first.	(project notNil and: [project world notNil]) ifTrue: [self closeMyFlapIfAny. ^project enter].	url := tuple third.	url isEmptyOrNil ifTrue: [^Beeper beep].	self closeMyFlapIfAny.	ProjectLoading thumbnailFromUrl: url."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'dgd 9/20/2003 18:52'!rebuild	| history r1 |	history := ProjectHistory currentHistory mostRecentCopy.	changeCounter := ProjectHistory changeCounter.	self removeAllMorphs.	self rubberBandCells: false. "enable growing"	r1 := self addARow: {		self inAColumn: {			StringMorph new contents: 'Jump...' translated; lock.		}.	}.	r1 on: #mouseUp send: #jumpToProject to: self.	history do: [ :each |		(			self addARow: {				(self inAColumn: {					StretchyImageMorph new form: each second; minWidth: 35; minHeight: 35; lock				}) vResizing: #spaceFill.				self inAColumn: {					StringMorph new contents: each first; lock.					"StringMorph new contents: each third; lock."				}.			}		)			color: Color paleYellow;			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			on: #mouseUp send: #mouseUp:in: to: self;			on: #mouseDown send: #mouseDown:in: to: self;			on: #mouseMove send: #mouseMove:in: to: self;			on: #mouseLeave send: #mouseLeave:in: to: self;			setProperty: #projectParametersTuple toValue: each;			setBalloonText: (each third isEmptyOrNil ifTrue: ['not saved'] ifFalse: [each third])	]."---	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.---"! !!EToyProjectQueryMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:18'!project: ignored actionBlock: aBlock	actionBlock := aBlock.	projectDetails := Dictionary new.! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'tak 3/15/2005 16:37'!onServer: aProjectServer	"EToyProjectQueryMorph onServer: SuperSwikiServer testOnlySuperSwiki"	| criteria clean |	(self basicNew)		project: nil		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty					ifFalse: [criteria add: k,': *',clean,'*']].			aProjectServer queryProjectsAndShow: criteria];		initialize;		becomeModal;		openCenteredInWorld! !!EToyProjectQueryMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 10/18/2000 12:34'!test1: aProject"EToyProjectQueryMorph test1: nil"	| criteria clean |	(self basicNew)		project: aProject		actionBlock: [ :x | 			criteria := OrderedCollection new.			x keysAndValuesDo: [ :k :v |				(clean := v withBlanksTrimmed) isEmpty ifFalse: [					criteria add: k,': *',clean,'*'				].			].			SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow: criteria		];		initialize;		openCenteredInWorld! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:25'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString translated font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString translated.	col := (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'yo 2/23/2005 17:25'!fieldForProjectName	| tm |	tm := self genericTextFieldNamed: 'projectname'.	tm crAction: (MessageSend receiver: self selector: #doOK).	tm setBalloonText: 'Pick a name 24 characters or less and avoid the following characters: : < > | / \ ? * " .' translated.	^tm	! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/12/2000 13:55'!project: aProject actionBlock: aBlock	theProject := aProject.	actionBlock := aBlock.	(namedFields at: 'projectname') contentsWrapped: theProject name.! !!EToyProjectRenamerMorph methodsFor: 'as yet unclassified' stamp: 'pk 10/17/2006 09:39'!validateTheProjectName	| proposed |	proposed _ (namedFields at: 'projectname') contents string withBlanksTrimmed.	proposed isEmpty ifTrue: [		self inform: 'I do need a name for the project' translated.		^false	].	proposed size > 24 ifTrue: [		self inform: 'Please make the name 24 characters or less' translated.		^false	].	(Project isBadNameForStoring: proposed) ifTrue: [		self inform: 'Please remove any funny characters from the name' translated.		^false	].	proposed = theProject name ifTrue: [^true].	(ChangesOrganizer changeSetNamed: proposed) ifNotNil: [		Utilities inform: 'Sorry that name is already used' translated.		^false	].	^true! !!EToySystem class methodsFor: 'development support' stamp: 'sd 5/11/2003 22:13'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream := ReferenceStream fileNamed: 'JanForms'.	newFormDict := aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Imports default importImage: assoc value named: assoc key]! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:05'!addNewChildAfter: anotherOrNilOrZero	| where newNode |	anotherOrNilOrZero == 0 ifTrue: [		newNode := EToyTextNode newNode.		children := {newNode} asOrderedCollection,children.		^newNode	].	where := children indexOf: anotherOrNilOrZero ifAbsent: [children size].	children add: (newNode := EToyTextNode newNode) afterIndex: where.	^newNode! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 10:33'!firstDisplayedOnLevel: level	firstDisplay := false.	text addAttribute: (TextFontChange fontNumber: ((5 - level) max: 1)).! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'RAA 7/31/2000 09:53'!showInOpenedState	| answer |	answer := self valueOfProperty: #showInOpenedState ifAbsent: [false].	self removeProperty: #showInOpenedState.	^answer! !!EToyTextNode methodsFor: 'initialization' stamp: 'RAA 7/30/2000 17:09'!initialize	| newStyle |	super initialize.	firstDisplay := true.	children := OrderedCollection new.	(newStyle := TextStyle named: #Palatino) ifNotNil: [		textStyle := newStyle copy defaultFontIndex: 2	].! !!EToyTextNodeWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 11:51'!parentWrapper: anotherWrapper	parentWrapper := anotherWrapper! !!EToyVocabulary methodsFor: 'initialization' stamp: 'sw 12/18/2000 14:33'!includesSelector: aSelector forInstance: anInstance ofClass: aTargetClass limitClass: mostGenericClass	"Answer whether the vocabulary includes the given selector for the given class (and instance, if provided), only considering method implementations in mostGenericClass and lower"	| classToUse aClass theKeys |	(aTargetClass isUniClass and:		[(aTargetClass namedTileScriptSelectors includes: aSelector) or:			[(((theKeys := aTargetClass slotInfo keys collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName])) includes: aSelector)					or:						[(theKeys collect: [:anInstVarName | Utilities setterSelectorFor: anInstVarName]) includes: aSelector]]]) ifTrue: [^ true].	(methodInterfaces includesKey: aSelector) ifFalse: [^ false].	classToUse := self classToUseFromInstance: anInstance ofClass: aTargetClass.	^ (aClass := classToUse whichClassIncludesSelector: aSelector)		ifNil:			[false]		ifNotNil:			[aClass includesBehavior: mostGenericClass]! !!EToyVocabulary methodsFor: 'method list' stamp: 'sw 10/7/2004 17:09'!allMethodsInCategory: aCategoryName forInstance: anObject ofClass: aClass	"Answer a list of all methods in the etoy interface which are in the given category, on behalf of anObject, or if it is nil, aClass"	| aCategory unfiltered suitableSelectors isAll |	aCategoryName ifNil: [^ OrderedCollection new].	aClass isUniClass ifTrue:		[aCategoryName = ScriptingSystem nameForScriptsCategory ifTrue:			[^ aClass namedTileScriptSelectors].		aCategoryName = ScriptingSystem nameForInstanceVariablesCategory ifTrue:			[^ aClass slotInfo keys asSortedArray collect:				[:anInstVarName | Utilities getterSelectorFor: anInstVarName]]].	unfiltered := (isAll := aCategoryName = self allCategoryName)		ifTrue:			[methodInterfaces collect: [:anInterface | anInterface selector]]		ifFalse:			[aCategory := categories detect: [:cat | cat categoryName = aCategoryName] 							ifNone: [^ OrderedCollection new].			aCategory elementsInOrder collect: [:anElement | anElement selector]].	(anObject isKindOf: Player) ifTrue:		[suitableSelectors := anObject costume selectorsForViewer.		unfiltered := unfiltered  select:			[:aSelector | suitableSelectors includes: aSelector]].	(isAll and: [aClass isUniClass]) ifTrue:		[unfiltered addAll: aClass namedTileScriptSelectors.		unfiltered addAll: (aClass slotInfo keys asSortedArray collect:			[:anInstVarName | Utilities getterSelectorFor: anInstVarName])].	^ (unfiltered copyWithoutAll: #(dummy unused)) asSortedArray! !!EmphasizedMenu methodsFor: 'emphasis'!emphases: emphasisArray	emphases := emphasisArray! !!EmphasizedMenu methodsFor: 'emphasis' stamp: 'fc 2/19/2004 22:07'!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  "	emphases := (Array new: selections size) atAllPut: #normal.	emphases at: itemNumber put: #bold! !!EmphasizedMenu methodsFor: 'private' stamp: 'fc 2/20/2004 11:01'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |		labelString := labelString asText.	emphases isEmptyOrNil ifTrue: [^ self].	selStart := 1.	1 to: selections size do:		[:line |			selEnd := selStart + (selections at: line) size - 1.			((currEmphasis := emphases at: line) size > 0 and: [currEmphasis ~~ #normal]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart := selEnd + 2]! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sw 9/11/97 16:14'!example2	"EmphasizedMenu example2"	| aMenu |	aMenu := EmphasizedMenu selections: #('One' 'Two' 'Three' 'Four').	aMenu onlyBoldItem: 3.	^ aMenu startUpWithCaption: 'Only the Bold'! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/23/96'!selectionAndEmphasisPairs: interleavedList	"An alternative form of call.  "	| selList  emphList |	selList := OrderedCollection new.	emphList := OrderedCollection new.	interleavedList pairsDo:		[:aSel :anEmph |			selList add: aSel.			emphList add: anEmph].	^ self selections:selList emphases: emphList! !!EtoyLoginMorph methodsFor: 'actions' stamp: 'dgd 10/8/2003 18:58'!doOK	| proposed |	proposed := theNameMorph contents string.	proposed isEmpty ifTrue: [^self inform: 'Please enter your login name' translated].	proposed size > 24 ifTrue: [^self inform: 'Please make the name 24 characters or less' translated].	(Project isBadNameForStoring: proposed) ifTrue: [		^self inform: 'Please remove any funny characters' translated	].	(actionBlock value: proposed) ifTrue:[self delete].! !!EtoyLoginMorph methodsFor: 'building' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString font: self myFont;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	col := (self inAColumn: {f}) hResizing: #spaceFill.	^col! !!EtoyLoginMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 16:01'!defaultColor	"answer the default color/fill style for the receiver"	| result |	result := GradientFillStyle ramp: {0.0					-> (Color							r: 0.5							g: 0.5							b: 1.0). 1.0					-> (Color							r: 0.8							g: 0.8							b: 1.0)}.	result origin: self bounds origin.	result direction: 0 @ self bounds height.	^ result! !!EtoyLoginMorph methodsFor: 'initialize' stamp: 'ar 9/24/2000 00:09'!name: aString actionBlock: aBlock cancelBlock: altBlock	theName := aString.	actionBlock := aBlock.	cancelBlock := altBlock.	theNameMorph contentsWrapped: theName.	theNameMorph editor selectAll.! !!EtoyLoginMorph methodsFor: 'initialize' stamp: 'ar 9/23/2000 23:52'!rebuild	self removeAllMorphs.	self addARow: { (StringMorph contents:'') lock }.	self addARow: {		(StringMorph contents: 'Please enter your Squeak login name' font: self myFont) lock.	}.	(self addARow: {		(theNameMorph := TextMorph new			beAllFont: self myFont;			crAction: (MessageSend receiver: self selector: #doOK);			extent: 300@20;			contentsWrapped: 'the old name';			setBalloonText: 'Enter your name and avoid the following characters: : < > | / \ ? * "'			).	}) color: Color white; borderColor: Color black; borderWidth: 1.	self addARow: {		self okButton.		self cancelButton.	}.	self addARow: { (StringMorph contents:'') lock }.! !!EtoyLoginMorph class methodsFor: 'instance creation' stamp: 'ar 8/23/2001 21:37'!loginAndDo: aBlock ifCanceled: cancelBlock	"EtoyLoginMorph loginAndDo:[:n| true] ifCanceled:[]"	| me |	(me := self new)		name: 'your name' actionBlock: aBlock cancelBlock: cancelBlock;		fullBounds;		position: Display extent - me extent // 2;		openInWorld.	me position: me position + (0@40).! !!EtoyUpdatingThreePhaseButtonMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/11/2000 12:18'!step	| newBoolean |	state == #pressed ifTrue: [^ self].	newBoolean := target perform: getSelector withArguments: arguments.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean ifTrue: [#on] ifFalse: [#off])]! !!EtoyUpdatingThreePhaseButtonMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 8/8/2000 13:34'!setFormsCheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 4278190081 2003331177 4278190081 4278190081 0 0 0 0 0 0 0 4278190081 2003331177 0 4278190081 4278190081 0 0 0 0 0 0 4278190081 2003331177 0 0 4278190081 4278190081 0 4278190081 0 0 0 4278190081 2003331177 0 0 0 4278190081 4278190081 0 2003331177 4278190081 0 4278190081 2003331177 0 0 0 0 4278190081 4278190081 0 0 2003331177 4278190081 2003331177 0 0 0 0 0 4278190081 4278190081 0 0 0 2003331177 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0).MouseDownForm := UncheckedForm := (Form	extent: 12@12	depth: 32	fromArray: #( 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 0 0 0 0 0 0 0 0 0 0 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081 4278190081)	offset: 0@0)! !!EventHandler methodsFor: '*eToys-initialization' stamp: 'jcg 9/21/2001 12:57'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient := mouseDownSelector := nil].	mouseMoveSelector == aSelector		ifTrue: [mouseMoveRecipient := mouseMoveSelector := nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient := mouseStillDownSelector := nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient := mouseUpSelector := nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient := mouseEnterSelector := nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient := mouseLeaveSelector := nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient := mouseEnterDraggingSelector := nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient := mouseLeaveDraggingSelector := nil].	clickSelector == aSelector		ifTrue: [clickRecipient := clickSelector := nil].	doubleClickSelector == aSelector		ifTrue: [doubleClickRecipient := doubleClickSelector := nil].	doubleClickTimeoutSelector == aSelector		ifTrue: [doubleClickTimeoutRecipient := doubleClickTimeoutSelector := nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient := keyStrokeSelector := nil].! !!FileList methodsFor: 'own services' stamp: 'edc 4/24/2007 09:49'!viewContentsInWorkspace	"View the contents of my selected file in a new workspace"		| aString aFileStream aName |	aString := (aFileStream := directory readOnlyFileNamed: self fullName) setConverterForCode contentsOfEntireFile.	aName := aFileStream localName.	aFileStream close.	UIManager default edit: aString withSqueakLineEndings label: 'Workspace from ', aName! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet pseudoClass: pseudoClass selector: selector	"Returns the source code for a conflict if a conflict is found, otherwise returns nil."	| classOrMeta allChangeSets moreRecentChangeSets conflictingChangeSets changeRecordSource classAndMethodPrintString |	classAndMethodPrintString _ pseudoClass name, (pseudoClass hasMetaclass ifTrue: [' class'] ifFalse: ['']), '>>', selector asString.	changeRecordSource _ pseudoClass sourceCode at: selector.	changeRecordSource isText		ifTrue: [changeRecordSource _ Text					fromString: 'method: ', classAndMethodPrintString, ' was removed']		ifFalse: [changeRecordSource stamp isEmptyOrNil ifTrue:					[self notify: 'Warning: ', classAndMethodPrintString, ' in ', self packageName, ' has no timestamp/initials!!']].	pseudoClass exists ifFalse:		[(self classes at: pseudoClass name) hasDefinition			ifTrue: [^ nil  "a method was added for a newly defined class; not a conflict"]			ifFalse: [self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString, '... class ', pseudoClass name asString, ' does not exist in the image and is not defined in the file'.					^ changeRecordSource]].	classOrMeta _ pseudoClass realClass.	"Only printout the replacing methods here, but we still check for removed methods too in the rest of this method."	(self class verboseConflicts and: [classOrMeta includesSelector: selector])		ifTrue: [self class logCr; log: '...checking ', classOrMeta asString, '>>', selector asString].	allChangeSets _ ChangesOrganizer allChangeSets.	moreRecentChangeSets _ allChangeSets				copyFrom: (allChangeSets indexOf: updateNumberChangeSet)				to: (allChangeSets size).	conflictingChangeSets _ (moreRecentChangeSets select:		[:cs | (cs atSelector: selector class: classOrMeta) ~~ #none]).	conflictingChangeSets isEmpty ifTrue: [^ nil].	self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString,				(' with newer changeset' asPluralBasedOn: conflictingChangeSets).	conflictingChangeSets do: [:cs | self class log: ' ', cs name].	^ changeRecordSource! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!findUpdateChangeSetMatching: updateNumber	"Find update-changeset beginning with updateNumber, or reasonably close."	"This is to account for the fact that many changeset files are output from final releases, but may be tested for conflicts in a following alpha image, which will often not include that particular update-changeset from the final release but will contain ones near it.  For example, if the file updateNumber is 5180 (from 3.5 final), but the image has no update-changeset beginning with 5180 because it's a 3.6alpha image (which starts at 5181), it will try up to 5190 and down to 5170 for a close match."	| updateNumberChangeSet updateNumberToTry |	updateNumberToTry _ updateNumber.	updateNumberChangeSet _ nil.	[updateNumberChangeSet isNil and: [updateNumberToTry notNil]] whileTrue:		[updateNumberChangeSet _ ChangesOrganizer allChangeSets			detect: [:cs | (cs name beginsWith: updateNumberToTry asString)							and: [(cs name at: (updateNumberToTry asString size + 1)) isDigit not]]			ifNone: [nil].		updateNumberToTry >= updateNumber ifTrue:			[updateNumberToTry < (updateNumber + 10)				ifTrue: [updateNumberToTry _ updateNumberToTry + 1]				ifFalse: [updateNumberToTry _ updateNumber]].		updateNumberToTry <= updateNumber ifTrue:			[updateNumberToTry > (updateNumber - 10)				ifTrue: [updateNumberToTry _ updateNumberToTry - 1]				ifFalse: [updateNumberToTry _ nil  "we're done trying"]].		].	updateNumberChangeSet ifNil:		[(self confirm: 'Warning: No changeset beginning with ',updateNumber asString, ' (within +/- 10) was found in the image.You must have changesets going back this far in your imagein order to accurately check for conflicts.Proceed anyway?')			ifTrue: [updateNumberChangeSet _ ChangesOrganizer allChangeSets first]].	^ updateNumberChangeSet! !!FilePackage methodsFor: 'reading' stamp: 'edc 4/1/2007 07:58'!fromStream: aStream named: aName	| chgRec changes |	changes := ChangeSet scanFile: aStream from: 0 to: aStream size.	aStream close.	('Processing ', aName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbolwith: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation' stamp: 'edc 4/1/2007 07:57'!fromStream: aStream named: aName	^self new fromStream: aStream named: aName! !!FileStream methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:39'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: (self localName)! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 4/28/1998 06:18'!acceptOnCR: aBoolean	acceptOnCR := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'jm 5/6/1998 15:13'!done: aBoolean	done := aBoolean.! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:45'!responseUponCancel: resp	responseUponCancel := resp! !!FillInTheBlank methodsFor: 'initialize-release' stamp: 'sw 1/31/2000 14:42'!initialize	super initialize.	acceptOnCR := false.	done := false.	responseUponCancel := ''! !!FillInTheBlank methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel := ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!FillInTheBlank methodsFor: 'private' stamp: 'sma 6/18/2000 10:54'!show: fillInView	| savedArea |	savedArea := Form fromDisplay: fillInView displayBox.	fillInView display.	contents isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: contents size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ contents! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'th 9/17/2002 16:46'!controlInitialize	model acceptOnCR ifFalse: [^ super controlInitialize].	self setMark: self markBlock stringIndex.	self setPoint: self pointBlock stringIndex.	self initializeSelection.	beginTypeInBlock := nil.! !!FillInTheBlankController methodsFor: 'basic control sequence' stamp: 'jm 5/6/1998 15:11'!controlTerminate	| topController |	super controlTerminate.	topController := view topView controller.	topController ifNotNil: [topController close].! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 08:35'!multiLineOn: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView |	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jdr 6/4/2000 15:03'!requestPassword: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView myPar pwdFont myArray myStyle |	aFillInTheBlank acceptOnCR: true.	messageView := DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView := self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	" now answerView to use the password font"	myPar := answerView displayContents.	pwdFont := (StrikeFont passwordFontSize: 12).	myArray := Array new: 1.	myArray at: 1 put: pwdFont.	myStyle := TextStyle fontArray: myArray.	myPar setWithText: (myPar text) style: myStyle.	topView := View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !!FixedFaceFont methodsFor: 'initialize-release' stamp: 'rej 9/29/2007 09:04'!initialize	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	baseFont := StrikeFont defaultSized: 12.	self passwordFont! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 12/9/2006 09:23'!defaultsQuadsDefiningWidgetsFlap	"Answer a structure defining the default Widgets flap.     previously in quadsDefiningWidgetsFlap"	^ #(	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')	(AllScriptsTool			allScriptsToolForActiveWorld	'All Scripts' 		'A tool that lets you see and control all the running scripts in your project')	(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')	(GeeMailMorph			new						'Gee-Mail'			'A place to present annotated content')	(RecordingControlsMorph	authoringPrototype		'Sound'				'A device for making sound recordings.')	"(MPEGMoviePlayerMorph	authoringPrototype		'Movie Player'		'A Player for MPEG movies')"	(FrameRateMorph		authoringPrototype			'Frame Rate'		'An indicator of how fast your system is running')	(MagnifierMorph		newRound					'Magnifier'			'A magnifying glass')	(ScriptingSystem		newScriptingSpace			'Scripting'			'A confined place for drawing and scripting, with its own private stop/step/go buttons.')	(ScriptingSystem		holderWithAlphabet			'Alphabet'			'A source for single-letter objects')	(BouncingAtomsMorph	new						'Bouncing Atoms'	'Atoms, mate')	(ObjectsTool				newStandAlone				'Object Catalog'		'A tool that lets you browse the catalog of objects')	) asOrderedCollection! !!FloatArray methodsFor: 'arithmetic' stamp: 'laza 3/24/2000 13:07'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	"<primitive:'primitiveFloatArrayDotProduct'>"	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result := 0.0.	1 to: self size do:[:i|		result := result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: 'comparing' stamp: 'ar 5/3/2001 13:02'!hash	| result |	<primitive:'primitiveHashArray' module: 'FloatArrayPlugin'>	result := 0.	1 to: self size do:[:i| result := result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aFloatArray 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	aFloatArray class = self class ifFalse: [^ false].	length := self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aFloatArray at: i) ifFalse: [^ false]].	^ true! !!FloatTest methodsFor: 'NaN behavior' stamp: 'rej 10/7/2007 20:40'!testNaN2	"Two NaN values are always considered to be different.	On an little-endian machine (32 bit Intel), Float nan is 16rFFF80000 16r00000000.	On a big-endian machine (PowerPC), Float nan is 16r7FF80000 16r00000000. Changing	the bit pattern of the first word of a NaN produces another value that is still	considered equal to NaN. This test should work on both little endian and big	endian machines. However, it is not guaranteed to work on future 64 bit versions	of Squeak, for which Float may have different internal representations."	"FloatTest new testNaN2"	| nan1 nan2 |	nan1 := Float nan copy.	nan2 := Float nan copy.	"test two instances of NaN with the same bit pattern"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1.	"change the bit pattern of nan1"	self assert: nan1 size = 2.	self assert: (nan1 at: 2) = 0.	nan1 at: 1 put: (nan1 at: 1) + 999.	self assert: nan1 isNaN.	self assert: nan2 isNaN.	self deny: (nan1 at: 1) = (nan2 at: 1).	"test two instances of NaN with different bit patterns"	self deny: nan1 = nan2.	self deny: nan1 = nan2.	self deny: nan1 = nan1.	self assert: nan1 == nan1! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 1/10/2007 02:29'!testFractionAsFloat2	"test rounding to nearest even"			self assert: ((1<<52)+0+(1/4)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(1/2)) asFloat asTrueFraction = ((1<<52)+0).	self assert: ((1<<52)+0+(3/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/4)) asFloat asTrueFraction = ((1<<52)+1).	self assert: ((1<<52)+1+(1/2)) asFloat asTrueFraction = ((1<<52)+2).	self assert: ((1<<52)+1+(3/4)) asFloat asTrueFraction = ((1<<52)+2).! !!Form methodsFor: 'testing' stamp: 'ar 7/21/2007 21:37'!isAllWhite	"Answer whether all bits in the receiver are white"	| word |	self unhibernate.	word := Color white pixelWordForDepth: self depth.	1 to: bits size do: [:i | (bits at: i) = word ifFalse: [^ false]].	^ true! !!FormButtonCache methodsFor: 'accessing'!form: aForm	"Set the receiver's form to be the argument."	form := aForm! !!FormButtonCache methodsFor: 'accessing'!initialState: aBoolean	"Set the receiver's initial state, on or off, to be the argument."	initialState := aBoolean! !!FormButtonCache methodsFor: 'accessing'!offset: anInteger	"Set the receiver's offset."	offset := anInteger! !!FormButtonCache methodsFor: 'accessing'!value: aCharacter	"Set the receiver's key character."	value := aCharacter! !!FormEditor methodsFor: 'editing tools'!changeTool: aCharacter 	"Change the value of the instance variable tool to be the tool 	corresponding to aCharacter. Typically sent from a Switch in a 	FormMenuView."	previousTool := tool.	tool := self selectTool: aCharacter.	(#(singleCopy repeatCopy line curve block) includes: tool)		ifFalse:			[self perform: tool]! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/10/2003 16:21'!curve	"Conic-section specified by three points designated by: first point--press 	red button second point--release red button third point--click red button. 	The resultant curve on the display is displayed according to the current 	form and mode."	| firstPoint secondPoint thirdPoint curve drawForm |	"sensor noButtonPressed ifTrue: [^self]."	firstPoint := self cursorPoint.	secondPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	thirdPoint :=  self rubberBandFrom: secondPoint until: [sensor redButtonPressed].	Display depth > 1	  ifTrue:	    [self deleteRubberBandFrom: secondPoint to: thirdPoint.	     self deleteRubberBandFrom: firstPoint to: secondPoint].	curve := CurveFitter new.	curve firstPoint: firstPoint.	curve secondPoint: secondPoint.	curve thirdPoint: thirdPoint.	drawForm := form asFormOfDepth: Display depth.	Display depth > 1 ifTrue:	  [drawForm mapColor: Color white to: Color transparent; 	               mapColor: Color black to: color].	curve form: drawForm.	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]										ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]). 	sensor waitNoButton.	hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!eraseMode	"Set the mode for the tools that copy the form onto the display to erase. 	Leaves the tool set in its previous state."	mode := 4.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 12/12/2003 15:51'!line	"Line is specified by two points from the mouse: first point--press red 	button; second point--release red button. The resultant line is displayed 	according to the current form and mode."	| firstPoint endPoint drawForm |	drawForm := form asFormOfDepth: Display depth.		 Display depth > 1 	  ifTrue:	    [drawForm mapColor: Color white to: Color transparent; 	                 mapColor: Color black to: color].	           	firstPoint := self cursorPoint.	endPoint := self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	endPoint isNil ifTrue: [^self].	Display depth > 1 ifTrue: [self deleteRubberBandFrom: firstPoint to: endPoint.].	(Line from: firstPoint to: endPoint withForm: drawForm)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: (Display depth > 1 ifTrue: [mode ~= Form erase ifTrue: [Form paint] ifFalse: [mode]]								ifFalse: [mode])		fillColor: (Display depth = 1 ifTrue: [color] ifFalse: [nil]).  		hasUnsavedChanges contents: true.! !!FormEditor methodsFor: 'editing tools'!magnify	"Allow for bit editing of an area of the Form. The user designates a 	rectangular area that is scaled by 5 to allow individual screens dots to be 	modified. Red button is used to set a bit to black, and yellow button is 	used to set a bit to white. Editing continues until the user depresses any 	key on the keyboard."	| smallRect smallForm scaleFactor tempRect |	scaleFactor := 8@8.	smallRect := (Rectangle fromUser: grid) intersect: view insetDisplayBox.	smallRect isNil ifTrue: [^self].	smallForm := Form fromDisplay: smallRect.	"Do this computation here in order to be able to save the existing display screen."	tempRect := BitEditor locateMagnifiedView: smallForm scale: scaleFactor.	BitEditor		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'jm 6/30/1999 15:46'!newSourceForm	"Allow the user to define a new source form for the FormEditor. Copying 	the source form onto the display is the primary graphical operation. 	Resets the tool to be repeatCopy."	| dForm interiorPoint interiorColor |	dForm := Form fromUser: grid.	"sourceForm must be only 1 bit deep"	interiorPoint := dForm extent // 2.	interiorColor := dForm colorAt: interiorPoint.	form := (dForm makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:f | f pixelValueAt: interiorPoint put: 1].	form := form trimBordersOfColor: Color white.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!overMode	"Set the mode for the tools that copy the form onto the display to over. 	Leaves the tool set in its previous state."	mode := Form over.	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!reverseMode	"Set the mode for the tools that copy the form onto the display to reverse. 	Leaves the tool set in its previous state."	mode := Form reverse.	tool := previousTool! !!FormEditor methodsFor: 'editing tools' stamp: 'BG 2/25/2001 21:36'!setColor: aColor	"Set the mask (color) to aColor.	Hacked to invoke color chooser if not B/W screen.	Leaves the tool set in its previous state."	self normalizeColor:  (unNormalizedColor := Display depth > 1							ifTrue: [Color fromUser]							ifFalse: [aColor]).	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!togglexGridding	"Turn x (horizontal) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	xgridOn		ifTrue: 			[grid := 1 @ grid y.			xgridOn := false]		ifFalse: 			[grid := togglegrid x @ grid y.			xgridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!toggleyGridding	"Turn y (vertical) gridding off, if it is on, and turns it on, if it is off. 	Does not change the primary tool."	ygridOn		ifTrue: 			[grid := grid x @ 1.			ygridOn := false]		ifFalse: 			[grid := grid x @ togglegrid y.			ygridOn := true].	tool := previousTool! !!FormEditor methodsFor: 'editing tools'!underMode	"Set the mode for the tools that copy the form onto the display to under. 	Leaves the tool set in its previous state."	mode := Form under.	tool := previousTool! !!FormEditor methodsFor: 'initialize-release'!release	"Break the cycle between the Controller and its view. It is usually not 	necessary to send release provided the Controller's view has been properly 	released independently."	super release.	form := nil! !!FormEditor methodsFor: 'private' stamp: 'jm 12/4/97 10:22'!normalizeColor: aColor	color := aColor.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/10/2003 16:47'!rubberBandFrom: startPoint until: aBlock	| endPoint previousEndPoint |	previousEndPoint := startPoint.	[aBlock value] whileFalse:		[(endPoint := self cursorPoint) = previousEndPoint 			ifFalse:			[(Line from: startPoint to: previousEndPoint withForm: form) 				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			(Line from: startPoint to: endPoint withForm: form)				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				fillColor: Color gray.			previousEndPoint  := endPoint]].	(Line from: startPoint to: previousEndPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		fillColor: (Display depth = 1 ifTrue: [Color gray] ifFalse: [Color black]).	^endPoint! !!FormEditor methodsFor: 'private' stamp: 'BG 12/5/2003 22:58'!setVariables	tool := #repeatCopy.	previousTool := tool.	grid := 1 @ 1.	togglegrid := 8 @ 8.	xgridOn := false.	ygridOn := false.	mode := Form over.	form := Form extent: 8 @ 8.	form fillBlack.	unNormalizedColor := color := Color black.	hasUnsavedChanges := ValueHolder new contents: false.! !!FormEditor methodsFor: 'private' stamp: 'BG 12/12/2003 15:50'!trackFormUntil: aBlock	| previousPoint cursorPoint displayForm |	previousPoint := self cursorPoint.	displayForm := Form extent: form extent depth: form depth.	displayForm copy: (0 @ 0 extent: form extent)	               from: form	               to: 0 @ 0	               rule: Form over.	Display depth > 1 ifTrue: [displayForm reverse]. 	displayForm displayOn: Display at: previousPoint rule: Form reverse.	[aBlock value] whileFalse:		[cursorPoint := self cursorPoint.		(FlashCursor or: [cursorPoint ~= previousPoint])			ifTrue:			[displayForm displayOn: Display at: previousPoint rule: Form reverse.			displayForm displayOn: Display at: cursorPoint rule: Form reverse.			previousPoint := cursorPoint]].	displayForm displayOn: Display at: previousPoint rule: Form reverse.	^previousPoint! !!FormEditor class methodsFor: 'class initialization'!flashCursor: aBoolean	FlashCursor := aBoolean	"FormEditor flashCursor: true"! !!FormEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 15:06'!initialize	FlashCursor := false.	self setKeyboardMap.	YellowButtonMenu := SelectionMenu 		labels:'acceptcanceleditfile out'		lines: #(2)		selections: #(accept cancel edit fileOut).	"FormEditor initialize"! !!FormEditor class methodsFor: 'instance creation'!openFullScreenForm	"Create and schedule an instance of me on the form whose extent is the 	extent of the display screen."	| topView |	topView := self createFullScreenForm.	topView controller 		openDisplayAt: (topView viewport extent//2)	"FormEditor openFullScreenForm."! !!FormEditor class methodsFor: 'instance creation'!openOnForm: aForm	"Create and schedule an instance of me on the form aForm."	| topView |	topView := self createOnForm: aForm.	topView controller open! !!FormEditor class methodsFor: 'private' stamp: 'di 1/16/98 15:46'!createFullScreenForm	"Create a StandardSystemView for a FormEditor on the form whole screen."	| formView formEditor menuView topView extent aForm |	aForm := Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.	formView := FormHolderView new model: aForm.	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: menuView controller.	topView := StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView model: aForm.	topView addSubView: formView.	topView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	topView window: 		(formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).	topView label: 'Form Editor'.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private' stamp: 'BG 12/5/2003 23:18'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder := 2.	formView := FormHolderView new model: aForm.	formEditor := formView controller.	menuView := FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView := View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView := "ColorSystemView" FormEditorView new.	topView model: formEditor.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent := topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !!FormEditor class methodsFor: 'private'!setKeyboardMap	"Keyboard Mapping."	SelectKey:=$a.	SingleCopyKey:=$s.			"tools"	RepeatCopyKey:=$d.	LineKey:=$f.	CurveKey:=$g.	BlockKey:=$h.	OverKey:=$j.				"modes"	UnderKey:=$k.	ReverseKey:=$l.	EraseKey:=$;.	InKey:=$'.					"file In"	BitEditKey:=$z.	WhiteKey:=$x.				"colors"	LightGrayKey:=$c.	GrayKey:=$v.	DarkGrayKey:=$b.	BlackKey:=$n.	TogglexGridKey:=$m.		"gridding"	ToggleyGridKey:=$,.	ChangeGridsKey:=$..	OutKey:=$/					"file Out"! !!FormHolderView methodsFor: 'displaying'!displayView 	"Display the Form associated with this View according to the rule and	fillColor specifed by this class."	| oldOffset |	oldOffset := displayedForm offset.	displayedForm offset: 0@0.	displayedForm		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	displayedForm offset: oldOffset! !!FormHolderView methodsFor: 'initialize-release'!release	super release.	displayedForm release.	displayedForm := nil! !!FormHolderView methodsFor: 'model access'!model: aForm	super model: aForm.	displayedForm := aForm deepCopy! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale := self insetDisplayBox extent / model selection extent.	scale := (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormMenuController methodsFor: 'control defaults' stamp: 'jm 4/7/98 20:59'!processMenuKey	"The user typed a key on the keyboard. Perform the action of the button whose shortcut is that key, if any."	| aView |	aView := view subViewContainingCharacter: sensor keyboard.	aView ~~ nil ifTrue: [aView performAction].! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:22'!makeButton: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	button := Button newOff.	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector := Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector := Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 15:24'!makeGridSwitch: index	| buttonCache button |	buttonCache := FormButtons at: index.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	button offAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'BG 12/4/2003 14:23'!makeSwitch: index	| buttonCache button |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.	buttonCache initialState = #true		ifTrue: [button := Switch newOn]		ifFalse: [button := Switch newOff].	button onAction: [model changeTool: buttonCache value].	self makeViews: buttonCache for: button.! !!FormMenuView methodsFor: 'private' stamp: 'jm 4/7/98 20:24'!makeViews: cache for: aSwitch	| form aSwitchView |	form := cache form.	aSwitchView := PluggableButtonView		on: aSwitch		getState: #isOn		action: #switch.	aSwitchView		label: form;		shortcutCharacter: cache value;		window: (0@0 extent: form extent);		translateBy: cache offset;		borderWidth: 1.	self addSubView: aSwitchView.	^ aSwitchView! !!FormMenuView class methodsFor: 'class initialization' stamp: 'jm 3/27/98 14:54'!fileOut	"Save the FormEditor button icons."	"FormMenuView fileOut"	| names |	names := 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').	1 to: FormButtons size do: [:i |		(FormButtons at: i) form writeOnFileNamed: (names at: i)].	SpecialBorderForm writeOnFileNamed: 'specialborderform.form'.	BorderForm writeOnFileNamed: 'borderform.form'.! !!FormMenuView class methodsFor: 'class initialization' stamp: 'md 7/23/2006 16:41'!initialize2	"The icons for the menu are typically stored on files. In order to avoid reading them every time, they are stored in a collection in a class variable, along with their offset, tool value, and initial visual state (on or off)."	"FormMenuView initialize"	| offsets keys states names button |	offsets _ OrderedCollection new: 21.	#(0 64 96 128 160 192 256 288 320 352 420) do: [:i | offsets addLast: i@0].  "First row"	#(0 64 96 128 160 192 256 304 352 420) do: [:i | offsets addLast: i@48].  "Second row"	offsets _ offsets asArray.	keys _ #($a $s $d $f $g $h $j $k $l $; $' $z $x $c $v $b $n $m $, $. $/ ).  "Keyboard"	states _ #(		#false #false #true #false #false #false #true #false #false #false #false		#false #false #false #false #false #true #false #false #false #false).  "Initial button states"	names _ 		#('select.form' 'singlecopy.form' 'repeatcopy.form' 'line.form' 'curve.form'		'block.form' 'over.form' 'under.form' 'reverse.form' 'erase.form' 'in.form'		'magnify.form' 'white.form' 'lightgray.form' 'gray.form' 'darkgray.form' 'black.form'		'xgrid.form' 'ygrid.form' 'togglegrids.form' 'out.form').  "Files of button images"	FormButtons _ OrderedCollection new.	1 to: 21 do: [:index |		button _ FormButtonCache new.		button form: (Form fromFileNamed: (names at: index)).		button offset: (offsets at: index).		button value: (keys at: index).		button initialState: (states at: index).		FormButtons addLast: button].	SpecialBorderForm  _ Form fromFileNamed: 'specialborderform.form'.	BorderForm _ Form fromFileNamed: 'borderform.form'.! !!FormTest methodsFor: 'tests' stamp: 'ar 7/21/2007 21:41'!testIsAllWhite	"self run: #testIsAllWhite"	"Make sure #isAllWhite works for all bit depths"	| form |	#(-32 -16 -8 -4 -2 -1 1 2 4 8 16 32) do:[:d|		form := Form extent: 16@16 depth: d.		form fillBlack.		self deny: form isAllWhite.		form fillWhite.		self assert: form isAllWhite.	].! !!FormTest commentStamp: 'ar 7/21/2007 21:39' prior: 0!Various tests for class form.!!FormView methodsFor: 'accessing'!fillColor: aForm 	"Set the display mask for displaying the receiver's model to be the 	argument, aForm."	mask := aForm! !!FormView methodsFor: 'accessing'!rule: anInteger 	"Set the display rule for the receiver to be the argument, anInteger."	rule := anInteger! !!FormView methodsFor: 'displaying' stamp: 'hmm 7/21/97 20:45'!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset := model offset.	model offset: "borderWidth origin" 0@0.	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset! !!FormView class methodsFor: 'examples'!exampleOne	"Frame a Form (specified by the user) with a border of 2 bits in width and display it offset 60 x 40 from the cornor of the display screen. "	| f view |	f := Form fromUser.	view := self new model: f.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleOne"! !!FormView class methodsFor: 'examples'!exampleTwo	"Frame a Form (specified by the user) that is scaled by 2. The border is 2 bits in width. Displays at location 60, 40."	| f view |	f := Form fromUser.	view := self new model: f.	view scaleBy: 2.0.	view translateBy: 60 @ 40.	view borderWidth: 2.	view display.	view release	"FormView exampleTwo"! !!FormView class methodsFor: 'examples' stamp: 'BG 12/5/2003 14:45'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView := StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: aForm extent;	          maximumSize: aForm extent.	aView := FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!Fraction methodsFor: 'converting' stamp: 'nice 1/10/2007 02:07'!asFloat	"Answer a Float that closely approximates the value of the receiver.	This implementation will answer the closest floating point number to	the receiver.	It uses the IEEE 754 round to nearest even mode	(can happen in case denominator is a power of two)"		| a b q r exponent floatExponent n ha hb hq q1 |	a := numerator abs.	b := denominator abs.	ha := a highBit.	hb := b highBit.		"If both numerator and denominator are represented exactly in floating point number,	then fastest thing to do is to use hardwired float division"	(ha < 54 and: [hb < 54]) ifTrue: [^numerator asFloat / denominator asFloat].		"Try and obtain a mantissa with 54 bits.	First guess is rough, we might get one more bit or one less"	exponent := ha - hb - 54.	exponent > 0		ifTrue: [b := b bitShift: exponent]		ifFalse: [a := a bitShift: exponent negated].	q := a quo: b.	r := a - (q * b).	hq := q highBit.		"check for gradual underflow, in which case we should use less bits"	floatExponent := exponent + hq - 1.	n := floatExponent > -1023		ifTrue: [54]		ifFalse: [54 + floatExponent + 1022].		hq > n		ifTrue: [exponent := exponent + hq - n.			r := (q bitAnd: (1 bitShift: hq - n) - 1) * b + r.			q := q bitShift: n - hq].	hq < n		ifTrue: [exponent := exponent + hq - n.			q1 := (r bitShift: n - hq) quo: b.			q := (q bitShift: n - hq) bitAnd: q1.			r := (r bitShift: n - hq) - (q1 * b)].			"check if we should round upward.	The case of exact half (q bitAnd: 1) isZero not & (r isZero)	will be handled by Integer>>asFloat"	((q bitAnd: 1) isZero or: [r isZero])		ifFalse: [q := q + 1].			^ (self positive		ifTrue: [q asFloat]		ifFalse: [q asFloat negated])		timesTwoPower: exponent! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:40'!fileIntoNewChangeSet: fullFileName	"FileIn the contents of a gzipped file"	| zipped unzipped cs |	cs := Smalltalk at: #ChangesOrganizer ifAbsent: [ ^self ].	zipped := self on: (FileStream readOnlyFileNamed: fullFileName).	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	cs newChangesFromStream: unzipped named: (FileDirectory localNameFor: fullFileName)! !!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pk 10/17/2006 09:41'!fileReaderServicesForFile: fullName suffix: suffix 	| services |	(suffix = 'gz') | (suffix = '*')		ifFalse: [^ #()].	services := OrderedCollection new.	(suffix = '*') | (fullName asLowercase endsWith: '.cs.gz') | (fullName asLowercase endsWith: '.mcs.gz')		ifTrue: [services add: self serviceFileIn.			(Smalltalk includesKey: #ChangSet)				ifTrue: [services add: self serviceFileIntoNewChangeSet]].	services addAll: self services.	^ services! !!GeeMailMorph methodsFor: '*eToys-customevents-stepping and presenter' stamp: 'nk 10/12/2003 13:23'!step	"For each submorph of thePasteUp that has just been scrolled into view, fire the script named #scrolledIntoView, if any.	For each submorph of thePasteUp that has just been scrolled out of view, fire the script named #scrolledOutOfView, if any."	| lastVisible nowVisible newlyVisible newlyInvisible |	super step.	lastVisible := self visibleMorphs.	nowVisible := (thePasteUp submorphs copyWithoutAll: (self allTextPlusMorphs))		select: [ :m | self bounds intersects: (m boundsIn: self world) ].	newlyInvisible := lastVisible difference: nowVisible.	newlyInvisible do: [ :ea | ea triggerEvent: #scrolledOutOfView ].	newlyVisible := nowVisible difference: lastVisible.	newlyVisible do: [ :ea | ea triggerEvent: #scrolledIntoView ].	self visibleMorphs: nowVisible.	! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 11/2/2004 21:26'!buttonNamed: aString action: aSymbol color: aColor help: helpString	| f col |	f := SimpleButtonMorph new		target: self;		label: aString;		color: aColor;		borderColor: aColor muchDarker;		actionSelector: aSymbol;		setBalloonText: helpString.	col := (self inAColumn: {f}) hResizing: #shrinkWrap.	^col! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 16:41'!clearSliderFeedback	| feedBack |	feedBack := self valueOfProperty: #sliderFeedback ifAbsent: [^self].	feedBack delete! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 16:22'!inAColumn: aCollectionOfMorphs	| col |	col := AlignmentMorphBob1 newColumn		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #topCenter.	aCollectionOfMorphs do: [ :each | col addMorphBack: each].	^col! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 12:27'!inARow: aCollectionOfMorphs	| row |	row := AlignmentMorphBob1 newRow		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #leftCenter.	aCollectionOfMorphs do: [ :each | row addMorphBack: each].	^row! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:22'!mouseAdjust: evt in: aMorph	| fractionalPosition feedBack testExtent |	feedBack := self showSliderFeedback: nil.	feedBack world ifNil: [		feedBack bottomLeft: evt cursorPoint - (0@8)	].	testExtent := 100@100.		"the real extent may change"	fractionalPosition := (evt cursorPoint - aMorph topLeft) / testExtent.	self 		perform: (aMorph valueOfProperty: #changeSelector)		with: fractionalPosition! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 13:09'!openNearTarget	| w wb tb leftOverlap rightOverlap topOverlap bottomOverlap best |	w := myTarget world ifNil: [World].	wb := w bounds.	self fullBounds.	tb := myTarget boundsInWorld.	leftOverlap := self width - (tb left - wb left).	rightOverlap := self width - (wb right - tb right).	topOverlap := self height - (tb top - wb top).	bottomOverlap := self height - (wb bottom - tb bottom).	best := nil.	{		{leftOverlap. #topRight:. #topLeft}.		{rightOverlap. #topLeft:. #topRight}.		{topOverlap. #bottomLeft:. #topLeft}.		{bottomOverlap. #topLeft:. #bottomLeft}.	} do: [ :tuple |		(best isNil or: [tuple first < best first]) ifTrue: [best := tuple].	].	self perform: best second with: (tb perform: best third).	self bottom: (self bottom min: wb bottom) rounded.	self right: (self right min: wb right) rounded.	self top: (self top max: wb top) rounded.	self left: (self left max: wb left) rounded.	self openInWorld: w.! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/9/2001 10:12'!showSliderFeedback: aString	| feedBack |	feedBack := self 		valueOfProperty: #sliderFeedback 		ifAbsent: [			feedBack := AlignmentMorph newRow				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				color: (Color yellow" alpha: 0.6");				addMorph: (					TextMorph new 						contents: '?';						beAllFont: ((TextStyle default fontOfSize: 24) emphasized: 1)				).			self setProperty: #sliderFeedback toValue: feedBack.			feedBack		].	aString ifNotNil: [		feedBack firstSubmorph contents: aString asString.		feedBack world ifNil: [feedBack openInWorld].	].	^feedBack! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:01'!targetMorph: x	myTarget := x! !!GenericPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:16'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 4.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	thingsToRevert := Dictionary new.	self useRoundedCorners! !!GraphicSymbolInstance methodsFor: 'accessing'!graphicSymbol: aGraphicSymbol 	"Set the argument, aGraphicSymbol, to be the graphic symbol that the 	receiver displays."	graphicSymbol := aGraphicSymbol! !!GraphicSymbolInstance methodsFor: 'transforming'!transformation: aWindowingTransformation 	"Set the argument, aWindowingTransformation, to be the receiver's 	display transformation."	transformation := aWindowingTransformation! !!GraphicSymbolInstance class methodsFor: 'examples'!example	"Simply evaluate the method and two GraphicSymbolInstances, each	displaying a transformation of the same graphic symbol, will be	presented on the screen. Clears the screen to white."	| gate instance1 instance2 trans1 trans2 line arc f|	Display fillWhite.			"clear the Screen."	f := Form extent: 2@2.	f fillBlack.	gate:= GraphicSymbol new.		"make a logic gate out of lines and arcs."	line:=Line new.  line beginPoint: -20@-20.  line endPoint: 0@-20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: -20@20.  line endPoint: 0@20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: 0@-40.  line endPoint: 0@40. line form: f.	gate add: line.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 1.	arc form: f.	gate add: arc.	arc := Arc new. arc center: 0@0 radius: 40 quadrant: 4.	arc form: f.	gate add: arc.			"one instance at 1/2 scale."	trans1:=WindowingTransformation identity.		trans1:= trans1 scaleBy: 0.5@0.5.	trans1:= trans1 translateBy: 100@100.			"the other instance at 2 times scale"	trans2:=WindowingTransformation identity.		trans2:= trans2 scaleBy: 2.0@2.0.	trans2:= trans2 translateBy: 200@200.	instance1 := GraphicSymbolInstance new.	instance1 transformation: trans1.	instance1 graphicSymbol: gate.	instance2 := GraphicSymbolInstance new.	instance2 transformation: trans2.	instance2 graphicSymbol: gate.			"display both instances of the logic gate"	instance1 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil.	instance2 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil	"GraphicSymbolInstance example"! !!GraphicTile methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:45'!initialize"initialize the state of the receiver"	super initialize.""	type := #literal.	self		useForm: (ScriptingSystem formAtKey: #Menu)! !!GraphicTile methodsFor: 'initialization' stamp: 'sw 4/3/2001 15:52'!setLiteral: anObject	"Set the receiver's literal to be anObject. No readout morph here."	type := #literal.	self setLiteralInitially: anObject.! !!GraphicTile methodsFor: 'initialization' stamp: 'sw 4/3/2001 15:40'!useForm: aForm	"Set the receiver to represent the given form"	| thumbnail |	self removeAllMorphs.	literal := aForm.	thumbnail := ThumbnailMorph  new objectToView: self viewSelector: #literal.	self addMorphBack: thumbnail.	thumbnail extent: 16 @ 16.! !!HandBugs methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testTargetPoint"self new testTargetPoint""self run: #testTargetPoint"self shouldnt: [ ActiveHand targetPoint ] raise: Error .! !!HandMorph methodsFor: 'accessing' stamp: 'wiz 12/4/2006 00:16'!targetPoint	"Return the new position of the target.	I.E. return the position of the hand less 	the original distance between hand and target position"	^ self position - targetOffset! !!Heap methodsFor: 'accessing' stamp: 'jcg 3/8/2003 02:00'!indexUpdateBlock: aBlockOrNil	indexUpdateBlock := aBlockOrNil.	indexUpdateBlock fixTemps.! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock: aBlock	sortBlock := aBlock.	sortBlock fixTemps.	self reSort.! !!Heap methodsFor: 'adding' stamp: 'jcg 3/8/2003 02:07'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally := tally + 1) put: anObject.	self updateObjectIndex: tally.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growTo: newSize	"Grow to the requested size."	| newArray |	newArray := Array new: (newSize max: tally).	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array := newArray! !!Heap methodsFor: 'private' stamp: 'ar 9/15/2000 17:12'!privateRemoveAt: index	"Remove the element at the given index and make sure the sorting order is okay"	| removed |	removed := array at: index.	array at: index put: (array at: tally).	array at: tally put: nil.	tally := tally - 1.	index > tally ifFalse:[		"Use #downHeapSingle: since only one element has been removed"		self downHeapSingle: index].	^removed! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:35'!setCollection: aCollection	array := aCollection.	tally := 0.! !!Heap methodsFor: 'private' stamp: 'ar 9/10/1999 13:18'!setCollection: aCollection tally: newTally	array := aCollection.	tally := newTally.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j := j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n := k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					self updateObjectIndex: k.					"and try again with j"					k := j]].	array at: k put: value.	self updateObjectIndex: k.! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:11'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n := tally bitShift: -1.	k := anIndex.	value := array at: anIndex.	[k <= n] whileTrue:[		j := k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j := j + 1].		array at: k put: (array at: j).		self updateObjectIndex: k.		"and try again with j"		k := j].	array at: k put: value.	self updateObjectIndex: k.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'jcg 3/8/2003 02:12'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k := anIndex.	value := array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp := array at: (kDiv2 := k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			self updateObjectIndex: k.			k := kDiv2].	array at: k put: value.	self updateObjectIndex: k.! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:33'!heapExample	"HeapTest new heapExample"	"Create a sorted collection of numbers, remove the elements	sequentially and add new objects randomly.	Note: This is the kind of benchmark a heap is designed for."	| n rnd array time sorted |	n := 5000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for Heap: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for SortedCollection: ', time printString,' msecs'.! !!HeapTest methodsFor: 'examples' stamp: 'md 2/12/2006 15:34'!heapSortExample	"HeapTest new heapSortExample"	"Sort a random collection of Floats and compare the results with	SortedCollection (using the quick-sort algorithm) and 	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."	| n rnd array  time sorted |	n := 10000. "# of elements to sort"	rnd := Random new.	array := (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time := Time millisecondsToRun:[		sorted := Heap withAll: array.		1 to: n do:[:i| sorted removeFirst].	].	Transcript cr; show:'Time for heap-sort: ', time printString,' msecs'.	"The quicksort version"	time := Time millisecondsToRun:[		sorted := SortedCollection withAll: array.	].	Transcript cr; show:'Time for quick-sort: ', time printString,' msecs'.	"The merge-sort version"	time := Time millisecondsToRun:[		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].	].	Transcript cr; show:'Time for merge-sort: ', time printString,' msecs'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:26'!testCharacterHex| result |result _ $a hex.self assert: result = '61'.result _ $A hex.self assert: result = '41'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:39'!testColorPrintHtmlStringself assert: (Color red printHtmlString ) = ( Color red asHTMLColor allButFirst asUppercase).! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:21'!testIntegerHex| result |result _ 15 asInteger hex.self assert: result = '0F'.result _ 0 asInteger hex.self assert: result = '00'.result _ 255 asInteger hex.self assert: result = 'FF'.result _ 90 asInteger hex.self assert: result = '5A'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:44'!testStringAsHex| result |result _ 'abc' asHex.self assert: result = '616263'.! !!HexTest commentStamp: 'JPF 6/26/2007 10:15' prior: 0!Rather than testing a single class, this set of tests looks at the interactions between Character, String, Integer and Color using hex and printStringHex!!IdentityDictionary methodsFor: 'private' stamp: 'RAA 1/10/2001 14:57'!fasterKeys	"This was taking some time in publishing and we didn't really need a Set"	| answer index |	answer := Array new: self size.	index := 0.	self keysDo: [:key | answer at: (index := index + 1) put: key].	^ answer! !!IdentityDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:41'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentitySet methodsFor: 'private' stamp: 'md 10/5/2005 15:42'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| finish hash start element |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 14:47'!isExpanded: aBoolean	| tm |	super isExpanded: aBoolean.	tm := self repositionText.	isExpanded ifFalse: [		self height: tm height.	].	self addMorph: tm.	"tm clipToOwner: isExpanded not."		"not really working right yet"! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 16:06'!position: p andWidth: w	| widthChanged |	widthChanged := self width ~= w.	self position: p.	self width: w.	submorphs isEmpty ifTrue: [^self height].	widthChanged ifTrue: [		self repositionText.	].	self height: self desiredHeight.	^self desiredHeight! !!IndentingListParagraphMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/30/2000 19:19'!repositionText	| sRect tm |	sRect := self textMorphBounds.	(tm := complexContents withoutListWrapper)		"clipToOwner: isExpanded not;"		position: sRect origin;		width: sRect width.	isExpanded ifTrue: [		tm extent: sRect width@10.		tm contents: tm contents wrappedTo: sRect width.		tm extent: sRect width@10.	] ifFalse: [		tm contentsAsIs: tm contents.		tm extent: tm extent.		"force bounds recompute"	].	tm lock: isExpanded not."{tm. tm bounds. sRect} explore."	^tm! !!IndentingListParagraphMorph methodsFor: 'drawing' stamp: 'RAA 1/26/2001 10:26'!drawToggleOn: aCanvas in: aRectangle	| aForm |	aCanvas 		fillRectangle: (bounds withRight: aRectangle right)		color: container color.	complexContents hasContents ifFalse: [^self].	aForm := isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	^aCanvas 		paintImage: aForm 		at: aRectangle topLeft! !!IndentingListParagraphMorph methodsFor: 'event handling' stamp: 'RAA 7/31/2000 10:04'!keyStroke: evt	| char |	char := evt keyCharacter.	evt controlKeyPressed ifTrue: [		char = Character cr ifTrue: [			container model addSibling.			^true	"we did handle it"		].		char = Character tab ifTrue: [			container model addNewChildAfter: 0.			^true	"we did handle it"		].	].	^false	"we did not handle it"! !!IndentingListParagraphMorph methodsFor: 'initialization' stamp: 'RAA 7/31/2000 09:52'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	super initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel.	self width: hostList width.	complexContents withoutListWrapper firstDisplay ifTrue: [		complexContents withoutListWrapper firstDisplayedOnLevel: indentLevel.		isExpanded := true.	].	complexContents withoutListWrapper showInOpenedState ifTrue: [		isExpanded := true.	].	self addMorph: self repositionText.! !!Inspector methodsFor: '*eToys-menu commands' stamp: 'sw 10/23/2000 18:25'!tearOffTile	"Tear off a tile that refers to the receiver's selection, and place it in the mophic hand"	| objectToRepresent |	objectToRepresent := self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	self currentHand attachMorph: (TileMorph new referTo: objectToRepresent)	! !!Installer methodsFor: 'action report' stamp: 'kph 1/11/2007 00:22'!actionMatch: theLine reportOn: report ifNoMatch: aBlock	| line |		line := theLine withBlanksCondensed.		((line beginsWith: 'Installer install:') | (line beginsWith: 'Installer do:')) 		ifTrue: [ ^self webAction: theLine reportOn: report ].			((line beginsWith: 'Installer installUrl:') and: 		[ | ext |		 ext :=  (line readStream upToAll: '''.') copyAfterLast: $..		 (#( 'cs' 'st' 'mcz' 'sar') includes: ext) not ]) ifTrue: [ ^self urlAction: theLine reportOn: report ].	(line beginsWith: 'Installer mantis fixBug:') ifTrue: [ ^self mantisAction: theLine reportOn: report ].			aBlock value.! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:14'!extractFromHtml: html option: allOrLast	|  start stop test in |	start := self markersBegin.	stop :=  self markersEnd.	test := self markersTest.			 	in := ReadWriteStream with: String new.			[ html upToAll: start; atEnd ] 		whileFalse: [			| chunk |			(allOrLast == #last) ifTrue: [ in resetToStart ]. 			chunk := html upToAll: stop.			self isSkipLoadingTestsSet ifTrue: [ chunk := chunk readStream upToAll: test ].			in nextPutAll: chunk. 		 ].	^self removeHtmlMarkupFrom: in reset	 ! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!mantisAction: line reportOn: report		| param mantis |		mantis := Installer mantis.		param :=  line readStream upTo: $: ; upTo: $..		mantis setBug: ((param readStream upTo: $'; atEnd)		 ifTrue: [  param ]		 ifFalse: [ param readStream upTo: $'; upTo: $' ]).		self reportSection: line on: report.			report nextPutAll: (mantis replaceEntitiesIn: mantis markersBegin readStream).		self reportFor: line page: mantis maScript on: report.		report nextPutAll: (mantis replaceEntitiesIn: mantis markersEnd readStream); cr.	! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 08:17'!reportFor: theLine page: thePage on: report  		[ thePage atEnd ] whileFalse: [ 		| line |		line := thePage nextLine.		self actionMatch: line reportOn: report ifNoMatch: [ report nextPutAll: line; cr. ] 		].! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:20'!reportSection: line on: report		report isEmpty ifFalse: [ report cr ].		report nextPutAll: '">>>> ' ; nextPutAll: (line copyWithout: $"); nextPut: $"; cr.	! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!urlAction: line reportOn: report  	url :=  line readStream upTo: $' ; upTo: $'.  		self reportSection: line on: report.	(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 		self reportFor: line page: pageDataStream on: report ! !!Installer methodsFor: 'action report' stamp: 'kph 1/8/2007 11:19'!webAction: line reportOn: report		package :=  line readStream upTo: $' ; upTo: $'.	self reportSection: line on: report.	 	url := self webFindUrlToDownload.		self reportFor: line page: pageDataStream on: report ! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 13:07'!answer: aString with: anAnswer^self answers add: ( Array with: aString with: anAnswer )! !!Installer methodsFor: 'auto answering' stamp: 'kph 10/17/2006 14:30'!suppress: aMessagemessagesToSuppress add: aMessage! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 13:06'!answers^ answers ifNil: [ answers := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!answers: anObject	"Set the value of answers"	answers := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!bug	"Answer the value of bug"	^ bug! !!Installer methodsFor: 'accessing' stamp: 'kph 12/21/2006 02:42'!date: anObject	"Set the value of markers"	date := anObject asDate! !!Installer methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc	 	^ desc! !!Installer methodsFor: 'accessing' stamp: 'kph 1/8/2007 07:22'!desc: anObject	desc := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:16'!infoself sm ifTrue: [ ^ self smInfo  ].self wsm ifNotNil: [ ^ self wsmInfo  ].! !!Installer methodsFor: 'accessing' stamp: 'kph 1/5/2007 00:08'!installself logErrorDuring: [	self mc ifNotNil: [ ^self mcInstall ].	self wsm ifNotNil: [ ^self wsmInstall ].	self sm ifTrue: [ ^self smInstall ].	self url ifNotNil: [ ^self urlInstall ].	self package ifNotNil: [ ^self webInstall ].] ! !!Installer methodsFor: 'accessing' stamp: 'kph 10/18/2006 11:29'!install: packageNameCollectionOrDetectBlockself package: packageNameCollectionOrDetectBlock.self install! !!Installer methodsFor: 'accessing' stamp: 'kph 12/21/2006 02:07'!isSkipLoadingTestsSet^SkipLoadingTests ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!ma	"Answer the value of ma"	^ ma! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!ma: aUrl 	"Set the value of host"	ma := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 1/4/2007 07:06'!markers	"Answer the value of markers"	^ markers ifNil: [ '<code st>..."test ...</code st>' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!markers: anObject	"Set the value of markers"	markers := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!mc	"Answer the value of mc"	^ mc! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 07:07'!mc: aUrl 	"Set the value of host"	mc := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/17/2006 14:30'!messagesToSuppress^ messagesToSuppress ifNil: [ messagesToSuppress := OrderedCollection new ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/19/2006 06:55'!messagesToSuppress: anObject	"Set the value of messagesToSuppress"	messagesToSuppress := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 2/1/2007 20:01'!open	self sm ifTrue: [ self classSMLoader open ].self mc ifNotNil: [self mcRepository morphicOpen: nil ].! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package	"Answer the value of package"	^ package! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:05'!package: anObject	"Set the value of package"	package := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:23'!packages	self sm ifTrue: [ ^self smPackages ].self mc ifNotNil: [ ^self mcRepository allFileNames ].self wsm ifNotNil: [ ^self wsmPackagesByName keys ].! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 05:06'!packages: anObject	"Set the value of packages"	packages := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:16'!password	"Answer the value of password"	^ password  ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!password: anObject	"Set the value of password"	password := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/8/2006 00:56'!printOn: s s nextPutAll: '(Installer'.self sm ifTrue: [ s nextPutAll: ' squeakmap' ].self ma ifNotNil: [ s nextPutAll: ' mantis' ].self wsm ifNotNil: [ s nextPutAll: ' websqueakmap' ].self url ifNotNil: [ s nextPutAll: ' url:''', self url,'''' ].self mc ifNotNil: [ s nextPutAll: ' repository:''', self mc,'''' ].s nextPut: $).self project ifNotNil: [ s nextPutAll: ' project:';  						nextPutAll: '''', self project, ''''.					   self package ifNotNil: [ s nextPutAll: '; '] ].					self package ifNotNil: [ s nextPutAll: ' package:';  						 nextPutAll: '''', self package asString, '''' ].					s nextPut: $..! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:30'!project	"Answer the value of project"	^ project! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:33'!project: anObject	"Set the value of project"	project := anObject.	^self copy.! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:55'!sm	"Answer the value of sm"	^ sm ifNil: [ false ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 06:38'!sm: anObject	"Set the value of sm"	sm := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 04:23'!url^url! !!Installer methodsFor: 'accessing' stamp: 'kph 11/7/2006 04:23'!url: aUrl  url := aUrl! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 04:15'!user	"Answer the value of user"	^ user ifNil: [ '' ]! !!Installer methodsFor: 'accessing' stamp: 'kph 10/15/2006 03:56'!user: anObject	"Set the value of user"	user := anObject! !!Installer methodsFor: 'accessing' stamp: 'kph 10/21/2006 05:50'!versions	self sm ifTrue: [ ^self smVersions ].self mc ifNotNil: [ ^self mcVersions ].self wsm ifNotNil: [ ^self wsmVersions ].! !!Installer methodsFor: 'script bindings' stamp: 'kph 1/8/2007 00:11'!bindingOf: aString 		Bindings isNil ifTrue: [ Bindings := Dictionary new].	(Bindings includesKey: aString)		ifFalse: [Bindings at: aString put: nil].	^ Bindings associationAt: aString.! !!Installer methodsFor: 'script bindings' stamp: 'kph 1/11/2007 02:03'!unload: categoryMatchesString  (SystemOrganization categoriesMatching: categoryMatchesString) do: [ :cat |      self logCR: 'Unloading ', cat. 	(MCPackage named: cat)  workingCopy unload.	SystemOrganization removeCategory: cat. ]."Until Mantis 5718 is addressed" Smalltalk at: #PackagePaneBrowser ifPresent: [ :ppbClass | ppbClass allInstancesDo: [ :ppb | ppb updatePackages ]  ]. Smalltalk at: #Browser ifPresent: [ :bClass | bClass allInstancesDo: [ :b | b updateSystemCategories ] ].! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!bug: aBugNo"Installer mantis viewBug: 5639."	| page text | 	self setBug: aBugNo.		page := self maPage. 	text := String streamContents: [ :str |						#('Bug ID' 'Category' 'Severity' 'Reproducibility' 'Date Submitted' 			'Date Updated' 'Reporter' 'View Status' 'Handler' 			'Priority' 'Resolution' 'Status' 'Product Version' 'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		].		str nextPutAll: 'Notes: '; cr.		(self maReadNotes: page) do: [ :note | str nextPutAll: note; cr; cr ].				str nextPutAll: 'Files: '; nextPutAll: self maFiles keys asArray printString.	]. 	^ text	! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:11'!bug: aBugNo fix: aFileName	^ self bug: aBugNo fix: aFileName date: nil! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:08'!bug: aBugNo fix: aFileName date: aDate 	| stream |	self setBug: aBugNo.	self logCR: 'obtaining ', aFileName, '...'.	stream := self maStreamForFile: aFileName.	self ditchOldChangeSetFor: aFileName.	self maCheckDateAgainst: aDate.	self install: aFileName from: stream.	self class fixesApplied add: aBugNo.			^ date! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:49'!bug: aBugNo retrieve: aFileName	 self setBug: aBugNo.	^ (self maStreamForFile: aFileName) contents! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!bug: aBugNo view: aFileName	| file list |		self setBug: aBugNo.		file :=  self maStreamForFile: aFileName.	list := self classChangeList new			scanFile:  file from: 1 to: file size.		 	self classChangeList open: list name: (aFileName, ' mantis: ', aBugNo printString) 		multiSelect: true.! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:10'!ensureFix: aBugNo	| fixesAppliedNumbers |		self setBug: aBugNo.		fixesAppliedNumbers := self class fixesApplied collect: [ :fixDesc | fixDesc asInteger ].		(fixesAppliedNumbers includes: bug) ifFalse: [ self fixBug: aBugNo ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/7/2007 16:18'!ensureFixes: aBugNos	aBugNos do: [ :bugNo | self ensureFixes: bugNo ].! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:40'!evaluate: streamstream fileIn.! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:12'!fixBug: aBugNo	^ self fixBug: aBugNo date: nil! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 11:45'!fixBug: aBugNo date: aDate	self setBug: aBugNo.	 	self install: self maUrl from: self maScript.		self maCheckDateAgainst: aDate.			! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:43'!install: aFileName from: stream| ext installSelector |	 	self log: 'installing...'. 	ext := aFileName copyAfterLast: $..	installSelector := ('install', ext asUppercase, ':from:') asSymbol.		self withAnswersDo:	[		(self respondsTo: installSelector)			ifTrue: [ self perform: installSelector with: aFileName with: stream ]			ifFalse: [ self installDefault: aFileName from: stream ].	]. 	self log: '.done' ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/30/2007 01:06'!installCS: aFileName from: stream	self ditchOldChangeSetFor: aFileName.	self newChangeSetFromStream: stream named: (self validChangeSetName: aFileName).! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installDefault: aFileName from: streamstream fileIn.! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installGZ: aFileName from: stream 	"FileIn the contents of a gzipped stream"	| zipped unzipped |	 	zipped := self classGZipReadStream on: stream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString.	unzipped reset.	self  newChangeSetFromStream: unzipped named:aFileName.	! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installMCZ: aFileName from: stream 	self classMczInstaller ifNotNilDo: [ :reader | ^reader installStream: stream].  	self classMCMczReader ifNotNilDo: [ :reader | ^(reader versionFromStream: stream) load]. 	self error: 'no monticello readers available'.  ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 06:42'!installSAR: aFileName from: stream  | newCS |	self classSARInstaller withCurrentChangeSetNamed: aFileName		do: [:cs | newCS := cs. self classSARInstaller new fileInFrom: stream].	newCS isEmpty ifTrue: [ self classChangeSet removeChangeSet: newCS ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: nil ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/4/2007 06:43'!justFixBug: aBugNo date: d	^self class skipLoadingTests: true during: [ self fixBug: aBugNo date: d ]! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 11:37'!maFiles  | file files bugPage id  |   files := Dictionary new.  bugPage := self maPage. [  id := bugPage upToAll: 'href="file_download.php?file_id='; upTo: $&.  file := bugPage upToAll: 'amp;type=bug"' ; upTo: $<.  ((file size > 1) and: [file first = $>]) ifTrue: [ files at: file copyWithoutFirst put: id ].  id notEmpty ] whileTrue.^files ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maPage  "  self mantis bug: 5251. " | page |page :=  self httpGet: self maUrl. date := ((self maRead: page field: 'Date Updated') value upTo: $ ) asDate. ^page reset! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 04:50'!maRead: page field: fieldKey	 | value | 	value := page upToAll: ('!!-- ', fieldKey, ' -->'); upToAll: '<td'; upTo: $>; upToAll: '</td>'.		page upTo: $<.		page peek = $t ifTrue: [ value := page upToAll: 'td'; upTo: $>; upToAll: '</td>' ].	  	^Association key: fieldKey value: value withBlanksTrimmed! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 05:54'!maReadNotes: page 	 |  notes note  | 	notes := OrderedCollection new.	[ page upToAll: 'tr class="bugnote"'; upTo: $>.	  page atEnd ]			whileFalse: [ 		note := (self removeHtmlMarkupFrom: (page upToAll: '</tr>') readStream) contents.		note := note withBlanksCondensed.		"note replaceAll: Character cr with: $ ."		note replaceAll: Character lf with: Character cr.		notes add: note  	].		^notes! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 10:01'!maScript 	^self extractFromHtml: self maPage option: #last! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:48'!maStreamForFile: aFileName	| fileId  | 	fileId :=  self maFiles at: aFileName ifAbsent: [ self error: aFileName, ' not found' ]. 	^ self httpGet: (self ma, 'file_download.php?file_id=' , fileId , '&type=bug').	 ! !!Installer methodsFor: 'mantis' stamp: 'kph 1/8/2007 09:54'!maUrl 	^ url := self ma, 'view.php?id=', bug asString ! !!Installer methodsFor: 'mantis' stamp: 'kph 12/18/2006 04:08'!maUrlFor: maBugNo 	^ url := self ma, 'view.php?id=', maBugNo asString  ! !!Installer methodsFor: 'mantis' stamp: 'kb 12/18/2006 13:01'!newChangeSetFromStream: aStream named: aName 	"This code is based upon ChangeSet-c-#newChangesFromStream:named: which is in 3.9,	implemented here for previous versions. The second branch is for 3.8, where ChangeSets	are loaded by ChangeSorter. "	| oldChanges newName newSet newStream |	(self classChangeSet respondsTo: #newChangesFromStream:named:) 		ifTrue: [ ^self classChangeSet newChangesFromStream: aStream named:aName ].	(self classChangeSorter respondsTo: #newChangesFromStream:named:)		ifTrue: [ ^self classChangeSorter newChangesFromStream: aStream named: aName ].	oldChanges := ChangeSet current. 	"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self classChangeSet basicNewNamed: newName.	[newSet		ifNotNil: [(aStream respondsTo: #converter:)				ifTrue: [newStream := aStream]				ifFalse: [newStream := self classMultiByteBinaryOrTextStream with: aStream contentsOfEntireFile.					newStream reset].			self classChangeSet newChanges: newSet.			newStream setConverterForCode.			newStream fileInAnnouncing: 'Loading ' , newName , '...'.			Transcript cr; show: 'File ' , aName , ' successfully filed in to change set ' , newName].	aStream close]		ensure: [self classChangeSet newChanges: oldChanges].	 	^ newSet! !!Installer methodsFor: 'mantis' stamp: 'edc 5/8/2007 16:45'!preambleCsForRB: aBugNo"Installer mantis preambleCsForRB: 5936."	| page text   | 	self setBug: aBugNo.		page := self maPage. 	text := String streamContents: [ :str |						#('Reporter'  'Summary' 'Description' 'Additional Information' ) 				do: [ :field |						| f |						f := self maRead: page field: field.			str nextPutAll: f key; nextPutAll: ': '; nextPutAll: f value; cr.		]	]. 	^ text	! !!Installer methodsFor: 'mantis' stamp: 'kph 1/30/2007 14:18'!setBug: stringOrNumber   | str |  stringOrNumber isInteger ifTrue: [ bug := stringOrNumber. desc := ''. ^self ].  bug := stringOrNumber asInteger. str := str printString.  desc := stringOrNumber copyFrom: (str size + 1) to: (stringOrNumber size) ! !!Installer methodsFor: 'mantis' stamp: 'kph 12/21/2006 01:28'!skipTests! !!Installer methodsFor: 'mantis' stamp: 'kph 12/23/2006 06:02'!viewBug: aBugNo	^Workspace new contents: (self bug: aBugNo); openLabel: ('Mantis ', aBugNo printString).! !!Installer methodsFor: 'class references' stamp: 'kph 12/23/2006 02:05'!classChangeList^Smalltalk at: #ChangeList  ifAbsent: [ self error: 'ChangeList not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 22:17'!classChangeSet^Smalltalk at: #ChangeSet  ifAbsent: [ self error: 'ChangeSet not present' ]! !!Installer methodsFor: 'class references' stamp: 'kb 12/18/2006 12:40'!classChangeSorter^Smalltalk at: #ChangeSorter ifAbsent: [ self error: 'ChangeSorter not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 22:16'!classGZipReadStream^Smalltalk at: #GZipReadStream  ifAbsent: [ self error: 'Compression not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:42'!classHTTPSocket^Smalltalk at: #HTTPSocket ifAbsent: [ self error: 'Network package not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 03:15'!classMCHttpRepository^Smalltalk at: #MCHttpRepository ifAbsent: [ self error: 'Monticello not present' ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 02:46'!classMCMczReader^Smalltalk at: #MCMczReader ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/17/2006 02:44'!classMczInstaller^Smalltalk at: #MczInstaller ifAbsent: [ nil ]	! !!Installer methodsFor: 'class references' stamp: 'kph 11/23/2006 03:18'!classMultiByteBinaryOrTextStream^Smalltalk at: #MultiByteBinaryOrTextStream  ifAbsent: [ self error: 'MultiByteBinaryOrTextStream not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:40'!classSARInstaller^Smalltalk at: #SARInstaller  ifAbsent: [ self error: 'SARInstaller not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 2/1/2007 20:02'!classSMLoader^Smalltalk at: #SMLoader  ifAbsent: [ self error: 'SqueakMap Loader not present' ]! !!Installer methodsFor: 'class references' stamp: 'kph 11/16/2006 15:40'!classSMSqueakMap^Smalltalk at: #SMSqueakMap  ifAbsent: [ self error: 'SqueakMap not present' ]! !!Installer methodsFor: 'utils' stamp: 'kph 1/30/2007 15:15'!ditchOldChangeSetFor: aFileName 	| changeSetName | 	changeSetName := (self validChangeSetName: aFileName) sansPeriodSuffix.	(self classChangeSet named: changeSetName)		ifNotNil: [  					(self logCR:'Removing old change set ', changeSetName) cr.				self classChangeSet removeChangeSet: (self classChangeSet named: changeSetName) ].! !!Installer methodsFor: 'utils' stamp: 'kph 12/18/2006 06:50'!httpGet: aUrl	| page |	page := self classHTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ self error: 'unable to contact web site' ]. 	^ page	! !!Installer methodsFor: 'utils' stamp: 'kph 12/21/2006 02:51'!maCheckDateAgainst: okDate	(okDate notNil and: [date < okDate asDate ]) ifTrue: [ self notify: 'bug ', self bug asString, ' updated on ', date printString ]. ! !!Installer methodsFor: 'utils' stamp: 'kph 1/7/2007 15:57'!viewUrl	^Workspace new contents: (self urlGet contents); openLabel: self urlToDownload.! !!Installer methodsFor: 'url' stamp: 'kph 1/10/2007 04:50'!isHtmlStream: page	"matches  '<!!DOCTYPE HTML', and <html>' "		| first |			first := (page next: 14) asUppercase.		^ (first = '<!!DOCTYPE HTML') | (first beginsWith: '<HTML>')	! !!Installer methodsFor: 'url' stamp: 'kph 12/21/2006 01:54'!markersBegin		 	 	 ^ self markers upTo: $.! !!Installer methodsFor: 'url' stamp: 'kph 12/23/2006 04:02'!markersEnd		"return the third marker or the second if there are only two"		| str  a |		 	 	 str := self markers readStream.	 a := str upToAll: '...'; upToAll: '...'.	 str atEnd  ifTrue: [ ^a ] ifFalse: [ ^str upToEnd ]	! !!Installer methodsFor: 'url' stamp: 'kph 12/21/2006 01:56'!markersTest		 	 	 ^ self markers readStream upToAll: '...'; upToAll: '...'! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 11:16'!removeHtmlMarkupFrom: in 	| out | 	out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: (in upTo: $<).		(((in upTo: $>) asLowercase beginsWith: 'br') and: [ (in peek = Character cr) ]) ifTrue: [ in next ].		].		^self replaceEntitiesIn: out reset.! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 11:15'!replaceEntitiesIn: in	| out |		out := ReadWriteStream on: (String new: 100).	[ in atEnd ] whileFalse: [ 		out nextPutAll: ((in upTo: $&) replaceAll: Character lf with: Character cr).		in atEnd ifFalse: [ out nextPutAll: (self class entities at: (in upTo: $;) ifAbsent: '?') ].		].	^out reset! !!Installer methodsFor: 'url' stamp: 'kph 1/7/2007 02:15'!urlGet^ self urlGet: self urlToDownload! !!Installer methodsFor: 'url' stamp: 'kph 1/10/2007 04:35'!urlGet: aUrl	| page |	page := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.   	(page respondsTo: #reset)  ifFalse: [ ^ nil ]. 	(self isHtmlStream: page) ifTrue: [ page := self extractFromHtml: page option: nil ].	^ page reset	! !!Installer methodsFor: 'url' stamp: 'kph 1/8/2007 07:03'!urlInstall "Installer installUrl: 'wiki.squeak.org/742'." 	self logCR: 'retrieving ', self urlToDownload , ' ...'.		(pageDataStream := self urlGet: self urlToDownload) 		ifNil: [ self error: 'unable to contact host' ].	 	self install: self urlToDownload from: pageDataStream.		^ pageDataStream ! !!Installer methodsFor: 'url' stamp: 'kph 1/4/2007 23:49'!urlToDownload	^ (self url, (self package ifNil: [ '' ])) asUrl asString.	 ! !!Installer methodsFor: 'url' stamp: 'kph 1/7/2007 02:16'!urlView^ self urlGet: self urlToDownload! !!Installer methodsFor: 'url' stamp: 'kb 12/18/2006 13:30'!validChangeSetName: aFileName	" dots in the url confuses the changeset loader. I replace them with dashes" 	self url ifNotNil: [ | asUrl |		asUrl := Url absoluteFromText: aFileName.		^String streamContents: [:stream |			stream nextPutAll: (asUrl authority copyReplaceAll: '.' with: '-').			asUrl path allButLastDo: [:each |				stream					nextPutAll: '/';					nextPutAll: (each copyReplaceAll: '.' with: '-') ].			stream				nextPutAll: '/';				nextPutAll: asUrl path last ] ].	^aFileName! !!Installer methodsFor: 'logging' stamp: 'kph 12/18/2006 04:51'!log: text^Transcript show: text.! !!Installer methodsFor: 'logging' stamp: 'kph 12/18/2006 04:53'!logCR: text^ Transcript cr; show: text! !!Installer methodsFor: 'logging' stamp: 'kph 1/30/2007 01:28'!logErrorDuring: block(IsSetToTrapErrors == false) ifTrue: [ ^ block value ].block on: Error do: [ :e | self logCR: e messageText. ]! !!Installer methodsFor: 'searching' stamp: 'kph 1/4/2007 23:59'!match: aMatch	^self packagesMatching: aMatch! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:19'!packagesMatching: aMatchself sm ifTrue: [ ^ (self packages select: [ :p | aMatch match: p name ]) collect: [ :p | self copy package: p name; yourself ] ].self mc ifNotNil: [ ^ (self packages select: [ :p | ( aMatch , '.mcz' ) match: p ]) collect: [ :p | self copy package: p ; yourself ] ].self wsm ifNotNil: [ ^ (self packages select: [ :p | ( aMatch) match: p ]) collect: [ :p | self copy package: p ; yourself ] ].^'search type not supported'! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:19'!search: aMatchself sm ifTrue: [ ^ self smSearch: ('*',aMatch,'*') ].self mc ifTrue: [ ^ self mcSearch: ('*',aMatch,'*')  ].self wsm ifNotNil: [ ^ self wsmSearch: ('*',aMatch,'*')  ].^'search type not supported'! !!Installer methodsFor: 'searching' stamp: 'kph 11/12/2006 23:28'!smSearch: aMatch  	| results |		results := Set new.	self packages do: [ :pkg |		({ 'name:',pkg name.		   'summary:', pkg summary.		   'description:', pkg description.		   'author:', pkg author. } anySatisfy: [ :field | aMatch match: field ])		 ifTrue: [ results add: (self copy package: pkg name) ]. 	].	^results! !!Installer methodsFor: 'monticello' stamp: 'kph 11/17/2006 03:16'!mcInstall	| repository sortMczs files fileToLoad  version detectFileBlock  count |	self logCR: 'installing ', self package asString, '...'.	self package isString ifTrue: [ detectFileBlock := [ :file | file beginsWith: self package ] ].	(self package isKindOf: Array) 			ifTrue: [ detectFileBlock :=  [ :file | (self package detect: [ :item | file beginsWith: item ] ifNone: [ false ]) ~= false ] ].	self package isBlock ifTrue: [ detectFileBlock := self package ].  	repository := self mcRepository.	sortMczs := [:a :b |         	[(a findBetweenSubStrs: #($.)) allButLast last asInteger > (b findBetweenSubStrs: #($.)) allButLast last asInteger] on: Error do: [:ex | false]].	"several attempts to read files - repository readableFileNames sometimes fails"	count := 0. fileToLoad := nil.		[count := count + 1.	 (fileToLoad = nil) and:[ count < 5 ] ] 		whileTrue: [						files := repository readableFileNames asSortedCollection: sortMczs.						fileToLoad := files detect: detectFileBlock ifNone: [ nil ].																						].	version := repository versionFromFileNamed: fileToLoad.	version workingCopy repositoryGroup addRepository: repository.	repository creationTemplate: 'MCHttpRepository        	location: ''', self mcUrl, '''        	user: ''', self user, '''        	password: ''', self password, ''''.	self log: ' ', version fileName, '...'.	self withAnswersDo: [ version load ].	self log: 'done'.! !!Installer methodsFor: 'monticello' stamp: 'kph 11/16/2006 17:47'!mcRepository^self classMCHttpRepository location: (self mcUrl) user: self user password: self password.! !!Installer methodsFor: 'monticello' stamp: 'kph 12/17/2006 17:58'!mcUrl^ self mc, (self project ifNil: [''])! !!Installer methodsFor: 'monticello' stamp: 'kph 10/21/2006 05:47'!mcVersions^ (self packages select: [ :p | ( self package,'-*.mcz' ) match: p ]) collect: [ :p | self copy package: p  ; yourself ]. ! !!Installer methodsFor: 'monticello' stamp: 'kph 10/21/2006 06:52'!withAnswersDo: aBlock	(aBlock respondsTo: #valueSuppressingMessages:supplyingAnswers: )		ifTrue: [aBlock valueSuppressingMessages: self messagesToSuppress supplyingAnswers: self answers.]		ifFalse: [ aBlock value ]! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/21/2006 06:54'!smInstall 	| pkgAndVersion releases release |	pkgAndVersion := self smPackageAndVersion.	self logCR: 'installing ', self package, ' from SqueakMap...'.	releases := self smReleasesForPackage: pkgAndVersion first. 		release := pkgAndVersion last isEmpty ifTrue: [ releases last ]					ifFalse:[ releases detect: [ :rel | rel version = pkgAndVersion last ] ]. 		self withAnswersDo: [ release install ].	self log: ' done'.! !!Installer methodsFor: 'squeakmap' stamp: 'kph 10/17/2006 15:24'!smPackageAndVersion| p |p := ReadStream on: self package .^Array with: (p upTo: $() with: (p upTo: $)).! !!Installer methodsFor: 'squeakmap' stamp: 'kph 2/1/2007 19:14'!smPackages	^self classSMSqueakMap default packagesByName! !!Installer methodsFor: 'squeakmap' stamp: 'kph 11/16/2006 15:40'!smReleasesForPackage: name ^(self classSMSqueakMap default packageWithName: name) releases! !!Installer methodsFor: 'squeakmap' stamp: 'kph 11/12/2006 16:54'!smVersions ^ (self smReleasesForPackage: self package) collect: [ :v | self copy package: (v package name,'(',v version,')'); yourself. ]  ! !!Installer methodsFor: 'web install' stamp: 'kph 1/30/2007 00:53'!webFindUrlToDownload	self class webSearchPath do: [ :pathSpec | 		| potentialUrl readPathSpec  |			readPathSpec := pathSpec readStream.		potentialUrl := (readPathSpec upTo: $*), package, (readPathSpec upToEnd ifNil: [ '' ]).			pageDataStream := self urlGet: potentialUrl.				pageDataStream notNil ifTrue: [ ^potentialUrl ]	].	^nil! !!Installer methodsFor: 'web install' stamp: 'kph 1/30/2007 00:56'!webInstall "Installer install: 'MyPage'." 	url := self webFindUrlToDownload ifNil: [ self logCR: 'url not found'. self error: 'url not found' ].		self logCR: 'found ',  url, ' ...'.		pageDataStream size > 0 		ifTrue: [ self install: url from: pageDataStream ]		ifFalse: [ self logCR: '...',url,' was empty' ].		^ pageDataStream.	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 01:37'!wsm	"Answer the value of wsm"		^ wsm! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 01:37'!wsm: aUrl 	"Set the value of host"	wsm := aUrl last = $/ ifTrue: [ aUrl ] ifFalse: [ aUrl, '/' ]! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:49'!wsmDownloadUrl | pkgAndVersion packageId packageName packageVersion releaseAutoVersion downloadPage |	pkgAndVersion := self smPackageAndVersion.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self wsmPackagesByName at: packageName.	releaseAutoVersion := (self wsmReleasesFor: packageId) at: packageVersion.					 	downloadPage := self httpGet: (self wsm,'packagebyname/', packageName,'/autoversion/', releaseAutoVersion,'/downloadurl') asUrl asString.				 		 	^ downloadPage contents	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 1/8/2007 06:43'!wsmInstall 	| downloadUrl |	self logCR: 'finding ', self package, ' from websqueakmap(', self wsm, ') ...'.	downloadUrl := self wsmDownloadUrl.		self logCR: 'found at ', downloadUrl asString, ' ...'.	 	self install: downloadUrl from: (self httpGet: downloadUrl).	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:51'!wsmPackagesByName	| html id name | 		packages ifNotNil: [ ^packages ].		packages := Dictionary new.		html := self httpGet: (self wsm, 'packagesbyname').		[		id := html upToAll: '/package/'; upToAll: '">'.		name := html upTo: $<.				(id notEmpty and: [ name notEmpty ]) 	] whileTrue: [ packages at: name put: id ].	^ packages		! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 12/18/2006 06:50'!wsmReleasesFor: packageId	| html autoVersion version releases |			releases := Dictionary new.		html := self httpGet: (self wsm, '/package/', packageId ).		[		releases at: #latest put: autoVersion.		autoVersion := html upToAll: '/autoversion/'; upTo: $".		version := html upTo: $-; upTo: $<.				(autoVersion notEmpty and: [version notEmpty ]) 	] whileTrue: [ releases at: version put: autoVersion ].	^ releases	! !!Installer methodsFor: 'websqueakmap' stamp: 'kph 10/21/2006 06:04'!wsmVersions| pkgAndVersion packageId packageName packageVersion versions |	pkgAndVersion := self smPackageAndVersion.	packageName := pkgAndVersion first.	packageVersion := pkgAndVersion last.	packageVersion isEmpty ifTrue: [ packageVersion := #latest ].	packageId := self wsmPackagesByName at: packageName.		versions := (self wsmReleasesFor: packageId) keys.	versions remove: #latest.		^ versions collect: [ :version | self copy package: (packageName,'(', version ,')'); yourself ]. ! !!Installer commentStamp: 'kph 1/7/2007 22:53' prior: 0!Installer provides a simple Domain Specific Language for installing packages from monticello and squeakmap of various version.One design decision is to be able to paste scripts a workspace and run and tested from there without any special editing.Installer can also be used as a squeak startup document with various commandline parameters.example 1 (non working example)unix$ squeak Squeak3.8-7067 http://installer.pbwiki.com/f/Installer.st Url="http://..." saveas="MyImage" postinstall=Tester done=quitThis will load installer as the startup document, installer will install a file/script from the given url, then the image will be saved in the given filename, and processing is then passed on to the class Tester, once complete the image will quit.supported parameters:P|PATH=prefix1*suffix1;...;prefixN*suffixNI|IN|INSTALL=aPage (needs PATH)U|URL=aUrlO|OUT|SAVEAS=aFileName+S|SAVEP|TEST|POSTINSTALL=aClassName | aPage(given PATH) | aUrlDONE= save | quit | save&quit | aClassName+SKIPTESTSexample 2: (working example)unix$ squeak Squeak3.8-7067 http://installer.pbwiki.com/f/Installer.st path=wiki.squeak.org/squeak/;installer.pbwiki.com/*-alt in=CommandLineExample2 done=quit.===Examples - Using SqueakMap1)squeakmap := Installer squeakmap.squeakmap install: 'DynamicBindings'.squeakmap open. "opens the squeak map loader gui"2)Installer squeakmap install: 'DynamicBindings'.3) Alternatively using websqueakmap which uses http (similar usage api to squeakmap)squeakmap := Installer websqueakmap.squeakmap package: 'DynamicBindings'; install.4) Abbreviated instanciationsqueakmap := Installer sm. "squeakmap"squeakmap := Installer wsm. "web-squeakmap"5) Finding Packages by Name(Installer sm match: 'Labby*') explore.6) Obtaining List of Package Versions(Installer sm package: 'Labby & Walker'; versions)  explore.  6) Searching PackagesInstaller sm search: 'seaside'.Installer sm search: 'author:*Smith'. "fields available for searching: author: name:, summary:,description:"7) Specify specific version of a package for installationInstaller sm install: 'Labby(17)'.Examples - Using Monticello1)squeaksource := Installer repository: 'http://www.squeaksource.com'.seaside := squeaksource project: 'Seaside'.seaside install: 'Comet-lr.8';		install: 'Scriptaculous'.2) squeaksource := Installer repository: 'http://www.squeaksource.com'		squeaksource project: 'Seaside';			  install: 'Comet-lr.8;			  install: 'Scriptaculous'.3) Supplying user/password.squeaksource := Installer repository: 'http://www.squeaksource.com'.squeaksource user: 'me'; password: 'asecret'.4) Abbreviated instanciation for convenience.squeaksource := Installer squeakSource.orsqueaksource := Installer ss.Examples - install straight from a url		1a)(Installer url: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/MakeTestsGreen39.cs') install.1b)Installer installUrl: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/MakeTestsGreen39.cs'.2)| page |page := Installer url: 'http://minnow.cc.gatech.edu/squeak/uploads/5889/'.page package: 'MakeTestsGreen39.cs'.page install.3)In html page scripts are delimited by <code st>...</code st>| page |page := Installer url: 'http://wiki.squeak.org/squeak/742'.page install.4)specify your own delimeters| page |page := Installer url: 'http://wiki.squeak.org/742'.page markers: 'beginning of script...end of script'.page install.Note: Scripts embedded in html or a swiki page may need to escape some entities.Supported entities are &amp; &gt; &lt; &star; &quot; (see Installer-c-entities)Examples - Using Mantis1 . Viewing a file uploaded to a mantis bug reportInstaller mantis bug: 4874 view: 'Join.4.cs'.1. Installing a file uploaded to a mantis bug reportInstaller mantis bug: 4874 fix: 'Join.4.cs'.2. as above, inform user if bug report has been updated since a given date Installer mantix	bug: 4874 fix: 'JoinTest.1.cs' date: '12-18-06'. 	3. Install or view a fix for a given bug.Installer mantis viewBug: 4874.Installer mantis fixBug: 4874.The fix script is published in a note added to the bug report page with the following syntax"fix begin" Installer mantis bug: 474 fix: 'Join.4.cs'."fix test" Installer mantis bug: 474 fix: 'JoinTest.1.cs' date: '12-18-06'. "fix end"4. Install a fix for a given bug, ignoring all test code(test code being delimeted by: "fix test" ... "fix end" )Installer mantis justFixBug: 474.orInstaller mantis justFixBug: 474 date: '12-19-06'.!!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/21/2006 02:08'!cancelSkipLoadingTests"sets a flag to un-ignore loading of the testing portion of scripts embedded in pages"SkipLoadingTests := false. ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/11/2007 00:17'!do: webPageNameself webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].^(self new package: webPageName) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/23/2006 05:46'!entities^ Entities ifNil: [ Entities := "enough entities to be going on with"  Dictionary new.Entities at: 'lt' put: '<';	at: 'gt' put: '>';	at: 'amp' put: '&';	at: 'star' put: '*';	at: 'quot' put: '"';	at: 'nbsp' put: ' '; 	yourself] ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/7/2007 16:13'!fixesApplied^ Fixes ifNil: [ Fixes := OrderedCollection new ].! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 07:42'!install: webPageNameself webSearchPath isEmpty ifTrue: [ ^self error: 'search path not set' ].^(self new package: webPageName) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 07:42'!installUrl: urlString^ (self url: urlString) install.! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 12/21/2006 01:49'!skipLoadingTests"sets a flag to ignore loading of the testing portion of scripts embedded in pages"SkipLoadingTests := true. ! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/4/2007 06:42'!skipLoadingTests: yesNo during: block	| oldValue |	oldValue := SkipLoadingTests.	SkipLoadingTests := yesNo.		block ensure:[ SkipLoadingTests := oldValue ].! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 1/8/2007 08:37'!view: webPageNameOrUrl| theReport |theReport := String streamContents: [ :report | 	(webPageNameOrUrl beginsWith: 'http://') ifTrue: [ 		self new urlAction: ('Installer installUrl: ', (webPageNameOrUrl printString),'.')  							 reportOn: report.	]	ifFalse: [		self new webAction: ('Installer install: ', (webPageNameOrUrl printString),'.')  							 reportOn: report.	].].Workspace new contents: (theReport contents); openLabel: webPageNameOrUrl.^theReport contents! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/21/2006 01:38'!websqueakmap^self new wsm: 'http://map.squeak.org'; yourself! !!Installer class methodsFor: 'as yet unclassified' stamp: 'kph 10/21/2006 01:38'!websqueakmap: host^self new wsm: host; yourself! !!Installer class methodsFor: 'accessing system' stamp: 'kph 2/14/2007 07:36'!classProjectLauncher^Smalltalk at: #ProjectLauncher ifAbsent: [ self error: 'ProjectLauncher not present' ]! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:52'!classes^ Smalltalk! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:50'!smalltalkImage^ SmalltalkImage current! !!Installer class methodsFor: 'accessing system' stamp: 'kph 1/5/2007 02:53'!sourceFiles^ SourceFiles! !!Installer class methodsFor: 'documentation' stamp: 'kph 1/10/2007 04:52'!history"7 Jan 2007  !!Installer fixBug: <aBugNo>aBugNo can now be a number or a string, beginning with a number. This allows the mantis bug report summary to be used verbatim.It also provides more infomarion for Installer to support self documentation.!!Install fix if not already installed Installer ensureFix: <aBugNoOrString> Installer ensureFixes: #(1 2 3 4)Installer now keeps a list of fix <aBugNoOrString> that have been installed up to this point.#ensureFix: will only install the fix if it has not already been loaded.note that only the bugNumber not the description is significant in the check.8 Jan 2007!!Installer view: <webPageNameOrUrl>Provided that web page based scripts follow some simple rules, installer can collate the scripts from web pages into a single workspace where you can manually 'doit' portions as you wish.The report generation is not very clever, it only matches on: 'Installer install:' ,  'Installer installUrl:', and 'Installer mantis fixBug:' note these lines must be properly completed with an ending $. (period).also invoked by commandline option VIEW=<webPageNameOrUrl>10 Jan 2007!!Now matches simpler htmlCheck for an html page, now matches'<!!DOCTYPE HTML' and <html> the allows use of pbwiki's raw=bare option which returns iframe embeddable html without the usual headers."! !!Installer class methodsFor: 'instanciation' stamp: 'kph 3/14/2007 21:07'!mantis	^ self mantis: 'http://bugs.squeak.org/'! !!Installer class methodsFor: 'instanciation' stamp: 'kph 12/21/2006 04:26'!mantis: host^self new	ma: host; 			markers: '&quot;fix begin&quot;...&quot;fix test&quot;...&quot;fix end&quot;'; 			yourself.! !!Installer class methodsFor: 'instanciation' stamp: 'kph 10/15/2006 06:37'!squeakmap^self new sm: true; yourself! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/16/2007 19:28'!path: aString	"convenience abbreviation"	self webSearchPathFrom: aString! !!Installer class methodsFor: 'accessing' stamp: 'kph 11/12/2006 16:37'!repository: host  ^self new mc: host ! !!Installer class methodsFor: 'accessing' stamp: 'kph 11/10/2006 00:48'!url: urlString^self new url: urlString; yourself! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/5/2007 00:18'!webSearchPath"a search path item, has the following format. prefix*suffix"^ WebSearchPath ifNil: [ WebSearchPath := OrderedCollection new ].! !!Installer class methodsFor: 'accessing' stamp: 'kph 1/5/2007 04:19'!webSearchPathFrom: string	| reader result |		reader := string readStream.	result := OrderedCollection new.		[ reader atEnd ] whileFalse: [ result add: (reader upTo: $;) ].	WebSearchPath := result.! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/12/2006 16:30'!sm^self squeakmap! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/17/2006 01:52'!squeaksource^self repository: 'http://www.squeaksource.com'! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/17/2006 01:53'!ss^self squeaksource ! !!Installer class methodsFor: 'instanciation-abbreviated' stamp: 'kph 11/12/2006 16:35'!wsm^self websqueakmap! !!Installer class methodsFor: 'utility' stamp: 'kph 1/10/2007 15:27'!unload: categoryMatchesString ^ self new unload: categoryMatchesString! !!Integer methodsFor: 'printing' stamp: 'JPF 6/26/2007 21:11'!hex"receiver is in range 0 to 255. Returns a two 'digit' hexadecimal representation of the receiver.If you want no padding use asHexDigit or printStringHex. i.e.     15 printStringHex ==  'F'     15 asHexDigit == $F     15 hex == '0F'"^self printStringBase: 16 length: 2 padded: true! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index	| word |	<primitive: 165>	word := self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:40'!at: index put: anInteger	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word := 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[word := anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 3/3/2001 23:34'!atAllPut: anInteger	| word |	anInteger < 0		ifTrue:["word := 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[word := anInteger].	self primFill: word.! !!Interval methodsFor: 'accessing' stamp: 'BG 6/15/2004 22:58'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock   "  startIndex is an positive integer, the collection index where the search is started. "   " during the computation of  val , floats are only used when the receiver contains floats "   | index val |   (self rangeIncludes: anElement)       ifFalse: [^0].   	val _ (anElement - self first)  / self increment.	val fractionPart abs * 100000000 < step abs	  ifFalse: [^0]	  ifTrue: [index := val rounded + 1].   " finally, the value of  startIndex  comes into play: "   ^index < startIndex      ifTrue: [0]      ifFalse: [index].! !!Interval methodsFor: 'enumerating'!collect: aBlock	| nextValue result |	result := self species new: self size.	nextValue := start.	1 to: result size do:		[:i |		result at: i put: (aBlock value: nextValue).		nextValue := nextValue + step].	^ result! !!Interval methodsFor: 'enumerating'!do: aBlock	| aValue |	aValue := start.	step < 0		ifTrue: [[stop <= aValue]				whileTrue: 					[aBlock value: aValue.					aValue := aValue + step]]		ifFalse: [[stop >= aValue]				whileTrue: 					[aBlock value: aValue.					aValue := aValue + step]]! !!Interval methodsFor: 'enumerating' stamp: 'apb 4/22/2007 12:38'!reverseDo: aBlock 	"Evaluate aBlock for each element of my interval, in reverse order."	| aValue |	aValue := self last.	step < 0		ifTrue: [[start >= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]		ifFalse: [[start <= aValue]				whileTrue: [aBlock value: aValue.					aValue := aValue - step]]! !!Interval methodsFor: 'private'!setFrom: startInteger to: stopInteger by: stepInteger	start := startInteger.	stop := stopInteger.	step := stepInteger! !!Interval methodsFor: 'private' stamp: 'di 4/24/2000 13:56'!valuesInclude: aNumber	"Private - answer whether or not aNumber is one of the enumerated values in this interval."	| val |	val := (aNumber - self first) asFloat / self increment.	^ val fractionPart abs < (step * 1.0e-10)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:34'!testDo	| s i |	s := OrderedCollection new.	i := (10 to: 20).	i do: [ :each | s addLast: each].	self assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:35'!testReverseDo	| s i |	s := OrderedCollection new.	i := 10 to: 20.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:36'!testReverseUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		reverseDo: [:each | s addFirst: each].	self		assert: (s hasEqualElements: i)! !!IntervalTest methodsFor: 'tests' stamp: 'apb 4/22/2007 12:39'!testUnevenDo	| s i |	s := OrderedCollection new.	i := 10 to: 20 by: 3.	i		do: [:each | s addLast: each].	self		assert: (s hasEqualElements: i)! !!KedamaAngleToTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 10:57'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'thetaTo' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaAngleToTile methodsFor: 'initialization' stamp: 'yo 6/17/2004 10:03'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getAngleTo:.	self addTile.! !!KedamaAngleToTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 11:19'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'thetaTo' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:45'!getAttribute: aSymbol of: anObject	| attributes |	attributes := dictionaries at: anObject ifAbsent: [^ nil].	^ attributes at: aSymbol ifAbsent: [nil].! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:46'!initialize	dictionaries := IdentityDictionary new.! !!KedamaAttributeDictionary methodsFor: 'all' stamp: 'yo 8/28/2004 00:46'!setAttribute: aSymbol of: anObject to: value	| attributes |	attributes := dictionaries at: anObject ifAbsentPut: [IdentityDictionary new].	attributes at: aSymbol put: value.! !!KedamaBounceOnColorTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 10:56'!addPlayerTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width + 6.	m2 := ColorTileMorph new.	"m3 := Morph new extent: 12@8; color: (Color r: 0.8 g: 0.0 b: 0.0)."	desiredW := desiredW + m2 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	"m2 addMorph: m3."	m2 position: ((bounds center x - (m2 width // 2)) + 3)@ (bounds top + 1).	self addMorphBack: m2.	self addMorphFront: m1.	self addMorphFront: label.	playerTile := m1.	colorTile := m2.! !!KedamaBounceOnColorTile methodsFor: 'initialization' stamp: 'yo 9/28/2004 18:43'!initialize	super initialize.	type := #Player.	operatorOrExpression := #bounceOn:color:.	self addPlayerTile.! !!KedamaBounceOnColorTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:56'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: playerTile.! !!KedamaBounceOnTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 10:58'!addPlayerTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	playerTile := m1.! !!KedamaBounceOnTile methodsFor: 'initialization' stamp: 'yo 9/27/2004 14:53'!initialize	super initialize.	type := #Player.	operatorOrExpression := #bounceOn:.	self addPlayerTile.! !!KedamaBounceOnTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:56'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'bounce on' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: playerTile.! !!KedamaCategoryViewer methodsFor: 'support' stamp: 'yo 4/3/2005 23:14'!booleanPhraseFromPhrase: phrase	| outerPhrase |	outerPhrase := super booleanPhraseFromPhrase: phrase.	outerPhrase replacePlayerInReadoutWith: scriptedPlayer.	^ outerPhrase.! !!KedamaCategoryViewer methodsFor: 'get/set slots' stamp: 'yo 4/4/2005 08:41'!getterTilesFor: getterSelector type: aType	| phrase |	phrase := super getterTilesFor: getterSelector type: aType.	phrase replacePlayerInReadoutWith: scriptedPlayer.	^ phrase.! !!KedamaDistanceToTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 10:59'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'distanceTo' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaDistanceToTile methodsFor: 'initialization' stamp: 'yo 6/14/2004 15:58'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getDistanceTo:.	self addTile.! !!KedamaDistanceToTile methodsFor: 'tile protocol' stamp: 'yo 1/30/2005 10:59'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'distanceTo' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaExamplerPlayer methodsFor: 'player protocol' stamp: 'yo 9/27/2004 16:24'!addInstanceVarNamed: aName withValue: aValue	self basicAddInstanceVarNamed: aName withValue: aValue.	"turtles := kedamaWorld turtlesOf: self."	turtles addInstanceVarVectorNamed: aName withValue: aValue.! !!KedamaExamplerPlayer methodsFor: 'player protocol' stamp: 'yo 3/25/2005 11:45'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	turtles setVectorSlotTypeFor: slotName typeChosen: typeChosen.	sequentialStub ifNotNil: [sequentialStub setScalarSlotTypeFor: slotName typeChosen: typeChosen].	self updateAllViewers.	"does siblings too"! !!KedamaExamplerPlayer methodsFor: 'subclass players management' stamp: 'yo 9/27/2004 16:34'!createSequenceStub	| class |	class := self class createSequencialStubSubclass.	sequentialStub := class new.	sequentialStub kedamaWorld: kedamaWorld.	sequentialStub examplerPlayer: self.	sequentialStub turtles: turtles.! !!KedamaExamplerPlayer methodsFor: 'subclass players management' stamp: 'yo 9/28/2004 14:03'!createTurtles	turtles := self class createTurtleSubclass new.	turtles kedamaWorld: kedamaWorld.	turtles exampler: self.	^ turtles.! !!KedamaExamplerPlayer methodsFor: 'method management' stamp: 'yo 9/27/2004 16:25'!compileInstVarAccessorsFor: varName	self basicCompileInstVarAccessorsFor: varName.	"turtles := kedamaWorld turtlesOf: self."	turtles compileVectorInstVarAccessorsFor: varName.	sequentialStub compileScalarInstVarAccessorsFor: varName.! !!KedamaExamplerPlayer methodsFor: 'debug support' stamp: 'yo 10/22/2004 07:26'!copyAllMethodsAgain	| c result |	c := turtles class.	result := (ClassBuilder new)		name: c name		inEnvironment: c environment		subclassOf: c superclass		type: c typeOfClass		instanceVariableNames: KedamaTurtleVectorPlayer instanceVariablesString		classVariableNames: KedamaTurtleVectorPlayer classVariablesString		poolDictionaries: KedamaTurtleVectorPlayer sharedPoolsString		category: c category.	turtles class copyAllCategoriesUnobtrusivelyFrom: KedamaTurtleVectorPlayer.	sequentialStub ifNotNil: [sequentialStub class copyAllCategoriesUnobtrusivelyFrom: KedamaSequenceExecutionStub].! !!KedamaExamplerPlayer methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:06'!delete	| anInstance |	turtles delete.	sequentialStub delete.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/27/2004 16:26'!doCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	turtles ifNotNil: [aBlock value: turtles].	^ ret.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/27/2004 16:26'!doDieCommand: aBlock	| ret origSize |	ret := self doExamplerCommand: aBlock.	turtles initializeDeletingIndex.	origSize := turtles size.	1 to: origSize do: [:i |		i > origSize ifTrue: [^ ret].		sequentialStub index: (turtles nextDeletingIndex).		aBlock value: sequentialStub.	].	^ ret.! !!KedamaExamplerPlayer methodsFor: 'command execution' stamp: 'yo 9/28/2004 10:21'!doSequentialCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	self getGrouped ifFalse: [		1 to: turtles size do: [:i |			sequentialStub index: i.			aBlock value: sequentialStub.		].	] ifTrue: [		aBlock value: turtles.	].	turtles invalidateTurtleMap.	^ ret.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 9/23/2004 17:15'!kedamaWorld: k	kedamaWorld := k.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 4/3/2005 17:56'!nearestIDFor: aNumber	| whoArray last next smaller bigger |	whoArray := turtles arrays first.	whoArray isEmpty ifTrue: [^ nil].	aNumber < whoArray first ifTrue: [^ whoArray first].	last := whoArray at: 1.	2 to: whoArray size do: [:i |		(last <= aNumber and: [aNumber < (next := whoArray at: i)]) ifTrue: [			smaller := last.			bigger := next.			(smaller - aNumber) abs <= (bigger - aNumber) abs ifTrue: [^ smaller] ifFalse: [^ bigger].		].		last := next.	].	^ last.! !!KedamaExamplerPlayer methodsFor: 'accessing' stamp: 'yo 4/4/2005 13:59'!whoAt: index	| whoArray |	whoArray := turtles arrays first.	index < 1 ifTrue: [^ 0].	index > whoArray size ifTrue: [^ 0].	^ whoArray at: index.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:40'!* other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primMulScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:30'!+ other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primAddScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primAddArray: self and: other into: result.	].	^ super + other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:40'!- other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primSubScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primSubArray: self and: other into: result.	].	^ super - other.! !!KedamaFloatArray methodsFor: 'arithmetic' stamp: 'yo 10/25/2004 15:41'!/ other	| result |	other isNumber ifTrue: [		result := KedamaFloatArray new: self size.		^ self primDivScalar: self and: other into: result.	].	((other isMemberOf: WordArray) or: [other isMemberOf: KedamaFloatArray]) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primDivArray: self and: other into: result.	].	^ super / other.! !!KedamaGetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:32'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: (operatorOrExpression asString copyWithout: $:) font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaGetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:31'!componentName: aSymbol	aSymbol = #blue ifTrue: [		operatorOrExpression := #getBlueComponentIn:.	].	aSymbol = #green ifTrue: [		operatorOrExpression := #getGreenComponentIn:.	].	aSymbol = #red ifTrue: [		operatorOrExpression := #getRedComponentIn:.	].	self addPatchTile.! !!KedamaGetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:29'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getBlueComponentIn:.	self addPatchTile.	self line1: 'getBlueComponentIn:'.! !!KedamaGetColorComponentTile methodsFor: 'tile protocol' stamp: 'yo 10/12/2004 22:32'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: (operatorOrExpression asString copyWithout: $:) font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaGetPixelValueTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 11:03'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'getValueIn' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaGetPixelValueTile methodsFor: 'initialization support' stamp: 'yo 1/30/2005 11:04'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'patchValueIn' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaGetPixelValueTile methodsFor: 'initialization' stamp: 'yo 10/8/2004 07:45'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getPatchValueIn:.	self addPatchTile.	self line1: 'getPatchValueIn:'.! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25'!acceptDroppingMorph: morphToDrop event: evt	| f turtle |	(morphToDrop renderedMorph isKindOf: SketchMorph) ifFalse: [		^morphToDrop rejectDropMorphEvent: evt.	].	f := morphToDrop renderedMorph rotatedForm.	f := f magnify: f boundingBox by: (1.0 / self pixelsPerPatch asFloat) smoothing: 1.	turtle := self player newTurtleSilently.	turtle createTurtlesAsIn: f originAt: ((morphToDrop topLeft - self topLeft) / self pixelsPerPatch asFloat) asIntegerPoint.	"turtle isGroup: true."	turtle color: (self dominantColorWithoutTransparent: f).! !!KedamaMorph methodsFor: 'event handling' stamp: 'ar 7/8/2006 20:25'!dominantColorWithoutTransparent: aForm	| tally max maxi |	aForm depth > 16 ifTrue:		[^self dominantColorWithoutTransparent: (aForm asFormOfDepth: 16)].	tally := aForm tallyPixelValues.	max := maxi := 0.	tally withIndexDo: [:n :i | n > max ifTrue: [ i ~= 1 ifTrue: [max := n. maxi := i]]].	^ Color colorFromPixelValue: maxi - 1 depth: aForm depth! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/9/2004 15:24'!addToPatchDisplayList: p	| a |	a := patchesToDisplay copyWithout: p.	patchesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/14/2004 20:24'!addToTurtleDisplayList: p	| a |	(p isKindOf: KedamaExamplerPlayer) ifFalse: [^ self].	a := turtlesToDisplay copyWithout: p.	turtlesToDisplay := a copyWith: p.! !!KedamaMorph methodsFor: 'setup' stamp: 'yo 9/27/2004 10:26'!clearAll	"Reset this StarSqueak world. All patch variables are cleared, all turtles are removed, and all demons are turned off."	patchVarDisplayForm := Form extent: dimensions depth: 32.	self initializePatch.	self recreateMagnifiedDisplayForm.	self initializeTurtlesDict.	turtleCount := 0.	lastTurtleID := 0.	self color: Color black.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 6/17/2004 17:56'!display	"Display this world on the Display. Used for debugging."	| c |	c := FormCanvas extent: (dimensions * pixelsPerPatch) depth: 32.	c := c copyOffset: bounds origin negated.	self drawOn: c.	c form display.! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/27/2004 10:28'!drawOn: aCanvas	"Display this StarSqueak world."	| result |	"Time millisecondClockValue printString displayAt: 0@0."	self player ifNil: [^ aCanvas fillRectangle: (self bounds) color: self color].	patchVarDisplayForm fillColor: self color.	patchesToDisplay do: [:p |		p displayPatchVariableOn: patchVarDisplayForm.	].	self drawTurtlesOnForm: patchVarDisplayForm.	pixelsPerPatch = 1 ifTrue: [		aCanvas drawImage: patchVarDisplayForm at: bounds origin.	] ifFalse: [		result := self zoom: patchVarDisplayForm into: magnifiedDisplayForm factor: pixelsPerPatch.		result ifNil: [			aCanvas warpImage: patchVarDisplayForm transform: (MatrixTransform2x3 withScale: pixelsPerPatch) at: self innerBounds origin.		] ifNotNil: [			aCanvas drawImage: magnifiedDisplayForm at: bounds origin.		]	].	autoChanged ifTrue: [self changed].! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:16'!removeAllFromPatchDisplayList	patchesToDisplay := #().! !!KedamaMorph methodsFor: 'drawing' stamp: 'yo 9/9/2004 15:19'!removeAllFromTurtleDisplayList	turtlesToDisplay := #().! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!bottomEdgeMode: aSymbol	bottomEdgeMode := aSymbol asSymbol.	bottomEdgeMode == #wrap ifTrue: [		bottomEdgeModeMnemonic := 1.		^ self	].	bottomEdgeMode == #stick ifTrue: [		bottomEdgeModeMnemonic := 2.		^ self	].	(bottomEdgeMode == #bounce or: [bottomEdgeMode == #bouncing]) ifTrue: [		bottomEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 4/6/2005 12:59'!colorAt: aLocalPoint	| pix |	pix := patchVarDisplayForm pixelValueAt: (aLocalPoint // pixelsPerPatch) asIntegerPoint.	^ Color colorFromPixelValue: (pix bitOr: 16rFF000000) depth: 32.! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!leftEdgeMode: aSymbol	leftEdgeMode := aSymbol asSymbol.	leftEdgeMode == #wrap ifTrue: [		leftEdgeModeMnemonic := 1.		^ self	].	leftEdgeMode == #stick ifTrue: [		leftEdgeModeMnemonic := 2.		^ self	].	(leftEdgeMode == #bounce or: [leftEdgeMode == #bouncing]) ifTrue: [		leftEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 6/11/2004 01:06'!pixelsPerPatch: anInteger	"Set the width of one patch in pixels. Larger numbers scale up this StarSqueak world, but numbers larger than 2 or 3 result in a blocky look. The useful range is 1 to 10."	pixelsPerPatch := (anInteger rounded max: 1) min: 10.	super extent: dimensions * pixelsPerPatch.	self recreateMagnifiedDisplayForm! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:52'!rightEdgeMode: aSymbol	rightEdgeMode := aSymbol asSymbol.	rightEdgeMode == #wrap ifTrue: [		rightEdgeModeMnemonic := 1.		^ self	].	rightEdgeMode == #stick ifTrue: [		rightEdgeModeMnemonic := 2.		^ self	].	(rightEdgeMode == #bounce or: [rightEdgeMode == #bouncing]) ifTrue: [		rightEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'accessing' stamp: 'yo 1/20/2005 19:53'!topEdgeMode: aSymbol	topEdgeMode := aSymbol asSymbol.	topEdgeMode == #wrap ifTrue: [		topEdgeModeMnemonic := 1.		^ self	].	topEdgeMode == #stick ifTrue: [		topEdgeModeMnemonic := 2.		^ self	].	(topEdgeMode == #bounce or: [topEdgeMode == #bouncing])  ifTrue: [		topEdgeModeMnemonic := 3.		^ self	].! !!KedamaMorph methodsFor: 'turtles' stamp: 'KR 4/14/2006 15:52'!calcTurtlesCount	turtleCount := 0.	turtlesDict do: [:a | turtleCount := turtleCount + a size].	SmalltalkImage current vmParameterAt: 5 put: ((turtleCount * 3) min: 16000 max: 4000).	SmalltalkImage current vmParameterAt: 6 put: ((turtleCount * 6) min: 32000 max: 8000).! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 7/20/2005 22:34'!deleteTurtleID: who of: examplerPlayer	"Delete the given turtle from this world."	| array |	array := examplerPlayer turtles.	array ifNil: [^ self].	turtlesDictSemaphore critical: [		array deleteTurtleID: who.	].	self calcTurtlesCount.	examplerPlayer costume renderedMorph privateTurtleCount: array size.	"examplerPlayer allOpenViewers do: [:v | v resetWhoIfNecessary]."! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/20/2004 09:28'!lastWhoOf: exampler	| turtles |	turtles := turtlesDict at: exampler ifAbsent: [nil].	^ (turtles arrays first) at: turtles arrays first size.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29'!makePrototypeOfExampler: examplerPlayer color: cPixel	| array inst info |	array := examplerPlayer turtles.	info := array info.	array size > 0 ifTrue: [		inst := array makePrototypeFromFirstInstance.		cPixel ifNotNil: [inst at: (info at: #color) put: cPixel].		^ inst.	].	inst := Array new: array instSize.	info associationsDo: [:assoc |		inst at: (assoc value) put: (examplerPlayer perform: (Utilities getterSelectorFor: assoc key)).	].	cPixel ifNotNil: [inst at: (info at: #color) put: cPixel] ifNil: [inst at: (info at: #color) put: ((examplerPlayer getColor pixelValueForDepth: 32) bitAnd: 16rFFFFFF)].	inst at: (info at: #visible) put: ((inst at: (info at: #visible)) ifTrue: [1] ifFalse: [0]).	^ inst.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:29'!makeReplicatedTurtles: count examplerPlayer: tp color: c ofPrototype: prototype randomize: randomizeFlag	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [		array addTurtlesCount: count ofPrototype: inst for: self randomize: randomizeFlag.	].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:16'!makeTurtlesAtPositionsIn: positionAndColorArray examplerPlayer: tp ofPrototype: prototype	| array inst |	array := tp turtles.	inst := prototype ifNil: [self makePrototypeOfExampler: tp].	turtlesDictSemaphore critical: [array addTurtlesCount: positionAndColorArray first size ofPrototype: inst for: self positionAndColorArray: positionAndColorArray].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/28/2004 14:13'!makeTurtles: count examplerPlayer: tp color: c ofPrototype: prototype turtles: turtles randomize: randomizeFlag	| array inst |	array := tp turtles.	(turtlesDict keys includes: tp) ifFalse: [		self addToTurtleDisplayList: tp.		turtlesDict at: tp put: (array := turtles).	].	inst := prototype ifNil: [self makePrototypeOfExampler: tp color: c].	turtlesDictSemaphore critical: [array setTurtlesCount: count prototype: inst for: self randomize: randomizeFlag].	self calcTurtlesCount.	self changed.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 17:34'!nextTurtleID	^ lastTurtleID := lastTurtleID + 1.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/14/2004 20:28'!removeFromTurtleDisplayList: examplerPlayer	turtlesToDisplay := turtlesToDisplay copyWithout: examplerPlayer.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30'!setTurtlesCount: count examplerPlayer: tp color: cPixel	| prototype |	prototype := self makePrototypeOfExampler: tp color: cPixel.	turtlesDictSemaphore critical: [(tp turtles) setTurtlesCount: count prototype: prototype for: self randomize: true].	self calcTurtlesCount.! !!KedamaMorph methodsFor: 'turtles' stamp: 'yo 9/27/2004 16:30'!turtlesCountOf: exampler	| array |	array := exampler turtles.	array ifNil: [^ 0].	^ array size.! !!KedamaMorph methodsFor: 'etoys' stamp: 'yo 6/11/2004 11:20'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	^ super categoriesForViewer."	| aList |	aList := OrderedCollection new.	aList addAllFirstUnlessAlreadyPresent: (self class additionsToViewerCategories collect:				[:categorySpec | categorySpec first]).	^ aList"! !!KedamaMorph methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:11'!delete	| c |	super delete.	turtlesDict keysDo: [:k |		self deleteAllTurtlesOfExampler: k.		c := k costume.		c ifNotNil: [c renderedMorph delete].	].! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/17/2004 19:34'!initialize	super initialize.	dimensions := self class defaultDimensions.  "dimensions of this StarSqueak world in patches"	wrapX := dimensions x asFloat.	wrapY := dimensions y asFloat.	pixelsPerPatch := 2.	super extent: dimensions * pixelsPerPatch.	self assuredPlayer assureUniClass.	self clearAll.  "be sure this is done once in case setup fails to do it"	autoChanged := true.	self leftEdgeMode: #wrap.	self rightEdgeMode: #wrap.	self topEdgeMode: #wrap.	self bottomEdgeMode: #wrap.	turtlesDictSemaphore := Semaphore forMutualExclusion.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/9/2004 15:15'!initializePatch	| f |	f := self player addPatchVarNamed: #patch.	patchesToDisplay := Array new: 0.	self addToPatchDisplayList: f.	^ f.! !!KedamaMorph methodsFor: 'initialization' stamp: 'yo 9/28/2004 14:12'!initializeTurtlesDict	turtlesDict := IdentityDictionary new.	turtlesToDisplay := Array new.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 9/14/2004 18:47'!isVisible: examplerPlayer	| turtleMorph |	turtleMorph := examplerPlayer costume.	turtleMorph visible ifFalse: [^ false].	turtleMorph owner isRenderer ifFalse: [^ true].	^ turtleMorph owner visible.! !!KedamaMorph methodsFor: 'private' stamp: 'yo 6/6/2004 23:25'!recreateMagnifiedDisplayForm	magnifiedDisplayForm := Form extent: self dimensions * pixelsPerPatch depth: 32.	self changed.! !!KedamaMorph methodsFor: 'menu' stamp: 'yo 6/16/2004 08:56'!setScale	| reply |	reply := FillInTheBlank		request: 'Set the number of pixels per patch (a number between 1 and 10)?'		 initialAnswer: pixelsPerPatch printString.	reply isEmpty ifTrue: [^ self].	self pixelsPerPatch: reply asNumber.! !!KedamaMorph methodsFor: 'utils' stamp: 'yo 3/23/2005 12:24'!random: range	"Answer a random integer between 0 and range."	| r val |	<primitive: 'randomRange' module: 'KedamaPlugin'>	r := range < 0 ifTrue: [range negated] ifFalse: [range].	RandomSeed := ((RandomSeed * 1309) + 13849) bitAnd: 65535.	val := (RandomSeed * (r + 1)) >> 16.	^ range < 0 ifTrue: [val negated] ifFalse: [^ val].! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 9/2/2004 23:23'!initialize	"Kedama initialize"	RandomSeed := 17.! !!KedamaMorph class methodsFor: 'class initialization' stamp: 'yo 10/23/2005 20:33'!newSet	| k p t s w |	k := self new.	p := k assuredPlayer getPatch costume renderedMorph.	t := k assuredPlayer newTurtleForSet.	s := SelectionMorph new.	w := PasteUpMorph new.	w extent: 400@400.	p position: 275@50.	t position: 300@175.	k position: 25@25.	w addMorph: k.	w addMorph: t.	w addMorph: p.	w addMorph: s.	s bounds: w bounds.	s selectSubmorphsOf: w.	^ s.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 11:47'!degreesToRadians: degrees	| deg q headingRadians |	deg := 90.0 - degrees.	q := (deg / 360.0) asInteger.	deg < 0.0 ifTrue: [q := q - 1].	headingRadians := (deg - (q * 360.0)) * 0.0174532925199433.	^ headingRadians.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/11/2004 12:45'!radiansToDegrees: radians	| degrees deg |	degrees := radians / 0.0174532925199433.	deg := 90.0 - degrees.	deg > 0.0 ifFalse: [deg := deg + 360.0].	^ deg.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:07'!scalarXAt: index xArray: xArray headingArray: headingArray value: val destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode	| newX headingRadians |	newX := val.	newX < 0.0 ifTrue: [		leftEdgeMode = 1 ifTrue: [			"wrap"			newX := newX + destWidth.		].		leftEdgeMode = 2 ifTrue: [			"stick"			newX := 0.0.		].		leftEdgeMode = 3 ifTrue: [			"bounce"			newX := 0.0 - newX.			headingRadians := headingArray at: index.			headingRadians <  3.141592653589793				ifTrue: [headingArray at: index put: 3.141592653589793 - headingRadians]				ifFalse: [headingArray at: index put: 9.42477796076938 - headingRadians].		].	].	newX >= destWidth ifTrue: [		rightEdgeMode = 1 ifTrue: [			newX := newX - destWidth.		].		rightEdgeMode = 2 ifTrue: [			newX := destWidth - 0.000001.		].		rightEdgeMode = 3 ifTrue: [			newX := (destWidth - 0.000001) - (newX - destWidth).			headingRadians := headingArray at: index.			headingRadians < 3.141592653589793				ifTrue: [headingArray at: index put: (3.141592653589793 - headingRadians)]				ifFalse: [headingArray at: index put: (9.42477796076938 - headingRadians)].		]	].	xArray at: index put: newX.! !!KedamaMorph class methodsFor: 'global primitive backup' stamp: 'yo 10/10/2004 09:09'!scalarYAt: index yArray: yArray headingArray: headingArray value: val destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| newY |	newY := val.	newY < 0.0 ifTrue: [		topEdgeMode = 1 ifTrue: [			"wrap"			newY := newY + destHeight.		].		topEdgeMode = 2 ifTrue: [			"stick"			newY := 0.0.		].		topEdgeMode = 3 ifTrue: [			"bounce"			newY := 0.0 - newY.			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		].	].	newY >= destHeight ifTrue: [		bottomEdgeMode = 1 ifTrue: [			newY := newY - destHeight.		].		bottomEdgeMode = 2 ifTrue: [			newY := destHeight - 0.000001.		].		bottomEdgeMode = 3 ifTrue: [			newY := (destHeight - 0.000001) - (newY - destHeight).			headingArray at: index put: (6.283185307179586 - (headingArray at: index)).		]	].	yArray at: index put: newY.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/7/2004 10:21'!autoChanged: aBoolean	autoChanged := aBoolean.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:56'!basicPixelAtX: xPos y: yPos	| x y i |	x := xPos truncated.	y := yPos truncated.	((x < 0) or: [y < 0]) ifTrue: [^ 0].	((x >= form width) or: [y >= form height]) ifTrue: [^ 0].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	^ form bits at: i.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 11/30/2005 12:07'!basicPixelAtX: xPos y: yPos put: value	| x y i v |	x := xPos truncated.	y := yPos truncated.	v := value asInteger min: 16rFFFFFFFF max: 0.	((x < 0) or: [y < 0]) ifTrue: [^ self].	((x >= form width) or: [y >= form height]) ifTrue: [^ self].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	form bits at: i put: v.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:59'!blueComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16rFFFF00) bitOr: (anotherPix).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 21:29'!colorAtX: xPos y: yPos put: aColor	| pixel |	pixel := aColor pixelValueForDepth: 32.	self pixelAtX: xPos y: yPos put: pixel.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:54'!diffuse	| dim newV |	dim := form extent.	form bits class == ByteArray ifTrue: [form unhibernate].	newV := Bitmap new: form bits size.	self primDiffuseFrom: form bits		to: newV		width: dim x		height: dim y		delta: diffusionRate truncated.	form bits: newV.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 20:48'!diffusionRate: newRate	"Set the diffusion rate to an integer between 0 and 10. The diffusion rate gives the number of patches on one size of the area averaged to compute the next value of the variable for a given patch. Larger numbers cause faster diffusion. Zero means no diffusion."	diffusionRate := (newRate rounded max: 0) min: 10.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/16/2004 04:34'!displayMax: anInteger	displayMax := WordArray with: (anInteger asInteger min: 16rFFFFFFFF max: 0).	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/14/2004 16:20'!displayShiftAmount: anInteger	shiftAmount := anInteger min: 8 max: -32.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 4/5/2005 10:11'!displayType: aSymbol	displayType := aSymbol asSymbol.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/3/2004 20:50'!evaporationRate: newRate	"Set the evaporation rate. The useful range is 0 to 25 or so. Larger numbers cause faster evaporation. Zero means no evaporization."	scaledEvaporationRate := ((1024 - newRate truncated) max: 1) min: 1024.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:06'!greenComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16rFF00FF) bitOr: (anotherPix bitShift: 8).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:38'!pixelAtX: xPos y: yPos	| x y i |	x := xPos truncated.	y := yPos truncated.	((x < 0) or: [y < 0]) ifTrue: [^ 0].	((x >= form width) or: [y >= form height]) ifTrue: [^ 0].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	^ form bits at: i.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 11/30/2005 12:07'!pixelAtX: xPos y: yPos put: value	| x y i v |	x := xPos truncated.	y := yPos truncated.	v := (value asInteger max: 0) bitAnd: 16rFFFFFFFF.	((x < 0) or: [y < 0]) ifTrue: [^ self].	((x >= form width) or: [y >= form height]) ifTrue: [^ self].	i := ((y * form width) + x) + 1.	form bits class == ByteArray ifTrue: [form unhibernate].	form bits at: i put: v.	self formChanged.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 10/13/2004 01:05'!redComponentFrom: another	| pix anotherPix |	0 to: self height - 1 do: [:y |		0 to: self width -1 do: [:x |			pix := self pixelAtX: x y: y.			anotherPix := (another pixelAtX: x y: y) bitAnd: 16rFF.			pix := (pix bitAnd: 16r00FFFF) bitOr: (anotherPix bitShift: 16).			self pixelAtX: x y: y put: pix.		].	].! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 6/4/2004 01:36'!sniffRange: aNumber	sniffRange := aNumber.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 8/18/2005 10:54'!uphillForTurtleX: tX turtleY: tY turtleHeading: tH	"Answer the heading the points in the direction of increasing value for the given patch variable. If there is no gradient, or if the turtle is outside the world bounds, answer the turtles current heading."	| ret |	form bits class == ByteArray ifTrue: [form unhibernate].	ret := self primUpHillX: tX y: tY heading: tH bits: form bits width: form width height: form height sniffRange: sniffRange.	ret ifNotNil: [^ ret].	^ self basicUphillForTurtleX: tX turtleY: tY turtleHeading: tH.! !!KedamaPatchMorph methodsFor: 'commands and slots' stamp: 'yo 3/7/2005 12:20'!useLogDisplay: aBoolean	displayType := aBoolean ifTrue: [#logScale] ifFalse: [#linear].	self formChanged.! !!KedamaPatchMorph methodsFor: 'private' stamp: 'yo 3/7/2005 12:19'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'useLogDisplay' ifPresent: [ :x | 		displayType := x ifTrue: [#logScale] ifFalse: [#linear].	].	displayType ifNil: [displayType := #logScale].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!KedamaPatchMorph methodsFor: 'drawing' stamp: 'yo 8/18/2005 11:42'!displayPatchVariableOn: aForm	| patchVar pixelValue |	form ifNil: [^self].	formChanged ifTrue: [		"displayForm fillColor: Color transparent."		pixelValue := (self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF.		form bits class == ByteArray ifTrue: [form unhibernate].		patchVar := form bits.		displayForm bits class == ByteArray ifTrue: [displayForm unhibernate].		displayType = #linear ifTrue: [			self primMakeMaskOf: patchVar in: displayForm bits colorPixel: pixelValue shift: shiftAmount.		].		displayType = #logScale ifTrue: [			self primMakeMaskOf: patchVar in: displayForm bits colorPixel: pixelValue max: displayMax.		].		displayType = #color ifTrue: [			form displayOn: displayForm.			displayForm fixAlpha.		].	].	tmpForm fillColor: Color black.	displayForm displayOn: tmpForm at: 0@0 rule: 24.	aForm == tmpForm ifFalse: [		displayForm displayOn: aForm at: 0@0 rule: 24.	].	formChanged := false.! !!KedamaPatchMorph methodsFor: 'drawing' stamp: 'yo 6/6/2004 23:23'!formChanged	formChanged := true.! !!KedamaPatchMorph methodsFor: 'initialization' stamp: 'yo 3/7/2005 12:17'!initialize	super initialize.	self evaporationRate: 6.	self diffusionRate: 1.	self sniffRange: 1.	displayType := #logScale.	displayMax := WordArray with: 1024.	shiftAmount := -2.	autoChanged := true.	self formChanged.! !!KedamaPatchMorph methodsFor: 'initialization' stamp: 'yo 2/2/2005 17:37'!initializeForm: aForm 	form := aForm. 	form fillColor: Color transparent.	displayForm := (Form extent: aForm extent depth: 32).	tmpForm := (Form extent: aForm extent depth: 32).	tmpForm fillColor: Color black.	super extent: form extent.	self changed.	self formChanged.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 6/26/2004 20:07'!primMakeMaskOf: dataBits in: maskBits colorPixel: pixel max: max	| highMask alpha maxLog data |	<primitive: 'makeMaskLog' module: 'KedamaPlugin'>	"^ KedamaSqueakPlugin doPrimitive: #makeMaskLog."	highMask := 16rFF000000.	"maxLog := self cCode: 'log(max)' inSmalltalk: [max first ln]."	maxLog := max first ln.	maxLog := 255.0 / maxLog.	1 to: dataBits size do: [:i |		data := dataBits at: i.		data = 0 ifTrue: [alpha := 0] ifFalse: [			"alpha := ((255.0 / maxLog) * (self cCode: 'log(data)' inSmalltalk: [data ln])) asInteger."			alpha := (maxLog * (data ln)) asInteger.		].		(alpha > 255) ifTrue: [alpha := 255].		maskBits at: i put: (((alpha << 24) bitAnd: highMask) bitOr: pixel).	].	^ self.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 6/18/2004 15:18'!primMakeMaskOf: dataBits in: maskBits colorPixel: pixel shift: shift	| highMask data alpha |	<primitive: 'makeMask' module: 'KedamaPlugin'>	"^ KedamaSqueakPlugin doPrimitive: #makeMask."	highMask := 16rFF000000.	1 to: dataBits size do: [:i |		data := dataBits at: i.		alpha := data bitShift: shift.		(alpha > 255) ifTrue: [alpha := 255].		maskBits at: i put: (((alpha << 24) bitAnd: highMask) bitOr: pixel).	].	^ self.! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 8/19/2005 12:24'!primPixelsAtXArray: xArray yArray: yArray bits: bits width: width height: height into: aWordArray	| x y formIndex val |	<primitive: 'primPixelsAtXY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primPixelsAtXY."	1 to: aWordArray size do: [:i |		val := nil.		x := (xArray at: i) truncated.		y := (yArray at: i) truncated.		((x < 0) or: [y < 0]) ifTrue: [val := 0].		((x >= form width) or: [y >= form height]) ifTrue: [val := 0].		val ifNil: [			formIndex := ((y * form width) + x) + 1.			val := bits at: formIndex.		].		aWordArray at: i put: val.	].! !!KedamaPatchMorph methodsFor: 'primitives' stamp: 'yo 10/25/2004 16:56'!primSetPixelsAtXArray: xArray yArray: yArray bits: bits width: width height: height value: value	| v |	<primitive: 'primSetPixelsAtXY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primSetPixelsAtXY."	value isNumber ifTrue: [v := value].	1 to: xArray size do: [:i |		value isNumber ifFalse: [			v := value at: i.		].				self pixelAtX: (xArray at: i) y: (yArray at: i) put: v.	].! !!KedamaPatchMorph class methodsFor: 'instance creation' stamp: 'yo 2/2/2005 17:45'!newExtent: aPoint	| inst |	inst := self new.	inst newExtent: aPoint.	^ inst.! !!KedamaPatchTile methodsFor: 'initialization' stamp: 'yo 6/7/2004 13:56'!initialize	super initialize.	type := #literal.	self extent: 16@16.! !!KedamaPatchTile methodsFor: 'tile protocol' stamp: 'yo 6/5/2004 16:11'!setLiteral: anObject	"Set the receiver's literal to be anObject. No readout morph here."	type := #literal.	self setLiteralInitially: anObject.! !!KedamaPatchTile methodsFor: 'initialization support' stamp: 'yo 6/18/2004 16:02'!usePatch: aPatch	| aTile displayer |	self removeAllMorphs.	literal := aPatch.	aTile := KedamaPatchType basicNew newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: aPatch;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	displayer useStringFormat.	aTile addMorphBack: displayer.	aTile setLiteralInitially: (aPatch perform: #externalName).	self addMorphBack: aTile.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 10/13/2004 04:16'!defaultArgumentTile	"Answer a tile to represent the type"	| patch ks k p |	patch := KedamaPatchTile new typeColor: self typeColor.	ks := ActiveWorld allMorphs select: [:e | e isKindOf: KedamaMorph].	ks isEmpty ifFalse: [		k := ks first.		p := k player getPatch.	] ifTrue: [		k := KedamaPatchMorph new.		k assuredPlayer.		p := k player.	].	patch usePatch: p.	^ patch.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 10/13/2004 01:53'!defaultArgumentTileFor: aPlayer	"Answer a tile to represent the type"	| patch morph |	patch := KedamaPatchTile new typeColor: self typeColor.	morph := aPlayer costume renderedMorph.	(morph isKindOf: KedamaMorph) ifTrue: [		patch usePatch: aPlayer costume renderedMorph player getPatch.	].	(morph isKindOf: KedamaPatchMorph) ifTrue: [		patch usePatch: morph player.	].	^ patch.! !!KedamaPatchType methodsFor: 'tile protocol' stamp: 'yo 9/13/2005 21:23'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: (aTarget perform: getter) costume renderedMorph;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs == 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	displayer useStringFormat.	^ aTile! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 18:51'!basicGetAngleTo: player	| ret i |	i := self index.	ret := ((player getX - ((turtles arrays at: 2) at: i))@(player getY - ((turtles arrays at: 3) at: i))) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360.0].	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 18:07'!basicGetDistanceTo: aPlayer	| i |	i := self index.	^ ((aPlayer getX - ((turtles arrays at: 2) at: i)) squared + (aPlayer getY - ((turtles arrays at: 3) at: i)) squared) sqrt.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:47'!bounceOn: aPlayer	| aTurtle xy |	aPlayer = exampler ifTrue: [^ false].	xy := self getXAndY.	aTurtle := aPlayer turtles aTurtleAtX: xy x y: xy y.	aTurtle ifNil: [^ false].	self doBounceOn: aTurtle of: aPlayer.	^ true.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:48'!bounceOn: aPlayer color: c	| aTurtle xy |	aPlayer = exampler ifTrue: [^ false].	xy := self getXAndY.	aTurtle := aPlayer turtles aTurtleAtX: xy x y: xy y.	aTurtle ifNil: [^ false].	((aPlayer turtles arrays at: 5) at: aTurtle index) = c ifFalse: [^ false].	self doBounceOn: aTurtle of: aPlayer.	^ true.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 4/5/2005 11:04'!colorFromPatch: aPatch	| i |	i := self index.	(turtles arrays at: 5) at: i put: ((aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i)) bitAnd: 16rFFFFFF).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 22:01'!colorToPatch: aPatch	| i |	i := self index.	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: ((turtles arrays at: 5) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:48'!doBounceOn: aTurtle of: aPlayer	| bounceDir myHeading neg newHeading xy |	aPlayer = exampler ifTrue: [^ false].	bounceDir := aTurtle getHeading.	myHeading := self getHeading.	neg := (myHeading + 180.0) \\ 360.0.	newHeading := (bounceDir - neg + bounceDir).	self setHeading: newHeading.	[xy := self getXAndY. (aPlayer turtles aTurtleAtX: xy x y: xy y) ~= nil] whileTrue: [		self forward: 0.5.	].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:49'!getAngleTo: aPlayer	| i xy |	i := self index.	xy := aPlayer getXAndY.	^ self primGetAngleToX: xy x toY: xy y fromX: ((turtles arrays at: 2) at: i) fromY: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getBlueComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ pix bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:49'!getDistanceTo: aPlayer	| i xy |	i := self index.	xy := aPlayer getXAndY.	^ self primGetDistanceToX: xy x toY: xy y fromX: ((turtles arrays at: 2) at: i) fromY: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getGreenComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ (pix bitShift: -8) bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:04'!getNormal	| headingRadians degrees |	headingRadians := (turtles arrays at: 7) at: self index.	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 18:16'!getPatchValueIn: aPatch	| i |	i := self index.	^ aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/12/2004 15:24'!getRedComponentIn: aPatch	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	^ (pix bitShift: -16) bitAnd: 16rFF.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 16:35'!getReplicated	| proto newWho n |	proto := (1 to: turtles arrays size) collect: [:i | (turtles arrays at: i) at: self index].	kedamaWorld makeReplicatedTurtles: 1 examplerPlayer: exampler color: nil ofPrototype: proto randomize: false.	exampler costume renderedMorph privateTurtleCount: (kedamaWorld turtlesCountOf: exampler).	newWho := (kedamaWorld lastWhoOf: exampler).	n := self clone.	n who: newWho.	^ n.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/23/2004 23:50'!getTurtleAt: aPlayer	| ret xy |	xy := aPlayer getXAndY.	ret := exampler turtles aTurtleAtX: xy x y: xy y.	^ ret ifNil: [self].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 3/7/2005 11:33'!getTurtleOf: aBreedPlayer	| ret xy |	xy := self getXAndY.	ret := aBreedPlayer turtles aTurtleAtX: xy x y: xy y.	^ ret ifNil: [self].! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/30/2004 11:42'!getUphillIn: aPatch	| i p |	i := self index.	p := aPatch costume renderedMorph.	^ p			uphillForTurtleX: ((turtles arrays at: 2) at: i)			turtleY: ((turtles arrays at: 3) at: i)			turtleHeading: ((turtles arrays at: 4) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setBlueComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFFFF00) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 16).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setGreenComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFF00FF) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 8).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:05'!setNormal: degrees	| headingRadians |	headingRadians := ((90.0 - degrees) \\ 360.0) degreesToRadians.	(turtles arrays at: 7) at: self index put: headingRadians.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 9/27/2004 18:19'!setPatchValueIn: aPatch to: value	| i |	i := self index.	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: value.! !!KedamaSequenceExecutionStub methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:42'!setRedComponentIn: aPatch to: value	| i pix |	i := self index.	pix := aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i).	pix := (pix bitAnd: 16rFFFF) bitOr: ((value asInteger bitAnd: 16rFF) bitShift: 16).	aPatch costume renderedMorph pixelAtX: ((turtles arrays at: 2) at: i) y: ((turtles arrays at: 3) at: i) put: pix.! !!KedamaSequenceExecutionStub methodsFor: 'method management' stamp: 'yo 9/30/2004 13:13'!compileScalarInstVarAccessorsFor: varName	| nameString type setPhrase arrayIndex getPhrase |	nameString := varName asString capitalized.	arrayIndex := turtles info at: varName asSymbol.	type := turtles types at: arrayIndex.	type = #Number ifTrue: [		setPhrase := 'setNumberVarAt:'.		getPhrase := 'getNumberVarOf:'.	].	type = #Boolean ifTrue: [		setPhrase := 'setBooleanVarAt:'.		getPhrase := 'getBooleanVarOf:'	].	type = #Color ifTrue: [		setPhrase := 'setColorVarAt:'.		getPhrase := 'getColorVarOf:'	].	setPhrase ifNil: [setPhrase := 'setObjectVarAt:'].	getPhrase ifNil: [getPhrase := 'getObjectVarOf:'].	self class compileSilently: ('get', nameString, '	^ self ', getPhrase, '((turtles arrays at: ', arrayIndex printString, ') at: self index)')		classified: 'access'.	self class compileSilently: ('set', nameString, ': xxxArg		self ', setPhrase, arrayIndex printString, ' at: self index put: xxxArg' )		classified: 'access'! !!KedamaSequenceExecutionStub methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:03'!delete	| anInstance |	arrays := nil.	exampler := nil.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaSequenceExecutionStub methodsFor: 'command execution' stamp: 'yo 9/29/2004 09:02'!doDieCommand: aBlock	| ret |	ret := self doExamplerCommand: aBlock.	sequentialStub index: index.	aBlock value: sequentialStub.	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'player protocol' stamp: 'yo 9/17/2004 17:15'!examplerPlayer: e	exampler := e.! !!KedamaSequenceExecutionStub methodsFor: 'accessing - private' stamp: 'yo 10/23/2004 23:44'!getXAndY	| i |	i := self index.	^ ((turtles arrays at: 2) at: i)@((turtles arrays at: 3) at: i).! !!KedamaSequenceExecutionStub methodsFor: 'accessing - private' stamp: 'yo 9/27/2004 16:34'!setColorVarAt: arrayIndex at: i put: v	| val |	val := v isColor ifTrue: [v pixelValueForDepth: 32] ifFalse: [v].	(turtles arrays at: arrayIndex) at: i put: val.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/16/2004 10:41'!index: i	index := i.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/28/2004 11:15'!turtles: t	turtles := t.! !!KedamaSequenceExecutionStub methodsFor: 'accessing' stamp: 'yo 9/18/2004 15:34'!who: w	who := w.	index := nil.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/10/2004 09:14'!primForwardAt: i xArray: xArray yArray: yArray headingArray: headingArray value: value destWidth: destWidth destHeight: destHeight leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| dist newX newY |	<primitive: 'primScalarForward' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primScalarForward."	dist := value.	newX := (xArray at: i) + (dist asFloat * (headingArray at: i) cos).	newY := (yArray at: i) - (dist asFloat * (headingArray at: i) sin).	KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.	KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/23/2004 18:55'!primGetAngleToX: toX toY: toY fromX: fromX fromY: fromY	| ret |	<primitive: 'scalarGetAngleTo' module:'KedamaPlugin'>	ret := ((toX - fromX)@(toY - fromY)) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360.0].	^ ret.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/11/2004 14:33'!primGetHeadingAt: i headingArray: headingArray	| heading |	<primitive: 'getScalarHeading' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #getScalarHeading."	heading := headingArray at: i.	^ heading := KedamaMorph radiansToDegrees: heading.! !!KedamaSequenceExecutionStub methodsFor: 'primitives' stamp: 'yo 10/11/2004 14:07'!primSetHeadingAt: i headingArray: headingArray value: heading	| rad |	<primitive: 'setScalarHeading' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #setScalarHeading."	rad := KedamaMorph degreesToRadians: heading.	headingArray at: index put: rad.! !!KedamaSetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 1/30/2005 11:20'!addPatchTile	| m1 desiredW m2 label |	m1 := TilePadMorph new.	label := 	StringMorph contents: (operatorOrExpression asString upTo: $:) translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaSetColorComponentTile methodsFor: 'initalization support' stamp: 'yo 10/12/2004 22:38'!componentName: aSymbol	aSymbol = #blue ifTrue: [		operatorOrExpression := #setBlueComponentIn:to:.	].	aSymbol = #green ifTrue: [		operatorOrExpression := #setGreenComponentIn:to:.	].	aSymbol = #red ifTrue: [		operatorOrExpression := #setRedComponentIn:to:.	].	self addPatchTile.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:36'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #setBlueComponentIn:to:.	self addPatchTile.	self line1: 'setBlueComponent:'.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:20'!line1: line1	| chopped label label2 tail headIndex |	(line1 select: [:e | e = $:]) size >= 2 ifTrue: [^ self].	self removeAllMorphs.	headIndex := line1 indexOf: $: ifAbsent: [line1 indexOf: Character space ifAbsent: [0]].	chopped := line1 copyFrom: 1 to: headIndex - 1.	tail := line1 copyFrom: chopped size + 2 to: line1 size.	label := 	StringMorph contents: (chopped) translated font: ScriptingSystem fontForTiles.	label2 := StringMorph contents: tail translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.	self addMorphBack: label2.! !!KedamaSetColorComponentTile methodsFor: 'initialization' stamp: 'yo 10/12/2004 23:33'!storeCodeOn: aStream indent: tabCount 	"We have a hidden arg. Output two keywords with interspersed arguments."	| firstKeyword |	(#('redComponentIn:' 'setRedComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setRedComponentIn'.	].	(#('greenComponentIn:' 'setGreenComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setGreenComponentIn'	].	(#('blueComponentIn:' 'setBlueComponentIn:') includes: assignmentRoot) ifTrue: [		firstKeyword := 'setBlueComponentIn'	].	aStream nextPutAll: firstKeyword.	aStream nextPut: $:.			aStream space."Simple assignment, don't need existing value"	patchTile submorphs first storeCodeOn: aStream indent: tabCount.	aStream nextPutAll: ' to: '.	assignmentSuffix = ':' 		ifFalse: 			["Assignments that require that old values be retrieved"			aStream nextPutAll: '( '.			self assignmentReceiverTile storeCodeOn: aStream indent: tabCount.			aStream space.			aStream nextPutAll: 'getPatchValueIn:'.			patchTile submorphs first storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ')'.			aStream space.			aStream nextPutAll: (self operatorForAssignmentSuffix: assignmentSuffix).			aStream space]! !!KedamaSetColorComponentTile methodsFor: 'tile protocol' stamp: 'yo 10/12/2004 22:39'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self addArrowsIfAppropriate; updateLiteralLabel.! !!KedamaSetPixelValueTile methodsFor: 'initialization-support' stamp: 'yo 10/9/2004 17:59'!addPatchTile	| m1 desiredW m2 label |	m1 := TilePadMorph new.	label := 	StringMorph contents: 'setValueIn' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaSetPixelValueTile methodsFor: 'initialization' stamp: 'yo 10/8/2004 09:25'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #setPatchValueIn:to:.	self addPatchTile.	self line1: 'setPatchValue:'.! !!KedamaSetPixelValueTile methodsFor: 'tile protocol' stamp: 'yo 10/8/2004 09:28'!line1: line1	| chopped label label2 tail headIndex |	(line1 select: [:e | e = $:]) size >= 2 ifTrue: [^ self].	self removeAllMorphs.	headIndex := line1 indexOf: $: ifAbsent: [line1 indexOf: Character space ifAbsent: [0]].	chopped := line1 copyFrom: 1 to: headIndex - 1.	tail := line1 copyFrom: chopped size + 2 to: line1 size.	label := 	StringMorph contents: (chopped) font: ScriptingSystem fontForTiles.	label2 := StringMorph contents: tail font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.	self addMorphBack: label2.! !!KedamaSetPixelValueTile methodsFor: 'tile protocol' stamp: 'yo 6/7/2004 21:01'!setAssignmentSuffix: aString	assignmentSuffix := aString.	self computeOperatorOrExpression.	type := #operator. 	self addArrowsIfAppropriate; updateLiteralLabel! !!KedamaStandardViewer methodsFor: 'initialization' stamp: 'yo 4/4/2005 18:14'!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	stub := aPlayer clonedSequentialStub.	stub who: 0.	restrictedWho := 0.	restrictedIndex := 0.	super initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo.! !!KedamaStandardViewer methodsFor: 'turtle view' stamp: 'yo 4/4/2005 18:05'!providePossibleRestrictedView: anInteger	| who |	restrictedIndex := anInteger.	who := scriptedPlayer whoAt: anInteger.	restrictedWho = who ifTrue: [^ self].	restrictedWho := who.	stub who: who.	who = 0 ifTrue: [self replaceTargetsWithExampler] ifFalse: [self replaceTargetsWithStub].	self searchingViewerMorphs do: [:v | v updateWhoString].! !!KedamaTurtleAtTile methodsFor: 'initialization-support' stamp: 'yo 10/11/2004 15:49'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'turtle at' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaTurtleAtTile methodsFor: 'initialization' stamp: 'yo 10/9/2004 10:35'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getTurtleAt:.	self addTile.! !!KedamaTurtleAtTile methodsFor: 'tile protocol' stamp: 'yo 10/9/2004 10:35'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'turtleAt' font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaTurtleMorph methodsFor: 'viewer access' stamp: 'yo 6/11/2004 11:18'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order"	"^ super categoriesForViewer."	| aList |	aList := OrderedCollection new.	aList addAllFirstUnlessAlreadyPresent: (self class additionsToViewerCategories collect:				[:categorySpec | categorySpec first]).	^ aList! !!KedamaTurtleMorph methodsFor: 'initialization' stamp: 'ar 7/8/2006 20:26'!initialize	super initialize.	turtleCount := 1.	self assuredPlayer assureUniClass.	self extent: 40@40.	isGroup := false.	self color: self saturatedRandomColor.! !!KedamaTurtleMorph methodsFor: 'initialization' stamp: 'yo 9/23/2004 18:38'!install	| t |	self player kedamaWorld: kedamaWorld.	t := self player createTurtles.	kedamaWorld makeTurtles: turtleCount examplerPlayer: self player color: ((self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF) ofPrototype: nil turtles: t randomize: true.	self player createSequenceStub.! !!KedamaTurtleMorph methodsFor: 'group turtle creation' stamp: 'yo 10/11/2004 16:00'!createTurtlesAsIn: aForm originAt: origin	| c xArray yArray colorArray newX newY |	xArray := OrderedCollection new: aForm width * aForm height.	yArray := OrderedCollection new: aForm width * aForm height.	colorArray := OrderedCollection new: aForm width * aForm height.	0 to: aForm height do: [:y |		0 to: aForm width do: [:x |			c := aForm colorAt: (x@y).			c isTransparent ifFalse: [				newX := x + origin x.				newY := y + origin y.				((newX >= 0 and: [newX < kedamaWorld dimensions x]) and: [newY >= 0 and: [newY < kedamaWorld dimensions y]]) ifTrue: [					xArray add: newX.					yArray add: newY.					colorArray add: (c pixelValueForDepth: 32).				].			].		].	].	kedamaWorld makeTurtlesAtPositionsIn: {xArray asArray. yArray asArray. colorArray asArray} examplerPlayer: self player ofPrototype: nil.	self privateTurtleCount: (kedamaWorld turtlesCountOf: self player).! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 9/14/2004 15:46'!isGroup: aBoolean	isGroup := aBoolean.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:49'!kedamaWorld: k	kedamaWorld := k.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 6/5/2004 19:38'!privateTurtleCount: c	turtleCount := c.! !!KedamaTurtleMorph methodsFor: 'accessing' stamp: 'yo 4/4/2005 17:47'!turtleCount: count	| c |	c := count asInteger max: 0.	kedamaWorld setTurtlesCount: c examplerPlayer: self player color: ((self color pixelValueForDepth: 32) bitAnd: 16rFFFFFF).	turtleCount := c.	"turtleCount <= 0 ifTrue: [self player allOpenViewers do: [:v | v providePossibleRestrictedView: 0]]."! !!KedamaTurtleOfTile methodsFor: 'initalization support' stamp: 'yo 3/7/2005 08:38'!addTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'turtle of' font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Player.	m1 addMorph: m2.	desiredW := m1 width.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	turtleTile := m1.! !!KedamaTurtleOfTile methodsFor: 'initialization' stamp: 'yo 3/7/2005 08:36'!initialize	super initialize.	type := #Player.	operatorOrExpression := #getTurtleOf:.	self addTile.! !!KedamaTurtleOfTile methodsFor: 'tile protocol' stamp: 'yo 3/7/2005 08:38'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'turtleOf' font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: turtleTile.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!who: anInteger	who := anInteger.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!x: aNumber	x := aNumber.! !!KedamaTurtlePlayer methodsFor: 'accessing' stamp: 'yo 6/2/2004 22:36'!y: aNumber	y := aNumber.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/17/2004 07:26'!color: aColor	color := aColor.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/17/2004 09:59'!getAngleTo: aPlayer	| ret |	ret := ((aPlayer x - self x)@(aPlayer y - self y)) theta radiansToDegrees + 90.0.	ret > 360.0 ifTrue: [^ ret - 360].	^ ret.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/14/2004 16:09'!getDistanceTo: aPlayer	| dist |	dist := ((aPlayer x - self x) squared + (aPlayer y - self y) squared) sqrt.	^ dist.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/6/2004 01:45'!getHeading	"Answer my heading in degrees."	| degrees |	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/14/2004 19:56'!getReplicated	| newGuys theNewGuy |	newGuys := world makeTurtles: 1 turtlePlayerClass: self class color: self color ofPrototype: self.	theNewGuy := newGuys first.	theNewGuy x: self x.	theNewGuy y: self y.	theNewGuy heading: self heading.	(world prototypeOf: self class) privateTurtleCount: (world turtlesCountOf: self class).	^ theNewGuy! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!goto: aPoint	"Jump to the given location."	x := aPoint x.	y := aPoint y.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!heading	"Answer my heading in degrees."	| degrees |	degrees := 90.0 - headingRadians radiansToDegrees.	^ degrees >= 0.0 ifTrue: [degrees] ifFalse: [degrees + 360.0].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 6/2/2004 22:36'!heading: angleInDegrees	"Set my heading in degrees. Like a compass, up or north is 0 degrees and right or east is 90 degrees."	headingRadians := ((90.0 - angleInDegrees) \\ 360.0) degreesToRadians.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:45'!hide	visible := false! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 15:09'!setX: val	| leftEdgeMode rightEdgeMode |	x := val.	x < 0.0 ifTrue: [		leftEdgeMode := world leftEdgeMode.		leftEdgeMode == #wrap ifTrue: [			x := x + world wrapX.		].		leftEdgeMode == #stick ifTrue: [			x := 0.0.		].		leftEdgeMode == #bounce ifTrue: [			x := val negated.			headingRadians < Float pi				ifTrue: [headingRadians := Float pi - headingRadians]				ifFalse: [headingRadians := Float threePi - headingRadians]		].	].	x >= world wrapX ifTrue: [		rightEdgeMode := world rightEdgeMode.		rightEdgeMode == #wrap ifTrue: [			x := x - world wrapX.		].		rightEdgeMode == #stick ifTrue: [			x := world wrapX - 0.0000001.		].		rightEdgeMode == #bounce ifTrue: [			x := world wrapX - 0.0000001 - (x - world wrapX).			headingRadians < Float pi				ifTrue: [headingRadians := Float pi - headingRadians]				ifFalse: [headingRadians := Float threePi - headingRadians]		].	].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 15:09'!setY: val	| topEdgeMode bottomEdgeMode |	y := val.	y < 0.0 ifTrue: [		topEdgeMode := world topEdgeMode.		topEdgeMode == #wrap ifTrue: [			y := y + world wrapY.		].		topEdgeMode == #stick ifTrue: [			y := 0.0.		].		topEdgeMode == #bounce ifTrue: [			y := val negated.			headingRadians := Float twoPi - headingRadians.		].	].	y >= world wrapY ifTrue: [		bottomEdgeMode := world bottomEdgeMode.		bottomEdgeMode == #wrap ifTrue: [			y := y - world wrapY.		].		bottomEdgeMode == #stick ifTrue: [			y := world wrapY - 0.0000001.		].		bottomEdgeMode == #bounce ifTrue: [			y := world wrapY - 0.0000001 - (y - world wrapY).			headingRadians := Float twoPi - headingRadians.		].	].! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:44'!show	visible := true.! !!KedamaTurtlePlayer methodsFor: 'commands and slots' stamp: 'yo 9/9/2004 14:44'!visible: aBoolean	visible := aBoolean.! !!KedamaTurtlePlayer methodsFor: 'initialization' stamp: 'yo 9/16/2004 17:41'!initializeWorld: aStarSqueakWorld who: anInteger color: cPixel	| dims |	dims := aStarSqueakWorld dimensions.	world := aStarSqueakWorld.	who := anInteger.	x := world random: dims x - 1.	y := world random: dims y - 1.	headingRadians := ((self random: 36000) / 100.0) degreesToRadians.	color := cPixel.	self isGroup: false.	self show.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/24/2004 18:45'!addInstanceVarNamed: aName withValue: aValue	| newArray |	(aValue isKindOf: Number) ifTrue: [		newArray := KedamaFloatArray new: self size.	].	(aValue isKindOf: Color) ifTrue: [		newArray := WordArray new: self size.	].	(aValue isKindOf: Player) ifTrue: [		newArray := Array new: self size.	].	arrays := arrays, newArray.	info at: aName asSymbol put: arrays size.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/24/2004 18:45'!addInstanceVarVectorNamed: aName withValue: aValue	| newArray |	newArray := KedamaFloatArray new: self size.	arrays := arrays, (Array with: newArray).	newArray atAllPut: aValue.	info at: aName asSymbol put: arrays size.	types at: arrays size put: #Number.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 12:00'!compileVectorInstVarAccessorsFor: varName	| nameString index type setPhrase |	nameString := varName asString capitalized.	index := info at: varName asSymbol.	self class compileSilently: ('get', nameString, '	^ ', '(arrays at: ', index printString, ')')		classified: 'access'.	type := types at: index.	type = #Number ifTrue: [		setPhrase := 'setNumberVarAt:'.	].	type = #Boolean ifTrue: [		setPhrase := 'setBooleanVarAt:'.	].	type = #Color ifTrue: [		setPhrase := 'setColorVarAt:'.	].	setPhrase ifNil: [setPhrase := 'setObjectVarAt:'].	self class compileSilently: ('set', nameString, ': xxxArg	self ', setPhrase, index printString, ' put: xxxArg')		classified: 'access'! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 12:20'!removeSlotNamed: aSlotName	| index newArrays |	self basicRemoveSlotNamed: aSlotName.	index := info at: aSlotName asSymbol ifAbsent: [^ self].	newArrays := (arrays copyFrom: 1 to: index - 1), (arrays copyFrom: index + 1 to: arrays size).	types replaceFrom: index to: types size with: types startingAt: index + 1.	info removeKey: aSlotName asSymbol.	arrays := newArrays.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 16:34'!removeVectorSlotNamed: aSlotName	| index newArrays |	index := info at: aSlotName asSymbol ifAbsent: [^ self].	newArrays := (arrays copyFrom: 1 to: index - 1), (arrays copyFrom: index + 1 to: arrays size).	types replaceFrom: index to: types size - 1 with: types startingAt: index + 1.	info removeKey: aSlotName asSymbol.	arrays := newArrays.	self compileAllAccessors.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 10/27/2004 16:29'!renameVectorSlot: oldSlotName newSlotName: newSlotName	| index |	index := info at: oldSlotName asSymbol ifAbsent: [^ self].	info removeKey: oldSlotName asSymbol.	info at: newSlotName put: index.! !!KedamaTurtleVectorPlayer methodsFor: 'player protocol' stamp: 'yo 9/20/2004 17:59'!setVectorSlotTypeFor: slotName typeChosen: typeChosen	| index initVar |	index := info at: slotName asSymbol.	index = 0 ifTrue: [^ self].	initVar := self initialValueForSlotOfType: typeChosen.	types at: index put: typeChosen.	self compileAllAccessors.	arrays at: index put: (self arrayForType: typeChosen).	self perform: ('set', slotName capitalized, ':') asSymbol with: initVar.! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 10/30/2004 18:56'!addTurtlesCount: count ofPrototype: prototype for: aKedamaWorld positionAndColorArray: positionAndColorArray	| index array defaultValue newArray oldCount |	oldCount := self size.	info associationsDo: [:assoc |		index := info at: assoc key.		array := arrays at: (info at: assoc key).		defaultValue := prototype at: index.		newArray := array class new: count.		(#(who x y heading color normal) includes: assoc key) ifFalse: [			newArray atAllPut: defaultValue.		].		assoc key = #x ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray first startingAt: 1].		assoc key = #y ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray second startingAt: 1].		assoc key = #color ifTrue: [newArray replaceFrom: 1 to: newArray size with: positionAndColorArray third startingAt: 1].		assoc key = #heading ifTrue: [newArray atAllPut: 1.57079631 "Float pi / 2.0"].		assoc key = #normal ifTrue: [newArray atAllPut: 1.57079631 "Float pi / 2.0"].		arrays at: (assoc value) put: array, newArray.	].	#(who) do: [:name |		self setInitialValueOf: name from: oldCount + 1 to: self size for: aKedamaWorld.	].	whoTableValid := false.	turtleMapValid := false.	! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 9/18/2004 15:27'!addTurtlesCount: count ofPrototype: prototype for: aKedamaWorld randomize: randomizeFlag	| index array defaultValue newArray oldCount |	oldCount := self size.	info associationsDo: [:assoc |		index := info at: assoc key.		array := arrays at: index.		defaultValue := prototype at: index.		newArray := array class new: count.		newArray atAllPut: defaultValue.		arrays at: index put: (array, newArray).	].	self setInitialValueOf: #who from: oldCount + 1 to: self size for: aKedamaWorld.	randomizeFlag ifTrue: [		#(x y heading) do: [:name |			self setInitialValueOf: name from: oldCount + 1 to: self size for: aKedamaWorld.		].	].	whoTableValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'add turtles' stamp: 'yo 9/27/2004 16:14'!setTurtlesCount: count prototype: prototype for: aKedamaWorld randomize: rondomizeFlag	| anInteger array |	anInteger := count.	count < 0 ifTrue: [anInteger := 0].	self size > anInteger ifTrue: [		info associationsDo: [:assoc |			array := (arrays at: assoc value).			array := array copyFrom: 1 to: anInteger.			arrays at: assoc value put: array.		].		turtleMapValid := false.		whoTableValid := false.	].	self size < anInteger ifTrue: [		self addTurtlesCount: (anInteger - self size) ofPrototype: prototype for: aKedamaWorld randomize: rondomizeFlag.		turtleMapValid := false.		whoTableValid := false.	].! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 10/24/2004 18:45'!arrayForType: typeName	| newArray |	(typeName = #Number) ifTrue: [		newArray := KedamaFloatArray new: self size.	].	(typeName = #Color) ifTrue: [		newArray := WordArray new: self size.	].	(typeName = #Boolean) ifTrue: [		newArray := ByteArray new: self size.	].	newArray ifNil: [		newArray := Array new: self size.	].	^ newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/28/2004 17:16'!groupForward: dist	| x y headingRadians |	self size = 0 ifTrue: [^ self].	x := (arrays at: 2) first.	y := (arrays at: 3) first.	headingRadians := (arrays at: 4) first.	self groupSetX: (x + (dist asFloat * headingRadians cos)).	self groupSetY: (y - (dist asFloat * headingRadians sin)).! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/29/2004 08:35'!groupSetX: val	| xArray headingArray origX origHeading leftEdgeMode rightEdgeMode newArray wrapX minX maxX |	self size = 0 ifTrue: [^ self].	xArray := arrays at: 2.	headingArray := arrays at: 4.		origX := xArray first.	origHeading := headingArray first.	leftEdgeMode := kedamaWorld leftEdgeModeMnemonic.	rightEdgeMode := kedamaWorld rightEdgeModeMnemonic.	newArray := xArray collect: [:e | e + val - origX].	wrapX := kedamaWorld wrapX.	minX := newArray min.	maxX := newArray max.	((minX < 0.0) not and: [(maxX >= wrapX) not]) ifTrue: [		arrays at: 2 put: newArray.		^ self.	].	minX < 0.0 ifTrue: [		leftEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e < 0.0 ifTrue: [newArray at: i put: e + wrapX].			].		].		leftEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - minX.			].		].		leftEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e + (minX * -2.0).			].		].			].	maxX >= wrapX ifTrue: [		rightEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e >= wrapX ifTrue: [newArray at: i put: e - wrapX].			].		].		rightEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - (maxX - wrapX) - 2.35099e-038.			].		].		rightEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - ((maxX - wrapX) * 2.0) - 2.35099e-038.			].		].	].	arrays at: 2 put: newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 9/28/2004 17:58'!groupSetY: val	| yArray headingArray origY origHeading topEdgeMode bottomEdgeMode newArray wrapY minY maxY |	self size = 0 ifTrue: [^ self].	yArray := arrays at: 3.	headingArray := arrays at: 4.		origY := yArray first.	origHeading := headingArray first.	topEdgeMode := kedamaWorld topEdgeModeMnemonic.	bottomEdgeMode := kedamaWorld bottomEdgeModeMnemonic.	newArray := yArray collect: [:e | e + val - origY].	wrapY := kedamaWorld wrapY.	minY := newArray min.	maxY := newArray max.	((minY < 0.0) not and: [(maxY >= wrapY) not]) ifTrue: [		arrays at: 3 put: newArray.		^ self.	].	minY < 0.0 ifTrue: [		topEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e < 0.0 ifTrue: [newArray at: i put: e + wrapY].			].		].		topEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - minY.			].		].		topEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e + (minY * -2.0).			].		].			].	maxY >= wrapY ifTrue: [		bottomEdgeMode = 1 ifTrue: [			newArray withIndexDo: [:e :i |				e >= wrapY ifTrue: [newArray at: i put: e - wrapY].			].		].		bottomEdgeMode = 2 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - (maxY - wrapY) - 2.35099e-038.			].		].		bottomEdgeMode = 3 ifTrue: [			newArray withIndexDo: [:e :i |				newArray at: i put: e - ((maxY - wrapY) * 2.0) - 2.35099e-038.			].		].	].	arrays at: 3 put: newArray.! !!KedamaTurtleVectorPlayer methodsFor: 'private' stamp: 'yo 10/25/2004 16:23'!useKedamaFloatArray	| newArray |	arrays withIndexDo: [:array :index |		(array isMemberOf: FloatArray) ifTrue: [			newArray := KedamaFloatArray new: array size.			newArray replaceFrom: 1 to: array size with: array startingAt: 1.			arrays at: index put: newArray.		].	].! !!KedamaTurtleVectorPlayer methodsFor: 'accessing' stamp: 'yo 9/28/2004 14:02'!exampler: e	exampler := e.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 10/22/2004 07:10'!aTurtleAtX: xPos y: yPos	| w x y index who stub |	turtleMapValid ifFalse: [		self makeTurtlesMap.	].	w := kedamaWorld dimensions x.	x := xPos truncated.	y := yPos truncated.	x < 0 ifTrue: [^ nil].	x >= w ifTrue: [^ nil].	y < 0 ifTrue: [^ nil].	y >= kedamaWorld dimensions y ifTrue: [^ nil].	index := (w * y) + x + 1.	who := turtlesMap at: index.	who = 0 ifTrue: [^ nil].	who = lastWho ifTrue: [^ lastWhoStub].	stub := exampler clonedSequentialStub.	stub who: who.	lastWho := who.	^ lastWhoStub := stub.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/29/2004 17:24'!basicMakeTurtlesMap	| x y xArray yArray width height mapIndex whoArray |	xArray := arrays at: 2.	yArray := arrays at: 3.	whoArray := arrays at: 1.	width := kedamaWorld dimensions x.	height := kedamaWorld dimensions y.	turtlesMap atAllPut: 0.	1 to: self size do: [:index |		x := (xArray at: index) truncated.		y := (yArray at: index) truncated.		mapIndex := (width * y) + x + 1.		(0 < mapIndex and: [mapIndex <= turtlesMap size]) ifTrue: [			turtlesMap at: mapIndex put: (whoArray at: index).		].	].	turtleMapValid := true.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/28/2004 10:21'!invalidateTurtleMap	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'turtle map' stamp: 'yo 9/29/2004 17:31'!makeTurtlesMap	| xArray yArray width height whoArray ret |	xArray := arrays at: 2.	yArray := arrays at: 3.	whoArray := arrays at: 1.	width := kedamaWorld dimensions x.	height := kedamaWorld dimensions y.	turtlesMap ifNil: [turtlesMap := WordArray new: width * height].	ret := self primMakeTurtlesMap: turtlesMap whoArray: whoArray xArray: xArray yArray: yArray width: width height: height.	ret ifNil: [self basicMakeTurtlesMap].	turtleMapValid := true.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!basicGetAngleTo: players	| ret p xArray yArray result |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	1 to: self size do: [:index |		players isCollection ifTrue: [			p := players at: index.		].		ret := ((p getX - (xArray at: index))@(p getY - (yArray at: index))) theta radiansToDegrees + 90.0.		ret > 360.0 ifTrue: [ret := ret - 360.0].		result at: index put: ret.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!basicGetDistanceTo: players	| p xArray yArray result |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	1 to: self size do: [:index |		players isCollection ifTrue: [			p := players at: index.		].		result at: index put: ((p getX - (xArray at: index)) squared + (p getY - (yArray at: index)) squared) sqrt.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 4/5/2005 11:04'!colorFromPatch: aPatch	| xArray yArray cArray patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	cArray := arrays at: 5.	patch := aPatch costume renderedMorph.	1 to: self size do: [:i |		cArray at: i put: ((patch pixelAtX: (xArray at: i) y: (yArray at: i)) bitAnd: 16rFFFFFF).	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/12/2004 23:14'!colorToPatch: aPatch	| xArray yArray cArray patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	cArray := arrays at: 5.	patch := aPatch costume renderedMorph.	1 to: self size do: [:i |		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: (cArray at: i).	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/26/2004 11:34'!deleteTurtleID: who	| whoArray whoIndex newArray |	whoArray := arrays at: 1.	whoIndex := whoArray indexOf: who ifAbsent: [^ self].	deletingIndex := whoIndex - 1.	arrays withIndexDo: [:array :index |		newArray := (array copyFrom: 1 to: whoIndex - 1), (array copyFrom: whoIndex + 1 to: array size).		arrays at: index put: newArray.	].	whoTableValid := false.	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/30/2004 11:13'!forward: val	exampler getGrouped ifFalse: [		self primForwardXArray: (arrays at: 2) yArray: (arrays at: 3) headingArray: (arrays at: 4) value: (val isNumber ifTrue: [val asFloat] ifFalse: [val]) destWidth: kedamaWorld wrapX asFloat destHeight: kedamaWorld wrapY asFloat leftEdgeMode: kedamaWorld leftEdgeModeMnemonic rightEdgeMode: kedamaWorld rightEdgeModeMnemonic topEdgeMode: kedamaWorld topEdgeModeMnemonic bottomEdgeMode: kedamaWorld bottomEdgeModeMnemonic.	] ifTrue: [		self groupForward: val	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getAngleTo: players	| p xArray yArray result pX pY xy |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	players isCollection ifTrue: [		pX := KedamaFloatArray new: players size.		pY := KedamaFloatArray new: players size.		1 to: players size do: [:i |			xy := (players at: i) getXAndY.			pX at: i put: xy x.			pY at: i put: xy y.		].	] ifFalse: [		xy := p getXAndY.		pX := xy x.		pY := xy y.	].	^ self primGetAngleToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:34'!getBlueComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: (pix bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getDistanceTo: players	| p xArray yArray result pX pY xy |	players isCollection ifFalse: [		p := players	].	xArray := arrays at: 2.	yArray := arrays at: 3.	result := KedamaFloatArray new: self size.	players isCollection ifTrue: [		pX := KedamaFloatArray new: players size.		pY := KedamaFloatArray new: players size.		1 to: players size do: [:i |			xy := (players at: i) getXAndY.			pX at: i put: xy x.			pY at: i put: xy y.		].	] ifFalse: [		xy := p getXAndY.		pX := xy x.		pY := xy y.	].	^ self primGetDistanceToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:34'!getGreenComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: ((pix bitShift: -8) bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:45'!getHeading	| heading result ret |	heading := (arrays at: 4).	result := KedamaFloatArray new: heading size.	ret := self primGetHeading: heading into: result.	ret ifNotNil: [^ result].	! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:46'!getNormal	| result ret normal |	normal := (arrays at: 7).	result := KedamaFloatArray new: normal size.	ret := self primGetHeading: normal into: result.	ret ifNotNil: [^ result].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 16:44'!getPatchValueIn: aPatch	| w patch xArray yArray |	w := WordArray new: self size.	patch := aPatch costume renderedMorph.	xArray := arrays at: 2.	yArray := arrays at: 3.	patch pixelsAtXArray: xArray yArray: yArray into: w.	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 11:35'!getRedComponentIn: aPatch	| pix xArray yArray patch w |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	w := WordArray new: self size.	1 to: self size do: [:i |		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		w at: i put: ((pix bitShift: -16) bitAnd: 16rFF).	].	^ w.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 08:22'!getTurtleAt: aPlayer	| xy |	aPlayer isCollection ifTrue: [		self error: 'should not happen'.	].	xy := aPlayer getXAndY.	^ (self aTurtleAtX: xy x y: xy y) ifNil: [^ aPlayer].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 08:37'!getTurtleOf: aBreedPlayer	| xy |	aBreedPlayer isCollection ifTrue: [		"self error: 'should not happen'."		^ aBreedPlayer.	].	xy := aBreedPlayer getXAndY.	^ (self aTurtleAtX: xy x y: xy y) ifNil: [^ aBreedPlayer].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/24/2004 18:46'!getUphillIn: aPatch	| xArray yArray headingArray result patch |	xArray := arrays at: 2.	yArray := arrays at: 3.	headingArray := arrays at: 4.	result := KedamaFloatArray new: self size.	patch := aPatch costume renderedMorph.	1 to: self size do: [:index |		result at: index put: (patch			uphillForTurtleX: (xArray at: index)			turtleY: (yArray at: index)			turtleHeading: (headingArray at: index)).	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:21'!getX	| xArray |	exampler getGrouped ifFalse: [		^ arrays at: 2.	] ifTrue: [		xArray := arrays at: 2.		xArray size = 0 ifTrue: [^ exampler getX].		^ xArray first.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:22'!getY	| yArray |	exampler getGrouped ifFalse: [		^ arrays at: 3.	] ifTrue: [		yArray := arrays at: 3.		yArray size = 0 ifTrue: [^ exampler getY].		^ yArray first.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/16/2004 23:02'!heading: degrees	| deg |	deg := degrees isNumber ifTrue: [degrees asFloat] ifFalse: [degrees].	self primSetHeading: (arrays at: 4) from: deg.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 09:06'!normal: degrees	| deg |	deg := degrees isNumber ifTrue: [degrees asFloat] ifFalse: [degrees].	self primSetHeading: (arrays at: 7) from: deg.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:41'!setBlueComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := value asInteger bitAnd: 16rFF.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := (value at: i) asInteger bitAnd: 16rFF.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16rFFFF00) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:40'!setGreenComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := (value asInteger bitAnd: 16rFF) bitShift: 8.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := ((value at: i) asInteger bitAnd: 16rFF) bitShift: 8.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16rFF00FF) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 3/7/2005 13:41'!setInitialValueOf: name from: from to: to for: aKedamaWorld	| array max |	array := arrays at: (info at: name).	name = #who ifTrue: [		from to: to do: [:index |			array at: index put: (aKedamaWorld nextTurtleID).		].		^ self.	].	name = #x ifTrue: [		max := aKedamaWorld dimensions x * 100.		self primRandomRange: max from: from to: to intoFloatArray: array factor: 0.01.		^ self.	].	name = #y ifTrue: [		max := aKedamaWorld dimensions y * 100.		self primRandomRange: max from: from to: to intoFloatArray: array factor: 0.01.		^ self.	].	name = #heading ifTrue: [		self primRandomRange: 36000 from: from to: to intoFloatArray: array factor: (0.01 *  0.0174532925199433).		^ self.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/25/2004 16:57'!setPatchValueIn: aPatch to: value	| xArray yArray patchMorph |	xArray := arrays at: 2.	yArray := arrays at: 3.	patchMorph := aPatch costume renderedMorph.	patchMorph setPixelsAtXArray: xArray yArray: yArray value: value.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 10/13/2004 06:40'!setRedComponentIn: aPatch to: value	| pix xArray yArray patch component |	xArray := arrays at: 2.	yArray := arrays at: 3.	patch := aPatch costume renderedMorph.	value isCollection ifFalse: [		component := (value asInteger bitAnd: 16rFF) bitShift: 16.	].	(1 to: self size) do: [:i |		value isCollection ifTrue: [			component := ((value at: i) asInteger bitAnd: 16rFF) bitShift: 16.		].		pix := patch pixelAtX: (xArray at: i) y: (yArray at: i).		pix := (pix bitAnd: 16r00FFFF) bitOr: component.		patch pixelAtX: (xArray at: i) y: (yArray at: i) put: pix.	].! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:13'!setX: v	exampler getGrouped ifFalse: [		self			primSetX: (arrays at: 2)			headingArray: (arrays at: 4)			value: (v isNumber ifTrue: [v asFloat] ifFalse: [v])			destWidth: kedamaWorld wrapX			leftEdgeMode: kedamaWorld leftEdgeModeMnemonic			rightEdgeMode: kedamaWorld rightEdgeModeMnemonic.	] ifTrue: [		self groupSetX: v	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'player commands' stamp: 'yo 9/29/2004 14:13'!setY: v	exampler getGrouped ifFalse: [		self			primSetY: (arrays at: 3)			headingArray: (arrays at: 4)			value: (v isNumber ifTrue: [v asFloat] ifFalse: [v])			destHeight: kedamaWorld wrapY			topEdgeMode: kedamaWorld topEdgeModeMnemonic			bottomEdgeMode: kedamaWorld bottomEdgeModeMnemonic.	] ifTrue: [		self groupSetY: v.	].	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'deleting' stamp: 'yo 10/8/2004 11:04'!delete	| anInstance |	exampler := nil.	arrays := nil.	whoTable := nil.	turtlesMap := nil.	self class removeFromSystem: false.	anInstance := UnscriptedPlayer new.	self become: anInstance.! !!KedamaTurtleVectorPlayer methodsFor: 'displaying' stamp: 'yo 9/16/2004 21:40'!drawOn: aForm	| xArray yArray colorArray visibleArray bits x y visible bitsIndex dimX dimY ret |	xArray := arrays at: 2.	yArray := arrays at: 3.	colorArray := arrays at: 5.	visibleArray := arrays at: 6.	bits := aForm bits.	dimX := aForm width.	dimY := aForm height.	ret := self primDrawOn: bits destWidth: dimX destHeight: dimY xArray: xArray yArray: yArray colorArray: colorArray visibleArray: visibleArray.	ret ifNotNil: [^ self].	1 to: self size do: [:index |		x := (xArray at: index) truncated.		y := (yArray at: index) truncated.		visible := (visibleArray at: index) ~= 0.		(visible and: [((x >= 0) and: [y >= 0]) and: [(x < dimX) and: [y < dimY]]]) ifTrue: [			bitsIndex := ((y * dimX) + x) + 1.			bits at: bitsIndex put: (colorArray at: index).		].	].! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/27/2004 15:16'!indexOf: who	| whoArray |	whoTableValid ifTrue: [^ whoTable at: (who - whoTableBase)].	whoArray := arrays at: 1.	whoArray size = 0 ifTrue: [^ 0].	whoTableBase := whoArray first - 1.	whoTable := WordArray new: whoArray last - whoTableBase.	1 to: whoArray size do: [:w |		whoTable at: (whoArray at: w) - whoTableBase put: w.	].	whoTableValid := true.	^ whoTable at: (who - whoTableBase).! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/18/2004 12:02'!initializeDeletingIndex	deletingIndex := 0.! !!KedamaTurtleVectorPlayer methodsFor: 'enumeration' stamp: 'yo 9/18/2004 12:02'!nextDeletingIndex	^ deletingIndex := deletingIndex + 1.! !!KedamaTurtleVectorPlayer methodsFor: 'initialization' stamp: 'yo 10/24/2004 18:46'!initialize	super initialize.	info := IdentityDictionary new.	info at: #who put: 1.	info at: #x put: 2.	info at: #y put: 3.	info at: #heading put: 4.	info at: #color put: 5.	info at: #visible put: 6.	info at: #normal put: 7.	arrays := Array new: 7.	arrays at: (info at: #who) put: (WordArray new: 0).	arrays at: (info at: #x) put: (KedamaFloatArray new: 0).	arrays at: (info at: #y) put: (KedamaFloatArray new: 0).	arrays at: (info at: #heading) put: (KedamaFloatArray new: 0).	arrays at: (info at: #color) put: (WordArray new: 0).	arrays at: (info at: #visible) put: (ByteArray new: 0).	arrays at: (info at: #normal) put: (KedamaFloatArray new: 0).	types := Array new: 64.	types at: 1 put: #Integer.	types at: 2 put: #Number.	types at: 3 put: #Number.	types at: 4 put: #Number.	types at: 5 put: #Color.	types at: 6 put: #Boolean.	types at: 7 put: #Number.	whoTableValid := false.	turtleMapValid := false.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:49'!primDrawOn: destBits destWidth: destWidth destHeight: destHeight xArray: xArray yArray: yArray colorArray: colorArray visibleArray: visibleArray	| x y visible bitsIndex |	<primitive: 'drawTurtlesInArray' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #drawTurtlesInArray."	1 to: xArray size do: [:i |		x := (xArray at: i) asInteger.		y := (yArray at: i) asInteger.		visible := (visibleArray at: i).		(visible ~= 0 and: [((x >= 0) and: [y >= 0]) and: [(x < destWidth) and: [y < destHeight]]]) ifTrue: [			bitsIndex := ((y * destWidth) + x) + 1.			destBits at: bitsIndex put: (colorArray at: i).		]	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:04'!primForwardXArray: xArray yArray: yArray headingArray: headingArray value: v destWidth: destWidth destHeight: destHeight leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| dist newX newY |	<primitive: 'primTurtlesForward' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primTurtlesForward."	1 to: xArray size do: [:i |		v isCollection ifTrue: [			dist := (v at: i) asFloat.		] ifFalse: [			dist := v asFloat.		].		newX := (xArray at: i) + (dist * (headingArray at: i) cos).		newY := (yArray at: i) - (dist * (headingArray at: i) sin).		KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.		KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/23/2004 22:19'!primGetAngleToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result	| ppx ppy x y ret |	<primitive: 'vectorGetAngleTo' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #vectorGetAngleTo."	ppx := pX.	ppy := pY.	1 to: result size do: [:index |		pX isCollection ifTrue: [			ppx := pX at: index.			ppy := pY at: index.		].		x := ppx - (xArray at: index).		y := ppy - (yArray at: index).		ret := (x@y) theta radiansToDegrees + 90.0.		ret > 360.0 ifTrue: [ret := ret - 360.0].		result at: index put: ret.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/23/2004 18:02'!primGetDistanceToX: pX toY: pY xArray: xArray yArray: yArray resultInto: result	| ppx ppy |	<primitive: 'vectorGetDistanceTo' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #vectorGetDistanceTo."	ppx := pX.	ppy := pY.	1 to: result size do: [:index |		pX isCollection ifTrue: [			ppx := pX at: index.			ppy := pY at: index.		].		result at: index put: ((ppx - (xArray at: index)) squared + (ppy - (yArray at: index)) squared) sqrt.	].	^ result.! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/9/2004 17:29'!primGetHeading: headingArray into: resultArray	| heading |	<primitive: 'getHeadingArrayInto' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #getHeadingArrayInto."	1 to: headingArray size do: [:i |		heading := headingArray at: i.		heading := heading / 0.0174532925199433.		heading := 90.0 - heading.		heading > 0.0 ifFalse: [heading := heading + 360.0].		resultArray at: i put: heading.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:40'!primSetHeading: headingArray from: val	| heading |	<primitive: 'setHeadingArrayFrom' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #setHeadingArrayFrom."	val isCollection ifFalse: [		heading := val asFloat.		heading := KedamaMorph degreesToRadians: heading.	].	1 to: headingArray size do: [:i |		val isCollection ifTrue: [			heading := val at: i.			heading := KedamaMorph degreesToRadians: heading.		].		headingArray at: i put: heading.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:19'!primSetX: xArray headingArray: headingArray value: v destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode	| val newX |	<primitive: 'turtlesSetX' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #turtlesSetX."	v isCollection ifFalse: [		val := v asFloat.	].	1 to: xArray size do: [:i |		v isCollection ifTrue: [			newX := v at: i.		] ifFalse: [			newX := val.		].		KedamaMorph scalarXAt: i xArray: xArray headingArray: headingArray value: newX destWidth: destWidth leftEdgeMode: leftEdgeMode rightEdgeMode: rightEdgeMode.	].! !!KedamaTurtleVectorPlayer methodsFor: 'primitives' stamp: 'yo 10/11/2004 11:21'!primSetY: yArray headingArray: headingArray value: v destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode	| val newY |	<primitive: 'turtlesSetY' module: 'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #turtlesSetY."	v isCollection ifFalse: [		val := v asFloat.	].	1 to: yArray size do: [:i |		v isCollection ifTrue: [			newY := v at: i.		] ifFalse: [			newY := val.		].		KedamaMorph scalarYAt: i yArray: yArray headingArray: headingArray value: newY destHeight: destHeight topEdgeMode: topEdgeMode bottomEdgeMode: bottomEdgeMode.	].! !!KedamaUpHillTile methodsFor: 'initialization-support' stamp: 'yo 4/5/2005 14:53'!addPatchTile	| m1 desiredW m2 label |	self removeAllMorphs.	m1 := TilePadMorph new.	label := 	StringMorph contents: 'upHillIn' translated font: ScriptingSystem fontForTiles.	m2 := TileMorph new.	m2 extent: 20@22.	m2 minWidth: 20.	m1 extent: (m2 extent + (2@2)).	m1 setType: #Patch.	m1 addMorph: m2.	desiredW := m1 width + 6.	self extent: (desiredW max: self basicWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2)) @ (bounds top + 1).	self addMorphBack: m1.	self addMorphFront: label.	patchTile := m1.! !!KedamaUpHillTile methodsFor: 'initialization' stamp: 'yo 6/7/2004 18:34'!initialize	super initialize.	type := #Patch.	operatorOrExpression := #getUphillIn:.	self addPatchTile.! !!KedamaUpHillTile methodsFor: 'tile protocol' stamp: 'yo 4/5/2005 14:53'!line1: line1	| label |	self removeAllMorphs.	label := 	StringMorph contents: 'upHillIn' translated font: ScriptingSystem fontForTiles.	self addMorphBack: label.	self addMorphBack: patchTile.! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 9/24/2004 11:47'!checkFirstPairFor: stmt in: obj	^ self checkRequireVectorIn: stmt for: obj."	| receiver selector ret |	receiver := Compiler evaluate: (self getReceiverFromStatement: stmt) name for: obj logged: false.	selector := (self getSelectorFromStatement: stmt) key.	ret := self isVectorizationRequiredWithPlayer: receiver andSelector: selector.	attributes setAttribute: #firstTurtle of: stmt to: receiver.	attributes setAttribute: #requireVector of: stmt to: ret.	^ ret."! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 2/14/2005 15:33'!checkRequireVectorIn: aMessageNode for: obj	| players playersSet sel playerNodes |	"self halt."	playerNodes := self getAllPlayersIn: aMessageNode for: obj.	players := playerNodes collect: [:e | Compiler evaluate: e name for: obj logged: false.].	playersSet := players asSet.	(playersSet select: [:e | e isPrototypeTurtlePlayer]) size = 0 ifTrue: [		attributes setAttribute: #firstTurtle of: aMessageNode to: (Compiler evaluate: playerNodes first name for: obj logged: false).		attributes setAttribute: #requireVector of: aMessageNode to: false.		^ self.	].	(playersSet select: [:e | e isPrototypeTurtlePlayer]) size > 0 ifTrue: [			playerNodes with: players do: [:n :p |			p isPrototypeTurtlePlayer ifTrue: [				sel := self getSelectorRootFor: p fromMessageNode: aMessageNode for: obj ignoreSelectors: #(beNotZero: setTurtleCount: getTurtleCount setGrouped: getGrouped).				sel ifNotNil: [					(self isVectorizationRequiredWithPlayer: p andSelector: sel) ifTrue: [						attributes setAttribute: #requireVector of: aMessageNode to: true.						attributes setAttribute: #firstTurtle of: aMessageNode to: p.						attributes setAttribute: #firstNode of: aMessageNode to: n.						^ self.					].				].			].		].	].	attributes setAttribute: #firstTurtle of: aMessageNode to: players first.	attributes setAttribute: #requireVector of: aMessageNode to: false.! !!KedamaVectorizer methodsFor: 'private' stamp: 'yo 9/24/2004 12:11'!vectorizeAt: index inMethodNode: aMethodNode	| v encoder origReceiverName origReceiver aMessageNode |	aMessageNode := aMethodNode block statements at: index.	(attributes getAttribute: #requireVector of: aMessageNode) ifFalse: [^ self].	encoder := aMethodNode encoder.	encoder autoBind: 'xxxObj'.	v := encoder encodeVariable: 'xxxObj' sourceRange: nil ifUnknown: [].	origReceiver := attributes getAttribute: #firstNode of: aMessageNode.	(origReceiver isMemberOf: VariableNode) ifTrue: [		origReceiverName := origReceiver name.	] ifFalse: [		origReceiverName := 'self'.	].	self replaceRoot: origReceiverName with: v inMessageNode: aMessageNode.	"self changeSelectorAt: index inMethodNode: aMethodNode."	self insertTurtleCommandAt: index in: aMethodNode block statements variableNode: v from: encoder firstReceiverName: origReceiverName.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 10/8/2004 05:23'!getAllPlayersInMethodNode: aMethodNode for: obj	| aCollection |	aCollection := OrderedCollection new.	aMethodNode block statements do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection.		].	].	^ aCollection.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 11:13'!getAllPlayersIn: aMessageNode for: obj	| aCollection |	aCollection := OrderedCollection new.	self getPlayersMessage: aMessageNode for: obj into: aCollection.	^ aCollection.! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 11:08'!getPlayersBlock: aBlockNode for: obj into: aCollection	| statements |	statements := aBlockNode statements.	statements do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection..		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 9/24/2004 12:02'!getPlayersMessage: aMessageNode for: obj into: aCollection	| thisPlayer |	((Array with: aMessageNode receiver), aMessageNode arguments) do: [:stmt |		(stmt isMemberOf: MessageNode) ifTrue: [			self getPlayersMessage: stmt for: obj into: aCollection.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getPlayersBlock: stmt for: obj into: aCollection..		].		(stmt isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: stmt name for: obj logged: false.			(thisPlayer isKindOf: Player) ifTrue: [aCollection add: stmt].		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 2/14/2005 15:34'!getSelectorFor: receiver fromMessageNode: aMessageNode for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors	| thisPlayer key |	root ifNotNil: [^ self].	(Array with: aMessageNode receiver), aMessageNode arguments do: [:stmt |		(stmt isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: stmt name for: obj logged: false.			thisPlayer == receiver ifTrue: [				key :=  aMessageNode selector key.				(ignoreSelectors includes: key) ifFalse: [aBlock value: key. ^ self]].		].		(stmt isMemberOf: MessageNode) ifTrue: [			self getSelectorFor: receiver fromMessageNode: stmt for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors		].		(stmt isMemberOf: BlockNode) ifTrue: [			self getSelectorFor: receiver fromBlockNode: stmt for: obj ifFoundDo: aBlock ignoreSelectors: ignoreSelectors		].	].! !!KedamaVectorizer methodsFor: 'player and selector look up' stamp: 'yo 2/14/2005 15:25'!getSelectorRootFor: receiver fromMessageNode: aMessageNode for: obj ignoreSelectors: ignoreSelectors	| val |	root := nil.	self getSelectorFor: receiver fromMessageNode: aMessageNode for: obj ifFoundDo: [:sel | root := sel] ignoreSelectors: ignoreSelectors.	val := root.	root := nil.	^ val.! !!KedamaVectorizer methodsFor: 'entry point' stamp: 'yo 10/8/2004 05:33'!includesTurtlePlayer: aMethodNode for: obj	| players p |	players := self getAllPlayersInMethodNode: aMethodNode for: obj.	players do: [:e |		p := Compiler evaluate: e name for: obj logged: false.		(p isKindOf: KedamaExamplerPlayer) ifTrue: [^ true].	].	^ false.! !!KedamaVectorizer methodsFor: 'initialization' stamp: 'yo 8/28/2004 00:47'!initialize	attributes := KedamaAttributeDictionary new initialize.! !!KedamaVectorizer methodsFor: 'insert block node' stamp: 'yo 9/18/2004 12:08'!insertTurtleCommandAt: index in: statements variableNode: varNode from: encoder firstReceiverName: origName	| messageNode blockNode newMessageNode selector |	messageNode := statements at: index.	(attributes getAttribute: #requireVector of: messageNode) ifFalse: [^ self].	blockNode := BlockNode new arguments: (Array with: varNode) statements: (Array with: messageNode) returns: false from: encoder.	selector := (attributes getAttribute: #dieMessage of: messageNode) ifNotNil: [#doDieCommand:].	selector ifNil: [		selector := (attributes getAttribute: #constant of: messageNode) ifTrue: [#doCommand:] ifFalse: [#doSequentialCommand:].	].			newMessageNode := MessageNode new				receiver: (encoder encodeVariable: origName)				selector: selector				arguments: (Array with: blockNode)				precedence: 3				from: encoder				sourceRange: nil.	statements at: index put: newMessageNode.! !!KedamaVectorizer methodsFor: 'replace receiver' stamp: 'yo 10/9/2004 15:56'!replace: varName with: newNode inMessageNode: aMessageNode	| receiver att |	aMessageNode arguments withIndexDo: [:e :index |		(e isMemberOf: MessageNode) ifTrue: [			self replace: varName with: newNode inMessageNode: e.		].		(e isMemberOf: BlockNode) ifTrue: [			self replace: varName with: newNode inBlockNode: e.		].		(e isMemberOf: VariableNode) ifTrue: [			att := attributes getAttribute: #isTurtle of: e.			((att notNil & att) and: [e name = varName]) ifTrue: [aMessageNode arguments at: index put: newNode].		].	].	receiver := aMessageNode receiver.	(receiver isMemberOf: MessageNode) ifTrue: [		self replace: varName with: newNode inMessageNode: receiver.	].	(receiver isMemberOf: VariableNode) ifTrue: [		att := attributes getAttribute: #isTurtle of: receiver.		((att notNil & att) and: [receiver name = varName]) ifTrue: [aMessageNode receiver: newNode].	].! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 9/17/2004 11:20'!traverseBlock: aBlockNode in: obj firstPlayer: firstPlayer inCondition: inCondition	| value statements |	statements := aBlockNode statements.	statements do: [:stmt |		(stmt isMemberOf: MessageNode)	ifTrue: [			self traverseMessage: stmt in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(stmt isMemberOf: BlockNode) ifTrue: [			self traverseBlock: stmt in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(stmt isMemberOf: VariableNode) ifTrue: [			attributes setAttribute: #constant of: stmt to: false		].		(stmt isMemberOf: LiteralNode) ifTrue: [			attributes setAttribute: #constant of: stmt to: true		].	].	value := statements collect: [:stmt | attributes getAttribute: #constant of: stmt].	value := value inject: true into: [:s :t | s & t].	attributes setAttribute: #constant of: aBlockNode to: value.! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 9/24/2004 09:20'!traverseMessageRoot: aMessageNode in: obj firstPlayer: firstPlayer	| inCondition |	inCondition := #(ifTrue: ifFalse: ifTrue:ifFalse:) includes: aMessageNode selector key.	root := aMessageNode.	self traverseMessage: aMessageNode in: obj firstPlayer: firstPlayer inCondition: inCondition.! !!KedamaVectorizer methodsFor: 'vectorization attribute calculation' stamp: 'yo 3/7/2005 08:36'!traverseMessage: aMessageNode in: obj firstPlayer: firstPlayer inCondition: inCondition	| receiver thisPlayer ret constant proto |	aMessageNode arguments do: [:argument |		(argument isMemberOf: MessageNode) ifTrue: [			self traverseMessage: argument in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(argument isMemberOf: BlockNode) ifTrue: [			self traverseBlock: argument in: obj firstPlayer: firstPlayer inCondition: inCondition.		].		(argument isMemberOf: LiteralNode) ifTrue: [			attributes setAttribute: #constant of: argument to: true.		].		(argument isMemberOf: VariableNode) ifTrue: [			thisPlayer := Compiler evaluate: argument name for: obj logged: false.			ret := (thisPlayer isKindOf: Player) and: [thisPlayer costume renderedMorph isKindOf: KedamaPatchMorph].			attributes setAttribute: #constant of: argument to: ret.		].	].	receiver := aMessageNode receiver.	(receiver isMemberOf: MessageNode) ifTrue: [		self traverseMessage: receiver in: obj firstPlayer: firstPlayer inCondition: inCondition.	].	(receiver isMemberOf: BlockNode) ifTrue: [		self traverseBlock: receiver in: obj firstPlayer: firstPlayer inCondition: inCondition.	].	(receiver isMemberOf: LiteralNode) ifTrue: [		attributes setAttribute: #constant of: receiver to: true.	].	(receiver isMemberOf: VariableNode) ifTrue: [		thisPlayer := Compiler evaluate: receiver name for: obj logged: false.		ret := thisPlayer == firstPlayer.		attributes setAttribute: #constant of: receiver to: ret.		proto := (thisPlayer isKindOf: Player) and: [thisPlayer isPrototypeTurtlePlayer].		attributes setAttribute: #isTurtle of: receiver to: proto.		attributes setAttribute: #scalar of: aMessageNode selector to:		(ret not and: [(proto and: [self isScalarizable: thisPlayer andSelector: aMessageNode selector key])]).	].	"special cases..."	(#(atRandom die getReplicated bounceOn: bounceOn:color: bounceOnColor: ifTrue: ifFalse: ifTrue:ifFalse: itFalse:ifTrue:	setPatchValueIn:to: getTurtleAt: getTurtleOf:) includes: aMessageNode selector key) ifTrue: [		attributes setAttribute: #constant of: aMessageNode to: false.		aMessageNode selector key = #die ifTrue: [			attributes setAttribute: #dieMessage of: root to: true.		].	] ifFalse: [		constant := (aMessageNode arguments copyWith: receiver) inject: true into: [:s :t | s := s and: [attributes getAttribute: #constant of: t]].		attributes setAttribute: #constant of: aMessageNode to: constant.	].! !!KedamaWhoSearchingViewer methodsFor: 'initialization' stamp: 'yo 4/4/2005 14:33'!addNamePaneTo: header	"Add the namePane, which may be a popup or a type-in depending on the type of CategoryViewer"	| plugTextMor searchButton |	namePane := AlignmentMorph newRow vResizing: #spaceFill; height: 14.	namePane hResizing: #spaceFill.	namePane listDirection: #leftToRight.	plugTextMor := PluggableTextMorph on: self					text: #searchString accept: #searchString:notifying:					readSelection: nil menu: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor setNameTo: 'Turtle' translated.	plugTextMor vResizing: #spaceFill; hResizing: #spaceFill.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor setTextMorphToSelectAllOnMouseEnter.	searchButton := SimpleButtonMorph new 		target: self;		beTransparent;		label: 'Turtle' translated;		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	searchButton setBalloonText: 'Type a number into the pane to specify the individual turtle.' translated.	namePane addMorphFront: searchButton.	namePane addTransparentSpacerOfSize: 6@0.	namePane addMorphBack: plugTextMor.	header addMorphBack: namePane! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/4/2005 18:03'!doSearchFrom:  aSource interactive: isInteractive	"Perform the search operation.  If interactive is true, this actually happened because a search button was pressed; if false, it was triggered some other way for which an informer would be inappropriate."	| searchFor |	searchString := (aSource isKindOf: PluggableTextMorph)		ifFalse:			[aSource]		ifTrue:			[aSource text string].	searchFor := searchString asNumber asInteger.	(self outerViewer isMemberOf: KedamaStandardViewer) ifTrue: [		self outerViewer providePossibleRestrictedView: searchFor.		self updateWhoString.	].! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!rawSearchString: aString	"Set the search string as indicated"	searchString := aString asString! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!searchString	"Answer the search string"	^ searchString ifNil: [searchString := '']! !!KedamaWhoSearchingViewer methodsFor: 'search' stamp: 'yo 4/3/2005 09:16'!searchString: aString notifying: znak	"Set the search string as indicated and carry out a search"	searchString := aString asString.	self doSearchFrom: searchString! !!KeyedIdentitySet methodsFor: 'private' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Same as super except change = to ==, and hash to identityHash"	| element start finish |	finish := array size.	start := (anObject identityHash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 10/6/2000 20:28'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| obj |	obj := array at: (self findElementOrNil: key).	obj ifNil: [^ aBlock value].	^ obj! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 9/5/2000 03:58'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v := self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 7/3/2004 17:55'!keys	| keys |	keys := Set new.	self keysDo: [:key | keys add: key].	^ keys! !!KeyedSet methodsFor: 'accessing' stamp: 'ajh 5/11/2002 13:28'!keysSorted	| keys |	keys := SortedCollection new.	self do: [:item | keys add: (keyBlock value: item)].	^ keys! !!KeyedSet methodsFor: 'adding' stamp: 'md 3/14/2006 12:37'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: (keyBlock value: newObject).	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!KeyedSet methodsFor: 'adding' stamp: 'ajh 6/3/2002 10:11'!member: newObject	"Include newObject as one of the receiver's elements, if already exists just return it"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: (keyBlock value: newObject).	(array at: index) ifNotNil: [^ array at: index].	self atNewIndex: index put: newObject.	^ newObject! !!KeyedSet methodsFor: 'copying' stamp: 'ajh 9/5/2000 03:56'!postCopyBlocks	keyBlock := keyBlock copy.	"Fix temps in case we're referring to outside stuff"	keyBlock fixTemps.! !!KeyedSet methodsFor: 'initialize' stamp: 'ajh 9/5/2000 03:36'!keyBlock: oneArgBlock	"When evaluated return the key of the argument which will be an element of the set"	keyBlock := oneArgBlock! !!KeyedSet methodsFor: 'removing' stamp: 'ajh 9/5/2000 03:47'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: (keyBlock value: oldObject).	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!KeyedSet methodsFor: 'removing' stamp: 'ajh 3/29/2001 19:03'!removeKey: key ifAbsent: aBlock	| index obj |	index := self findElementOrNil: key.	(obj := array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ obj! !!KeyedSet methodsFor: 'private' stamp: 'ajh 9/5/2000 03:44'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex :=  1]			ifFalse: [oldIndex :=  oldIndex + 1].	(element := self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex := self findElementOrNil: (keyBlock value: element).			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!KeyedSet methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	super initialize: n.	keyBlock := [:element | element key].! !!KeyedSet methodsFor: 'private' stamp: 'ajh 9/5/2000 03:46'!noCheckAdd: anObject	array at: (self findElementOrNil: (keyBlock value: anObject)) put: anObject.	tally := tally + 1! !!KeyedSet methodsFor: 'private' stamp: 'ajh 12/13/2001 00:17'!rehash	| newSelf |	newSelf := self species new: self size.	newSelf keyBlock: keyBlock.	self do: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!KeyedSet methodsFor: 'private' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'wiz 5/19/2008 14:17'!tearDownPreferences restoreDefaultFonts! !!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'wiz 10/27/2006 00:56'!testIsFontAvailable"self new testIsFontAvailable""self run: #testIsFontAvailable"| oldPref |oldPref := Preferences valueOfPreference: #tinyDisplay .Preferences enable: #tinyDisplay .self shouldnt: [ [ ( LanguageEnvironment localeID: 'en' ) isFontAvailable ] 					ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref] ] 	raise: Error.^true! !!LanguageEnvironment methodsFor: 'fonts support' stamp: 'wiz 9/8/2007 00:19'!isFontAvailable	| encoding f |	encoding := self leadingChar + 1.	f _ TextStyle defaultFont.	f isFontSet ifTrue: [		f fontArray			at: encoding			ifAbsent: [^ false].		^ true	].	encoding = 1 ifTrue: [^ true].	f fallbackFont isFontSet ifFalse: [^false].	f fallbackFont fontArray		at: encoding		ifAbsent: [^ false].	^ true! !!LanguageEnvironment commentStamp: '<historical>' prior: 0!The name multilingualized Squeak suggests that you can use multiple language at one time.  This is true, of course, but the system still how to manage the primary language; that provides the interpretation of data going out or coming in from outside world. It also provides how to render strings, as there rendering rule could be different in one language to another, even if the code points in a string is the same.  Originally, LanguageEnvironment and its subclasses only has class side methods.  After merged with Diego's Babel work, it now has instance side methods.  Since this historical reason, the class side and instance side are not related well.  When we talk about the interface with the outside of the Squeak world, there are three different "channels"; the keyboard input, clipboard output and input, and filename.  On a not-to-uncommon system such as a Unix system localized to Japan, all of these three can have (and does have) different encodings.  S   o       w   e       n   e   e   d       t   o       m   a   n   a   g   e       t   h   e   m       s   e   p   a   r   a   t   e   l   y   .           N   o   t   e       t   h   a   t       t   h   e       e   n   c   o   d   i   n   g       i   n       a       f   i   l   e       c   a   n       b   e       a   n   y   t   h   i   n   g   .           W   h   i   l   e       i   t       i   s       n   i   c   e       t   o       p   r   o   v   i   d   e       a       s   u   g   g   e   s   t   e   d       g   u   e   s   s       f   o   r       t   h   i   s       '   d   e   f   a   u   l   t       s   y   s   t   e   m       f   i   l   e       c   o   n   t   e   n   t       e   n   c   o   d   i   n   g   '   ,       i   t       i   s       n   o   t       c   r   i   t   i   c   a   l   .                 R   e   n   d   e   r   i   n   g       s   u   p   p   o   r   t       i   s       l   i   m   i   t   e   d       b   a   s   i   c       L   -   t   o   -   R       r   e   n   d   e   r   i   n   g       s   o       f   a   r   .           B   u   t       y   o   u       c   a   n       p   r   o   v   i   d   e       d   i   f   f   e   r   e   n   t       l   i   n   e   -   w   r   a   p       r   u   l   e   ,       a   t       l   e   a   s   t   .      !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:48'!defaultClipboardInterpreter	SmalltalkImage current platformName = 'Win32' ifTrue:[^UTF8ClipboardInterpreter new].	ClipboardInterpreterClass ifNil: [ClipboardInterpreterClass := self currentPlatform class clipboardInterpreterClass].	^ ClipboardInterpreterClass new.! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'ar 6/3/2007 18:49'!defaultFileNameConverter	SmalltalkImage current  platformName = 'Win32' ifTrue:[^UTF8TextConverter new].	FileNameConverterClass		ifNil: [FileNameConverterClass := self currentPlatform class fileNameConverterClass].	^ FileNameConverterClass new! !!Lexicon methodsFor: '*eToys-tiles' stamp: 'nb 6/17/2003 12:25'!acceptTiles	| pp pq methodNode cls sel |	"In complete violation of all the rules of pluggable panes, search dependents for my tiles, and tell them to accept."	pp := self dependents detect: [:pane | pane isKindOf: PluggableTileScriptorMorph] 			ifNone: [^ Beeper beep].	pq := pp findA: TransformMorph.	methodNode := pq findA: SyntaxMorph.	cls := methodNode parsedInClass.	sel := cls compile: methodNode decompile classified: self selectedCategoryName			notifying: nil.	self noteAcceptanceOfCodeFor: sel.	self reformulateListNoting: sel.! !!Lexicon methodsFor: '*eToys-tiles' stamp: 'nk 4/28/2004 10:15'!installTilesForSelection	"Install universal tiles into the code pane."	| source aSelector aClass tree syn tileScriptor aWindow codePane |	(aWindow := self containingWindow)		ifNil: [self error: 'hamna dirisha'].	aSelector := self selectedMessageName.	aClass := self selectedClassOrMetaClass				ifNil: [targetClass].	aClass		ifNotNil: [aSelector				ifNil: [source := SyntaxMorph sourceCodeTemplate]				ifNotNil: [aClass := self selectedClassOrMetaClass whichClassIncludesSelector: aSelector.					source := aClass sourceCodeAt: aSelector].			tree := Compiler new						parse: source						in: aClass						notifying: nil.			(syn := tree asMorphicSyntaxUsing: SyntaxMorph) parsedInClass: aClass.			tileScriptor := syn inAPluggableScrollPane].	codePane := aWindow				findDeepSubmorphThat: [:m | (m isKindOf: PluggableTextMorph)						and: [m getTextSelector == #contents]]				ifAbsent: [].	codePane		ifNotNil: [codePane hideScrollBars].	codePane		ifNil: [codePane := aWindow						findDeepSubmorphThat: [:m | m isKindOf: PluggableTileScriptorMorph]						ifAbsent: [self error: 'no code pane']].	tileScriptor color: aWindow paneColorToUse;		 setProperty: #hideUnneededScrollbars toValue: true.	aWindow replacePane: codePane with: tileScriptor.	currentCompiledMethod := aClass				ifNotNil: [aClass						compiledMethodAt: aSelector						ifAbsent: []].	tileScriptor owner clipSubmorphs: true.	tileScriptor extent: codePane extent! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BG 3/13/2004 13:18'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd := position + aCollection size.	newEnd > limit ifTrue: [		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).		^ limitBlock value.	].	newEnd > writeLimit ifTrue: [		self growTo: newEnd + 10	].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position := newEnd.! !!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'di 6/20/97 09:07'!setLimit: sizeLimit limitBlock: aBlock	"Limit the numer of elements this stream will write..."	limit := sizeLimit.	"Execute this (typically ^ contents) when that limit is exceded"	limitBlock := aBlock! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 19:16'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock := aBlock fixTemps.	self updatePosition! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:45'!linesUpToEnd	| elements ln |	elements := OrderedCollection new.	[(ln := self nextLine) isNil] whileFalse: [ 		elements add: ln].	^elements! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!next	"Provide character-based access"	position isNil ifTrue: [^nil].	position < line size ifTrue: [^line at: (position := position + 1)].	line := stream nextLine.	self updatePosition.	^ Character cr! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:09'!nextLine	| thisLine |	self atEnd ifTrue: [^nil].	thisLine := line.	line := stream nextLine.	^thisLine! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 16:53'!skipThisLine	line := stream nextLine.	self updatePosition.! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 2/19/1999 11:47'!upToEnd	| ln |	^String streamContents: [:strm |		[(ln := self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'bf 11/24/1998 14:37'!updatePosition	"Call this before doing character-based access"	position := self atEnd ifFalse: [0]! !!LimitingLineStreamWrapper methodsFor: 'private' stamp: 'bf 11/24/1998 14:30'!setStream: aStream delimiter: aString	stream := aStream.	line := stream nextLine.	self delimiter: aString.	"sets position"! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 11:48'!example1	"LimitingLineStreamWrapper example1"	"Separate chunks of text delimited by a special string"	| inStream msgStream messages |	inStream := self exampleStream.	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.	messages := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine.		messages add: msgStream upToEnd].	^messages			! !!LimitingLineStreamWrapper class methodsFor: 'examples' stamp: 'bf 2/19/1999 12:46'!example2	"LimitingLineStreamWrapper example2"	"Demo nesting wrappers - get header lines from some messages"	| inStream msgStream headers headerStream |	inStream := self exampleStream.	msgStream := LimitingLineStreamWrapper on: inStream delimiter: 'From '.	headers := OrderedCollection new.	[inStream atEnd] whileFalse: [		msgStream skipThisLine. "Skip From"		headerStream := LimitingLineStreamWrapper on: msgStream delimiter: ''.		headers add: headerStream linesUpToEnd.		[msgStream nextLine isNil] whileFalse. "Skip Body"	].	^headers			! !!Line methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm	| newPath newLine |	newPath := aTransformation applyTo: self.	newLine := Line new.	newLine beginPoint: newPath firstPoint.	newLine endPoint: newPath secondPoint.	newLine form: self form.	newLine		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Line class methodsFor: 'examples'!example	"Designate two places on the screen by clicking any mouse button. A	straight path with a square black form will be displayed connecting the	two selected points."	| aLine aForm |  	aForm := Form extent: 20@20.		"make a form one quarter of inch square"	aForm fillBlack.							"turn it black"	aLine := Line new.	aLine form: aForm.						"use the black form for display"	aLine beginPoint: Sensor waitButton. Sensor waitNoButton.	aForm displayOn: Display at: aLine beginPoint.		aLine endPoint: Sensor waitButton.	aLine displayOn: Display.				"display the line"	"Line example"! !!Line class methodsFor: 'instance creation'!from: beginPoint to: endPoint withForm: aForm 	"Answer an instance of me with end points begingPoint and endPoint; 	the source form for displaying the line is aForm."	| newSelf | 	newSelf := super new: 2.	newSelf add: beginPoint.	newSelf add: endPoint.	newSelf form: aForm.	^newSelf! !!Line class methodsFor: 'instance creation'!new	| newSelf | 	newSelf := super new: 2.	newSelf add: 0@0.	newSelf add: 0@0.	^newSelf! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 22:16'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anIntegerfillColor: aForm 	| line |	line := Line new.	line form: self form.	1 to: self size - 1 do: 		[:i | 		line beginPoint: (self at: i).		line endPoint: (self at: i + 1).		line displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!LinearFit methodsFor: 'displaying' stamp: 'jrm 9/7/1999 23:00'!displayOn: aDisplayMedium transformation: aTransformation clippingBox:clipRect rule: anInteger fillColor: aForm 	| transformedPath |	"get the scaled and translated Path."	transformedPath := aTransformation applyTo: self.	transformedPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!LinearFit class methodsFor: 'examples'!example	"Select points on a Path using the red button. Terminate by selecting	any other button. Creates a Path from the points and displays it as a	piece-wise linear approximation." 	| aLinearFit aForm flag |	aLinearFit := LinearFit new.	aForm := Form extent: 1 @ 40.	aForm  fillBlack.	aLinearFit form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: [aLinearFit add: Sensor waitButton. Sensor waitNoButton.					aForm displayOn: Display at: aLinearFit last]			ifFalse: [flag:=false]].	aLinearFit displayOn: Display	"LinearFit example"! !!LinedTTCFont class methodsFor: 'as yet unclassified' stamp: 'ar 11/14/2006 15:18'!fromTTCFont: aTTCFont emphasis: code	| inst |	inst := self new.	inst ttcDescription: aTTCFont ttcDescription.	inst pointSize: aTTCFont pointSize.	inst emphasis: (aTTCFont emphasis bitOr: code).	inst lineGlyph: (aTTCFont ttcDescription at: $_).	^ inst.! !!Link methodsFor: 'accessing'!nextLink: aLink 	"Store the argument, aLink, as the link to which the receiver refers. 	Answer aLink."	^nextLink := aLink! !!LinkedList methodsFor: 'accessing' stamp: 'ajh 8/6/2002 15:46'!at: index	| i |	i := 0.	self do: [:link |		(i := i + 1) = index ifTrue: [^ link]].	^ self errorSubscriptBounds: index! !!LinkedList methodsFor: 'adding' stamp: 'ajh 8/22/2002 14:17'!add: link before: otherLink	| aLink |	firstLink == otherLink ifTrue: [^ self addFirst: link].	aLink := firstLink.	[aLink == nil] whileFalse: [		aLink nextLink == otherLink ifTrue: [			link nextLink: aLink nextLink.			aLink nextLink: link.			^ link		].		 aLink := aLink nextLink.	].	^ self errorNotFound: otherLink! !!LinkedList methodsFor: 'adding'!addFirst: aLink 	"Add aLink to the beginning of the receiver's list. Answer aLink."	self isEmpty ifTrue: [lastLink := aLink].	aLink nextLink: firstLink.	firstLink := aLink.	^aLink! !!LinkedList methodsFor: 'adding'!addLast: aLink 	"Add aLink to the end of the receiver's list. Answer aLink."	self isEmpty		ifTrue: [firstLink := aLink]		ifFalse: [lastLink nextLink: aLink].	lastLink := aLink.	^aLink! !!LinkedList methodsFor: 'enumerating'!do: aBlock	| aLink |	aLink := firstLink.	[aLink == nil] whileFalse:		[aBlock value: aLink.		 aLink := aLink nextLink]! !!LinkedList methodsFor: 'removing'!remove: aLink ifAbsent: aBlock  	"Remove aLink from the receiver. If it is not there, answer the result of	evaluating aBlock."	| tempLink |	aLink == firstLink		ifTrue: [firstLink := aLink nextLink.				aLink == lastLink					ifTrue: [lastLink := nil]]		ifFalse: [tempLink := firstLink.				[tempLink == nil ifTrue: [^aBlock value].				 tempLink nextLink == aLink]					whileFalse: [tempLink := tempLink nextLink].				tempLink nextLink: aLink nextLink.				aLink == lastLink					ifTrue: [lastLink := tempLink]].	aLink nextLink: nil.	^aLink! !!LinkedList methodsFor: 'removing'!removeFirst	"Remove the first element and answer it. If the receiver is empty, create 	an error notification."	| oldLink |	self emptyCheck.	oldLink := firstLink.	firstLink == lastLink		ifTrue: [firstLink := nil. lastLink := nil]		ifFalse: [firstLink := oldLink nextLink].	oldLink nextLink: nil.	^oldLink! !!LinkedList methodsFor: 'removing'!removeLast	"Remove the receiver's last element and answer it. If the receiver is 	empty, create an error notification."	| oldLink aLink |	self emptyCheck.	oldLink := lastLink.	firstLink == lastLink		ifTrue: [firstLink := nil. lastLink := nil]		ifFalse: [aLink := firstLink.				[aLink nextLink == oldLink] whileFalse:					[aLink := aLink nextLink].				 aLink nextLink: nil.				 lastLink := aLink].	oldLink nextLink: nil.	^oldLink! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList := view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListController methodsFor: 'marker adjustment'!markerDelta	| viewList |	viewList := view list.	viewList compositionRectangle height == 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!ListController methodsFor: 'scrolling'!scrollView: anInteger 	"Scroll the view and highlight the selection if it just came into view"	| wasClipped |	wasClipped := view isSelectionBoxClipped.	(view scrollBy: anInteger)		ifTrue: [view isSelectionBoxClipped ifFalse:					[wasClipped ifTrue:  "Selection came into view"						[view displaySelectionBox]].				^ true]		ifFalse: [^ false]! !!ListController methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	| viewList |	viewList := view list.	^(viewList clippingRectangle top -			viewList compositionRectangle top -			((marker top - scrollBar inside top) asFloat /				scrollBar inside height asFloat *				viewList compositionRectangle height asFloat))		roundTo: viewList lineGrid! !!ListController methodsFor: 'selecting' stamp: 'tk 4/1/98 10:33'!redButtonActivity	| noSelectionMovement oldSelection selection nextSelection pt scrollFlag firstTime |	noSelectionMovement := true.	scrollFlag := false.	oldSelection := view selection.	firstTime := true.	[sensor redButtonPressed | firstTime]		whileTrue: 			[selection := view findSelection: (pt := sensor cursorPoint).			firstTime := false.			selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"					[pt y < view insetDisplayBox top ifTrue:						[self scrollView: view list lineGrid.						scrollFlag := true.						selection := view firstShown].					pt y > view insetDisplayBox bottom ifTrue:						[self scrollView: view list lineGrid negated.						scrollFlag := true.						selection := view lastShown]].			selection == nil ifFalse:					[view moveSelectionBox: (nextSelection := selection).					nextSelection ~= oldSelection						ifTrue: [noSelectionMovement := false]]].	nextSelection ~~ nil & (nextSelection = oldSelection			ifTrue: [noSelectionMovement]			ifFalse: [true]) ifTrue: [self changeModelSelection: nextSelection].	scrollFlag ifTrue: [self moveMarker]! !!ListParagraph methodsFor: 'composition'!composeAll	"No composition is necessary once the ListParagraph is created."		lastLine isNil ifTrue: [lastLine := 0].			"Because composeAll is called once in the process of creating the ListParagraph."	^compositionRectangle width! !!ListParagraph methodsFor: 'private'!trimLinesTo: lastLineInteger	"Since ListParagraphs are not designed to be changed, we can cut back the		lines field to lastLineInteger."	lastLine := lastLineInteger.	lines := lines copyFrom: 1 to: lastLine! !!ListParagraph methodsFor: 'private' stamp: 'di 7/13/97 16:56'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines := Array new: 20.	lastLine := 0.	startOfLine := 1.	endOfLine := 1.	lineIndex := 0.	anArray do: 		[:item | 		endOfLine := startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex := lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine := endOfLine + 1].	endOfLine := endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString := String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item asString			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	anArray with: lines do: 		[:item :interval |  item isText ifTrue:			[text replaceFrom: interval first to: interval last - 1 with: item]].	self updateCompositionHeight! !!ListParagraph class methodsFor: 'initialization' stamp: 'nk 9/1/2004 10:27'!initialize 	"ListParagraph initialize"	| aFont |	"Allow different line spacing for lists"	aFont := Preferences standardListFont.	ListStyle := TextStyle fontArray: { aFont }.	ListStyle gridForFont: 1 withLead: 1! !!ListView methodsFor: 'delimiters'!bottomDelimiter: aString 	"Set the string used to indicate the bottom of the list."	bottomDelimiter := aString! !!ListView methodsFor: 'delimiters'!noBottomDelimiter	"Set the string used to indicate the bottom of the list to be nothing."	bottomDelimiter := nil! !!ListView methodsFor: 'delimiters'!noTopDelimiter	"Set the string used to indicate the top of the list to be nothing."	topDelimiter := nil! !!ListView methodsFor: 'delimiters'!topDelimiter: aString 	"Set the string used to indicate the top of the list."	topDelimiter := aString! !!ListView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self clippingBox ~= list clippingRectangle])		ifTrue:  "Recompose the list if the window changed"			[selection isNil ifTrue: [selection := 0].			self positionList].	super display! !!ListView methodsFor: 'displaying'!scrollBy: anInteger 	"Scroll up by this amount adjusted by lineSpacing and list limits"	| maximumAmount minimumAmount amount wasClipped |	maximumAmount := 0 max:		list clippingRectangle top - list compositionRectangle top.	minimumAmount := 0 min:		list clippingRectangle bottom - list compositionRectangle bottom.	amount := (anInteger min: maximumAmount) max: minimumAmount.	amount ~= 0		ifTrue: [list scrollBy: amount negated.  ^ true]		ifFalse: [^ false]  "Return false if no scrolling took place"! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta := self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta := self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle := nil]		ifNotNil: [			textStyle := TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter := '------------'.	bottomDelimiter := '------------'.	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'list access' stamp: 'sw 12/10/1999 10:43'!assuredTextStyle	^ textStyle ifNil:		[textStyle :=  ListParagraph standardListStyle]! !!ListView methodsFor: 'list access' stamp: 'sw 12/9/1999 18:06'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty := anArray isEmpty.	arrayCopy := Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i := 2.	anArray do: [:el | arrayCopy at: i put: el. i := i+1].	arrayCopy := arrayCopy copyWithout: nil.	list := ListParagraph withArray: arrayCopy style: self assuredTextStyle.	selection := 0.	self positionList.! !!ListView methodsFor: 'list access'!reset	"Set the list of items displayed to be empty."	isEmpty := true.	self list: Array new! !!ListView methodsFor: 'list access'!selection: selIndex	selection := selIndex! !!ListView methodsFor: 'selecting'!findSelection: aPoint 	"Determine which selection is displayed in an area containing the point, 	aPoint. Answer the selection if one contains the point, answer nil 	otherwise."	| trialSelection |	(self clippingBox containsPoint: aPoint) ifFalse: [^nil].	trialSelection := aPoint y - list compositionRectangle top // list lineGrid + 1.	topDelimiter == nil ifFalse: [trialSelection := trialSelection - 1].	(trialSelection < 1) | (trialSelection > self maximumSelection)		ifTrue: [^ nil]		ifFalse: [^ trialSelection]! !!ListView methodsFor: 'selecting'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[self deselect.			selection := anInteger.			self displaySelectionBox].	self isSelectionBoxClipped		ifTrue: [self scrollSelectionIntoView]! !!ListView methodsFor: 'private'!firstShown	"Return the index of the top item currently visible"	| trial |	trial := self findSelection: self insetDisplayBox topLeft.	^ trial == nil		ifTrue: [1]		ifFalse: [trial]! !!ListView methodsFor: 'private'!lastShown	"Return the index of the bottom item currently visible"	| trial bottomMargin |	bottomMargin := self insetDisplayBox height \\ list lineGrid.	trial := self findSelection: self insetDisplayBox bottomLeft - (0@bottomMargin).	trial == nil		ifTrue: [trial := self findSelection: self insetDisplayBox bottomLeft					- (0@(list lineGrid+bottomMargin))].	^ trial == nil		ifTrue: [list numberOfLines - 2]		ifFalse: [trial]! !!ListView methodsFor: 'private'!wrappingBox	| aRectangle |	aRectangle := self insetDisplayBox. 	selection = 0		ifTrue: [^aRectangle topLeft + (4 @ 0) extent: list compositionRectangle extent]		ifFalse: [^aRectangle left + 4 @ 					(aRectangle top - 						(self selectionBoxOffset 							min: ((list height - aRectangle height 									+ list lineGrid truncateTo: list lineGrid)							max: 0))) 					extent: list compositionRectangle extent]! !!ListViewLine methodsFor: 'object represented' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the object represented by the receiver to be as requested"	objectRepresented := anObject.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self setNameTo: anObject name.	self removeAllMorphs.! !!LiteralNode methodsFor: '*eToys-tiles' stamp: 'tk 8/24/2001 15:43'!asMorphicSyntaxIn: parent	| row |	row := parent addRow: #literal on: self.	(key isVariableBinding) ifFalse: [		row layoutInset: 1.		^ row addMorphBack: (row addString: key storeString special: false)].	key key isNil ifTrue: [		^ row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^ row addTextRow: ('##', key key)	].	! !!LookupKey methodsFor: 'accessing'!key: anObject 	"Store the argument, anObject, as the lookup key of the receiver."	key := anObject! !!LookupKey methodsFor: 'bindings' stamp: 'ar 8/16/2001 11:59'!beBindingOfType: aClass announcing: aBool	"Make the receiver a global binding of the given type"	| old new |	(Smalltalk associationAt: self key) == self		ifFalse:[^self error:'Not a global variable binding'].	self class == aClass ifTrue:[^self].	old := self.	new := aClass key: self key value: self value.	old become: new.	"NOTE: Now self == read-only (e.g., the new binding)"	^self recompileBindingsAnnouncing: aBool! !!MCDefinition methodsFor: 'installing' stamp: 'rej 2/26/2007 18:45'!addMethodAdditionTo: aCollection  Transcript show: self printString.  self load! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'rej 2/21/2007 21:08'!refresh	| packageNames name latest av |	packageNames := Set new.	versions := repository readableFileNames collect: [ :each |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	versions := versions select: [:each | (each at: 3) isNumber].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCMethodDefinition methodsFor: 'installing' stamp: 'rej 2/26/2007 10:42'!addMethodAdditionTo: aCollection	| methodAddition |	methodAddition := MethodAddition new		compile: source		classified: category		withStamp: timeStamp		notifying: (SyntaxError new category: category)		logSource: true		inClass: self actualClass.	"This might raise an exception and never return"	methodAddition createCompiledMethod.	aCollection add: methodAddition.! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'edc 3/8/2007 10:08'!override ^ 1! !!MCPackageLoader methodsFor: 'private' stamp: 'rej 2/26/2007 10:52'!basicLoad	errorDefinitions := OrderedCollection new.	[[additions do: [:ea | self tryToLoad: ea] displayingProgress: 'Loading...'.	removals do: [:ea | ea unload] displayingProgress: 'Cleaning up...'.	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea addMethodAdditionTo: methodAdditions] displayingProgress: 'Reloading...'.	methodAdditions do: [:each | each installMethod].	methodAdditions do: [:each | each notifyObservers].	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] displayingProgress: 'Initializing...']		on: InMidstOfFileinNotification 		do: [:n | n resume: true]]			ensure: [self flushChangesFile]! !!MCPackageLoader methodsFor: 'private' stamp: 'abc 2/26/2007 21:39'!initialize	additions := OrderedCollection new.	removals := OrderedCollection new.	obsoletions := Dictionary new.	methodAdditions := OrderedCollection new. ! !!MCPackageLoader methodsFor: 'private' stamp: 'rej 2/26/2007 10:41'!tryToLoad: aDefinition	[aDefinition addMethodAdditionTo: methodAdditions] on: Error do: [errorDefinitions add: aDefinition].! !!MCPackageLoader methodsFor: 'private' stamp: 'pk 10/17/2006 09:41'!useChangeSetNamed: baseName during: aBlock	"Use the named change set, or create one with the given name."	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := (ChangesOrganizer changeSetNamed: baseName) ifNil: [ ChangeSet new name: baseName ].	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!MCPackageLoader commentStamp: 'rej 2/26/2007 07:35' prior: 0!A MCPackageLoader is responsible for loading packages.  It gets used by VersionLoader, so it is eventually responsible for loading everything.Instance Variables	additions:		<Definitions>  Definitions that need to be added	errorDefinitions:		<Object>	obsoletions:		<Object>	provisions:		<Object>	removals:		<Object>	requirements:		<Object>	unloadableDefinitions:		<Object>	methodAdditions  <MethodAdditions> MethodDefinitions corresponding to the Definitions in "additions" that have been added so far.additions	- xxxxxerrorDefinitions	- xxxxxobsoletions	- xxxxxprovisions	- xxxxxremovals	- xxxxxrequirements	- xxxxxunloadableDefinitions	- xxxxx!!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'klc 5/25/2008 20:20'!versionWithInfo: aVersionInfo	^self versionWithInfo: aVersionInfo ifNone: [ nil ]! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'md 7/23/2006 15:28'!methodWithStyle	^ '!!EventHandler methodsFor: ''copying'' stamp: ''tk 1/22/2001 17:39''!!veryDeepInner: deepCopier	"ALL fields are weakly copied.  Can''t duplicate an object by duplicating a button that activates it.  See DeepCopier."	super veryDeepInner: deepCopier.	"just keep old pointers to all fields"	clickRecipient := clickRecipient.!!]style[(25 108 10 111)f1b,f1,f1LDeepCopier Comment;,f1!! !!'! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'al 7/18/2006 15:49'!saveVersion	| repo |	self canSave ifFalse: [^self].	self checkForNewerVersions ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNilDo:		[:v |		(MCVersionInspector new version: v) show.		Cursor wait showWhile: [repo storeVersion: v].		MCCacheRepository default cacheAllFileNamesDuring: 			[repo cacheAllFileNamesDuring: 				[v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]]]]]! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:41'!atColumn: column	|p|	p := (self indexForRow: 1 andColumn: column)-ncols.	^(1 to: nrows) collect: [:row | contents at: (p := p+ncols)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!atColumn: column put: aCollection	|p|	aCollection size = nrows ifFalse: [self error: 'wrong column size'].	p := (self indexForRow: 1 andColumn: column)-ncols.	aCollection do: [:each | contents at: (p := p+ncols) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/22/2002 12:42'!atRow: row put: aCollection	|p|	aCollection size = ncols ifFalse: [self error: 'wrong row size'].	p := (self indexForRow: row andColumn: 1)-1.	aCollection do: [:each | contents at: (p := p+1) put: each].	^aCollection! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 10/23/2002 20:41'!diagonal	"Answer (1 to: (nrows min: ncols)) collect: [:i | self at: i at: i]"	|i|	i := ncols negated.	^(1 to: (nrows min: ncols)) collect: [:j | contents at: (i := i + ncols + 1)]! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:21'!swapColumn: anIndex withColumn: anotherIndex	|a b|	a := self indexForRow: 1 andColumn: anIndex.	b := self indexForRow: 1 andColumn: anotherIndex.	nrows timesRepeat: [		contents swap: a with: b.		a := a + ncols.		b := b + ncols].! !!Matrix methodsFor: 'accessing rows/columns' stamp: 'raok 11/28/2002 14:22'!swapRow: anIndex withRow: anotherIndex	|a b|	a := self indexForRow: anIndex andColumn: 1.	b := self indexForRow: anotherIndex andColumn: 1.	ncols timesRepeat: [		contents swap: a with: b.		a := a + 1.		b := b + 1].! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:30'!atRows: r1 to: r2 columns: c1 to: c2	"Answer a submatrix [r1..r2][c1..c2] of the receiver."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 13:05'!atRows: r1 to: r2 columns: c1 to: c2 ifInvalid: element	"Answer a submatrix [r1..r2][c1..c2] of the receiver.	 Portions of the result outside the bounds of the original matrix	 are filled in with element."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	^self class rows: r2-rd columns: c2-cd tabulate: [:r :c| self at: r+rd at: c+cd ifInvalid: element]! !!Matrix methodsFor: 'accessing submatrices' stamp: 'raok 11/25/2002 12:32'!atRows: r1 to: r2 columns: c1 to: c2 put: aMatrix	"Set the [r1..r2][c1..c2] submatrix of the receiver	 from the [1..r2-r1+1][1..c2-c1+1] submatrix of aMatrix.	 As long as aMatrix responds to at:at: and accepts arguments in the range shown,	 we don't care if it is bigger or even if it is a Matrix at all."	|rd cd|	rd := r1 - 1.	cd := c1 - 1.	r1 to: r2 do: [:r |		c1 to: c2 do: [:c |			self at: r at: c put: (aMatrix at: r-rd at: c-cd)]].	^aMatrix! !!Matrix methodsFor: 'arithmetic' stamp: 'raok 10/22/2002 20:02'!preMultiplyByMatrix: m	"Answer m +* self where m is a Matrix."	|s|	nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col |		s := 0.		1 to: nrows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].		s]! !!Matrix methodsFor: 'copying' stamp: 'raok 11/22/2002 12:57'!, aMatrix	"Answer a new matrix having the same number of rows as the receiver and aMatrix,	 its columns being the columns of the receiver followed by the columns of aMatrix."	|newCont newCols anArray oldCols a b c|	self assert: [nrows = aMatrix rowCount].	newCont := Array new: self size + aMatrix size.	anArray := aMatrix privateContents.	oldCols := aMatrix columnCount.	newCols := ncols + oldCols.	a := b := c := 1.	1 to: nrows do: [:r |		newCont replaceFrom: a to: a+ncols-1 with: contents startingAt: b.		newCont replaceFrom: a+ncols to: a+newCols-1 with: anArray startingAt: c.		a := a + newCols.		b := b + ncols.		c := c + oldCols].	^self class rows: nrows columns: newCols contents: newCont		! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/23/2002 20:57'!indicesCollect: aBlock	|r i|	r := Array new: nrows * ncols.	i := 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			r at: (i := i+1) put: (aBlock value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:51'!indicesInject: start into: aBlock	|current|	current := start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current := aBlock value: current value: row value: column]].	^current! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesCollect: aBlock	|i r|	i := 0.	r := contents shallowCopy.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			i := i+1.			r at: i put: (aBlock value: (r at: i) value: row value: column)]].	^self class rows: nrows columns: ncols contents: r! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesDo: aBlock	|i|	i := 0.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			aBlock value: (contents at: (i := i+1)) value: row value: column]].! !!Matrix methodsFor: 'enumerating' stamp: 'raok 10/21/2002 23:52'!withIndicesInject: start into: aBlock	|i current|	i := 0.	current := start.	1 to: nrows do: [:row |		1 to: ncols do: [:column |			current := aBlock value: current value: (contents at: (i := i+1)) 							  value: row value: column]].	^current! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 22:47'!rowAndColumnForIndex: index	|t|	t := index - 1.	^(t // ncols + 1)@(t \\ ncols + 1)! !!Matrix methodsFor: 'private' stamp: 'raok 10/21/2002 23:05'!rows: rows columns: columns contents: anArray	self assert: [rows isInteger and: [rows >= 0]].	self assert: [columns isInteger and: [columns >= 0]].	self assert: [rows * columns = anArray size].	nrows := rows.	ncols := columns.	contents := anArray.	^self! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 00:09'!diagonal: aCollection	|r i|	r := self zeros: aCollection size.	i := 0.	aCollection do: [:each | i := i+1. r at: i at: i put: each].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/23/2002 20:59'!identity: n	|r|	r := self zeros: n.	1 to: n do: [:i | r at: i at: i put: 1].	^r! !!Matrix class methodsFor: 'instance creation' stamp: 'raok 10/22/2002 19:51'!rows: rows columns: columns tabulate: aBlock	"Answer a new Matrix of the given dimensions where	 result at: i at: j     is   aBlock value: i value: j"	|a i|	a := Array new: rows*columns.	i := 0.	1 to: rows do: [:row |		1 to: columns do: [:column |			a at: (i := i+1) put: (aBlock value: row value: column)]].	^self rows: rows columns: columns contents: a! !!MatrixTest methodsFor: 'testing' stamp: 'dc 3/3/2007 17:58'!setUp	matrix1 := Matrix new: 2.	matrix1 at:1 at:1 put: 1.	matrix1 at:1 at:2 put: 3.	matrix1 at:2 at:1 put: 2.	matrix1 at:2 at:2 put: 4.		matrix2 := Matrix new: 2.	matrix2 at:1 at:1 put: 3.	matrix2 at:1 at:2 put: 7.	matrix2 at:2 at:1 put: 4.	matrix2 at:2 at:2 put: 8.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:47'!testAtAt	self should:[matrix1 at: 2 at: 3] raise: Error.	self should:[matrix1 at: 3 at: 2] raise: Error.	self should:[matrix1 at: 3 at: 3] raise: Error.	self should:[matrix1 at: 0 at: 1] raise: Error.	self should:[matrix1 at: 1 at: 0] raise: Error.	self should:[matrix1 at: 0 at: 0] raise: Error.		self assert: (matrix1 at: 1 at: 1) = 1! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:52'!testReplaceAll	matrix1 replaceAll: 1 with: 10.	self assert: (matrix1 at:1 at:1) = 10.	self assert: (matrix1 at:2 at:1) = 2.	self assert: (matrix1 at:1 at:2) = 3.	self assert: (matrix1 at:2 at:2) = 4.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:53'!testSwap	matrix1 swap: 1 at: 2 with: 1 at: 1.	self assert: (matrix1 at: 1 at: 1) = 3.	self assert: (matrix1 at: 1 at: 2) = 1.! !!MatrixTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:58'!testTransposed	| transposedMatrix |		transposedMatrix := matrix1 transposed.	self assert: [(transposedMatrix at:1 at:1) = 1].	self assert: [(transposedMatrix at:1 at:2) = 2].	self assert: [(transposedMatrix at:2 at:1) = 3].	self assert: [(transposedMatrix at:2 at:2) = 4].! !!MatrixTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:48'!testCopy	| copyMatrix |		copyMatrix := matrix1 copy.	self assert: matrix1 = copyMatrix ! !!MatrixTest methodsFor: 'tests - testing' stamp: 'dc 3/3/2007 17:49'!testIncludes	self assert:			((1 to: 4)				allSatisfy: [:i | matrix1 includes: i])! !!MatrixTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:50'!testMultiply		| result |	self	should: [matrix1	preMultiplyByMatrix: (Matrix new: 3)]raise: Error.	result := matrix2 preMultiplyByMatrix: matrix1.	self assert: (result at: 1 at: 1) = 15.	self assert: (result at: 1 at: 2) = 31.	self assert: (result at: 2 at: 1) = 22.	self assert: (result at: 2 at: 2) = 46! !!MenuMorph methodsFor: 'construction' stamp: 'pf 11/15/2006 16:42'!addTitle: aString icon: aForm updatingSelector: aSelector updateTarget: aTarget 	"Add a title line at the top of this menu Make aString its initial  	contents.  	If aSelector is not nil, then periodically obtain fresh values for  	its  	contents by sending aSelector to aTarget.."	| title titleContainer |	title := AlignmentMorph newColumn.	self setTitleParametersFor: title.	""	aForm isNil		ifTrue: [titleContainer := title]		ifFalse: [| pair | 			pair := AlignmentMorph newRow.			pair color: Color transparent.			pair hResizing: #shrinkWrap.			pair layoutInset: 0.			""			pair addMorphBack: aForm asMorph.			""			titleContainer := AlignmentMorph newColumn.			titleContainer color: Color transparent.			titleContainer vResizing: #shrinkWrap.			titleContainer wrapCentering: #center.			titleContainer cellPositioning: #topCenter.			titleContainer layoutInset: 0.			pair addMorphBack: titleContainer.			""			title addMorphBack: pair].	""	aSelector		ifNil: [""			aString asString				linesDo: [:line | titleContainer						addMorphBack: (StringMorph contents: line font: Preferences standardMenuFont)]]		ifNotNil: [| usm | 			usm := UpdatingStringMorph on: aTarget selector: aSelector.			usm font: Preferences standardMenuFont.			usm useStringFormat.			usm lock.			titleContainer addMorphBack: usm].	""	title setProperty: #titleString toValue: aString.	self addMorphFront: title.	""	title useSquareCorners.	(self hasProperty: #needsTitlebarWidgets)		ifTrue: [self addStayUpIcons]! !!MenuTile methodsFor: 'arrows' stamp: 'sw 11/22/1999 11:54'!arrowAction: delta	| phrase aPlayer newItem |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	aPlayer := phrase associatedPlayer.	newItem := delta > 0		ifTrue:			[aPlayer menuItemAfter: literal]		ifFalse:			[aPlayer menuItemBefore: literal].	self literal: newItem.	self layoutChanged! !!MenuTile methodsFor: 'event handling' stamp: 'sw 10/3/2002 21:16'!mouseDown: evt	| aPoint aMenu reply |	aPoint := evt cursorPoint.	nArrowTicks := 0.	((upArrow bounds containsPoint: aPoint) or: [downArrow bounds containsPoint: aPoint]) ifTrue: [^ self mouseStillDown: evt].	aMenu := SelectionMenu selections: (((self ownerThatIsA: PhraseTileMorph) associatedPlayer costume allMenuWordings) copyWithout: '').	reply := aMenu startUp.	reply ifNotNil: [self literal: reply; layoutChanged]! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'tk 11/15/2000 15:19'!asTilesIn: playerClass	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: (self stringFor: receiver).		keywords := selector keywords.		strm space; nextPutAll: keywords first.		(num := selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'tk 9/28/2001 13:41'!asTilesIn: playerClass globalNames: makeSelfGlobal	| code keywords num tree syn block phrase |	"Construct SyntaxMorph tiles for me.  If makeSelfGlobal is true, name the receiver and use that name, else use 'self'.  (Note that this smashes 'self' into the receiver, regardless of what it was.)"	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: 			(makeSelfGlobal ifTrue: [self stringFor: receiver] ifFalse: ['self']).		keywords := selector keywords.		strm space; nextPutAll: keywords first.		(num := selector numArgs) > 0 ifTrue: [strm space. 					strm nextPutAll: (self stringFor: arguments first)].		2 to: num do: [:kk |			strm space; nextPutAll: (keywords at: kk).			strm space; nextPutAll: (self stringFor: (arguments at: kk))]].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!MessageSend methodsFor: '*eToys-tiles' stamp: 'sw 6/20/2001 14:17'!stringFor: anObject	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	| generic aName |	anObject isLiteral ifTrue: [^ anObject printString].	anObject class == Color ifTrue: [^ anObject printString].	anObject class superclass == Boolean ifTrue: [^ anObject printString].	anObject class == BlockContext ifTrue: [^ '[''do nothing'']'].	"default block"		"Real blocks need to construct tiles in a different way"	anObject class isMeta ifTrue: ["a class" ^ anObject name].	generic := anObject knownName.	"may be nil or 'Ellipse' "	aName := anObject uniqueNameForReference.	generic ifNil:		[(anObject respondsTo: #renameTo:) 			ifTrue: [anObject renameTo: aName]			ifFalse: [aName := anObject storeString]].	"for Fraction, LargeInt, etc"	^ aName! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToAnyChangeSet	"Filter down only to messages present in ANY change set"	self filterFrom:		[:aClass :aSelector |			ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector]! !!MessageSet methodsFor: 'filtering' stamp: 'pk 10/17/2006 09:42'!filterToNotAnyChangeSet	"Filter down only to messages present in NO change set"	self filterFrom:		[:aClass :aSelector |			(ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not]! !!MessageSet methodsFor: 'private' stamp: 'sd 11/20/2005 21:27'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB: special handling for uniclasses."	| s |	messageList := OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil:					[class isUniClass						ifTrue:							[s := class typicalInstanceName, ' ', sel]						ifFalse:							[s := class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex := messageList isEmpty ifTrue: [0] ifFalse: [1].	contents := ''! !!Metaclass methodsFor: 'testing' stamp: 'wbk 7/26/2007 12:41'!isSelfEvaluating	^ true! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 10:51'!compile    "This method is the how compiling a method used to work.  All these steps were done at once.     This method should not normally be used, because the whole point of MethodAddition is to let	you first create a compiled method and then install the method later."	self createCompiledMethod.	self installMethod.	self notifyObservers.	^selector! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:36'!compile: aString classified: aString1 withStamp: aString2 notifying: aRequestor logSource: aBoolean inClass: aClass	text := aString.	category := aString1.	changeStamp := aString2.	requestor := aRequestor.	logSource := aBoolean.	myClass := aClass! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/26/2007 05:17'!createCompiledMethod	methodAndNode := myClass compile: text asString classified: category notifying: requestor							trailer: myClass defaultMethodTrailer ifFail: [^nil].	selector := methodAndNode selector.	compiledMethod := methodAndNode method.	self writeSourceToLog.	priorMethodOrNil := myClass compiledMethodAt: selector ifAbsent: [nil].! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:09'!installMethod	myClass addSelectorSilently: selector withMethod: compiledMethod.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 22:12'!notifyObservers	SystemChangeNotifier uniqueInstance 		doSilently: [myClass organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: myClass requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: myClass requestor: requestor].	"The following code doesn't seem to do anything."	myClass instanceSide noteCompilationOf: selector meta: myClass isClassSide.! !!MethodAddition methodsFor: 'as yet unclassified' stamp: 'rej 2/25/2007 20:42'!writeSourceToLog	logSource ifTrue: [		myClass logMethodSource: text forMethodWithNode: methodAndNode 			inCategory: category withStamp: changeStamp notifying: requestor.	].! !!MethodAddition commentStamp: 'rej 2/25/2007 19:30' prior: 0!I represent the addition of a method to a class.  I can produce the CompiledMethod, install it, and then notify the system that the method has been added.  This allows Monticello to implement atomic addition.  A loader can compile all classes and methods first and then install all methods only after they have been all compiled, and in a way that executes little code.!!MethodContext methodsFor: 'closure support' stamp: 'mvl 3/13/2007 11:42'!isExecutingBlock	"Is this executing a block versus a method"	^ self method notNil and: [self method isBlockMethod]! !!MethodContext methodsFor: 'printing' stamp: 'mvl 3/13/2007 11:40'!printString	"Answer an emphasized string in case of a breakpoint method"	^(self method notNil and: [self method hasBreakpoint])		ifTrue:[(super printString , ' [break]') asText allBold]		ifFalse:[super printString]! !!MethodMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/7/2000 22:07'!installRollBackButtons: target	| mine |	"If I don't already have such a button, put one in at the upper right.  Set its target to the furtherest enclosing book.  Send chooseAndRevertToVersion when clicked.  Stay in place via scrollBar install."	mine := self submorphNamed: #chooseAndRevertToVersion ifNone: [nil].	mine ifNil: [mine := SimpleButtonMorph new.		"mine height: mine height - 2."		mine label: 'Roll Back'; cornerStyle: #square.		mine color: Color white; borderColor: Color black.		mine actionSelector: #chooseAndRevertToVersion.		mine align: mine topRight with: (self findA: ScrollBar) topLeft +(1@1).		self addMorphFront: mine.		mine height: mine height - 5 "14"].	mine target: target.! !!MethodMorph methodsFor: 'scrolling' stamp: 'nk 4/28/2004 10:23'!showScrollBar	"Copied down and modified to get rid of the ruinous comeToFront of the inherited version."	| scriptor |	(submorphs includes: scrollBar)		ifTrue: [^ self].	self vResizeScrollBar.	self privateAddMorph: scrollBar atIndex: 1.	retractableScrollBar		ifTrue:			["Bring the pane to the front so that it is fully visible"			"self comeToFront. -- thanks but no thanks"			(scriptor := self ownerThatIsA: ScriptEditorMorph)				ifNotNil:					[scriptor comeToFront]]		ifFalse: [self resetExtent]! !!MethodNode methodsFor: 'initialize-release' stamp: 'md 2/5/2007 15:40'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 		self 		selector: selOrFalse		arguments: args		precedence: p		temporaries: temps		block: blk encoder:		anEncoder 		primitive: prim 		properties: MethodProperties new.! !!MethodNode methodsFor: 'printing' stamp: 'md 2/3/2007 11:53'!printOn: aStream 	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				aStream withStyleFor: #methodArgument					do: [aStream nextPutAll: arg key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '|'.			aStream withStyleFor: #temporaryVariable				do: [temporaries do: 						[:temp | aStream space; nextPutAll: temp key]].				aStream nextPutAll: ' |'].	properties ifNotNil: [ 		properties pragmas do: [ :each |			"Don't decompile basic primitives that return self, i-vars, etc."			each keyword = #primitive:				ifFalse: [ aStream crtab: 1. each printOn: aStream ]				ifTrue: [					( (each argumentAt: 1) isNumber and: [(each argumentAt: 1) between: 255 and: 519])						ifFalse: [ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ] ].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15'!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49'!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!MethodPragmaTest methodsFor: 'testing-printing-reformating' stamp: 'md 2/3/2007 11:55'!testReformat	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.		self shouldnt: [ DisplayScreen class reformatMethodAt: #actualScreenDepth] raise: Error.	self assert: (DisplayScreen class compiledMethodAt: #actualScreenDepth) getSource string = 'actualScreenDepth	<primitive: ''primitiveScreenDepth''>	^ Display depth'.	! !!MethodReference methodsFor: 'comparisons' stamp: 'kph 12/16/2006 10:11'!asStringOrText	^stringVersion ifNil: [ self stringVersionDefault ]! !!MethodReference methodsFor: 'comparisons' stamp: 'kph 12/16/2006 10:11'!stringVersionDefault	^classSymbol, (classIsMeta ifTrue: [ ' class ' ] ifFalse: [' ']), methodSymbol  ! !!MethodReference methodsFor: 'setting' stamp: 'kph 12/16/2006 10:06'!setStandardClass: aClass methodSymbol: methodSym	classSymbol _ aClass theNonMetaClass name.	classIsMeta _ aClass isMeta.	methodSymbol _ methodSym.	stringVersion _ nil.! !!MethodWithInterface methodsFor: 'access' stamp: 'sw 3/28/2001 16:25'!playerClass	"Answer the playerClass associated with the receiver.  Note: fixes up cases where the playerClass slot was a Playerxxx object because of an earlier bug"	^ (playerClass isKindOf: Class)		ifTrue:			[playerClass]		ifFalse:			[playerClass := playerClass class]! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 1/30/2001 11:37'!convertFromUserScript: aUserScript	"The argument represents an old UserScript object.  convert it over"	defaultStatus := aUserScript status.! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:44'!initialize	"Initialize the receiver by setting its inst vars to default values"	super initialize.	defaultStatus := #normal! !!MethodWithInterface methodsFor: 'initialization' stamp: 'sw 9/12/2001 11:59'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	playerClass := aPlayerClass.	selector := aSelector.! !!MethodWithInterface methodsFor: 'rename' stamp: 'sw 3/11/2003 00:01'!renameScript: newSelector fromPlayer: aPlayer	"The receiver's selector has changed to the new selector.  Get various things right, including the physical appearance of any Scriptor open on this method"	self allScriptEditors do:		[:aScriptEditor | aScriptEditor renameScriptTo: newSelector].	(selector numArgs = 0 and: [newSelector numArgs = 1])		ifTrue:			[self argumentVariables: (OrderedCollection with:				(Variable new name: #parameter type: #Number))].	(selector numArgs = 1 and: [newSelector numArgs = 0])		ifTrue:			[self argumentVariables: OrderedCollection new].	selector := newSelector asSymbol.	self bringUpToDate.	self playerClass atSelector: selector putScript: self.	self allScriptActivationButtons do:		[:aButton | aButton bringUpToDate].! !!MethodWithInterface methodsFor: 'script editor' stamp: 'sw 3/28/2001 16:26'!instantiatedScriptEditorForPlayer: aPlayer	"Return a new script editor for the player and selector"	| aScriptEditor |	aScriptEditor := (self playerClass includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: aPlayer]			ifFalse: [ScriptEditorMorph new				setMorph: aPlayer costume				scriptName: selector].		defaultStatus == #ticking ifTrue:			[aPlayer costume arrangeToStartStepping].		^ aScriptEditor! !!MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!dataStream: anObject	dataStream := anObject! !!MimeConverter methodsFor: 'accessing' stamp: 'tk 12/9/97 13:51'!mimeStream: anObject	mimeStream := anObject! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:05'!close	"This is how we leave the mode." 	modeActive := false.! !!ModalController methodsFor: 'as yet unclassified' stamp: 'jm 5/1/1998 07:02'!controlInitialize	modeActive := true.	^ super controlInitialize! !!Morph methodsFor: 'geometry' stamp: 'nk 4/27/2003 16:16'!intersects: aRectangle	"Answer whether aRectangle, which is in World coordinates, intersects me."	^self fullBoundsInWorld intersects: aRectangle! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53'!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !!Morph methodsFor: 'menus' stamp: 'wiz 12/4/2006 00:24'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsOfColor:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsOfColor:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph methodsFor: 'menus' stamp: 'wiz 10/19/2006 00:35'!adhereToEdge: edgeSymbol 	| edgeMessage |	(owner isNil or: [owner isHandMorph]) ifTrue: [^self].	(owner class canUnderstand:  edgeSymbol) ifFalse:  [^self].	(self class canUnderstand: ( edgeMessage := (edgeSymbol , ':') asSymbol ))		 ifFalse:  [^self].		self perform: edgeMessage		withArguments: (Array with: (owner perform: edgeSymbol))! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 11/9/2006 23:04'!potentialTargetsAt: aPoint 	"Return the potential targets for the receiver.  	This is derived from Morph>>potentialEmbeddingTargets."	| realOwner |	realOwner := self topRendererOrSelf	owner		ifNil: [^ #()].	^ realOwner		morphsAt: aPoint		! !!Morph methodsFor: 'structure' stamp: 'wiz 12/7/2006 15:12'!renderedMorph	"This now  gets overridden by rendering morphs."	^self! !!Morph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/25/2003 11:36'!removeAllEventTriggers	"Remove all the event registrations for my Player.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player := self player) ifNil: [ ^self ].	self removeAllEventTriggersFor: player.	self currentWorld removeAllEventTriggersFor: player.! !!Morph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/25/2003 11:37'!removeEventTrigger: aSymbol	"Remove all the event registrations for my Player that are triggered by aSymbol.	User custom events are triggered at the World,	while system custom events are triggered on individual Morphs."	| player |	(player := self player) ifNil: [ ^self ].	self removeEventTrigger: aSymbol for: player.	self currentWorld removeEventTrigger: aSymbol for: player.! !!Morph class methodsFor: '*eToys-new-morph participation' stamp: 'sw 10/24/2001 15:51'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!MorphBugs methodsFor: 'as yet unclassified' stamp: 'wiz 10/19/2006 00:32'!adhereToEdgeTest"self new adhereToEdgeTest""self run: #adhereToEdgeTest"| r |r := RectangleMorph new openInWorld .self shouldnt: [ [ r adhereToEdge: #eternity ] ensure: [ r delete ] ] raise: Error . r delete .^true ! !!MorphExtension methodsFor: '*eToys-accessing' stamp: 'dgd 2/16/2003 21:53'!actorState: anActorState "change the receiver's actorState"	actorState := anActorState! !!MorphExtension methodsFor: '*eToys-accessing' stamp: 'dgd 2/16/2003 21:53'!player: anObject 	"change the receiver's player"	player := anObject ! !!MorphicModel class methodsFor: '*eToys-queries' stamp: 'sw 2/27/2002 14:58'!baseUniclass	"Answer the uniclass that new instances should be instances of.  This protocol is primarily intended for the Player lineage, but can get sent to a MorphicModel subclass when the project-loading mechanism is scrambling to fix up projects that have naming conflicts with the project being loaded."	| curr |	curr := self.	[curr theNonMetaClass superclass name endsWithDigit]		whileTrue:			[curr := curr superclass].	^ curr"PlayWithMe1 baseUniclass"! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 1/3/2007 12:16'!findWindowInWorldLabeled: aLabel^ World submorphs detect: [ :each |	each class == SystemWindow		and: [ each label = aLabel ] ] ifNone: [ nil ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 6/11/2007 20:34'!setUp"default. tests will add morphs to list. Teardown will delete."cases := #() .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 1/3/2007 11:25'!tearDown"default. tests will add morphs to list. Teardown will delete."cases do: [ :each | each delete ] .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:58'!testOpenWorkspace"self new testOpenWorkspace""MorphicUIBugTest run: #testOpenWorkspace"| window myLabel foundWindow myModel |self assert: ( Smalltalk isMorphic ) .myLabel := 'Workspace from ', 'SUnit test' .foundWindow := self findWindowInWorldLabeled: myLabel .self assert: ( foundWindow isNil ) .window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel .window = window. foundWindow := self findWindowInWorldLabeled: myLabel .cases := Array with: foundWindow . "For teardown."myModel := (foundWindow submorphs detect: [ :each |	each isMorphicModel ] )  .self assert: ( myModel model class == Workspace ) .self assert: ( foundWindow model class == Workspace ) .foundWindow delete .! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'wiz 4/18/2007 00:57'!testOpenWorkspaceAns"Test if method opening a workspace answers the window opened""MorphicUIBugTest run: #testOpenWorkspaceAns"| window myLabel foundWindow |self assert: ( Smalltalk isMorphic ) .myLabel := 'Workspace from ', 'SUnit test' .foundWindow := self findWindowInWorldLabeled: myLabel .self assert: ( foundWindow isNil ) .window := UIManager default edit: '"MorphicUIBugTest run: #openWorkspaceTest"'  label: myLabel .foundWindow := self findWindowInWorldLabeled: myLabel .cases := Array with: foundWindow . "For teardown."self assert: ( window == foundWindow ) .foundWindow delete .! !!MorphicUIBugTest commentStamp: 'wiz 1/3/2007 13:57' prior: 0!A MorphicUIBugTest is a class for testing the shortcomings and repairs of the MorphicUI manager..Instance Variables	cases:		<aCollection>cases	- a list of morphs that may need to be deleted during teardown.	the tests are expected to fill this list it starts out empty by default.		!!MorphicUIManager methodsFor: 'ui requests' stamp: 'wiz 1/3/2007 13:50'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window holder text |	holder := Workspace  new.	holder contents: aText.	text := PluggableTextMorphPlus 		on: holder 		text: #contents 		accept: #acceptContents: 		readSelection: nil 		menu: nil.	text acceptAction: anAction.	window := SystemWindow new.	labelString ifNotNil:[window setLabel: labelString].	window model: holder .	window addMorph: text frame: (0@0 extent: 1@1).	window paneColor: Color gray.	window openInWorld.^ window ! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint := sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu := nil.	redButtonMessages := nil! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index := redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu := aSystemMenu.	redButtonMessages := anArray! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sw 2/17/2002 04:35'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu |	(menu := self getPluggableYellowButtonMenu: shiftKeyState)		ifNil:			[sensor waitNoButton]		ifNotNil:			[self terminateAndInitializeAround:				[menu invokeOn: model orSendTo: self]]! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MultiByteFileStream class methodsFor: 'class initialization' stamp: 'apb 2/19/2007 13:31'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current getSystemAttribute: 1002)					beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!Number methodsFor: 'printing' stamp: 'fcs 12/13/2006 19:47'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point.  It now handles negative numbers between 0 and -1 and rounds correctly in more cases.  This method probably could be optimized -- improvements welcomed.  Category was/is 'converting' but should be 'printing' "	| precision rounded frac sign integerString fractionString result |	placesDesired <= 0 ifTrue: [^ self rounded printString].	precision _ Utilities floatPrecisionForDecimalPlaces: placesDesired.	rounded _ self roundTo: precision.	sign := rounded negative ifTrue: ['-'] ifFalse: [''].	integerString := rounded abs integerPart asInteger printString.	frac := ((rounded abs fractionPart roundTo: precision) * (10 raisedToInteger: placesDesired)) asInteger.	fractionString := frac printString padded: #right to: placesDesired with: $0.	result := sign , integerString , '.' , fractionString.	^result"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 2-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2Number categoryForSelector: #printShowingDecimalPlaces:"! !!NumberTest methodsFor: 'tests' stamp: 'fcs 12/13/2006 17:26'!testPrintShowingDecimalPlaces	self assert: (111.2 printShowingDecimalPlaces: 2) = '111.20'.	self assert: (111.2 printShowingDecimalPlaces: 0) = '111'.	self assert: (111 printShowingDecimalPlaces: 0) = '111'.	self assert: (111111111111111 printShowingDecimalPlaces: 2) = '111111111111111.00'.	self assert: (10 printShowingDecimalPlaces: 20) ='10.00000000000000000000'.	self assert: (0.98 printShowingDecimalPlaces: 2) = '0.98'.	self assert: (-0.98 printShowingDecimalPlaces: 2) = '-0.98'.	self assert: (2.567 printShowingDecimalPlaces: 2) = '2.57'.	self assert: (-2.567 printShowingDecimalPlaces: 2) = '-2.57'.	"self assert: (Number categoryForSelector: #printShowingDecimalPlaces:) = 'printing'."! !!NumericReadoutTile methodsFor: 'accessing' stamp: 'ar 9/15/2000 23:27'!abandonLabelFocus	| aLabel |	"If the receiver's label has editing focus, abandon it"	self flag: #arNote. "Probably unnecessary"	(aLabel := self labelMorph) ifNotNil:		[aLabel hasFocus ifTrue:			[aLabel contents: aLabel readFromTarget.			aLabel handsWithMeForKeyboardFocus do:				[:aHand | aHand releaseKeyboardFocus]]]! !!NumericReadoutTile methodsFor: 'accessing' stamp: 'tak 12/6/2004 01:53'!literalFromContents	| label |	label := self labelMorph				ifNil: [^ super literal].	label step.	^ literal := label valueFromContents! !!NumericReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal := anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!NumericReadoutTile methodsFor: 'parts bin' stamp: 'sw 11/15/2001 20:22'!initializeToStandAlone	"Enclose my prototype in a SyntaxMorph.  For the ObjectTool"	| aWatcher aTile aLine aColor ms slotMsg |	super initializeToStandAlone.	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aTile := self typeColor: aColor.	aWatcher := UpdatingStringMorph new.	aWatcher growable: true;		getSelector: nil;		putSelector: nil;		setToAllowTextEdit.	aWatcher target: nil.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: 5 width: 30.	ms := MessageSend receiver: nil selector: #aNumber arguments: #().	slotMsg := ms asTilesIn: Player globalNames: false.		"For CardPlayers, use 'aPlayer'.  For others, name it, and use its name."	ms := MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).	aLine := ms asTilesIn: Player globalNames: false.	aLine firstSubmorph delete.		"A little over-complicated?  Yes?"	aLine addMorphFront: (slotMsg submorphs second) firstSubmorph.	aLine addMorphFront: (Morph new transparentSpacerOfSize: 3@3).	aLine lastSubmorph delete.	aLine lastSubmorph delete.	aLine color: aColor.	aLine addMorphBack: (Morph new transparentSpacerOfSize: 3@3).	aLine addMorphBack: aTile.	aLine cellPositioning: #leftCenter.	aWatcher step; fitContents.	^ aLine markAsPartsDonor.! !!NumericReadoutTile class methodsFor: 'instance creation' stamp: 'tk 12/14/2001 19:32'!borderedPrototype	"Just number and up/down arrows"	| aWatcher aTile |	aTile := self new typeColor: (Color r: 0.387 g: 0.581 b: 1.0).	aWatcher := UpdatingStringMorph new.	aWatcher growable: true; setNameTo: 'value'.	aTile addMorphBack: aWatcher.	aTile addArrows; setNameTo: 'Number (mid)'.	aTile setLiteralTo: 5 width: 30.	aWatcher step; fitContents; setToAllowTextEdit.	^ aTile extent: 30@24; markAsPartsDonor! !!NumericReadoutTile class methodsFor: 'scripting' stamp: 'tk 12/14/2001 19:30'!authoringPrototype	"Enclose my prototype in a SyntaxMorph."	| aWatcher aTile aLine aColor ms slotMsg |	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aTile := self new typeColor: aColor.	aWatcher := UpdatingStringMorph new.	aWatcher growable: true;		setToAllowTextEdit;		getSelector: nil;		putSelector: nil.	aWatcher target: nil.	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: 5 width: 30.	"This is the long way around to do this..."	ms := MessageSend receiver: nil selector: #aNumber arguments: #().	slotMsg := ms asTilesIn: Player globalNames: false.		"For CardPlayers, use 'aPlayer'.  For others, name it, and use its name."	ms := MessageSend receiver: 3 selector: #= asSymbol arguments: #(5).	aLine := ms asTilesIn: Player globalNames: false.	aLine firstSubmorph delete.		aLine addMorphFront: (slotMsg submorphs second) firstSubmorph.	aLine firstSubmorph setNameTo: 'label'.	aLine addMorphFront: (Morph new transparentSpacerOfSize: 3@3).	aLine lastSubmorph delete.	aLine lastSubmorph delete.	aLine color: aColor; setNameTo: 'Number (fancy)'.	aLine addMorphBack: (Morph new transparentSpacerOfSize: 3@3).	aLine addMorphBack: aTile.	aLine readOut setNameTo: 'value'.	aLine cellPositioning: #leftCenter.	aWatcher step; fitContents.	^ aLine markAsPartsDonor.! !!Object methodsFor: 'message handling' stamp: 'st 11/5/2004 16:19'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackage	^false! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^false! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:04'!adjustTargetBorderWidth: aFractionalPoint	| n |	myTarget borderWidth: (n := (aFractionalPoint x * 10) rounded max: 0).	self showSliderFeedback: n.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:02'!adjustTargetGradientDirection: aFractionalPoint	| fs p |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs direction: (p := (aFractionalPoint * myTarget extent) rounded).	self showSliderFeedback: p.	myTarget changed.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:05'!adjustTargetGradientOrigin: aFractionalPoint	| fs p |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs origin: (p := myTarget topLeft + (aFractionalPoint * myTarget extent) rounded).	self showSliderFeedback: p.	myTarget changed.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:03'!adjustTargetShadowOffset: aFractionalPoint	| n |	myTarget changed; layoutChanged.	myTarget shadowOffset: (n := (aFractionalPoint * 4) rounded).	self showSliderFeedback: n.	myTarget changed; layoutChanged.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:03'!doEnables	| itsName fs |	fs := myTarget fillStyle.	self allMorphsDo: [ :each |		itsName := each knownName.		itsName == #pickerForColor ifTrue: [			self enable: each when: fs isSolidFill | fs isGradientFill		].		itsName == #pickerForBorderColor ifTrue: [			self enable: each when: (myTarget respondsTo: #borderColor:)		].		itsName == #pickerForShadowColor ifTrue: [			self enable: each when: myTarget hasDropShadow		].		itsName == #pickerFor2ndGradientColor ifTrue: [			self enable: each when: fs isGradientFill		].	].! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/8/2003 19:35'!rebuild	self removeAllMorphs.	self addARow: {		self lockedString: ('Properties for {1}' translated format: {myTarget name}).	}.	self addARow: {		self inAColumn: {			self paneForCornerRoundingToggle.			self paneForStickinessToggle.			self paneForLockedToggle.		}.	}.	self addARow: {		self paneForMainColorPicker.		self paneFor2ndGradientColorPicker.	}.	self addARow: {		self paneForBorderColorPicker.		self paneForShadowColorPicker.	}.	self addARow: {		self 			buttonNamed: 'Accept' translated action: #doAccept color: color lighter 			help: 'keep changes made and close panel' translated.		self 			buttonNamed: 'Cancel' translated action: #doCancel color: color lighter 			help: 'cancel changes made and close panel' translated.	}, self rebuildOptionalButtons.	thingsToRevert := Dictionary new.	"thingsToRevert at: #fillStyle: put: myTarget fillStyle."	myTarget isSystemWindow ifTrue: [		thingsToRevert at: #setWindowColor: put: myTarget paneColorToUse	].	thingsToRevert at: #hasDropShadow: put: myTarget hasDropShadow.	thingsToRevert at: #shadowColor: put: myTarget shadowColor.	(myTarget respondsTo: #borderColor:) ifTrue: [		thingsToRevert at: #borderColor: put: myTarget borderColor.	].	thingsToRevert at: #borderWidth: put: myTarget borderWidth.	thingsToRevert at: #cornerStyle: put: myTarget cornerStyle.	thingsToRevert at: #sticky: put: myTarget isSticky.	thingsToRevert at: #lock: put: myTarget isLocked.! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'wiz 9/21/2005 22:42'!rebuildOptionalButtons	| answer |	answer := #() .		myTarget isTextMorph ifTrue: [		answer := answer, {			self 				buttonNamed: 'Text' translated action: #doTextProperties color: color lighter 				help: 'open a text properties panel for the morph' translated.		}.	].	^answer! !!ObjectPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/8/2001 18:02'!toggleTargetRadial	| fs |	(fs := myTarget fillStyle) isGradientFill ifFalse: [^self].	fs radial: fs radial not.	myTarget changed.	self doEnables.! !!ObjectPropertiesMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:44'!initialize"initialize the state of the receiver"	super initialize.""	myTarget		ifNil: [myTarget := RectangleMorph new openInWorld].	self rebuild! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'sd 11/13/2003 21:03'!borderPrototype: aBorderStyle help: helpString	| selector proto |	selector := BorderedMorph new.	selector borderWidth: 0.	selector color: Color transparent.	proto := Morph new extent: 16@16.	proto color:  Color transparent.	proto borderStyle: aBorderStyle.	selector extent: proto extent + 4.	selector addMorphCentered: proto.	(myTarget canDrawBorder: aBorderStyle) ifTrue:[		selector setBalloonText: helpString.		selector on: #mouseDown send: #toggleBorderStyle:with:from: to: self withValue: proto.		(myTarget borderStyle species == aBorderStyle species and:[			myTarget borderStyle style == aBorderStyle style]) ifTrue:[selector borderWidth: 1].	] ifFalse:[		selector setBalloonText: 'This border style cannot be used here' translated.		selector on: #mouseDown send: #beep to: Beeper.		selector addMorphCentered: ((Morph new) color: (Color black alpha: 0.5); extent: selector extent).	].	^selector! !!ObjectPropertiesMorph methodsFor: 'panes' stamp: 'ar 8/25/2001 18:35'!toggleBorderStyle: provider with: arg1 from: arg2	| oldStyle newStyle |	oldStyle := myTarget borderStyle.	newStyle := provider borderStyle copy.	oldStyle width = 0 		ifTrue:[newStyle width: 2]		ifFalse:[newStyle width: oldStyle width].	newStyle baseColor: oldStyle baseColor.	myTarget borderStyle: newStyle.	provider owner owner submorphsDo:[:m| m borderWidth: 0].	provider owner borderWidth: 1.! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject	"Set the receiver's representee.  This clears out any preexisting state in the receiver"	objectRepresented := anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: anObject name asString).	self setNameTo: anObject name	! !!ObjectRepresentativeMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/1/2000 15:55'!objectRepresented: anObject labelString: aLabel	"Set the receiver's representee as indicated, and use the given label to tag it"	objectRepresented := anObject.	self removeAllMorphs.	self hResizing: #shrinkWrap.  	self vResizing: #shrinkWrap.	self addMorphBack: (StringMorph new contents: aLabel asString).	self setNameTo: aLabel asString	! !!ObjectsTool methodsFor: 'categories' stamp: 'edc 12/4/2007 15:34'!showCategory: aCategoryName fromButton: aButton 	"Project items from the given category into my lower pane"	| quads |	"self partsBin removeAllMorphs. IMHO is redundant, "		Cursor wait		showWhile: [quads := OrderedCollection new.			Morph withAllSubclasses				do: [:aClass | aClass theNonMetaClass						addPartsDescriptorQuadsTo: quads						if: [:aDescription | aDescription translatedCategories includes: aCategoryName]].			quads := quads						asSortedCollection: [:q1 :q2 | q1 third <= q2 third].			self installQuads: quads fromButton: aButton]! !!OneOnSwitch methodsFor: 'connection'!connection: anObject 	"Set anObject to be the connection among two or more Switches. Make the 	receiver a dependent of the argument, anObject."	connection := anObject.	connection addDependent: self! !!OneOnSwitch methodsFor: 'state'!turnOn	"Does nothing if it is already on. If it is not, it is set to 'on', its	dependents are 	notified of the change, its connection is notified, and	its action is executed."	self isOff		ifTrue: 			[on := true.			self changed.			self notifyConnection.			self doAction: onAction]! !!OrderedCollection methodsFor: 'accessing'!at: anInteger put: anObject 	"Put anObject at element index anInteger. at:put: cannot be used to	append, front or back, to an ordered collection; it is used by a	knowledgeable client to replace an element."	| index |	index := anInteger asInteger.	(index < 1 or: [index + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^array at: index + firstIndex - 1 put: anObject]! !!OrderedCollection methodsFor: 'adding'!add: newObject after: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just succeeding oldObject. Answer newObject."		| index |	index := self find: oldObject.	self insert: newObject before: index + 1.	^newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject before: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."		| index |	index := self find: oldObject.	self insert: newObject before: index.	^newObject! !!OrderedCollection methodsFor: 'adding'!addFirst: newObject 	"Add newObject to the beginning of the receiver. Answer newObject."	firstIndex = 1 ifTrue: [self makeRoomAtFirst].	firstIndex := firstIndex - 1.	array at: firstIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding'!addLast: newObject 	"Add newObject to the end of the receiver. Answer newObject."	lastIndex = array size ifTrue: [self makeRoomAtLast].	lastIndex := lastIndex + 1.	array at: lastIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'ajh 5/22/2003 12:03'!at: index ifAbsentPut: block	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"	| v |	index <= self size ifTrue: [		^ (v := self at: index)			ifNotNil: [v]			ifNil: [self at: index put: block value]	].	[self size < index] whileTrue: [self add: nil].	^ self at: index put: block value! !!OrderedCollection methodsFor: 'adding'!grow	"Become larger. Typically, a subclass has to override this if the subclass	adds instance variables."	| newArray |	newArray := Array new: self size + self growSize.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array := newArray! !!OrderedCollection methodsFor: 'copying' stamp: 'di 12/12/2000 10:15'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection := self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection addLast: (self at: index)].	^ targetCollection! !!OrderedCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta := 0.	startIndex := start.	stopIndex := stop.	start < 1		ifTrue: [startIndex := stopIndex := 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex := stopIndex := self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta := stopIndex - startIndex + 1]].	newOrderedCollection := 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection! !!OrderedCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection := self copy.	newCollection add: newElement.	^newCollection! !!OrderedCollection methodsFor: 'copying' stamp: 'sw 1/26/96'!reversed	"Answer a copy of the receiver with element order reversed.  "	| newCol |	newCol := self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into a collection that is like me. Answer the new 	collection. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection := self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (aBlock value: (array at: index))].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/18/2000 17:34'!collect: aBlock from: fromIndex to: toIndex	"Override superclass in order to use addLast:, not at:put:."	| result |	(fromIndex < 1 or:[toIndex + firstIndex - 1 > lastIndex])		ifTrue: [^self errorNoSuchElement].	result := self species new: toIndex - fromIndex + 1.	firstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:		[:index | result addLast: (aBlock value: (array at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating'!do: aBlock 	"Override the superclass for performance reasons."	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue: 			[aBlock value: (array at: index).			index := index + 1]! !!OrderedCollection methodsFor: 'enumerating'!reverseDo: aBlock 	"Override the superclass for performance reasons."	| index |	index := lastIndex.	[index >= firstIndex]		whileTrue: 			[aBlock value: (array at: index).			index := index - 1]! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:13'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection element |	newCollection := self copyEmpty.	firstIndex to: lastIndex do:		[:index |		(aBlock value: (element := array at: index))			ifTrue: [newCollection addLast: element]].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result := self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!OrderedCollection methodsFor: 'enumerating' stamp: 'bf 5/16/2000 16:30'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection := self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (elementAndIndexBlock			value: (array at: index)			value: index - firstIndex + 1)].	^ newCollection! !!OrderedCollection methodsFor: 'removing'!remove: oldObject ifAbsent: absentBlock	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue: 			[oldObject = (array at: index)				ifTrue: 					[self removeIndex: index.					^ oldObject]				ifFalse: [index := index + 1]].	^ absentBlock value! !!OrderedCollection methodsFor: 'removing' stamp: 'raok 4/27/2001 15:35'!removeAllSuchThat: aBlock 	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| n |	n := firstIndex.	firstIndex to: lastIndex do: [:index |	    (aBlock value: (array at: index)) ifFalse: [			array at: n put: (array at: index).			n := n + 1]].	n to: lastIndex do: [:index | array at: index put: nil].	lastIndex := n - 1! !!OrderedCollection methodsFor: 'removing' stamp: 'ar 5/22/2000 12:19'!removeAt: index	| removed |	removed := self at: index.	self removeIndex: index + firstIndex - 1.	^removed! !!OrderedCollection methodsFor: 'removing'!removeFirst	"Remove the first element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| firstObject |	self emptyCheck.	firstObject := array at: firstIndex.	array at: firstIndex put: nil.	firstIndex := firstIndex + 1.	^ firstObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:37'!removeFirst: n	"Remove first n object into an array"	| list |	list := Array new: n.	1 to: n do: [:i |		list at: i put: self removeFirst].	^ list! !!OrderedCollection methodsFor: 'removing'!removeLast	"Remove the last element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| lastObject |	self emptyCheck.	lastObject := array at: lastIndex.	array at: lastIndex put: nil.	lastIndex := lastIndex - 1.	^ lastObject! !!OrderedCollection methodsFor: 'removing' stamp: 'ajh 6/22/2003 14:36'!removeLast: n	"Remove last n object into an array with last in last position"	| list |	list := Array new: n.	n to: 1 by: -1 do: [:i |		list at: i put: self removeLast].	^ list! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:26'!find: oldObject  "  This method answers an index in the range firstIndex .. lastIndex, which is meant for internal use only.     Never use this method in your code, the methods for public use are:        #indexOf:        #indexOf:ifAbsent: "	| index |	index := firstIndex.	[index <= lastIndex]		whileTrue:			[(array at: index) = oldObject ifTrue: [^ index].			index := index + 1].	self errorNotFound: oldObject! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:29'!insert: anObject before: spot  "  spot is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.      Never use this method in your code, it is meant for private use by OrderedCollection only.     The methods for use are:        #add:before:   to insert an object before another object        #add:beforeIndex:   to insert an object before a given position. "	| "index" delta spotIndex|	spotIndex := spot.	delta := spotIndex - firstIndex.	firstIndex = 1		ifTrue: 			[self makeRoomAtFirst.			spotIndex := firstIndex + delta].	firstIndex := firstIndex - 1.	array		replaceFrom: firstIndex		to: spotIndex - 2		with: array		startingAt: firstIndex + 1.	array at: spotIndex - 1 put: anObject."	index := firstIndex := firstIndex - 1.	[index < (spotIndex - 1)]		whileTrue: 			[array at: index put: (array at: index + 1).			index := index + 1].	array at: index put: anObject."	^ anObject! !!OrderedCollection methodsFor: 'private'!makeRoomAtFirst	| delta index |	delta := array size - self size.	delta = 0 ifTrue: 			[self grow.			delta := array size - self size].	lastIndex = array size ifTrue: [^ self]. "just in case we got lucky"	index := array size.	[index > delta]		whileTrue: 			[array at: index put: (array at: index - delta + firstIndex - 1).			array at: index - delta + firstIndex - 1 put: nil.			index := index - 1].	firstIndex := delta + 1.	lastIndex := array size! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast := self size.	array size - self size = 0 ifTrue: [self grow].	(delta := firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex := 1.	lastIndex := newLast! !!OrderedCollection methodsFor: 'private' stamp: 'BG 1/9/2004 12:28'!removeIndex: removedIndex  "  removedIndex is an index in the range firstIndex .. lastIndex, such an index is not known from outside the collection.    Never use this method in your code, it is meant for private use by OrderedCollection only.     The method for public use is:        #removeAt: "	array 		replaceFrom: removedIndex 		to: lastIndex - 1 		with: array 		startingAt: removedIndex+1.	array at: lastIndex put: nil.	lastIndex := lastIndex - 1.! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!reset	firstIndex := array size // 3 max: 1.	lastIndex := firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'ar 4/16/1999 07:59'!resetTo: index	firstIndex := index.	lastIndex := firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!setCollection: anArray	array := anArray.	self reset! !!OrderedCollection methodsFor: 'private' stamp: 'apb 10/15/2000 18:10'!setContents: anArray	array := anArray.	firstIndex := 1.	lastIndex := array size.! !!OrderedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^newCollection"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'apb 10/15/2000 22:02'!ofSize: n	"Create a new collection of size n with nil as its elements.	This method exists because OrderedCollection new: n creates an	empty collection,  not one of size n."	| collection |	collection := self new: n.	collection setContents: (collection collector).	^ collection! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'rej 11/26/2006 21:22'!cExternalCall1	<primitive: 'prim1' module: 'CPCCT'>! !!PCCByCompilationTest methodsFor: 'example module' stamp: 'rej 11/26/2006 21:22'!cExternalCall2		<primitive:'prim2'module:'CPCCT'>		self primitiveFailed! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'rej 11/26/2006 21:22'!cFailedCall	<primitive: 'primGetModuleName' module:'CFailModule'>	^ 'failed call'! !!PCCByCompilationTest methodsFor: 'test methods' stamp: 'rej 11/26/2006 21:22'!cRealExternalCallOrPrimitiveFailed	<primitive: 'primGetModuleName' module:'LargeIntegers'>	self primitiveFailed! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'rej 11/24/2006 18:24'!tearDown	World changed.	fileName notNil ifTrue: [FileDirectory default deleteFileNamed: fileName]! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle := clipRect! !!Paragraph methodsFor: 'accessing'!compositionRectangle: compRectangle 	"Set the rectangle whose width is the dimension, modified by indents and 	tabsLevels, against which line wraparound is measured."	compositionRectangle := compRectangle.	self composeAll! !!Paragraph methodsFor: 'accessing'!fillColor: maskForm 	"Set the argument, maskForm, to be the form with which each character 	is combined by the scanner before applying the rule for display."	mask := maskForm! !!Paragraph methodsFor: 'accessing'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator cr tab ch |	cr := Character cr.	tab := Character tab.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: lastLine) last.	reader := ReadStream on: text string from: first to: last.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) == tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	lastSeparator = last | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!Paragraph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines := lines copy.	obsoleteLastLine := lastLine.	"find the starting and stopping lines"	firstLineIndex := startLine := self lineIndexOfCharacterIndex: start.	stopLine := self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange := aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle := compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle := (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner := CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex := (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine := compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine := startLine - 1.							self lineAt: startLine put: newLine.							startIndex := newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done := false.	lastLineIndex := stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine := compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop := (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY := self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY := self topAtLineIndex: firstLineIndex + 1.						stopLine := firstLineIndex.						done := true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex := lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex := firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex := lastLineIndex + 1]].		startIndex := newLine last + 1.		firstLineIndex := firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine := firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle :=				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing'!rule: ruleInteger 	"Set the rule according to which character display behaves."	rule := ruleInteger! !!Paragraph methodsFor: 'accessing'!text: aText 	"Set the argument, aText, to be the text for the receiver."	text := aText.	self composeAll! !!Paragraph methodsFor: 'composition' stamp: 'yo 1/23/2003 22:47'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines := Array new: 32.	lastLine := 0.	maximumRightX := 0.	text size = 0		ifTrue:			[compositionRectangle := compositionRectangle withHeight: 0.			^maximumRightX].	startIndex := lineIndex := 1.	stopIndex := text size.	compositionScanner := MultiCompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX := compositionScanner rightX max: maximumRightX.		 startIndex := (lines at: lineIndex) last + 1.		 lineIndex := lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'composition'!wrappingBox: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap 	within the rectangle, compositionRect, and the display of the text is 	clipped by the rectangle, clippingRect."	self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset.	clippingRectangle := clippingRect copy! !!Paragraph methodsFor: 'converting' stamp: 'yo 6/23/2003 19:05'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	textStyle isTTCStyle ifTrue: [		theForm :=  (Form extent: compositionRectangle extent depth: 32)		offset: offset.	] ifFalse: [		theForm := (ColorForm extent: compositionRectangle extent)			offset: offset;			colors: (Array				with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])				with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	].	oldBackColor := backColor.	oldForeColor := foreColor.	backColor := Color white.	foreColor := Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor := oldBackColor.	foreColor := oldForeColor.	^ theForm"Example:| p |p := 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule := ruleInteger.	mask := aForm.	clippingRectangle := clipRectangle.	compositionRectangle := aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'scrolling' stamp: 'hmm 9/16/2000 21:30'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max := 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min := 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount := ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [destinationForm deferUpdatesIn: clippingRectangle while: [					self scrollUncheckedBy: amount						withSelectionFrom: startBlock to: stopBlock].				^ true]		ifFalse: [^ false]! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta := 0 @ (0 - heightToMove).	compositionRectangle := compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle := clippingRectangle.	clippingRectangle := clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle := heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle := savedClippingRectangle! !!Paragraph methodsFor: 'selecting' stamp: 'ar 5/28/2000 12:10'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box := CaretForm boundingBox.	f := Form extent: box extent depth: depth.	map := (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb := BitBlt current toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'dvf 10/1/2003 13:28'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model in: self at: clickPoint editor: aController) ifTrue: [action := true]]]]].	^ action! !!Paragraph methodsFor: 'selecting' stamp: 'th 9/19/2002 17:27'!extendSelectionMark: markBlock pointBlock: pointBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."	true 		ifTrue:[^self mouseMovedFrom: pointBlock					pivotBlock: markBlock					showingCaret:(pointBlock = markBlock)]		ifFalse:		[	| beginBlock endBlock |			beginBlock := markBlock min: pointBlock.			endBlock := markBlock max: endBlock.				(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock				ifTrue: [^self mouseMovedFrom: beginBlock 							pivotBlock: endBlock							showingCaret: (beginBlock = endBlock)]				ifFalse: [^self mouseMovedFrom: endBlock 							pivotBlock: beginBlock							showingCaret: (beginBlock = endBlock)]		]! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/1/1999 12:31'!hiliteRect: rect	| highlightColor |	highlightColor := Color quickHighLight: destinationForm depth.	rect ifNotNil: [		destinationForm			fill: rect			rule: Form reverse			fillColor: highlightColor.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: highlightColor" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock := startBlock := beginBlock.	showingCaret := caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock := self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret := false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock := stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock := stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!mouseSelect	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes.  Return quickly if the button is noticed up	to make double-click more responsive."	| pivotBlock startBlock stopBlock origPoint stillDown |	stillDown := Sensor redButtonPressed.	pivotBlock := startBlock := stopBlock :=		self characterBlockAtPoint: (origPoint := Sensor cursorPoint).	stillDown := stillDown and: [Sensor redButtonPressed].	self reverseFrom: startBlock to: startBlock.	[stillDown and: [Sensor cursorPoint = origPoint]] whileTrue:		[stillDown := Sensor redButtonPressed].	(stillDown and: [clippingRectangle containsPoint: Sensor cursorPoint])		ifFalse: [^Array with: pivotBlock with: stopBlock].	^ self mouseMovedFrom: startBlock 		pivotBlock: pivotBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!mouseSelect: clickPoint 	"Track text selection and answer with an Array of two CharacterBlocks."	| startBlock |	startBlock := self characterBlockAtPoint: clickPoint.	self reverseFrom: startBlock to: startBlock.	^ self mouseMovedFrom: startBlock 		pivotBlock: startBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret := self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle := 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo := self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline := lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle := clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle := 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle := 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle := 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle := 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle := 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle := 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle := 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'utilities'!deepCopy	"Don't want to copy the destForm (Display) or fonts in the TextStyle.  9/13/96 tk"	| new |	new := self copy.	new textStyle: textStyle copy.	new destinationForm: destinationForm.	new lines: lines copy.	new text: text deepCopy.	^ new! !!Paragraph methodsFor: 'utilities'!destinationForm: destForm	destinationForm := destForm! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle := clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'utilities'!lines: lineArray	lines := lineArray! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle := compositionRect copy.	text := aText.	textStyle := aTextStyle.	rule := DefaultRule.	mask := nil.		"was DefaultMask "	marginTabsLevel := 0.	destinationForm := Display.	offset := aPoint.	^self composeAll! !!Paragraph methodsFor: 'private' stamp: 'yo 1/23/2003 22:48'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex := self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex := linesInterval first].	lastLineIndex := self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex := lastLine]		  		ifFalse: [lastLineIndex := linesInterval last]].	lastLineIndexBottom := (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY := self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				MultiDisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	saveDestinationForm := destinationForm.	destinationForm := aDisplayMedium.	self displayLines: lineInterval.	destinationForm := saveDestinationForm! !!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex 	"Build the left margin for composition of a line. Depends upon	marginTabsLevel and the indent."	| indent |	lineIndex = 1		ifTrue: [indent := textStyle firstIndent]		ifFalse: [indent := textStyle restIndent].	^indent + (textStyle leftMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private' stamp: 'ar 12/15/2001 23:29'!leftMarginForDisplayForLine: lineIndex alignment: alignment	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(alignment = LeftFlush or: [alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad := (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad := 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineAt: indexInteger put: aTextLineInterval 	"Store a line, track last, and grow lines if necessary."	indexInteger > lastLine ifTrue: [lastLine := indexInteger].	lastLine > lines size ifTrue: [lines := lines , (Array new: lines size)].	^lines at: indexInteger put: aTextLineInterval! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y := compositionRectangle top.	1 to: lastLine do:		[:i | line := lines at: i.		(y := y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle := compositionRectangle translateBy: delta.	clippingRectangle := clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded := Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth := self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle := compositionRectangle withWidth: compositionWidth.	clippingRectangle := compositionRectangle copy.	shrink := unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	^self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: cf backColor: cb	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle := clipRect copy.	self foregroundColor: cf backgroundColor: cb.	^ self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y := compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y := y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y := compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y := y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!trimLinesTo: lastLineInteger	(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].	(lastLine := lastLineInteger) < (lines size // 2) 		ifTrue: [lines := lines copyFrom: 1 to: lines size - (lines size // 2)]! !!Paragraph methodsFor: 'private'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle := compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle := compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip := clippingRectangle.	clippingRectangle := clipRect.		aBlock value.	clippingRectangle := saveClip! !!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point := Sensor waitButton.	para := 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: c1 backColor: c2	"Answer an instance of me with text set to aText and style set to 	aTextStyle, composition rectangle is compRect and the clipping rectangle 	is clipRect."	| para |	para := super new.	para setWithText: aText		style: aTextStyle		compositionRectangle: compRect		clippingRectangle: clipRect		foreColor: c1 backColor: c2.	^para! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 5/22/2007 11:28'!tallyIt	^ self tallySelection! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'ktt 11/28/2005 12:16'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	startIndex := self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex := 1 max: startIndex - 1.			].	self backTo: startIndex.			^false! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'edc 4/13/2007 16:42'!yellowButtonExpertMenu	^ MenuMorph fromArray: {			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			     		{'print it (p)' translated.		#printIt}.		     		{'inspect it (i)' translated.		#inspectIt}.		     		{'explore it (I)' translated.		#exploreIt}.		     		{'debug it' translated.			#debugIt}.		     		{'tally it' translated.			#tallyIt}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.			#-.			{'show bytecodes' translated.			#showBytecodes}.			#-.			{'copy html' translated.					#copyHtml}.			#-.			{'more...' translated.					#shiftedTextPaneMenuRequest}.		}.! !!ParameterTile methodsFor: 'access' stamp: 'sw 3/15/2005 22:36'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	"Answer a phrase of the right type for the putative container"	| aTemporaryViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[aTemporaryViewer := CategoryViewer new invisiblySetPlayer: aPlayer.		aPhrase := aTemporaryViewer booleanPhraseFromPhrase: self.		aPhrase justGrabbedFromViewer: false.		^ aPhrase].	^ self! !!ParameterTile methodsFor: 'access' stamp: 'sw 1/18/2004 22:12'!scriptEditor	"Answer the receiver's script editor.  The slightly strange code here is in order to contend with the unusual situation where a parameter tile obtained from one script editor is later dropped into a different script editor.  As long as the parameter tile is *in* a script editor, that containing scriptEditor is the one; if it is *not*, then we use the last known one"	| aScriptEditor |	^ (aScriptEditor := self outermostMorphThat: [:m | m isKindOf: ScriptEditorMorph])		ifNotNil:			[scriptEditor := aScriptEditor]		ifNil:			[scriptEditor]! !!ParameterTile methodsFor: 'code generation' stamp: 'yo 12/20/2003 02:49'!storeCodeOn: aStream indent: tabCount	"Store code on the stream" 	| myTypeString |	myTypeString := self resultType.	(self scriptEditor hasParameter and: [self scriptEditor typeForParameter = myTypeString])		ifTrue:			[aStream nextPutAll: 'parameter']		ifFalse:			["This script no longer bears a parameter, yet there's an orphaned Parameter tile in it"			aStream nextPutAll: '(self defaultValueOfType: #', myTypeString, ')']! !!ParameterTile methodsFor: 'initialization' stamp: 'yo 3/14/2005 08:01'!forScriptEditor: aScriptEditor	"Make the receiver be associated with the given script editor"	scriptEditor := aScriptEditor.	self line1: aScriptEditor typeForParameter translated.! !!ParameterTile methodsFor: 'miscellaneous' stamp: 'sw 3/15/2005 22:37'!booleanComparatorPhrase	"Answer a boolean-valued phrase derived from a retriever (e.g. 'car's heading'); this is in order to assure that tiles laid down in a TEST area will indeed produce a boolean result"	| outerPhrase rel retrieverType |	retrieverType := self resultType.	rel := (Vocabulary vocabularyForType: retrieverType) comparatorForSampleBoolean.	outerPhrase := PhraseTileMorph new setOperator: rel type: #Boolean rcvrType: retrieverType argType: retrieverType.	outerPhrase firstSubmorph addMorph: self.	outerPhrase submorphs last addMorph: (ScriptingSystem tileForArgType: retrieverType).	outerPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: rel).    	^ outerPhrase! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:47'!addCommentToMorph: aMorph	| row |	(self comment isNil or: [self comment isEmpty]) ifTrue: [^ self].	row := aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'RAA 8/24/1999 12:24'!asMorphicSyntaxIn: parent	| morph |	"Default for missing implementations"	morph := parent addColumn: #error on: self.	morph addTextRow: self class printString.	^morph	! !!Parser methodsFor: 'error correction' stamp: 'rr 10/3/2007 09:58'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges _ false.	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[(UIManager default 				confirm: (temp , ' appears to be\unused in this method.\OK to remove it?') withCRs)				ifTrue: [end _ tempsMark.						["Beginning at right temp marker..."						start _ end - temp size + 1.						end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isAlphaNumeric not & (str at: end+1) isAlphaNumeric not]]]						whileFalse: ["Search left for the unused temp"									end _ requestor nextTokenFrom: end direction: -1].						end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start _ start-1].						requestor correctFrom: start to: end with: ''.						str _ str copyReplaceFrom: start to: end with: ''. 						madeChanges _ true.						tempsMark _ tempsMark - (end-start+1)]]]].	madeChanges ifTrue: [ParserRemovedUnusedTemps signal]! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48'!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04'!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47'!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50'!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!PartsBin methodsFor: '*BabySRE-connectors-initialization' stamp: 'edc 12/4/2007 16:01'!listDirection: aListDirection quadList: quadList buttonClass: buttonClass	"Initialize the receiver to run horizontally or vertically, obtaining its elements from the list of tuples of the form:		(<receiver> <selector> <label> <balloonHelp>)"	| aButton aClass |	self layoutPolicy: TableLayout new.	self listDirection: aListDirection.	self wrapCentering: #topLeft.	self layoutInset: 2.	self cellPositioning: #bottomCenter.	aListDirection == #leftToRight		ifTrue:			[self vResizing: #rigid.			self hResizing: #spaceFill.			self wrapDirection: #topToBottom]		ifFalse:			[self hResizing: #rigid.			self vResizing: #spaceFill.			self wrapDirection: #leftToRight].	quadList do:		[:tuple |			aClass _ Smalltalk at: tuple first.			aButton _ buttonClass new .			aButton color: self color;		initializeToShow: (self class thumbnailForQuad: tuple) withLabel:  tuple third andSend: tuple second to: aClass.			(tuple size > 3 and: [tuple fourth isEmptyOrNil not]) ifTrue:				[aButton setBalloonText: tuple fourth]. 			self addMorphBack: aButton].! !!PasteUpMorph methodsFor: 'world state' stamp: 'wiz 12/4/2006 00:32'!paintArea	"What rectangle should the user be allowed to create a new painting in??	An area beside the paintBox. Allow playArea to override with its own	bounds!! "	| playfield paintBoxBounds |	playfield := self				submorphNamed: 'playfield'				ifNone: [].	playfield		ifNotNil: [^ playfield bounds].	paintBoxBounds := self paintBox bounds.	self firstHand targetPoint x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left @ bounds bottom"paint on left side"]		ifFalse: [^ paintBoxBounds right @ bounds top corner: bounds bottomRight]! !!PasteUpMorph methodsFor: '*eToys-customevents-scripting' stamp: 'nk 9/26/2003 23:20'!userCustomEventNames	| reg |	reg := self valueOfProperty: #userCustomEventsRegistry ifAbsent: [ ^#() ].	^reg keys asArray sort! !!PasteUpMorphTest methodsFor: 'tests' stamp: 'wiz 7/19/2007 10:56'!testPlayWithMe1Romoval	"A trivial test for checking that PlayWithMe classes are all removed"	self deny: ( Smalltalk hasClassNamed: 'PlayWithMe1' ) .! !!Path methodsFor: 'accessing'!form	"Answer the receiver's form, or, if form is nil, then answer a 1 x 1 black 	form (a black dot)."	| aForm |	form == nil		ifTrue: 			[aForm := Form extent: 1 @ 1.			aForm fillBlack.			^aForm]		ifFalse: 			[^form]! !!Path methodsFor: 'accessing'!form: aForm 	"Make the argument, aForm, be the receiver's form."	form := aForm! !!Path methodsFor: 'display box access'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	| box |	box := Rectangle origin: (self at: 1) extent: 0 @ 0.	collectionOfPoints do: 		[:aPoint | box := box merge: (Rectangle origin: aPoint extent: 0 @ 0)].	^box! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Displays this path, translated and scaled by aTransformation. Get the	scaled and translated Path."	| newPath transformedPath |	transformedPath := displayTransformation applyTo: self.	newPath := Path new.	transformedPath do: [:point | newPath add: point].	newPath form: self form.	newPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Path methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect the resulting values into a path that is like the receiver. Answer 	the new path."	| newCollection |	newCollection := collectionOfPoints collect: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new path like the receiver only those elements for which 	aBlock evaluates to true. Answer the new path."	| newCollection |	newCollection := collectionOfPoints select: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:26'!scaleBy: aPoint 	"Answers a new Path scaled by aPoint. Does not affect the current data in 	this Path."	| newPath | 	newPath := self species new: self size. 	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element scaleBy: aPoint)].	^newPath! !!Path methodsFor: 'transforming' stamp: 'jrm 9/1/1999 21:28'!translateBy: aPoint 	"Answers a new Path whose elements are translated by aPoint. Does not	affect the elements of this Path."	| newPath |	newPath := self species new: self size.	newPath form: self form.	collectionOfPoints do: [:element | newPath add: (element translateBy: aPoint)].	^newPath! !!Path methodsFor: 'private'!initializeCollectionOfPoints	collectionOfPoints := OrderedCollection new! !!Path methodsFor: 'private'!initializeCollectionOfPoints: anInteger	collectionOfPoints := OrderedCollection new: anInteger! !!Path class methodsFor: 'examples'!example	"Creates a Path from mousePoints and displays it several ways on the display screen. Messes up the display. For learning about class Path, just select the code below and execute it to create a path and see it redisplayed in another place on the screen. Each path displays using a different form. A path is indicated by pressing the red mouse button in a sequence; press any other mouse button to terminate. "	| aPath aForm pl fl flag |	aForm := Form extent: 2 @ 40.		"creates a form one inch long"	aForm fillBlack.							"turns it black"	aPath := Path new.	aPath form: aForm.						"use the long black form for displaying"	flag := true.	[flag]		whileTrue: 			[Sensor waitButton.			Sensor redButtonPressed				ifTrue: 					[aPath add: Sensor waitButton.					Sensor waitNoButton.					aForm displayOn: Display at: aPath last]				ifFalse: [flag := false]].	Display fillWhite.	aPath displayOn: Display.			"the original path"	pl := aPath translateBy: 0 @ 100.	fl := Form extent: 40 @ 40.	fl fillGray.	pl form: fl.	pl displayOn: Display.				"the translated path"	Sensor waitNoButton	"Path example"! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 12/13/2001 17:41'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	"Answer a phrase of the right type for the putative container"	| aTemporaryViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aTemporaryViewer := CategoryViewer new invisiblySetPlayer: aPlayer.		aPhrase := aTemporaryViewer booleanPhraseFromPhrase: self.		aPhrase justGrabbedFromViewer: false.		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/9/2001 00:15'!justDroppedInto: newOwner event: evt	"Phrase tiles only auto-expand if they originate from viewers.  Any phrase tile, once dropped, loses its auto-phrase-expansion thing"	justGrabbedFromViewer := false.	super justDroppedInto: newOwner event: evt! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 8/28/2004 14:23'!initialize	"Initialize a nascent instance"	super initialize.	resultType := #unknown.	brightenedOnEnter := false.	self wrapCentering: #center; cellPositioning: #leftCenter.	self hResizing: #shrinkWrap.	borderWidth := 0.	self layoutInset: 0.	self extent: 5@5.  "will grow to fit"	self minCellSize: (0 @ (Preferences standardEToysFont height rounded + 10)).	justGrabbedFromViewer := true.  "All new PhraseTileMorphs that go through the initialize process (rather than being copied) are placed in viewers; the clones dragged out from them will thus have this set the right way; the drop code resets this to false"! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:01'!setAngleToOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaAngleToTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 10/29/1998 16:01'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 8/12/2004 18:58'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := AssignmentTileMorph new rawVocabulary: aVocabulary.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	anAssignmentTile setAssignmentSuffix: #:.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 9/28/2004 18:24'!setBounceOnColorOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaBounceOnColorTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 9/27/2004 14:58'!setBounceOnOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaBounceOnTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 10/12/2004 22:43'!setColorComponentRoot: opSymbol componentName: componentName type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := KedamaSetColorComponentTile new rawVocabulary: aVocabulary.	anAssignmentTile componentName: componentName.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:01'!setDistanceToOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaDistanceToTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 1/30/2005 11:02'!setGetColorComponentOperator: opSymbol componentName: componentName type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaGetColorComponentTile new adoptVocabulary: self currentVocabulary.	aTileMorph componentName: componentName.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:50'!setGetPixelOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaGetPixelValueTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 9/26/2001 11:58'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := TileMorph new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:02'!setPixelValueRoot: opSymbol type: opType rcvrType: rcvrType argType: argType vocabulary: aVocabulary	"Add submorphs to make me constitute a setter of the given symbol"	| anAssignmentTile |	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	anAssignmentTile := KedamaSetPixelValueTile new rawVocabulary: aVocabulary.	self addMorphBack: (anAssignmentTile typeColor: color).	anAssignmentTile setRoot: opSymbol asString dataType: argType.	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'sw 9/27/2001 17:41'!setSlotRefOperator: opSymbol type: opType	"Set the given symbol as the receiver's slot-reference operator, adding tiles to the receiver appropriately"	resultType := opType.	self color: (ScriptingSystem colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #Player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 10/9/2004 15:38'!setTurtleAtOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaTurtleAtTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 3/7/2005 08:39'!setTurtleOfOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaTurtleOfTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'initialization' stamp: 'yo 6/18/2004 16:02'!setUpHillOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	"Set the operator, type, receiver type, and argument type for the phrase"	| aTileMorph |	resultType := opType.	opType ifNotNil: [self color: (ScriptingSystem colorForType: opType)].	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	aTileMorph := KedamaUpHillTile new adoptVocabulary: self currentVocabulary.	self addMorphBack: ((aTileMorph setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue:		[self addMorphBack: (TilePadMorph new setType: (argType ifNil: [#Object]))]! !!PhraseTileMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:35'!currentVocabulary	"Answer the current vocabulary"	vocabulary "fix up old strutures"		ifNotNil: 			[vocabularySymbol := vocabulary vocabularyName.			vocabulary := nil].	^ vocabularySymbol		ifNotNil:			[Vocabulary vocabularyNamed: vocabularySymbol]		ifNil:			[super currentVocabulary]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'tk 8/6/1999 13:59'!associatedPlayer	"Answer the player that's the object of my attention"	| pp |	pp := self firstSubmorph.	[pp isKindOf: PhraseTileMorph] whileTrue: [pp := pp firstSubmorph].	^ pp firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 12/22/2004 01:34'!dismissViaHalo	"The user has clicked in the delete halo-handle.."	| ed |	ed := self topEditor.	super dismissViaHalo.	ed ifNotNil: [ed scriptEdited]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/19/2001 15:06'!justGrabbedFromViewer	"Answer whether the receiver originated in a Viewer.  Only tiles that originated in a viewer will ever do that infernal sprouting of a new script around them.  The nil branch is only for backward compatibility."	^ justGrabbedFromViewer ifNil: [justGrabbedFromViewer := true]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/19/2001 14:25'!justGrabbedFromViewer: aBoolean	"Set the receiver's justGrabbedFromViewer instance variable"	justGrabbedFromViewer := aBoolean! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'tk 2/14/2001 14:07'!sproutNewScriptor	"The receiver, operating as a naked phrase tile, wishes to get iself placed in a nascent script"	| newScriptor |	self actualObject assureUniClass.	newScriptor := self actualObject newScriptorAround:		((self ownerThatIsA: Viewer orA: ScriptEditorMorph)			ifNotNil:				[self veryDeepCopy]			ifNil:				[self]).	self currentHand attachMorph: newScriptor! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'yo 4/4/2005 17:15'!try	"Evaluate the given phrase once"	| aPlayer |	(userScriptSelector notNil and: [userScriptSelector numArgs = 0])		ifTrue:			[aPlayer := self objectViewed player.			aPlayer triggerScript: userScriptSelector]		ifFalse:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false]! !!PhraseTileMorph methodsFor: 'miscellaneous' stamp: 'sw 1/29/98 01:49'!userScriptSelector: s	userScriptSelector := s! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'tak 3/15/2005 11:40'!catchDivideByZero: aStream indent: tabCount 	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	| exp |	submorphs second type = #operator ifFalse: [^false].	"not me"	exp := submorphs second operatorOrExpression.	(#(/ // \\) includes: exp) ifFalse: [^false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs third) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^true! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'tak 4/6/2005 14:20'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor pos aWatcher op |	((actualObject := self actualObject) isNil or: [actualObject costume isInWorld not]) ifTrue: [^ self].	self isCommand ifFalse:  "Can't expand to a scriptor, but maybe launch a watcher..."		[^ (Preferences dropProducesWatcher and: [(#(unknown command) includes: self resultType) not] and:			[(op := self operatorTile operatorOrExpression) notNil] and: [op numArgs = 0] and: [(Vocabulary gettersForbiddenFromWatchers includes: op) not])			ifTrue:				[aWatcher := WatcherWrapper new fancyForPlayer: self associatedPlayer getter: op.				aWatcher position: self position]			ifFalse:				[self]].	self justGrabbedFromViewer ifFalse: [^ self].	actualObject assureUniClass.	itsSelector := self userScriptSelector.	pos := self position.	aScriptor := itsSelector isEmptyOrNil		ifFalse:			[actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			actualObject newScriptorAround: self].	aScriptor ifNil:[^self].	(self hasOwner: aScriptor) ifTrue:[		aScriptor fullBounds. "force layout"		aScriptor position: pos - self position.	] ifFalse:[		aScriptor position: self position.	].	^ aScriptor! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'sw 6/17/2003 16:03'!mouseDown: evt 	"Handle a mouse-down on the receiver"	| ed guyToTake dup enclosingPhrase |	self isPartsDonor ifTrue:		[dup := self duplicate.		dup eventHandler: nil.   "Remove viewer-related evt mouseover feedback"		evt hand attachMorph: dup.		dup position: evt position.		"So that the drag vs. click logic works"		dup formerPosition: evt position.		^ self].	submorphs isEmpty		ifTrue: [^ self].	guyToTake := self.	[(enclosingPhrase := guyToTake ownerThatIsA: PhraseTileMorph) notNil] whileTrue:		[guyToTake := enclosingPhrase].  "This logic always grabs the outermost phrase, for now anyway"		"the below had comment: 'picking me out of another phrase'"	"owner class == TilePadMorph		ifTrue:			[(ss := submorphs first) class == TilePadMorph				ifTrue: [ss := ss submorphs first].			guyToTake :=  ss veryDeepCopy]."	(ed := self enclosingEditor) ifNil: [^ evt hand grabMorph: guyToTake].	evt hand grabMorph: guyToTake.	ed startStepping.	ed mouseEnterDragging: evt.	ed setProperty: #justPickedUpPhrase toValue: true.! !!PhraseTileMorph methodsFor: 'queries' stamp: 'nk 7/8/2000 13:35'!isCommand	"Answer whether the receiver is a true line of phrase-command. If not,  	it is a fragment that will not be able to serve as a line of script on its  	own"	| rcvrTile pad |	submorphs isEmpty		ifTrue: [^ false].	pad := submorphs first.	(pad isKindOf: TilePadMorph)		ifTrue: [(submorphs second isKindOf: AssignmentTileMorph)				ifTrue: [^ true].			(((rcvrTile := pad submorphs first) isKindOf: TileMorph)					and: [rcvrTile isPossessive])				ifTrue: [^ false]].	^ true! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'sw 10/24/2005 02:48'!duplicate	"Make and return a duplicate of the receiver."	| newMorph |	newMorph := super duplicate.	(self ownerThatIsA: Viewer) ifNotNilDo:		[:aViewer | newMorph replacePlayerInReadoutWith: aViewer scriptedPlayer].	^ newMorph! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'yo 4/3/2005 17:36'!morphsBearingPlayers	| c |	c := OrderedCollection new.	self allMorphsWithPlayersDo: [:e :p | c add: e].	^ c asArray.! !!PhraseTileMorph methodsFor: 'kedama' stamp: 'yo 4/6/2005 14:59'!replacePlayerInReadoutWith: aPlayer 	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.	self allMorphsDo: [:e |		((e isMemberOf: UpdatingStringMorph) or: [e isMemberOf: UpdatingRectangleMorph]) ifTrue: [			e target isPlayerLike ifTrue: [				e target: aPlayer			].		].	].! !!PhraseTileMorph class methodsFor: 'backward compatibility' stamp: 'sw 1/19/2001 22:25'!markViewerOrigination	"For bringing old content forward"	| hadIt gotIt didntWantIt |	hadIt := 0.	gotIt := 0.	didntWantIt := 0.	self allSubInstancesDo:		[:m | (m ownerThatIsA: CategoryViewer)			ifNil:				[m justGrabbedFromViewer: false.				didntWantIt := didntWantIt + 1]			ifNotNil:				[(m justGrabbedFromViewerOrNil == true)					ifTrue:						[hadIt := hadIt + 1]					ifFalse:						[m justGrabbedFromViewer: true.						gotIt := gotIt + 1]]].	Transcript cr; show: 'updating phrase tiles -- already ok: '; show: hadIt; show: '  marked as in-viewer: '; show: gotIt; show: '  marked as not-in-viewer: '; show: didntWantIt.	"PhraseTileMorph markViewerOrigination"! !!PhraseWrapperMorph methodsFor: 'parts bin' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PhraseWrapperMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/1/2000 22:30'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or:		[aMorph hasProperty: #newPermanentScript]! !!PhraseWrapperMorph commentStamp: '<historical>' prior: 0!An alignment morph designed for use in scripting Viewers; it wraps a set of phrases in a category viewer, and repels attempts to drop phrases upon it.!!PhraseWrapperMorph class methodsFor: 'new-morph participation' stamp: 'sw 11/9/1998 16:16'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!Player methodsFor: 'copying' stamp: 'tk 1/8/2001 10:38'!copyUniClassWith: deepCopier	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls := self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this in mapUniClasses"	newCls slotInfo: (self class privateSlotInfo veryDeepCopyWith: deepCopier).	newCls copyAddedStateFrom: self class.  "All class inst vars for inter Player refs"	^ newCls! !!Player methodsFor: 'copying' stamp: 'sw 9/15/1998 13:12'!initializeCostumesFrom: aPlayer	"Used to copy costume info over from an UnscriptedPlayer to a Player UniClass"	costume := aPlayer costume.	costumes := aPlayer costumes! !!Player methodsFor: 'copying' stamp: 'tk 9/4/2001 11:10'!veryDeepFixupWith: deepCopier	| old |	"Any uniClass inst var may have been weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.Player instSize + 1 to: self class instSize do:	[:ii | old := self instVarAt: ii.	self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!Player methodsFor: 'copying' stamp: 'tk 9/5/2001 09:43'!veryDeepInner: deepCopier	"Special code that handles user-added instance variables of a uniClass.	Copy all of my instance variables.  Some need to be not copied at all, but shared.  This is special code for the dictionary.  See DeepCopier."	| instVar weak subAss |	super veryDeepInner: deepCopier.	"my own instance variables are completely normal"	costume := costume veryDeepCopyWith: deepCopier.	costumes := costumes veryDeepCopyWith: deepCopier.	Player instSize + 1 to: self class instSize do: [:index |		instVar := self instVarAt: index.		weak := instVar isMorph | instVar isPlayerLike. 		(subAss := deepCopier references associationAt: instVar ifAbsent: [nil])				"use association, not value, so nil is an exceptional value"			ifNil: [weak ifFalse: [					self instVarAt: index put: (instVar veryDeepCopyWith: deepCopier)]]			ifNotNil: [self instVarAt: index put: subAss value].		].! !!Player methodsFor: 'costume' stamp: 'sw 9/30/2004 04:29'!ceaseHavingAParameterFor: aSelector	"Make the script represented by aSelector cease bearing a parameter"	| newSel |	self renameScript: aSelector newSelector: (newSel := (aSelector copyWithout: $:) asSymbol).	(self scriptEditorFor: newSel) assureParameterTilesValid; install! !!Player methodsFor: 'costume' stamp: 'sw 7/18/2002 11:26'!changeParameterTypeFor: aSelector	"Change the parameter type for the given selector.  Not currently sent, since types are now set by direct manipulation in the Scriptor header.  If this were reinstated someday, there would probably be an issue about getting correct-looking Parameter tile(s) into the Scriptor header(s)"	| current typeChoices typeChosen |	current := self typeforParameterFor: aSelector.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 		('Choose the TYPEfor the parameter (currently ', current, ')').	self setParameterFor: aSelector toType: typeChosen! !!Player methodsFor: 'costume' stamp: 'sw 4/7/1999 21:20'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph := self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes isEmptyOrNil ifFalse:		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/24/1998 21:48'!newCostume	| aMenu reply |	aMenu := SelectionMenu selections: self availableCostumeNames.	(reply := aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume := aMorph! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember := aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes := OrderedCollection new].	existing := (costumeToRemember isSketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes := costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 12/12/2001 14:13'!renderedCostume: aMorph remember: rememberCostume	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph known anEventHandler w baseGraphic |	renderedMorph := costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	baseGraphic := costume renderedMorph valueOfProperty: #baseGraphic.	rememberCostume		ifTrue: [self rememberCostume: renderedMorph].	renderedMorph changed.	w := renderedMorph world.	"Copy 'player state' (e.g., state which should be associated with the player but is stored in the morph itself these days) from the old rendered morph the new morph."	aMorph rotationStyle: renderedMorph rotationStyle.	aMorph forwardDirection: renderedMorph forwardDirection.	"Note: referencePosition is *not* state but #moveTo: behavior"	aMorph referencePosition: renderedMorph referencePosition.	anEventHandler := renderedMorph eventHandler.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owner ifNotNil: [costume owner replaceSubmorph: costume by: aMorph].			aMorph player: self.			aMorph actorState: costume actorState.			(known := costume knownName) ifNotNil:				[aMorph setNameTo: known].			costume := aMorph.			w ifNotNil:				[w stopStepping: renderedMorph.				w startStepping: aMorph]].	baseGraphic ifNotNil: [self setBaseGraphic: baseGraphic].	aMorph eventHandler: anEventHandler.	aMorph changed! !!Player methodsFor: 'costume' stamp: 'sw 8/3/2000 10:16'!resetCostumeList	costumes := nil! !!Player methodsFor: 'costume' stamp: 'nk 6/12/2004 10:02'!restoreBaseGraphic	"Restore my base graphic"	| cos |	((cos := self costume renderedMorph) isSketchMorph)		ifTrue:			[cos restoreBaseGraphic]! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:55'!sendMessageToCostume: aSelector	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 10/26/1998 15:54'!sendMessageToCostume: aSelector with: arg	| aCostume |	(aCostume := self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector with: arg].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume := self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 7/22/2002 17:44'!setParameterFor: aSelector toType: aTypeSymbol	"Set the parameter type for the given selector"	| aUniclassScript |	aTypeSymbol isEmptyOrNil ifTrue: [^ self].	(self typeforParameterFor: aSelector) = aTypeSymbol ifTrue: [^ self].	aUniclassScript := self class scripts at: aSelector.	aUniclassScript argumentVariables first variableType: aTypeSymbol.	aUniclassScript currentScriptEditorDo:		[:aScriptEditor | aScriptEditor assureParameterTilesValid].	self updateAllViewersAndForceToShow: #scripts	! !!Player methodsFor: 'costume' stamp: 'sw 9/30/2004 04:49'!startHavingParameterFor: aSelector	"Start having a parameter for the given selector.  After this change, the script name will change by the addition of a colon."	| newSelector |	self renameScript: aSelector newSelector: (newSelector := (aSelector, ':') asSymbol).	(self scriptEditorFor: newSelector) install! !!Player methodsFor: 'costume' stamp: 'sw 3/11/2003 00:32'!tearOffButtonToFireScriptForSelector: aSelector	"Tear off a button to fire the script for the given selector"	| aButton props |	Preferences useButtonProprtiesToFire ifFalse:		[aButton := ScriptActivationButton new.		aButton initializeForPlayer: self uniclassScript:  (self class scripts at: aSelector).		^ aButton openInHand].	(aButton := RectangleMorph new) useRoundedCorners; color: Color yellow.	props := aButton ensuredButtonProperties.	props		target: self;		actionSelector: #runScript:;		arguments: {aSelector};		delayBetweenFirings: 80;		actWhen: #mouseUp;		mouseDownHaloWidth: 8;		wantsRolloverIndicator: true;		mouseOverHaloWidth: 5;		establishEtoyLabelWording.	aButton width: aButton submorphs first width + 20; height: 20.	self currentHand attachMorph: aButton.! !!Player methodsFor: 'costume' stamp: 'sw 12/3/1998 10:05'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume renderedMorph isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume := aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 2/20/98 00:32'!wearCostumeOfName: aName	| classToUse |	classToUse := Smalltalk at: (aName, 'Morph') asSymbol ifAbsent: 		[Smalltalk at: aName asSymbol].	self wearCostumeOfClass: classToUse! !!Player methodsFor: 'customevents-costume' stamp: 'nk 9/24/2003 17:33'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds := costume bounds.		(costume ownerThatIsA: HandMorph orA: PasteUpMorph) replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorStateOrNil.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume := aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'customevents-misc' stamp: 'nk 9/24/2003 18:26'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors viewerFlaps |	viewers := OrderedCollection new.	viewerFlaps := OrderedCollection new.	scriptors := OrderedCollection new.	aWorld allMorphs do:		[:m | m isAViewer ifTrue: [viewers add: m].			((m isKindOf: ViewerFlapTab) and: [m scriptedPlayer == self])				ifTrue:					[viewerFlaps add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	aMorph  removeAllEventTriggersFor: self.	aWorld removeAllEventTriggersFor: self.	viewers do: [:v |  v noteDeletionOf: aMorph].	viewerFlaps do: [:v  | v dismissViaHalo].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'customevents-scripts-kernel' stamp: 'nk 9/24/2003 17:36'!instantiatedUserScriptsDo: aBlock	"Evaluate aBlock on behalf of all the instantiated user scripts in the receiver"	| aState aCostume |	((aCostume := self costume) notNil and: [(aState := aCostume actorStateOrNil) notNil]) ifTrue:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'customevents-scripts-kernel' stamp: 'nk 8/18/2004 17:40'!pacifyScript: aSymbol	"Make sure the script represented by the symbol doesn't do damage by lingering in related structures on the morph side"	| aHandler aUserScript |	aUserScript := self class userScriptForPlayer: self selector: aSymbol.	aUserScript ifNil: [self flag: #deferred.  ^ Beeper beep].  	"Maddeningly, without this line here the thing IS nil and the debugger is in a bad state	(the above note dates from 1/12/99 ?!!"	self class allInstancesDo:		[:aPlayer | | itsCostume |		aPlayer actorState instantiatedUserScriptsDictionary removeKey: aSymbol ifAbsent: [].		itsCostume := aPlayer costume renderedMorph.		(aHandler := itsCostume eventHandler) ifNotNil:			[aHandler forgetDispatchesTo: aSymbol].		itsCostume removeEventTrigger: aSymbol ]! !!Player methodsFor: 'error handling' stamp: 'tk 11/21/2000 16:17'!doesNotUnderstand: aMessage 	 | ours |"See it the message is a special setter that has not been defined.  Define it and try again."	ours := false.	(aMessage selector endsWith: 'IncreaseBy:') ifTrue: [ours := true].	(aMessage selector endsWith: 'DecreaseBy:') ifTrue: [ours := true].	(aMessage selector endsWith: 'MultiplyBy:') ifTrue: [ours := true].	ours ifFalse: [^ super doesNotUnderstand: aMessage].	(self addSpecialSetter: aMessage selector) ifFalse: ["not our inst var"		^ super doesNotUnderstand: aMessage].	^ aMessage sentTo: self! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headDown	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headLeft	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs negated @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headRight	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headUp	| radians |	radians := (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs negated) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'misc' stamp: 'nk 8/18/2004 16:43'!adoptScriptsFrom	"Let the user click on another object form which the receiver should obtain scripts and code"	| aMorph |	Sensor waitNoButton.	aMorph := ActiveWorld chooseClickTarget.	aMorph ifNil: [^ Beeper beep].	(((aMorph isSketchMorph) and: [aMorph player belongsToUniClass]) and: [self belongsToUniClass not])		ifTrue:			[costume acquirePlayerSimilarTo: aMorph player]		ifFalse:			[Beeper beep]! !!Player methodsFor: 'misc' stamp: 'sw 7/4/2004 00:20'!arrowDeltaFor: aGetSelector	"Answer the arrowDelta to use in conjunction with a readout for aGetSelector, which will be of the form 'getXXX'"	costume ifNotNil:		[^ costume renderedMorph arrowDeltaFor: aGetSelector].	^ 1		"For the future, possibly:  If we want the SlotInformation for a user-defined slot to be able to specify a standard arrowDelta for that slot, we'd include something like the following... 	| aSlotName slotInfo |	aSlotName := Utilities inherentSelectorForGetter: aGetSelector.	(slotInfo := self slotInfoAt: aSlotName ifAbsent: [nil]) ifNotNil:		[^ slotInfo arrowDelta]."! !!Player methodsFor: 'misc' stamp: 'sw 3/17/2005 00:47'!beNotZero: aNumber	"This is a runtime check if the arg to divide in a script is zero.  If it is, put up a warning message.  Return 0.001 instead of 0.  Note the time.  If fails again within 1 min., don't tell the user again."	aNumber = 0 ifFalse: [^ aNumber].	"normal case"	"We have a problem"	TimeOfError 		ifNil: [TimeOfError := Time totalSeconds]		ifNotNil: [(Time totalSeconds - TimeOfError) > 45 ifTrue: [			TimeOfError := Time totalSeconds.	"in case user interrupt and reenter"			self inform: 'Dividing by zero makes a number toolarge for even a Sorcerer to handle.Please change your script.' translated.			TimeOfError := Time totalSeconds]].	^ 0.001! !!Player methodsFor: 'misc' stamp: 'sw 3/20/2001 12:21'!browseEToyVocabulary	"Open a protocol browser on the receiver, showing its etoy vocabulary"	| littleMe | 	littleMe := self assureUniClass.	(InstanceBrowser new useVocabulary: Vocabulary eToyVocabulary) openOnObject: littleMe  inWorld: ActiveWorld showingSelector: nil! !!Player methodsFor: 'misc' stamp: 'sw 7/4/2004 00:29'!defaultFloatPrecisionFor: aGetSelector	"Answer the float position to use in conjunction with a readout for aGetSelector, which will be of the form 'getXXX'"	| aSlotName slotInfo |	aSlotName := Utilities inherentSelectorForGetter: aGetSelector.	(slotInfo := self slotInfoAt: aSlotName ifAbsent: [nil]) ifNotNil:		[^ slotInfo floatPrecision].	self costume ifNotNil:		[^ self costume renderedMorph defaultFloatPrecisionFor: aGetSelector].	^ 1! !!Player methodsFor: 'misc' stamp: 'ka 3/25/2004 05:25'!grabPlayerIn: aWorld	"Invoked from a Viewer: rip my morph out of its container, wherever that may be, and place it in the hand, being careful to set things up so that if the subsequent drop is rejected, the morph will end up in a visible location on the screen"	| aMorph newPosition |	self costume == aWorld ifTrue: [^ self].	ActiveHand releaseMouseFocus.	(aMorph := self costume) visible: true.	newPosition := ActiveHand position - (aMorph extent // 2).	aMorph isInWorld		ifTrue:			[aMorph goHome.			aMorph formerPosition: aMorph positionInWorld]		ifFalse:			[aMorph formerPosition: aWorld center].	aMorph formerOwner: ActiveWorld.	aMorph position: newPosition.	ActiveHand targetOffset: aMorph position - ActiveHand position.	ActiveHand addMorphBack: aMorph.! !!Player methodsFor: 'misc' stamp: 'nk 6/12/2004 10:01'!impartSketchScripts	"Let the user designate another object to which my scripts and code should be imparted"	| aMorph |	Sensor waitNoButton.	aMorph := ActiveWorld chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph renderedMorph isSketchMorph) ifTrue:		[aMorph acquirePlayerSimilarTo: self]! !!Player methodsFor: 'misc' stamp: 'sw 7/28/2001 01:03'!indicateLocationOnScreen	"Give momentary feedback on screen until mouse button is clicked"	| bds |	bds := self costume boundsInWorld.	5 timesRepeat:		[Display reverse: bds.		(Delay forMilliseconds: 80) wait.		Display reverse: bds.		(Delay forMilliseconds: 200) wait.].	costume changed! !!Player methodsFor: 'misc' stamp: 'sw 10/6/2004 11:17'!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size == 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' translated target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' translated target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' translated target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.' translated.	aMenu add: 'choose limit class...' translated target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.' translated.	aMenu add: 'open standard lexicon' translated target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format' translated.	aMenu add: 'open lexicon with search pane' translated target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: costume selector: #inspect.	aMenu add: 'inspect player' translated target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' translated target: self action: #browsePlayerClass.		aMenu add: 'inspect class' translated target: self class action: #inspect].	aMenu add: 'inspect this Viewer' translated target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' translated target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' translated target: aViewer action: #relaunchViewer.	aMenu add: 'attempt repairs' translated target: ActiveWorld action: #attemptCleanup.	aMenu add: 'view morph directly' translated target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.' translated.	(costume renderedMorph isSketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' translated target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'dgd 4/4/2006 16:25'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver.  If the shift key is held down, put up the alternate menu. The menu omits the 'add a new variable' item when in eToyFriendly mode, as per request from teachers using Squeakland in 2003 once the button for adding a new variable was added to the viewer"	| aMenu aWorld  |	(evt notNil and: [evt shiftPressed] and: [Preferences eToyFriendly not]) ifTrue:[		^ self offerAlternateViewerMenuFor: aViewer event: evt	].	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: self externalName.	aMenu addStayUpItem.	self costume renderedMorph offerCostumeViewerMenu: aMenu.	Preferences eToyFriendly ifFalse: "exclude this from squeakland-like UI "		[aMenu add: 'add a new variable' translated target: self action: #addInstanceVariable.		aMenu balloonTextForLastItem: 'Add a new variable to this object and all of its siblings.  You will be asked to supply a name for it.' translated].	aMenu add: 'add a new script' translated target: aViewer action: #newPermanentScript.	aMenu balloonTextForLastItem: 'Add a new script that will work for this object and all of its siblings' translated.	aMenu addLine.	self hasCostumeThatIsAWorld ifFalse:[		aMenu add: 'grab me' translated target: self selector: #grabPlayerIn: argument: aWorld.		aMenu balloonTextForLastItem: 'This will actually pick up the object this Viewer is looking at, and hand it to you.  Click the (left) button to drop it' translated.	].	aMenu add: 'reveal me' translated target: self selector: #revealPlayerIn: argument: aWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object that this Viewer is looking at, use this item to (try to) make it visible' translated.	aMenu addLine.	aMenu add: 'tile representing me' translated action: #tearOffTileForSelf.	aMenu add: 'add search pane' translated target: aViewer action: #addSearchPane.	Preferences eToyFriendly ifFalse:[		aMenu addLine.		aMenu add: 'more...' translated target: self selector: #offerAlternateViewerMenuFor:event: argumentList: {aViewer. evt}.	].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'misc' stamp: 'sw 10/27/2000 06:38'!ordinalNumber	"Answer a number indicating the relative position of the receiver in its stack, if any, else 1"	| aStack |	^ (aStack := self stack) ifNotNil: [aStack cardIndexOf: self] ifNil: [nil]! !!Player methodsFor: 'misc' stamp: 'sw 7/28/2001 01:05'!revealPlayerIn: aWorld	"Reveal the receiver if at all possible in the world; once it's visible, flash its image for a bit, and leave it with its halo showing"	| aMorph |	(aMorph := self costume) isInWorld ifTrue:		[aMorph goHome.		self indicateLocationOnScreen.		aMorph addHalo.		^ self].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue:  "will have obtained halo already"			[aWorld doOneCycle.			self indicateLocationOnScreen.			^ self]].	"The morph is truly unreachable in this world at present.  So extract it from hyperspace, and place it at center of screen, wearing a halo."	aMorph isWorldMorph ifFalse:		[aWorld addMorphFront: aMorph.		aMorph position: aWorld bounds center.		aMorph addHalo]		! !!Player methodsFor: 'misc' stamp: 'yo 8/15/2005 18:08'!tileReferringToSelf	"answer a tile that refers to the receiver"	| aTile  nn tile |	Preferences universalTiles ifTrue:		[nn := self externalName. 	"name it, if necessary, and put in References"		(References includesKey: nn asSymbol) ifFalse: [			 References at: nn asSymbol put: self].		tile := SyntaxMorph new parseNode: 			(VariableNode new name: nn key: nn code: nil).		tile layoutInset: 1; addMorph: (tile addString: nn special: false).		tile color: (SyntaxMorph translateColor: #variable).		tile extent: tile firstSubmorph extent + (2@2).		^ tile].	aTile := TileMorph new setToReferTo: self.	aTile updateWordingToMatchVocabulary.	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 9/6/2002 13:11'!touchesA: aPrototypicalPlayer	"Answer whether the receiver overlaps any player who wears a Sketch costume and who is of the same class as the prototypicalPlayer and who is wearing the same bitmap, but who is *not that player itself*!!  This is an extreme case of a function highly customized (by Bob Arning) to suit a single, idiosycratic, and narrow demo need of Alan's.  Consult:http://groups.yahoo.com/group/squeak/message/40560"	| envelope trueNeighbor trueGoal trueSelf itsPlayer |	aPrototypicalPlayer ifNil: [^ false].	envelope := costume owner ifNil: [^ false].	trueSelf := costume renderedMorph.	trueGoal := aPrototypicalPlayer costume renderedMorph.	envelope submorphs do: [:each |		trueNeighbor := each renderedMorph.		(trueNeighbor == trueGoal or: [trueNeighbor == trueSelf]) ifFalse:			[(itsPlayer := each player) ifNotNil:				[(itsPlayer overlaps: self) ifTrue:					[(trueGoal appearsToBeSameCostumeAs: trueNeighbor) ifTrue: [^ true]]]]].	^ false! !!Player methodsFor: 'misc' stamp: 'dgd 9/1/2003 14:17'!unusedScriptName	"answer a name of the form 'scriptN', where N is one higher than the highest-numbered similarly-named script"	| highestThus aPair |	highestThus := 0.	self class tileScriptNames do:		[:aName |			aPair := (aName copyWithout: $:) stemAndNumericSuffix.			aPair first = 'script' translated ifTrue: [highestThus := highestThus max: aPair last]].	^ ('script' translated, (highestThus + 1) printString) asSymbol! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:35'!updateAllViewers	"The receiver's structure has changed, so viewers on it and its siblings need to be reconstituted."	| aPresenter |	(aPresenter := self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer]! !!Player methodsFor: 'misc' stamp: 'sw 1/19/2001 15:36'!updateAllViewersAndForceToShow: aCategory	"The receiver's structure has changed, so viewers on it and all its siblings need to be reconstituted."	| aPresenter |	(aPresenter := self costume presenter) ifNil: [^ self].	self allOpenViewersOnReceiverAndSiblings do:		[:aViewer | aPresenter updateViewer: aViewer forceToShow: aCategory]! !!Player methodsFor: 'pen' stamp: 'nk 6/12/2004 10:00'!addPlayerMenuItemsTo: aMenu hand: aHandMorph	"Note that these items are primarily available in another way in an object's Viewer"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	self getPenDown		ifTrue: [subMenu add: 'lift pen' action: #liftPen]		ifFalse: [subMenu add: 'lower pen' action: #lowerPen].	subMenu add: 'choose pen size...' action: #choosePenSize.	subMenu add: 'choose pen color...' action: #choosePenColor:.	aMenu add: 'pen...' subMenu: subMenu.	(costume renderedMorph isSketchMorph) ifTrue:		[self belongsToUniClass			ifFalse: 				[aMenu add: 'adopt scripts from...' target: self action: #adoptScriptsFrom]			ifTrue:				[aMenu add: 'impart scripts to...' target: self action: #impartSketchScripts]]! !!Player methodsFor: 'pen' stamp: 'sw 11/28/2000 09:03'!setPenDown: penDown	"Set the penDown state as indicated, to true or false"	| morph trailMorph tfm |	self actorState setPenDown: penDown.	((morph := self costume) notNil and: [(trailMorph := morph trailMorph) notNil])		ifTrue:		[tfm := morph owner transformFrom: trailMorph.		trailMorph notePenDown: penDown forPlayer: self					at: (tfm localPointToGlobal: morph referencePosition)]! !!Player methodsFor: 'scripting' stamp: 'tk 8/13/2001 09:27'!methodInterfacesForScriptsCategoryIn: aVocabulary	"Answer a list of method interfaces for the category #scripts, as seen in a viewer or other tool.  The vocabulary argument is not presently used."	| myScripts |	myScripts := self class scripts values collect: [:us |		(us isKindOf: UserScript)			ifTrue: [us as: MethodWithInterface]			ifFalse: [us]].	^ {self methodInterfaceForEmptyScript}, myScripts! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any := false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any := true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any := false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any := true]].	^ any! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/4/2005 02:18'!acceptableScriptNameFrom: originalString forScriptCurrentlyNamed: currentName	"Produce an acceptable script name, derived from the current name, for the receiver.  This method will always return a valid script name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix withoutColon currentNumArgs withColon |	withoutColon := originalString copyWithoutAll: {$:. $ }.	(currentName notNil and: [(currentName copyWithout: $:) = withoutColon])		ifTrue:			[^ currentName].  "viz. no change; otherwise, the #respondsTo: check gets in the way"	currentNumArgs := currentName ifNil: [0] ifNotNil: [currentName numArgs].	aString := withoutColon asIdentifier: false.  "get an identifier starting with a lowercase letter"	stemAndSuffix := aString stemAndNumericSuffix.	proscribed := #(self super thisContext costume costumes dependents #true #false size).	stem := stemAndSuffix first.	suffix := stemAndSuffix last.	withoutColon := aString asSymbol.	withColon := (withoutColon, ':') asSymbol.	[(proscribed includes: withoutColon)		or: [self respondsTo: withoutColon]		or: [self respondsTo: withColon]		or:	[Smalltalk includesKey: withoutColon]		or: [Smalltalk includesKey: withColon]]	whileTrue:		[suffix := suffix + 1.		withoutColon := (stem, suffix printString) asSymbol.		withColon := (withoutColon, ':') asSymbol].	^ currentNumArgs = 0		ifTrue:			[withoutColon]		ifFalse:			[withColon]! !!Player methodsFor: 'scripts-kernel' stamp: 'NS 1/28/2004 14:41'!acceptScript: aScriptEditorMorph for: aSelector	"Accept the tile code in the script editor as the code for the given selector.  This branch is only for the classic-tile system, 1997-2001"	| aUniclassScript |	self class compileSilently: aScriptEditorMorph methodString		classified: 'scripts'.	aUniclassScript := self class assuredMethodInterfaceFor: aSelector asSymbol.	aUniclassScript currentScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/8/2000 17:03'!expungeEmptyScripts	"Track down and destroy -- and destroy screen artifacts relating to -- all scripts belonging to the receiver that have no lines of code in them"	| any |	any := false.	self class namedTileScriptSelectors do:		[:aSel |			(self isEmptyTileScript: aSel)				ifTrue:					[any := true.					self removeScriptWithoutUpdatingViewers: aSel]].	any ifTrue: [self updateAllViewersAndForceToShow: #scripts]			! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 9/8/2000 17:04'!expungeEmptyUnRenamedScripts	"Track down and destroy -- and destroy screen artifacts relating to -- all scripts belonging to the receiver that have not been named and that have no lines of code in them"	| any |	any := false.	self class namedTileScriptSelectors do:		[:aSel |			(self isExpendableScript: aSel)				ifTrue:					[any := true.					self removeScriptWithoutUpdatingViewers: aSel]].	any ifTrue:		[self updateAllViewersAndForceToShow: #scripts]			! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/20/2001 02:28'!isEmptyTileScript: aScriptName	"Answer whether the script of the given name is an empty classic tile script.  Presently disused -- formerly it was all too easy to propagate many empty tile scripts but this difficulty has receded considerably with recent changes, so this has no senders other than from an unusual menu item, and will perhaps die soon"	| aUserScript |	Preferences universalTiles ifTrue: [^ false].	aUserScript := self class userScriptForPlayer: self selector: aScriptName.	^ (aUserScript instantiatedScriptEditorForPlayer: self) isEmpty! !!Player methodsFor: 'scripts-kernel' stamp: 'mir 7/12/2004 19:41'!methodInterfaceForEmptyScript	"Answer a MethodInterface representing Andreas's 'emptyScript' feature"	| anInterface |	anInterface := MethodInterface new.	anInterface receiverType: #Player.	anInterface flagAttribute: #scripts.	anInterface		wording: (ScriptingSystem wordingForOperator: #emptyScript);		helpMessage: 'an empty script; drop on desktop to get a new empty script for this object'.	anInterface selector: #emptyScript type: nil setter: nil.	^ anInterface! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 7/17/2002 16:41'!newTextualScriptorFor: aSelector	"Sprout a scriptor for aSelector, opening up in textual mode.  Rather special-purpose, consult my lone sender"	| aMethodWithInterface aScriptEditor |	(self class selectors includes: aSelector) ifTrue: [self error: 'selector already exists'].	aMethodWithInterface := self class permanentUserScriptFor: aSelector player: self.	aScriptEditor := aMethodWithInterface instantiatedScriptEditorForPlayer: self.	aScriptEditor install.	aScriptEditor showSourceInScriptor.	aMethodWithInterface selector numArgs == 0 ifTrue:		[self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aMethodWithInterface selector]].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 5/6/2005 09:49'!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	|  aUserScript anInstantiation aDict |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs == 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer | | itsCostume |					anInstantiation := aPlayer scriptInstantiationForSelector: oldSelector.					anInstantiation ifNotNil: [						newSelector numArgs == 0							ifTrue:								[anInstantiation changeSelectorTo: newSelector].						aDict := aPlayer costume actorState instantiatedUserScriptsDictionary.						itsCostume := aPlayer costume renderedMorph.						itsCostume renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						self currentWorld renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						aDict removeKey: oldSelector.						newSelector numArgs  == 0 ifTrue:							[aDict at: newSelector put: anInstantiation.							anInstantiation assureEventHandlerRepresentsStatus]]]]		ifFalse:			[newSelector numArgs == 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation := aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation ifNotNil: [anInstantiation assureEventHandlerRepresentsStatus]]]].	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/17/2001 01:05'!scriptEditorFor: aSelector	"Answer the receiver's script editor for aSelector"	| aScriptEditor |	aScriptEditor := (self class userScriptForPlayer: self selector: aSelector) instantiatedScriptEditorForPlayer: self.	aScriptEditor updateToPlayer: self.	aScriptEditor bringUpToDate.	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'yo 5/6/2005 09:47'!scriptInstantiationForSelector: aSelector	"Answer a script instantiation for the given selector, creating it at this time if necessary"	|  entry scriptDict classEntry actorState |	actorState := self actorState.	actorState ifNil: [^ nil].	scriptDict := actorState instantiatedUserScriptsDictionary.	entry := scriptDict at: aSelector ifAbsent: [nil].	entry ifNil:		[classEntry := self class userScriptForPlayer: self selector: aSelector.		entry := ScriptInstantiation new player: self selector: aSelector status: classEntry defaultStatus.		scriptDict at: aSelector put: entry].	^ entry! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 1/19/2001 15:15'!scriptorsForSelector: aSelector inWorld: aWorld	"Answer, for the purpose of deletion, a list of all scriptor objects for the given selector that are associated with any member of the receiver's uniclass"	| scriptors |	aWorld ifNil: [^ OrderedCollection new].	scriptors := (aWorld allMorphs select:		[:m | (((m isKindOf: ScriptEditorMorph) and: [m playerScripted class == self class]) and: [m scriptName == aSelector])] thenCollect: [:m | m topEditor]) asSet.	^ scriptors asArray! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/3/2005 14:48'!slotInfoButtonHitFor: aGetterSymbol inViewer: aViewer	"The user made a gesture asking for slot menu for the given getter symbol in a viewer; put up the menu."	| aMenu slotSym aType typeVocab interface selector |	 (#(+ - * /) includes: aGetterSymbol)		ifTrue:			 [^ self inform: aGetterSymbol, ' is used for vector operations'].	slotSym := Utilities inherentSelectorForGetter: aGetterSymbol.	aType := self typeForSlotWithGetter: aGetterSymbol asSymbol.	aMenu := MenuMorph new defaultTarget: self.	interface := aViewer currentVocabulary methodInterfaceAt: aGetterSymbol ifAbsent: [nil].	selector := interface isNil		ifTrue: [slotSym asString]		ifFalse: [interface selector].	aMenu addTitle: (selector, ' (', (aType asString translated), ')').	aType = #Patch ifTrue: [		aMenu add: 'grab morph' translated			target: (self perform: aGetterSymbol)			selector: #grabPatchMorph			argument: #().			aMenu addLine.	].	(typeVocab := Vocabulary vocabularyForType: aType) addWatcherItemsToMenu: aMenu forGetter: aGetterSymbol.	(self slotInfo includesKey: slotSym)		ifTrue:			[aMenu add: 'change value type' translated selector: #chooseSlotTypeFor: argument: aGetterSymbol.			typeVocab addUserSlotItemsTo: aMenu slotSymbol: slotSym.			aMenu add: ('remove "{1}"' translated format: {slotSym}) selector: #removeSlotNamed: argument: slotSym.			aMenu add: ('rename "{1}"' translated format: {slotSym}) selector: #renameSlot: argument: slotSym.			aMenu addLine].	typeVocab addExtraItemsToMenu: aMenu forSlotSymbol: slotSym.  "e.g. Player type adds hand-me-tiles"	aMenu add: 'show categories....' translated target: aViewer selector: #showCategoriesFor: argument: aGetterSymbol.	self addIdiosyncraticMenuItemsTo: aMenu forSlotSymol: slotSym.	aMenu items isEmpty ifTrue:		[aMenu add: 'ok' translated action: #yourself].	aMenu popUpForHand: aViewer primaryHand in: aViewer world! !!Player methodsFor: 'scripts-kernel' stamp: 'mir 7/12/2004 19:36'!tilesToCall: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| resultType cmd argType argTile selfTile aPhrase balloonTextSelector aDocString universal |	self class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := self isUniversalTiles)		ifTrue:			[aPhrase := self universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs == 0			ifTrue:				[aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile := ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(self belongsToUniClass and: [self class includesSelector: cmd])		ifTrue:			[aDocString := (self class userScriptForPlayer: self selector: cmd) documentation.			aDocString				ifNotNil: [aPhrase submorphs second setBalloonText: aDocString]				ifNil: [balloonTextSelector := #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	universal ifFalse:		[selfTile := self tileToRefer.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile.		aPhrase makeAllTilesGreen.		aPhrase justGrabbedFromViewer: false].	^ aPhrase! !!Player methodsFor: 'scripts-kernel' stamp: 'tk 9/29/2001 22:20'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList makeSelfGlobal phrase |	itsSelector := aMethodInterface selector.	argList := OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile := ScriptingSystem tileForArgType: (aType := aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #Player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms := MessageSend receiver: self selector: itsSelector arguments: argList asArray.	"For CardPlayers, use 'self'.  For others, name me, and use my global name."	makeSelfGlobal := self class officialClass ~~ CardPlayer.	phrase := ms asTilesIn: self class globalNames: makeSelfGlobal.	makeSelfGlobal ifFalse: [phrase setProperty: #scriptedPlayer toValue: self].	^ phrase! !!Player methodsFor: 'scripts-standard' stamp: 'sw 9/4/2001 07:42'!assignStatus: newStatus toAllFor: scriptName	"Change the status of my script of the given name to be as specified in me and all of my siblings."	| aWorld |	(self existingScriptInstantiationForSelector: scriptName) ifNotNilDo:		[:scriptInstantiation |				scriptInstantiation status: newStatus.				scriptInstantiation assignStatusToAllSiblings.				^ (aWorld := self costume world) ifNotNil:					[aWorld updateStatusForAllScriptEditors]]! !!Player methodsFor: 'scripts-standard' stamp: 'mir 6/7/2002 17:08'!forward: dist 	"Move forward (viz. in the direction of my heading) by the given amount"	| rho radians delta didStray p aCostume aPlayfield |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	rho := (aCostume asNumber: dist) asFloat.	radians := (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta := (radians cos @ radians sin) * rho.	(aPlayfield := aCostume pasteUpMorph) fenceEnabled ifTrue:		[(aPlayfield bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my playfield, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray := false.			((aCostume left < aPlayfield left and: [delta x < 0]) or:			 [aCostume right > aPlayfield right and: [delta x > 0]]) ifTrue:				[delta := delta x negated @ delta y.				didStray := true].			((aCostume top < aPlayfield top and: [delta y < 0]) or:			 [aCostume bottom > aPlayfield bottom and: [delta y > 0]]) ifTrue:				[delta := delta x @ delta y negated.				didStray := true].			(didStray and: [Preferences fenceSoundEnabled]) ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p := aCostume referencePosition + delta.	aCostume referencePosition: p! !!Player methodsFor: 'scripts-standard' stamp: 'sw 9/7/2000 12:52'!getObtrudes	"Answer whether the receiver's costume obtrudes beyond the bounds of its container"	| aCostume |	(aCostume := self costume) ifNil: [^ false].	^ aCostume obtrudesBeyondContainer! !!Player methodsFor: 'scripts-standard' stamp: 'gk 2/23/2004 20:51'!loadSound: soundName	| snd |	snd := SoundService default soundNamed: soundName.	snd ifNotNil: [self sendMessageToCostume: #loadSound: with: snd].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/29/2005 17:32'!moveToward: aPlayer	"Move a standard amount in the direction of the given player.  If the object has an instance variable named 'speed', the speed of the motion will be governed by that value"	| myPosition itsPosition |	((aPlayer ~~ self) and: [(self overlaps: aPlayer) not]) ifTrue:		[((myPosition := self costume referencePosition) = (itsPosition := aPlayer costume referencePosition))			ifFalse:				[self setHeading: (myPosition bearingToPoint: itsPosition).				self forward: self getSpeed]]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 7/29/2005 17:25'!turnToward: aPlayer	"Turn to face the given player, unless our positions coincide."	|  aCostume myPosition itsPosition |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	aCostume := self costume.	aCostume isWorldMorph ifTrue: [^ self].	(self overlaps: aPlayer) ifFalse:		[((myPosition := aCostume referencePosition) = (itsPosition := aPlayer costume referencePosition))			ifFalse: "avoid division by zero ;-("				[self setHeading: (myPosition bearingToPoint: itsPosition)]]! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!* aNumber	"Treating Players like vectors, return a new Player that is myself scaled by the number"	| new |	new := costume usableSiblingInstance player.	new setX: self getX * aNumber asPoint x.	new setY: self getY * aNumber asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!+ aPlayer	"Treating Players like vectors, add aPlayer to me and return a new Player"	| new |	new := costume usableSiblingInstance player.	new setX: self getX + aPlayer asPoint x.	new setY: self getY + aPlayer asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:46'!- aPlayer	"Treating Players like vectors, subtract aPlayer from me and return a new Player"	| new |	new := costume usableSiblingInstance player.	new setX: self getX - aPlayer asPoint x.	new setY: self getY - aPlayer asPoint y.	^ new! !!Player methodsFor: 'scripts-vector' stamp: 'nk 9/25/2003 11:45'!/ aNumber	"Treating Players like vectors, return a new Player that is myself divided by the number"	| new |	new := costume usableSiblingInstance player.	new setX: self getX / aNumber asPoint x.	new setY: self getY / aNumber asPoint y.	^ new! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/7/2002 13:18'!bookEmbodied	"Answer the book embodied by the receiver's costume; usually this is directly the receiver's costume, but in case it is not, we look up the owner chain for one.  This allows page-number messages to be sent to a *page* of the stack, as Alan is wont to do, and have them still find their way to the right place"	| aMorph |	^ ((aMorph := self costume renderedMorph) isKindOf: BookMorph)		ifTrue:			[aMorph]		ifFalse:			[aMorph ownerThatIsA: BookMorph]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getBaseGraphic	"Answer a form representing the receiver's base graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!getCardNumber	"Answer the current card number"	| aStack |	^ (aStack := self stackEmbodied) cardNumberOf: aStack currentCard! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 18:09'!getCharacterAtCursor	"Answer the value of the text cursor"	| aLoc aTextMorph aString |	aLoc := (aTextMorph := self costume renderedMorph) cursor.	aString := aTextMorph text string.	^ (aString at: aLoc ifAbsent: ['']) asString! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:34'!getColor	"Answer the color of my costume.  If it uses a gradient fill, answer the first color."	| aFillStyle aMorph |	^ (aFillStyle := (aMorph := self costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle colorRamp first value]		ifFalse:			[aMorph color]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostume	"Answer a form representing the receiver's primary graphic.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph imageForm]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getCostumeAtCursor	"Answer the form representing the object at the current cursor.  An earlier wording, disused but may persist in preexisting scripts"	| anObject aMorph |		anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph := anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[anObject imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphic	"Answer a form representing the receiver's primary graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form]		ifFalse:			[aMorph isPlayfieldLike				ifTrue:					[aMorph backgroundForm]				ifFalse:					[aMorph imageForm]]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:00'!getGraphicAtCursor	"Answer the form representing the object at the current cursor"	| anObject aMorph |		anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[ScriptingSystem formAtKey: #Paint]		ifFalse:			[((aMorph := anObject renderedMorph) isSketchMorph)				ifTrue:					[aMorph form]				ifFalse:					[aMorph isPlayfieldLike						ifTrue:							[aMorph backgroundForm]						ifFalse:							[aMorph imageForm]]]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/17/2002 10:50'!getHeadingTheta	"Answer the angle, in degrees, between the positive x-axis and the receiver's heading vector"	| aHeading excess normalized |	aHeading := self getHeadingUnrounded.	excess := aHeading - (aHeading rounded).	normalized := (450 - aHeading) \\ 360.	^ normalized + excess! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getLength	"Answer the length of the object"	| aLength cost |	((cost  := self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedLength].	aLength := cost renderedMorph height.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aLength := aLength * cost scaleFactor].	^ aLength! !!Player methodsFor: 'slot getters/setters' stamp: 'tak 1/26/2005 14:58'!getNewClone	"Answer a new player of the same class as the receiver, with a costume much like mine"	| clone |	clone :=  costume usableSiblingInstance.	costume pasteUpMorph ifNotNilDo: [:parent | parent addMorph: clone].	^ clone player! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/1/2000 10:36'!getNumberAtCursor	"Answer the number borne by the object at my costume's current cursor position"	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor getNumericValue]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/7/2002 13:31'!getPageNumber	"Answer the current page number of my book"	| aBook |	^ (aBook := self bookEmbodied) pageNumberOf: aBook currentPage! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/16/2001 08:32'!getRadialGradientFill	"Geter for costume's useGradientFill"	| aStyle |	^ (aStyle := costume renderedMorph fillStyle) isGradientFill and:		[aStyle isRadialFill]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:12'!getSecondColor	"Getter for costume's second color, if it's using gradient fill; sonst answers white."	| aFillStyle |	^ (aFillStyle := costume renderedMorph fillStyle) isGradientFill		ifTrue:			[aFillStyle  colorRamp last value]		ifFalse:			[Color white]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject := self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 3/10/2004 12:15'!getWidth	"Answer the width of the object"	| aWidth cost |	((cost := self costume) isLineMorph) "annoying special case"		ifTrue:			[^ cost unrotatedWidth].	aWidth := cost renderedMorph width.  "facing upward when unrotated"	cost isRenderer		ifTrue:			[aWidth := aWidth * cost scaleFactor].	^ aWidth! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 7/19/2005 01:49'!setAlpha: alpha	"Set the alpha of the color of my costume."	| adjusted |	adjusted := (alpha max: 0.0) min: 1.0.	^ self setColor: (self getColor alpha: adjusted)! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setBaseGraphic: aGraphic	"Set the base graphic"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph baseGraphic: aGraphic]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setBottom: w	"Set the bottom coordinate (cartesian sense) of the object as requested"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost bottom: cost top + topLeftNow y - w! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 2/17/2003 17:35'!setCharacterAtCursor: aCharOrString	"Insert the given character at my cursor position"	| aLoc aTextMorph aString charToUse |	aLoc := (aTextMorph := self costume renderedMorph) cursor.	charToUse := (aString := aCharOrString asString) size > 0		ifTrue:			[aString first]		ifFalse:			[''].	aTextMorph paragraph replaceFrom: aLoc to: aLoc with: charToUse asString asText displaying: true.	aTextMorph updateFromParagraph  ! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/10/2001 00:27'!setColor: aColor	"Set the color of the graphic as requested"	| aFillStyle aMorph |	(aFillStyle := (aMorph := self costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle firstColor: aColor forMorph: aMorph hand: nil]		ifFalse:			[aMorph color: aColor]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setCostume: aForm	"Set the receiver's graphic as indicated.  An earlier wording, disused but may persist in preexisting scripts."	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			["what to do?"]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:35'!setDistance: aDistance	"Set the object's distance from the origin to be as indicated, preserving its angle."	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost cartesianXY: (Point r: aDistance degrees:  self getTheta)! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 3/15/2005 18:23'!setDropShadow: aValue	"Setter for costume's dropShadow"	| aMorph |	(aMorph := costume renderedMorph) hasDropShadow ~~ aValue ifTrue: [aMorph toggleDropShadow]! !!Player methodsFor: 'slot getters/setters' stamp: 'nk 6/12/2004 10:02'!setGraphic: aForm	"Set the receiver's graphic as indicated"	| aMorph |	^ ((aMorph := costume renderedMorph) isSketchMorph)		ifTrue:			[aMorph form: aForm]		ifFalse:			[aMorph isPlayfieldLike				ifTrue: 					[aMorph backgroundForm: aForm]				ifFalse:					["what to do?"]]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:34'!setHeading: newHeading	"Set the heading as indicated"	| aCostume |	aCostume := self costume.	aCostume isWorldMorph ifTrue: [^ self].	(newHeading closeTo: aCostume heading) ifTrue: [^ self].	aCostume heading: newHeading.	aCostume := self costume. "in case we just got flexed for no apparent reason"	(aCostume isFlexMorph and:[aCostume hasNoScaleOrRotation]) 		ifTrue:	[aCostume removeFlexShell]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setLeft: w	"Set the object's left coordinate as indicated"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost left: cost left - topLeftNow x + w! !!Player methodsFor: 'slot getters/setters' stamp: 'dgd 10/23/2004 14:44'!setLength: aLength	"Set the length of the receiver."	| cost lengthToUse |	self hasCostumeThatIsAWorld ifTrue:[^ self].	((cost := self costume) isLineMorph)		ifTrue:			[^ cost unrotatedLength: aLength].	lengthToUse := cost isRenderer		ifTrue:			[aLength / cost scaleFactor]		ifFalse:			[aLength].	cost renderedMorph height: lengthToUse! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 9/1/2000 10:37'!setNumberAtCursor: aNumber	"Place the given number into the morph residing at my costume's current cursor position"	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor setNumericValue: aNumber]! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/16/2001 08:51'!setRadialGradientFill: aBoolean	"Setter for costume's radialGradientFill"	| aStyle |	(aStyle := costume renderedMorph fillStyle) isGradientFill		ifTrue:			[aStyle isRadialFill ~~ aBoolean ifTrue:				[aStyle radial: aBoolean.				costume renderedMorph changed]]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setRight: w	"Set the right coordinate to the given value"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost right: cost left - topLeftNow x + w! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:33'!setScaleFactor: aNumber	"Set the scale factor to be the given value"	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost scaleFactor: ((aNumber asFloat max: 0.1) min: 10.0)! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 12/9/2001 23:55'!setSecondColor: aColor	"Setter for costume's second color, if it's using gradient fill; if not, does nothing"	| aFillStyle aMorph |	^ (aFillStyle := (aMorph := costume renderedMorph) fillStyle) isGradientFill		ifTrue:			[aFillStyle lastColor: aColor forMorph: aMorph hand: ActiveHand]! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:35'!setTheta: aTheta	"Set the object's position such that its rho is unchanged but the angle between the positive x-axis and the vector connecting the origin and the object's position is as given."	| cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	cost cartesianXY: (Point r: self getDistance degrees: aTheta)! !!Player methodsFor: 'slot getters/setters' stamp: 'yo 3/16/2005 15:32'!setTop: w	"Set the top coordinate as indicated, using cartesian sense"	| topLeftNow cost |	cost := self costume.	cost isWorldMorph ifTrue: [^ self].	topLeftNow := cost cartesianBoundsTopLeft.	^ cost top: cost top + topLeftNow y - w! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume := self costume.	((renderedMorph := aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slot getters/setters' stamp: 'di 9/12/2001 20:49'!setX: val	"Set the x coordinate as indicated"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	^ aCostume x: val! !!Player methodsFor: 'slot getters/setters' stamp: 'di 9/12/2001 20:51'!setY: val	"Set the y coordinate as indicated"	| aCostume |	(aCostume := self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	aCostume owner isHandMorph ifTrue: [^ self].	^ aCostume y: val! !!Player methodsFor: 'slot getters/setters' stamp: 'sw 11/4/2002 19:31'!stackEmbodied	"Answer the stack embodied by the receiver's costume; usually this is directly the receiver's costume, but in case it is not, we look up the owner chain for one.  This allows card-number messages to be sent to a *page* of the stack, as Alan is wont to do, and have them still find their way to the right place"	| aMorph |	^ ((aMorph := self costume renderedMorph) isKindOf: StackMorph)		ifTrue:			[aMorph]		ifFalse:			[aMorph ownerThatIsA: StackMorph]! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/3/2004 23:58'!categories	"Answer a list of categories appropriate to the the receiver and its costumes"	| aList |	(self hasCostumeThatIsAWorld)		ifTrue:	[^ self categoriesForWorld].	aList := OrderedCollection new.	self slotNames notEmpty ifTrue:		[aList add: ScriptingSystem nameForInstanceVariablesCategory].	aList addAll: costume categoriesForViewer.	aList remove: ScriptingSystem nameForScriptsCategory ifAbsent: [].	aList add: ScriptingSystem nameForScriptsCategory after: aList first.	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 3/3/2004 00:00'!categoriesForVocabulary: aVocabulary	"Answer a list of categories appropriate to the receiver and its costumes, in the given Vocabulary"	| aList |	self hasCostumeThatIsAWorld		ifTrue:			[aList := self categoriesForWorld]		ifFalse:			[aList := OrderedCollection new.			self slotNames ifNotEmpty:				[aList add: ScriptingSystem nameForInstanceVariablesCategory].			aList addAll: costume categoriesForViewer].	aVocabulary addCustomCategoriesTo: aList.	aList remove: ScriptingSystem nameForScriptsCategory ifAbsent: [].	aList add: ScriptingSystem nameForScriptsCategory after: aList first.	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'dgd 4/4/2006 16:21'!categoriesForWorld	"Answer the list of categories given that the receiver is the Player representing a World"	| aList |	aList := #(#'color & border' #geometry #'pen trails' playfield collections #'stack navigation') asOrderedCollection.	aList addFirst: ScriptingSystem nameForScriptsCategory.	aList addFirst: ScriptingSystem nameForInstanceVariablesCategory.	aList add: #input.	Preferences eToyFriendly ifFalse:		[aList add: #preferences].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'yo 8/1/2004 02:04'!methodInterfacesForInstanceVariablesCategoryIn: aVocabulary	"Return a collection of methodInterfaces for the instance-variables category.  The vocabulary parameter, at present anyway, is not used."	| aList anInterface itsSlotName |	aList := OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			anInterface := MethodInterface new.			itsSlotName := assoc key.			anInterface				wording: itsSlotName;				helpMessage: 'a variable defined by this object' translated.			anInterface selector: (Utilities getterSelectorFor: itsSlotName) type: assoc value type setter: (Utilities setterSelectorFor: itsSlotName).			anInterface setToRefetch.			aList add: anInterface].	^ aList! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/2005 14:21'!typeForSlotWithGetter: aGetter	"Answer the data type for values of the instance variable of the given name"	| getter inherentSelector |	(#(color:sees: seesColor: touchesA: overlaps: overlapsAny:) includes: aGetter) ifTrue: [^ #Boolean].	(#(+ * - /) includes: aGetter) ifTrue: [^ #Player].  "weird vector stuff"  	"Annoying special cases"	inherentSelector := Utilities inherentSelectorForGetter: aGetter.	(self slotInfo includesKey: inherentSelector) ifTrue: [^ (self slotInfoAt: inherentSelector) type].	getter := (aGetter beginsWith: 'get')		ifTrue:			[aGetter]		ifFalse:			[Utilities getterSelectorFor: aGetter].	^ (Vocabulary eToyVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aGetter]) resultType! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/29/2001 13:57'!typeForSlot: aSlotName	"Answer the data type for values of the instance variable of the given name"	| getter |	(self slotInfo includesKey: aSlotName) ifTrue: [^ (self slotInfoAt: aSlotName) type].	getter := (aSlotName beginsWith: 'get')		ifTrue:			[aSlotName]		ifFalse:			[Utilities getterSelectorFor: aSlotName].	^ (self currentVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aSlotName]) resultType! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/24/2001 14:29'!typeForSlot: aSlotName vocabulary: aVocabulary	"Answer the data type for values of the instance variable of the given name.  Presently has no senders but retained for a while..."	| getter inherentSelector |	inherentSelector := Utilities inherentSelectorForGetter: aSlotName.	(self slotInfo includesKey: inherentSelector) ifTrue: [^ (self slotInfoAt: inherentSelector) type].	getter := (aSlotName beginsWith: 'get')		ifTrue:			[aSlotName]		ifFalse:			[Utilities getterSelectorFor: aSlotName].	^ (aVocabulary methodInterfaceAt: getter ifAbsent: [self error: 'Unknown slot name: ', aSlotName]) resultType! !!Player methodsFor: 'slots-user' stamp: 'yo 9/24/2004 09:09'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it."	| itsName initialValue typeChosen usedNames initialAnswer setterSelector originalString |	usedNames := self class instVarNames.	initialAnswer := Utilities keyLike: ('var' translated, (usedNames size + 1) asString)  satisfying: [:aKey | (usedNames includes: aKey) not].	originalString := FillInTheBlank request: 'name for new variable: ' translated initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^ self].	itsName := ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size == 0 ifTrue: [^ self].		self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileInstVarAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	((self class allSubInstances copyWithout: self) reject: [:e | e isSequentialStub]) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'yo 6/5/2004 18:49'!addInstanceVariable2Named: nameSymbol type: typeChosen value: aValue	"Add an instance variable of the given name and type, and initialize it to have the given value"	| initialValue setterSelector |	self assureUniClass.	self slotInfo at: nameSymbol put: (SlotInformation new initialize type: typeChosen).	initialValue := aValue.	self addInstanceVarNamed: nameSymbol withValue: aValue.	self class compileAccessorsFor: nameSymbol.	setterSelector := Utilities setterSelectorFor: nameSymbol.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: #'instance variables'! !!Player methodsFor: 'slots-user' stamp: 'md 3/1/2006 09:15'!addInstanceVariableNamed: nameSymbol type: typeChosen value: aValue	"Add an instance variable of the given name and type, and initialize it to have the given value"	| initialValue setterSelector |	self assureUniClass.	self slotInfo at: nameSymbol put: (SlotInformation new type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: nameSymbol withValue: aValue.	self class compileAccessorsFor: nameSymbol.	setterSelector := Utilities setterSelectorFor: nameSymbol.	(self class allSubInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'NS 1/28/2004 14:47'!addSpecialSetter: selector	| instVar code |	"For the special setters, fooIncreaseBy:, fooDecreaseBy:, fooMultiplyBy:, add a method that does them." 	self assureUniClass.	instVar := (selector allButLast: 11) asLowercase.  "all three are 11 long!!"	(self respondsTo: ('set', instVar capitalized, ':') asSymbol) ifFalse: [^ false].	code := String streamContents: [:strm |		strm nextPutAll: selector, ' amount'; crtab.		strm nextPutAll: 'self set', instVar capitalized, ': (self get', instVar capitalized; space.		(selector endsWith: 'IncreaseBy:') ifTrue: [strm nextPut: $+].		(selector endsWith: 'DecreaseBy:') ifTrue: [strm nextPut: $-].		(selector endsWith: 'MultiplyBy:') ifTrue: [strm nextPut: $*].		strm nextPutAll: ' amount)'].	self class compileSilently: code classified: 'access' notifying: nil.	^ true! !!Player methodsFor: 'slots-user' stamp: 'sw 1/6/2005 01:32'!allPossibleWatchersFromWorld	"Answer a list of all UpdatingStringMorphs, PlayerReferenceReadouts, ThumbnailMorphs, and  UpdatingReferenceMorphs in the Active world and its hidden book pages, etc., which have me or any of my siblings as targets"	| a |	a := IdentitySet new: 400.	ActiveWorld allMorphsAndBookPagesInto: a.	^ a select: [:e | e isEtoyReadout and: [e target class == self class]]! !!Player methodsFor: 'slots-user' stamp: 'yo 9/20/2004 12:13'!basicRemoveSlotNamed: aSlotName	"The user has requested that an instance variable be removed..."	| aSetter aGetter |	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: 'Sorry, ', aSlotName, ' is inuse in a script.'].	aSetter := Utilities setterSelectorFor: aSlotName.	aGetter := Utilities getterSelectorFor: aSlotName.	((self systemNavigation allCallsOn: aSetter) size > 0 or: [(self systemNavigation allCallsOn: aGetter) size > 0]) ifTrue:		[self inform: 'Caution!!  There may be scripts belonging toother objects that may rely on the presence ofthis variable.  If there are, they may now be broken.You may need to fix them up manually.'].	self class removeInstVarName: aSlotName asString.	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 3/24/2005 01:33'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) startUpWithCaption: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	self updateAllViewers.	"does siblings too"	self changeTypesInWatchersOf: slotName  "does siblings too"! !!Player methodsFor: 'slots-user' stamp: 'sw 4/5/1999 13:55'!chooseUserSlot	| names aMenu result |	(names := self slotNames) size == 1		ifTrue: [^ names first].	aMenu := SelectionMenu selections: names.	result := aMenu startUpWithCaption: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 18:58'!fancyWatcherFor: aGetter	"Anser a labeled readout for viewing a value textuallyi"	| aWatcher aColor aLine itsName aSelector aLabel |	aWatcher := self unlabeledWatcherFor: aGetter.	aColor := Color r: 0.387 g: 0.581 b: 1.0.	aLine := WatcherWrapper newRow.	aLine player: self variableName: (aSelector := Utilities inherentSelectorForGetter: aGetter).	itsName := aWatcher externalName.	aWatcher setNameTo: 'readout'.	aLine addMorphFront: (self tileReferringToSelf				borderWidth: 0; layoutInset: 4@0;				typeColor: aColor; 				color: aColor; bePossessive).	aLabel := StringMorph contents: aSelector translated, ' = ' font: ScriptingSystem fontForTiles.	aLabel setProperty: #watcherLabel toValue: true.	aLine addMorphBack: aLabel.	aLine addMorphBack: aWatcher.	aLine setNameTo: itsName.	^ aLine! !!Player methodsFor: 'slots-user' stamp: 'yo 2/12/2005 20:09'!offerGetterTiles: slotName 	"For a player-type slot, offer to build convenient compound tiles that otherwise would be hard to get"	| typeChoices typeChosen thePlayerThereNow slotChoices slotChosen getterTiles aCategoryViewer playerGetter |	typeChoices := Vocabulary typeChoices.	typeChosen := (SelectionMenu labelList: (typeChoices collect: [:t | t translated]) lines: #() selections: typeChoices) 				startUpWithCaption: ('Choose the TYPEof data to get from{1}''s {2}' translated format: {self externalName. slotName translated}).	typeChosen isEmptyOrNil ifTrue: [^self].	thePlayerThereNow := self perform: (Utilities getterSelectorFor: slotName).	thePlayerThereNow 		ifNil: [thePlayerThereNow := self presenter standardPlayer].	slotChoices := thePlayerThereNow slotNamesOfType: typeChosen.	slotChoices isEmpty 		ifTrue: [^self inform: 'sorry -- no slots of that type' translated].	slotChoices := slotChoices asSortedArray.	slotChosen := (SelectionMenu labelList: (slotChoices collect: [:t | t translated]) selections: slotChoices) 				startUpWithCaption: ('Choose the datumyou want to extract from {1}''s {2}' translated format: {self externalName. slotName translated}).	slotChosen isEmptyOrNil ifTrue: [^self].	"Now we want to tear off tiles of the form		holder's valueAtCursor's foo"	getterTiles := nil.	aCategoryViewer := CategoryViewer new initializeFor: thePlayerThereNow				categoryChoice: 'basic'.	getterTiles := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotChosen)				type: typeChosen.	aCategoryViewer := CategoryViewer new initializeFor: self				categoryChoice: 'basic'.	playerGetter := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotName)				type: #Player.	getterTiles submorphs first acceptDroppingMorph: playerGetter event: nil.	"the pad"	"simulate a drop"	getterTiles makeAllTilesGreen.	getterTiles justGrabbedFromViewer: false.	(getterTiles firstSubmorph)		changeTableLayout;		hResizing: #shrinkWrap;		vResizing: #spaceFill.	ActiveHand attachMorph: getterTiles! !!Player methodsFor: 'slots-user' stamp: 'yo 2/11/2005 15:44'!removeSlotNamed: aSlotName	"The user has requested that an instance variable be removed..."	| aSetter aGetter |	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: ('Sorry, {1} is inuse in a script.' translated format: {aSlotName})].	aSetter := Utilities setterSelectorFor: aSlotName.	aGetter := Utilities getterSelectorFor: aSlotName.	((self systemNavigation allCallsOn: aSetter) size > 0 or: [(self systemNavigation allCallsOn: aGetter) size > 0]) ifTrue:		[self inform: 'Caution!!  There may be scripts belonging toother objects that may rely on the presence ofthis variable.  If there are, they may now be broken.You may need to fix them up manually.' translated].	self class removeInstVarName: aSlotName asString.	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/2004 00:26'!setFloatPrecisionFor: aReadout	"If appropriate, set the floatPrecision for the given watcher readout (an UpdatingStringMorph), whose getter is assumed already to be established."		| precision  |	(precision := self defaultFloatPrecisionFor: aReadout getSelector) ~= 1 ifTrue: [aReadout floatPrecision: precision]! !!Player methodsFor: 'slots-user' stamp: 'sw 7/26/2001 12:01'!slotInfoAt: slotName ifAbsent: aBlock	"If the receiver has a slot of the given name, answer its slot info, else answer nil"	| info |	info := self slotInfo at: slotName ifAbsent: [^ aBlock value].	^ info! !!Player methodsFor: 'slots-user' stamp: 'sw 5/16/2001 18:29'!slotNamesOfType: aType	"Answer a list of potential slot names of the given type in the receiver"	| fullList forViewer gettersToOffer |	fullList := (ScriptingSystem systemSlotNamesOfType: aType),		(self class slotGettersOfType: aType).	forViewer := costume renderedMorph selectorsForViewer select:		[:aSel | aSel beginsWith: 'get'].	gettersToOffer := fullList select: [:anItem | forViewer includes: anItem].	^ gettersToOffer collect:		[:aSel | Utilities inherentSelectorForGetter: aSel]! !!Player methodsFor: 'slots-user' stamp: 'sw 8/12/2004 02:27'!tearOffWatcherFor: aSlotGetter	"Tear off a simple textual watcher for the slot whose getter is provided"	| aWatcher anInterface info isNumeric |	info := self slotInfoForGetter: aSlotGetter.	info		ifNotNil:			[isNumeric := info type == #Number]		ifNil:			[anInterface := Vocabulary eToyVocabulary methodInterfaceAt: aSlotGetter ifAbsent: [nil].			isNumeric := anInterface notNil and: [anInterface resultType == #Number]].	aWatcher := UpdatingStringMorph new.		aWatcher		growable: true;		getSelector: aSlotGetter;		putSelector: (info notNil			ifTrue:				[ScriptingSystem setterSelectorForGetter: aSlotGetter]			ifFalse:				[anInterface companionSetterSelector]);		setNameTo: (info notNil			ifTrue:				[Utilities inherentSelectorForGetter: aSlotGetter]			ifFalse:				[anInterface wording]); 		target: self.	isNumeric		ifFalse:			[aWatcher useStringFormat]		ifTrue:			[self setFloatPrecisionFor: aWatcher].	aWatcher		step;		fitContents;		openInHand! !!Player methodsFor: 'slots-user' stamp: 'sw 1/5/2005 22:17'!unlabeledWatcherFor: aGetter	"Answer an unnlabeled readout for viewing a numeric-valued slot of mine"	| aWatcher info anInterface watcherWording itsType vocab aSetter |	info := self slotInfoForGetter: aGetter.	info ifNotNil:			[itsType := info type.			watcherWording := Utilities inherentSelectorForGetter: aGetter.			aSetter := Utilities setterSelectorFor: watcherWording]		ifNil:			[anInterface :=Vocabulary eToyVocabulary methodInterfaceAt: aGetter ifAbsent: [nil].			anInterface				ifNotNil:					[itsType := anInterface resultType.					aSetter := anInterface companionSetterSelector]				ifNil:					[itsType := #Unknown.					aSetter := nil].			watcherWording := anInterface ifNotNil: [anInterface wording] ifNil: ['*']].	vocab := Vocabulary vocabularyForType: itsType.	aWatcher := vocab updatingTileForTarget: self partName: watcherWording getter: aGetter setter: aSetter.	aWatcher setNameTo: (self externalName, '''s ', watcherWording).	aWatcher minHeight: (vocab wantsArrowsOnTiles ifTrue: [22] ifFalse: [14]).	^ aWatcher! !!Player methodsFor: 'translation' stamp: 'sw 7/25/2005 05:04'!changeTypesInWatchersOf: slotName	"The type of a variable has changed; adjust watchers to that fact."	| aGetter newWatcher |	aGetter := Utilities getterSelectorFor: slotName.	self allPossibleWatchersFromWorld do: [:aWatcher |		(aWatcher getSelector = aGetter) ifTrue:			[(aWatcher ownerThatIsA: WatcherWrapper) ifNotNilDo:				[:aWrapper |					newWatcher := (aWrapper submorphs size = 1)						ifTrue:							[WatcherWrapper new unlabeledForPlayer: self getter: aGetter]						ifFalse:							[WatcherWrapper new fancyForPlayer: self getter: aGetter].					newWatcher position: aWatcher position.					aWrapper owner replaceSubmorph: aWrapper by: newWatcher]]]! !!Player methodsFor: 'translation' stamp: 'sw 1/6/2005 16:34'!renameSlotInWatchersOld: oldName new: newName	"A variable has been renamed; get all relevant extant watchers updated.  All this assumed to be happening in the ActiveWorld"	| wasStepping oldGetter |	oldGetter := Utilities getterSelectorFor: oldName.	self allPossibleWatchersFromWorld do: [:aWatcher |		(aWatcher getSelector = oldGetter) ifTrue:			[(wasStepping := aWatcher isStepping) ifTrue: [aWatcher stopStepping].			aWatcher getSelector: (Utilities getterSelectorFor: newName).			aWatcher putSelector ifNotNil:				[aWatcher putSelector: (Utilities setterSelectorFor: newName)].			((aWatcher isKindOf: UpdatingStringMorph) and: [aWatcher hasStructureOfComplexWatcher]) ifTrue:  "Old style fancy watcher"				[aWatcher owner owner traverseRowTranslateSlotOld: oldName to: newName.				(aWatcher target labelFromWatcher: aWatcher) contents: newName, ' = '].			(aWatcher ownerThatIsA: WatcherWrapper) ifNotNilDo:				[:wrapper | wrapper player: self variableName: newName].			wasStepping ifTrue: [aWatcher startStepping]]]! !!Player methodsFor: 'viewer' stamp: 'sw 5/22/2001 14:56'!elementTypeFor: aStringOrSymbol vocabulary: aVocabulary	"Answer whether aStringOrSymbol is best characterized as a #systemSlot, #systemScript, #userSlot, or #userScript.  This is ancient and odious but too tedious to rip out at this point."	| aSymbol anInterface aSlotName |	aSymbol := aStringOrSymbol asSymbol.	aSlotName := Utilities inherentSelectorForGetter: aSymbol.	(self slotInfo includesKey: aSlotName) ifTrue: [^ #userSlot].	(self class isUniClass and: [self class scripts includesKey: aSymbol]) ifTrue: [^ #userScript].		anInterface := aVocabulary methodInterfaceAt: aSymbol ifAbsent: [nil].	^ anInterface		ifNotNil:			[(anInterface resultType == #unknown)				ifTrue:					[#systemScript]				ifFalse:					[#systemSlot]]		ifNil:			[#systemScript]! !!Player methodsFor: 'viewer' stamp: 'sw 1/28/2001 20:17'!externalName	"Answer an external name for the receiver.  If it has none, supply a backstop name"	| aCostume |	^ (aCostume := self costume) ifNotNil: [aCostume externalName] ifNil: ['an orphaned Player']! !!Player methodsFor: 'viewer' stamp: 'tk 8/3/2001 11:08'!newScriptorAround: aPhrase	"Sprout a scriptor around aPhrase, thus making a new script.  aPhrase may either be a PhraseTileMorph (classic tiles 1997-2001) or a SyntaxMorph (2001 onward)"	| aScriptEditor aUniclassScript tw blk |	aUniclassScript := self class permanentUserScriptFor: self unusedScriptName player: self.	aScriptEditor := aUniclassScript instantiatedScriptEditorForPlayer: self.	Preferences universalTiles ifTrue: [		aScriptEditor install.		"aScriptEditor hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			cellPositioning: #topLeft;			setProperty: #autoFitContents toValue: true."		aScriptEditor insertUniversalTiles.  "Gets an empty SyntaxMorph for a MethodNode"		tw := aScriptEditor findA: TwoWayScrollPane.		aPhrase ifNotNil:			[blk := (tw scroller findA: SyntaxMorph "MethodNode") findA: BlockNode.			blk addMorphFront: aPhrase.			aPhrase accept.		].		SyntaxMorph setSize: nil andMakeResizable: aScriptEditor.	] ifFalse: [		aPhrase 				ifNotNil: [aScriptEditor phrase: aPhrase]	"does an install"				ifNil: [aScriptEditor install]	].	self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aUniclassScript selector].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'viewer' stamp: 'sw 10/30/2000 17:13'!uniqueNameForReference	"Answer a unique name for referring to the receiver"	| itsReferent |	self flag: #deferred.  "The once-and-maybe-future ObjectRepresentativeMorph scheme is for the moment disenfranchised"	"(costume isKindOf: ObjectRepresentativeMorph) ifTrue:		[((itsReferent := costume objectRepresented) isKindOf: Class)			ifTrue:				[^ itsReferent name].		itsReferent == Smalltalk ifTrue: [^ #Smalltalk].		itsReferent == ScriptingSystem ifTrue: [^ #ScriptingSystem]]."	^  super uniqueNameForReference! !!Player methodsFor: 'slot-kedama' stamp: 'yo 2/2/2005 17:47'!addPatchVarNamed: nameSymbol	| f |	f := KedamaPatchMorph newExtent: self costume dimensions.	f assuredPlayer assureUniClass.	f setNameTo: (ActiveWorld unusedMorphNameLike: f innocuousName).	self addInstanceVariable2Named: nameSymbol type: #Patch value: f player.	^ f.! !!Player methodsFor: 'slot-kedama' stamp: 'KR 4/14/2006 15:40'!createSlotForPatch: aPatchMorph	"anEmbeddedMorph has just been added to my costume because of explicit user action.  	Create an instance variable and accessors for it as a Player-valued slot."	| itsName openViewers |	self costume isInWorld ifFalse: [ ^self ].	itsName := aPatchMorph externalName asSymbol.	self slotInfo		at: itsName		put: (SlotInformation new initialize type: #Patch).	self addInstanceVarNamed: itsName withValue: (aPatchMorph assuredPlayer).	self class compileAccessorsFor: itsName.	openViewers := self allOpenViewersOnReceiverAndSiblings.	openViewers isEmpty		ifTrue: [^ self]		ifFalse: [| aPresenter | 			(aPresenter := self costume presenter)				ifNil: [^ self].			openViewers				do: [:aViewer | aPresenter updateViewer: aViewer forceToShow: ScriptingSystem nameForInstanceVariablesCategory]]! !!Player methodsFor: 'slot-kedama' stamp: 'yo 9/13/2005 22:03'!newPatch	| f |	f := KedamaPatchMorph newExtent: self costume renderedMorph dimensions.	f assuredPlayer assureUniClass.	f setNameTo: (ActiveWorld unusedMorphNameLike: f innocuousName).	self createSlotForPatch: f.	self addToPatchDisplayList: f assuredPlayer.	self costume world primaryHand attachMorph: f.	^ f.! !!Player methodsFor: 'slot-kedama' stamp: 'yo 8/18/2005 15:33'!newTurtle	| m |	m := KedamaTurtleMorph new openInWorld.	self costume hasNoTurtleBreed ifTrue: [m color: Color red].	self useTurtle: m player.	m setNameTo: (ActiveWorld unusedMorphNameLike: m innocuousName).	self costume world primaryHand attachMorph: m.	^ m.! !!Player methodsFor: 'slot-kedama' stamp: 'yo 8/10/2004 12:37'!newTurtleSilently	| m |	m := KedamaTurtleMorph new openInWorld.	self useTurtle: m player.	m turtleCount: 0.	m setNameTo: (ActiveWorld unusedMorphNameLike: m innocuousName).	^ m.! !!Player class methodsFor: 'housekeeping' stamp: 'ls 10/10/1999 13:42'!abandonUnnecessaryUniclasses	"Player abandonUnnecessaryUniclasses"	| oldCount oldFree newFree newCount report |	oldCount := self subclasses size - 1.	oldFree := Smalltalk garbageCollect.	self allSubInstances do:		[:aPlayer | aPlayer revertToUnscriptedPlayerIfAppropriate.  		"encourage last one to get garbage-collected"		aPlayer := nil ].	ScriptingSystem spaceReclaimed.	newFree := Smalltalk garbageCollect.	newCount := self subclasses size - 1.	report := 'Before: ', oldCount printString, ' uniclasses, ', oldFreeprintString, ' bytes freeAfter:  ', newCount printString, ' uniclasses, ', newFree printString, 'bytes free'.	Transcript cr; show: 'abandonUnnecessaryUniclasses:'; cr; show: report.	^ report	! !!Player class methodsFor: 'housekeeping' stamp: 'sw 12/15/2004 20:43'!cleanseScripts	"Fix up various known structure errors in the uniclass relating to the scripts dctionary.  Answer the number of fixes made."	| errs ed |	scripts ifNil: [scripts := IdentityDictionary new].	errs := 0.	(scripts includesKey: nil) ifTrue: [errs := errs + 1.  scripts removeKey: nil].	scripts keysAndValuesDo: 		[:sel :uniclassScript |			uniclassScript				ifNil:					[errs := errs + 1.					Transcript cr; show: ' fix type 1, nil scripts key'.					scripts removeKey: sel]				ifNotNil:					[(ed := uniclassScript currentScriptEditor)						ifNil:							[errs := errs + 1.							Transcript cr; show: ' fix type 2, sel = ', sel.							self someInstance removeScriptWithSelector: uniclassScript selector.]						ifNotNil:							[uniclassScript playerClassPerSe								ifNil:									[errs := errs + 1.									Transcript cr; show: ' fix type 3, sel = ', sel.									uniclassScript playerClass: self selector:  sel]								ifNotNil:									[(ed scriptName ~= uniclassScript selector) ifTrue:										[errs := errs + 1.										ed restoreScriptName: sel.										Transcript cr; show: ' fix type 4, sel = ', sel.]]]]].	^ errs! !!Player class methodsFor: 'housekeeping' stamp: 'sw 5/19/2000 16:26'!cleanseSlotInfo	| newInfo |	slotInfo ifNotNil:		[newInfo := IdentityDictionary new.		slotInfo associationsDo:			[:assoc | newInfo at: assoc key asSymbol put: assoc value].		slotInfo := newInfo]! !!Player class methodsFor: 'housekeeping' stamp: 'ar 4/25/2005 13:36'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables referencesto instances of themselves that are housekeepingwise unreachable. Thismethod allows such loops to be garbage collected. This is done in threesteps:	1. Remove user-created subclasses from the 'subclasses' set and fromSmalltalk. Only remove classes whose name begins with 'Player' and whichhave no references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance'ssuperclass is this class. Reset the subclasses set to this set ofclasses, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| oldFree candidatesForRemoval class |	oldFree := Smalltalk garbageCollect.	candidatesForRemoval := self subclasses asOrderedCollection select:		[:aClass | (aClass name beginsWith: 'Player') and: [aClass nameendsWithDigit]].	"Break all system links and then perform garbage collection."	candidatesForRemoval do:		[:c | self removeSubclass: c.  "Break downward subclass pointers."		Smalltalk removeKey: c name ifAbsent: [].  "Break binding of globalname"].	candidatesForRemoval := nil.	Smalltalk garbageCollect.  "Now this should reclaim all unusedsubclasses"	"Now reconstruct system links to subclasses with valid references."	"First restore any global references via associations"	(Association allSubInstances select:			[:assn | (assn key isSymbol)					and: [(assn key beginsWith: 'Player')					and: [assn key endsWithDigit]]])		do: [:assn | class := assn value.			(class isKindOf: self class) ifTrue:				[self addSubclass: class.				Smalltalk add: assn]].	"Then restore any further direct references, creating newassociations."	(Metaclass allInstances select:			[:m | (m soleInstance name beginsWith: 'Player')					and: [m soleInstance name endsWithDigit]])		do: [:m | class := m soleInstance.			((class isKindOf: self class) and: [(Smalltalk includesKey: classname) not]) ifTrue:				[self addSubclass: class.				Smalltalk at: class name put: class]].	SystemOrganization removeMissingClasses.	^ Smalltalk garbageCollect - oldFree! !!Player class methodsFor: 'housekeeping' stamp: 'yo 6/3/2004 13:36'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree := Smalltalk garbageCollect.	candidatesForRemoval := OrderedCollection new.	self allSubclassesWithLevelDo: [:e :l | candidatesForRemoval add: e] startingLevel: 2.	candidatesForRemoval := candidatesForRemoval reverse.	candidatesForRemoval :=		candidatesForRemoval select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval := candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!Player class methodsFor: 'namespace' stamp: 'sw 4/27/1998 23:42'!makeReferenceFor: anObject	| stem otherNames i partName |	stem := anObject class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString, stem allButFirst.	otherNames := self class allInstVarNames.	i := 1.	[otherNames includes: (partName := stem, i printString)]		whileTrue: [i := i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: anObject.  "assumes added as last field"	self compileReferenceAccessorFor: partName.	^ self referenceAccessorSelectorFor: partName! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii := BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className := (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii := ii + 1].	BiggestSubclassNumber := ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'yo 6/2/2004 23:34'!chooseUniqueTurtleClassName	| ii className |	className := self name.	[className last isDigit] whileTrue: [className := className copyFrom: 1 to: className size - 1].	ii := BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className := (className , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii := ii + 1].	BiggestSubclassNumber := ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'sw 6/4/2004 13:56'!typicalInstanceName	"For the purpose of documentation, answer the name of a named instance of the receiver, if possible, else answer the class name"	| known |	known := (self allInstances collect: [:i | i knownName]) detect: [:n | n isEmptyOrNil not] ifNone: [nil].	^ known ifNil: [self name]! !!Player class methodsFor: 'scripts' stamp: 'sw 2/17/2001 03:44'!assuredMethodInterfaceFor: aSelector	"Answer the method interface object for aSelector, creating it if it does not already exist."	| selSym  aMethodInterface |	selSym := aSelector asSymbol.	aMethodInterface := self scripts at: selSym ifAbsent: 		[scripts at: selSym put: (self nascentUserScriptInstance playerClass: self selector: selSym)].		^ aMethodInterface! !!Player class methodsFor: 'scripts' stamp: 'sw 4/9/98 21:55'!jettisonScripts	scripts := IdentityDictionary new! !!Player class methodsFor: 'scripts' stamp: 'sw 12/19/2003 23:28'!namedUnaryTileScriptSelectors	"Answer a list of all the selectors of named unary tile scripts"	| sel |	scripts ifNil: [^ OrderedCollection new].	^ scripts select: [:aScript | ((sel := aScript selector) ~~ nil) and: [sel numArgs == 0]] 		thenCollect: [:aScript | aScript selector]! !!Player class methodsFor: 'scripts' stamp: 'sw 2/18/2001 18:42'!nascentUserScriptInstance	"Answer a new script object of the appropriate class"	| classToUse |	classToUse := Preferences universalTiles		ifTrue:	[MethodWithInterface]		ifFalse:	[UniclassScript].	^ classToUse new! !!Player class methodsFor: 'scripts' stamp: 'sw 2/17/2001 00:59'!permanentUserScriptFor: aSelector player: aPlayer	"Create and answer a suitable script  object for the given player (who will be an instance of the receiver) and selector.  Save that script-interface object in my (i.e. the class's) directory of scripts"	|  entry |	scripts ifNil: [scripts := IdentityDictionary new].	entry := self nascentUserScriptInstance playerClass: aPlayer class selector: aSelector.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 4/20/2001 20:11'!scripts	"Answer the receiver's scripts -- an IdentityDictionary"	scripts		ifNil:			[scripts := IdentityDictionary new]		ifNotNil:			[self cleanseScriptsOfNilKeys].	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:41'!scripts: aDict	"for copying"	scripts := aDict! !!Player class methodsFor: 'scripts' stamp: 'tk 1/22/2001 14:54'!tilesFrom: aString	| code tree syn block phrase |	"Construct SyntaxMorph tiles for the String."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab.		strm nextPutAll: aString].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: self		notifying: nil.	syn := tree asMorphicSyntaxUsing: SyntaxMorph.	block := syn submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == BlockNode] ifFalse: [false]].	phrase := block submorphs detect: [:mm | 		(mm respondsTo: #parseNode) ifTrue: [			mm parseNode class == MessageNode] ifFalse: [false]].	^ phrase! !!Player class methodsFor: 'scripts' stamp: 'sw 3/28/2001 16:18'!userScriptForPlayer: aPlayer selector: aSelector	"Answer the user script for the player (one copy for all instances of the uniclass) and selector"	|  newEntry existingEntry |	scripts ifNil: [scripts := IdentityDictionary new].	existingEntry := scripts at: aSelector ifAbsent: [nil].	"Sorry for all the distasteful isKindOf: and isMemberOf: stuff here, folks; it arises out of concern for preexisting content saved on disk from earlier stages of this architecture.  Someday much of it could be cut loose"	Preferences universalTiles		ifTrue:			[(existingEntry isMemberOf: MethodWithInterface) ifTrue: [^ existingEntry].			newEntry := (existingEntry isKindOf: UniclassScript)				ifTrue:					[existingEntry as: MethodWithInterface] "let go of extra stuff if it was UniclassScript"				ifFalse:					[MethodWithInterface new playerClass: aPlayer class selector: aSelector].			scripts at: aSelector put: newEntry.			^ newEntry]		ifFalse:			[(existingEntry isKindOf: UniclassScript)				ifTrue:					[^ existingEntry]				ifFalse:					[newEntry := UniclassScript new playerClass: self selector: aSelector.					scripts at: aSelector put: newEntry.					existingEntry ifNotNil: "means it is a grandfathered UserScript that needs conversion"						[newEntry convertFromUserScript: existingEntry].					^ newEntry]]! !!Player class methodsFor: 'slots' stamp: 'md 7/23/2006 15:13'!compileInstVarAccessorsFor: varName	"Compile getters and setteres for the given instance variable name"	| nameString |	nameString := varName asString capitalized.	self compileSilently: ('get', nameString, '	^ ', varName)		classified: 'access'.	self compileSilently: ('set', nameString, ': val	', varName, ' := val')		classified: 'access'! !!Player class methodsFor: 'slots' stamp: 'sw 12/17/1998 20:31'!removeInstVarAccessorsFor: varName	| nameString |	nameString := varName asString capitalized.	self removeSelector: ('get', nameString) asSymbol.	self removeSelector: ('set', nameString, ':') asSymbol! !!Player class methodsFor: 'slots' stamp: 'sw 5/25/2001 10:26'!slotGettersOfType: aType	"Answer a list of gettter selectors for slots of mine of the given type"	| aList |	aList := OrderedCollection new.	self slotInfo associationsDo:		[:assoc |			(assoc value type = aType) ifTrue:				[aList add: (Utilities getterSelectorFor: assoc key)]].	^ aList! !!Player class methodsFor: 'slots' stamp: 'sw 4/8/98 11:58'!slotInfo	slotInfo ifNil: [slotInfo := IdentityDictionary new].	^ slotInfo! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:44'!slotInfo: aDict	"for copying"	slotInfo := aDict! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 6/4/2004 15:04'!addMethodReferencesTo: aCollection	"For each extant script in the receiver, add a MethodReference object"	| sel |	self scripts do:		[:aScript |			(sel := aScript selector) ifNotNil:				[aCollection add: (MethodReference new setStandardClass: self methodSymbol: sel)]]! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 10/30/2000 07:04'!baseUniclass	"Answer the uniclass that new instances should be instances of; this protocol allows for individual cards of a background to have their own class"	| curr |	curr := self.	[curr theNonMetaClass superclass name endsWithDigit]		whileTrue:			[curr := curr superclass].	^ curr"CardPlayer100 baseUniclass CardPlayer100X baseUniclass"! !!Player class methodsFor: 'turtles' stamp: 'yo 9/17/2004 08:06'!createSequencialStubSubclass	| instVarString classInstVarString aName aClass |	instVarString := KedamaSequenceExecutionStub instVarNames.	classInstVarString := ''.	aName := self chooseUniqueTurtleClassName.	aClass := self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	aClass copyAllCategoriesUnobtrusivelyFrom: KedamaSequenceExecutionStub.	^ aClass! !!Player class methodsFor: 'turtles' stamp: 'yo 9/14/2004 21:36'!createTurtleSubclass	| instVarString classInstVarString aName aClass |	instVarString := KedamaTurtleVectorPlayer instVarNames.	classInstVarString := ''.	aName := self chooseUniqueTurtleClassName.	aClass := self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	aClass copyAllCategoriesUnobtrusivelyFrom: KedamaTurtleVectorPlayer.	^ aClass! !!PlayerReferenceReadout methodsFor: 'initialization' stamp: 'sw 4/26/1998 02:07'!objectToView: objectOrNil viewSelector: aSelector putSelector: aPutSelector	self objectToView: objectOrNil viewSelector: aSelector.	putSelector := aPutSelector! !!PlayerSurrogate methodsFor: 'accessing' stamp: 'sw 7/28/2004 21:16'!playerRepresented: anObject	"Set the value of playerRepresented"	playerRepresented := anObject.	self rebuildRow.	self setNameTo: anObject costume topRendererOrSelf externalName! !!PlayerSurrogate methodsFor: 'accessing' stamp: 'sw 7/28/2004 22:19'!rebuildRow	"Rebuild the row"	| aThumbnail aTileButton aViewerButton |	self removeAllMorphs.	self layoutInset: 2; cellInset: 3.	self beTransparent.	aThumbnail := ThumbnailForAllPlayersTool new objectToView: playerRepresented viewSelector: #graphicForViewerTab.	aThumbnail setBalloonText: 'Click here to reveal this object' translated.	self addMorphBack: aThumbnail.	aThumbnail on: #mouseUp send: #beRevealedInActiveWorld to: playerRepresented.		"aMenuButton := IconicButton new labelGraphic: Cursor menu.	aMenuButton target: self;		actionSelector: #playerButtonHit;		color: Color transparent;		borderWidth: 0;		shedSelvedge;		actWhen: #buttonDown.	aMenuButton setBalloonText: 'Press here to get a menu'.	self addMorphBack: aMenuButton."	aViewerButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #Viewer).	aViewerButton color: Color transparent; 			actWhen: #buttonUp;			actionSelector: #beViewed; target: playerRepresented;			setBalloonText: 'click here to obtain this object''s Viewer' translated;			color: Color transparent;			borderWidth: 0;			shedSelvedge.	self addMorphBack: aViewerButton.	aTileButton := IconicButton  new borderWidth: 0.	aTileButton labelGraphic: (TileMorph new setToReferTo: playerRepresented) imageForm.	aTileButton color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #tearOffTileForSelf; target: playerRepresented;			setBalloonText: 'click here to obtain a tile that refers to this player.' translated.	self addMorphBack: aTileButton."	aNameMorph := UpdatingStringMorph new		useStringFormat;		target:  playerRepresented;		getSelector: #nameForViewer;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aNameMorph putSelector: #setName:.		aNameMorph setProperty: #okToTextEdit toValue: true.	aNameMorph step.	self addMorphBack: aNameMorph.	aNameMorph setBalloonText: 'Click here to edit the player''s name.'.	"	! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:49'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback.				 shownAsComplemented := true]! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 9/7/1999 08:44'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu := view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self terminateAndInitializeAround: [menu invokeOn: model]].! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'sma 5/28/2000 16:29'!controlActivity 	shownAsComplemented ifNil: [^ self].	shownAsComplemented = self viewHasCursor		ifFalse:			[view ifNotNil: [view toggleMouseOverFeedback]. 			shownAsComplemented := shownAsComplemented not]! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector := aSymbol! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging := aBoolean.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'nk 4/17/2004 19:49'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	((aStringOrDisplayObject isKindOf: Paragraph)	or: [aStringOrDisplayObject isForm])		ifTrue: [label := aStringOrDisplayObject]		ifFalse: [label := aStringOrDisplayObject asParagraph].	self centerLabel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter := aCharacter.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown := aBoolean.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:49'!displayComplemented	"Complement the receiver if it isn't already."	complemented ifFalse: [		complemented := true.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:43'!displayNormal	"Complement the receiver if its mode is 'complemented'."	complemented ifTrue: [		complemented := false.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display				at: label boundingBox topLeft				clippingBox: self insetDisplayBox].	complemented := false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'jm 5/2/1998 15:20'!initialize 	super initialize.	label := nil.	getStateSelector := nil.	actionSelector := nil.	getLabelSelector := nil.	getMenuSelector := nil.	shortcutCharacter := nil.	askBeforeChanging := false.	triggerOnMouseDown := false.	complemented := false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'sw 2/17/2002 05:32'!on: anObject getState: getStateSel action: actionSel getArguments: getArgumentsSel from: argsProvidor label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	argumentsSelector := getArgumentsSel.	argumentsProvider := argsProvidor.	getLabelSelector := labelSel.	getMenuSelector := menuSel! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	getLabelSelector := labelSel.	getMenuSelector := menuSel.! !!PluggableButtonView methodsFor: 'private' stamp: 'nk 4/17/2004 19:49'!centerAlignLabelWith: aPoint	"Align the center of the label with aPoint."	| alignPt |	alignPt := label boundingBox center.	(label isKindOf: Paragraph) ifTrue: 		[alignPt := alignPt + (0@(label textStyle leading))]. 	(label isForm)	  ifTrue: [label offset: 0 @ 0].	label align: alignPt with: aPoint! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:09'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: 		[insetDisplayBox := self computeInsetDisplayBox.		 self centerLabel].	^insetDisplayBox! !!PluggableButtonView class methodsFor: 'example' stamp: 'jm 4/7/98 19:55'!example	"PluggableButtonView example"	| s1 s2 s3 b1 b2 b3 topView |	s1 := Switch new.	s2 := Switch new turnOn.	s3 := Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 := (PluggableButtonView on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 := (PluggableButtonView on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 := (PluggableButtonView on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1 borderWidth: 1.	b2 borderWidth: 1.	b3 borderWidth: 1.	topView := StandardSystemView new		label: 'Switch Test';		addSubView: b1;		addSubView: b2 toRightOf: b1;		addSubView: b3 toRightOf: b2.	topView controller open.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	equalBlock := aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock := aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'dvf 6/10/200019:34'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet := PluggableSet new: self size.	self equalBlock ifNotNil: [aSet equalBlock: self equalBlock fixTemps].	self hashBlock ifNotNil: [aSet hashBlock: self hashBlock fixTemps].	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:35'!postCopyBlocks	hashBlock := hashBlock copy.	equalBlock := equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableDictionary methodsFor: 'private' stamp: 'dvf 6/11/2000 01:33'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect := trueOrFalse! !!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tpr 10/4/2001 22:19'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit := true.	scrollFlag := false.	lastSelection := 0.	[sensor redButtonPressed] whileTrue: 		[selection := view findSelection: (pt := sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag := true.				selection := view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag := true.				selection := view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit := false.				turningOn := (view listSelectionAt: selection) not].			view selection: selection.			(view listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				view listSelectionAt: selection put: turningOn].			lastSelection := selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		view listSelectionAt: selection put: (view listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListControllerOfMany methodsFor: 'scrolling' stamp: 'tk 4/8/98 11:09'!scrollView: anInteger 	"Need to minimize the selections which get recomputed"	| oldLimit |	oldLimit := anInteger > 0		ifTrue: [view firstShown]		ifFalse: [view lastShown].	(view scrollBy: anInteger)		ifTrue: [anInteger > 0  "Highlight selections brought into view"					ifTrue: [view highlightFrom: view firstShown								to: (oldLimit-1 min: view lastShown)]					ifFalse: [view highlightFrom: (oldLimit+1 max: view firstShown)								to: view lastShown].				^ true]		ifFalse: [^ false]! !!PluggableListMorph methodsFor: 'model access' stamp: 'apb 5/23/2007 14:16'!basicKeyPressed: aChar 	| oldSelection nextSelection max milliSeconds slowKeyStroke nextSelectionList nextSelectionText |	nextSelection := oldSelection := self getCurrentSelectionIndex.	max := self maximumSelection.	milliSeconds := Time millisecondClockValue.	slowKeyStroke := milliSeconds - lastKeystrokeTime > 300.	lastKeystrokeTime := milliSeconds.	nextSelectionList := OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: ((oldSelection - 1) max: 0)).	slowKeyStroke		ifTrue: ["forget previous keystrokes and search in following elements"			lastKeystrokes := aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addLast: (self getList at: oldSelection)]]		ifFalse: ["append quick keystrokes but don't move selection if it still matches"			lastKeystrokes := lastKeystrokes , aChar asLowercase asString.			oldSelection > 0 ifTrue: [nextSelectionList addFirst: (self getList at: oldSelection)]].	"Get rid of blanks and style used in some lists"	nextSelectionText := nextSelectionList		detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]		ifNone: [^ self flash "match not found"].	"No change if model is locked"	model okToChange ifFalse: [^ self].	nextSelection := self getList findFirst: [:a | a = nextSelectionText].	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'scrolling' stamp: 'ge 9/6/2006 19:02'!numSelectionsInView	"Answer the scroller's height based on the average number of submorphs."		(scroller submorphCount > 0) ifFalse:[ ^0 ].		"ugly hack, due to code smell.	PluggableListMorph added another level of indirection, 	There is always only one submorph - a LazyListMorph which holds the actual list,	but TransformMorph doesn't know that and we are left with a breach of interface.		see vUnadjustedScrollRange for another bad example."			^scroller numberOfItemsPotentiallyInViewWith: (scroller 												submorphs last getListSize).! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:56'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect := trueOrFalse.! !!PluggableListView methodsFor: 'initialization' stamp: 'di 6/20/2001 09:58'!list: arrayOfStrings	"Set the receivers items to be the given list of strings	The instance variable 'items' holds the original list. The instance variable 'list' is a paragraph constructed from this list."	((items == arrayOfStrings) "fastest" or: [items = arrayOfStrings]) ifTrue: [^ self].	items := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do:					[:item | item == nil ifFalse:						[(item isMemberOf: MethodReference)  "A very specific fix for MVC"							ifTrue: [s nextPut: item asStringOrText]							ifFalse: [s nextPut: item]]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'tk 4/12/1998 08:25'!menu: getMenuSel	getMenuSelector := getMenuSel! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector := getMenuTitleSel! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:55'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector := getListSel.	getSelectionSelector := getSelectionSel.	setSelectionSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	| newIndex |	newIndex := anInteger.	(autoDeselect == nil or: [autoDeselect]) ifTrue:		[getSelectionSelector ifNotNil:			[(model perform: getSelectionSelector) = anInteger ifTrue:				["Click on existing selection deselects"				newIndex := 0]]].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: newIndex].! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst := model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu := model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu := model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:45'!handleKeystroke: aChar	"Answer the menu for this list view."	| args aSpecialKey |	aSpecialKey := aChar asciiValue.	aSpecialKey < 32 ifTrue: [ self specialKeyPressed: aSpecialKey. ^nil ].	keystrokeActionSelector ifNil: [^ nil].	controller controlTerminate.	(args := keystrokeActionSelector numArgs) = 1		ifTrue: [model perform: keystrokeActionSelector with: aChar.				^ controller controlInitialize].	args = 2		ifTrue: [model perform: keystrokeActionSelector with: aChar with: self.				^ controller controlInitialize].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'nk 6/29/2004 14:42'!specialKeyPressed: keyEvent	"Process the up and down arrows in a list pane."     | oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: keyEvent) ifFalse: [ ^ false ].     oldSelection := self getCurrentSelectionIndex.     nextSelection := oldSelection.     max := self maximumSelection.     min := self minimumSelection.     howMany := self numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				"self controller moveMarker"]].		^true			! !!PluggableListView methodsFor: 'updating' stamp: 'BG 1/22/2004 13:15'!verifyContents	| newItems existingSelection anIndex |	"Called on window reactivation to react to possible structural changes.  Update contents if necessary."	newItems := self getList.	((items == newItems) "fastest" or: [items = newItems]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection := list stringAtLineNumber: (selection + (topDelimiter ifNil: [0] ifNotNil: [1])).  "account for cursed ------ row"	self list: newItems.	(newItems size > 0 and: [newItems first isKindOf: Symbol]) ifTrue:		[existingSelection := existingSelection asSymbol].	(anIndex := newItems indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.]		ifNil:			[self changeModelSelection: 0].	selection := 0. " to display the list without selection "	self displayView.	self update: getSelectionSelector.! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:28'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ifNotNil: [		item := (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setSelectionSelector with: item].! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 16:27'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item := model perform: getSelectionSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'sw 12/9/1999 18:07'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList := arrayOfStrings.	isEmpty := arrayOfStrings isEmpty.	"add top and bottom delimiters"	list := ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection := self getCurrentSelectionIndex.	self positionList.! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection := 0.	1 to: self maximumSelection do:		[:i | selection := i.		(self listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tpr 10/4/2001 21:34'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection := i.		(self listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection := 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 20:42'!scrollBy: anInteger	"This is a possible way to intercept what ListOfManyController did to get multiple selections to show.  Feel to replace this."	| ans |	ans := super scrollBy: anInteger."	self displaySelectionBox."	^ ans! !!PluggableListViewOfMany methodsFor: 'initialization' stamp: 'tpr 10/8/2001 20:53'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[selection := anInteger.			self displaySelectionBox]! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock := aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock := aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'dvf 6/10/2000 19:34'!postCopyBlocks	hashBlock := hashBlock copy.	equalBlock := equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock ifNotNil: [hashBlock fixTemps].	equalBlock ifNotNil: [equalBlock fixTemps]! !!PluggableSet methodsFor: 'private' stamp: 'dvf 6/11/2000 00:54'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil(indicating 	  an empty slot) or an element that matches anObject. Answer the index 	  	of that slot or zero if no slot is found. This  method will beoverridden   	in various subclasses that have different interpretations for matching  	elements."	| element start finish |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist: anInteger	artistIndex := anInteger.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artistName	"Answer the name of the currently selected artist, or nil if no artist is selected."	| artistsForCurrentType |	artistsForCurrentType := self artistList.	(artistIndex between: 1 and: artistsForCurrentType size)		ifTrue: [^ artistsForCurrentType at: artistIndex]		ifFalse: [^ nil].! !!PluggableTest methodsFor: 'initialization' stamp: 'jm 5/3/1998 16:20'!initialize	musicTypeList := #('reggae' 'classical' 'early').	artistList := #(		('alpha blondy' 'black uhuru' 'bob marley' 'burning spear')		('bach' 'beethoven' 'josquin' 'morley' 'mozart' 'telemann')		('josquin' 'morley' 'telemann')).	musicTypeIndex := 0.	artistIndex := 0.! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType: anInteger	| oldArtist |	oldArtist := self artistName.	musicTypeIndex := anInteger.  "this changes artists list"	artistIndex := self artistList indexOf: oldArtist.	self changed: #musicType.	self changed: #artistList.! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'dgd 9/21/2003 17:47'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	view hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]]    .! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect := paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet := self visibleAreas.	bottomStrip := paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'transcript' stamp: 'th 9/20/2002 11:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY := self stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY := self stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:23'!visibleAreas	"Transcript dependents last controller visibleAreas"	| visibleAreas rect remnants myTopController |	myTopController := self view topView controller.	visibleAreas := Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | c == myTopController ifTrue: [^ visibleAreas].		rect := c view windowBox.		remnants := OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas := remnants].	^ visibleAreas! !!PluggableTextView methodsFor: 'initialization' stamp: 'sw 10/29/1999 21:02'!initialize 	super initialize.	hasEditingConflicts := false! !!PluggableTextView methodsFor: 'initialization' stamp: 'tk 4/6/98 10:51'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector := getTextSel.	setTextSelector := setTextSel.	getSelectionSelector := getSelectionSel.	getMenuSelector := getMenuSel.	self borderWidth: 1.	self editString: self getText.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu := CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 4/1/98 08:32'!getText 	"Answer the list to be displayed."	| txt |	getTextSelector == nil ifTrue: [^ Text new].	txt := model perform: getTextSelector.	txt == nil ifTrue: [^ Text new].	self hasUnacceptedEdits: false.	"clean now"	^ txt! !!PluggableTextView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasEditingConflicts ifNil: [hasEditingConflicts := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasEditingConflicts: aBoolean	hasEditingConflicts := aBoolean! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	aBoolean ifFalse: [hasEditingConflicts := false]! !!PluggableTileScriptorMorph methodsFor: 'as yet unclassified' stamp: 'tk 9/23/2001 02:27'!syntaxMorph	"Return the SyntaxMorph(MethodNode) that is inside me."	| tm |	^ (tm := self findA: TransformMorph) ifNotNil: [tm findA: SyntaxMorph]! !!PluggableTileScriptorMorph methodsFor: 'event handling' stamp: 'tk 9/23/2001 02:28'!keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keystroke on to my syntaxMorph, and also, if I have an event handler, pass it on to that handler"	| sm |	(sm := self syntaxMorph) ifNotNil: [sm keyStroke: evt].	super keyStroke: evt! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems := 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!PopUpMenu methodsFor: 'accessing' stamp: 'sw 3/12/2002 21:37'!startUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	| saveAlignment result |	Smalltalk isMorphic ifFalse:		[saveAlignment := PopUpMenu alignment.		PopUpMenu leftFlush].	[result := self startUp] ensure:		[Smalltalk isMorphic ifFalse:			[PopUpMenu alignment: saveAlignment]].	^ result! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove := true.	Sensor anyButtonPressed		ifFalse:			[didNotMove := false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos := Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove := false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString findTokens: Character cr asString.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'tlk 5/2/2006 22:22'!startUpWithCaption: captionOrNil icon: aForm at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	| maxHeight |	(ProvideAnswerNotification signal: captionOrNil) ifNotNilDo:		[:answer | ^ selection := answer ifTrue: [1] ifFalse: [2]].		 	maxHeight := Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location			allowKeyboard: aBoolean].	Smalltalk isMorphic		ifTrue:[			selection := Cursor normal showWhile:				[| menuMorph | 				menuMorph := MVCMenuMorph from: self title: nil.				(captionOrNil notNil or:[aForm notNil])					ifTrue:[menuMorph addTitle: captionOrNil icon: aForm].				MenuIcons decorateMenu: menuMorph.				menuMorph					invokeAt: location 					in: ActiveWorld					allowKeyboard: aBoolean].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame := frame align: marker leftCenter with: aPoint + (2@0).	outerFrame := frame.	captionOrNil notNil ifTrue:		[captionText := (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame := captionText boundingBox insetBy: -2.		outerFrame := frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta := outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta := 0 - frame width @ delta y].	frame := frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm := captionText form.		captionBox := captionForm boundingBox expandBy: 4.		captionBox := captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave := Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker := marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea := Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc := frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 4/13/1999 17:42'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt := Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifFalse: [pt := pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker := 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection := marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!scrollIntoView: cursorLoc	| dy |	dy := 0.	cursorLoc y < 2 ifTrue: [dy := font height].	cursorLoc y > (Display height-3) ifTrue: [dy := font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame := frame translateBy: 0@dy.	marker := marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection := (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker := marker translateBy: 0 @ (newSelection - selection * marker height).	selection := newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !!PopUpMenu methodsFor: 'private' stamp: 'BG 8/6/2003 12:34'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset := 4@4.	paraForm := (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm := Form extent: paraForm extent + (borderInset * 2) depth: paraForm depth.      menuForm fill: (0 @ 0 extent: menuForm  extent)                        rule: Form over                        fillColor: Color white.	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame := Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside := frame inside.	marker := inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection := 1.	^ form := menuForm! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 16:21'!labels: aString font: aFont lines: anArray	labelString := aString.	font := aFont.	lineArray := anArray.! !!PopUpMenu methodsFor: 'private' stamp: 'sma 2/5/2000 11:56'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString := 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	frame := marker := form := nil.	"PopUpMenu allSubInstancesDo: [:m | m rescan]"! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 13:08'!initialize  "PopUpMenu initialize"	(MenuStyle := TextStyle default copy)		gridForFont: TextStyle default defaultFontIndex withLead: 0;		centered.	PopUpMenu allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:27'!setMenuFontTo: aFont	"Set the menu font as indicated"	MenuStyle := TextStyle fontArray: { aFont }.	MenuStyle 		gridForFont: 1 withLead: 0;		centered.	self allSubInstancesDo: [:m | m rescan]! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:21'!back	"Go back one element and return it."	self position = 0 ifTrue: [self errorCantGoBack].	self skip: -1.	^ self peek! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 3/27/98 08:44'!nextDelimited: terminator	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."	| out ch |	out := WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next == terminator ifFalse: [self skip: -1].	"absorb initial terminator"	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	| newArray |	newArray := collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:54'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| obj |	0 to: n-1 do:[:i|		(obj := self next) == nil ifTrue:[^aCollection copyFrom: 1 to: startIndex+i-1].		aCollection at: startIndex+i put: obj].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:20'!oldBack	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"	"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)"	self position = 0 ifTrue: [self errorCantGoBack].	self position = 1 ifTrue: [self position: 0.  ^ nil].	self skip: -2.	^ self next! !!PositionableStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| nextObject |	self atEnd ifTrue: [^nil].	nextObject := self next.	position := position - 1.	^nextObject! !!PositionableStream methodsFor: 'accessing' stamp: 'dc 8/1/2007 16:02'!peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element := self oldBack.	self skip: 1.	^ element! !!PositionableStream methodsFor: 'accessing'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position := position - 1.	^false! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 7/18/1999 17:10'!upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	| startPos endMatch result |	startPos := self position.	(self match: aCollection) 		ifTrue: [endMatch := self position.			self position: startPos.			result := self next: endMatch - startPos - aCollection size.			self position: endMatch.			^ result]		ifFalse: [self position: startPos.			^ self upToEnd]! !!PositionableStream methodsFor: 'accessing' stamp: 'BG 2/19/2004 14:06'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream |	newStream := WriteStream on: (collection species new: 100).	[self atEnd] whileFalse: [ newStream nextPut: self next ].	^ newStream contents! !!PositionableStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (collection species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:43'!int16	"Answer the next signed, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	n >= 16r8000 ifTrue: [n := n - 16r10000].	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:44'!int16: anInteger	"Store the given signed, 16-bit integer on this (binary) stream."	| n |	(anInteger < -16r8000) | (anInteger >= 16r8000)		ifTrue: [self error: 'outside 16-bit integer range'].	anInteger < 0		ifTrue: [n := 16r10000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 15:15'!int32	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit >= 128 ifTrue: [n := -16r100000000 + n].  "decode negative 32-bit integer"	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:46'!int32: anInteger	"Store the given signed, 32-bit integer on this (binary) stream."	| n |	(anInteger < -16r80000000) | (anInteger >= 16r80000000)		ifTrue: [self error: 'outside 32-bit integer range'].	anInteger < 0		ifTrue: [n := 16r100000000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 07:35'!string	"Answer the next string from this (binary) stream."	| size |	size := self uint16.	^ (self next: size) asString! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16	"Answer the next unsigned, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 08:07'!uint24	"Answer the next unsigned, 24-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint32	"Answer the next unsigned, 32-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'dc 8/1/2007 16:02'!backChunk	"Answer the contents of the receiver back to the previous terminator character.  Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	[(ch := self oldBack) == nil] whileFalse: 			[ch == terminator 				ifTrue: 					[self peekBack == terminator 						ifTrue: [self oldBack	"skip doubled terminator"]						ifFalse: [^ out contents reversed]].			out nextPut: ch].	^ out contents reversed! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/7/2003 13:04'!basicNextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	self skipSeparators.	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:44'!copyMethodChunkFrom: aStream	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	chunk := aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 10/15/2003 19:02'!copyMethodChunkFrom: aStream at: pos	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	aStream position: pos.	chunk := aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:34'!decodeString: string andRuns: runsRaw	| strm runLength runValues newString index |	strm := ReadStream on: runsRaw from: 1 to: runsRaw size.	(strm peekFor: $( ) ifFalse: [^ nil].	runLength := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runLength add: (Number readFrom: strm)].	runValues := OrderedCollection new.	[strm atEnd not] whileTrue: 		[runValues add: (Number readFrom: strm).		strm next.].	newString := WideString new: string size.	index := 1.	runLength with: runValues do: [:length :leadingChar |		index to: index + length - 1 do: [:pos |			newString at: pos put: (Character leadingChar: leadingChar code: (string at: pos) charCode).		].		index := index + length.	].	^ newString.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 13:36'!decodeStyle: runsObjData version: styleVersion	"Decode the runs array from the ReferenceStream it is stored in."	"Verify that the class mentioned have the same inst vars as we have now"	| structureInfo |	styleVersion = RemoteString currentTextAttVersion ifTrue: [		"Matches our classes, no need for checking"		^ (ReferenceStream on: runsObjData) next].	structureInfo := RemoteString structureAt: styleVersion.	"or nil"		"See SmartRefStream instVarInfo: for dfn"	^ SmartRefStream read: runsObjData withClasses: structureInfo! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'NS 1/28/2004 11:21'!fileInFor: client announcing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title.	Does NOT handle preambles or postscripts specially."	| val chunk |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				[ val := (self peekFor: $!!) ifTrue: [						(Compiler evaluate: self nextChunk for: client logged: false) scanFrom: self					] ifFalse: [						chunk := self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk for: client logged: true ].				] on: InMidstOfFileinNotification				  do: [ :ex | ex resume: true].				self atEnd ifFalse: [ self skipStyleChunk ]].		self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	Smalltalk forgetDoIts.	^ val! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 11:59'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator := $!!.	out := WriteStream on: (String new: 1000).	self skipSeparators.	[(ch := self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ self parseLangTagFor: out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ self parseLangTagFor: out contents.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:13'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek pos |	"Read the plain text"	string := self nextChunk.		"Test for ]style[ tag"	pos := self position.	peek := self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [self position: pos. ^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw := self basicNextChunk.	"style encoding"	strm := ReadStream on: runsRaw from: 1 to: runsRaw size.	runs := RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'sumim 11/20/2003 18:11'!parseLangTagFor: aString	| string peek runsRaw pos |	string := aString.	"Test for ]lang[ tag"	pos := self position.	peek := self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [self position: pos. ^ string].  "no tag"	(self upTo: $[) = ']lang' ifTrue: [		runsRaw := self basicNextChunk.		string := self decodeString: aString andRuns: runsRaw	] ifFalse: [		self position: pos	].	^ string.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:08'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd]		whileFalse:		[(peek := self next) isSeparator			ifFalse: [self position: self position-1. ^ peek]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 12:37'!skipStyleChunk	"Get to the start of the next chunk that is not a style for the previous chunk"	| pos |	pos := self position.	self skipSeparators.	self peek == $] 		ifTrue: [(self upTo: $[) = ']text' 	"old -- no longer needed"				"now positioned past the open bracket"			ifFalse: [self nextChunk]]	"absorb ]style[ and its whole chunk"						ifFalse: [self position: pos]	"leave untouched"! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s := 0.	1 to: 4 do: [:i | s := (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos := int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'jm 4/9/98 21:36'!nextLittleEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes s |	bytes := self next: n.	s := 0.	n to: 1 by: -1 do: [:i | s := (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'di 12/6/1999 10:13'!nextLittleEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes := ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !!PositionableStream methodsFor: 'nonhomogeneous accessing'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s := 0.	1 to: n do: 		[:i | s := (s bitShift: 8) bitOr: self next asInteger].	^ s normalize! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 3/1/2005 06:03'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| length aByteArray |	"read the length in binary mode"	self binary.	length := self next.		"first byte."	length >= 192 ifTrue: [length := length - 192.		1 to: 3 do: [:ii | length := length * 256 + self next]].	aByteArray := ByteArray new: length.	self nextInto: aByteArray.	^aByteArray asString.! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length := self next.		"first byte."	length >= 192 ifTrue: [length := (length - 192) * 256 + self next].	aString := String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length := s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s asByteArray.	^s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWord	"Answer the next two bytes from the receiver as an Integer."	| high low |	high := self next.		high==nil ifTrue: [^false].	low := self next.		low==nil ifTrue: [^false].	^(high asInteger bitShift: 8) + low asInteger! !!PositionableStream methodsFor: 'positioning' stamp: 'tk 3/22/2002 19:33'!backUpTo: subCollection	"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter.""Example:	| strm | strm := ReadStream on: 'zabc abdc'.	strm setToEnd; backUpTo: 'abc'; position "	| pattern startMatch |	pattern := ReadStream on: subCollection reversed.	startMatch := nil.	[pattern atEnd] whileFalse: 		[self position = 0 ifTrue: [^ false].		self skip: -1.		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch-1.						startMatch := nil]].		self skip: -1].	self position: startMatch.	^ true! !!PositionableStream methodsFor: 'positioning' stamp: 'hmm 10/22/1999 21:18'!match: subCollection	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := ReadStream on: subCollection.	startMatch := nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch := self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch := nil]]].	^ true! !!PositionableStream methodsFor: 'positioning' stamp: 'di 2/15/98 14:41'!padTo: nBytes put: aCharacter 	"Pad using the argument, aCharacter, to the next boundary of nBytes characters."	| rem |	rem := nBytes - (self position \\ nBytes).	rem = nBytes ifTrue: [^ 0].	self next: rem put: aCharacter.! !!PositionableStream methodsFor: 'positioning' stamp: 'mir 7/5/2005 08:32'!positionOfSubCollection: subCollection ifAbsent: exceptionBlock	"Return a position such that that element at the new position equals the first element of sub, and the next elements equal the rest of the elements of sub. Begin the search at the current position.	If no such match is found, answer the result of evaluating argument, exceptionBlock."	| pattern startPosition currentPosition |	pattern := ReadStream on: subCollection.	startPosition := self position.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^exceptionBlock value].		self next = pattern next			ifFalse: [				self position: self position-pattern position+1.				pattern reset]].	currentPosition := self position.	self position: startPosition.	^pattern atEnd		ifTrue: [currentPosition + 1 - subCollection size]		ifFalse: [exceptionBlock value]! !!PositionableStream methodsFor: 'positioning' stamp: 'nice 3/10/2008 22:29'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	(anInteger >= 0 and: [anInteger <= readLimit])		ifTrue: [position := anInteger]		ifFalse: [self positionError]! !!PositionableStream methodsFor: 'positioning'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position := 0! !!PositionableStream methodsFor: 'positioning' stamp: 'sw 3/10/98 13:55'!resetContents	"Set the position and limits to 0."	position := 0.	readLimit := 0! !!PositionableStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of the sequence of objects."	position := readLimit! !!PositionableStream methodsFor: 'testing' stamp: 'dc 2/27/2007 16:16'!isEmpty	"Answer whether the receiver's contents has no elements."	"Returns true if both the set of past and future sequence values ofthe receiver are empty. Otherwise returns false"	^ self atEnd and: [position = 0]! !!PositionableStream methodsFor: 'private'!on: aCollection	collection := aCollection.	readLimit := aCollection size.	position := 0.	self reset! !!PositionableStream methodsFor: 'private'!setFrom: newStart to: newStop	position := newStart - 1.	readLimit := newStop! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12'!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13'!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14'!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph: aMorph	associatedMorph := aMorph! !!Presenter methodsFor: 'button creation' stamp: 'sw 3/7/1999 00:52'!addTrashCan	| aPosition aCan |	(aCan := associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan := TrashCanMorph newSticky.	aPosition := associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'intialize' stamp: 'sw 12/13/2004 16:58'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList objectsReferredToByTiles |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNilDo: [:ed |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := (fullList asSet asSortedCollection:			[:a :b | a externalName < b externalName]) asArray! !!Presenter methodsFor: 'misc' stamp: 'sw 8/28/2002 23:07'!drawingJustCompleted: aSketchMorph	"The user just finished drawing.  Now maybe put up a viewer"	| aWorld |	self flushPlayerListCache.  "Because a new drawing already created one, thus obviating #assuredPlayer kicking in with its invalidation"	aWorld := associatedMorph world.	(aWorld hasProperty: #automaticFlapViewing)		ifTrue:			[^ aWorld presenter viewMorph: aSketchMorph].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[self viewMorph: aSketchMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield := aPlayfield! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette := aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 22:02'!systemQueryPhraseWithActionString: anActionString labelled: aLabel	"Answer a SystemQueryPhrase with the given action string and label"	| aTile aPhrase |		aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: anActionString label: aLabel.	aPhrase addMorph: aTile.	aPhrase enforceTileColorPolicy.	^ aPhrase! !!Presenter methodsFor: 'playerList' stamp: 'yo 7/2/2004 19:45'!allKnownScriptSelectors	"Answer a list of all the selectors implemented by any user-scripted objected within the scope of the receiver"	| aSet allUniclasses |	aSet := Set with: ('script' translated , '1') asSymbol.	allUniclasses := (self presenter allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 12/19/2003 23:39'!allKnownUnaryScriptSelectors	"Answer a list of all the unary selectors implemented by any user-scripted objected within the scope of the receiver; include #emptyScript as a bail-out"	| aSet allUniclasses |	aSet := Set with: #emptyScript.	allUniclasses := (self allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedUnaryTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownUnaryScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/2/2004 17:24'!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size == 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList := nil! !!Presenter methodsFor: 'playerList' stamp: 'sw 11/14/2001 00:31'!reinvigorateAllScriptsTool: anAllScriptsTool 	"Rebuild the contents of an All Scripts tool"	| showingOnlyActiveScripts candidateList firstTwo oldList allExtantPlayers newList morphList |	showingOnlyActiveScripts := anAllScriptsTool showingOnlyActiveScripts.	self flushPlayerListCache.	"needed? Probably to pick up on programmatical script-status control only"	firstTwo := {anAllScriptsTool submorphs first.  anAllScriptsTool submorphs second}.	oldList := (anAllScriptsTool submorphs copyFrom: 3 to: anAllScriptsTool submorphs size) collect:		[:aRow |			(aRow findA: UpdatingSimpleButtonMorph) target].	allExtantPlayers := self allExtantPlayers.	anAllScriptsTool showingAllInstances "take all instances of all classes"		ifTrue:			[candidateList := allExtantPlayers]  		ifFalse:  "include only one exemplar per uniclass.  Try to get one that has some qualifying scripts"			[candidateList := Set new.			allExtantPlayers do:				[:aPlayer |					(candidateList detect: [:plyr | plyr isMemberOf:  aPlayer class] ifNone: [nil]) ifNil:						[aPlayer instantiatedUserScriptsDo: [:aScriptInstantiation |							(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) 								ifTrue:									[candidateList add: aPlayer]]]]].	newList := OrderedCollection new.	candidateList do:		[:aPlayer | aPlayer instantiatedUserScriptsDo:			[:aScriptInstantiation |				(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) ifTrue:					[newList add: aScriptInstantiation]]].	oldList asSet = newList asSet		ifFalse:			[anAllScriptsTool removeAllMorphs; addAllMorphs: firstTwo.			morphList := newList collect:				[:aScriptInstantiation |  aScriptInstantiation statusControlRowIn: anAllScriptsTool].			anAllScriptsTool addAllMorphs: morphList.			newList do:				[:aScriptInstantiation | aScriptInstantiation updateAllStatusMorphs]]! !!Presenter methodsFor: 'playerList' stamp: 'sw 7/28/2004 21:00'!reinvigoratePlayersTool: aPlayersTool 	"Rebuild the contents of the Players tool"	| firstTwo oldList newList rowsForPlayers |	firstTwo := {aPlayersTool submorphs first.  aPlayersTool submorphs second}.	oldList := (aPlayersTool submorphs copyFrom: 3 to: aPlayersTool submorphs size) collect:		[:aRow |			aRow playerRepresented].	self flushPlayerListCache.	newList := self allExtantPlayers.	oldList asSet = newList asSet		ifFalse:			[aPlayersTool removeAllMorphs; addAllMorphs: firstTwo.			rowsForPlayers := newList collect:				[:aPlayer |  aPlayer entryForPlayersTool: aPlayersTool].			aPlayersTool addAllMorphs: rowsForPlayers ]! !!Presenter methodsFor: 'playerList' stamp: 'yo 2/10/2005 17:07'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList := self uniclassesAndCounts) ifEmpty:  [^ self inform: 'there are no scripted players' translated].	aString := String streamContents:		[:aStream |			aList do:				[:aPair |					aStream nextPutAll: aPair first name, ' -- ', aPair second printString.					aStream nextPutAll: ' ', (aPair second > 1 ifTrue: ['instances'] ifFalse: ['instance']) translated, ', '.					aStream nextPutAll: 'named' translated.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first typicalInstanceName.					aStream nextPutAll: '''s' translated.					aStream nextPutAll: ' scripts:' translated.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts in this project' translated"self currentWorld presenter reportPlayersAndScripts"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'tk 7/28/2005 04:54'!createStandardPlayer	| aMorph |	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	(standardPlayer := aMorph assuredPlayer) renameTo: 'dot' translated.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'tile support' stamp: 'sw 9/27/2001 17:43'!valueTiles	"Answer some constant-valued tiles.  This dates back to very early etoy work in 1997, and presently has no senders"	| tiles |	tiles := OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #Number)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #Number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'yo 3/30/2005 11:21'!nascentPartsViewerFor: aViewee	"Create a new, naked Viewer object for viewing aViewee.  Give it a vocabulary if either the viewee insists on one or if the project insists on one."	| aViewer aVocab |	(aViewee isKindOf: KedamaExamplerPlayer) ifTrue: [^ KedamaStandardViewer new].	aViewer := StandardViewer new.	(aVocab := aViewee vocabularyDemanded)		ifNotNil:			[aViewer useVocabulary: aVocab]		ifNil:			[(aVocab := associatedMorph currentVocabularyFor: aViewee) ifNotNil:				[aViewer useVocabulary: aVocab]].		"If the viewee does not *demand* a special kind of Viewer, and if the project has not specified a preferred vocabulary, then the system defaults will kick in later"	^ aViewer! !!Presenter methodsFor: 'viewer' stamp: 'yo 4/4/2005 18:22'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight itsVocabulary aCategory categoryInfo restrictedIndex |	aCategory := aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	categoryInfo := aViewer categoryMorphs  asOrderedCollection collect:		[:aMorph | aMorph categoryRestorationInfo].	itsVocabulary := aViewer currentVocabulary.	aCategory ifNotNil: [(categoryInfo includes: aCategorySymbol) ifFalse: [categoryInfo addFirst: aCategorySymbol]].	aPlayer := aViewer scriptedPlayer.	aPosition := aViewer position.	wasSticky := aViewer isSticky.	newViewer := aViewer species new visible: false.	(aViewer isMemberOf: KedamaStandardViewer)		ifTrue: [restrictedIndex := aViewer restrictedIndex].	barHeight := aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: categoryInfo.	(newViewer isMemberOf: KedamaStandardViewer)		ifTrue: [			newViewer providePossibleRestrictedView: 0.			newViewer providePossibleRestrictedView: restrictedIndex].	wasSticky ifTrue: [newViewer beSticky].	oldOwner := aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world ifNotNilDo: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!Presenter methodsFor: 'viewer' stamp: 'nk 9/21/2003 12:53'!viewMorph: aMorph 	| aPlayer openViewers aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown 		ifFalse: 			[((aPalette := aMorph standardPalette) notNil and: [aPalette isInWorld]) 				ifTrue: [^aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	openViewers := aPlayer allOpenViewers.	aViewer := openViewers isEmpty ifFalse: [ openViewers first ] ifTrue: [ self nascentPartsViewer ].	self cacheSpecs: topItem.	"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc := associatedMorph.	"world"	Preferences viewersInFlaps  ifTrue:  [		aViewer owner ifNotNilDo: [ :f | ^f flapTab showFlap; yourself ].		aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.	"force layout"			"associatedMorph addMorph: aViewer."	"why???"			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aFlapTab referent submorphs 				do: [:m | (m isKindOf: Viewer) ifTrue: [m delete]].			aViewer visible: true.			aFlapTab applyThickness: aViewer width + 25.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent addMorph: aViewer beSticky.	"moved"			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			^aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	"force layout"	Preferences automaticViewerPlacement 		ifTrue: 			[aPoint := aMorph bounds right 						@ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight) 						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			"it's already in the world, somewhat coincidentally"			^aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Presenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 13:12'!viewObjectDirectly: anObject	"Open up and return a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	associatedMorph addMorph: (aViewer := self nascentPartsViewerFor: anObject).	flapLoc := associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab := flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].		"Caution: the branch below is historical and has not been used for a long time, though if you set the #viewersInFlaps preference to false you'd hit it.  Not at all recently maintained."	aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint := anObject bounds right @ 			(anObject center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).		aRect := (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	anObject primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Process methodsFor: 'changing process state' stamp: 'ar 10/5/2007 18:01'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock inSema |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		myList := nil.		self primitiveSuspend.	] ifFalse: [		"Since the receiver is not the active process, drop its priority to rock-bottom so that		it doesn't accidentally preempt the process that is trying to terminate it."		priority := 10.		myList ifNotNil: [			myList remove: self ifAbsent: [].			"Figure out if the receiver was terminated while waiting on a Semaphore"			inSema := myList class == Semaphore.			myList := nil].		suspendedContext ifNotNil: [			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(inSema == true and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!ProjectController methodsFor: 'control activity' stamp: 'rbb 2/16/2005 16:24'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index := (UIManager default chooseFrom: #('enter' 'jump to project...') lines: #()).	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false revert: false saveForRevert: false].	index = 2 ifTrue: [Project jumpToProject. ^ self].! !!ProjectView methodsFor: 'displaying' stamp: 'tk 4/19/2000 17:15'!armsLengthCommand: aCommand	"Set up a save to be done after the subproject exits to here.  displayOn: checks it."	ArmsLengthCmd := aCommand.! !!ProjectView methodsFor: 'displaying' stamp: 'tk 6/21/2000 16:22'!displayDeEmphasized	| cmd |	"Display this view with emphasis off.  Check for a command thatcould not be executed in my subproject.  Once it is done, remove thetrigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	ArmsLengthCmd first == model ifFalse: [^ self].	"not ours"	cmd := ArmsLengthCmd second.	ArmsLengthCmd := nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectView class methodsFor: 'as yet unclassified'!open: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView controller open! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'RAA 7/25/2000 10:35'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on 	the display screen."	| topView |	topView := self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView world: nil).	ScheduledControllers schedulePassive: topView controller.	aProject		enter: false		revert: false		saveForRevert: false! !!ProjectViewMorph methodsFor: '*eToys-user interface' stamp: 'RAA 7/10/2000 23:30'!eToyStreamedRepresentationNotifying: aWidget	| safeVariant outData |	self flag: #bob.		"probably irrelevant"	safeVariant := self copy.	[ outData := SmartRefStream streamedRepresentationOf: safeVariant ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				aWidget ifNotNil: [aWidget flashIndicator: #working].			].		].	^outData! !!QuotedPrintableMimeConverter methodsFor: 'conversion' stamp: 'bf 11/24/1998 20:33'!mimeDecode	"Do conversion reading from mimeStream writing to dataStream"	| line s c1 v1 c2 v2 |	[(line := mimeStream nextLine) isNil] whileFalse: [		line := line withoutTrailingBlanks.		line size = 0			ifTrue: [dataStream cr]			ifFalse: [				s := ReadStream on: line.				[dataStream nextPutAll: (s upTo: $=).				s atEnd] whileFalse: [					c1 := s next. v1 := c1 digitValue.					((v1 between: 0 and: 15) and: [s atEnd not])						ifFalse: [dataStream nextPut: $=; nextPut: c1]						ifTrue: [c2 := s next. v2 := c2 digitValue.							(v2 between: 0 and: 15)								ifFalse: [dataStream nextPut: $=; nextPut: c1; nextPut: c2]								ifTrue: [dataStream nextPut: (Character value: v1 * 16 + v2)]]].				line last = $= ifFalse: [dataStream cr]]].	^ dataStream! !!RFC2047MimeConverter methodsFor: 'conversion' stamp: 'bf 3/10/2000 16:06'!mimeEncode	"Do conversion reading from dataStream writing to mimeStream. Break long lines and escape non-7bit chars."	| word pos wasGood isGood max |	true ifTrue: [mimeStream nextPutAll: dataStream upToEnd].	pos := 0.	max := 72.	wasGood := true.	[dataStream atEnd] whileFalse: [		word := self readWord.		isGood := word allSatisfy: [:c | c asciiValue < 128].		wasGood & isGood ifTrue: [			pos + word size < max				ifTrue: [dataStream nextPutAll: word.					pos := pos + word size]				ifFalse: []		]	].	^ mimeStream! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/12/2000 14:36'!isStructuredField: aString	| fName |	fName := aString copyUpTo: $:.	('Resent' sameAs: (fName copyUpTo: $-))		ifTrue: [fName := fName copyFrom: 8 to: fName size].	^#('Sender' 'From' 'Reply-To' 'To' 'cc' 'bcc') anySatisfy: [:each | fName sameAs: each]! !!RFC2047MimeConverter methodsFor: 'private-encoding' stamp: 'bf 3/11/2000 22:30'!readWord	| strm |	strm := WriteStream on: (String new: 20)	dataStream skipSeparators.	[dataStream atEnd] whileFalse: 		[ | c |		c := dataStream next.		strm nextPut: c.		c isSeparator ifTrue: [^ strm contents]].	^ strm contents! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/25/97 13:22'!ascii	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:46'!binary	isBinary := true! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit := readLimit max: position.	newArray := ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte := super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 19:26'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: anInteger.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ls 3/27/2000 22:24'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary := false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection := collection asString.		isBinary := true].! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 6/20/97 19:47'!text	isBinary := false! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 19:27'!upToEnd	"Must override to get class right."	| newArray |	newArray := (isBinary ifTrue: [ByteArray] ifFalse: [ByteString]) new: self size - self position.	^ self nextInto: newArray! !!RandomNumberTile methodsFor: 'accessing' stamp: 'yo 9/16/2004 18:50'!storeCodeOn: aStream indent: tabCount	| phrase player costume |	phrase := self outermostMorphThat: [:m| m isKindOf: PhraseTileMorph].	phrase ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	player := phrase associatedPlayer.	player ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	costume := player costume.	costume ifNil: [^ self basicStoreCodeOn: aStream indent: tabCount].	(player isKindOf: KedamaExamplerPlayer) ifTrue: [		^ self kedamaStoreCodeOn: aStream indent: tabCount actualObject: player costume renderedMorph kedamaWorld].	(costume renderedMorph isMemberOf: KedamaMorph) ifTrue: [		^ self kedamaStoreCodeOn: aStream indent: tabCount actualObject: costume renderedMorph].	^ self basicStoreCodeOn: aStream indent: tabCount.! !!RandomNumberTile methodsFor: 'event handling' stamp: 'RAA 7/31/2001 12:02'!handlesMouseDown: evt	| aPoint |	self inPartsBin ifTrue: [^false].	aPoint := evt cursorPoint.	"This might actually be a suitable test for the superclass, but I'll do it here to minimize the downside"	{upArrow. downArrow. suffixArrow. retractArrow} do: [ :each |		(each notNil and: [each bounds containsPoint: aPoint]) ifTrue: [			^true		]	].	^false		"super handlesMouseDown: evt"! !!RandomNumberTile methodsFor: 'initialization' stamp: 'dgd 9/20/2003 19:11'!initialize	"Initialize the receiver fully, including adding all its relevant submorphs"	| m1 m2 |	super initialize.	self vResizing: #shrinkWrap.	self typeColor: (ScriptingSystem colorForType: #Number).	self addArrows.	m1 := StringMorph contents: 'random' translated font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 := UpdatingStringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 target: self; getSelector: #literal; putSelector: #literal:.	m2 position: m1 topRight.	self addMorphBack: m2.	literal := 180.	self updateLiteralLabel.	self makeAllTilesGreen! !!RandomNumberTile methodsFor: 'initialization' stamp: 'yo 7/2/2004 20:59'!updateWordingToMatchVocabulary	| stringMorph |	stringMorph := submorphs				detect: [:morph | morph class == StringMorph]				ifNone: [^ self].	stringMorph contents: 'random' translated.! !!RandomNumberTile methodsFor: 'player viewer' stamp: 'tk 8/14/2000 23:23'!updateLiteralLabel	| myReadout |	(myReadout := self labelMorph) ifNil: [^ self].	myReadout contents: literal stringForReadout.! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:41'!accept 	"Overridden to allow accept of clean text"	(view setText: paragraph text from: self) ifTrue:		[initialText := paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'ar 8/17/2001 18:03'!value: aValue	(AttemptToWriteReadOnlyGlobal signal: 'Cannot store into read-only bindings') == true ifTrue:[		value := aValue.	].! !!ReadOnlyVariableBinding methodsFor: 'private' stamp: 'ar 8/14/2001 23:11'!privateSetKey: aKey value: aValue	key := aKey.	value := aValue! !!ReadStream methodsFor: 'accessing'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition := position + anInteger  min:  readLimit.	ans := collection copyFrom: position+1 to: endPosition.	position := endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:01'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!ReadStream methodsFor: 'accessing' stamp: 'ar 3/18/2007 03:16'!nextFloat	"Read a floating point value from the receiver. This method is highly optimized for cases	where many floating point values need to be read subsequently. And if this needs to go	even faster, look at the inner loops fetching the characters - moving those into a plugin	would speed things up even more."	| buffer count sign index cc value digit fraction exp startIndex anyDigit digitNeeded |	buffer := collection.	count := readLimit.	index := position+1.	"Skip separators"	index := ByteString findFirstInString: buffer inSet: String noSeparatorMap startingAt: index.	index = 0 ifTrue:[self setToEnd. ^nil].	"check for sign"	digitNeeded := false.	sign := 1. cc := buffer byteAt: index.	cc = 45 "$- asciiValue"		ifTrue:[sign := -1. index := index+1. digitNeeded := true]		ifFalse:[cc =  43 "$+ asciiValue" ifTrue:[index := index+1. digitNeeded := true]].	"Read integer part"	startIndex := index.	value := 0.	[index <= count and:[		digit := (buffer byteAt: index) - 48. "$0 asciiValue"		digit >= 0 and:[digit <= 9]]] whileTrue:[			value := value * 10 + digit.			index := index + 1.	].	anyDigit := index > startIndex.	index > count ifTrue:[		(digitNeeded and:[anyDigit not]) ifTrue:[^self error: 'At least one digit expected'].		self setToEnd. ^value asFloat * sign].	(buffer byteAt: index) = 46 "$. asciiValue" ifTrue:["<integer>.<fraction>"		index := index+1.		startIndex := index.		"NOTE: fraction and exp below can overflow into LargeInteger range. If they do, then things slow down horribly due to the relatively slow LargeInt -> Float conversion. This can be avoided by changing fraction and exp to use floats to begin with (0.0 and 1.0 respectively), however, this will give different results to Float>>readFrom: and it is not clear if that is acceptable here."		fraction := 0. exp := 1.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				fraction := fraction * 10 + digit.				exp := exp * 10.				index := index + 1.		].		value := value + (fraction asFloat / exp asFloat).		anyDigit := anyDigit or:[index > startIndex].	].	value := value asFloat * sign.	"At this point we require at least one digit to avoid allowing:		- . ('0.0' without leading digits)		- e32 ('0e32' without leading digits) 		- .e32 ('0.0e32' without leading digits)	but these are currently allowed:		- .5 (0.5)		- 1. ('1.0')		- 1e32 ('1.0e32')		- 1.e32 ('1.0e32')		- .5e32 ('0.5e32')	"	anyDigit ifFalse:["Check for NaN/Infinity first"		(count - index >= 2 and:[(buffer copyFrom: index to: index+2) = 'NaN'])			ifTrue:[position := index+2. ^Float nan * sign].		(count - index >= 7 and:[(buffer copyFrom: index to: index+7) = 'Infinity'])			ifTrue:[position := index+7. ^Float infinity * sign].		^self error: 'At least one digit expected'	].	index > count ifTrue:[self setToEnd. ^value asFloat].	(buffer byteAt: index) = 101 "$e asciiValue" ifTrue:["<number>e[+|-]<exponent>"		index := index+1. "skip e"		sign := 1. cc := buffer byteAt: index.		cc = 45 "$- asciiValue"			ifTrue:[sign := -1. index := index+1]			ifFalse:[cc = 43 "$+ asciiValue" ifTrue:[index := index+1]].		startIndex := index.		exp := 0. anyDigit := false.		[index <= count and:[			digit := (buffer byteAt: index) - 48. "$0 asciiValue"			digit >= 0 and:[digit <= 9]]] whileTrue:[				exp := exp * 10 + digit.				index := index + 1.		].		index> startIndex ifFalse:[^self error: 'Exponent expected'].		value := value * (10.0 raisedToInteger: exp * sign).	].	position := index-1.	^value! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start := position+1.	end := collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start := position+1.	position := collection size.	^collection copyFrom: start to: position! !!ReadStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection := aCollection.	readLimit :=  lastIndex > (len := collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position := firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:58'!testIsEmpty	| stream |	self assert: self emptyStream isEmpty.		stream := self streamOnArray.	self deny: stream isEmpty.	stream skip: 3.	self deny: stream isEmpty.		stream := self streamOnString.	self deny: stream isEmpty.	stream next;next;next.	self deny: stream isEmpty.	stream setToEnd.	self deny: stream isEmpty.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 14:14'!testUpToAll	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd') = 'ab'.	self assert: (self streamOn: 'abcdefgh' upToAll: 'cd' upToAll: 'gh') = 'ef'.	self assert: (self streamOn: '' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: '') = ''.	self assert: (self streamOn: 'a' upToAll: 'a') = ''.	self assert: (self streamOn: 'a' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: '') = ''.	self assert: (self streamOn: 'ab' upToAll: 'a') = ''.	self assert: (self streamOn: 'ab' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'ab' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'ab' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: '') = ''.	self assert: (self streamOn: 'abc' upToAll: 'a') = ''.	self assert: (self streamOn: 'abc' upToAll: 'b') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'c') = 'ab'.	self assert: (self streamOn: 'abc' upToAll: 'd') = 'abc'.	self assert: (self streamOn: 'abc' upToAll: 'ab') = ''.	self assert: (self streamOn: 'abc' upToAll: 'bc') = 'a'.	self assert: (self streamOn: 'abc' upToAll: 'cd') = 'abc'.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 14:14'!testPositionOfSubCollection		self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'q' ) = 0.	self assert: ((self streamOn: 'xyz')  positionOfSubCollection: 'x' ) = 1.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'y' ) = 2.	self assert: ((self streamOn: 'xyz') positionOfSubCollection: 'z' ) = 3.! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!emptyStream	^ ReadStream on: String new.! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnArray	^ ReadStream on: (Array with: 1 with: #(a b c) with: false).! !!ReadStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/27/2007 16:58'!streamOnString	^ ReadStream on: 'abcde'.! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:58'!streamOn: collection upToAll: subcollection	^ (self streamOn: collection) upToAll: subcollection! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 2/28/2007 14:14'!streamOn: collection upToAll: subcollection1 upToAll: subcollection2	^(self streamOn: collection)		upToAll: subcollection1;		upToAll: subcollection2! !!ReadStreamTest methodsFor: 'accessing' stamp: 'dc 3/7/2007 13:48'!classUnderTest	^ ReadStream! !!ReadStreamTest commentStamp: 'tlk 12/5/2004 14:36' prior: 0!I am an SUnit test for ReadStream.I have no test fixtures.!!ReadWriteStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	readLimit := readLimit max: position.	^collection copyFrom: 1 to: readLimit! !!ReadWriteStream methodsFor: 'accessing'!next	"Primitive. Return the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	"treat me as a FIFO"	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position := position + 1)]! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ar 8/5/2003 02:23'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	readLimit := readLimit max: position.	endPosition := position + anInteger  min:  readLimit.	ans := collection copyFrom: position+1 to: endPosition.	position := endPosition.	^ans! !!ReadWriteStream methodsFor: 'converting' stamp: 'yo 7/16/2003 14:59'!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm := self binary.	strm isZipArchive ifTrue: [		archive := ZipArchive new readFrom: strm.		which := archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm := which contentStream.		archive close].	first := strm next.	isGZip := (strm next * 256 + first) = (GZipConstants gzipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream := (MultiByteBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream := strm].	^ outputStream! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/17/97 16:12'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			refStream := SmartRefStream on: self.			object := refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			object := SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/16/2004 13:45'!fileOutClass: extraClass andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self text.	self header; timeStamp.	extraClass ifNotNil: [		class := extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	self binary.	"Append the object's raw data"	srefStream := SmartRefStream on: self.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'tk 3/13/98 22:25'!fileOutClass: extraClass andObject: theObject blocking: anIdentDict	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically.  Accept a list of objects to map to nil or some other object (blockers).  In addition to teh choices in each class's objectToStoreOnDataStream"	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self header; timeStamp.	extraClass ifNotNil: [		class := extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	"Append the object's raw data"	srefStream := SmartRefStream on: self.	srefStream blockers: anIdentDict.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'testing' stamp: 'nk 8/21/2004 15:47'!isZipArchive	"Determine if this appears to be a valid Zip archive"	| sig |	self binary.	sig := self next: 4.	self position: self position - 4. "rewind"	^ZipArchive validSignatures includes: sig! !!ReadWriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:06'!testIsEmpty	| stream |	stream := ReadWriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.	stream next.	self deny: stream isEmpty.! !!RemoteString methodsFor: 'accessing' stamp: 'ls 9/4/2003 12:37'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile := SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	theFile position > theFile size ifTrue: [		self error: 'RemoteString past end of file' ].	^ theFile nextChunkText! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:36'!testForward"If the bug exist there will be an infinte recursion.""self new testForward""self run: #testForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [self assert: ( t forwardDirection = 0.0 ) ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:34'!testHeading"If the bug exist there will be an infinte recursion.""self new testHeading""self run: #testHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ [self assert: ( t heading = 0.0 ) ] 				ensure: [ t delete ] ]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetForward"If the bug exist there will be an infinte reccursion.""self new testSetForward""self run: #testSetForward"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self 	shouldntTakeLong: [ t forwardDirection: 180.0 . 					self assert: ( t forwardDirection = 0.0 )  ]  ."and without a rendee it should not change things."^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:35'!testSetHeading"If the bug exist there will be an infinte recursion.""self new testSetHeading""self run: #testSetHeading"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ t heading:  180 .					 self assert: ( t heading = 0.0 ) .]  .^true  ! !!RenderBugz methodsFor: 'tests' stamp: 'wiz 5/15/2008 22:33'!testTestTime"This is a control case. Should always pass. If it does not something external to the tests are slowing things down past the 1 millisecond mark.""self new testTestTime""self run: #testTestTime"| t |cases := {t := TransformationMorph new openCenteredInWorld } . self shouldntTakeLong: [ self assert: ( true )  ]  .^true  ! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/15/2008 22:44'!long"return time limit in milliseconds for tests"^4! !!RenderBugz methodsFor: 'utility' stamp: 'wiz 5/14/2008 23:25'!shouldntTakeLong: aBlock"Check for infinite recursion. Test should finish in a reasonable time."^self should:  aBlock  		notTakeMoreThanMilliseconds: self long .! !!RenderBugz commentStamp: 'wiz 5/15/2008 22:58' prior: 0!A RenderBugz is an infinite recursion bug test for TransformationMorphs.In 3.9 (7067) and before, when TransformationMorph has no rendee there are several methods that will infinitely recurse until manually stopped or the image runs out of memory.So far the ones I've caught are the getters and setters for heading and forwardDirection.So there  are tests for them here.Ideally there would be a way to run a test against a stopwatch to catch endless recursion.Found it. Now incorperated. And the tests should be both save to run and cleanup after themselves even when they fail. So far we have not tested the normal cases of rendering working. I will leave that as a separate task for another time. So this is an automatic test when the bugs are fixed and interactive (crash) tests when the bugs are present.Instance VariablesRevision notes. wiz 5/15/2008 22:58When running tests from the TestRunner browser the test would sporadically fail.When they failed a transfomation morph would be left on the screen and not removed by the ensureBlock. So I changed things to fall under MorphicUIBugTests because that had a cleanup mechansizm for left over morphs.I also added one routine to test for time and one parameter to determine the time limit.To my surprise doubling or tripling the time limit still produced sporadic errors when the test is run repeatedly enough ( I am using a 400mz iMac. )  So now the parameter is set to 4. Things will probably fail there if tried long enough. At that point try 5 etc. I am reluctant to make the number larger than necessary. The tighter the test the more you know what is working.I also added a dummy test to check specifically for the timing bug. It fails on the same sporadic basis as the other test went the time parameter is short enough. This lends confidence to the theory that the timing difficulty is coming from outside the test. The sunit runner puts up a progress morph for each test. So the morphic display stuff is busy and probably also the GC.!!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04'!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!RunArray methodsFor: 'accessing' stamp: 'nice 2/14/2007 21:59'!at: index put: aValue 	"Set an element of the RunArray"	| runIndex offsetInRun lastValue runLength runReplacement valueReplacement iStart iStop |	index isInteger		ifFalse: [self errorNonIntegerIndex].	(index >= 1			and: [index <= self size])		ifFalse: [self errorSubscriptBounds: index].	self		at: index		setRunOffsetAndValue: [:run :offset :value | 			runIndex := run.			offsetInRun := offset.			lastValue := value].	aValue = lastValue		ifTrue: [^ aValue].	runLength := runs at: runIndex.	runReplacement := Array				with: offsetInRun				with: 1				with: runLength - offsetInRun - 1.	valueReplacement := Array				with: lastValue				with: aValue				with: lastValue.	iStart := offsetInRun = 0				ifTrue: [2]				ifFalse: [1].	iStop := offsetInRun = (runLength - 1)				ifTrue: [2]				ifFalse: [3].	self		setRuns: (runs copyReplaceFrom: runIndex to: runIndex with: (runReplacement copyFrom: iStart to: iStop))		setValues: (values copyReplaceFrom: runIndex to: runIndex with: (valueReplacement copyFrom: iStart to: iStop)).	self coalesce.	^ aValue! !!RunArray methodsFor: 'accessing'!size	| size |	size := 0.	1 to: runs size do: [:i | size := size + (runs at: i)].	^size! !!RunArray methodsFor: 'accessing' stamp: 'di 11/10/97 13:34'!withStartStopAndValueDo: aBlock	| start stop |	start := 1.	runs with: values do:		[:len : val | stop := start + len - 1.		aBlock value: start value: stop value: val.		start := stop + 1]		! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addFirst: value	"Add value as the first element of the receiver."	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs := {1}, runs.		values := {value}, values]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 20:25'!addLast: value	"Add value as the last element of the receiver."	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs := runs copyWith: 1.		values := values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:47'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex := nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs := runs copyWith: times.		values := values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'tk 1/28/98 09:28'!coalesce	"Try to combine adjacent runs"	| ind |	ind := 2.	[ind > values size] whileFalse: [		(values at: ind-1) = (values at: ind) 			ifFalse: [ind := ind + 1]			ifTrue: ["two are the same, combine them"				values := values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs := runs copyReplaceFrom: ind to: ind with: #().				"self error: 'needed to combine runs' "]].			! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex := nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs := runs copyWith: times.		values := values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ar 10/16/2001 18:48'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex := nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs := runs copyWith: 1.		values := values copyWith: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ar 10/16/2001 18:57'!, aRunArray 	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray."	| new newRuns |	(aRunArray isMemberOf: RunArray)		ifFalse: 			[new := self copy.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copy].	aRunArray runs size = 0 ifTrue: [^self copy].	(values at: values size) ~= (aRunArray values at: 1)		ifTrue: [^RunArray					runs: runs , aRunArray runs					values: values , aRunArray values].	newRuns := runs					copyReplaceFrom: runs size					to: runs size					with: aRunArray runs.	newRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).	^RunArray		runs: newRuns		values: 			(values				copyReplaceFrom: values size				to: values size				with: aRunArray values)! !!RunArray methodsFor: 'copying' stamp: 'ls 10/10/1999 13:15'!copyFrom: start to: stop	| newRuns run1 run2 offset1 offset2 | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:r :o :value1 | run1 := r. offset1:= o.  value1].	self at: stop setRunOffsetAndValue: [:r :o :value2 | run2 := r. offset2:= o. value2].	run1 = run2		ifTrue: 			[newRuns := Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns := runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'enumerating' stamp: 'ar 12/17/2001 00:00'!runsFrom: start to: stop do: aBlock	"Evaluate aBlock with all existing runs in the range from start to stop"	| run value index |	start > stop ifTrue:[^self].	self at: start setRunOffsetAndValue:[:firstRun :offset :firstValue|		run := firstRun.		value := firstValue.		index := start + (runs at: run) - offset.		[aBlock value: value.		index <= stop] whileTrue:[			run := run + 1.			value := values at: run.			index := index + (runs at: run)]].! !!RunArray methodsFor: 'private'!at: index setRunOffsetAndValue: aBlock 	"Supply all run information to aBlock."	"Tolerates index=0 and index=size+1 for copyReplace: "	| run limit offset |	limit := runs size.	(lastIndex == nil or: [index < lastIndex])		ifTrue:  "cache not loaded, or beyond index - start over"			[run := 1.			offset := index-1]		ifFalse:  "cache loaded and before index - start at cache"			[run := lastRun.			offset := lastOffset + (index-lastIndex)].	[run <= limit and: [offset >= (runs at: run)]]		whileTrue: 			[offset := offset - (runs at: run).			run := run + 1].	lastIndex := index.  "Load cache for next access"	lastRun := run.	lastOffset := offset.	run > limit		ifTrue: 			["adjustment for size+1"			run := run - 1.			offset := offset + (runs at: run)].	^aBlock		value: run	"an index into runs and values"		value: offset	"zero-based offset from beginning of this run"		value: (values at: run)	"value for this run"! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values := values collect: [:val | mapBlock value: val]! !!RunArray methodsFor: 'private' stamp: 'ar 10/16/2001 18:47'!setRuns: newRuns setValues: newValues	lastIndex := nil.  "flush access cache"	runs := newRuns asArray.	values := newValues asArray.! !!RunArray class methodsFor: 'instance creation' stamp: 'dc 5/24/2007 10:53'!new: aSize	^ self new: aSize withAll: nil! !!RunArray class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new.	aCollection do: [:x | newCollection addLast: x].	^newCollection"	RunArray newFrom: {1. 2. 2. 3}	{1. $a. $a. 3} as: RunArray	({1. $a. $a. 3} as: RunArray) values"! !!RunArray class methodsFor: 'instance creation'!readFrom: aStream	"Answer an instance of me as described on the stream, aStream."	| size runs values |	size := aStream nextWord.	runs := Array new: size.	values := Array new: size.	1 to: size do:		[:x |		runs at: x put: aStream nextWord.		values at: x put: aStream nextWord].	^ self runs: runs values: values! !!RunArray class methodsFor: 'instance creation'!runs: newRuns values: newValues 	"Answer an instance of me with runs and values specified by the 	arguments."	| instance |	instance := self basicNew.	instance setRuns: newRuns setValues: newValues.	^instance! !!RunArray class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 15:12'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv := OrderedCollection new.	"Value array"	aa := OrderedCollection new.	"Attributes list"	[(this := strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa := OrderedCollection new].		this == $a ifTrue: [aa add: 			(TextAlignment new alignment: (Integer readFrom: strm))].		this == $f ifTrue: [aa add: 			(TextFontChange new fontNumber: (Integer readFrom: strm))].		this == $F ifTrue: [aa add: (TextFontReference toFont: 			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm)))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)].		this == $p ifTrue: [aa add: (TextSqkProjectLink scanFrom: strm)].		this == $P ifTrue: [aa add: (TextPrintIt scanFrom: strm)].		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:22'!testNew	"self debug: #testNew"	| array |	array := RunArray new.	self assert: array size = 0.! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:24'!testNewFrom	"self debug: #testNewFrom"	| array |	array := RunArray newFrom: #($a $b $b $b $b $c $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:15'!testNewWithAll	"self debug: #testNewWithAll"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array size = 5.	self assert: array = #(2 2 2 2 2)! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 5/24/2007 10:56'!testNewWithSize	|array|	array := RunArray new: 5.	self assert: array size = 5.	1 to: 5 do: [:index | self assert: (array at: index) isNil]! !!RunArrayTest methodsFor: 'tests - instance creation' stamp: 'dc 2/12/2007 09:30'!testRunsValues	"self debug: #testRunsValues"	| array |	array := RunArray runs: #(1 4 2 1) values: #($a $b $c $a).	self assert: array size = 8.	self assert: array = #($a $b $b $b $b $c $c $a).! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:25'!testAt	"self debug: #testAt"	| array |	array := RunArray new: 5 withAll: 2.	self assert: (array at: 3) = 2.		array at: 3 put: 5.	self assert: (array at: 3) = 5! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:26'!testAtPut	"self debug: #testAtPut"	| array |	array := RunArray new: 5 withAll: 2.		array at: 3 put: 5.	self assert: array = #(2 2 5 2 2).		array at: 1 put: 1.	self assert: array = #(1 2 5 2 2).! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/15/2007 10:29'!testAtPut2	"self debug: #testAtPut2"	| array |	array := RunArray new: 5 withAll: 2.		self should: [array at: 0 put: 5] raise: Error.	self should: [array at: 6 put: 5] raise: Error.	self should: [array at: $b put: 5] raise: Error.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testFirst	"self debug: #testFirst"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array first = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array first = $a.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:49'!testLast	"self debug: #testLast"	| array |	array := RunArray new: 5 withAll: 2.	self assert: array last = 2.		array := #($a $b $c $d) as: RunArray.	self assert: array last = $d.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 09:58'!testRunLengthAt	"self debug: #testRunLengthAt"	| array |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	self assert: (array runLengthAt: 1) = 1.	self assert: (array runLengthAt: 2) = 2.	self assert: (array runLengthAt: 3) = 1.	self assert: (array runLengthAt: 4) = 3.	self assert: (array runLengthAt: 5) = 2.	self assert: (array runLengthAt: 6) = 1.	self assert: (array runLengthAt: 7) = 2.	self assert: (array runLengthAt: 8) = 1.! !!RunArrayTest methodsFor: 'tests - accessing' stamp: 'dc 2/12/2007 10:12'!testWithStartStopAndValueDo	"self debug: #testWithStartStopAndValueDo"	| array elements startStops |	array := #($a $b $b $c $c $c $d $d) as: RunArray.	elements := OrderedCollection new.	startStops := OrderedCollection new.	array withStartStopAndValueDo: [:start :stop :value | elements add: value. startStops add: start->stop].		self assert: elements asArray = #($a $b  $c  $d).	self assert: startStops asArray = {1->1 . 2->3 . 4->6 . 7->8}! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!basicNewChangeSet: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs basicNewChangeSet: newName ].	(self changeSetNamed: newName) ifNotNil: [ self inform: 'Sorry that name is already used'. ^nil ].	^ChangeSet basicNewNamed: newName.! !!SARInstaller class methodsFor: 'change set utilities' stamp: 'pk 10/17/2006 09:42'!changeSetNamed: newName	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/16/2002 00:33'!handleCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 18:26'!handleComment: aString	self saxHandler		checkEOD; 		comment: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:38'!handleEndDocument	self saxHandler endDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePI: piTarget data: piData	self saxHandler		checkEOD; 		processingInstruction: piTarget data: piData! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:29'!handleStartDocument	self saxHandler startDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:35'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/18/2003 01:00'!handleWhitespace: aString	self saxHandler		checkEOD; 		ignorableWhitespace: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:39'!handleXMLDecl: attributes namespaces: namespaces	self saxHandler		checkEOD; 		documentAttributes: attributes.	self usesNamespaces		ifTrue: [			namespaces keysAndValuesDo: [:ns :uri |				self scope declareNamespace: ns uri: uri]]! !!SAXDriver methodsFor: 'initialization' stamp: 'mir 6/5/2003 16:29'!initialize	super initialize.	useNamespaces := false.	validateAttributes := false! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:51'!saxHandler	^saxHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler _ aHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:51'!useNamespaces: aBoolean	useNamespaces := aBoolean! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/24/2003 13:40'!scope	scope ifNil: [scope := XMLNamespaceScope new].	^scope! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i _ aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 16:30'!usesNamespaces	^useNamespaces! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 17:06'!validatesAttributes	^validateAttributes! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:27'!characters: aString	"This call corresponds to the Java SAX call	characters(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:24'!checkEOD	"Check if the document shouldn't be ended already"	self eod		ifTrue: [self driver errorExpected: 'No more data expected,']! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/17/2002 13:12'!documentAttributes: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod _ true! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 19:05'!endElement: elementName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName	"This call corresponds to the Java SAX call	endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName).	By default this call is mapped to the following more convenient call:"	self endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!endPrefixMapping: prefix	"This call corresonds to the Java SAX call	endPrefixMapping(java.lang.String prefix)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!ignorableWhitespace: aString	"This call corresonds to the Java SAX call	ignorableWhitespace(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:26'!processingInstruction: piName data: dataString	"This call corresonds to the Java SAX call	processingInstruction(java.lang.String target, java.lang.String data)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!skippedEntity: aString	"This call corresonds to the Java SAX call	skippedEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!startDocument	"This call corresonds to the Java SAX call	startDocument()."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!startElement: elementName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 16:50'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	"This call corresonds to the Java SAX call	startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts).	By default this call is mapped to the following more convenient call:"	self startElement: localName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:47'!startPrefixMapping: prefix uri: uri	"This call corresonds to the Java SAX call	startPrefixMapping(java.lang.String prefix, java.lang.String uri)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:52'!comment: commentString	"This call corresponds to the Java SAX ext call	comment(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!endEntity: entityName	"This call corresponds to the Java SAX ext call	endEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!startCData	"This call corresponds to the Java SAX ext call	startCData()."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startDTD: declName publicID: publicID systemID: systemID	"This call corresponds to the Java SAX ext call	startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startEntity: entityName	"This call corresponds to the Java SAX ext call	startEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document	^document! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document _ aDocument! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver	^driver! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver _ aDriver.	driver saxHandler: self! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:18'!eod	^eod! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:28'!useNamespaces: aBoolean	self driver useNamespaces: aBoolean! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod _ false! !!SAXHandler methodsFor: 'parsing' stamp: 'mir 1/8/2002 18:18'!parseDocument	[self driver nextEntity isNil or: [self eod]] whileFalse! !!SAXHandler methodsFor: 'entity' stamp: 'mir 8/11/2000 17:33'!resolveEntity: publicID systemID: systemID	"This call corresonds to the Java SAX call	resolveEntity(java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:29'!new	^super new initialize! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	parser _ self new driver: driver.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser _ self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:13'!parseDocumentFrom: aStream	|  parser |	parser _ self on: aStream.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName	^self parseDocumentFromFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	[xmlDoc _ self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:15'!parserOnFileNamed: fileName	^self parserOnFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	^self on: stream! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangesOrganizer. "	Smalltalk		at: #ChangesOrganizer		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangesOrganizer."	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12'!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12'!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12'!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13'!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02'!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12'!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40'!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader commentStamp: '<historical>' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!ScreenController methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:47'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp := DiskProxy global: #ScheduledControllers selector: #screenController args: #().	refStrm replace: self with: dp.	^ dp! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!closeUnchangedWindows	"Close any window that doesn't have unaccepted input."	| clean |	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	clean := ScheduledControllers scheduledControllers select:		[:c | c model canDiscardEdits and: [(c isKindOf: ScreenController) not]].	clean do: [:c | c closeAndUnscheduleNoTerminate].	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:01'!durableHelpMenu 	| aMenu selectionList labelList targetList i wordingList colorPattern |	aMenu := self helpMenu.	selectionList := aMenu selections.	labelList := (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList :=  (1 to: selectionList size) collect: [:ind | self].	(i := labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList := selectionList copyReplaceFrom: i to: i with: Array new.		labelList := labelList copyReplaceFrom: i to: i with: Array new.		targetList := targetList copyReplaceFrom: i to: i with: Array new].	colorPattern := #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange).	wordingList := selectionList collect:		[:aSelection |			(aSelection == #soundOnOrOff) ifTrue: [#soundEnablingString] ifFalse: [nil]].	^ Utilities windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList wordingSelectors: wordingList title: 'Help'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 11/25/1998 12:21'!durableOpenMenu 	| colorPattern |	colorPattern := #(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan) asOrderedCollection.	colorPattern add: Project someInstance backgroundColorForMvcProject.	colorPattern add: Project someInstance backgroundColorForMorphicProject.	colorPattern add: #orange.	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern: colorPattern! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:28'!durableWindowMenu 	| aMenu selectionList labelList targetList i wordingList colorPattern |	aMenu := self windowMenu.	selectionList := aMenu selections.	labelList := (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList :=  (1 to: selectionList size) collect: [:ind | self].	(i := labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList := selectionList copyReplaceFrom: i to: i with: Array new.		labelList := labelList copyReplaceFrom: i to: i with: Array new.		targetList := targetList copyReplaceFrom: i to: i with: Array new].	colorPattern := #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange).	wordingList := selectionList collect:		[:aSelection |			(#(fastWindows changeWindowPolicy) includes: aSelection)				ifFalse:					[nil]				ifTrue:					[aSelection == #fastWindows						ifFalse:							[#staggerPolicyString]						ifTrue:							[#bitCachingString]]].	^ Utilities windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList wordingSelectors: wordingList title: 'windows'! !!ScreenController methodsFor: 'menu messages'!emergencyCollapse	"Emergency collapse of a selected window"	| controller |	(controller := ScheduledControllers windowFromUser) notNil		ifTrue:			[controller collapse.			controller view deEmphasize]! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOff	Display fullScreenMode: (LastScreenModeSelected := false).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sd 6/7/2003 19:49'!fullScreenOn	Display fullScreenMode: (LastScreenModeSelected := true).	DisplayScreen checkForNewScreenSize.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 4/24/2001 12:00'!openProject 	"Create and schedule a Project."	| proj |	Smalltalk at: #ProjectView ifPresent:		[:c | proj := Project new.		c open: proj].! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 9/18/1999 20:01'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result := (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result]! !!ScriptActivationButton methodsFor: 'access' stamp: 'sw 3/10/2003 23:57'!uniclassScript	"Answer the receiver's uniclassScript.  For old buttons, this might initially be nil but will get set, when possible herein."	^ uniclassScript ifNil:		[uniclassScript := target class scripts at: arguments first ifAbsent: [nil]]! !!ScriptActivationButton methodsFor: 'initialization' stamp: 'sw 3/11/2003 00:31'!initializeForPlayer: aPlayer uniclassScript: aUniclassScript	"Initialize the receiver for the given player and uniclass script"	target := aPlayer.	uniclassScript := aUniclassScript.	actionSelector := #runScript:.	arguments := Array with: uniclassScript selector.	self establishLabelWording	! !!ScriptActivationButton methodsFor: 'label' stamp: 'yo 11/30/2005 14:14'!establishLabelWording	"Set the label wording, unless it has already been manually edited"	| itsName |	itsName := target externalName.	(self hasProperty: #labelManuallyEdited)		ifFalse:			[self label: (itsName, ' ', arguments first)].	self setBalloonText: 		('click to run the script "{1}" in player named "{2}"' translated format: {arguments first. itsName}).! !!ScriptActivationButton methodsFor: 'miscellaneous' stamp: 'sw 3/11/2003 00:35'!bringUpToDate	"The object's name, or the script name, or both, may have changed.  Make sure I continue to look and act right"	uniclassScript ifNotNil:		[arguments := Array with: uniclassScript selector].	self establishLabelWording! !!ScriptActivationButton methodsFor: 'miscellaneous' stamp: 'sw 2/28/2001 21:42'!setLabel	"Allow the user to enter a new label for this button"	| newLabel existing |	existing := self label.	newLabel := FillInTheBlank		request: 'Please enter a new label for this button'		initialAnswer: existing.	(newLabel isEmptyOrNil not and: [newLabel ~= existing]) ifTrue:		[self setProperty: #labelManuallyEdited toValue: true.		self label: newLabel].! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 10/30/2000 11:08'!initializePermanentScriptFor: aPlayer selector: aSelector	"Initialize the receiver on behalf of the player, setting its status to #normal and giving it the given selector"	player := aPlayer.	status := #normal.	selector := aSelector! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 7/21/2003 20:07'!defineNewEvent	| newEventName newEventHelp |	"Prompt the user for the name of a new event and install it into the custom event table"	newEventName := FillInTheBlankMorph request: 'What is the name of your new event?'.	newEventName isEmpty ifTrue: [ ^self ].	newEventName := newEventName asSymbol.	(ScriptingSystem customEventStati includes: newEventName) ifTrue: [		self inform: 'That event is already defined.'. ^self ].	newEventHelp := FillInTheBlankMorph request: 'Please describe this event:'.	ScriptingSystem addUserCustomEventNamed: newEventName help: newEventHelp.! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 7/21/2003 20:32'!deleteCustomEvent	| userEvents eventName |	userEvents :=  ScriptingSystem userCustomEventNames.	eventName := (SelectionMenu selections: userEvents) startUpWithCaption: 'Remove which event?' at: ActiveHand position allowKeyboard: true.	eventName ifNotNil: [ ScriptingSystem removeUserCustomEventNamed: eventName ].	self class allSubInstancesDo: [ :ea | ea status = eventName ifTrue: [ ea status: #normal ]]! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'nk 11/1/2004 07:53'!presentScriptStatusPopUp	"Put up a menu of status alternatives and carry out the request"	| reply  m menu submenu |	menu := MenuMorph new.	self addStatusChoices: #( normal " -- run when called" ) toMenu: menu.	self addStatusChoices: 		#(	paused 		"ready to run all the time"			ticking			"run all the time" )		toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati copyFrom: 1 to: 3) toMenu: menu.	self addStatusChoices: (ScriptingSystem standardEventStati allButFirst: 3) toMenu: menu.	self addStatusChoices: 		#(opening			"when I am being opened"			closing			"when I am being closed" )		toMenu: menu.		submenu := MenuMorph new.	self addStatusChoices: (ScriptingSystem globalCustomEventNamesFor: player) toSubMenu: submenu forMenu: menu.	menu add: 'more... ' translated subMenu: submenu.	(Preferences allowEtoyUserCustomEvents) ifTrue: [		submenu addLine.		self addStatusChoices: ScriptingSystem userCustomEventNames toSubMenu: submenu forMenu: menu.		submenu addLine.		self addStatusChoices:			(Array streamContents: [ :s | s nextPut: { 'define a new custom event'. #defineNewEvent }.			ScriptingSystem userCustomEventNames isEmpty				ifFalse: [ s nextPut: { 'delete a custom event'. #deleteCustomEvent } ]])			toSubMenu: submenu forMenu: menu ].		menu addLine.	self addStatusChoices: #(		('what do these mean?'explainStatusAlternatives)		('apply my status to all siblings' assignStatusToAllSiblings) ) toMenu: menu.	menu addTitle: 'When should this script run?' translated.	menu submorphs last delete.	menu invokeModal.		reply := menu modalSelection.	reply == #explainStatusAlternatives ifTrue: [^ self explainStatusAlternatives].	reply == #assignStatusToAllSiblings ifTrue: [^ self assignStatusToAllSiblings].	reply == #defineNewEvent ifTrue: [ ^self defineNewEvent ].	reply == #deleteCustomEvent ifTrue: [ ^self deleteCustomEvent ].	reply ifNotNil: 		[self status: reply.  "Gets event handlers fixed up"		reply == #paused ifTrue:			[m := player costume.			(m isKindOf: SpeakerMorph) ifTrue: [m stopSound]].		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'sw 4/21/1999 09:13'!frequency: aNumber	frequency := aNumber! !!ScriptInstantiation methodsFor: 'frequency' stamp: 'ar 2/12/2001 18:26'!tickingRate: aNumber	"See the comment in #tickingRate"	tickingRate := aNumber.	self updateAllStatusMorphs.! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 10/24/2004 17:05'!assignStatusToAllSiblings	"Let all sibling instances of my player have the same status that I do.  The stati affected are both the event stati and the tickingStati"	| aScriptInstantiation |	(player class allInstances copyWithout: player) do:		[:aPlayer |			aScriptInstantiation := aPlayer scriptInstantiationForSelector: selector.			aScriptInstantiation status: status.			aScriptInstantiation frequency: self frequency.			aScriptInstantiation tickingRate: self tickingRate.			aScriptInstantiation updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:11'!offerMenuIn: aStatusViewer	"Put up a menu."	| aMenu |	ActiveHand showTemporaryCursor: nil.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: player knownName, ' ', selector.	aMenu addStayUpItem.	(player class instanceCount > 1) ifTrue:		[aMenu add: 'propagate status to siblings' translated selector: #assignStatusToAllSiblingsIn: argument: aStatusViewer.		aMenu balloonTextForLastItem: 'Make the status of this script in all of my sibling instances be the same as the status you see here' translated].	aMenu add: 'reveal this object' translated target: player selector: #revealPlayerIn: argument: ActiveWorld.	aMenu balloonTextForLastItem: 'Make certain this object is visible on the screen; flash its image for a little while, and give it the halo.' translated.	aMenu add: 'open this script''s Scriptor' translated target: player selector: #grabScriptorForSelector:in: argumentList: {selector. aStatusViewer world}.	aMenu balloonTextForLastItem: 'Open up the Scriptor for this script' translated.	aMenu add: 'open this object''s Viewer' translated target: player selector: #beViewed.	aMenu balloonTextForLastItem: 'Open up a Viewer for this object' translated.	aMenu addLine.	aMenu add: 'more...' translated target: self selector: #offerShiftedMenuIn: argument: aStatusViewer.	aMenu balloonTextForLastItem: 'The "more..." branch offers you menu items that are less frequently used.' translated.	aMenu popUpInWorld: ActiveWorld! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:12'!offerShiftedMenuIn: aStatusViewer	"Put up the shifted menu"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: player knownName, ' ', selector.	aMenu add: 'grab this object' translated target: player selector: #grabPlayerIn: argument: self currentWorld.	aMenu balloonTextForLastItem: 'Wherever this object currently is, the "grab" command will rip it out, and place it in your "hand".  This is a very drastic step, that can disassemble things that may be very hard to put back together!!' translated.	aMenu add: 'destroy this script' translated target: player selector: #removeScriptWithSelector: argument: selector.	aMenu balloonTextForLastItem: 'Caution!!  This is irreversibly destructive -- it removes the script from the system.' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: player costume selector: #inspect.	aMenu add: 'inspect player' translated target: player selector: #inspect.	aMenu popUpInWorld: ActiveWorld! !!ScriptInstantiation methodsFor: 'misc' stamp: 'ar 2/12/2001 18:58'!prepareToBeRunning	lastTick := nil.! !!ScriptInstantiation methodsFor: 'misc' stamp: 'dgd 12/15/2003 10:09'!statusControlRowIn: aStatusViewer	"Answer an object that reports my status and lets the user change it"	| aRow aMorph buttonWithPlayerName |	aRow := ScriptStatusLine newRow beTransparent.	buttonWithPlayerName := UpdatingSimpleButtonMorph new.	buttonWithPlayerName		on: #mouseEnter send: #menuButtonMouseEnter: to: buttonWithPlayerName;		 on: #mouseLeave send: #menuButtonMouseLeave: to: buttonWithPlayerName.	buttonWithPlayerName target: self; wordingSelector: #playersExternalName; actionSelector: #offerMenuIn:; arguments: {aStatusViewer}; beTransparent; actWhen: #buttonDown.	buttonWithPlayerName setBalloonText: 'This is the name of the player to which this script belongs; if you click here, you will get a menu of interesting options pertaining to this player and script' translated.	buttonWithPlayerName borderWidth: 1; borderColor: Color blue.	aRow addMorphBack: buttonWithPlayerName.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aMorph := UpdatingStringMorph on: self selector: #selector.	aMorph color: Color brown lighter; useStringFormat.	aMorph setBalloonText: 'This is the name of the script to which this entry pertains.' translated.	aRow addMorphBack: aMorph.	aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.	aRow addTransparentSpacerOfSize: 10@0.	aRow addMorphBack: self statusControlMorph.	aRow submorphsDo: [:m | m wantsSteps ifTrue: [m step]].	^ aRow! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 1/28/2001 16:06'!changeSelectorTo: aNewSelector	"Change the selector associated with the receiver to the new one provided"	selector := aNewSelector! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/13/1998 10:43'!player: p	"Needed for making duplicate players, otherwise private"	player := p! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/1/1998 21:33'!player: p selector: s status: st	frequency := 0.	status := st.	player := p.	selector := s! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 4/30/1998 14:07'!selector: sel	selector := sel! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfClosing	| result |	(result := status == #closing) ifTrue:		[player triggerScript: selector].	^ result! !!ScriptInstantiation methodsFor: 'running' stamp: 'nk 8/21/2004 12:08'!runIfOpening	| result |	(result := status == #opening) ifTrue:		[player triggerScript: selector].	^ result! !!ScriptInstantiation methodsFor: 'status control' stamp: 'dgd 9/6/2003 18:15'!presentTickingMenu	"Put up a menu of status alternatives and carry out the request"	| aMenu ticks item any |	ticks := self tickingRate.	ticks = ticks asInteger ifTrue:[ticks := ticks asInteger].	aMenu := MenuMorph new defaultTarget: self.	any := false.	#(1 2 5 8 10 25 50 100) do:[:i | 		item := aMenu addUpdating: nil target: self selector: #tickingRate: argumentList: {i}.		item contents:			((ticks = i) ifTrue:[ any := true. '<on>', i printString]					ifFalse:['<off>', i printString])].	item := aMenu addUpdating: nil target: self selector: #typeInTickingRate argumentList: #().	item contents: (any ifTrue:['<off>'] ifFalse:['<on>']), 'other...' translated.	aMenu addTitle: ('Ticks (now: {1}/sec)' translated format:{ticks}).	aMenu  popUpEvent: self currentEvent in: self currentWorld! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 6/13/2002 15:14'!resetToNormalIfCurrently: aStatus	"If my status *had been* aStatus, quietly reset it to normal, without tampering with event handlers.  But get the physical display of all affected status morphs right"	status == aStatus ifTrue:		[status := #normal.		self updateAllStatusMorphs]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'sw 4/30/1998 14:10'!status	status ifNil: [status := #normal].	^ status! !!ScriptInstantiation methodsFor: 'status control' stamp: 'em 3/24/2005 14:49'!typeInTickingRate	| reply aNumber |	reply := FillInTheBlank request: 'Number of ticks per second: ' translated initialAnswer: self tickingRate printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self tickingRate: aNumber]]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'dgd 9/21/2003 16:04'!updateStatusMorph: statusControlMorph	"the status control may need to reflect an externally-induced change in status"	| colorSelector statusReadoutButton |	statusControlMorph ifNil: [^ self].	self pausedOrTicking		ifTrue:			[statusControlMorph assurePauseTickControlsShow]		ifFalse:			[statusControlMorph maybeRemovePauseTickControls].	statusReadoutButton := statusControlMorph submorphs last.	colorSelector := ScriptingSystem statusColorSymbolFor: self status.	statusReadoutButton color: (Color perform: colorSelector) muchLighter.	statusReadoutButton label: self translatedStatus asString font: Preferences standardButtonFont! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46'!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !!ScriptLoader methodsFor: 'private helpers' stamp: 'pk 5/13/2007 14:16'!cleaningCS	"self new cleaningCS" 	 	ChangesOrganizer removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33'!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12'!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08'!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07'!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !!ScriptNameTile methodsFor: 'initialization' stamp: 'sw 12/19/2003 23:09'!dataType: aDataType	"Initialize the receiver with the given data type"	dataType := aDataType.	literal := #emptyScript! !!ScriptNameType methodsFor: 'tiles' stamp: 'sw 12/19/2003 23:11'!defaultArgumentTile	"Answer a tile to represent the type"	| aTile  |	aTile := ScriptNameTile new dataType: self vocabularyName.	aTile addArrows.	aTile setLiteral: #emptyScript.	^ aTile! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'dgd 9/21/2003 15:54'!assurePauseTickControlsShow	"Add two little buttons that allow the user quickly to toggle between paused and ticking state"	| colorSelector status |	self beTransparent.	(tickPauseWrapper isKindOf: TickIndicatorMorph) ifFalse:[		"this was an old guy"		tickPauseWrapper ifNotNil:[tickPauseWrapper delete].		tickPauseWrapper := TickIndicatorMorph new.		tickPauseWrapper on: #mouseDown send: #mouseDownTick:onItem: to: self.		tickPauseWrapper on: #mouseUp send: #mouseUpTick:onItem: to: self.		tickPauseWrapper setBalloonText:'Press to toggle ticking state. Hold down to set tick rate.' translated.		self addMorphFront: tickPauseWrapper.	].	status := scriptInstantiation status.	colorSelector := ScriptingSystem statusColorSymbolFor: status.	tickPauseWrapper color: (Color perform: colorSelector) muchLighter.	tickPauseWrapper stepTime: (1000 // scriptInstantiation tickingRate max: 0).	tickPauseWrapper isTicking: status == #ticking.	tickPauseButtonsShowing := true.! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'dgd 11/26/2003 15:02'!initializeFor: aScriptInstantiation	"Answer a control that will serve to reflect and allow the user to change the status of the receiver"	|  statusReadout |	self hResizing: #shrinkWrap.	self cellInset: 2@0.	scriptInstantiation := aScriptInstantiation.	tickPauseButtonsShowing := false.	self addMorphBack: (statusReadout := UpdatingSimpleButtonMorph new).	statusReadout label: aScriptInstantiation status asString font: Preferences standardButtonFont.	statusReadout setNameTo: 'trigger'.	statusReadout target: aScriptInstantiation; wordingSelector: #translatedStatus; actionSelector: #presentScriptStatusPopUp.	statusReadout setBalloonText: 'when this script should run' translated.	statusReadout actWhen: #buttonDown.	self assurePauseTickControlsShow.	aScriptInstantiation updateStatusMorph: self! !!ScriptStatusControl methodsFor: 'initialization' stamp: 'ar 2/12/2001 18:24'!maybeRemovePauseTickControls	"If we're in the business of removing pauseTick controls when we're neither paused nor ticking, then do it now.  The present take is not to remove these controls, which explains why the body of this method is currently commented out."	tickPauseButtonsShowing := false.	"note: the following is to change color of the tick control appropriately"	self assurePauseTickControlsShow.! !!ScriptableButton methodsFor: 'accessing' stamp: 'sw 10/30/2000 11:02'!label	"Answer a string representing the label of the receiver, returning an empty string if necessary"	| aStringMorph |	^ (aStringMorph := self findA: StringMorph)		ifNil:		['']		ifNotNil:	[aStringMorph contents]! !!ScriptableButton methodsFor: 'accessing' stamp: 'sw 10/30/2000 10:59'!label: aString	"Set the receiver's label as indicated"	| aLabel |	(aLabel := self findA: StringMorph)		ifNotNil:			[aLabel contents: aString]		ifNil:			[aLabel := StringMorph contents: aString font: TextStyle defaultFont.			self addMorph: aLabel].	self extent: aLabel extent + (borderWidth + 6).	aLabel position: self center - (aLabel extent // 2).	aLabel lock! !!ScriptableButton methodsFor: 'accessing' stamp: 'tk 9/28/2001 21:09'!scriptSelector: aSymbol	scriptSelector := aSymbol! !!ScriptableButton methodsFor: 'label' stamp: 'yo 11/4/2002 22:13'!label: aString font: aFontOrNil	"Set the receiver's label and font as indicated"	| oldLabel m aFont |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	aFont := aFontOrNil ifNil: [TextStyle defaultFont].	m := StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!ScriptableButton methodsFor: 'menu' stamp: 'sw 10/30/2000 11:02'!setLabel	"Invoked from a menu, let the user change the label of the button"	| newLabel |	newLabel := FillInTheBlank		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!ScrollBar methodsFor: 'initialize' stamp: 'wiz 12/22/2007 23:01'!initializeMenuButton"initialize the receiver's menuButton"	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	(Preferences valueOfFlag: #scrollBarsWithoutMenuButton)		ifTrue: [menuButton := nil .^ self].	menuButton _ self roundedScrollbarLook		ifTrue: [RectangleMorph					newBounds: ((bounds isWide							ifTrue: [upButton bounds topRight]							ifFalse: [upButton bounds bottomLeft])							extent: self buttonExtent)]		ifFalse: [RectangleMorph					newBounds: (self innerBounds topLeft extent: self buttonExtent)					color: self thumbColor].	menuButton		on: #mouseEnter		send: #menuButtonMouseEnter:		to: self.	menuButton		on: #mouseDown		send: #menuButtonMouseDown:		to: self.	menuButton		on: #mouseLeave		send: #menuButtonMouseLeave:		to: self.	"menuButton 	addMorphCentered: (RectangleMorph 	newBounds: (0 @ 0 extent: 4 @ 2) 	color: Color black)."	self updateMenuButtonImage.	self roundedScrollbarLook		ifTrue: [menuButton color: Color veryLightGray.			menuButton				borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [menuButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: menuButton! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar := scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker := marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea := Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar := Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'basic control sequence'!controlTerminate	super controlTerminate.	savedArea notNil 			ifTrue: 			[savedArea displayOn: Display at: scrollBar topLeft.			savedArea := nil].! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar := Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker := Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar := Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker := marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !!ScrollController methodsFor: 'marker adjustment'!moveMarker: anInteger anchorMarker: anchorMarker	"Update the marker so that is is translated by an amount corresponding to 	a distance of anInteger, constrained within the boundaries of the scroll 	bar.  If anchorMarker ~= nil, display the border around the area where the	marker first went down."	Display fill: marker fillColor: scrollBar insideColor.	anchorMarker = nil		ifFalse: [Display border: anchorMarker width: 1 fillColor: Color gray].	marker := marker translateBy: 0 @				((anInteger min: scrollBar inside bottom - marker bottom) max:					scrollBar inside top - marker top).	marker displayOn: Display! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor := sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling' stamp: 'th 12/11/1999 16:57'!scrollByKeyboard	| keyEvent |	keyEvent := sensor keyboardPeek.	keyEvent ifNil: [^ false].	(sensor controlKeyPressed or:[sensor commandKeyPressed]) ifFalse: [^ false].	keyEvent asciiValue = 30		ifTrue: 			[sensor keyboard.			self scrollViewDown ifTrue: [self moveMarker].			^ true].	keyEvent asciiValue = 31		ifTrue: 			[sensor keyboard.			self scrollViewUp ifTrue: [self moveMarker].			^ true].	^ false! !!ScrollController methodsFor: 'private'!scrollAbsolute	| markerOutline oldY markerForm |	self changeCursor: Cursor rightArrow.	oldY := -1.	sensor anyButtonPressed ifTrue: 	  [markerOutline := marker deepCopy.	  markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  Display border: markerOutline width: 1 fillColor: Color gray.	  markerForm 		follow: 			[oldY ~= sensor cursorPoint y				ifTrue: 					[oldY := sensor cursorPoint y.					marker := marker translateBy: 					  0 @ ((oldY - marker center y 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).					self scrollView].				marker origin] 		while: [sensor anyButtonPressed].	  Display fill: markerOutline fillColor: scrollBar insideColor.	  self moveMarker]! !!ScrollController methodsFor: 'private'!scrollDown	| markerForm firstTime |	self changeCursor: Cursor down.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewDown ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController methodsFor: 'private'!scrollUp	| markerForm firstTime |	self changeCursor: Cursor up.	sensor anyButtonPressed ifTrue:	  [markerForm := Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime := true.	  markerForm 		follow: 			[self scrollViewUp ifTrue:				[marker := marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime := false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!SearchingViewer methodsFor: 'initialization' stamp: 'tak 8/8/2005 11:31'!addNamePaneTo: header	"Add the namePane, which may be a popup or a type-in depending on the type of CategoryViewer"	| plugTextMor searchButton |	namePane := AlignmentMorph newRow vResizing: #spaceFill; height: 14.	namePane hResizing: #spaceFill.	namePane listDirection: #leftToRight.	plugTextMor := PluggableTextMorph on: self					text: #searchString accept: #searchString:notifying:					readSelection: nil menu: nil.	plugTextMor setProperty: #alwaysAccept toValue: true.	plugTextMor askBeforeDiscardingEdits: false.	plugTextMor acceptOnCR: true.	plugTextMor setTextColor: Color brown.	plugTextMor setNameTo: 'Search' translated.	plugTextMor vResizing: #spaceFill; hResizing: #spaceFill.	plugTextMor hideScrollBarsIndefinitely.	plugTextMor setTextMorphToSelectAllOnMouseEnter.	searchButton := SimpleButtonMorph new 		target: self;		beTransparent;		actionSelector: #doSearchFrom:;		arguments: {plugTextMor}.	namePane addMorphFront: searchButton.	namePane addTransparentSpacerOfSize: 6@0.	namePane addMorphBack: plugTextMor.	header addMorphBack: namePane.	self updateSearchButtonLabel.! !!SearchingViewer methodsFor: 'search' stamp: 'nk 8/29/2004 17:21'!doSearchFrom:  aSource interactive: isInteractive	"Perform the search operation.  If interactive is true, this actually happened because a search button was pressed; if false, it was triggered some other way for which an informer would be inappropriate."	| searchFor aVocab aList all anInterface useTranslations scriptNames addedMorphs |	searchString := (aSource isKindOf: PluggableTextMorph)		ifFalse:			[aSource]		ifTrue:			[aSource text string].	searchFor := searchString asString asLowercase withBlanksTrimmed.	aVocab := self outerViewer currentVocabulary.	(useTranslations := (scriptedPlayer isPlayerLike) and: [aVocab isEToyVocabulary])		ifTrue:			[all := scriptedPlayer costume selectorsForViewer.			all addAll: (scriptNames := scriptedPlayer class namedTileScriptSelectors)]		ifFalse:			[all := scriptNames := scriptedPlayer class allSelectors].	aList := all select:		[:aSelector | (aVocab includesSelector: aSelector forInstance: scriptedPlayer ofClass: scriptedPlayer class limitClass: ProtoObject) and:			[(useTranslations and: [(anInterface := aVocab methodInterfaceAt: aSelector ifAbsent: [nil]) notNil and: [anInterface wording includesSubstring: searchFor caseSensitive: false]])				or:					[((scriptNames includes: aSelector) or: [useTranslations not]) and:						[aSelector includesSubstring: searchFor caseSensitive: false]]]].	aList := aList asSortedArray.	self removeAllButFirstSubmorph. "that being the header"	self addAllMorphs:		((addedMorphs := scriptedPlayer tilePhrasesForSelectorList: aList inViewer: self)).	self enforceTileColorPolicy.	self secreteCategorySymbol.	self world ifNotNil: [self world startSteppingSubmorphsOf: self].	self adjustColorsAndBordersWithin.	owner ifNotNil: [owner isStandardViewer ifTrue: [owner fitFlap].	(isInteractive and: [addedMorphs isEmpty]) ifTrue:		[self inform: ('No matches found for "' translated), searchFor, '"']]! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/22/2002 15:14'!rawSearchString: aString	"Set the search string as indicated"	searchString := aString asString! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/11/2002 02:14'!searchString	"Answer the search string"	^ searchString ifNil: [searchString := '']! !!SearchingViewer methodsFor: 'search' stamp: 'sw 8/22/2002 20:30'!searchString: aString notifying: znak	"Set the search string as indicated and carry out a search"	searchString := aString asString.	self doSearchFrom: searchString! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections := selectionArray! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel := self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:26'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"	| index |	index := super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu methodsFor: 'invocation' stamp: 'sw 11/18/2002 16:24'!invokeOn: targetObject orSendTo: anObject	"Pop up the receiver, obtaining a selector; return the result of having the target object perform the selector.  If it dos not understand the selector, give the alternate object a chance"	| aSelector |	^ (aSelector := self startUp) ifNotNil:		[(targetObject respondsTo: aSelector)			ifTrue:				[targetObject perform: aSelector]			ifFalse:				[anObject perform: aSelector]]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 11/8/1999 17:52'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList := OrderedCollection new.	lines := OrderedCollection new.	selections := OrderedCollection new.	anIndex := 0.	anArray do:		[:anElement |			anElement size == 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size == 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex := anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:02'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	| labelString |	(labels isString)		ifTrue: [labelString := labels]		ifFalse: [labelString := String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!Semaphore methodsFor: 'communication' stamp: 'ar 8/30/2007 16:15'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d := Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	[self wait] ensure:[d unschedule].! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock				"Evaluate mutuallyExcludedBlock only if the receiver is not currently in	the process of running the critical: message. If the receiver is, evaluate	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue caught |	caught := false.	[		caught := true.		self wait.		blockValue := mutuallyExcludedBlock value	] ensure: [caught ifTrue: [self signal]].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:33'!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical:[[mutuallyExcludedBlock value] ifCurtailed: terminationBlock]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 17:59'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	self critical:[		blockValue := [mutuallyExcludedBlock value] ifError:[:msg :rcvr|			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/5/2007 18:34'!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	excessSignals == 0 ifTrue:[		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ac 7/5/2004 22:35'!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index := self indexOf: target.	^ (index == 0 or: [index = self size])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index + 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:45'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	| size |	(size := self size) > 26 "first method faster from 27 accesses and on"		ifTrue: [self from: 1 to: size put: anObject]		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'apb 11/4/2000 22:51'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	"#('one' 'two' 'three' 'four') atAll: #(3 2 4)"	| newCollection |	newCollection := self species ofSize: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ac 7/5/2004 22:36'!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index := self indexOf: target.	^ (index == 0 or: [index == 1])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index - 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'SqR 10/30/2000 22:06'!from: startIndex to: endIndex put: anObject	"Put anObject in all indexes between startIndex 	and endIndex. Very fast. Faster than to:do: for	more than 26 positions. Answer anObject"	| written toWrite thisWrite |	startIndex > endIndex ifTrue: [^self].	self at: startIndex put: anObject.	written := 1.	toWrite := endIndex - startIndex + 1.	[written < toWrite] whileTrue:		[			thisWrite := written min: toWrite - written.			self 				replaceFrom: startIndex + written				to: startIndex + written + thisWrite - 1				with: self startingAt: startIndex.			written := written + thisWrite		].	^anObject! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	"Answer the index of the receiver's first element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	start of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| first index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first := sub first.	start to: self size - sub size + 1 do:		[:startIndex |		(self at: startIndex) = first ifTrue:			[index := 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index := index+1]]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:30'!last: n	"Answer the last n elements of the receiver.  	Raise an error if there are not enough elements."	| size |	size := self size.	^ self copyFrom: size - n + 1 to: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index := self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index := self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver 	starting at index, repStart, in the sequenceable collection, 	replacementCollection. Answer the receiver. No range checks are 	performed."	| index repOff |	repOff := repStart - start.	index := start - 1.	[(index := index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!SequenceableCollection methodsFor: 'accessing'!swap: oneIndex with: anotherIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| element |	element := self at: oneIndex.	self at: oneIndex put: (self at: anotherIndex).	self at: anotherIndex put: element! !!SequenceableCollection methodsFor: 'comparing' stamp: 'tk 12/6/2000 11:39'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size := self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'comparing' stamp: 'SqR 8/3/2000 13:39'!hash	| hash |	hash := self species hash.	1 to: self size do: [:i | hash := (hash + (self at: i) hash) hashMultiply].	^hash! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray := FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray := IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'NS 5/30/2001 20:56'!asPointArray	"Answer an PointArray whose elements are the elements of the receiver, in 	the same order."	| pointArray |	pointArray := PointArray new: self size.	1 to: self size do:[:i| pointArray at: i put: (self at: i)].	^pointArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 4/10/2005 18:02'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream := WriteStream on: (String new: 200).	self do: [:each |		each isString			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray := WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'raok 6/23/2003 12:51'!concatenation	|result index|	result := Array new: (self inject: 0 into: [:sum :each | sum + each size]).	index := 0.	self do: [:each | each do: [:item | result at: (index := index+1) put: item]].	^result! !!SequenceableCollection methodsFor: 'converting' stamp: 'jm 4/27/98 04:09'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n := self size.	result := self species new: n.	src := n + 1.	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].	^ result! !!SequenceableCollection methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize := stop - start + 1.	^(self species new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying' stamp: 'ar 10/16/2001 19:03'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| newSequenceableCollection newSize endReplacement |	newSize := self size - (stop - start + 1) + replacementCollection size.	endReplacement := start - 1 + replacementCollection size.	newSequenceableCollection := self species new: newSize.	start > 1 ifTrue:[		newSequenceableCollection			replaceFrom: 1			to: start - 1			with: self			startingAt: 1].	start <= endReplacement ifTrue:[		newSequenceableCollection			replaceFrom: start			to: endReplacement			with: replacementCollection			startingAt: 1].	endReplacement < newSize ifTrue:[		newSequenceableCollection			replaceFrom: endReplacement + 1			to: newSize			with: self			startingAt: stop + 1].	^newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'ajh 9/27/2002 12:09'!copyWithFirst: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element."	| newIC |	newIC := self species ofSize: self size + 1.	newIC 		replaceFrom: 2		to: self size + 1		with: self		startingAt: 1.	newIC at: 1 put: newElement.	^ newIC! !!SequenceableCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newIC |	newIC := self species new: self size + 1.	newIC 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newIC at: newIC size put: newElement.	^newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'fcs 1/20/2002 16:03'!forceTo: length paddingStartWith: elem 	"Force the length of the collection to length, padding  	the beginning of the result if necessary with elem.  	Note that this makes a copy."	| newCollection padLen |	newCollection := self species new: length.	padLen := length - self size max: 0.	newCollection		from: 1		to: padLen		put: elem.	newCollection		replaceFrom: padLen + 1		to: ((padLen + self size) min: length)		with: self		startingAt:  1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/22/2000 18:01'!forceTo: length paddingWith: elem	"Force the length of the collection to length, padding	if necessary with elem.  Note that this makes a copy."	| newCollection copyLen |	newCollection := self species new: length.	copyLen := self size min: length.	newCollection replaceFrom: 1 to: copyLen with: self startingAt: 1.	newCollection from: copyLen + 1 to: length put: elem.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'djp 10/23/1999 22:12'!shuffledBy: aRandom	| copy | 	copy := self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: ((1 to: i) atRandom: aRandom)].	^ copy! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:41'!asDigitsToPower: anInteger do: aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection := Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:46'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 11:47'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| size result j |	size := lastIndex - firstIndex + 1.	result := self species new: size.	j := firstIndex.	1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:52'!combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection := Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:52'!findBinary: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test item |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (item := self at: index).		test = 0 			ifTrue:[^item]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating'!findFirst: aBlock	"Return the index of my first element for which aBlock evaluates as true."	| index |	index := 0.	[(index := index + 1) <= self size] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating'!findLast: aBlock	"Return the index of my last element for which aBlock evaluates as true."	| index |	index := self size + 1.	[(index := index - 1) >= 1] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'nk 7/17/2003 17:55'!overlappingPairsCollect: aBlock 	"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements."	| retval |	retval := self species new: self size - 1.	1 to: self size - 1		do: [:i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].	^retval! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 12/27/2000 09:53'!polynomialEval: thisX	| sum valToPower |	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	sum := self first.	valToPower := thisX.	2 to: self size do: [:ind | 		sum := sum + ((self at: ind) * valToPower).		valToPower := valToPower * thisX].	^ sum! !!SequenceableCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream := WriteStream on: (self species new: self size).	1 to: self size do: 		[:index |		(aBlock value: (self at: index))			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 5/17/1998 13:34'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'testing' stamp: 'bp 2/23/2004 21:48'!endsWith: aSequenceableCollection	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start := self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'private' stamp: 'yo 9/2/2002 18:22'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isString) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString := self.	startSearch := 1.	[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex := currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString := aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch := currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch := currentIndex + 1]					ifFalse: [startSearch := currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection class methodsFor: 'stream creation'!streamContents: blockWithArg	| stream |	stream := WriteStream on: (self new: 100).	blockWithArg value: stream.	^stream contents! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'di 6/20/97 09:07'!streamContents: blockWithArg limitedTo: sizeLimit	| stream |	stream := LimitedWriteStream on: (self new: (100 min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !!SequenceableCollectionTest methodsFor: 'tests - accessing' stamp: 'dc 3/3/2007 17:12'!testAtAllPut	|table|.	table := Array new: 5.	table atAllPut: $a.	self assert: (table allSatisfy: [:elem | elem = $a])! !!SequenceableCollectionTest methodsFor: 'tests - copying' stamp: 'dc 3/3/2007 17:13'!testCopyWith	| table |	table := Array new: 4 withAll: 3.	self assert: table = #(3 3 3 3).	table := table copyWith: 4.	self assert: table = #(3 3 3 3 4).! !!SequenceableCollectionTest methodsFor: 'tests - converting' stamp: 'dc 3/3/2007 17:16'!testEvalStrings	| table |	table := #('String new' 'Array with: 3 with: $a' '15+4').	table := table evalStrings.	self assert: table first isString.	self assert: table first isEmpty.		self assert: table second isArray.	self assert: table second first = 3.	self assert: table second second = $a.		self assert: table third = 19.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:19'!testPreMultiplyByArray	| array|.	array := #(3).	self assert:(array preMultiplyByArray: 2)=6.		array := Array new: 4.	self should:[array preMultiplyByArray: 2] raise:Error.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:26'!testPreMultiplyByMatrix	| array matrix result|.	array := #(1 2 3 4 5).		"( 1  2  3  4  5	  10 20 30 40 50)"	matrix := Matrix				rows:2 columns:5 tabulate: [:row :column | row = 1 											ifTrue: column											ifFalse: column * 10].	result := array preMultiplyByMatrix: matrix.	self assert: result isArray.	self assert: result size = 2.	self assert: result first = 55.	self assert: result second = 550.! !!SequenceableCollectionTest methodsFor: 'tests - arithmetic' stamp: 'dc 3/3/2007 17:28'!testPreMultiplyByMatrix2	| array matrix|.		array := #(1 2 3 4 5).	matrix := Matrix rows:1 columns:4 tabulate: [:row :column | column].		"Not compatible size"	self should:[array preMultiplyByMatrix: matrix] raise: Error.! !!SequenceableCollectionTest methodsFor: 'testing' stamp: 'dc 3/5/2007 15:57'!testReplaceFromToWithStartingAt	| string |	string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'lmnd'.		string := 'abcd' copy.	string replaceFrom: 1 to: 3 with: 'lmnop' startingAt: 2.	self assert: string = 'mnod'.		string := 'abcd' copy.	string replaceFrom: 2 to: 3 with: 'lmnop' startingAt: 1.	self assert: string = 'almd'.! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 15:45'!eToyUserList	"Return a list of all known users for eToy login support"	| urlString |	eToyUserList ifNotNil:[^eToyUserList].	urlString := self eToyUserListUrl.	urlString ifNil:[^nil].	eToyUserList := self class parseEToyUserListFrom: urlString.	^eToyUserList! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 8/24/2001 14:31'!eToyUserListUrl: aString	eToyUserListUrl := aString.	eToyUserList := nil.! !!ServerDirectory methodsFor: '*eToys-school support' stamp: 'ar 8/24/2001 14:31'!eToyUserList: aCollectionOrNil	"Set a list of all known users for eToy login support"	eToyUserList := aCollectionOrNil.! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 16:38'!eToyUserListForFileDirectory: aFileDirectory	| urlString |	urlString := self eToyUserListUrlForFileDirectory: aFileDirectory.	urlString ifNil:[^nil].	^self parseEToyUserListFrom: urlString! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 16:11'!localEToyBaseFolderSpecs	^LocalEToyBaseFolderSpecs ifNil:[LocalEToyBaseFolderSpecs := IdentityDictionary new]! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'ar 9/5/2001 15:47'!localEToyUserListUrls	^LocalEToyUserListUrls ifNil:[LocalEToyUserListUrls := IdentityDictionary new].! !!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'fbs 2/2/2005 13:24'!parseEToyUserListFrom: urlString	| url userString userList |	urlString ifNil:[^nil].	url := urlString asUrl.	["Note: We need to prevent going through the plugin API 	when retrieving a local (file) URL, since the plugin API	(correctly) rejects file:// downloads."		Cursor wait showWhile:[			(url hasRemoteContents) ifTrue:[				"Go through the browser (if present)"				userString := (HTTPClient httpGet: url asString) contents.			] ifFalse:[				"Go grab it directly"				userString := url retrieveContents contents.			].		].	] on: Error do:[:ex| userString := nil. ex return].	userString ifNil:[^nil].	"Get rid of any line ending problems"	userString := userString copyReplaceAll: String crlf with: String cr.	userString := userString copyReplaceAll: String lf with: String cr.	userList := (userString findTokens: Character cr) collect:[:each| each withBlanksTrimmed].	userList := userList reject:[:any| any isEmpty].	(userList first = '##user list##') ifFalse:[^nil].	userList := userList copyFrom: 2 to: userList size.	^userList! !!Set methodsFor: 'accessing' stamp: 'md 7/31/2005 08:56'!atRandom: aGenerator	"Answer a random element of the receiver. Uses aGenerator whichshould be kept by the user in a variable and used every time. Usethis instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."	| rand |	self emptyCheck.	rand := aGenerator nextInt: self size.	self doWithIndex:[:each :ind |		ind == rand ifTrue:[^each]].	^ self errorEmptyCollection! !!Set methodsFor: 'accessing' stamp: 'SqR 8/23/2000 13:51'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index |	^(index := self scanFor: anObject) = 0		ifFalse: [array at: index]! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:28'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:49'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet := Set new: self size.	array do: [:each | each ifNotNil: [newSet add: (aBlock value: each)]].	^ newSet! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 14:36'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each := array at: index) ifNotNil: [aBlock value: each]]! !!Set methodsFor: 'enumerating'!doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index := 0.	self do: [:item | aBlock2 value: item value: (index := index+1)]! !!Set methodsFor: 'removing'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: oldObject.	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!Set methodsFor: 'private'!atNewIndex: index put: anObject	array at: index put: anObject.	tally := tally + 1.	self fullCheck! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:39'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index := self scanFor: anObject.	index > 0 ifTrue: [^index].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private' stamp: 'SqR 8/23/2000 14:28'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex := 1]			ifFalse: [oldIndex := oldIndex + 1].	(element := self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex := self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!Set methodsFor: 'private'!grow	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := Array new: array size + self growSize.	tally := 0.	oldElements do:		[:each | each == nil ifFalse: [self noCheckAdd: each]]! !!Set methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	"Initialize array to an array size of n"	array := Array new: n.	tally := 0! !!Set methodsFor: 'private'!noCheckAdd: anObject	array at: (self findElementOrNil: anObject) put: anObject.	tally := tally + 1! !!Set methodsFor: 'private'!rehash	| newSelf |	newSelf := self species new: self size.	self do: [:each | newSelf noCheckAdd: each].	array := newSelf array! !!Set methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'private'!withArray: anArray	"private -- for use only in copy"	array := anArray! !!Set class methodsFor: 'initialization' stamp: 'SqR 8/3/2000 13:19'!quickRehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c |			insts := c allInstances.			(insts isEmpty or: [c = MethodDictionary]) ifFalse:			['Rehashing instances of ' , c name				displayProgressAt: Sensor cursorPoint				from: 1 to: insts size				during: [:bar | 1 to: insts size do: [:x | bar value: x. (insts at: x) rehash]]			]		]! !!Set class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^ newCollection"	Set newFrom: {1. 2. 3}	{1. 2. 3} as: Set"! !!SharedQueue methodsFor: 'accessing' stamp: 'bf 2/11/2006 15:17'!flush	"Throw out all pending contents"	accessProtect critical: [		"nil out flushed slots --bf 02/11/2006"		contentsArray from: readPosition to: writePosition-1 put: nil.		readPosition := 1.		writePosition := 1.		"Reset the read synchronization semaphore"		readSynch initSignals].! !!SharedQueue methodsFor: 'accessing' stamp: 'NS 6/18/2002 11:15'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	| value newReadPos |	accessProtect critical: [		newReadPos := writePosition.		writePosition-1 to: readPosition by: -1 do:			[:i | value := contentsArray at: i.			contentsArray at: i put: nil.			(aBlock value: value) ifTrue: [				"We take an element out of the queue, and therefore, we need to decrement 				the readSynch signals"				readSynch wait.			] ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value]].		readPosition := newReadPos].	^value! !!SharedQueue methodsFor: 'accessing'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value |	readSynch wait.	accessProtect		critical: [readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1]].	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'RAA 12/14/2000 10:25'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	| value |	accessProtect critical: [		readPosition >= writePosition ifTrue: [			value := nil		] ifFalse: [			value := contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition := readPosition + 1		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'di 10/1/2001 20:58'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	| value readPos |	accessProtect critical: [		value := nil.		readPos := readPosition.		[readPos < writePosition and: [value isNil]] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value) ifTrue: [				readPosition to: readPos - 1 do: [ :j |					contentsArray at: j put: nil.				].				readPosition := readPos.			] ifFalse: [				value := nil.			].		].		readPosition >= writePosition ifTrue: [readSynch initSignals].	].	^value"===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing'!nextPut: value 	"Send value through the receiver. If a Process has been suspended 	waiting to receive a value through the receiver, allow it to proceed."	accessProtect		critical: [writePosition > contentsArray size						ifTrue: [self makeRoomAtEnd].				 contentsArray at: writePosition put: value.				 writePosition := writePosition + 1].	readSynch signal.	^value! !!SharedQueue methodsFor: 'accessing' stamp: 'tpr 1/5/2005 18:22'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	| value |	accessProtect		critical: [readPosition >= writePosition					ifTrue: [readPosition := 1.							writePosition := 1.							value := nil]					ifFalse: [value := contentsArray at: readPosition]].	^value! !!SharedQueue methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: size	contentsArray := Array new: size.	readPosition := 1.	writePosition := 1.	accessProtect := Semaphore forMutualExclusion.	readSynch := Semaphore new! !!SharedQueue methodsFor: 'private' stamp: 'bf 10/25/2005 15:33'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray := contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize := writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			"nil out remainder --bf 10/25/2005"			contentsArray				from: contentsSize+1				to: contentsArray size				put: nil.			readPosition := 1.			writePosition := contentsSize + 1]! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ls 6/25/2005 14:16'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no such object has been queued, answer <nil> and leave me intact."	| index |	^monitor critical: [		index := items findFirst: aBlock.		index = 0 ifTrue: [			nil ]		ifFalse: [			items removeAt: index ] ].! !!SharedQueue2 methodsFor: 'initializing' stamp: 'ls 6/25/2005 13:48'!initialize	monitor := Monitor new.	items := OrderedCollection new.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetPoint.	target := rootMorphs size > 1				ifTrue: [rootMorphs second]! !!SimplerTextContainer methodsFor: 'container protocol' stamp: 'RAA 7/30/2000 14:46'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| rects |	lineY > textMorph owner bottom ifTrue: [^#()].	rects := Array with: (self left@lineY extent: textMorph width@lineHeight).	"rects := rects collect: [:r | r insetBy: OuterMargin@0]."	^ rects! !!SketchMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: '*eToys-e-toy support' stamp: 'nk 6/12/2004 10:04'!acquirePlayerSimilarTo: aSketchMorphsPlayer	"Retrofit into the receiver a player derived from the existing scripted player of a different morph.  Works only between SketchMorphs. Maddeningly complicated by potential for transformations or native sketch-morph scaling in donor or receiver or both"	| myName myTop itsTop newTop newSketch |	myTop := self topRendererOrSelf.	aSketchMorphsPlayer belongsToUniClass ifFalse: [^ Beeper beep].	itsTop := aSketchMorphsPlayer costume.	(itsTop renderedMorph isSketchMorph)		ifFalse:	[^ Beeper beep].	newTop := itsTop veryDeepCopy.  "May be a sketch or a tranformation"	myName := myTop externalName.  "Snag before the replacement is added to the world, because otherwise that could affect this"	newSketch := newTop renderedMorph.	newSketch form: self form.	newSketch scalePoint: self scalePoint.	newSketch bounds: self bounds.	myTop owner addMorph: newTop after: myTop.	newTop heading ~= myTop heading ifTrue:		"avoids annoying round-off error in what follows"			[newTop player setHeading: myTop heading]. 	(newTop isFlexMorph and: [myTop == self])		ifTrue:			[newTop removeFlexShell].	newTop := newSketch topRendererOrSelf.	newTop bounds: self bounds.	(newTop isFlexMorph and:[myTop isFlexMorph]) ifTrue:[		"Note: This completely dumps the above #bounds: information.		We need to recompute the bounds based on the transform."		newTop transform: myTop transform copy.		newTop computeBounds].	newTop setNameTo: myName.	newTop player class bringScriptsUpToDate.	myTop delete! !!SketchMorph class methodsFor: '*eToys-instance creation' stamp: 'sw 6/13/2001 22:50'!exampleBackgroundSketch	"Answer an instance suitable for serving as a prototype for a background-field incarnation of a sketch"	| aSketch |	aSketch := self newSticky form: (ScriptingSystem formAtKey: #squeakyMouse).	aSketch setProperty: #shared toValue: true.	aSketch setProperty: #holdsSeparateDataForEachInstance toValue: true.	^ aSketch! !!SkipList methodsFor: 'accessing' stamp: 'sac 1/22/2002 18:18'!at: element ifAbsent: aBlock        "Get the key if it exists, or if it doesn't exist, get the key just after it."        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward]].        node := node next.        (self is: node theNodeFor: element) ifFalse: [^aBlock value].        ^node value! !!SkipList methodsFor: 'accessing' stamp: 'LC 6/18/2001 20:18'!maxLevel: n	| newLevel oldPointers |	newLevel := n max: level.	oldPointers := pointers.	pointers := Array new: newLevel.	splice := Array new: newLevel.	1 to: level do: [:i | pointers at: i put: (oldPointers at: i)]! !!SkipList methodsFor: 'accessing' stamp: 'sac 1/22/2002 18:33'!search: element         "Get the key if it exists, or if it doesn't exist, get the key just after it. If no key after it, return nil."        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward]].        node := node next.        ^node! !!SkipList methodsFor: 'accessing' stamp: 'LC 6/18/2001 17:30'!sortBlock: aBlock	sortBlock := aBlock! !!SkipList methodsFor: 'adding' stamp: 'sac 1/22/2002 18:23'!at: key put: value ifPresent: aBlock        | node lvl s |        node := self search: key updating: splice.        node ifNotNil: [^ aBlock value].        lvl := self randomLevel.        node := SkipListNode key: key value: value level: lvl.        level + 1 to: lvl do: [:i | splice at: i put: self].        1 to: lvl do: [:i |                                s := splice at: i.                                node atForward: i put: (s forward: i).                                s atForward: i put: node].        numElements := numElements + 1.        splice atAllPut: nil.        ^ node! !!SkipList methodsFor: 'initialization' stamp: 'LC 6/18/2001 20:08'!initialize: maxLevel	pointers := Array new: maxLevel.	splice := Array new: maxLevel.	numElements := 0.	level := 0.	Rand ifNil: [Rand := Random new]! !!SkipList methodsFor: 'node enumeration' stamp: 'LC 6/18/2001 19:30'!nodesDo: aBlock	| node |	node := pointers first.	[node notNil]		whileTrue:			[aBlock value: node.			node := node next]! !!SkipList methodsFor: 'removing' stamp: 'sac 1/22/2002 16:58'!remove: key ifAbsent: aBlock        | node i s |        "Remove and return th association containing key."        node := self search: key updating: splice.        node ifNil: [^ aBlock value].        i := 1.        [s := splice at: i.        i <= level and: [(s forward: i) == node]]                                whileTrue:                                        [s atForward: i put: (node forward: i).                                        i := i + 1].        numElements := numElements - 1.        splice atAllPut: nil.        ^ node.! !!SkipList methodsFor: 'removing' stamp: 'LC 6/18/2001 20:25'!removeAll	pointers atAllPut: nil.	splice atAllPut: nil.	numElements := 0.	level := 0.! !!SkipList methodsFor: 'private' stamp: 'LC 6/18/2001 19:26'!atForward: i put: node	level := node		ifNil: [pointers findLast: [:n | n notNil]]		ifNotNil: [level max: i].	^ pointers at: i put: node! !!SkipList methodsFor: 'private' stamp: 'sac 1/22/2002 17:50'!is: node before: element         | key |        node ifNil: [^ false].        key := node key.        ^ sortBlock                ifNil: [key < element]                ifNotNil: [(self is: key equalTo: element) ifTrue: [^ false].                        sortBlock value: key value: element]! !!SkipList methodsFor: 'private' stamp: 'LC 6/18/2001 15:37'!randomLevel	| p answer max |	p := 0.5.	answer := 1.	max := self maxLevel.	[Rand next < p and: [answer < max]]		whileTrue: [answer := answer + 1].	^ answer! !!SkipList methodsFor: 'private' stamp: 'sac 1/22/2002 18:01'!search: element updating: array        | node forward |        node := self.        level to: 1 by: -1 do: [:i |                        [forward := node forward: i.                        self is: forward before: element] whileTrue: [node := forward].                        "At this point: node < element <= forward"                        array ifNotNil: [array at: i put: node]].        node := node next.        ^ (self is: node theNodeFor: element) ifTrue: [node]! !!SkipList class methodsFor: 'instance creation' stamp: 'LC 6/18/2001 18:48'!newFrom: aCollection 	| skipList |	skipList := self new: aCollection size.	skipList addAll: aCollection.	^ skipList! !!SkipListNode methodsFor: 'accessing' stamp: 'sac 1/22/2002 17:22'!printOn: aStream        | first |        aStream                nextPut: $[.        super printOn: aStream.        aStream                nextPutAll: ']-->('.        first := true.        pointers do: [:node |                first ifTrue: [first := false] ifFalse: [aStream space].                node ifNil: [aStream nextPutAll: '*']                 ifNotNil: [node printOn: aStream]].        aStream nextPut: $)! !!SkipListNode methodsFor: 'initialization' stamp: 'LC 6/17/2001 11:54'!initialize: maxLevel	pointers := Array new: maxLevel! !!SlotInformation methodsFor: 'access' stamp: 'yo 8/1/2004 02:05'!documentation	"Answer the receiver's documentation"	documentation ifNil: [documentation := 'This is a variable defined by you.  Please edit this into your own meaningful documentation.' translated].	^ documentation! !!SlotInformation methodsFor: 'access' stamp: 'sw 11/6/1998 10:33'!documentation: d	documentation := d! !!SlotInformation methodsFor: 'access' stamp: 'sw 7/27/2001 18:19'!floatPrecision	"Answer the floatPrecision for the slot:		1.0 ->	show whole number		0.1	->	show one digit of precision		.01 ->	show two digits of precision		etc.	Initialize the precision to 1 if it is not present"	^ floatPrecision isNumber ifTrue: [floatPrecision] ifFalse: [floatPrecision := 1]! !!SlotInformation methodsFor: 'access' stamp: 'sw 9/8/1999 18:31'!floatPrecision: prec	floatPrecision := prec! !!SlotInformation methodsFor: 'access' stamp: 'sw 4/22/2002 15:10'!type	"Answer the type of the receiver, initializing it to Number if it is nil"	type isEmptyOrNil ifTrue: [^ type := #Number].	type first isUppercase ifFalse: [^ type := type capitalized].		"because of lingering, annoying issue of projects created in a plug-in image"	^ type! !!SlotInformation methodsFor: 'access' stamp: 'sw 11/6/1998 10:31'!type: aType	type := aType! !!SlotInformation methodsFor: 'access' stamp: 'sw 10/30/2000 10:16'!variableDock: vd	"Set the receiver's variableDock as indicated"	variableDock := vd! !!SlotInformation methodsFor: 'initialization' stamp: 'sw 9/27/2001 17:44'!initialize	"Initialize the receiver's instance variables to default values"	documentation := 'as yet undocumented'.	type := #Number.	floatPrecision := 0.1.! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:10'!decimalDigitLength	"Answer the number of digits printed out in base 10.	Note that this only works for positive SmallIntegers."		^ self < 10000		ifTrue: [self < 100				ifTrue: [self < 10						ifTrue: [1]						ifFalse: [2]]				ifFalse: [self < 1000						ifTrue: [3]						ifFalse: [4]]]		ifFalse: [self < 1000000				ifTrue: [self < 100000						ifTrue: [5]						ifFalse: [6]]				ifFalse: [self < 100000000						ifTrue: [self < 10000000								ifTrue: [7]								ifFalse: [8]]						ifFalse: [self < 1000000000								ifTrue: [9]								ifFalse: [10]]]]! !!SmallInteger methodsFor: 'printing' stamp: 'gk 5/25/2007 15:08'!printString	"Highly optimized version for base 10	and that we know it is a SmallInteger."		| integer next result len |	self = 0 ifTrue: [^'0'].	self < 0 ifTrue: [^'-', self negated printString].	len := self decimalDigitLength.	result := String new: len.	integer := self.	len to: 1 by: -1 do: [:i |		next := integer // 10.		result byteAt: i put: 48 + (integer - (next * 10)).		integer := next].	^result! !!SmallIntegerTest methodsFor: 'testing - printing' stamp: 'gk 5/25/2007 15:35'!testPrintStringself assert: 1 printString  = '1'.self assert: -1 printString  = '-1'.self assert: SmallInteger minVal printString  = '-1073741824'.self assert: SmallInteger maxVal printString  = '1073741823'.self assert: 12345 printString  = '12345'.self assert: -54321 printString  = '-54321'.self assert: 0 decimalDigitLength = 1.self assert: 4 decimalDigitLength = 1.self assert: 12 decimalDigitLength = 2.self assert: 123 decimalDigitLength = 3.self assert: 1234 decimalDigitLength = 4.self assert: 56789 decimalDigitLength = 5.self assert: 657483 decimalDigitLength = 6.self assert: 6571483 decimalDigitLength = 7.self assert: 65174383 decimalDigitLength = 8.self assert: 625744831 decimalDigitLength = 9.self assert: 1000001111 decimalDigitLength = 10.self assert: SmallInteger maxVal decimalDigitLength = 10.! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:48'!reverseInPlace	"Change this colleciton into its reversed.	Do not make a copy like reversed do, but change self in place."		| newFirstIndex oldSortBlock |	newFirstIndex := 1 + array size - lastIndex.	lastIndex := 1 + array size - firstIndex.	firstIndex := newFirstIndex.	array := array reversed.	oldSortBlock := (sortBlock ifNil: [[:a :b | a <= b]]) copy.	sortBlock := [:a :b | oldSortBlock value: b value: a] fixTemps! !!SortedCollection methodsFor: 'converting' stamp: 'nice 2/26/2008 22:28'!reversed	"Answer a collection that Sort elements in reverse order"		^self shallowCopy reverseInPlace! !!SortedCollection methodsFor: 'copying'!copy	| newCollection |	newCollection := self species sortBlock: sortBlock.	newCollection addAll: self.	^newCollection! !!SortedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection addLast: (aBlock value: each)].	^ newCollection! !!SortedCollection methodsFor: 'topological sort' stamp: 'hg 1/2/2002 13:34'!sortTopologically	"Plenty of room for increased efficiency in this one."	| remaining result pick |	remaining := self asOrderedCollection.	result := OrderedCollection new.	[remaining isEmpty] whileFalse: [		pick := remaining select: [:item |			remaining allSatisfy: [:anotherItem |				item == anotherItem or: [self should: item precede: anotherItem]]].		pick isEmpty ifTrue: [self error: 'bad topological ordering'].		result addAll: pick.		remaining removeAll: pick].	^self copySameFrom: result! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:36'!indexForInserting: newObject	| index low high |	low := firstIndex.	high := lastIndex.	sortBlock isNil		ifTrue: [[index := high + low // 2.  low > high]			whileFalse: 				[((array at: index) <= newObject)					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]]]		ifFalse: [[index := high + low // 2.  low > high]			whileFalse: 				[(sortBlock value: (array at: index) value: newObject)					ifTrue: [low := index + 1]					ifFalse: [high := index - 1]]].	^low! !!SortedCollection methodsFor: 'private' stamp: 'hg 12/17/2001 20:22'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n := j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di := array at: i.	dj := array at: j.	(self should: di precede: dj)		ifFalse: 			[array swap: i with: j.			 tt := di.			 di := dj.			 dj := tt].	n > 2		ifTrue:  "More than two elements."			[ij := (i + j) // 2.  "ij is the midpoint of i and j."			 dij := array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (self should: di precede: dij)			   ifTrue: 				[(self should: dij precede: dj)				  ifFalse: 					[array swap: j with: ij.					 dij := dj]]			   ifFalse:				[array swap: i with: ij.				 dij := di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k := i.				 l := j.				 [[l := l - 1.  k <= l and: [self should: dij precede: (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k := k + 1.  k <= l and: [self should: (array at: k) precede: dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self sort: i to: l.				self sort: k to: j]]! !!SortedCollectionTest methodsFor: 'basic' stamp: 'nice 2/26/2008 22:52'!testReversed		| sc1 sc2 sc3 |	sc1 := #(1 2 3 4) asSortedCollection.	self assert: sc1 reversed asArray = sc1 asArray reversed.		self		assert: sc1 reversed class = SortedCollection		description: 'reversing a SortedCollection should answer a SortedCollection'.		sc1 removeFirst; removeLast.	sc2 := sc1 reversed.	self assert: sc2 reversed asArray = sc1 asArray.		sc2 add: 3/2; add: 1/2; add: 7/2.	self assert: sc2 asArray = {7/2. 3. 2. 3/2. 1/2}.			sc3 := #(1 2 3 3.0 4) asSortedCollection.	self assert: sc3 reversed asArray = #(4 3.0 3 2 1).	self assert: (sc3 reversed at: 2) class = Float.	! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'sw 1/28/2005 00:57'!arrowAction: delta	"Do what is appropriate when an arrow on the tile is pressed; delta will be +1 or -1"	| soundChoices index |	soundChoices := self soundChoices.	index := soundChoices indexOf: literal.	self literal: (soundChoices atWrap: (index + delta)).	self playSoundNamed: literal! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'sw 1/28/2005 00:56'!mouseDown: evt	"Handle a mouse down event"	| aPoint index isUp soundChoices adjustment |	upArrow ifNotNil: [((isUp := upArrow containsPoint: (aPoint := evt cursorPoint)) or:  [downArrow containsPoint: aPoint])		ifTrue:			[soundChoices := self soundChoices.			index := soundChoices indexOf: literal ifAbsent: [1].			index > 0 ifTrue:				[adjustment := isUp ifTrue: [1] ifFalse: [-1].				self literal: (soundChoices atWrap: (index + adjustment))].			self playSoundNamed: literal.			^ self]].	self soundNameFromUser ifNotNilDo:		[:aSoundName |			self literal: aSoundName.			self playSoundNamed: literal]! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'yo 2/11/2005 16:08'!soundNameFromUser	"Obtain a sound from the user.  Exclude the items designated as being discouraged, except that if the current selection is one of those, show it anyway"	| choices |	choices := self soundChoices.	^ (SelectionMenu labels: (choices collect: [:t | t translated]) selections: self soundChoices) startUpWithCaption: 'Sounds' translated! !!SoundReadoutTile methodsFor: 'literal' stamp: 'sw 1/28/2005 00:57'!setLiteralTo: anObject width: w	"Set the literal and width of the tile as indicated"	| soundChoices index |	soundChoices := self soundChoices.	index := soundChoices indexOf: anObject.	self setLiteral: (soundChoices atWrap: index)! !!SoundTile methodsFor: 'event handling' stamp: 'sw 1/28/2005 01:49'!options	"Answer the options of the tile for an arrow"	| soundChoices |	soundChoices := self soundChoices.	^ {soundChoices. soundChoices}! !!SoundTile methodsFor: 'initialization' stamp: 'yo 7/22/2005 15:51'!initialize	"Initialize the state of the receiver. Pick the croak sound	if available, otherwise any sound."		| soundChoices startingSoundName |	super initialize.	soundChoices := self soundChoices.	startingSoundName := (soundChoices includes: 'croak')							ifTrue: ['croak']							ifFalse: [[soundChoices anyOne] ifError: ['silence']].	self addArrows; setLiteral: startingSoundName.	self labelMorph useSymbolFormat! !!SparseLargeTable methodsFor: 'accessing' stamp: 'tak 12/21/2004 16:59'!noCheckAt: index	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	(chunkIndex > self basicSize or: [chunkIndex < 1]) ifTrue: [^ defaultValue].	t := self basicAt: chunkIndex.	t ifNil: [^ defaultValue].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize))! !!SparseLargeTable methodsFor: 'accessing' stamp: 'yo 12/1/2003 19:18'!noCheckAt: index put: value	| chunkIndex t |	chunkIndex := index - base // chunkSize + 1.	chunkIndex > self basicSize ifTrue: [^ value].	t :=  self basicAt: chunkIndex.	t ifNil: [^ value].	^ t at: (index - base + 1 - (chunkIndex - 1 * chunkSize)) put: value! !!SparseLargeTable methodsFor: 'accessing' stamp: 'kwl 6/30/2006 03:02'!zapDefaultOnlyEntries	| lastIndex newInst |	1 to: self basicSize do: [:i |		(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].	].	lastIndex _ self findLastNonNilSubTable.	lastIndex = 0 ifTrue: [^ self].		newInst _ self class new: lastIndex*chunkSize chunkSize: chunkSize arrayClass: (self basicAt: lastIndex) class base: base defaultValue: defaultValue.	newInst privateSize: self size.	base to: newInst size do: [:i | newInst at: i put: (self at: i)].	1 to: newInst basicSize do: [:i |		(newInst allDefaultValueSubtableAt: i) ifTrue: [newInst basicAt: i put: nil].	].	" this is not allowed in production: self becomeForward: newInst. "	^ newInst.! !!SparseLargeTable methodsFor: 'initialization' stamp: 'yo 12/1/2003 16:58'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	| lastChunkSize |	chunkSize := aChunkSize.	size := aSize.	base := b.	defaultValue := d.	1 to: (self basicSize - 1) do: [ :in | self basicAt: in put: (aClass new: chunkSize withAll: defaultValue) ].	lastChunkSize := size \\ chunkSize.	lastChunkSize = 0 ifTrue: [lastChunkSize := chunkSize].	size = 0 		ifTrue: [self basicAt: 1 put: (aClass new: 0)]		ifFalse: [self basicAt: self basicSize put: (aClass new: lastChunkSize withAll: defaultValue)].! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 17:06'!printElementsOn: aStream	| element |	aStream nextPut: $(.	base to: size do: [:index | element := self at: index. aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!SparseLargeTable methodsFor: 'printing' stamp: 'yo 12/1/2003 15:59'!storeOn: aStream	| x |	(#(String) includes: self arrayClass name) ifTrue: 		[aStream nextPut: $'.		1 to: self size do:			[:i |			aStream nextPut: (x := self at: i).			x == $' ifTrue: [aStream nextPut: x]].		aStream nextPutAll: ''' asLargeArrayChunkSize: '.		aStream nextPutAll: self chunkSize asString.		^self].	^super storeOn: aStream! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 18:58'!allDefaultValueSubtableAt: index	| t |	t := self basicAt: index.	t ifNil: [^ true].	t do: [:e |		e ~= defaultValue ifTrue: [^ false].	].	^ true.! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 17:10'!analyzeSpaceSaving	| total elems tablesTotal nonNilTables |	total := size - base + 1.	elems := 0.	base to: size do: [:i | (self at: i) ~= defaultValue ifTrue: [elems := elems + 1]].	tablesTotal := self basicSize.	nonNilTables := 0.	1 to: self basicSize do: [:i | (self basicAt: i) ifNotNil: [nonNilTables := nonNilTables + 1]].	^ String streamContents: [:strm |		strm nextPutAll: 'total: '.		strm nextPutAll: total printString.		strm nextPutAll: ' elements: '.		strm nextPutAll: elems printString.		strm nextPutAll: ' tables: '.		strm nextPutAll: tablesTotal printString.		strm nextPutAll: ' non-nil: '.		strm nextPutAll: nonNilTables printString.	].! !!SparseLargeTable methodsFor: 'private' stamp: 'yo 12/1/2003 19:19'!privateSize: s	size := s.! !!Spline methodsFor: 'displaying'!computeCurve	"Compute an array for the coefficients."	| length extras |	length := self size.	extras := 0.	coefficients := Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(self at: i) x asFloat]						ifFalse: [(self at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver, a spline curve, approximated by straight line	segments."	| n line t x y x1 x2 x3 y1 y2 y3 |	collectionOfPoints size < 1 ifTrue: [self error: 'a spline must have at least one point'].	line := Line new.	line form: self form.	line beginPoint: 		(x := (coefficients at: 1) at: 1) rounded @ (y := (coefficients at: 5) at: 1) rounded.	1 to: (coefficients at: 1) size - 1 do: 		[:i | 		"taylor series coefficients"		x1 := (coefficients at: 2) at: i.		y1 := (coefficients at: 6) at: i.		x2 := ((coefficients at: 3) at: i) / 2.0.		y2 := ((coefficients at: 7) at: i) / 2.0.		x3 := ((coefficients at: 4) at: i) / 6.0.		y3 := ((coefficients at: 8) at: i) / 6.0.		"guess n"		n := 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3)							at: i + 1) abs + ((coefficients at: 7)							at: i + 1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t := j asFloat / n.			line endPoint: 				(x3 * t + x2 * t + x1 * t + x) rounded 							@ (y3 * t + y2 * t + y1 * t + y) rounded.			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			line beginPoint: line endPoint].		line beginPoint: 				(x := (coefficients at: 1) at: i + 1) rounded 					@ (y := (coefficients at: 5) at: i + 1) rounded.		line			displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Get the scaled and translated path of newKnots."	| newKnots newSpline |	newKnots := aTransformation applyTo: self.	newSpline := Spline new.	newKnots do: [:knot | newSpline add: knot].	newSpline form: self form.	newSpline		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Spline methodsFor: 'private'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| l v anArray |	l := a size.	l < 2 ifTrue: [^self].	l > 2	  ifTrue:		[v := Array new: l.		 v  at:  1 put: 4.0.		 anArray := Array new: l.		 anArray  at:  1 put: (6.0 * ((a  at:  1) - ((a  at:  2) * 2.0) + (a  at:  3))).		 2 to: l - 2 do:			[:i | 			v  at:  i put: (4.0 - (1.0 / (v  at:  (i - 1)))).			anArray				at:  i 				put: (6.0 * ((a  at:  i) - ((a  at:  (i + 1)) * 2.0) + (a  at:  (i + 2)))						- ((anArray  at:  (i - 1)) / (v  at:  (i - 1))))].		 point2  at: (l - 1) put: ((anArray  at:  (l - 2)) / (v  at:  (l - 2))).		 l - 2 to: 2 by: 0-1 do: 			[:i | 			point2 				at: i 				put: ((anArray  at:  (i - 1)) - (point2  at:  (i + 1)) / (v  at:  (i - 1)))]].	point2 at: 1 put: (point2  at:  l put: 0.0).	1 to: l - 1 do:		[:i | point1 				at: i 				put: ((a at: (i + 1)) - (a  at:  i) - 						((point2  at:  i) * 2.0 + (point2  at:  (i + 1)) / 6.0)).		      point3 at: i put: ((point2  at:  (i + 1)) - (point2  at:  i))]! !!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm := Form extent: 2@2.	aForm  fillBlack.	splineCurve := Spline new.	splineCurve form: aForm.	flag := true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag:=false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 3/10/2008 23:13'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	| p |	p := aRadix lowBit - 1.	^k positive		ifTrue: [(m * (((aRadix bitShift: p negated) raisedToInteger: k))) asFloat timesTwoPower: p*k]		ifFalse: [(Fraction numerator: m denominator: (((aRadix bitShift: p negated) raisedToInteger: k negated) bitShift: p*k negated)) asFloat]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:50'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa decimalMultiplier decimalFraction value numberOfTrailingZeroInFractionPart |	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base ifFail: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].		(sourceStream nextMatchAll: 'Infinity')			ifTrue: [^ neg					ifTrue: [Float infinity negated]					ifFalse: [Float infinity]].		^self expected: ['a digit between 0 and 9']].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			(sourceStream peekFor: $-)				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [fractionPart := self						nextUnsignedIntegerBase: base						ifFail: [sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated]								ifFalse: [integerPart]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			self readExponent				ifFalse: [self readScale						ifTrue: [decimalMultiplier := base raisedTo: numberOfNonZeroFractionDigits.							decimalFraction := integerPart * decimalMultiplier + fractionPart / decimalMultiplier.							neg								ifTrue: [decimalFraction := decimalFraction negated].							^ ScaledDecimal newFromNumber: decimalFraction scale: scale]].			fractionPart isZero				ifTrue: [mantissa := integerPart								// (base raisedTo: numberOfTrailingZeroInIntegerPart).					exponent := exponent + numberOfTrailingZeroInIntegerPart]				ifFalse: [mantissa := integerPart								* (base raisedTo: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).					exponent := exponent - numberOfNonZeroFractionDigits].			"very naive algorithm"			value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.			^ neg				ifTrue: [value isZero						ifTrue: [Float negativeZero]						ifFalse: [value negated]]				ifFalse: [value]]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:44'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in	instVar "		^ self		nextUnsignedIntegerBase: aRadix		ifFail: [self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:27'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in instVar"		| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[sourceStream atEnd				or: [digit := sourceStream next digitValue.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	nDigits = 0		ifTrue: [errorBlock value].	^value! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'em 3/31/2005 10:56'!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aMenu aBackground |	(bgs := self backgrounds) size == 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get' translated.		^ self insertCard].	aMenu := SelectionMenu		labels: 		(bgs collect: [:bg | bg externalName])		selections: 	bgs.	(aBackground := aMenu startUp) ifNotNil:		[self insertCardOfBackground: aBackground]! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/18/2002 02:02'!insertCardOfBackground: aBackground	"Insert a new card of the given background and have it become the current card"	| newCard |	newCard :=  aBackground newCard.	self privateCards add: newCard after: self currentCard.	self goToCard: newCard! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromAFile	"Using the current background, create new cards by reading in data from a fileThe data are in each record are expected to be tab-delimited, and to occur in the same order as the instance variables of the current-background's cards "	| aFileStream |	(aFileStream := FileList2 modalFileSelector) ifNil: [^ Beeper beep].	self addCardsFromString: aFileStream contentsOfEntireFile.	aFileStream close! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromClipboardData	"Using the current background, paste data from the (textual) clipboard to create new records.  The data are in each record are expected to be tab-delimited, and to occur in the same order as the instance variables of the current-background's cards "	| clip |	(clip := Clipboard clipboardText) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: clip! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromClipboardDataForInstanceVariables: slotNames	"Using the current background, paste data from the (textual) clipboard to create new records.  No senders, but can be usefully called manually for selectively bringing in data in oddball format."	| clip |	(clip := Clipboard clipboardText) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: clip slotNames: slotNames! !!StackMorph methodsFor: 'background' stamp: 'nb 6/17/2003 12:25'!addCardsFromFile: fileStream	"Using the current background, take tab delimited data from the file to create new records."	| aString |	(aString := fileStream contentsOfEntireFile) isEmptyOrNil ifTrue: [^ Beeper beep].	self addCardsFromString: aString! !!StackMorph methodsFor: 'background' stamp: 'sw 11/2/2002 17:56'!changeInstVarOrder	"Change the order of the receiver's instance variables"	| reply |	reply := FillInTheBlank request: 'rearrange, then accept; or cancel' initialAnswer:		((self currentPage player class instVarNames asArray collect: [:v | v asSymbol]) storeString copyWithoutAll: #($# $( $))) asString.	reply isEmptyOrNil ifTrue: [^ self].	self flag: #deferred.  "Error checking and graceful escape wanted"	self currentPage player class resortInstanceVariables: (Compiler evaluate:		('#(', reply, ')'))! !!StackMorph methodsFor: 'background' stamp: 'em 3/30/2005 14:47'!insertAsBackground: newPage resize: doResize	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| aName |	aName := FillInTheBlank request: 'What should we call this new background?' translated initialAnswer: 'alternateBackground' translated.	aName isEmptyOrNil ifTrue: [^ self].	newPage beSticky.	doResize ifTrue: [newPage extent: currentPage extent].	newPage beAStackBackground.	newPage setNameTo: aName.	newPage vResizeToFit: false.	pages isEmpty		ifTrue: [pages add: newPage]		ifFalse: [pages add: newPage after: currentPage].	self privateCards add: newPage currentDataInstance after: currentPage currentDataInstance.	self nextPage.! !!StackMorph methodsFor: 'background' stamp: 'tk 10/30/2001 19:01'!makeNewBackground	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| newPage |	(newPage := PasteUpMorph newSticky) color: self color muchLighter.	newPage borderWidth: currentPage borderWidth; borderColor: currentPage borderColor.	self insertAsBackground: newPage resize: true. ! !!StackMorph methodsFor: 'background' stamp: 'sw 3/18/2002 02:14'!sortByField: varName	"Perform a simple reordering of my cards, sorting by the given field name.  If there are multiple backgrounds, then sort the current one, placing all its cards first, followed by all others in unchanged order"	| holdCards thisClassesInstances sortedList |	holdCards := self privateCards copy.	thisClassesInstances := self privateCards select: [:c | c isKindOf: self currentCard class].	sortedList := thisClassesInstances asSortedCollection:		[:a :b | (a instVarNamed: varName) asString <= (b instVarNamed: varName) asString].	sortedList := sortedList asOrderedCollection.	holdCards removeAllFoundIn: sortedList.	self privateCards:  (sortedList asOrderedCollection, holdCards).	self goToFirstCardOfStack! !!StackMorph methodsFor: 'background' stamp: 'sw 12/6/2001 22:08'!sortCards	"Let the user provide an inst var on which to sort the cards of a background."	| names aMenu |	names := self currentPage player class instVarNames.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose field by which to sort:'.	names do: [:n | aMenu add: n selector: #sortByField: argument: n].	aMenu popUpInWorld! !!StackMorph methodsFor: 'card access' stamp: 'sw 10/23/2000 16:24'!browseCardClass	"Browse the class of the current card"	| suffix |	suffix := self currentCard class name numericSuffix.	HierarchyBrowser newFor: self currentCard class labeled: 'Background ', suffix asString! !!StackMorph methodsFor: 'card access' stamp: 'sd 11/13/2003 21:03'!deleteCard	"Delete the current card from the stack"	| aCard |	aCard := self currentCard.	self privateCards size = 1 ifTrue: [^ Beeper beep].	(self confirm: 'Really delete this card and all of its data?' translated) ifTrue:		[self goToNextCardInStack.		self privateCards remove: aCard].! !!StackMorph methodsFor: 'card access' stamp: 'em 3/31/2005 10:23'!goToCard	"prompt the user for an ordinal number, and use that as a basis for choosing a new card to install in the receiver"	| reply index |	reply := FillInTheBlank request: 'Which card number? ' translated initialAnswer: '1'.	reply isEmptyOrNil ifTrue: [^ self].	((index := reply asNumber) > 0 and: [index <= self privateCards size])		ifFalse: [^ self inform: 'no such card'].	self goToCard: (self privateCards at: index)! !!StackMorph methodsFor: 'card access' stamp: 'sw 11/8/2002 15:15'!goToCard: destinationCard	"Install the indicated destinationCard as the current card in the receiver.  Any viewer currently open on the current card will get retargeted to look at the new one."	| aBackground existingCard oldViewers |	destinationCard == self currentCard ifTrue: [^ self].	self currentPlayerDo:		[:aPlayer | aPlayer runAllClosingScripts].   "Like HyperCard 'on closeCard'"	aBackground := self backgroundWithCard: destinationCard.	existingCard := aBackground currentDataInstance.	oldViewers := existingCard ifNil: [#()] ifNotNil: [existingCard allOpenViewers].	aBackground installAsCurrent: destinationCard.	aBackground setProperty: #myStack toValue: self.	"pointer cardMorph -> stack"	aBackground ~~ currentPage ifTrue:		[self goToPageMorph: aBackground runTransitionScripts: false].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts] .  "Like HyperCard 'on opencard'"	oldViewers do: [:aViewer | aViewer retargetFrom: existingCard to: destinationCard]! !!StackMorph methodsFor: 'card access' stamp: 'nb 6/17/2003 12:25'!goToFirstCardInBackground	"Install the initial card in the current background as the current card in the stack"	| kind |	kind := currentPage player class baseUniclass.	self goToCard: (self privateCards detect: [:aCard | aCard isKindOf: kind] ifNone: [^ Beeper beep])! !!StackMorph methodsFor: 'card access' stamp: 'nb 6/17/2003 12:25'!goToLastCardInBackground	"Install the final card in the current background as the current card"	| kind |	kind := currentPage player class baseUniclass.	self goToCard: (self privateCards reversed detect: [:aCard | aCard isKindOf: kind] ifNone: [^ Beeper beep])! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!insertCardOfBackground: aBackground withDataFrom: aLine forInstanceVariables: slotNames	"Insert a new card of the given background and have it become the current card. "	| newCard |	newCard :=  aBackground newCard.	self privateCards add: newCard after: self currentCard.	newCard absorbBackgroundDataFrom: aLine forInstanceVariables: slotNames.	self goToCard: newCard! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 01:57'!makeCurrentCardFirstInStack	"Move the current card such that it becomes the first card in the stack"	| aCard |	aCard := self currentCard.	self privateCards remove: aCard ifAbsent: [];		addFirst: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:03'!makeCurrentCardLastInStack	"Move the current card such that it becomes the last card in the stack"	| aCard |	aCard := self currentCard.	self privateCards remove: aCard ifAbsent: [];		addLast: aCard.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:08'!moveCardOnePositionEarlier	"Move the current card such that its ordinal position is one fewer than it formerly was.  If the current card is already the first one one in the stack, then do nothing"	| aCard aPosition |	aCard := self currentCard.	aCard == self privateCards first ifTrue: [^ self].	aPosition := self privateCards indexOf: aCard.	self privateCards remove: aCard;		add: aCard afterIndex: (aPosition - 2).	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:05'!moveCardOnePositionLater	"Move the current card such that its ordinal position is one greater than it formerly was.  If the current card is already the last one one in the stack, then do nothing"	| aCard aPosition privateCards |	aCard := self currentCard.	privateCards := self privateCards.	aCard == privateCards last ifTrue: [^ self].	aPosition := privateCards indexOf: aCard.	privateCards remove: aCard.	privateCards add: aCard afterIndex: aPosition.	self currentPage flash! !!StackMorph methodsFor: 'card access' stamp: 'sw 3/18/2002 02:51'!privateCards: aCollection	"Private - Make my cards be te given colllection"	cards := aCollection! !!StackMorph methodsFor: 'card in a stack' stamp: 'sw 3/18/2002 02:03'!goToNextCardInStack	"Make the card *after* the current card become the current card"	| anIndex newCard |	anIndex := self privateCards indexOf: currentPage currentDataInstance.	newCard := self privateCards atWrap: anIndex + 1.	self goToCard: newCard! !!StackMorph methodsFor: 'card in a stack' stamp: 'sw 3/18/2002 02:01'!goToPreviousCardInStack	"Install the previous card as my current one"	| anIndex newCard |	anIndex := self privateCards indexOf: currentPage currentDataInstance.	newCard := self privateCards atWrap: anIndex - 1.	self goToCard: newCard! !!StackMorph methodsFor: 'controls' stamp: 'sw 10/30/2000 16:31'!pageControlsMorphFrom: controlSpecs	"Answer a controls morph derived from the spec supplied"	| controls |	controls := super pageControlsMorphFrom: controlSpecs.	controls eventHandler: nil.  "not grabbable"	^ controls! !!StackMorph methodsFor: 'initialization' stamp: 'sw 6/5/2003 04:04'!addPane: aPane paneType: aType	| anIndex |	anIndex := self insertionIndexForPaneOfType: aType.	self privateAddMorph: aPane atIndex: anIndex! !!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:12'!initialize	"Initialize the stack"	| initialBackground |	super initialize.	initialBackground := pages first.	initialBackground extent: (640@480); beSticky.	initialBackground beAStackBackground.	self beUnsticky.	self setProperty: #controlsAtBottom toValue: true.	self privateCards: (OrderedCollection with: initialBackground currentDataInstance)."self currentHand attachMorph: StackMorph authoringPrototype"! !!StackMorph methodsFor: 'initialization' stamp: 'sw 3/18/2002 02:13'!initializeWith: aCardMorph	"Install the card inside a new stack.  Make no border or controls, so I the card's look is unchanged.  Card already has a CardPlayer."		| wld |	wld := aCardMorph world.	self initialize.	self pageSize: aCardMorph extent.	self borderWidth: 0; layoutInset: 0; color: Color transparent.	pages := Array with: aCardMorph.	currentPage := aCardMorph.	self privateCards: (OrderedCollection with: currentPage currentDataInstance).	currentPage beAStackBackground.	self position: aCardMorph position.	submorphs last delete.	self addMorph: currentPage.		self showPageControls: self fullControlSpecs.	wld addMorph: self.! !!StackMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:14'!addBookMenuItemsTo: aMenu hand: aHandMorph	"Add book-related items to the given menu"	| controlsShowing subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'previous card' translated action: #goToPreviousCardInStack.	subMenu add: 'next card' translated action: #goToNextCardInStack.	subMenu add: 'go to card...' translated action: #goToCard.	subMenu add: 'insert a card' translated action: #insertCard.	subMenu add: 'delete this card' translated action: #deleteCard.	controlsShowing := self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide card controls' translated action: #hidePageControls.			subMenu add: 'fewer card controls' translated action: #fewerPageControls]		ifFalse:			[subMenu add: 'show card controls' translated action: #showPageControls].	subMenu addLine.	subMenu add: 'sound effect for all backgrounds' translated action: #menuPageSoundForAll:.	subMenu add: 'sound effect this background only' translated action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all backgrounds' translated action: #menuPageVisualForAll:.	subMenu add: 'visual effect this background only' translated action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' translated action: #sortPages:.	subMenu add: 'uncache page sorter' translated action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	subMenu  addUpdating: #showingFullScreenString action: #toggleFullScreen.	subMenu addLine.	subMenu add: 'search for text' translated action: #textSearch.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page' translated action: #pasteBookPage].	subMenu add: 'send all pages to server' translated action: #savePagesOnURL.	subMenu add: 'send this page to server' translated action: #saveOneOnURL.	subMenu add: 'reload all from server' translated action: #reload.	subMenu add: 'copy page url to clipboard' translated action: #copyUrl.	subMenu add: 'keep in one file' translated action: #keepTogether.	subMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: 'book...' translated subMenu: subMenu! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:06'!findText: wants	"Turn to the next card that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText := self valueOfProperty: #allText ifAbsent: [#()].	here := self privateCards identityIndexOf: self currentCard ifAbsent: [1].	fromHereOn := here+1 to: self privateCards size.	startToHere := 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys := wants allButFirst.		strings := allText at: here.		good := true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord := false.				strings do: [:longString |					(longString findWordStart: searchString startingAt: 1) > 0 ifTrue: [							thisWord := true]].				good := thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer := self valueOfProperty: #searchContainer.			oldIndex := self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				cardNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn := here to: self privateCards size].	"do search this page"	"other pages"	fromHereOn do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	startToHere do: [:cardNum |		(self findText: wants inStrings: (allText at: cardNum) startAt: 1 container: nil 				cardNum: cardNum) 					ifTrue: [^ true]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!StackMorph methodsFor: 'menu' stamp: 'gm 2/22/2003 13:13'!findText: keys inStrings: rawStrings startAt: startIndex container: oldContainer cardNum: cardNum 	"Call once to search a card of the stack.  Return true if found and highlight the text.  oldContainer should be NIL.  	(oldContainer is only non-nil when (1) doing a 'search again' and (2) the page is in memory and (3) keys has just one element.  oldContainer is a TextMorph.)"	| good thisWord index insideOf place container start strings old |	good := true.	start := startIndex.	strings := oldContainer ifNil: 					["normal case"					rawStrings]				ifNotNil: [self currentPage allStringsAfter: oldContainer text].	keys do: 			[:searchString | 			"each key"			good 				ifTrue: 					[thisWord := false.					strings do: 							[:longString | 							(index := longString findWordStart: searchString startingAt: start) > 0 								ifTrue: 									[thisWord not & (searchString == keys first) 										ifTrue: 											[insideOf := longString.											place := index].									thisWord := true].							start := 1].	"only first key on first container"					good := thisWord]].	good 		ifTrue: 			["all are on this page"			"wasIn := (pages at: pageNum) isInMemory."			self goToCardNumber: cardNum			"wasIn ifFalse: ['search again, on the real current text.  Know page is in.'.			^ self findText: keys 				inStrings: ((pages at: pageNum) allStringsAfter: nil)         recompute it					startAt: startIndex container: oldContainer 				pageNum: pageNum]"].	(old := self valueOfProperty: #searchContainer) ifNotNil: 			[(old respondsTo: #editor) 				ifTrue: 					[old editor selectFrom: 1 to: 0.	"trying to remove the previous selection!!"					old changed]].	good 		ifTrue: 			["have the exact string object"			(container := oldContainer) ifNil: 					[container := self 								highlightText: keys first								at: place								in: insideOf]				ifNotNil: 					[container userString == insideOf 						ifFalse: 							[container := self 										highlightText: keys first										at: place										in: insideOf]						ifTrue: 							[(container isTextMorph) 								ifTrue: 									[container editor selectFrom: place to: keys first size - 1 + place.									container changed]]].			self setProperty: #searchContainer toValue: container.			self setProperty: #searchOffset toValue: place.			self setProperty: #searchKey toValue: keys.	"override later"			ActiveHand newKeyboardFocus: container.			^true].	^false! !!StackMorph methodsFor: 'menu' stamp: 'em 3/31/2005 10:20'!findViaTemplate	| list pl cardInst |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	list := self templateMatches.	list isEmpty ifTrue: [^ self inform: 'No matches were found.Be sure the current card is mostly blankand only has text you want to match.' translated]. 	"put up a PluggableListMorph"	cardInst := self currentCard.	cardInst matchIndex: 0.	"establish entries"	cardInst results at: 1 put: list.	self currentPage setProperty: #myStack toValue: self.	"way to get back"	pl := PluggableListMorph new			on: cardInst list: #matchNames			selected: #matchIndex changeSelected: #matchIndex:			menu: nil "#matchMenu:shifted:" keystroke: nil.	ActiveHand attachMorph: (self formatList: pl).! !!StackMorph methodsFor: 'menu' stamp: 'tk 6/2/2001 11:40'!formatList: pl	| rr ff |	"Turn this plugglable list into a good looking morph."	pl color: Color transparent; borderWidth: 0.	pl font: ((TextStyle named: #Palatino) fontOfSize: 14).	pl toggleCornerRounding; width: 252; retractableOrNot; hResizing: #spaceFill.	rr := (RectangleMorph new) toggleCornerRounding; extent: pl extent + (30@30).	rr color: self currentPage color; fillStyle: (ff := self currentPage fillStyle copy).	ff isGradientFill ifTrue: [		rr fillStyle direction: (ff direction * self currentPage extent / rr extent) rounded.		rr fillStyle origin: rr bounds origin].	rr addMorph: pl.	rr layoutPolicy: TableLayout new.	rr layoutInset: 10@15; cellInset: 10@15; wrapDirection: #leftToRight.	rr listCentering: #center; borderWidth: 5; borderColor: #raised.	"Up and down buttons on left with arrows in a holder."	"lb := (RectangleMorph new) color: transparent; borderWidth: 0."	^ rr! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:07'!getAllText	"Collect the text for each card.  Just point at strings so don't have to recopy them.  (Parallel array of urls for ID of cards.  Remote cards not working yet.)	allText = Array (cards size) of arrays (fields in it) of strings of text.	allTextUrls = Array (cards size) of urls or card numbers."	| oldUrls oldStringLists allText allTextUrls aUrl which |	self writeSingletonData.	oldUrls := self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists := self valueOfProperty: #allText ifAbsent: [#()].	allText := self privateCards collect: [:pg | OrderedCollection new].	allTextUrls := Array new: self privateCards size.	self privateCards doWithIndex: [:aCard :ind | aUrl := aCard url.  aCard isInMemory 		ifTrue: [(allText at: ind) addAll: (aCard allStringsAfter: nil).			aUrl ifNil: [aUrl := ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of cards on server may be different.  (later keep up to date?)"			"*** bug in this algorithm if delete a page?"			which := oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!StackMorph methodsFor: 'menu' stamp: 'dgd 9/29/2004 20:47'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack' translated.	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	aMenu addList: {		{'find...' translated.					#textSearch}.		{'find via this template' translated.			#findViaTemplate}.		{'show designations' translated. 			#showDesignationsOfObjects}.		{'explain designations' translated.			#explainDesignations}.		#-.		{'previous card' translated. 				#goToPreviousCardInStack}.		{'next card' translated. 				#goToNextCardInStack}.		{'first card' translated. 				#goToFirstCardOfStack}.		{'last card' translated. 				#goToLastCardOfStack}.		{'go to card...' translated. 				#goToCard}.		#-.		{'add a card of this background' translated. 		#insertCard}.		{'add a card of background...' translated.		#insertCardOfBackground}.		{'make a new background...' translated. 		#makeNewBackground}.		#-.		{'insert cards from clipboard data' translated.		#addCardsFromClipboardData.	'Create new cards from a formatted string on the clipboard' translated}.		{'insert cards from a file...' translated.		#addCardsFromAFile.		'Create new cards from data in a file' translated}.		#-.		{'instance variable order...' translated.		#changeInstVarOrder.		'Caution -- DANGER. Change the order of the variables on the cards' translated}.		{'be defaults for new cards' translated. 		#beDefaultsForNewCards.		'Make these current field values be the defaults for their respective fields on new cards' translated}.		    {'sort cards by...' translated.			#sortCards.			'Sort all the cards of the current background using some field as the sort key' translated}.		#-.		{'delete this card' translated. 			#deleteCard}.		{'delete all cards *except* this one' translated.	#deleteAllCardsExceptThisOne}.		#-.		{'move card to front of stack' translated.		#makeCurrentCardFirstInStack}.		{'move card to back of stack' translated.		#makeCurrentCardLastInStack}.		{'move card one position earlier' translated.		#moveCardOnePositionEarlier}.		{'move card one position later' translated.		#moveCardOnePositionLater}.		#-.		{'scripts for this background' translated.		#browseCardClass}.		#-.		{'debug...' translated.					#offerStackDebugMenu}.		{'bookish items...' translated. 			#offerBookishMenu}}.	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!StackMorph methodsFor: 'menu' stamp: 'dgd 9/29/2004 20:47'!offerStackDebugMenu	"Put up a menu offering debugging items for the stack"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Stack debugging'.	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	aMenu addList: #(		('reassess'								reassessBackgroundShape)		('relax grip on variable names'			relaxGripOnVariableNames)		('commit card data'						commitCardData)		-		('browse card uniclass'					browseCardClass)		('inspect card'							inspectCurrentCard)		('inspect background'					inspectCurrentBackground)		('inspect stack'							inspectCurrentStack)).	aMenu popUpInWorld: (self world ifNil: [self currentWorld])! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 01:58'!templateMatches	| template docks keys bkg |	"Current card is the template.  Only search cards in this background. Look at cards directly (not allText). Key must be found in the same field as in the template.  HyperCard style (multiple starts of words).  	Put results in a list, outside the stack."	template := self currentCard.	template commitCardPlayerData.	docks := template class variableDocks.	(keys := template asKeys) ifNil: [^ #()]. "nothing to match against"	bkg := self currentPage.	^ self privateCards select: [:cardPlayer | 		(((cardPlayer == template) not) and: [cardPlayer costume == bkg]) 			and: [cardPlayer match: keys fields: docks]].! !!StackMorph methodsFor: 'menu' stamp: 'sw 3/18/2002 02:00'!writeSingletonData	"Backgrounds that have just one card, may never get their data written into a CardPlayer. Make sure we do it."	| sieve |	sieve := IdentityDictionary new.	pages do: [:pp | sieve at: pp put: 0].	self privateCards do: [:cc | sieve at: cc costume put: (sieve at: cc costume) + 1].	sieve associationsDo: [:ass | 		ass value = 1 ifTrue:			[ass key player commitCardPlayerDataFrom: ass key]].			"If currently showing card, may be some trouble... <- tk note 5/01"! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 3/18/2002 02:20'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs."	| coll |	coll := OrderedCollection new.	self privateCards do: [:cd | 		cd privateMorphs ifNotNil: [coll addAll: cd privateMorphs]].	^ coll! !!StackMorph methodsFor: 'submorphs-accessing' stamp: 'sw 6/5/2003 04:01'!insertionIndexForPaneOfType: aType	| naturalIndex insertionIndex |	naturalIndex := self naturalPaneOrder indexOf: aType.	insertionIndex := 1.	(self naturalPaneOrder copyFrom: 1 to: (naturalIndex - 1)) do: "guys that would precede"		[:sym | (self hasSubmorphWithProperty: sym)			ifTrue:				[insertionIndex := insertionIndex + 1]].	^ insertionIndex! !!StackMorph class methodsFor: 'authoring prototype' stamp: 'nk 7/12/2003 08:59'!designationsExplainer	"Answer a morph that contains designation explanation"	| aMorph aSwatch aTextMorph |	aMorph := AlignmentMorph newColumn color: Color black; layoutInset: 1.	#((green		'Shared items onBackground.Exact same itemshared by every card')	(orange'Data items onBackgroundEach card has itsown data')	(red'Instance-specificitemsuniqueto this card')) do:	[:aPair |		aSwatch := AlignmentMorph new extent: 132 @80; color: (Color perform: aPair first); lock.		aSwatch hResizing: #rigid; vResizing: #rigid; layoutInset: 0.		aSwatch borderColor: Color black.		aTextMorph := TextMorph new string: aPair second fontName: Preferences standardEToysFont familyName size: 18.		aTextMorph width: 130.		aTextMorph centered.		aSwatch addMorphBack: aTextMorph.		aMorph addMorphBack: aSwatch].	aMorph hResizing: #shrinkWrap; vResizing: #shrinkWrap.	^ aMorph	"StackMorph designationsExplainer openInHand"! !!StackMorph class methodsFor: 'misc' stamp: 'tk 12/14/2001 19:23'!discoverSlots: aMorph	"Examine the parts of the morph for ones that couldHoldSeparateData.  Return a pair of lists: Named morphs, and unnamed morphs (which may be labels, and non-data).  Examine all submorphs."	| named unnamed got sn generic |	named := OrderedCollection new.	unnamed := OrderedCollection new.	aMorph submorphsDo: [:direct | 		got := false.		direct allMorphsDo: [:sub |			sub couldHoldSeparateDataForEachInstance ifTrue: [				(sn := sub knownName) ifNotNil: [					generic := (#('Number (fancy)' 'Number (mid)' 'Number (bare)')									includes: sn).					(sn beginsWith: 'shared' "label") | generic ifFalse: [						named add: sub.						got := true]]]].		got ifFalse: [unnamed add: direct]].	^ Array with: named with: unnamed		! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!nextCardButton	"Answer a button that advances the user to the next card in the stack"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToNextCardInStack; label: '>'; color: Color yellow; borderWidth: 0.	aButton setNameTo: 'next'.	^ aButton! !!StackMorph class methodsFor: 'navigation buttons' stamp: 'sw 10/27/2000 10:53'!previousCardButton	"Answer a button that will take the user to the preceding card in the stack"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #goToPreviousCardInStack; label: '<'; color: Color yellow ; borderWidth: 0.	aButton setNameTo: 'previous'.	^ aButton! !!StackMorph class methodsFor: 'scripting' stamp: 'sw 10/9/2000 07:43'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book := self new markAsPartsDonor.	book pageSize: (480 @ 320); color: (Color gray: 0.7).	book borderWidth: 1; borderColor: Color black.	book currentPage extent: book pageSize.	book showPageControls: book fullControlSpecs.	^ book"self currentHand attachMorph: StackMorph authoringPrototype"! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'ar 6/3/2007 21:47'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto Squeak."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name :=  (FilePath pathName: rawName isEncoded: true) asSqueakPathName.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil ifTrue:[^nil].	self register.	rwmode := false.	buffer1 := String new: 1.! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 11/1/2004 07:47'!addCustomEventFor: registrantClass named: aSymbol help: helpString targetMorphClass: targetClass	| registration |	registration := self customEventsRegistry at: aSymbol ifAbsentPut: [ IdentityDictionary new ].	registration at: registrantClass put: { helpString. targetClass }.! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 7/20/2003 12:37'!removeCustomEventNamed: aSymbol for: registrant	| registration helpString |	registration := self customEventsRegistry at: aSymbol ifAbsent: [ ^nil ].	helpString := registration removeKey: registrant ifAbsent: [].	registration isEmpty ifTrue: [ self customEventsRegistry removeKey: aSymbol ].	^helpString! !!StandardScriptingSystem methodsFor: '*eToys-customevents-custom events' stamp: 'nk 9/26/2003 23:26'!removeUserCustomEventNamed: eventName	| retval |	retval := self currentWorld removeUserCustomEventNamed: eventName.	"Vocabulary addStandardVocabulary: UserCustomEventNameType new."	Vocabulary customEventsVocabulary.	SymbolListTile updateAllTilesForVocabularyNamed: #CustomEvents.	^retval! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 5/2/1998 14:01'!readFormsFromFileNamed: aFileName	"Read the entire FormDictionary in from a designated file on disk"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: aFileName.	FormDictionary := aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'EToyForms22Apr'"! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 9/14/2000 21:29'!readFormsFromFileNamed: aFileName andStoreIntoGlobal: globalName	"Read the a FormDictionary in from a designated file on disk and save it in the designated global"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: aFileName.	Smalltalk at: globalName put: aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'SystemFormsFromFwdF.forms' andStoreIntoGlobal: #FormsTemp"	"ScriptingSystem saveForm:  (FormsTemp at: #StackElementDesignationHelp) atKey: #StackElementDesignationHelp"! !!StandardScriptingSystem methodsFor: '*eToys-form dictionary' stamp: 'sw 4/23/1999 11:24'!restorePrivateGraphics	"ScriptingSystem restorePrivateGraphics"	| aReferenceStream |	aReferenceStream := ReferenceStream fileNamed: 'disGraphics'.	self mergeGraphicsFrom: aReferenceStream next.	aReferenceStream close.! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 5/3/1999 22:40'!prototypicalHolder	| aHolder |	aHolder := PasteUpMorph authoringPrototype color: Color orange muchLighter; borderColor: Color orange lighter.	aHolder setNameTo: 'holder'; extent: 160 @ 110.	^ aHolder behaveLikeHolder.! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 10/27/1998 13:35'!resetStandardPartsBin	"ScriptingSystem resetStandardPartsBin"	StandardPartsBin := nil! !!StandardScriptingSystem methodsFor: '*eToys-parts bin' stamp: 'sw 7/3/2001 08:01'!tilesForQuery: expressionString label: aLabel	"Answer scripting tiles that represent the query,"	| aPhrase aTile |	aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: expressionString  label: aLabel.	aPhrase addMorph: aTile.	^ aPhrase! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:40'!goButton	| aButton |	aButton :=  ThreePhaseButtonMorph new.	aButton image:  (ScriptingSystem formAtKey: 'GoPicOn');			offImage: (ScriptingSystem formAtKey: 'GoPic');			pressedImage: (ScriptingSystem formAtKey: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: aButton);			actWhen: #buttonUp;			target: self;			setNameTo: 'Go Button';			setBalloonText:'Resume running all paused scripts' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'sw 1/23/2001 11:39'!scriptControlButtons	"Answer a composite object that serves to control the stop/stop/go status of a Presenter"	| wrapper |	wrapper := AlignmentMorph newRow setNameTo: 'script controls'.	wrapper vResizing: #shrinkWrap.	wrapper hResizing: #shrinkWrap.	wrapper addMorph: self stopButton.	wrapper addMorphBack: self stepButton.	wrapper addMorphBack: self goButton.	wrapper beTransparent.	^ wrapper! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:41'!stepButton	| aButton |	self flag: #deferred.  "ambiguity about recipients"	aButton := ThreePhaseButtonMorph new.		aButton			image:  (ScriptingSystem formAtKey: 'StepPicOn');			offImage: (ScriptingSystem formAtKey: 'StepPic');			pressedImage:  (ScriptingSystem formAtKey: 'StepPicOn');			arguments: (Array with: nil with: aButton);		 	actionSelector: #stepStillDown:with:; 			target: self;			setNameTo: 'Step Button'; 			actWhen: #whilePressed;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every paused script exactly once.  Keep the mouse button down over "Step" and everything will keep running until you release it' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'dgd 9/19/2003 14:41'!stopButton	"Answer a new button that can serve as a stop button"	| aButton |	aButton := ThreePhaseButtonMorph new.	aButton		image:  (ScriptingSystem formAtKey: 'StopPic');		offImage: (ScriptingSystem formAtKey: 'StopPic');		pressedImage:  (ScriptingSystem formAtKey: 'StopPicOn').		aButton actionSelector: #stopUp:with:; 		arguments: (Array with: nil with: aButton);		actWhen: #buttonUp;		target: self;		setNameTo: 'Stop Button'; 		setBalloonText: 'Pause all ticking scripts.' translated.	^ aButton! !!StandardScriptingSystem methodsFor: '*eToys-script-control' stamp: 'sw 11/11/1998 15:16'!stopUp: dummy with: theButton	| aPresenter |	(aPresenter := theButton presenter) flushPlayerListCache.  "catch guys not in cache but who're running"	aPresenter stopRunningScriptsFrom: theButton! !!StandardScriptingSystem methodsFor: '*eToys-universal slots & scripts' stamp: 'sw 1/4/2005 02:20'!acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: currentName asSlotNameIn: aPlayer world: aWorld	"Produce an acceptable slot name, derived from the current name, for aPlayer.  This method will always return a valid slot name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix putative |	aString := originalString asIdentifier: false.  "get an identifier not lowercase"	stemAndSuffix := aString stemAndNumericSuffix.	proscribed := #(self super thisContext costume costumes dependents #true #false size), aPlayer class allInstVarNames.	stem := stemAndSuffix first.	suffix := stemAndSuffix last.	putative := aString asSymbol.		[(putative ~~ currentName) and: [(proscribed includes: putative)		or:	[(aPlayer respondsTo: putative)		or:	[Smalltalk includesKey: putative]]]]	whileTrue:		[suffix := suffix + 1.		putative := (stem, suffix printString) asSymbol].	^ putative! !!StandardScriptingSystem methodsFor: '*eToys-universal slots & scripts' stamp: 'sw 9/27/2001 04:08'!systemSlotNamesOfType: aType	"Answer the type of the slot name, or nil if not found."		| aList |	self flag: #deferred.  "Hard-coded etoyVocabulary needed here to make this work."	aList := OrderedCollection new.	Vocabulary eToyVocabulary methodInterfacesDo:		 [:anInterface |			anInterface resultType = aType ifTrue:				[aList add: anInterface selector]].	^ aList! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 10/30/2000 16:37'!allKnownClassVariableNames	"Answer a set of all the knwon class variable names in the system.  This normally retrieves them from a cache, and at present there is no organized mechanism for invalidating the cache.  The idea is to avoid, in the References scheme, names that may create a conflict"	^ ClassVarNamesInUse ifNil: [ClassVarNamesInUse := self allClassVarNamesInSystem]	"ClassVarNamesInUse := nil.	Time millisecondsToRun: [ScriptingSystem allKnownClassVariableNames]"! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 6/27/2004 11:11'!helpStringOrNilForOperator: anOperator	"Answer the help string associated with the given operator, nil if none found."	| anIndex opsAndHelp |	(anIndex := (opsAndHelp := self arithmeticalOperatorsAndHelpStrings) first indexOf: anOperator) > 0		ifTrue:	[^ (opsAndHelp second at: anIndex) translated].	(anIndex := (opsAndHelp := self numericComparitorsAndHelpStrings) first indexOf: anOperator) > 0		ifTrue:	[^ (opsAndHelp second at: anIndex) translated].	anOperator = #, ifTrue:		[^ 'Concatenate two Strings' translated].	^ nil! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'nk 7/12/2003 08:59'!holderWithAlphabet	"Answer a fully instantiated Holder that has submorphs that represent the letters of the uppercase alphabet, with each one having an 'index' slot which bears the letter's index in the alphabet -- 1 for A, 2 for B, etc.   A few special characters are provided as per ack request 10/00; for these the index provided is rather arbitrarily assigned"	| aMorph aPlayer newMorph oneCharString aContainer aWrapper |	"ScriptingSystem holderWithAlphabet openInHand"	aContainer := self prototypicalHolder useRoundedCorners.	aContainer borderColor: Color blue lighter.	aWrapper := AlignmentMorph new hResizing: #shrinkWrap; vResizing: #shrinkWrap; layoutInset: 0.	aWrapper addMorphBack: (aMorph := TextMorph new contents: 'A').	aMorph beAllFont: ((TextStyle named: Preferences standardEToysFont familyName) fontOfSize: 24).	aMorph width: 14; lock.	aWrapper beTransparent; setNameTo: 'A'.	aPlayer := aWrapper assuredPlayer.	aPlayer addInstanceVariableNamed: #index type: #Number value: 1.	aContainer addMorphBack: aWrapper.	2 to: 26 do:		[:anIndex |			newMorph := aWrapper usableSiblingInstance.			newMorph player perform: #setIndex: with: anIndex.			newMorph firstSubmorph contents: (oneCharString := ($A asciiValue + anIndex - 1) asCharacter asString).			newMorph setNameTo: oneCharString.			aContainer addMorphBack: newMorph].	#(' ' '.' '#') with: #(27 28 29) do:		[:aString :anIndex |			newMorph := aWrapper usableSiblingInstance.			newMorph player perform: #setIndex: with: anIndex.			newMorph firstSubmorph contents: aString.			aString = ' '				ifTrue:					[newMorph setNameTo: 'space'.					newMorph color: (Color gray alpha: 0.2)]				ifFalse:					[newMorph setNameTo: aString].			aContainer addMorphBack: newMorph].	aContainer setNameTo: 'alphabet'.	aContainer isPartsBin: true.	aContainer enableDrop: false.	aContainer indicateCursor: false; width: 162.	aContainer color: (Color r: 0.839 g: 1.0 b: 1.0).  "Color fromUser"	^ aContainer! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 11/13/2001 14:41'!newScriptingSpace2	"Answer a complete scripting space"	| aTemplate  aPlayfield aControl |		(aTemplate := PasteUpMorph new)		setNameTo: 'etoy';		extent: 638 @ 470;		color: Color white;		impartPrivatePresenter;		setProperty: #automaticPhraseExpansion toValue: true;		beSticky.	aTemplate useRoundedCorners; borderWidth: 2. 	aControl :=  ScriptingSystem scriptControlButtons setToAdhereToEdge: #bottomLeft.	aControl beSticky; borderWidth: 0; beTransparent.	aTemplate addMorphBack: aControl.	aTemplate presenter addTrashCan.	aTemplate addMorph: (aPlayfield := PasteUpMorph new).	aPlayfield		setNameTo: 'playfield';		useRoundedCorners;		setToAdhereToEdge: #topLeft;		extent: 340@300;		position: aTemplate topRight - (400@0);		beSticky;		automaticViewing: true;		wantsMouseOverHalos: true.	aTemplate presenter standardPlayfield: aPlayfield.		^ aTemplate! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 5/2/1998 14:17'!reclaimSpace	"Reclaim space from the scripting system, and report the result in an informer"	"ScriptingSystem reclaimSpace"	| reclaimed |	(reclaimed := self spaceReclaimed)  > 0		ifTrue:	[self inform: reclaimed printString, ' bytes reclaimed']		ifFalse:	[self inform: 'Hmm...  Nothing gained this time.']! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 6/9/2000 18:44'!reinvigorateThumbnailsInViewerFlapTabs	"It has happened that the thumbnail in a viewer flap tab will go solid gray because it got associated with some passing and disused player temporarily created during the initial painting process.  This method takes a sledge hammer to repair such thumbnails.   At its genesis, this method is called only from the postscript of its defining fileout."	| vwr thumbnail |	ViewerFlapTab allInstancesDo:		[:aTab | 			vwr := aTab referent findA: StandardViewer.			thumbnail := aTab findA: ThumbnailMorph.			(vwr notNil and: [thumbnail notNil]) ifTrue:				[thumbnail objectToView: vwr scriptedPlayer]]	"ScriptingSystem reinvigorateThumbnailsInViewerFlapTabs"! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'sw 7/25/2004 17:27'!restoreClassicEToyLook	"Restore classic EToy look, as closely as possible.  If ComicBold is present, restore it as the standard etoy and button font.  Substitute ComicSansMS and Accuny as respective alternatives if the classic fonts are absent.  If those also aren't available, do nothing."	| aTextStyle aFont | 	(aTextStyle := TextStyle named: #ComicBold)		ifNotNil:			[aFont := aTextStyle fontOfSize: 16.			Preferences setEToysFontTo: aFont.			Preferences setButtonFontTo: aFont]		ifNil:			[(aTextStyle := TextStyle named: #ComicSansMS) ifNotNil:				[Preferences setEToysFontTo: (aTextStyle fontOfSize: 18)].			(aTextStyle := TextStyle named: #Accuny) ifNotNil:				[Preferences setButtonFontTo: (aTextStyle fontOfSize: 12)]].	(aTextStyle := TextStyle named: #NewYork)		ifNotNil:			[Preferences setSystemFontTo: (aTextStyle fontOfSize: 12)]! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'di 3/3/2001 08:47'!spaceReclaimed	"Reclaim space from the EToy system, and return the number of bytes reclaimed"	"ScriptingSystem spaceReclaimed"	| oldFree  |	oldFree := Smalltalk garbageCollect.	ThumbnailMorph recursionReset.	Player removeUninstantiatedSubclassesSilently.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	^ Smalltalk garbageCollect - oldFree.! !!StandardScriptingSystem methodsFor: '*eToys-utilities' stamp: 'nk 10/14/2004 11:19'!wordingForOperator: aString	"Answer the wording to be seen by the user for the given operator symbol/string"	| toTest |	toTest := aString asString.	#(	(append:				'include at end')		(arrowheadsOnAllPens	'arrowheads on all pens')		(beep:					'make sound')		(bounce:				'bounce')		(clearTurtleTrails		'clear pen trails')		(clearOwnersPenTrails	'clear all pen trails')		(colorSees				'color  sees')		(color:sees:				'color sees')		(doMenuItem:			'do menu item')		(doScript:				'do')		(forward:				'forward by')		(goToRightOf:			'align after')		(includeAtCursor:		'include at cursor')		(isDivisibleBy:			'is divisible by')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(makeNewDrawingIn:	'start painting in')		(max:					'max')		(min:					'min')		(moveToward:			'move toward')		(noArrowheadsOnAllPens	'no arrowheads on pens')		(overlapsAny			'overlaps any')		(pauseAll:				'pause all')		(pauseScript:			'pause script')		(prepend:				'include at beginning')		(seesColor:				'is over color')		(startAll:				'start all')		(startScript:				'start script')		(stopProgramatically	'stop')		(stopAll:					'stop all')		(stopScript:				'stop script')		(tellAllSiblings:			'tell all siblings')		(tellSelfAndAllSiblings:	'send to all')		(turn:					'turn by')		(turnToward:				'turn toward')		(wearCostumeOf:		'look like'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"StandardScriptingSystem initialize"! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status := #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame := view displayBox.	side := #none.	VBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect := sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect := sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub := view subviewWithLongestSide: [:s | side := s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect := sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect := sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:22'!adjustWindowBorders 	| side noClickYet |	noClickYet := true.	VBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #left) | (side = #right)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]].	HBorderCursor showWhile:		[ [side := view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder			and: [(side = #top) | (side = #bottom)			and: [noClickYet or: [sensor redButtonPressed]]]]			whileTrue:			[sensor redButtonPressed ifTrue:				[noClickYet := false.				side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box := view windowBox.	clicked := false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox := ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p := sensor cursorPoint))						and: [(clicked := sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p := sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 := p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 := (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 := f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 := (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders' stamp: 'di 11/16/2001 22:30'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp := sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	view subViews size <= 1 ifTrue: [^ self].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp := sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i := view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box := view windowBox]		ifFalse: [box := (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/15/2000 22:19'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p := sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box := view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box := view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	(((box := view labelTextRegion expandBy: 1) containsPoint: p)			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status := #inactive! !!StandardSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	model okToChange ifFalse: [^self].	status := #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!move	"Ask the user to designate a new origin position for the receiver's view.	6/10/96 sw: tell the view that it has moved"	| oldBox | 	oldBox := view windowBox.	view uncacheBits.	view align: view windowBox topLeft		with: view chooseMoveRectangle topLeft.	view displayEmphasized.	view moved.  "In case its model wishes to take note."	(oldBox areasOutside: view windowBox) do:		[:rect | ScheduledControllers restore: rect]! !!StandardSystemController methodsFor: 'menu messages'!under	"Deactive the receiver's scheduled view and pass control to any view that 	might be positioned directly underneath it and the cursor."	status := #inactive! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnscheduleNoErase	"Remove the scheduled view from the collection of scheduled views. Set 	its status to closed but do not erase."	status := #closed.	view release.	ScheduledControllers unschedule: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 3/18/98 19:21'!closeAndUnscheduleNoTerminate	"Erase the receiver's view and remove it from the collection of scheduled views, but do not terminate the current process."	status := #closed.	view erase.	view release.	ScheduledControllers unschedule: self.! !!StandardSystemController methodsFor: 'scheduling'!open	"Create an area on the screen in which the receiver's scheduled view can 	be displayed. Make it the active view."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling'!openDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view."	view align: view viewport center with: aPoint.	view translateBy:		(view displayBox amountToTranslateWithin: Display boundingBox).	status := #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!openNoTerminateDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view. Do not terminate the 	currently active process."	view resizeMinimumCenteredAt: aPoint.	status := #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!status: aSymbol	status := aSymbol! !!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu := SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor := Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented := false]! !!StandardSystemView methodsFor: 'displaying'!cacheBits	| oldLabelState |	CacheBits ifFalse: [^ self uncacheBits].	(oldLabelState := isLabelComplemented) ifTrue: [ self deEmphasize ].	self cacheBitsAsIs.	(isLabelComplemented := oldLabelState) ifTrue: [ self emphasize ].! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits := (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid := true.! !!StandardSystemView methodsFor: 'displaying'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self displayDeEmphasized; emphasize.	isLabelComplemented := true! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 5/15/1998 21:55'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 := self labelDisplayBox insetBy: 2.	r2 := r1 insetBy: 0@2.	r3 := r2 insetBy: 0@3.	c3 := self labelColor.	c2 := c3 dansDarker.	c1 := c2 dansDarker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes := Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelBoxes	"closeBox, growBox."	| aRect smallRect backColor |	aRect := self closeBoxFrame.	backColor := self labelColor.	Display fill: (aRect insetBy: -2) fillColor: backColor.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	aRect := self growBoxFrame.	smallRect := aRect origin extent: 7@7.	Display fill: (aRect insetBy: -2) fillColor: backColor.	aRect := aRect insetOriginBy: 2@2 cornerBy: 0@0.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	Display fillBlack: smallRect.	Display fill: (smallRect insetBy: 1) fillColor: backColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect := self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'ar 5/14/2001 23:40'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox := self labelDisplayBox.	top := labelDisplayBox top + 3.	bottom := labelDisplayBox bottom - 3.	stripes := Bitmap with: (Display pixelWordFor: self labelColor)			with: (Display pixelWordFor: Color black).	top even ifFalse: [stripes swap: 1 with: 2].	left := labelDisplayBox left + 3.	box := self closeBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self labelTextRegion.	right := box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	box := self growBoxFrame.	right := box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left := box right + 2.	right := labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid := bitsValid.			bitsValid := false.			ScheduledControllers restore: self windowBox without: self.			bitsValid := oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying' stamp: 'RAA 6/14/2000 17:27'!makeMeVisible        | newLoc portRect |        ((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))                containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].        "window not on screen (probably due to reframe) -- move it now"        newLoc := self isCollapsed                ifTrue: [RealEstateAgent assignCollapsePointFor: self]                ifFalse: [(RealEstateAgent initialFrameFor: self world: nil) topLeft].        portRect := newLoc + self labelOffset                                extent: self windowBox extent - self labelOffset.        self resizeTo: portRect.        self setLabelRegion.! !!StandardSystemView methodsFor: 'displaying'!uncacheBits	windowBits := nil.	bitsValid := false.! !!StandardSystemView methodsFor: 'framing' stamp: 'sr 3/26/2000 03:47'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm := Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown := Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset := self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt := (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown := true]							ifFalse: [beenDown not]].		^ pt].	^ (RealEstateAgent assignCollapseFrameFor: self) origin.! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm := bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid := false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f := self getFrame.			bitsValid := false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset p |	offset := Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | p := Sensor cursorPoint + offset.					p := (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | p := Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 5/11/1999 22:09'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[model modelSleep.			(subViews ~~ nil and: [subViews size = 1 and: [subViews first isKindOf: MorphWorldView]])				ifTrue: [subViews first deEmphasizeView].			expandedViewport := self viewport.			savedSubViews := subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid := false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport := self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame := self chooseFrame expandBy: borderWidth.			collapsedViewport := self viewport.			subViews := savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews := nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'framing'!getFrame	"Ask the user to designate a rectangular area in which	the receiver should be displayed."	| minFrame |	minFrame := Cursor origin showWhile: 		[(Sensor cursorPoint extent: self minimumSize) newRectFrom:			[:f | Sensor cursorPoint extent: self minimumSize]].	self maximumSize <= self minimumSize ifTrue: [^ minFrame].	^ Cursor corner showWhile:		[minFrame newRectFrom:			[:f | self constrainFrame: (f origin corner: Sensor cursorPoint)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect := aDisplayBox.	theMin := 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim := ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta := minDim - theMin.		newRect := newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox := sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport := nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'BG 12/4/2003 13:14'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox := self windowBox.	portRect := newFrame topLeft + self labelOffset				corner: newFrame corner.	self setWindow: nil.	self resizeTo: portRect.	self setLabelRegion.	newBox := self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f := self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!resizeMinimumCenteredAt: aPoint 	"Determine the rectangular area for the receiver, adjusted so that it is 	centered a position, aPoint."	| aRectangle |	aRectangle := 0 @ 0 extent: self minimumSize.	aRectangle := aRectangle align: aRectangle center with: aPoint.	self resizeTo: aRectangle! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:29'!resizeTo: aRectangle	"Resize this view to aRectangle"	"First get scaling right inside borders"	self window: (self window insetBy: borderWidth)		viewport: (aRectangle insetBy: borderWidth).	"Then ensure window maps to aRectangle"	window := transformation applyInverseTo: aRectangle! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'sw 10/29/1999 12:58'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame := Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented := false.	minimumSize := 50 @ 50.	maximumSize := Display extent.	collapsedViewport := nil.	expandedViewport := nil.	bitsValid := false.	updatablePanes := #()! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:44'!label: aString 	"Set aString to be the receiver's label."	labelText := Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'sumim 2/8/2002 14:36'!setLabelTo: aString 	"Force aString to be the new label of the receiver, bypassing any logic about whether it is acceptable and about propagating information about the change."	| oldRegion oldWidth |	self label: aString.	self controller isControlActive ifFalse: [^ self].	oldRegion := self labelTextRegion.	oldWidth := self insetDisplayBox width.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized]! !!StandardSystemView methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		updatablePanes ifNil: [updatablePanes := #()].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!StandardSystemView methodsFor: 'size'!maximumSize: aPoint 	"Set the argument, aPoint, to be the maximum width and height of the 	receiver."	maximumSize := aPoint! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the 	receiver."	minimumSize := aPoint! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 12:57'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList := OrderedCollection new.	getSelectors do:		[:sel | aPane := self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes := aList asArray! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:20'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message upon window activation or expansion."	^ updatablePanes ifNil: [updatablePanes := #()]! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen := 0.	subViews do:		[:sub | box := sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub := sub.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView class methodsFor: 'class initialization'!doCacheBits	"StandardSystemView doCacheBits - Enable fast window repaint feature"	CacheBits := true.	ScheduledControllers unCacheWindows.	ScheduledControllers restore! !!StandardSystemView class methodsFor: 'class initialization'!dontCacheBits	"StandardSystemView dontCacheBits - Disable fast window repaint feature.	Return true iff bits were cached, ie if space was been recovered"	CacheBits ifFalse: [^ false].	CacheBits := false.	ScheduledControllers unCacheWindows.	^ true! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:26'!setLabelStyle	| aFont |	"StandardSystemView setLabelStyle"	aFont := Preferences windowTitleFont.	LabelStyle := TextStyle fontArray: { aFont }.	LabelStyle gridForFont: 1 withLead: 0! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/23/2002 14:56'!addCategoryViewerFor: categoryInfo atEnd: atEnd	"Add a category viewer for the given category info.  If atEnd is true, add it at the end, else add it just after the header morph"	| aViewer |	aViewer := self categoryViewerFor: categoryInfo.	atEnd		ifTrue:			[self addMorphBack: aViewer]		ifFalse:			[self addMorph: aViewer after: submorphs first].	aViewer establishContents.	self world ifNotNil: [self world startSteppingSubmorphsOf: aViewer].	self fitFlap! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:22'!chooseLimitClass	"Put up a menu allowing the user to choose the most generic class to show"	| aMenu limitClass |	aMenu := MenuMorph new defaultTarget: self.	limitClass := self limitClass.	scriptedPlayer class withAllSuperclasses do:		[:aClass | 			aClass == ProtoObject				ifTrue:					[aMenu addLine].			aMenu add: aClass name selector: #setLimitClass: argument: aClass.			aClass == limitClass ifTrue:				[aMenu lastItem color: Color red].			aClass == limitClass ifTrue: [aMenu addLine]].	aMenu addTitle: 'Show only methodsimplemented at or above...'.  "heh heh -- somebody please find nice wording here!!"	aMenu popUpInWorld: self currentWorld! !!StandardViewer methodsFor: 'categories' stamp: 'ka 11/29/2005 20:53'!likelyCategoryToShow	"Choose a category to show based on what's already showing and on some predefined heuristics"	| possible all aCat currVocab |	all := (scriptedPlayer categoriesForViewer: self) asOrderedCollection.	possible := all copy.	currVocab := self currentVocabulary.	self categoryMorphs do: 			[:m | 			aCat := currVocab categoryWhoseTranslatedWordingIs: m currentCategory.			aCat ifNotNil: [possible remove: aCat wording ifAbsent: []]].	(possible includes: ScriptingSystem nameForInstanceVariablesCategory translated) ifTrue:		[^ ScriptingSystem nameForInstanceVariablesCategory].	(currVocab isEToyVocabulary) 		ifTrue: 			[(possible includes: ScriptingSystem nameForScriptsCategory translated) 				ifTrue: [^ ScriptingSystem nameForScriptsCategory]].	{'kedama' translated. #basic translated} 		do: [:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	((scriptedPlayer isPlayerLike) 		and: [scriptedPlayer hasOnlySketchCostumes]) 			ifTrue: [(possible includes: #tests translated) ifTrue: [^#tests translated]].	{#'color & border' translated. #tests translated. #color translated. #flagging translated. #comparing translated.} 		do: [:preferred | (possible includes: preferred) ifTrue: [^ preferred]].	^ possible isEmpty ifFalse: [possible first] ifTrue: [all first]! !!StandardViewer methodsFor: 'categories' stamp: 'sw 8/3/2001 18:17'!limitClass	"Answer the limit class to use in this viewer"	| aClass |	(aClass := self valueOfProperty: #limitClass)  ifNotNil:		[^ aClass].	aClass := scriptedPlayer defaultLimitClassForVocabulary: self currentVocabulary.	self setProperty: #limitClass toValue: aClass.	^ aClass! !!StandardViewer methodsFor: 'categories' stamp: 'di 2/19/2001 10:39'!recreateCategories	"To change from old to new tiles"	| cats |	cats := self categoriesCurrentlyShowing.	self removeAllMorphsIn: self categoryMorphs.	cats do: [:cat | self addCategoryViewerFor: cat]! !!StandardViewer methodsFor: 'initialization' stamp: 'nk 9/2/2004 11:30'!addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean	"Add the header morph to the receiver, using anInteger as a guide for its height, and if aBoolean is true, include a dismiss buton for it"	| header aFont aButton aTextMorph nail wrpr costs headWrapper |	header := AlignmentMorph newRow color: self color muchLighter; wrapCentering: #center; cellPositioning: #leftCenter.	aFont := Preferences standardButtonFont.	aBoolean ifTrue:		[aButton := self tanOButton.		header addMorph: aButton.		aButton target: self;				actionSelector: #dismiss;				setBalloonText: 'remove this entire Viewer from the screendon''t worry -- nothing will be lost!!.' translated.		header addTransparentSpacerOfSize: 4@1].	aButton := IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: #AddCategoryViewer); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addCategoryViewer;			setBalloonText: 'click here to addanother category pane' translated;			shedSelvedge.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 4@1.	costs := scriptedPlayer costumes.	costs ifNotNil:	[(costs size > 1 or: [costs size = 1 and: [costs first ~~ scriptedPlayer costume]]) ifTrue:		[header addUpDownArrowsFor: self.		(wrpr := header submorphs last) submorphs second setBalloonText: 'switch to previous costume' translated.			wrpr submorphs first  setBalloonText: 'switch to next costume' translated]].		nail := (self hasProperty: #noInteriorThumbnail)		ifFalse:			[ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume]		ifTrue:			[ImageMorph new image: Cursor menu].	nail on: #mouseDown send: #offerViewerMenuForEvt:morph: to: scriptedPlayer.	header addMorphBack: nail.	nail setBalloonText: 'click here to get a menuthat will allow you toadd a variable,tear off a tile, etc..' translated.	(self hasProperty: #noInteriorThumbnail)		ifFalse:			[nail borderWidth: 3; borderColor: #raised].	header addTransparentSpacerOfSize: 5@5."	aButton := SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'S' translated font: (aFont := StrikeFont familyName: #ComicBold size: 16);  color: Color transparent; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object' translated.		header addMorphBack: aButton.	header addTransparentSpacerOfSize: 8@5."		aButton := SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'v' translated font: (aFont emphasized: 1);  color: Color transparent; borderWidth: 1; actWhen: #buttonUp.	"aButton firstSubmorph color: Color gray."	aButton setBalloonText: 'click here to add a variableto this object.' translated.	header addMorphBack: aButton.	header addTransparentSpacerOfSize: 5@5.	self viewsMorph ifTrue: [scriptedPlayer costume assureExternalName].	aTextMorph := UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #nameForViewer;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	self viewsMorph ifTrue:		[aTextMorph putSelector: #setName:.		aTextMorph setProperty: #okToTextEdit toValue: true].	aTextMorph step.	header  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s name.' translated.		header beSticky.	anInteger > 0		ifTrue:			[headWrapper := AlignmentMorph newColumn color: self color.			headWrapper addTransparentSpacerOfSize: (0 @ anInteger).			headWrapper addMorphBack: header.			self addMorph: headWrapper]		ifFalse:			[self addMorph: header]! !!StandardViewer methodsFor: 'initialization' stamp: 'yo 8/18/2005 13:43'!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer costume isMemberOf: KedamaMorph) ifTrue: [self addCategoryViewer].		].! !!StandardViewer methodsFor: 'initialization' stamp: 'sw 6/4/2001 19:40'!useVocabulary: aVocabulary	"Make the receiver show categories and methods as dictated by aVocabulary"	| itsName |	((self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil]) == (itsName := aVocabulary vocabularyName)) ifFalse:		[self setProperty: #currentVocabularySymbol toValue: itsName.		self removeProperty: #currentVocabulary.  "grandfathered"		(self submorphs select: [:m | m isKindOf: CategoryViewer]) do: [:m | m delete]]! !!StandardViewer methodsFor: 'macpal' stamp: 'sw 6/4/2001 18:05'!currentVocabulary	"Answer the vocabulary currently associated with the receiver"	| aSym aVocab |	aSym := self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil].	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self removeProperty: #currentVocabulary.			self setProperty: #currentVocabularySymbol toValue: aSym]].	^ aSym		ifNotNil:			[Vocabulary vocabularyNamed: aSym]		ifNil:			[(self world ifNil: [ActiveWorld]) currentVocabularyFor: scriptedPlayer]! !!StandardViewer methodsFor: 'user interface' stamp: 'sw 10/25/1999 22:08'!dismiss	| aFlapTab |	"User hit the dismiss button."	(owner isKindOf: TabbedPalette)		ifTrue:			[^ owner showNoPalette].	(aFlapTab := self pasteUpMorph correspondingFlapTab) ifNotNil:		[^ aFlapTab dismissViaHalo].	self topRendererOrSelf delete! !!StandardViewer methodsFor: 'user interface' stamp: 'sw 5/18/2001 10:46'!openLexicon	"Open a lexicon browser on the receiver, showing its current vocabulary"	| littleHim | 	littleHim := scriptedPlayer assureUniClass.	(InstanceBrowser new useVocabulary: self currentVocabulary) openOnObject: littleHim  inWorld: ActiveWorld showingSelector: nil! !!StickynessBugz methodsFor: 'as yet unclassified' stamp: 'wiz 7/28/2007 18:54'!testForTiltedStickyness"self new testForTiltedStickyness""self run: #testForTiltedStickyness"| m |m := RectangleMorph new openCenteredInWorld .cases := Array with: m . "save for tear down."self assert: ( m topRendererOrSelf isSticky not ) .m beSticky .self assert: ( m topRendererOrSelf isSticky ) .m addFlexShell .cases := Array with: m topRendererOrSelf .m topRendererOrSelf rotationDegrees: 45.0 .self assert: ( m topRendererOrSelf isSticky ) .m beUnsticky .self assert: ( m topRendererOrSelf isSticky not ) .m topRendererOrSelf delete.^true ! !!StickynessBugz commentStamp: 'wiz 11/24/2006 00:24' prior: 0!A StickynessBugz is for mantis #5500 rectangles and ellipses don't act sticky when rotated even when they are..Instance Variables!!Stream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger number of objects accessible by the receiver."	| aCollection |	aCollection := OrderedCollection new.	anInteger timesRepeat: [aCollection addLast: self next].	^aCollection! !!Stream methodsFor: 'accessing'!nextMatchAll: aColl    "Answer true if next N objects are the ones in aColl,     else false.  Advance stream of true, leave as was if false."    | save |    save := self position.    aColl do: [:each |       (self next) = each ifFalse: [            self position: save.            ^ false]        ].    ^ true! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements := OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!StretchyImageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/10/2000 16:20'!form: aForm	form := aForm! !!StretchyImageMorph methodsFor: 'drawing' stamp: 'nk 1/3/2004 17:40'!drawOn: aCanvas| t |"Smalltalk at: #Q4 put: OrderedCollection new."	form ifNil: [form := (Form extent: 32@32 depth: 8) fillColor: Color green].	(cache isNil or: [cache extent ~= bounds extent]) ifTrue: [		t := [cache := Form extent: bounds extent depth: form depth.		form displayInterpolatedIn: cache boundingBox on: cache.		cache := cache asFormOfDepth: aCanvas depth] timeToRun.		"Q4 add: {t. form. cache}."	].	aCanvas paintImage: cache at: bounds origin.! !!StrikeFont methodsFor: 'emphasis' stamp: 'rej 9/29/2007 09:02'!setupDefaultFallbackFont	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	self fallbackFont: (StrikeFont defaultSized: self height).	self reset.! !!StrikeFont class methodsFor: 'accessing' stamp: 'rej 9/29/2007 08:50'!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	^f! !!StrikeFontSet methodsFor: 'testing' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!do: aBlock toFieldNumber: aNumber	"Considering the receiver as a holder of tab-delimited fields, evaluate aBlock on behalf of a field in this string"	| start end index |	start := 1.	index := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aNumber = index ifTrue:			[aBlock value: (self copyFrom: start  to: end).			^ self].		index := index + 1.		start := end + 2]"1 to: 6 do:	[:aNumber |		'fred	charlie	elmo		wimpy	friml' do:			[:aField | Transcript cr; show: aField] toFieldNumber: aNumber]"! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:12'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min := self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim isCharacter 			ifTrue: [ind := self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind := self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min := min min: ind].	^ min! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findBetweenSubStrs: delimiters	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipAnySubStr: delimiters startingAt: keyStop.		keyStop := self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 10/15/2003 15:32'!findLastOccuranceOfString: subString startingAt: start 	"Answer the index of the last occurance of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	| last now |	last := self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue: [		now := last.		last := self findSubstring: subString in: self startingAt: last + subString size matchTable: CaseSensitiveOrder.	].	^ now.! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens := OrderedCollection new.	separators := delimiters isCharacter 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: separators startingAt: keyStop.		keyStop := self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'dtl 8/14/2004 11:27'!findTokens: delimiters escapedBy: quoteDelimiters 	"Answer a collection of Strings separated by the delimiters, where  	delimiters is a Character or collection of characters. Two delimiters in a  	row produce an empty string (compare this to #findTokens, which  	treats sequential delimiters as one).  	 	The characters in quoteDelimiters are treated as quote characters, such  	that any delimiter within a pair of matching quoteDelimiter characters  	is treated literally, rather than as a delimiter.  	 	The quoteDelimiter characters may be escaped within a quoted string.  	Two sequential quote characters within a quoted string are treated as  	a single character.  	 	This method is useful for parsing comma separated variable strings for  	spreadsheet import and export."	| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |	delimiterChars := (delimiters isNil				ifTrue: ['']				ifFalse: [delimiters]) asString.	quoteChars := (quoteDelimiters isNil				ifTrue: ['']				ifFalse: [quoteDelimiters]) asString.	tokens := OrderedCollection new.	rs := ReadStream on: self.	activeEscapeCharacter := nil.	ts := WriteStream on: ''.	[rs atEnd]		whileFalse: [char := rs next.			activeEscapeCharacter isNil				ifTrue: [(quoteChars includes: char)						ifTrue: [activeEscapeCharacter := char]						ifFalse: [(delimiterChars includes: char)								ifTrue: [token := ts contents.									tokens add: token.									ts := WriteStream on: '']								ifFalse: [ts nextPut: char]]]				ifFalse: [char == activeEscapeCharacter						ifTrue: [rs peek == activeEscapeCharacter								ifTrue: [ts nextPut: rs next]								ifFalse: [activeEscapeCharacter := nil]]						ifFalse: [ts nextPut: char]]].	token := ts contents.	(tokens isEmpty and: [token isEmpty])		ifFalse: [tokens add: token].	^ tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop := self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind := start.	[ind := self findSubstring: key in: self startingAt: ind matchTable: CaseInsensitiveOrder.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].	^ ind	"is a word start"! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter isCharacter) ifFalse: [ ^ aBlock value ].	ans := self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'nice 3/15/2007 21:03'!indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock 	"returns the index of the first character in the given set, starting from start "		| ans |	ans := self isWideString				ifTrue: ["Fallback to naive implementation"					self class						findFirstInString: self						inCharacterSet: aCharacterSet						startingAt: start]				ifFalse: ["We know we contain only byte characters						So use a byteArrayMap opimized for primitive call"					self class						findFirstInString: self						inSet: aCharacterSet byteArrayMap						startingAt: start].	ans = 0		ifTrue: [^ aBlock value]		ifFalse: [^ ans]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index := self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: 'accessing' stamp: 'yo 12/17/2002 16:56'!leadingCharRunLengthAt: index	| leadingChar |	leadingChar := (self at: index) leadingChar.	index to: self size do: [:i |		(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].	].	^ self size - index + 1.! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:33'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position.  1/15/96 sw:  Inefficient first stab at this"	| cr aChar answer |	cr := Character cr.	answer := ''.	1 to: self size do:		[:i | 			aChar := self at: i.			aChar = cr				ifTrue:					[i > anIndex						ifTrue:							[^ answer]						ifFalse:							[answer := '']]				ifFalse:					[answer := answer copyWith: aChar]].	^ answer! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineCount	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"	| cr count |	cr := Character cr.	count := 1  min: self size..	1 to: self size do:		[:i | (self at: i) = cr ifTrue: [count := count + 1]].	^ count"'FredtheBear' lineCount"! !!String methodsFor: 'accessing' stamp: 'yo 8/27/2002 14:34'!lineNumber: anIndex	"Answer a string containing the characters in the given line number.  5/10/96 sw"	| crString pos finalPos |	crString := String with: Character cr.	pos := 0.	1 to: anIndex - 1 do:		[:i | pos := self findString: crString startingAt: pos + 1.			pos = 0 ifTrue: [^ nil]].	finalPos := self findString: crString startingAt: pos + 1.	finalPos = 0 ifTrue: [finalPos := self size + 1].	^ self copyFrom: pos + 1 to: finalPos - 1"'FredtheBear' lineNumber: 3"! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start := 1.	[ start <= self size ] whileTrue: [		end := self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end := end - 1.		aBlock value: (self copyFrom: start  to: end).		start := end + 2. ].! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:28'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii := start-1.	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any := false.		delimiters do: [:delim |			delim isCharacter 				ifTrue: [(self at: ii) == delim ifTrue: [any := true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind := 0.						this := true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this := false].							ind := ind + 1].						this ifTrue: [ii := ii + delim size - 1.  any := true]]							ifTrue: [any := false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!tabDelimitedFieldsDo: aBlock	"Considering the receiver as a holder of tab-delimited fields, evaluate execute aBlock with each field in this string.  The separatilng tabs are not included in what is passed to aBlock"	| start end |	"No senders but was useful enough in earlier work that it's retained for the moment."	start := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aBlock value: (self copyFrom: start  to: end).		start := end + 2]"'fred	charlie	elmo		2' tabDelimitedFieldsDo: [:aField | Transcript cr; show: aField]"! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize := (j := self size) min: (k := aString size).	bonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i := 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i := i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j := j - 1.  k := k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'yo 8/27/2002 14:15'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count := self size min: aString size.	1 to: count do: [:i | 		(self at: i) = (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra := self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!howManyMatch: string 	"Count the number of characters that match up in self and aString."	| count shorterLength |		count  :=  0 .	shorterLength  :=  ((self size ) min: (string size ) ) .	(1 to: shorterLength  do: [:index |		 (((self at: index ) = (string at: index )  ) ifTrue: [count  :=  (count + 1 ) .			]   ).		]   ).	^  count 		! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i := i+1.  j := j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch := true.				matchStart := i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch := false.				matchStart := i].	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd := ii-1].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd := matchEnd min: ii-1].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 17:18'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b := ByteArray new: self byteSize.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i).	].	^ b.! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 13:55'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string := FileDirectory checkName: self fixErrors: true.	checkedString := (FilePath pathName: string) asVmPathName.	^ (FilePath pathName: checkedString isEncoded: true) asSqueakPathName.! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:38'!asFourCode	| result |	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result := self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!String methodsFor: 'converting' stamp: 'yo 8/26/2002 23:06'!asHex	| stream |	stream := WriteStream on: (String new: self size * 4).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp |	temp := self copyReplaceAll: '&' with: '&amp;'.	HtmlEntities keysAndValuesDo:		[:entity :char |		char = $& ifFalse:			[temp := temp copyReplaceAll: char asString with: '&' , entity , ';']].	temp := temp copyReplaceAll: '	' with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp := temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString := self select: [:el | el isAlphaNumeric].	firstLetterPosition := aString findFirst: [:ch | ch isLetter].	aString := firstLetterPosition == 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar := shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asLegalSelector	| toUse |	toUse := ''.	self do:		[:char | char isAlphaNumeric ifTrue: [toUse := toUse copyWith: char]].	(self size == 0 or: [self first isLetter not])		ifTrue:		[toUse := 'v', toUse].	^ toUse withFirstCharacterDownshifted"'234znak 43 ) 2' asLegalSelector"! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 20:55'!asOctetString	"Convert the receiver into an octet string"	| string |	string := String new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:39'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack := pack * 256 + next asInteger ].! !!String methodsFor: 'converting' stamp: 'dc 8/1/2007 16:02'!asSignedInteger	"Returns the first signed integer it can find or nil."	| start stream |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	stream := (ReadStream on: self) position: start.	stream oldBack = $- ifTrue: [stream oldBack].	^ Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'edc 4/23/2007 09:38'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest did |	in := ReadStream on: self.	out := WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char := in next) = $&						ifTrue: [rest := in upTo: $;.								did := out position.								rest = 'lt' ifTrue: [out nextPut: $<].								rest = 'gt' ifTrue: [out nextPut: $>].								rest = 'amp' ifTrue: [out nextPut: $&].								rest = 'deg' ifTrue: [out nextPut: $].								rest = 'quot' ifTrue: [out nextPut: $"].								rest = 'nbsp' ifTrue: [out nextPut: Character space].								did = out position ifTrue: [									self error: 'unknown encoded HTML char'.									"Please add it to this method"]]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize start result ri c ts |	null := Character value: 0.	str := self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize := str size.	tokens doWithIndex:		[:token :tIndex |		start := 1.		[(start := str findString: token startingAt: start) > 0]			whileTrue:			[ts := token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts := token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize := finalSize - (ts - 1).			start := start + ts]].	result := String new: finalSize.	ri := 0.	1 to: str size do:		[:i | (c := str at: i) = null ifFalse: [result at: (ri := ri+1) put: c]].	^ result! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize := smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting' stamp: 'yo 7/8/2004 12:02'!convertFromWithConverter: converter	| readStream writeStream c |	readStream := self readStream.	writeStream := String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		c := converter nextFromStream: readStream.		c ifNotNil: [writeStream nextPut: c] ifNil: [^ writeStream contents]	].	^ writeStream contents! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 14:01'!convertToSystemString	| readStream writeStream converter |	readStream := self readStream.	writeStream := String new writeStream.	converter := LanguageEnvironment defaultSystemConverter.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 7/8/2004 12:01'!convertToWithConverter: converter	| readStream writeStream |	readStream := self readStream.	writeStream := String new writeStream.	converter ifNil: [^ self].	[readStream atEnd] whileFalse: [		converter nextPut: readStream next toStream: writeStream	].	converter emitSequenceToResetStateIfNeededOn: writeStream.	^ writeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results := self correctAgainst: wordList continuedFrom: nil.	results := self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting' stamp: 'yo 7/29/2005 16:03'!encodeForHTTPWithTextEncoding: encodingName conditionBlock: conditionBlock	"change dangerous characters to their %XX form, for use in HTTP transactions"	| httpSafeStream encodedStream cont |	httpSafeStream := WriteStream on: (String new).	encodedStream := MultiByteBinaryOrTextStream on: (String new: 6).	encodedStream converter: (TextConverter newForEncoding: encodingName).	self do: [:c |		(conditionBlock value: c)			ifTrue: [httpSafeStream nextPut: (Character value: c charCode)]			ifFalse: [				encodedStream text; reset.				encodedStream nextPut: c.				encodedStream position: 0.				encodedStream binary.				cont := encodedStream contents.				cont do: [:byte |					httpSafeStream nextPut: $%.					httpSafeStream nextPut: (byte // 16) asHexDigit.					httpSafeStream nextPut: (byte \\ 16) asHexDigit.				].			].	].	^ httpSafeStream contents.! !!String methodsFor: 'converting' stamp: 'yo 7/5/2004 16:48'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel := self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel := sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens := sel findTokens: Character separators.		sel := self class streamContents:			[:s | level := 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].							(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].	sel isEmpty ifTrue: [^ nil].	sel isOctetString ifTrue: [sel := sel asOctetString].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size == 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit := (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit := self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'dc 4/10/2007 09:36'!keywords	"Answer an array of the keywords that compose the receiver."	| kwd char keywords |	keywords := Array streamContents:		[:kwds | kwd := WriteStream on: (String new: 16).		1 to: self size do:			[:i |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!romanNumber	| value v1 v2 |	value := v1 := v2 := 0.	self reverseDo:		[:each |		v1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).		v1 >= v2			ifTrue: [value := value + v1]			ifFalse: [value := value - v1].		v2 := v1].	^ value! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size == 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:13'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos := self findFirst: [:d | d isDigit not]) = 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos := self findFirst: [:d | d isDigit]) = 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!squeakToUtf8	"Convert the receiver into a UTF8-encoded string"	^self convertToWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix.  6/7/96 sw"	| stem suffix position |	stem := self.	suffix := 0.	position := 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix :=  stem last digitValue * position + suffix.		position := position * 10.		stem := stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix"'Fred2305' stemAndNumericSuffix"! !!String methodsFor: 'converting' stamp: 'ar 7/21/2007 21:50'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := end+1.	[beginning <= self size and:[(self at: beginning) isSeparator]]		whileTrue:[beginning := beginning + 1].	beginning <= self size] whileTrue: [		"find the end"		end := beginning.		[end <= self size and:[(self at: end) isSeparator not]]			whileTrue:[end := end + 1].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:20'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr := self.	[((curr first = $() and: [curr last = $)])] whileTrue:		[curr := curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: 'converting' stamp: 'ar 6/3/2007 18:32'!utf8ToSqueak	"Convert the receiver from a UTF8-encoded string"	^self convertFromWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	| trimmed lastBlank |	trimmed := self withBlanksTrimmed.	^String streamContents: [:stream |		lastBlank := false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank := c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: 'converting' stamp: 'yo 7/5/2004 16:43'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first result |	first := self findFirst: [:c | c isSeparator not].	first = 0 ifTrue: [^ ''].  "no non-separator character"	result :=  self		copyFrom: first		to: (self findLast: [:c | c isSeparator not]).	result isOctetString ifTrue: [^ result asOctetString] ifFalse: [^ result].	" ' abc  d   ' withBlanksTrimmed"! !!String methodsFor: 'converting' stamp: 'md 9/19/2004 15:19'!withFirstCharacterDownshifted	"Return a copy with the first letter downShifted"		| answer |		self ifEmpty: [^ self copy].	answer := self copy.	answer at: 1 put: (answer at: 1) asLowercase.	^ answer. ! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	listOfLines := OrderedCollection new.	currentLast := 0.	[currentLast < self size] whileTrue:		[currentStart := currentLast + 1.		putativeLast := (currentStart + aNumber - 1) min: self size.		putativeLine := self copyFrom: currentStart to: putativeLast.		(crPosition := putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast := currentStart + crPosition - 1.			putativeLine := self copyFrom: currentStart to: putativeLast].		currentLast := putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast := putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString := listOfLines first.	2 to: listOfLines size do:		[:i | resultString := resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'converting' stamp: 'tak 4/25/2004 12:57'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	"' test ' withSeparatorsCompacted = ' test '"	"' test test' withSeparatorsCompacted = ' test test'"	"'test test		' withSeparatorsCompacted = 'test test '"	| out in next isSeparator |	self isEmpty ifTrue: [^ self].	out := WriteStream on: (String new: self size).	in := self readStream.	isSeparator := [:char | char asciiValue < 256				and: [CSSeparators includes: char]].	[in atEnd] whileFalse: [		next := in next.		(isSeparator value: next)			ifTrue: [				out nextPut: $ .				[in atEnd or:					[next := in next.					(isSeparator value: next)						ifTrue: [false]						ifFalse: [out nextPut: next. true]]] whileFalse]			ifFalse: [out nextPut: next]].	^ out contents! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit := (self findFirst: [:m | m isDigit not and: [m ~= $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withoutTrailingBlanks	"Return a copy of the receiver from which trailing blanks have been trimmed."	| last |	last := self findLast: [:c | c isSeparator not].	last = 0 ifTrue: [^ ''].  "no non-separator character"	^ self copyFrom: 1 to: last	" ' abc  d   ' withoutTrailingBlanks"! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit := (self findFirst: [:m | m isDigit or: [m = $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1 to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:17'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER := PUTCOUNTER + 1."	integer := anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self at: location+3 put: (Character value: (integer \\ 256)).	self at: location+2 put: (Character value: (integer bitShift: -8) \\ 256).	self at: location+1 put: (Character value: (integer bitShift: -16) \\ 256).	self at: location put: (Character value: (integer bitShift: -24) \\ 256)."Smalltalk at: #PUTCOUNTER put: 0"! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:18'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength := OrderedCollection new.	runValues := OrderedCollection new.	runStart := 1.	leadingChar := (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar := (self at: index) leadingChar.			runStart := index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!String methodsFor: 'internet' stamp: 'yo 12/28/2003 01:17'!decodeMimeHeader	"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."	| input output temp charset decoder encodedStream encoding pos |	input := ReadStream on: self.	output := WriteStream on: String new.	[output		nextPutAll: (input upTo: $=).	"ASCII Text"	input atEnd]		whileFalse: [(temp := input next) = $?				ifTrue: [charset := input upTo: $?.					encoding := (input upTo: $?) asUppercase.					temp := input upTo: $?.					input next.					"Skip final ="					(charset isNil or: [charset size = 0]) ifTrue: [charset := 'LATIN-1'].					encodedStream := MultiByteBinaryOrTextStream on: String new encoding: charset.					decoder := encoding = 'B'								ifTrue: [Base64MimeConverter new]								ifFalse: [RFC2047MimeConverter new].					decoder						mimeStream: (ReadStream on: temp);						 dataStream: encodedStream;						 mimeDecode.					output nextPutAll: encodedStream reset contents.					pos := input position.					input skipSeparators.					"Delete spaces if followed by ="					input peek = $=						ifFalse: [input position: pos]]				ifFalse: [output nextPut: $=;						 nextPut: temp]].	^ output contents! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!isoToUtf8	"Convert ISO 8559-1 to UTF-8"	| s v |	s := WriteStream on: (String new: self size).	self do: [:c |		v := c asciiValue.		(v > 128)			ifFalse: [s nextPut: c]			ifTrue: [				s nextPut: (192+(v >> 6)) asCharacter.				s nextPut: (128+(v bitAnd: 63)) asCharacter]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s := WriteStream on: (String new: self size).		i := 1.	[i <= self size] whileTrue: [		c := self at: i. i:=i+1.		v := c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) == 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 := self at: i. i:=i+1.					v2 := c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr := Character cr.	lf := Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr := Character cr.	lf := Character linefeed.	crlf := CharacterSet new.	crlf add: cr; add: lf.	inPos := 1.	outPos := 1.	outString := String new: self size.	[ lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos := outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos := newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos := lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos := lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'paragraph support' stamp: 'yo 8/26/2002 22:19'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr := Character cr.	tab := Character tab.	reader := ReadStream on: self.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) = tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~= cr]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	lastSeparator = self size | (ch = cr)		ifTrue: [^aBlock value: leadingTabs].	^ leadingTabs.! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:57'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x := self at: i).		x = $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:58'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x := self at: i).		x = $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'system primitives' stamp: 'ar 4/10/2005 16:55'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0) ifTrue: [(matchTable at: c1 asciiValue + 1)]						ifFalse: [c1 asciiValue + 1])			= ((c2 leadingChar = 0) ifTrue: [(matchTable at: c2 asciiValue + 1)]								ifFalse: [c2 asciiValue + 1])]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!String methodsFor: 'system primitives' stamp: 'yo 11/3/2004 19:24'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric"		(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self findSubstring: ':' in: self startingAt: start matchTable: CaseSensitiveOrder) > 0]			whileTrue:				[numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess := 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess := 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String methodsFor: 'testing' stamp: 'yo 8/4/2003 12:26'!isAsciiString	| c |	c := self detect: [:each | each asciiValue > 127] ifNone: [nil].	^ c isNil.! !!String methodsFor: 'private' stamp: 'yo 11/3/2004 19:24'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices scoreMin results score maxChoices |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection isNil		ifTrue: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!String methodsFor: '*Universes' stamp: 'ls 8/26/2007 09:16'!asUVersion	^UVersion readFromString: self! !!String class methodsFor: 'initialization' stamp: 'ar 4/9/2005 22:37'!initialize   "self initialize"	| order |	AsciiOrder := (0 to: 255) as: ByteArray.	CaseInsensitiveOrder := AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order := order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish := String withAll: (Character allByteCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders := CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.! !!String class methodsFor: 'initialization' stamp: 'yo 8/11/2003 21:11'!initializeHtmlEntities	"self initializeHtmlEntities"	HtmlEntities := (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: Character euro;		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | HtmlEntities at: each put: (index + 159) asCharacter]! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s |	s := self new: 4.	s at: 1 put: (aLong digitAt: 4) asCharacter.	s at: 2 put: (aLong digitAt: 3) asCharacter.	s at: 3 put: (aLong digitAt: 2) asCharacter.	s at: 4 put: (aLong digitAt: 1) asCharacter.	^s"String fromPacked: 'TEXT' asPacked"! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:27'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream := WriteStream on: (self new: 16).	"go to first quote"	inStream skipTo: $'.	done := false.	[done or: [inStream atEnd]]		whileFalse: 			[char := inStream next.			char = $'				ifTrue: 					[char := inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done := true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!String class methodsFor: 'instance creation' stamp: 'dc 2/12/2007 10:47'!space	"Answer a string containing a single space character."	^ self with: Character space! !!String class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:34'!with: aCharacter	| newCollection |	aCharacter asInteger < 256		ifTrue:[newCollection := ByteString new: 1]		ifFalse:[newCollection := WideString new: 1].	newCollection at: 1 put: aCharacter.	^newCollection! !!String class methodsFor: 'primitives' stamp: 'yo 12/15/2005 13:41'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := (string1 at: i) asInteger.			c2 := (string2 at: i) asInteger.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := (string1 at: i) asInteger.		c2 := (string2 at: i) asInteger.		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'nice 3/15/2007 20:59'!findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start 	"Trivial, non-primitive version"		start		to: aString size		do: [:i | (aCharacterSet					includes: (aString at: i))				ifTrue: [^ i]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	| stringSize |	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asInteger = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:29'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asInteger.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	| char |	start to: stop do: [:i |		char := (aString at: i) asInteger.		char < 256 ifTrue: [aString at: i put: (table at: char+1)].	].! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:21'!noSeparatorMap	^CSNonSeparators byteArrayMap! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:28'!separatorMap	^CSSeparators byteArrayMap! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents := textOrString "asString"! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents := aStringOrText! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window := (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'jm 3/24/98 17:56'!initialize	"Initialize the state of the receiver with its default contents."	contents := self defaultContents.! !!StringHolder methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 10:15'!openLabel: aString andTerminate: terminateBoolean	"Create a standard system view of the model, me, a StringHolder and open it.; do not terminate the active process if in mvc"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphLabel: aString].	topView := (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView := PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	terminateBoolean		ifTrue:			[topView controller open]		ifFalse:			[topView controller openNoTerminate]! !!StringHolder methodsFor: 'tiles' stamp: 'di 11/4/2000 11:07'!openSyntaxView	"Open a syntax view on the current method"	| class selector |	(selector := self selectedMessageName) ifNotNil: [		class := self selectedClassOrMetaClass.		SyntaxMorph testClass: class andMethod: selector.	]! !!StringHolder class methodsFor: 'class initialization'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace := StringHolder new"	"StringHolder initialize"! !!StringHolderController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:14'!performMenuMessage: aSelector	"Intercept #again so the model does not get locked by keying the search text."	| hadEdits |	hadEdits := view canDiscardEdits not.	super performMenuMessage: aSelector.	(hadEdits not and:	 [aSelector == #again and:	 [(UndoMessage sends: #undoAgain:andReselect:typedKey:) and:	 [UndoMessage arguments at: 3]]])		ifTrue: [self userHasNotEdited].! !!StringHolderView methodsFor: 'initialize-release' stamp: 'jm 3/24/98 14:39'!initialize 	"Refer to the comment in View|initialize."	super initialize.	displayContents := '' asParagraph.	hasUnacceptedEdits := false.	askBeforeDiscardingEdits := true.! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents := Paragraph withText: aString asText		style: TextStyle default copy		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)		clippingRectangle: self insetDisplayBox		foreColor: self foregroundColor backColor: self backgroundColor.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 14:38'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 17:17'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	hasUnacceptedEdits := aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'dgd 9/21/2003 17:42'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated) ifTrue: [model clearUserEditFlag].		^ self].	stripes := (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel := self confirm: 'Changes have not been saved.Is it OK to cancel those changes?' translated.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView class methodsFor: 'instance creation'!container: aContainer 	"Answer an instance of me whose model is aContainer. Give it a 2-dot 	border."	| aCodeView |	aCodeView := self new model: aContainer.	aCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^aCodeView! !!StringHolderView class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	Smalltalk isMorphic ifTrue: [^ aStringHolder openAsMorphLabel: labelString].	aStringHolderView := self container: aStringHolder.	topView := StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !!StringReadoutTile methodsFor: 'accessing' stamp: 'sw 11/1/97 13:15'!literal: anObject	literal := anObject.	self updateLiteralLabel.	submorphs last informTarget! !!StringReadoutTile methodsFor: 'literal' stamp: 'sw 9/15/1999 15:14'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal := anObject.	self updateLiteralLabel.	submorphs last setWidth: w.	self updateLiteralLabel! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/3/2004 18:04'!decodeStringArray: aString	| idx numStrings |	idx _ 1.	numStrings _ aString getInteger32: idx.	idx _ idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size _ aString getInteger32: idx.		idx _ idx + 4.		str _ aString copyFrom: idx to: idx+size-1.		idx _ idx + size.		str ]	! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!encodeStringArray: stringArray	| size outBuf outBufIndex |	size _ self spaceToEncode: stringArray.		outBuf _ String new: size.	outBufIndex _ 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].		^outBuf! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!spaceToEncode: stringArray	^stringArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!StringTest methodsFor: 'tests - converting' stamp: 'dc 4/10/2007 09:35'!testUpTo	"self debug: #testUpTo"	self assert: #up:to: keywords = #(up: to:).	self assert: #copy:from:to: keywords = #(copy: from: to:).	self assert: #up keywords = #(up).	self assert: #at: keywords = #(at:).	! !!StringTest methodsFor: 'tests - converting' stamp: 'md 2/5/2007 15:21'!testZipped	| compressed |		compressed := 'hello' zipped.	self assert: (compressed unzipped = 'hello').! !!StringTest methodsFor: 'testing - converting' stamp: 'KR 06/24/2005 11:21'!testPercentEncodingJa	| leading hiraA hiraO hiraAO encodedHiraA encodedHiraO encodedHiraAO |    "Make Japanese String from unicode. see http://www.unicode.org/charts/PDF/U3040.pdf"     leading := JapaneseEnvironment leadingChar.	hiraA := (Character leadingChar: leading code: 16r3042) asString.  "HIRAGANA LETTER A"	hiraO := (Character leadingChar: leading code: 16r304A) asString.  "HIRAGANA LETTER O"	hiraAO := hiraA, hiraO.	"Percent Encoded Japanese String"	encodedHiraA := hiraA encodeForHTTP.	self assert: encodedHiraA = '%E3%81%82'.	encodedHiraO := hiraO encodeForHTTP.	self assert: encodedHiraO = '%E3%81%8A'.	encodedHiraAO := hiraAO encodeForHTTP.	self assert: encodedHiraAO =  '%E3%81%82%E3%81%8A'.     "without percent encoded string"	self assert: '' unescapePercents = ''.	self assert: 'abc' unescapePercents = 'abc'.	"latin1 character"	self assert: hiraAO unescapePercents = hiraAO.  "multibyte character"	"encoded latin1 string"	self assert: '%61' unescapePercents = 'a'.	self assert: '%61%62%63' unescapePercents = 'abc'.	"encoded multibyte string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: encodedHiraA unescapePercents = hiraA.		self assert: encodedHiraAO unescapePercents = hiraAO].	"mixed string"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraAO,'a') unescapePercents = (hiraAO, 'a').		self assert: ('a', encodedHiraA) unescapePercents = ('a', hiraA).		self assert: ('a', encodedHiraA, 'b')  unescapePercents = ('a', hiraA, 'b').		self assert: ('a', encodedHiraA, 'b', encodedHiraO) unescapePercents = ('a', hiraA, 'b', hiraO).		self assert: (encodedHiraA, encodedHiraO, 'b', encodedHiraA) unescapePercents = (hiraA, hiraO, 'b', hiraA)].	"for Seaside"	Locale currentPlatform: (Locale isoLanguage: 'ja') during: [ 		self assert: (encodedHiraA, '+', encodedHiraO) unescapePercents = (hiraA, ' ', hiraO)].! !!StringTest methodsFor: 'tests - indexOf' stamp: 'nice 3/15/2007 21:11'!testIndexOf		"test for http://bugs.impara.de/view.php?id=3574"	self assert: ('abc-' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 4.	self assert: ('ab7' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 3.	self assert: ('a2c' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 2.	self assert: ('3bc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 1.	self assert: ('abc' asWideString indexOfAnyOf: (CharacterSet newFrom: ' -0123456789')) = 0.		"extension to wide characters"	self assert: ((String with: 803 asCharacter with: 811 asCharacter) indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 2.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: 812 asCharacter))) = 0.		self assert: ('abc' indexOfAnyOf: (CharacterSet newFrom: (String with: 811 asCharacter with: $c))) = 3.		"make sure start index is used in wide string algorithm"	self assert: ('ab bcd abc' copyWith: 811 asCharacter) substrings = {'ab'. 'bcd'. 'abc' copyWith: 811 asCharacter}.! !!StringTest methodsFor: 'testing - instance creation' stamp: 'dc 3/21/2007 11:22'!testSpace	"self debug: #testSpace"		string := String new.	self assert: string size = 0. "instead of #isEmpty to be consistent with the following test"		string := String space.	self assert: string size = 1.	self assert: string = ' '! !!Switch methodsFor: 'action'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction := anAction fixTemps! !!Switch methodsFor: 'action'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction := anAction fixTemps! !!Switch methodsFor: 'state'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on := false.			self changed]! !!Switch methodsFor: 'state'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on := true.			self changed]! !!Switch methodsFor: 'state'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on := false.			self changed.			self doAction: offAction]! !!Switch methodsFor: 'state'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on := true.			self changed.			self doAction: onAction]! !!Switch methodsFor: 'private'!initializeOff	on := false. 	onAction := nil.	offAction := nil! !!Switch methodsFor: 'private'!initializeOn	on := true. 	onAction := nil.	offAction := nil! !!Symbol methodsFor: 'converting' stamp: 'ar 4/10/2005 22:42'!asString 	"Refer to the comment in String|asString."	| newString |	newString := self species new: self size.	newString replaceFrom: 1 to: newString size with: self startingAt: 1.	^newString! !!Symbol class methodsFor: 'access' stamp: 'yo 11/3/2004 19:24'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	aString first isLetter ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'RAA 5/29/2001 14:35'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with leadingCharacters.	Symbols beginning with a lower-case letter handled directly here.	Ignore case after first char.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines"	| size firstMatch key |	size := leadingCharacters size.	size = 0 ifTrue: [^skipSym ifNil: [#''] ifNotNil: [nil]].	firstMatch := leadingCharacters at: 1.	size > 1 ifTrue: [key := leadingCharacters copyFrom: 2 to: size].	self allSymbolTablesDo: [:each |			each size >= size ifTrue:				[					((each at: 1) == firstMatch and:						[key == nil or:							[(each findString: key startingAt: 2 caseSensitive: false) = 2]])								ifTrue: [^each]				]		] after: skipSym.	^nil"Symbol thatStarts: 'sf' skipping: nil""Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""Symbol thatStarts: 'candidate' skipping: nil"! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 12/17/2000 18:05'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols + 25% (changed from 1000 since sets like to have 25% free and the extra space would grow back in a hurry)"	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable array size.	SymbolTable growTo: SymbolTable size * 4 // 3 + 100.	^oldSize printString,'  ',(oldSize - SymbolTable array size) printString, ' slot(s) reclaimed'! !!Symbol class methodsFor: 'class initialization' stamp: 'RAA 5/29/2001 09:04'!initialize	"Symbol initialize"	Symbol rehash.	OneCharacterSymbols := nil.	OneCharacterSymbols := (1 to: 256) collect: [ :i | (i - 1) asCharacter asSymbol].	Smalltalk addToShutDownList: self.! !!Symbol class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:37'!intern: aStringOrSymbol 	^(self lookup: aStringOrSymbol) ifNil:[		| aClass aSymbol |		aStringOrSymbol isSymbol ifTrue:[			aSymbol := aStringOrSymbol.		] ifFalse:[			aClass := aStringOrSymbol isOctetString ifTrue:[ByteSymbol] ifFalse:[WideSymbol].			aSymbol := aClass new: aStringOrSymbol size.			aSymbol string: aStringOrSymbol.		].		NewSymbols add: aSymbol.		aSymbol].! !!Symbol class methodsFor: 'private' stamp: 'ar 4/10/2005 22:43'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol),  	otherwise supply the symbol to symBlock and return true."	| symbol |	^ (symbol := self lookup: aString)		ifNil: [false]		ifNotNil: [symBlock value: symbol.			true]! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 14:33'!possibleSelectorsFor: misspelled 	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long first ss |	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs := lookupString numArgs.	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].	first := lookupString first.	short := lookupString size - (lookupString size // 4 max: 3) max: 2.	long := lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates := OrderedCollection new.	self allSymbolTablesDo: [:s | (((ss := s size) >= short	"not too short"			and: [ss <= long			"not too long"					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"			and: [s numArgs = numArgs])	"and numArgs is the same"			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best := lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary := misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !!Symbol class methodsFor: 'private' stamp: 'RAA 5/29/2001 09:04'!shutDown: aboutToQuit	SymbolTable addAll: NewSymbols.	NewSymbols := WeakSet new.! !!SymbolListTile methodsFor: 'accessing' stamp: 'yo 7/2/2004 21:27'!literal: anObject	"Set the receiver's literal as indicated"	self flag: #yo.	literal := anObject asSymbol.	self updateLiteralLabel."	key := Vocabulary eToyVocabulary translationKeyFor: literal.	key isNil ifFalse: [literal := key]."	self flag: #deferred.  "The below formerly was necessary but now is problematical, leading to low-space condition etc.  May need to revisit, since as I comment this out now I am uncertain what if anything this may break"	"self labelMorph informTarget"! !!SymbolListTile methodsFor: 'customevents-initialization' stamp: 'nk 7/21/2003 22:14'!updateChoices	choices := (Vocabulary vocabularyNamed: dataType) choices.	(choices includes: literal) ifFalse: [ literal := choices first. self changed ]! !!SymbolListTile methodsFor: 'initialization' stamp: 'sw 10/30/2000 09:04'!choices: choiceList dataType: aDataType	"Initialize the receiver with the given choice-list and data type"	choices := choiceList.	dataType := aDataType.	literal := choiceList first! !!SymbolListTile methodsFor: 'initialization' stamp: 'tak 12/6/2004 01:38'!initialize	super initialize.	literal := #nothing! !!SymbolListTile methodsFor: 'misc' stamp: 'sw 11/6/2001 13:30'!setLiteralInitially: anObject	"Establish the initial literal.  Get the label correct, but do *not* send the value back to the target via the setter (unlike #literal:)"	literal := anObject ifNotNil: [anObject asSymbol].	self updateLiteralLabel! !!SymbolListTile methodsFor: 'player viewer' stamp: 'yo 1/12/2005 14:28'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed.  Copied down, for jimmying, unfortunately"	| myLabel |	(myLabel := self labelMorph) ifNil: [^ self].	myLabel useSymbolFormat.	myLabel acceptValue: literal asString.	self changed.! !!SymbolListType methodsFor: '*eToys-tiles' stamp: 'sw 12/3/2001 19:15'!defaultArgumentTile	"Answer a tile to represent the type"	| aTile choices |	aTile := SymbolListTile new choices: (choices := self choices) dataType: self vocabularyName.	aTile addArrows.	aTile setLiteral: choices first.	^ aTile! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 8/21/2001 09:36'!actualObject	| sub |	"Who is self in these tiles?  Usually a Player."	(self nodeClassIs: LiteralVariableNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		"Need to decompile here for odd synonyms of 'self' ?"		^ Compiler evaluate: sub contents for: Player logged: false].	(self nodeClassIs: VariableNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		^ References at: (self cleanUpString: sub) asSymbol ifAbsent: [nil]].	(self nodeClassIs: LiteralNode) ifTrue: [		(sub := self findA: StringMorph) ifNil: [^ nil].		^ Compiler evaluate: sub contents for: nil logged: false].	(sub := self findA: SyntaxMorph) ifNil: [^ nil].	^ sub actualObject	"receiver"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/20/2001 13:21'!argumentNodes	"Return a collection of this message's argument nodes.  "	| cls coll rec |	parseNode ifNil: [^ #()].	cls := parseNode class.	cls == SelectorNode ifTrue: [^ #()].	cls == KeyWordNode ifTrue: [^ #()].	coll := OrderedCollection new.	rec := self receiverNode.	submorphs do: [:sub | 		(sub isSyntaxMorph and: [sub ~~ rec]) ifTrue: [			sub isNoun ifTrue: [coll addLast: sub]	"complete arg"				ifFalse: [coll := coll, sub argumentNodes]]].	"MessagePartNode, MessageNode with no receiver"	^ coll! !!SyntaxMorph methodsFor: 'accessing' stamp: 'di 12/13/2000 15:25'!borderColor: colorOrSymbolOrNil	borderColor = colorOrSymbolOrNil ifFalse: [		borderColor := colorOrSymbolOrNil.		self bounds area < 40000			ifTrue: [self invalidRect: self bounds]			ifFalse: [(self bounds areasOutside: (self bounds insetBy: self borderWidth))						do: [:r | self invalidRect: r]]].! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 4/4/2001 12:36'!cleanUpString: stringSubMorph	| style rawData |	^ stringSubMorph 		valueOfProperty: #syntacticallyCorrectContents 		ifAbsent: [			style := stringSubMorph valueOfProperty: #syntacticReformatting.			rawData := stringSubMorph contents.			 (#(unary tempVariableDeclaration blockarg2 methodHeader1 tempVariable variable) includes: style) ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: nil.			].			style == #keywordGetz ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: 'Getz:'.			].			style == #keywordSetter ifTrue: [				rawData := self unSpaceAndUpShift: 'set ',rawData appending: ':'.			].			style == #unaryGetter ifTrue: [				rawData := self unSpaceAndUpShift: 'get ',rawData appending: nil.			].			(#(keyword2 methodHeader2) includes: style)  ifTrue: [				rawData := self unSpaceAndUpShift: rawData appending: ':'.			].			rawData		]! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 7/19/2001 20:04'!color: aColorOrSymbol	| deselectedColor cc |	aColorOrSymbol isColor ifTrue: [		self valueOfProperty: #deselectedColor ifAbsent: ["record my color the first time"			self setProperty: #deselectedColor toValue: aColorOrSymbol.			^ super color: (self scaleColorByUserPref: aColorOrSymbol)].		^ super color: aColorOrSymbol].	deselectedColor := self valueOfProperty: #deselectedColor ifAbsent: [nil].	deselectedColor ifNotNil: [^ super color: (self scaleColorByUserPref: deselectedColor)].	aColorOrSymbol == #comment  ifTrue: [^ self color: Color blue lighter].	SyntaxMorph noTileColor ifTrue: [	"override"		^ self color: Color transparent].	"Fix this to be real color!!"	(cc := self class translateColor: aColorOrSymbol) isColor		ifTrue: [^ self color: cc]		ifFalse: [Transcript show: aColorOrSymbol, ' needs to be handled in translateColor:'; cr.			^ self color: Color transparent].	"help!!"! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/19/2001 15:39'!enclosingPane	"The object that owns this script layout"	| oo higher |	oo := self owner.	[higher := oo isSyntaxMorph.	higher := higher or: [oo class == TransformMorph].	higher := higher or: [oo class == TwoWayScrollPane].	higher ifFalse: [^ oo].	higher] whileTrue: [oo := oo owner].! !!SyntaxMorph methodsFor: 'accessing' stamp: 'RAA 8/15/1999 16:11'!parseNode: x		parseNode := x			! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 9/23/2001 00:27'!receiverObject	"Return some object that could be the receiver to me (a selector).  Either the actual object who is the receiver in this message, or a guy of the right class."	| rec value mm |	(rec := owner) isSyntaxMorph ifFalse: [^ nil].	rec := rec receiverNode.	rec ifNil: [(rec := owner owner) isSyntaxMorph ifFalse: [^ nil].				rec := rec receiverNode].		rec ifNil: [(rec := owner owner owner) isSyntaxMorph ifFalse: [^ nil].				rec := rec receiverNode].	rec isSelfTile ifTrue: [		^ ((mm := self containingWindow model) respondsTo: #targetObject) 			ifTrue: [mm targetObject]			ifFalse: [mm selectedClassOrMetaClass new]].	value := rec ifNotNil: [rec try].	value class == Error ifTrue: [		value := Vocabulary instanceWhoRespondsTo: self selector].	^ value! !!SyntaxMorph methodsFor: 'accessing' stamp: 'tk 1/13/2001 20:08'!rename: newSelector	| keywords mainSel list last |	"Attempt to change the name as listed in my tiles.  Can change the number of argumtents.  MethodNode (SelectorNode (SelectorNode (string))) or MethodNode (SelectorNode (SelectorNode (string) TempVarNode() SelectorNode (string) TempVarNode()))"	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile rename: newSelector  "always do at the root"].	keywords := newSelector keywords.	mainSel := self findA: SelectorNode.	list := mainSel submorphs select: [:mm | 		mm isSyntaxMorph and: [mm parseNode class == SelectorNode]].	1 to: (list size min: keywords size) do: [:ind |		((list at: ind) findA: UpdatingStringMorph) contents: (keywords at: ind)].	keywords size + 1 to: list size do: [:ind | "removing keywords"		[last := mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class == TempVariableNode])] whileFalse: [				last delete].		[last := mainSel submorphs last.		 (last isSyntaxMorph and: [last parseNode class == SelectorNode])] whileFalse: [				last delete].	"the TempVariableNode and others"		mainSel submorphs last delete.	"the SelectorNode"		].	list size + 1 to: keywords size do: [:ind | "adding keywords"		"add a SelectorNode, add a spacer, add a TempVarNode"		mainSel addToken: (keywords at: ind) type: #keyword1 			on: (SelectorNode new key: (keywords at: ind) code: nil).		mainSel addMorphBack: (mainSel transparentSpacerOfSize: 4@4).		(TempVariableNode new name: 'arg', ind printString index: ind type: nil scope: nil)			 asMorphicSyntaxIn: mainSel].! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 2/26/2001 13:39'!constructSelfVariant: receiver and: key	| wordy |	(receiver isKindOf: VariableNode) ifFalse: [^nil].	receiver name = 'self'  ifFalse: [^nil].	(wordy := self translateFromWordySelfVariant: key) ifNil: [^nil].	^wordy! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 3/25/2001 17:16'!noiseStringMorph: aNoiseString	| sMorph |	sMorph := self aSimpleStringMorphWith: aNoiseString.	sMorph 		font: (self fontToUseForSpecialWord: aNoiseString); 		setProperty: #noiseWord toValue: true.	^sMorph! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'tk 7/28/2001 09:05'!translateToWordyGetter: key	"  setBlob:  becomes  's blob :=  "	^ '''s ', 	  (self splitAtCapsAndDownshifted: (key asString allButFirst: 3) 			withFirstCharacterDownshifted)! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'RAA 2/26/2001 13:45'!translateToWordySelfVariant: aString	| lc |	lc := aString asLowercase.	lc = 'me' ifTrue: [^#selfWrittenAsMe].	lc = 'my' ifTrue: [^#selfWrittenAsMy].	lc = 'i''ll' ifTrue: [^#selfWrittenAsIll].	lc = 'i''m' ifTrue: [^#selfWrittenAsIm].	lc = 'this' ifTrue: [^#selfWrittenAsThis].	^nil! !!SyntaxMorph methodsFor: 'card & stack' stamp: 'tk 11/4/2001 21:47'!setTarget: aPlayer	"Find my UpdatingStringMorph and set its getSelector, putSelector, and target"	| updatingString |	(updatingString := self readOut) ifNil: [^ self].	updatingString putSelector: (Utilities setterSelectorFor: self knownName).	updatingString getSelector: (Utilities getterSelectorFor: self knownName).	updatingString target: aPlayer. ! !!SyntaxMorph methodsFor: 'change reporting' stamp: 'tk 9/28/2001 13:36'!colorChangedForSubmorph: colorPatch	| sel newSel cc ms phrase completeMsg |	"reporting a color change"	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(sel := self selector) ifNil: [^ nil].	(Color colorNames includes: sel) | (sel == #r:g:b:) ifFalse: [^ nil].		"a standard color name"	"replace self with new tiles from the color"	(newSel := (cc := colorPatch color) name) 		ifNil: [ms := MessageSend receiver: Color selector: #r:g:b: arguments: 				(Array with: cc red with: cc green with: cc blue).			phrase := ms asTilesIn: Color globalNames: true]		ifNotNil: [ms := MessageSend receiver: Color selector: newSel arguments: #().			phrase := ms asTilesIn: Color globalNames: true].	self deletePopup.	completeMsg := self isNoun ifTrue: [self] ifFalse: [owner].	completeMsg owner replaceSubmorph: completeMsg by: phrase.	"rec setSelection: {rec. nil. rec}."	phrase acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/30/2001 11:09'!morphToDropInPasteUp: aPasteUp	"If property #beScript is true, create a scriptor around me."	| actualObject itsSelector aScriptor adjustment handy tw blk |	(self valueOfProperty: #beScript ifAbsent: [false]) ifFalse: [^ self].	self removeProperty: #beScript.	actualObject := self actualObject ifNil: [					self valueOfProperty: #scriptedPlayer ifAbsent: [nil]].	actualObject ifNil: [^ self].	self removeProperty: #scriptedPlayer.	actualObject assureUniClass.	itsSelector := self userScriptSelector.	aScriptor := itsSelector isEmptyOrNil		ifFalse:			[adjustment := 0@0.			actualObject scriptEditorFor: itsSelector]		ifTrue:			[adjustment := 60 @ 20.			actualObject newScriptorAround: self].	aScriptor ifNil: [^self].	handy := aPasteUp primaryHand.	aScriptor position: handy position - adjustment.	aPasteUp addMorphFront: aScriptor.	"do this early so can find World"	aScriptor showingMethodPane ifFalse: [		"(tw := aScriptor findA: TwoWayScrollPane) ifNil:			[itsSelector ifNil: ['blank script'.				tw := aScriptor findA: TwoWayScrollPane.				blk := (tw scroller findA:  SyntaxMorph ""MethodNode"") findA: BlockNode.				blk addMorphFront: self]].		"		SyntaxMorph setSize: nil andMakeResizable: aScriptor.		].	^ aScriptor! !!SyntaxMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/24/2001 10:04'!structureMatchWith: aMorph	| meNoun itNoun |	"Return true if the node types would allow aMorph to replace me.  This tests the gross structure of the method only."	meNoun := self isNoun.	itNoun := aMorph isNoun.	"Consider these nouns to be equal:  TempVariableNode, LiteralNode, VariableNode, (MessageNode with receiver), CascadeNode, AssignmentNode"	meNoun & itNoun ifTrue: [^ true].	meNoun & aMorph isBlockNode ifTrue: [^ true].	"If I am a BlockNode, and it is a TempVariableNode, add it into list"	"If I am a BlockNode, and it is a noun, add it as a new line"	self isBlockNode ifTrue:		[itNoun ifTrue: [^ true].		(aMorph nodeClassIs: ReturnNode) ifTrue:			[^ (self submorphs				detect: [:mm | ((mm isSyntaxMorph) and: [mm nodeClassIs: ReturnNode])]				ifNone: [nil]) isNil].	"none already in this block"				"If I am a BlockNode, and it is a ReturnNode, add to end"		(aMorph nodeClassIs: CommentNode) ifTrue: [^ true]].	(self isMethodNode) ifTrue: [^ false].	"Later add args and keywords"		"Later allow comments to be dropped in"		"Add MethodTemps by dropping into the main block"	(self nodeClassIs: ReturnNode) & (aMorph parseNode class == MessageNode) 		ifTrue: [^ true].		"Command replace Return"	(self nodeClassIs: MessageNode) & (aMorph parseNode class == ReturnNode) ifTrue: [		(owner submorphs select: [:ss | ss isSyntaxMorph]) last == self			ifTrue: [^ true]].	"Return replace last command"	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			^ self isAVariable & self isDeclaration not]].	"only assign to a variable"	"If nodes are of equal class, replace me with new one."	(self nodeClassIs: aMorph parseNode class) ifTrue: [		(self nodeClassIs: MessageNode) 				ifFalse: [^ true]	"normal match"				ifTrue: [^ self receiverNode == aMorph receiverNode]].	"both nil"	^ false "otherwise reject"! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:21'!keyStroke: evt	"Handle a keystroke event."	| spacer |	evt keyCharacter = Character backspace ifTrue:		[(owner notNil and: [owner isSyntaxMorph]) ifTrue:			[owner isBlockNode ifTrue:				["Delete a statement."				(spacer := self submorphAfter) class == AlignmentMorph						ifTrue: [spacer delete].				self delete].			]].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 9/26/2001 05:56'!mouseDown: evt 	| dup rootTile |	evt yellowButtonPressed ifTrue: [^ self showMenu: evt].	(rootTile := self rootTile) isMethodNode ifTrue:		[self currentSelectionDo:			[:innerMorph :mouseDownLoc :outerMorph |			(outerMorph notNil and: [self == innerMorph])				ifTrue: ["Click on prior selection -- record click point."						self setSelection: {self. evt cursorPoint. outerMorph}]				ifFalse: ["A new selection sequence."						self setSelection: {self. evt cursorPoint. nil}]].		^ self].	"Out in the world -- treat as a unit"	rootTile isSticky ifTrue: [^ self].	"later may allow to be selected"	rootTile isPartsDonor 		ifTrue: [dup := rootTile duplicate.				dup setProperty: #beScript toValue: true]		ifFalse: [dup := rootTile].	evt hand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: evt hand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 10/17/2001 13:41'!mouseMove: evt	| dup selection |	owner isSyntaxMorph ifFalse: [^ self].false ifTrue: ["for now, do not drag off a tile"	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		mouseDownLoc ifNotNil: [			(evt cursorPoint dist: mouseDownLoc) > 4 ifTrue:				["If drag 5 pixels, then tear off a copy of outer selection."				selection := outerMorph ifNil: [self].				selection deletePopup.				evt hand attachMorph: (dup := selection duplicate).				Preferences tileTranslucentDrag					ifTrue: [dup lookTranslucent]					ifFalse: [dup align: dup topLeft								with: evt hand position + self cursorBaseOffset].				self setSelection: nil.	"Why doesn't this deselect?"				(self firstOwnerSuchThat: [:m | m isSyntaxMorph and: [m isBlockNode]])					ifNotNilDo: [:m | "Activate enclosing block."								m startStepping]]]].	].! !!SyntaxMorph methodsFor: 'event handling' stamp: 'di 11/17/2000 08:13'!mouseUp: evt	| newSel |	self rootTile isMethodNode ifFalse: [^ self].	self currentSelectionDo:		[:innerMorph :mouseDownLoc :outerMorph |		newSel := outerMorph			ifNil: [self "first click"]			ifNotNil: [(outerMorph firstOwnerSuchThat:							[:m | m isSyntaxMorph and: [m isSelectable]]) ifNil: [self]].		newSel isMethodNode ifTrue: [^ self setSelection: nil].		self setSelection: {self. nil. newSel}]! !!SyntaxMorph methodsFor: 'event handling' stamp: 'tk 12/1/2000 15:42'!wantsKeyboardFocusFor: aSubmorph	| doEdit |	"only let strings edit on shift-click.  Editing on ordinary click defeats the brown selection and tile dragging."	doEdit := self world primaryHand lastEvent shiftPressed.	doEdit ifTrue: ["remove the arrows during editing"		self valueOfProperty: #myPopup ifPresentDo: [:panel |			panel delete. self removeProperty: #myPopup]].	^ doEdit! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'di 2/21/2001 11:42'!alansTest1		| root |	root := self rootTile ifNil: [self].	^root valueOfProperty: #alansNewStyle ifAbsent: [self usingClassicTiles not]! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 2/26/2001 09:02'!controlContrast2: evt	| origin scale startingContrastX |	evt isMouseUp ifTrue: [		^self removeProperty: #startingPointForSomeAdjustment	].	evt isMouseDown ifTrue: [		^self setProperty: #startingPointForSomeAdjustment toValue: evt cursorPoint	].	ContrastFactor ifNil: [ContrastFactor := 0.5].	scale := 200.0.	startingContrastX := ContrastFactor * scale.	origin := self valueOfProperty: #startingPointForSomeAdjustment.	ContrastFactor := (evt cursorPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.	self finalAppearanceTweaks.! !!SyntaxMorph methodsFor: 'formatting options' stamp: 'RAA 5/11/2001 07:41'!controlSpacing2: evt	| origin scale startingContrastX |	evt isMouseUp ifTrue: [		^self removeProperty: #startingPointForSomeAdjustment	].	evt isMouseDown ifTrue: [		^self setProperty: #startingPointForSomeAdjustment toValue: evt cursorPoint	].	SizeScaleFactor ifNil: [SizeScaleFactor := 0.15].	scale := 200.0.	startingContrastX := SizeScaleFactor * scale.	origin := self valueOfProperty: #startingPointForSomeAdjustment.	SizeScaleFactor := (evt cursorPoint x - origin x + startingContrastX) / scale min: 1.0 max: 0.0.	self finalAppearanceTweaks.! !!SyntaxMorph methodsFor: 'initialization' stamp: 'sw 3/6/2001 11:26'!inAPluggableScrollPane	"Answer a PluggableTileScriptorMorph that holds the receiver"	| widget |	widget := PluggableTileScriptorMorph new.	widget extent: 10@10; borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	widget hResizing: #spaceFill; vResizing: #spaceFill.	^ widget! !!SyntaxMorph methodsFor: 'initialization' stamp: 'di 1/31/2001 10:14'!openInWindow	| window widget sel |	sel := ''.	self firstSubmorph allMorphs do: [:rr | 			(rr isKindOf: StringMorph) ifTrue: [sel := sel, rr contents]].	window := (SystemWindow labelled: 'Tiles for ', self parsedInClass printString, '>>',sel).	widget := self inAScrollPane.	widget color: Color paleOrange.	window		addMorph: widget		frame: (0@0 extent: 1.0@1.0).	window openInWorldExtent: (		self extent + (20@40) min: (Display boundingBox extent * 0.8) rounded	)! !!SyntaxMorph methodsFor: 'initialization' stamp: 'FBS 2/24/2004 14:21'!returnNode: aNode expression: expr	| row expMorph sMorph aNoiseString |	row := self addRow: #return on: aNode.	self alansTest1 ifTrue: [		row setSpecialOuterTestFormat.		aNoiseString := ' Reply '.		sMorph := self aSimpleStringMorphWith: aNoiseString.		sMorph 			emphasis: TextEmphasis bold emphasisCode;			setProperty: #syntacticallyCorrectContents toValue: '^'.		row addMorphBack: sMorph.	] ifFalse: [		row addToken: '^ ' type: #upArrow on: aNode.	].	expMorph := expr asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [		(expMorph hasProperty: #deselectedColor) ifFalse: [expMorph setConditionalPartStyle].	].	expr addCommentToMorph: row.	^row! !!SyntaxMorph methodsFor: 'initialization' stamp: 'tk 1/19/2001 13:29'!sample: arg1"a comment"| temp1 |temp1 := 5.temp1 yourself.temp1 min: arg1.! !!SyntaxMorph methodsFor: 'insertion drop zones' stamp: 'tk 9/13/2001 15:24'!trackDropZones	| hand i localPt insertion insHt ii prevBot nxtHt d c1 c2 ht2 spacer1 spacer2 wid ht1 dc each |	hand := self primaryHand.	("hand lastEvent redButtonPressed &" hand hasSubmorphs		and: [(self hasOwner: hand) not]) ifFalse: [^ self].	insertion := hand firstSubmorph renderedMorph.	insertion isSyntaxMorph ifFalse: [^ self].	insertion isNoun ifFalse: [(insertion nodeClassIs: CommentNode) ifFalse: [^ self]].	localPt := self globalPointToLocal: hand position.	insHt := insertion height.  "**just use standard line height here"	self removeDropZones.  "Maybe first check if in right place, then just tweak heights."	i := (ii := self indexOfMorphAbove: localPt) min: submorphs size-1.	prevBot := i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].	nxtHt := (submorphs isEmpty		ifTrue: [insertion]		ifFalse: [self submorphs at: i+1]) height.	d := ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]			ifFalse: [0 max: (localPt y - prevBot min: nxtHt)].	"Top and bottom spacer heights cause continuous motion..."	c1 := Color transparent.  c2 := Color transparent.	ht2 := d*insHt//nxtHt.  ht1 := insHt - ht2.	wid := self width - (2*borderWidth) - (2*self layoutInset).	wid isPoint ifTrue: [wid := wid x].	(spacer1 := BorderedMorph newBounds: (0@0 extent: wid@ht1)				color: (ht1 > (insHt//2) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer1 color.	self privateAddMorph: spacer1 atIndex: (i+1 max: 1).	(spacer2 := BorderedMorph newBounds: (0@0 extent: wid@ht2)				color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]))					borderWidth: 1; borderColor: spacer2 color.	spacer1 setProperty: #dropZone toValue: true.	spacer2 setProperty: #dropZone toValue: true.	self privateAddMorph: spacer2 atIndex: (i+3 min: submorphs size+1).	self fullBounds.  "Force layout prior to testing for cursor containment"	"Maintain the drop target highlight -- highlight spacer if hand is in it."	{spacer1. spacer2} do:		[:spacer | (spacer containsPoint: localPt) ifTrue:			[spacer color: self dropColor.			"Ignore border color.  Maybe do it later.			self borderColor = self dropColor				ifTrue: [self borderColor: self stdBorderColor]"]].	"If no submorph (incl spacers) highlighted, then re-highlight the block."	"Ignore border color.  Maybe do it later.	((self wantsDroppedMorph: insertion event: hand lastEvent) and:		[(self submorphs anySatisfy: [:m | m containsPoint: localPt]) not])			ifTrue: [self borderColor: self dropColor].	"	"Dragging a tile within a Block, if beside a tile, color it a dropzone"	"Transcript show: localPt y printString; space; show: submorphs first top 		printString; space; show: submorphs last top printString; cr."	dc := self dropColor.	1 to: ((ii+4 min: submorphs size) max: 1) do: [:ind | 		each := submorphs at: ind.		each isSyntaxMorph ifTrue: [			localPt y >= each top 				ifTrue: ["in this one or beyond"					(localPt y < each bottom) 						ifTrue: [(each submorphs anySatisfy: [:m | 								m containsPoint: localPt])							ifTrue: [each setDeselectedColor]							ifFalse: [each color: dc]]						ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]				ifFalse: [each color = dc ifTrue: [each setDeselectedColor]]]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 9/13/2001 15:28'!acceptDroppingMorph: aMorph event: evt	| itNoun old |	"Two cases: 1) a phrase being dropped into a block.  Add a new line.		2) aMorph is replacing self by dropping on it.	For the moment, you have to drop it the right place (the end of a tile if it is complex).  We do not look at enclosing morphs"	itNoun := aMorph isNoun.	self withAllOwnersDo:		[:m | (m isSyntaxMorph and: [m isBlockNode])				ifTrue: [m stopStepping; removeDropZones]].	self isBlockNode & itNoun ifTrue:		[(aMorph nodeClassIs: TempVariableNode) ifTrue:				["If I am a BlockNode, and it is a TempVariableNode, add it into list"				(self addBlockArg: aMorph)].		"If I am a BlockNode and it is a noun add it as a new line"		^ self addToBlock: aMorph event: evt].					self isBlockNode ifTrue: [		 (aMorph nodeClassIs: CommentNode) ifTrue: [^ self addToBlock: aMorph event: evt].		 (aMorph nodeClassIs: ReturnNode) ifTrue: [^ self addToBlock: aMorph event: evt]].	"Later add args and keywords.  later allow comments to be dropped"	"Can't put statement, literal, assignment, or cascade into left side of assignment"	(owner isSyntaxMorph) ifTrue:		[(owner nodeClassIs: AssignmentNode) ifTrue:			[(owner submorphIndexOf: self) = 1 ifTrue:				[aMorph isAVariable ifFalse: [ ^ self]]]].	(aMorph nodeClassIs: AssignmentNode) ifTrue: [		itNoun ifFalse: ["create a new assignment"			self isAVariable ifTrue: [^ self newAssignment]					ifFalse: [^ self]]].	"only assign to a variable"	aMorph deselect.	(old := owner) replaceSubmorph: self by: aMorph.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:24'!addBlockArg: aMorph	"Add a temporary to a block or the method.  Return true if succeed"	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	"***NOTE: This method should be combined with addTempVar:"	| tempHolder tt var nn |	owner isMethodNode ifTrue: [		^ (self addTempVar: aMorph)].	"Node for them is not inside the block"		"If exists, drop the temp in this block and let user extend it."	nn := aMorph decompile string.	"name"	(self isKnownVarName: nn) ifTrue: [^ false].	"already defined"	tt := self firstSubmorph.	tempHolder := tt firstSubmorph isSyntaxMorph 				ifTrue: [(tt nodeClassIs: BlockArgsNode) 							ifTrue: [tt] ifFalse: [nil]]				ifFalse: [nil].	tempHolder ifNil: ["make new row"		tempHolder := self addRow: #blockarg1 on: (BlockArgsNode new).		tempHolder addNoiseString: self noiseBeforeBlockArg.		tempHolder submorphs last firstSubmorph emphasis: TextEmphasis bold emphasisCode.		tempHolder useRoundedCorners.		self addMorphFront: tempHolder.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	"Know this variable is not present, so add it"	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var := tempHolder addRow: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self aSimpleStringMorphWith: nn).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 3/25/2001 16:15'!addColumn: aColorOrSymbol on: aNode	| col |	self addMorphBack: (col := self class column: aColorOrSymbol on: aNode)."col setProperty: #howCreated toValue: thisContext longStack."	self alansTest1 ifTrue: [		(aColorOrSymbol == #block and: [self isMethodNode not]) ifTrue: [			col setConditionalPartStyle.		].	].	^ col! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:22'!addRow: aColorOrSymbol on: aNode	| row |	self addMorphBack: (row := self class row: aColorOrSymbol on: aNode)."row setProperty: #howCreated toValue: thisContext longStack."	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/24/2001 15:15'!addSingleKeywordRow: aStringLikeItem	| row sMorph modifiedString |	(row := self class row: #text on: nil) borderWidth: 1.	modifiedString := self substituteKeywordFor: aStringLikeItem.	sMorph := self addString: modifiedString special: true.	sMorph font: (self fontToUseForSpecialWord: modifiedString).	modifiedString = aStringLikeItem ifFalse: [		sMorph setProperty: #syntacticallyCorrectContents toValue: aStringLikeItem].	row addMorph: sMorph.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 4/4/2001 13:15'!addString: literalOrVarName special: aBoolean	| answer |	"Create and return an UpdatingStringMorph containing the value.  Use an UpdatingStringMorph, so it can inform its owner when it has been edited. Keep the getSelector being nil"	answer := (self anUpdatingStringMorphWith: literalOrVarName special: aBoolean)		target: self;		putSelector: #acceptIgnoring:;		useStringFormat.	^answer! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:23'!addTempVar: aMorph 	"know we are a block inside a MethodNode" 	"(aMorph nodeClassIs: TempVariableNode) is known to be true."	| tempHolder ii tt var nn |	nn := aMorph decompile string.	"name"	(self isKnownVarName: nn) ifTrue: [^ false].	"already defined"	tempHolder := nil.	(ii := owner submorphIndexOf: self) = 1 ifFalse: [		tt := owner submorphs at: ii - 1.		tt isSyntaxMorph ifTrue: [			(tt nodeClassIs: MethodTempsNode) ifTrue: [tempHolder := tt].			(tt nodeClassIs: UndefinedObject) ifTrue: [tempHolder := tt findA: MethodTempsNode]]].	tempHolder ifNil: [		tempHolder := owner addRow: #tempVariable on: MethodTempsNode new.		tempHolder addNoiseString: self noiseBeforeBlockArg.		tempHolder submorphs last firstSubmorph emphasis: TextEmphasis bold emphasisCode.		tempHolder useRoundedCorners.		owner addMorph: tempHolder inFrontOf: self.		aMorph parseNode name: nn key: nn code: nil.		aMorph parseNode asMorphicSyntaxIn: tempHolder.		tempHolder cleanupAfterItDroppedOnMe.		^ true].	aMorph parseNode name: nn key: nn code: nil.	tempHolder addMorphBack: (tempHolder transparentSpacerOfSize: 4@4).	var := tempHolder addRow: #tempVariable on: aMorph parseNode.	var layoutInset: 1.	var addMorphBack: (self addString: nn special: false).	var cleanupAfterItDroppedOnMe.	^ true! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/10/2001 09:57'!addTextRow: aStringLikeItem	| row tt |	(row := self class row: #text on: nil) borderWidth: 1.	(tt := TextMorph new) contents: aStringLikeItem.	row addMorph: tt.	"row addMorph: (self addString: (aStringLikeItem copyWithout: Character cr) special: false)."	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 7/25/2001 10:01'!addToBlock: aMorph event: evt	"Insert a new line of code.  Figure out who it goes before.  If evt Y is within an existing line (to the right of a tile), then replace that tile."	| whereDropped dropBefore replace |	whereDropped := "self pointFromWorld:" evt cursorPoint.	dropBefore := self submorphs 		detect: [:each | each isSyntaxMorph ifTrue: [			whereDropped y < each top ifTrue: [true]	"before this one"				ifFalse: [whereDropped y < each bottom 							ifTrue: [replace := true]	"replace this one"							ifFalse: [false]]]] "try next line"		ifNone: [nil].	(aMorph nodeClassIs: ReturnNode) ifTrue: [dropBefore := nil].		"Returns are always at the end. (Watch out for comments)"	dropBefore 		ifNil: [self addMorphBack: aMorph]		ifNotNil: [			replace ifNotNil: [aMorph deselect.				self replaceSubmorph: dropBefore by: aMorph.	"replace it!!"				^ dropBefore cleanupAfterItDroppedOnMe].	"now owned by no one"			self addMorph: aMorph inFrontOf: dropBefore].	self cleanupAfterItDroppedOnMe.! !!SyntaxMorph methodsFor: 'layout' stamp: 'FBS 2/24/2004 14:22'!addToken: aString type: aColorOrSymbol on: aNode	| sMorph modifiedString noiseWord row |	row := (self addRow: aColorOrSymbol on: aNode) layoutInset: 1.	self alansTest1 ifFalse: [		sMorph := self addString: aString special: false.		row addMorphBack: sMorph.		^row	].	noiseWord := [ :w |		w ifNotNil: [			row 				addMorphBack: (self noiseStringMorph: w);				addMorphBack: (self tokenVerticalSeparator)		].	].	(self shouldBeBrokenIntoWords: aColorOrSymbol) ifTrue: [		modifiedString := self substituteKeywordFor: aString.		sMorph := self addString: modifiedString special: (aColorOrSymbol ~= #assignmentArrow).			"(#(unary keywordGetz keywordSetter unaryGetter) includes: aColorOrSymbol)"		modifiedString = aString ifFalse: [			sMorph setProperty: #syntacticallyCorrectContents toValue: aString].		sMorph setProperty: #syntacticReformatting toValue: aColorOrSymbol;			contents: modifiedString.	] ifFalse: [		sMorph := self addString: (modifiedString := aString) special: false.	].	(#(keyword2 upArrow) includes: aColorOrSymbol) ifTrue: [		sMorph 			font: (self fontToUseForSpecialWord: modifiedString).	].	(#(keyword2 unary assignmentArrow methodHeader1 methodHeader2) includes: aColorOrSymbol) ifTrue: [		sMorph emphasis: TextEmphasis bold emphasisCode.	].	aColorOrSymbol == #blockarg1 ifTrue: [	].	(aColorOrSymbol == #variable or: [aColorOrSymbol == #tempVariable]) ifTrue: [		aString = 'self' ifTrue: [			sMorph setProperty: #wordyVariantOfSelf toValue: true.		].		noiseWord value: (self noiseWordBeforeVariableNode: aNode string: aString).	].	row addMorphBack: sMorph.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 3/25/2001 17:22'!addTokenSpecialCase: aString type: aColorOrSymbol on: aNode	| sMorph modifiedString noiseWord col |	noiseWord := nil.	sMorph := self addString: aString special: false.	(aColorOrSymbol == #keyword2) ifTrue: [		modifiedString := aString = 'if:' ifTrue: ['Test'] ifFalse: ['Yes'].		sMorph 			font: (self fontToUseForSpecialWord: modifiedString); 			setProperty: #syntacticallyCorrectContents toValue: aString;			contents: modifiedString.	].	col := (self addRow: aColorOrSymbol on: aNode) layoutInset: 1.	noiseWord ifNotNil: [		col 			addMorphBack: (self noiseStringMorph: noiseWord);			addMorphBack: (self transparentSpacerOfSize: 3@1)	].	col addMorphBack: sMorph.	^col! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/24/2001 15:21'!addUnaryRow: aStringLikeItem style: aSymbol	| row sMorph modifiedString fontToUse |	(row := self class row: #text on: nil) borderWidth: 1.	modifiedString := self substituteKeywordFor: aStringLikeItem.	sMorph := self addString: modifiedString special: true.	fontToUse := self fontToUseForSpecialWord: modifiedString.	sMorph 		font: fontToUse emphasis: 1;		setProperty: #syntacticReformatting toValue: #unary.	modifiedString = aStringLikeItem ifFalse: [		sMorph setProperty: #syntacticallyCorrectContents toValue: aStringLikeItem].	row addMorph: sMorph.	self addMorphBack: row.	^row! !!SyntaxMorph methodsFor: 'layout' stamp: 'RAA 2/15/2001 19:43'!foldMessage	"I am a message whose receiver is wide, and whose message part is a column.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow node2 |	node2 := parseNode copy receiver: nil.	messageRow := SyntaxMorph row: #keyword1 on: node2.	messageRow 		addMorph: (self transparentSpacerOfSize: 20@10);		addMorphBack: submorphs last.		"<<handle noise words better"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: (self transparentSpacerOfSize: 4@4);		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 1/15/2001 11:15'!foldMessageOneArg	"I am a message that is wide, a row with receiver and a row with selector and arg.	Rearrange me so that the message part appears indented under the receiver part."	| messageRow node2 |	node2 := parseNode copy receiver: nil.	messageRow := SyntaxMorph row: #keyword1 on: node2.	messageRow addMorph: (self transparentSpacerOfSize: 20@10);			addMorphBack: submorphs second;			addMorphBack: submorphs second.  "was the third"	self listDirection: #topToBottom;		wrapCentering: #topLeft;		addMorphBack: messageRow.! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/22/2001 16:30'!isKnownVarName: newVarName	"Return true if this variable is already known, as an argument, temp var, block temp, or instance variable."	| syntLevel |	(self parsedInClass allInstVarNames includes: newVarName) ifTrue: [^ true].	syntLevel := self.	[syntLevel tempVarNodesDo: [:node | 		node decompile string = newVarName ifTrue: [^ true]].	 (syntLevel := syntLevel owner) isSyntaxMorph] whileTrue.	^ false! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/1/2001 13:06'!removeReturnNode	| blk |	"If last line is ^ self, remove it.  I am a methodNode.  Keep if no other tiles in the block."	blk := self findA: BlockNode.	blk submorphs last decompile string = '^self ' ifTrue: [		(blk submorphs count: [:ss | ss isSyntaxMorph]) > 1 ifTrue: [			blk submorphs last delete]].! !!SyntaxMorph methodsFor: 'layout' stamp: 'tk 8/22/2001 16:35'!tempVarNodesDo: aBlock	"Execute the block for any block temporary variables, method temps, or method args we have"	| tempHolder argsHolder |	((self parseNode class == MethodNode) or: [self parseNode class == BlockNode]) ifTrue: [		self submorphsDoIfSyntax: [:sub | 				(sub nodeClassIs: MethodTempsNode) ifTrue: [tempHolder := sub].				((sub nodeClassIs: UndefinedObject) and: [tempHolder isNil]) ifTrue: [					tempHolder := sub findA: MethodTempsNode].				(sub nodeClassIs: BlockArgsNode) ifTrue: [tempHolder := sub].				(sub nodeClassIs: SelectorNode) ifTrue: [argsHolder := sub].				]			ifString: [:sub | ].		tempHolder ifNotNil: ["Temp variables"			tempHolder submorphsDoIfSyntax: [:sm | 					(sm nodeClassIs: TempVariableNode) ifTrue: [aBlock value: sm]]				ifString: [:sm | ]].		argsHolder ifNotNil: ["arguments"			argsHolder submorphsDoIfSyntax: [:sm | 					(sm nodeClassIs: TempVariableNode) ifTrue: [aBlock value: sm]]				ifString: [:sm | ]].		].	"otherwise do nothing"! !!SyntaxMorph methodsFor: 'layout' stamp: 'ar 8/10/2003 18:19'!unfoldMessage	"I am a message whose message part is a column.	Rearrange me so that the entire message is one row."	| messageRow |	messageRow := self submorphs last.	self removeMorph: messageRow.	messageRow submorphs do: [:m | self addMorphBack: m].! !!SyntaxMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:26'!currentVocabulary	"Answer the current vocabulary associated with the receiver.  If none is yet set, determine an appropriate vocabulary and cache it within my properties dictionary."	| aVocab aSym |	aSym := self valueOfProperty: #currentVocabularySymbol ifAbsent: [nil].	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self removeProperty: #currentVocabulary.			self setProperty: #currentVocabularySymbol toValue: aSym]].	aSym ifNotNil:		[^ Vocabulary vocabularyNamed: aSym].	aVocab := super currentVocabulary.	self setProperty: #currentVocabularySymbol toValue: aVocab vocabularyName.	^ aVocab! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 11/21/2000 16:35'!acceptIfInScriptor	| root |	"If I am in a ScriptEditorMorph, tell my root to accept the new changes."	(self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		root := self rootTile.		root ifNotNil: [root accept]]. ! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 17:15'!acceptInCategory: categoryString	"Turn my current state into the text of a method.  Compile it in my class."	| cls sc sel |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile accept  "always accept at the root"].	(cls := self parsedInClass) ifNil: [^ self].	sel := cls compile: self decompile classified: categoryString.	(sc := self firstOwnerSuchThat: [:mm | mm class == ScriptEditorMorph]) 		ifNotNil: [sc hibernate; unhibernate].	"rebuild the tiles"	^ sel! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/27/2001 19:12'!acceptSilently	"Turn my current state into the text of a method.	Compile it in my class.  Don't rebuild the tiles."	| cls |	self isMethodNode ifFalse: [		self rootTile == self ifTrue: [^ false].  "not in a script"		^ self rootTile acceptSilently  "always accept at the root"].	(self ownerThatIsA: ScriptEditorMorph) ifNil: [^ false].	(cls := self parsedInClass) ifNil: [^ false].	cls compile: self decompile classified: 'scripts'.	^ true! !!SyntaxMorph methodsFor: 'menus' stamp: 'di 5/4/2001 12:14'!acceptUnlogged	"This is an exact copy of acceptSilently, except it does not log to the source file.	Used for all but the last of scrolling number changes."	| cls |	self isMethodNode ifFalse:		[self rootTile == self ifTrue: [^ self].  "not in a script"		^ self rootTile acceptUnlogged  "always accept at the root"].	(self ownerThatIsA: ScriptEditorMorph) ifNil: [^ self].	(cls := self parsedInClass) ifNil: [^ self].	cls compile: self decompile		classified: ClassOrganizer default		withStamp: nil		notifying: nil		logSource: false.! !!SyntaxMorph methodsFor: 'menus' stamp: 'md 8/15/2005 11:02'!decompile	| stream |	"Produce Smalltalk code.  We have a tree of SyntaxMorphs, but not a tree of ParseNodes.  The user has dragged in many SyntaxMorphs, each with its own parseNode, but those nodes are not sewn together in a tree.  The only data we get from a ParseNode is its class.	We produce really ugly code.  But we compile it and decompile (prettyPrint) again for user to see."	stream := ColoredCodeStream on: (Text new: 400).	self printOn: stream indent: 1.	"Tree walk and produce text of the code"	^ stream contents! !!SyntaxMorph methodsFor: 'menus' stamp: 'md 7/23/2006 15:14'!offerTilesMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu |	menu := MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'me, by name' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<me by name>'. aReceiver}.	menu add: 'self' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'self'. VariableNode}.	menu add: '_   (assignment)' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'<assignment>'. nil}.	menu add: '"a Comment"' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'"a comment"\' withCRs. CommentNode}.	menu submorphs last color: Color blue.	menu add: 'a Number' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'5'. LiteralNode}.	menu add: 'a Character' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'$z'. LiteralNode}.	menu add: '''abc''' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'''abc'''. LiteralNode}.	menu add: 'a Symbol constant' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'#next'. LiteralNode}.	menu add: 'true' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'true'. VariableNode}.	menu add: 'a Test' target: self  selector: #attachTileForCode:nodeType: 				argumentList: {'true ifTrue: [self] ifFalse: [self]'. MessageNode}.	menu add: 'a Loop' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'1 to: 10 do: [:index | self]'. MessageNode}.	menu add: 'a Block' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'[self]'. BlockNode}.	menu add: 'a Class or Global' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'Character'. LiteralVariableNode}.	menu add: 'a Reply' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. ReturnNode}.	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 9/17/2001 13:38'!offerVarsMenuFor: aReceiver in: aLexiconModel	"Offer a menu of tiles for assignment and constants"	| menu instVarList cls |	menu := MenuMorph new addTitle: 'Hand me a tile for...'.	menu addLine.	menu add: '(accept method now)' target: aLexiconModel selector: #acceptTiles.	menu submorphs last color: Color red darker.	menu addLine.	menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 				argumentList: {'| temp | temp'. TempVariableNode}.	instVarList := OrderedCollection new.	cls := aReceiver class.	[instVarList addAllFirst: cls instVarNames.	 cls == aLexiconModel limitClass] whileFalse: [cls := cls superclass].	instVarList do: [:nn |		menu add: nn target: self selector: #instVarTile: argument: nn].	menu popUpAt: ActiveHand position forHand: ActiveHand in: World.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 12/14/2001 11:58'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	| updStr |	(updStr := self readOut) ifNotNil: ["If has a place to put per-card data, set that up."		updStr getSelector ifNotNil: [			self setProperty: #holdsSeparateDataForEachInstance toValue: true]].	super putOnBackground.! !!SyntaxMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 17:48'!showMenu: evt	| menu |	menu := MenuMorph new.	self rootTile isMethodNode ifTrue:		[menu add: 'accept method' target: self selector: #accept.		menu addLine.		menu add: 'new temp variable' target: self selector: #attachTileForCode:nodeType: 					argumentList: {'| temp | temp'. TempVariableNode}.		menu addLine.		self parsedInClass allInstVarNames do: [:nn |			menu add: nn,' tile' target: self selector: #instVarTile: argument: nn].		menu addLine.		menu add: 'show code' target: self selector: #showCode.		menu add: 'try out' target: self selector: #try.		menu popUpAt: evt hand position forHand: evt hand in: World].! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'md 7/23/2006 15:11'!attachTileForCode: expression nodeType: nodeClass	| nn master tile |	"create a new tile for a part of speech, and put it into the hand"	"a few special cases"	expression = 'self' ifTrue: [		^ (((self string: expression toTilesIn: Object) 				findA: ReturnNode) findA: nodeClass) attachToHand].	expression = '<me by name>' ifTrue: ["Tile for the variable in References"		nn := nodeClass knownName ifNil: [#+].		(References at: nn asSymbol ifAbsent: [nil]) == nodeClass ifTrue: [			^ self attachTileForCode: nn nodeType: LiteralVariableNode].		"otherwise just give a tile for self"		^ self attachTileForCode: 'self' nodeType: VariableNode].	expression = '<assignment>' ifTrue: ["do something really special"		master := self class new.		master addNoiseString: '  _   ' emphasis: TextEmphasis bold emphasisCode.		tile := master firstSubmorph.		^ (tile parseNode: AssignmentNode new) attachToHand].	"special marker"		"When this is dropped on a variable, enclose it in 			a new assignment statement"	"general case -- a tile for a whole line of code is returned"	^ ((self string: expression toTilesIn: Object) 				findA: nodeClass) attachToHand.! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 8/30/2001 06:22'!instVarTile: aName	"Make and put into hand a tile for an instance variable"	| sm |	sm := ((VariableNode new					name: aName					index: 1					type: 1 "LdInstType") asMorphicSyntaxIn: SyntaxMorph new).	sm roundedCorners.	ActiveHand attachMorph: sm.	Preferences tileTranslucentDrag		ifTrue: [sm lookTranslucent.			sm align: sm center with: ActiveHand position "+ self cursorBaseOffset"]		ifFalse: [sm align: sm topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'new tiles' stamp: 'tk 9/13/2001 13:44'!string: anExpression toTilesIn: playerClass	| code tree methodNode |	"Construct SyntaxMorph tiles for some code.  Returns the main BlockNode of a doIt."	"This is really cheating!!  Make a true parse tree later. -tk"	code := String streamContents: [:strm | 		strm nextPutAll: 'doIt'; cr; tab; nextPutAll: anExpression].	"decompile to tiles"	tree := Compiler new 		parse: code 		in: playerClass		notifying: nil.	methodNode := tree asMorphicSyntaxUsing: SyntaxMorph.	anExpression first == $" ifTrue: ["a comment" 		"(methodNode findA: CommentNode) firstSubmorph color: Color blue."		^ methodNode].	^ methodNode submorphs detect: [:mm | 		(mm respondsTo: #parseNode) 			ifTrue: [mm parseNode class == BlockNode] 			ifFalse: [false]].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/31/2001 17:27'!addTemporaryControls	| row stdSize |		stdSize := 8@8.	row := AlignmentMorph newRow		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self addMorphBack: row.	{		Morph new			extent: stdSize; 			color: Color paleBlue darker;			setBalloonText: 'Change the contrast';			on: #mouseUp send: #controlContrast2: to: self;			on: #mouseMove send: #controlContrast2: to: self;			on: #mouseDown send: #controlContrast2: to: self.	"Removed because it's default is giant tiles, which no one wants. --tk		Morph new			extent: stdSize; 			color: Color green;			setBalloonText: 'Change basic spacing';			on: #mouseUp send: #controlSpacing2: to: self;			on: #mouseMove send: #controlSpacing2: to: self;			on: #mouseDown send: #controlSpacing2: to: self.	"		Morph new			extent: stdSize; 			color: Color lightRed;			setBalloonText: 'Change basic style';			on: #mouseUp send: #changeBasicStyle to: self.	} do: [ :each |		row addMorphBack: each.		row addMorphBack: (self transparentSpacerOfSize: stdSize).	].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'yo 12/3/2004 17:01'!alanBinaryPostRcvr: aNode key: key args: args	| nodeWithNilReceiver row |"==Repeat for collection [ collect ( from foo. blah blah foo blah) ]Repeat for 1 to 50 [ do ( from i. blah blab i blah ) ]=="	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	row addToken: key asString		type: #binary		on: (SelectorNode new key: key asString code: nil "fill this in?").	args first asMorphicSyntaxIn: row.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/30/2001 14:52'!alanKeywordMessage: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver column keywords row onlyOne |	(key == #collect: and: [args first isKindOf: BlockNode]) ifTrue: [		^self			alanKwdCollect: aNode 			isAConditional: template 			key: key 			args: args	].	key == #repeatFor:doing: ifTrue: [		^self			alanKwdRepeatForDoing: aNode 			isAConditional: template 			key: key 			args: args	].	key == #if:do: ifTrue: [		^self			alanKwdIfDo: aNode 			isAConditional: template 			key: key 			args: args	].	(args size = 1 and: [key endsWith: 'Getz:']) ifTrue: [		^self			alanKwdSetter: aNode 			isAConditional: 0 			key: key 			args: args	].	(args size = 1 and: [self isStandardSetterKeyword: key]) ifTrue: [		^self			alanKwdSetter2: aNode 			isAConditional: 0 			key: key 			args: args	].	nodeWithNilReceiver := aNode copy receiver: nil.	template = 1 ifTrue: [		self listDirection: #topToBottom.	].	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	keywords := key keywords.	onlyOne := args size = 1.	onlyOne ifFalse: ["necessary for three keyword messages!!"		column setProperty: #deselectedBorderColor toValue: column compoundBorderColor].	keywords		with: (args first: keywords size)		do: [:kwd :arg |			template = 1 ifTrue: [				column addMorphBack: (column transparentSpacerOfSize: 3@3).			].			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: 						(onlyOne ifTrue: [MessageNode] ifFalse: [MessagePartNode]));				borderColor: row stdBorderColor.			template = 1 ifTrue: [row addMorphBack: (row transparentSpacerOfSize: 20@6)].			row addToken: kwd				type: #keyword2				on: (onlyOne ifTrue: [SelectorNode new key: kwd code: nil "fill this in?"]								ifFalse: [KeyWordNode new]).			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].	onlyOne ifTrue: [		self replaceSubmorph: column by: row.		column := row.	].			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 3/25/2001 16:31'!alanKwdCollect: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row kwdHolder |	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	kwdHolder := row		addToken: key		type: #keyword2		on: (SelectorNode new key: key code: nil "fill this in?").	kwdHolder firstSubmorph 		setProperty: #syntacticallyCorrectContents toValue: key asString;		contents: ''.	args first asMorphicCollectSyntaxIn: row.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/30/2001 14:52'!alanKwdIfDo: aNode isAConditional: template key: key args: args	"(know it has more than one arg)"	| nodeWithNilReceiver column keywords row |	nodeWithNilReceiver := aNode copy receiver: nil.	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	"column borderColor: column compoundBorderColor."	keywords := key keywords.	keywords		with: (args first: keywords size)		do: [:kwd :arg |			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: MessagePartNode).			kwd = 'do:' ifTrue: [				row addMorphBack: (row transparentSpacerOfSize: 26@6).			] ifFalse: [				row addMorphBack: (row transparentSpacerOfSize: 10@6).			].			row addTokenSpecialCase: kwd				type: #keyword2				on: KeyWordNode new.			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/28/2001 10:16'!alanKwdRepeatForDoing: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row column keywords |	nodeWithNilReceiver := aNode copy receiver: nil.	column := self addColumn: #keyword1 on: nodeWithNilReceiver.	keywords := key keywords.	keywords		with: (args first: keywords size)		do: [:kwd :arg |			(row := column addRow: #keyword2 on: nodeWithNilReceiver)				parseNode: (nodeWithNilReceiver as: MessagePartNode).			row addToken: kwd				type: #keyword2				on: KeyWordNode new.			(arg asMorphicSyntaxIn: row) setConditionalPartStyle.		].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'FBS 2/24/2004 14:22'!alanKwdSetter2: aNode isAConditional: template key: key args: args	"translates		foo setHeading: 0	to		foo's heading := 0	"	| kwdHolder wordy |	kwdHolder := self		addToken: key		type: #keywordSetter		on: (SelectorNode new key: key code: nil "fill this in?").	wordy := self translateToWordySetter: key.	kwdHolder firstSubmorph 		setProperty: #syntacticReformatting toValue: #keywordSetter;		contents: wordy;		emphasis: TextEmphasis bold emphasisCode.	wordy = key asString ifFalse: [		kwdHolder firstSubmorph 			setProperty: #syntacticallyCorrectContents toValue: key asString].	(args first asMorphicSyntaxIn: self) setConditionalPartStyle			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'md 7/23/2006 15:15'!alanKwdSetter: aNode isAConditional: template key: key args: args	| nodeWithNilReceiver row kwdHolder |	nodeWithNilReceiver := aNode copy receiver: nil.	(row := self addRow: #keyword2 on: nodeWithNilReceiver)		borderWidth: 1;		parseNode: (nodeWithNilReceiver as: MessageNode);		borderColor: row stdBorderColor.	row addNoiseString: '''s' emphasis: TextEmphasis bold emphasisCode.	kwdHolder := row		addToken: key		type: #keywordGetz		on: (SelectorNode new key: key code: nil "fill this in?").	kwdHolder firstSubmorph 		setProperty: #syntacticReformatting toValue: #keywordGetz;		setProperty: #syntacticallyCorrectContents toValue: key asString;		contents: (self splitAtCapsAndDownshifted: (key asString allButLast: 5));		emphasis: TextEmphasis bold emphasisCode.	row addNoiseString: '_' emphasis: TextEmphasis bold emphasisCode.	(args first asMorphicSyntaxIn: row) setConditionalPartStyle			! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'FBS 2/24/2004 14:21'!alanUnaryGetter: aNode key: key	"I am a MessageNode.  Fill me with a SelectorNode {getX} whose string is {'s x}.  All on one level."	| selSyn usm wordy |	selSyn := self		addToken: key		type: #unaryGetter		on: (SelectorNode new key: key code: nil "fill this in?").	usm := selSyn firstSubmorph.	usm setProperty: #syntacticReformatting toValue: #unaryGetter.	wordy := self translateToWordyGetter: key.	wordy = key asString ifFalse: [		usm setProperty: #syntacticallyCorrectContents toValue: key asString].	usm contents: wordy; emphasis: TextEmphasis bold emphasisCode.! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 4/4/2001 12:49'!alanUnaryPostRcvr: aNode key: key selector: selector	| row |	(self isStandardGetterSelector: key) ifTrue: [		^self alanUnaryGetter: aNode key: key	].	row := (self addUnaryRow: key style: #unary) layoutInset: 1.	^ row parseNode: selector! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'md 7/23/2006 15:14'!assignmentNode: aNode variable: variable value: value	| row v expMorph |	row := self addRow: #assignment on: aNode.	v := variable asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [v setConditionalPartStyle; layoutInset: 2].	row addToken: ' := ' type: #assignmentArrow on: aNode.	expMorph := value asMorphicSyntaxIn: row.	self alansTest1 ifTrue: [		row setSpecialOuterTestFormat.		(expMorph hasProperty: #deselectedColor) ifFalse: [expMorph setConditionalPartStyle].	].	^row! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/22/2001 17:00'!cascadeNode: aNode receiver: receiver messages: messages	| row |	self alansTest1 ifTrue: [		row := self addColumn: #cascade on: aNode.		row setSpecialOuterTestFormat.	] ifFalse: [		row := self addRow: #cascade on: aNode	].	receiver asMorphicSyntaxIn: row.	messages do: [:m | m asMorphicSyntaxIn: row].	^ row"	(node2 := aNode copy) receiver: nil messages: messages.	cascadeMorph := row addColumn: #cascade2 on: node2.	messages do: [ :m | m asMorphicSyntaxIn: cascadeMorph].	^row"! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/26/2001 14:04'!messageOneArg: key receiver: receiver selector: selector args: args	| row firstArgMorph |	row := (self addSingleKeywordRow: key) layoutInset: 1.	row parseNode: selector.	firstArgMorph := args first asMorphicSyntaxIn: self.	receiver ifNil: [^ self].	(firstArgMorph fullBounds height > 100			or: [firstArgMorph fullBounds width > 250])		ifTrue: [self foldMessageOneArg].! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/26/2001 17:12'!methodNodeInner: aNode selectorOrFalse: selectorOrFalse precedence: precedence arguments: arguments temporaries: temporaries primitive: primitive block: block	| header selNode |	selNode := selectorOrFalse class == SelectorNode 		ifTrue: [selectorOrFalse] 		ifFalse: [SelectorNode new key: selectorOrFalse code: nil].	header := self addRow: Color white on: selNode.	precedence = 1		ifTrue: [header addToken: aNode selector type: #methodHeader1 on: selNode]		ifFalse: [aNode selector keywords with: arguments do:					[:kwd :arg | 					header addToken: kwd type: #methodHeader2 on: selNode.					(arg asMorphicSyntaxIn: header) color: #blockarg2]].	aNode addCommentToMorph: self.	self addTemporaries: temporaries.	(primitive > 0 and: [(primitive between: 255 and: 519) not]) ifTrue:		["Dont decompile <prim> for, eg, ^ self "		self addTextRow: (String streamContents: [ :strm | aNode printPrimitiveOn: strm])].	block asMorphicSyntaxIn: self.	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'tk 7/31/2001 17:37'!methodNodeOuter: aNode	| block |		self borderWidth: 0.	aNode asMorphicSyntaxIn: self.	self alansTest1 ifTrue: [self addTemporaryControls].	self finalAppearanceTweaks.		"self setProperty: #deselectedColor toValue: Color transparent."	block := self findA: BlockNode.		"block setProperty: #deselectedColor toValue: Color transparent."	block submorphs size = 1 ifTrue: [^ self].	"keep '^ self' if that is the only thing in method"	block submorphs last decompile string = '^  self ' ifTrue: [		block submorphs last delete].	^ self! !!SyntaxMorph methodsFor: 'node to morph' stamp: 'RAA 2/15/2001 19:49'!vanillaMessageNode: aNode receiver: receiver selector: selector arguments: arguments	| substitute row sel |	sel := #message.	((self nodeClassIs: CascadeNode) and: [self parseNode receiver ~~ aNode]) ifTrue: [		sel := #keyword2.		receiver ifNotNil: [self inform: 'receiver should be nil']].	row := self addRow: sel on: aNode.	substitute := aNode as: TileMessageNode.	(aNode macroPrinter == #printCaseOn:indent:) ifTrue: [		aNode asMorphicCaseOn: row indent: nil.		^ self].	aNode macroPrinter		ifNotNil: 			[substitute perform: aNode macroPrinter with: row with: nil]		ifNil: 			[substitute 				printKeywords: selector key				arguments: arguments				on: row				indent: nil].	^ row addTransparentSpacerOfSize: 3@0.	"horizontal spacing only"! !!SyntaxMorph methodsFor: 'node types' stamp: 'tk 9/26/2001 05:50'!isDeclaration	"Return true if I am a TempVarNode inside a declaration of some kind, including a method arg"	| opc |	owner isSyntaxMorph ifFalse: [^ false].	opc := owner parseNode class.	opc == BlockArgsNode ifTrue: [^ true].	opc == MethodTempsNode ifTrue: [^ true].	opc == SelectorNode ifTrue: [^ true].	^ false! !!SyntaxMorph methodsFor: 'player' stamp: 'tk 2/15/2002 13:03'!variableDocks	"Answer a list of VariableDock objects for docking up my data with an instance held in my containing playfield.  For a numeric-readout tile."	"Is CardPlayer class holding my variableDock, or should I be using the caching mechanism in Morph>>variableDocks?"	| updatingString lab nn aGetter |	(updatingString := self readOut) ifNil: [^ #()].	updatingString getSelector ifNil: [		lab := self submorphNamed: 'label' ifNone: [self defaultName].		nn := lab contents asString.		"nn at: 1 put: nn first asUppercase."		updatingString getSelector: (aGetter := 'get',nn) asSymbol;			putSelector: (ScriptingSystem setterSelectorForGetter: aGetter).		].	^ Array with: (VariableDock new 			variableName: (updatingString getSelector allButFirst: 3) withFirstCharacterDownshifted 			type: #number 			definingMorph: updatingString 			morphGetSelector: #valueFromContents 			morphPutSelector: #acceptValue:)! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'md 7/23/2006 15:14'!assignmentArrow	"Offer to embed this variable in a new assignment statement.  (Don't confuse this with upDownAssignment:, which runs the up and down arrows that rotate among assignment types.)"	| rr |	self isAVariable ifFalse: [^ nil].	self isDeclaration ifTrue: [^ nil].	^ (rr := RectangleMorph new)		extent: 11@13; borderWidth: 1; color: Color lightGreen;		borderColor: Color gray;		addMorph: ((self noiseStringMorph: '_') topLeft: rr topLeft + (3@0));		on: #mouseUp send: #newAssignment to: self! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'gk 2/23/2004 21:08'!changeSound: upDown	| ind arg st soundChoices index it current |	"move in the list of sounds.  Adjust arg tile after me"	ind := owner submorphs indexOf: self.	arg := owner submorphs atWrap: ind+1.	arg isSyntaxMorph ifFalse: [^ self].	st := arg submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	soundChoices := SoundService default sampledSoundChoices.	current := st contents copyFrom: 2 to: st contents size-1.	"remove string quotes"	index := soundChoices indexOf: current.	index > 0 ifTrue:		[st contents: (it := soundChoices atWrap: index + upDown) printString.		self playSoundNamed: it].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/26/2001 14:31'!colorPatch	"Return a color patch button that lets the user choose a color and modifies the code"	| cc patch sel completeMsg |			((self nodeClassIs: MessageNode) "or: [self nodeClassIs: SelectorNode]") ifFalse: [^ nil].	(sel := self selector) ifNil: [^ nil].	(Color colorNames includes: sel) | (sel == #r:g:b:) ifFalse: [^ nil].		"a standard color name"	completeMsg := self isNoun ifTrue: [self] 				ifFalse: [owner isNoun ifTrue: [owner] ifFalse: [owner owner]].	(cc := completeMsg try) class == Color ifFalse: [^ nil].	patch := ColorTileMorph new colorSwatchColor: cc.		"sends colorChangedForSubmorph: to the messageNode"	patch color: Color transparent; borderWidth: 0.  patch submorphs last delete.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 2/21/2001 16:37'!deleteLine	| temp |	temp := owner.	self deletePopup.	self delete.	temp setSelection: nil.	temp acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 2/21/2001 13:09'!dismisser	"Return the icon to delete this line of tiles.  I am an entire line in a block."	| handle handleSpec colorToUse iconName form |	(owner isSyntaxMorph and: [owner nodeClassIs: BlockNode]) ifFalse: [^ nil].	handleSpec := Preferences haloSpecifications fourth.	"dismiss"	handle := EllipseMorph			newBounds: (Rectangle center: 10@10 extent: 16 asPoint)			color: (colorToUse := Color colorFrom: handleSpec color).	iconName := handleSpec iconSymbol.	form := ScriptingSystem formAtKey: iconName.	"#'Halo-Dismiss'"	handle addMorphCentered: (ImageMorph new				image: form; 				color: colorToUse makeForegroundColor;				lock).	handle on: #mouseDown send: #deleteLine to: self.	^ handle! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 10/17/2001 13:38'!dupTile: evt	| dup |	self deletePopup.	"self deselect."	dup := self duplicateMorph: evt.	Preferences tileTranslucentDrag		ifTrue: [dup align: dup center with: evt hand position.				dup lookTranslucent]		ifFalse: [dup align: dup topLeft					with: evt hand position + self cursorBaseOffset].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 10/17/2001 13:29'!duplicator	"Return the icon to duplicate this tile."	| handle handleSpec colorToUse iconName form |	handleSpec := Preferences haloSpecifications at: 11.	"duplicate"	handle := EllipseMorph			newBounds: (Rectangle center: 10@10 extent: 16 asPoint)			color: (colorToUse := Color colorFrom: handleSpec color).	iconName := handleSpec iconSymbol.	form := ScriptingSystem formAtKey: iconName.	"#'Halo-Dup'"	handle addMorphCentered: (ImageMorph new				image: form; 				color: colorToUse makeForegroundColor;				lock).	handle on: #mouseDown send: #dupTile: to: self.	^ handle! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:38'!extend	| messageNodeMorph first |	"replace this noun with a new message like (arg + 1).  If type is not known, ask the user to type in a selector.  Use nil as arg.  Let user drag something to it afterwards."	"Later do evaluation of self to see what type and offer right selector"	self deselect.	messageNodeMorph := (MessageSend receiver: 1 selector: #+ arguments: #(1))								asTilesIn: Player globalNames: false.	owner replaceSubmorph: self by: messageNodeMorph.	first := messageNodeMorph submorphs detect: [:mm | mm isSyntaxMorph].	messageNodeMorph replaceSubmorph: first by: self.	self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 13:14'!extendArrow	"Return the extend arrow button.  It replaces the argument with a new message.	I am a number or getter messageNode."	| patch |		self isNoun ifFalse: [^ nil].	self isDeclaration ifTrue: [^ nil].	patch := (ImageMorph new image: (TileMorph classPool at: #SuffixPicture)).	patch on: #mouseDown send: #extend to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 11:35'!newAssignment	"I am a variableNode.  Place me inside an assignment statement."	| new old |	parseNode name: self decompile.	"in case user changed name"	new := owner assignmentNode: AssignmentNode new variable: parseNode 					value: parseNode copy.	self deselect.	(old := owner) replaceSubmorph: self by: new.	"do the normal replacement"	(old isSyntaxMorph) ifTrue: [old cleanupAfterItDroppedOnMe].	"now owned by no one"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'dgd 2/22/2003 13:40'!offerPopUp	"Put up a halo to allow user to change		Literals (Integer, true),		Selector (beep: sound, +,-,*,//,\\, r:g:b:, setX: incX: decX: for any X,),		Variable (Color),		not AssignmentNode (:= inc dec),	Extend arrows on each literal, variable, and message, (block that is by itself).	Retract arrows on each literal or variable, or message or block that is an argument.	Any literal can be changed by Shift-clicking and typing."	| panel any upDown retract extend colorPatch edge dismiss rr duplicate |	(self hasProperty: #myPopup) ifTrue: [^self].	"already has one"	any := false.	(upDown := self upDownArrows) ifNotNil: [any := true].	"includes menu of selectors"	(retract := self retractArrow) ifNotNil: [any := true].	(extend := self extendArrow) ifNotNil: [any := true].	(dismiss := self dismisser) ifNotNil: [any := true].	(duplicate := self duplicator) ifNotNil: [any := true].	"(assign := self assignmentArrow) ifNotNil: [any := true].			get from menu or any other assignment"	submorphs last class == ColorTileMorph 		ifFalse: [(colorPatch := self colorPatch) ifNotNil: [any := true]].	any ifFalse: [^self].	"Transcript cr; print: parseNode class; space; 		print: (self hasProperty: #myPopup); endEntry."	panel := (RectangleMorph new)				color: Color transparent;				borderWidth: 0.	upDown ifNotNil: 			[panel addMorphBack: upDown first.			upDown first align: upDown first topLeft with: panel topLeft + (0 @ 0).			panel addMorphBack: upDown second.			upDown second align: upDown second topLeft				with: upDown first bottomLeft + (0 @ 1).			upDown size > 2 				ifTrue: 					[panel addMorphBack: upDown third.					upDown third align: upDown third topLeft						with: upDown first topRight + (2 @ 3)]].	rr := self right.	colorPatch ifNotNil: 			[rr := rr + colorPatch submorphs first width + 1.			self addMorphBack: colorPatch	"always in tile"			"colorPatch align: colorPatch topLeft 					with: panel topLeft + (1@1)"].	retract ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: retract.			retract align: retract topLeft with: (edge + 2) @ (panel top + 3)].	extend ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: extend.			extend align: extend topLeft with: (edge + 2) @ (panel top + 3)].	duplicate ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: duplicate.			duplicate align: duplicate topLeft with: (edge + 2) @ (panel top + 1)].	dismiss ifNotNil: 			[edge := panel submorphs isEmpty 						ifTrue: [panel left]						ifFalse: [panel submorphs last right].			panel addMorphBack: dismiss.			dismiss align: dismiss topLeft with: (edge + 2) @ (panel top + 1)].	"	assign ifNotNil: [		edge := panel submorphs isEmpty 			ifTrue: [panel left] 			ifFalse: [panel submorphs last right].		panel addMorphBack: assign.		assign align: assign topLeft with: (edge+2) @ (panel top + 2)]."	panel align: panel topLeft with: rr @ (self top - 2).	panel extent: panel submorphs last bottomRight - panel topLeft.	self setProperty: #myPopup toValue: panel.	self addMorphBack: panel	"Any reason ever to have panel below?"	"(owner listDirection = #topToBottom and: [self listDirection = #leftToRight])		ifTrue: [self addMorphBack: panel]		ifFalse: [owner addMorph: panel after: self]."! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 13:39'!replaceKeyWord: evt menuItem: stringMorph	"Replace my entire message (which may be multi-part) with the one specified.  Preserve all argument tiles, either in the new message or in the world outside the scriptor.  I am a SelectorNode or KeyWordNode."	| menu new news newSel mm newTree newRec newArgs top oldArgNodes share ctrY |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: #(' 5' $ )) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	mm := MessageSend receiver: 5 selector: newSel 			arguments: ((Array new: newSel numArgs) atAllPut: 5).	newTree := mm asTilesIn: Object globalNames: false.	newRec := newTree receiverNode.	newArgs := newTree argumentNodes.	ctrY := self fullBoundsInWorld center y.	top := self messageNode.	newRec owner replaceSubmorph: newRec by: top receiverNode.	oldArgNodes := top argumentNodes.	share := newArgs size min: oldArgNodes size.	(newArgs first: share) with: (oldArgNodes first: share) do: [:newNode :oldNode | 		newNode owner replaceSubmorph: newNode by: oldNode].	"later get nodes for objects of the right type for new extra args"	top owner replaceSubmorph: top by: newTree.	"Deposit extra args in the World"	(oldArgNodes copyFrom: share+1 to: oldArgNodes size) do: [:leftOver |		(leftOver parseNode class == LiteralNode and: [leftOver decompile asString = '5']) 			ifFalse: [newTree pasteUpMorph addMorphFront: leftOver.				leftOver position: newTree enclosingPane fullBoundsInWorld right - 20 @ ctrY.				ctrY := ctrY + 26]			ifTrue: [leftOver delete]].	newTree acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/19/2001 21:32'!replaceSel: evt menuItem: stringMorph	"I rep a SelectorNode.  Replace my selector with new one that was just chosen from a menu"	| menu new old newSel ms oa na case news |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: #(' 5' $ )) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	old := (ms := self findA: StringMorph) valueOfProperty: #syntacticallyCorrectContents.	old ifNil: [old := (self findA: StringMorph) contents].	oa := old numArgs.  na := newSel numArgs.  case := 5.	(oa = 1) & (na = 1) ifTrue: [case := 1]. 	(oa = 0) & (na = 0) ifTrue: [case := 2].	(oa = 1) & (na  = 0) ifTrue: [case := 3].	(oa = 0) & (na  = 1) ifTrue: [case := 4].	case <= 4 ifTrue: ["replace the selector"		ms contents: news.	"not multi-part"		ms setProperty: #syntacticallyCorrectContents toValue: newSel].	case = 3 ifTrue: [owner tossOutArg: 1].	case = 4 ifTrue: [self addArg: 1].	"more cases here.  Rebuild the entire MessageNode"		self acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/28/2001 10:06'!retract	"replace this message with its receiver.  I am the message node."	| rec cascade msg |	(self nodeClassIs: CascadeNode) ifTrue:		["This is a piece of a cascaded message -- just delete it"		self deletePopup.		cascade := owner.		self delete.		cascade setSelection: {cascade. nil. cascade}.		^ cascade acceptIfInScriptor].	self deletePopup.	(rec := self receiverNode)		ifNil: [msg := owner.			rec := owner receiverNode.			msg owner replaceSubmorph: msg by: rec]		ifNotNil: [owner replaceSubmorph: self by: rec].	rec setSelection: {rec. nil. rec}.	rec acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 12/13/2000 12:57'!retractArrow	"Return the retract arrow button.  It replaces the current message with its receiver.	I am in a MessageNode whose first subnode is not a MessagePartNode.  I did not encounter a block on the way up to it.  I am the last subnode in every owner up to it."	| patch |	(self nodeClassIs: MessageNode) ifFalse: [^ nil].	(owner isSyntaxMorph and: [owner parseNode == parseNode]) ifTrue: [^ nil].	patch := (ImageMorph new image: (TileMorph classPool at: #RetractPicture)).	patch on: #mouseDown send: #retract to: self.	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/18/2001 16:27'!selectorMenu	"Put up a menu of all selectors that my receiver could be sent.  Replace me with the one chosen.  (If fewer args, put the tiles for the extra arg to the side, in script's owner (world?).)	Go ahead and eval receiver to find out its type.  Later, mark selectors for side effects, and don't eval those.	Put up a table.  Each column is a viewer category."	| cats value catNames interfaces list setter wording all words ind aVocabulary limitClass |	cats := #().	all := Set new.	value := self receiverObject.	value class == Error ifTrue: [^ nil].		aVocabulary := self vocabularyToUseWith: value.	limitClass := self limitClassToUseWith: value vocabulary: aVocabulary.	catNames := value categoriesForVocabulary: aVocabulary limitClass: limitClass.	cats := catNames collect: [:nn | 		list := OrderedCollection new.		interfaces := value methodInterfacesForCategory: nn 						inVocabulary: aVocabulary limitClass: limitClass.		interfaces do: [:mi | 			(all includes: mi selector) ifFalse: [				"list add: (self aSimpleStringMorphWith: mi elementWording).  Expensive"				words := mi selector.				(words beginsWith: 'get ') ifTrue: [words := words allButFirst: 4].				mi selector last == $: ifTrue: [					words := String streamContents: [:strm | "add fake args"						(words findTokens: $:) do: [:part | strm nextPutAll: part; nextPutAll: ' 5 ']].					words := words allButLast].				mi selector isInfix ifTrue: [words := words, ' 5'].				words := self splitAtCapsAndDownshifted: words.					list add: (self anUpdatingStringMorphWith: words special: true).				words = mi selector ifFalse: [					list last setProperty: #syntacticallyCorrectContents toValue: mi selector].				all add: mi selector].			setter := mi companionSetterSelector asString.			(setter = 'nil') | (all includes: setter) ifFalse: ["need setters also"				wording := (self translateToWordySetter: setter).				list add:  (self aSimpleStringMorphWith: wording, ' 5').				wording = setter ifFalse: [					list last setProperty: #syntacticallyCorrectContents 						toValue: setter].				all add: setter]].		list].	(ind := catNames indexOf: 'scripts') > 0 ifTrue: [		(cats at: ind) first contents = 'empty script' ifTrue: [(cats at: ind) removeFirst]].	cats first addFirst: (self aSimpleStringMorphWith: ' ').	"spacer"	cats first addFirst: (self aSimpleStringMorphWith: '( from ', value class name, ' )').	cats first first color: (Color green mixed: 0.25 with: Color black).	self selectorMenuAsk: cats.	"The method replaceSel:menuItem: does the work.  		and replaces the selector."	! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/20/2001 16:04'!selectorMenuAsk: listOfLists	"I represent a SelectorNode to be replaced by one of the selectors in one of the category lists.  Each list has pre-built StringMorphs in it."	| menu col |	listOfLists isEmpty ifTrue: [^ nil].	listOfLists first addFirst: (self aSimpleStringMorphWith: '( Cancel )').	listOfLists first first color: Color red.	menu := RectangleMorph new.	menu listDirection: #leftToRight; layoutInset: 3; cellInset: 1@0.	menu layoutPolicy: TableLayout new; hResizing: #shrinkWrap; 		vResizing: #shrinkWrap; color: (Color r: 0.767 g: 1.0 b: 0.767);		useRoundedCorners; cellPositioning: #topLeft.	listOfLists do: [:ll |		col := Morph new.	 	col listDirection: #topToBottom; layoutInset: 0; cellInset: 0@0.		col layoutPolicy: TableLayout new; hResizing: #shrinkWrap.		col color: Color transparent; vResizing: #shrinkWrap.		menu addMorphBack: col.		ll do: [:ss | 			col addMorphBack: ss.			ss on: #mouseUp send: #replaceKeyWord:menuItem: to: self]		].	self world addMorph: menu.	menu setConstrainedPosition: (owner localPointToGlobal: self topRight) + (10@-30) 			hangOut: false.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'sw 3/18/2004 00:35'!setSelector: stringLike in: stringMorph	"Store the new selector and accept method."	| aSymbol myType str |	aSymbol := stringLike asSymbol.	(ScriptingSystem helpStringOrNilFor: aSymbol) ifNotNilDo:		[:aString |			self setBalloonText: aString translated].	myType := stringMorph valueOfProperty: #syntacticReformatting ifAbsent: [#none].	str := aSymbol.	(self isStandardSetterKeyword: str) ifTrue: [str := self translateToWordySetter: str].	(self isStandardGetterSelector: str) ifTrue: [str := self translateToWordyGetter: str].	(self shouldBeBrokenIntoWords: myType) 		ifTrue: [str := self substituteKeywordFor: str].	stringMorph contents: str.	"parseNode key: aSymbol code: nil."	str = stringLike ifFalse:		[stringMorph setProperty: #syntacticallyCorrectContents toValue: aSymbol].	self acceptSilently! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/19/2001 15:47'!tossOutArg: extras	"Remove the tiles for the last N keywords and arguments.  Place the tiles beside the current window.  I am a SyntaxMorph for a MessageNode."	| cnt ctr |	cnt := 0.	 submorphs copy reverseDo: [:sub |		ctr := sub fullBoundsInWorld center.		sub delete.		(sub isSyntaxMorph and: [sub parseNode notNil]) ifTrue: [			sub isNoun ifTrue: [				self pasteUpMorph addMorphFront: sub.				sub position: self enclosingPane fullBoundsInWorld right - 20 @ ctr y].			(cnt := cnt + 1) >= extras ifTrue: [^ self]]].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 13:35'!upDown: delta event: evt arrow: arrowMorph	| st |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: LiteralNode) ifTrue:		[ "+/- 1"		st contents: (self decompile asNumber + delta) printString.		^ self acceptUnlogged].	(self nodeClassIs: VariableNode) ifTrue:		[ "true/false"		st contents: (self decompile string = 'true') not printString.		^ self acceptSilently ifFalse: [self changed].			"maybe set parseNode's key"].	(self upDownArithOp: delta) ifTrue: [^ self].	"+ - // *   < > <= =   beep:"	(self upDownAssignment: delta) ifTrue: [^ self].		"Handle assignment --  increaseBy:  <-   multiplyBy:"! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 7/24/2001 17:54'!upDownArithOp: delta	"Change a + into a -.  Also do sounds (change the arg to the beep:)."	| aList index st |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		[aList := #(+ - * / // \\ min: max:).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList := #(= ~= > >= isDivisibleBy: < <=).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		aList := #(== ~~).		(index := aList indexOf: self decompile asString) > 0 ifTrue:			[self setSelector: (aList atWrap: index + delta) in: st.  ^ true].		'beep:' = self decompile asString ifTrue:			["replace sound arg"			self changeSound: delta.			self acceptSilently.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 9/20/2001 16:33'!upDownArrows	"Return an array of two up/down arrow buttons.	It replaces the selector or arg with a new one.	I am a number or boolean or a selector (beep:, +,-,*,//,\\, or setX: incX: decX: for any X."	| patch any noMenu |	any := (self nodeClassIs: LiteralNode) and: [parseNode key isNumber].	any := any or: [(self nodeClassIs: VariableNode) and:						[(#('true' 'false') includes: self decompile asString)]].	noMenu := any.	any := any or: [self nodeClassIs: SelectorNode].	"arrows and menu of selectors"	any := any or: [self nodeClassIs: KeyWordNode].	any ifFalse: [^ nil].	patch := {(ImageMorph new image: TileMorph upPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: 1;				on: #mouseStillDown send: #upDownMore:event:arrow: 					to: self withValue: 1;				on: #mouseUp send: #upDownDone to: self.			(ImageMorph new image: TileMorph downPicture)				on: #mouseDown send: #upDown:event:arrow: to: self withValue: -1;				on: #mouseStillDown send: #upDownMore:event:arrow: 					to: self withValue: -1;				on: #mouseUp send: #upDownDone to: self}.	noMenu ifFalse: [patch := patch, {(RectangleMorph new)						extent: 6@10; borderWidth: 1;						borderColor: Color gray;						on: #mouseUp send: #selectorMenu to: self}.					patch last color: ((self nodeClassIs: SelectorNode) 						ifTrue: [Color lightGreen] ifFalse: [Color red darker])].	^ patch! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'tk 8/24/2001 12:33'!upDownAssignment: delta	"Rotate between increaseBy:  decreaseBy:   :=  multiplyBy:"	| st now want instVar |	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	(self nodeClassIs: SelectorNode) ifTrue:		["kinds of assignment"		((now := self decompile asString) beginsWith: 'set') ifTrue:			["a setX: 3"			want := 1+delta.  instVar := (now allButFirst: 3) allButLast].		(now endsWith: 'IncreaseBy:') ifTrue:			["a xIncreaseBy: 3 a setX: (a getX +3)."			want := 2+delta.  instVar := now allButLast: 11].		(now endsWith: 'DecreaseBy:') ifTrue:			["a xDecreaseBy: 3 a setX: (a getX -3)."			want := 3+delta.  instVar := now allButLast: 11].		(now endsWith: 'MultiplyBy:') ifTrue:			["a xMultiplyBy: 3 a setX: (a getX *3)."			want := 4+delta.  instVar := now allButLast: 11].		want ifNil: [^ false].		instVar := instVar asLowercase.		want := #(1 2 3 4) atWrap: want.		want = 1 ifTrue:			["setter method is present"			self setSelector: ('set', instVar capitalized, ':') in: st.  ^ true].		want = 2 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'IncreaseBy:' in: st.  ^ true].		want = 3 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'DecreaseBy:' in: st.  ^ true].		want = 4 ifTrue:			["notUnderstood will create the method if needed"			self setSelector: instVar, 'MultiplyBy:' in: st.  ^ true].		].	^ false! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'di 5/4/2001 12:26'!upDownMore: delta event: evt arrow: arrowMorph	| st delay1 delay2 now timeOfLastTick currentDelay |	(self nodeClassIs: LiteralNode) ifFalse: [^ self].	st := submorphs detect: [:mm | mm isKindOf: StringMorph] ifNone: [^ self].	delay1 := 300.  "ms"	delay2 := 50.  "ms"	now := Time millisecondClockValue.	timeOfLastTick := (self valueOfProperty: #timeOfLastTick) ifNil: [now - delay1].	currentDelay := (self valueOfProperty: #currentDelay) ifNil: [delay1].	now >= (timeOfLastTick + currentDelay) ifTrue:		[self setProperty: #timeOfLastTick toValue: now.		"decrease the delay"		self setProperty: #currentDelay toValue: (currentDelay*8//10 max: delay2).		st contents: (self decompile asNumber + delta) printString.		^ self acceptUnlogged].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:33'!getHeader: strm	| se |	"We are in an EToy scriptor and the method header line has been removed.  Try to recover the method name.  Fail if method has args (deal with this later)."	(se := self ownerThatIsA: ScriptEditorMorph) ifNotNil: [		se scriptName numArgs > 0 ifTrue: [^ false].	"abort"		strm nextPutAll: se scriptName].	^ true! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 02:11'!printAssignmentNodeOn: strm indent: level	"sometimes an assignment is in parens"	| parens above |	parens := submorphs size >= 3.	parens ifTrue: [		above := self ownerPrecedence.	"high if not in an expression"		parens := above <= 3].	"assignment is a noun inside a message"	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			strm ensureNoSpace. 	":= will have a leading space"			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 3/4/2001 12:19'!printBlockArgsNodeOn: strm indent: level	| argString |	self		submorphsDoIfSyntax: [ :sub |			(argString := sub decompile) isEmpty ifFalse: [				strm 					nextPut: $:;					nextPutAll: argString;					space			].		] 		ifString: [ :sub |			"self printSimpleStringMorph: sub on: strm	<<<< do we need this??"		].	strm nextPut: $|; crtab: level.! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:17'!printBlockNodeOn: strm indent: level	| lev inASyntaxButNotOutermost subNodeClass |	lev := level.	inASyntaxButNotOutermost := owner isSyntaxMorph and: [ owner isMethodNode not].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $[.  lev := lev+1].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: lev.			subNodeClass := sub parseNode class.			(#(BlockArgsNode ReturnNode CommentNode) includes: subNodeClass name) ifFalse: [				strm ensureNoSpace; nextPut: $.].			subNodeClass == BlockArgsNode				ifTrue: [strm space]				ifFalse: [strm crtab: lev].		] 		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	inASyntaxButNotOutermost ifTrue: [strm nextPut: $] ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:19'!printCascadeNodeOn: strm indent: level	| parens cnt me above |	parens := parseNode receiver notNil.	parens ifTrue: [me := self selector precedence.		above := self ownerPrecedence.	"high if not in an expression"		parens := me > above].	parens ifTrue: [strm nextPut: $( ].	cnt := 0.	self		submorphsDoIfSyntax: [ :sub |			cnt := cnt + 1.			"maybe we want to test sub isCascadePart for the following???"			cnt > 2 ifTrue: [strm nextPutAll: '; '].			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/23/2001 01:17'!printMessageNodeOn: strm indent: level	| parens me above |	parens := parseNode receiver notNil.	parens ifTrue: [me := self selector precedence.		above := self ownerPrecedence.	"high if not in an expression"		parens := me > above].	parens ifTrue: [strm nextPut: $( ].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].	parens ifTrue: [strm ensureNoSpace; nextPut: $) ].! !!SyntaxMorph methodsFor: 'printing' stamp: 'tk 9/14/2001 13:52'!printOn: strm indent: level	| nodeClass |	(self hasProperty: #ignoreNodeWhenPrinting) ifFalse: [		nodeClass := parseNode class.		nodeClass == VariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == LiteralVariableNode ifTrue: [^self printVariableNodeOn: strm indent: level].		nodeClass == MessageNode ifTrue: [^self printMessageNodeOn: strm indent: level].		nodeClass == BlockNode ifTrue: [^self printBlockNodeOn: strm indent: level].		nodeClass == BlockArgsNode ifTrue: [^self printBlockArgsNodeOn: strm indent: level].		nodeClass == MethodNode ifTrue: [^self printMethodNodeOn: strm indent: level].		nodeClass == MethodTempsNode ifTrue: [^self printMethodTempsNodeOn: strm indent: level].		nodeClass == CascadeNode ifTrue: [^self printCascadeNodeOn: strm indent: level].		nodeClass == AssignmentNode ifTrue: [^self printAssignmentNodeOn: strm indent: level].	].	self		submorphsDoIfSyntax: [ :sub |			sub printOn: strm indent: level.			strm ensureASpace.		]		ifString: [ :sub |			self printSimpleStringMorph: sub on: strm		].! !!SyntaxMorph methodsFor: 'printing' stamp: 'RAA 2/16/2001 18:16'!printSimpleStringMorph: aMorph on: strm	| trialContents |	(aMorph hasProperty: #wordyVariantOfSelf) ifTrue: [		strm nextPutAll: 'self '.		strm nextPutAll: ((self translateToWordySelfVariant: aMorph contents) ifNil: [^self]).		^self	].	(aMorph hasProperty: #noiseWord) ifFalse: [		trialContents := self cleanUpString: aMorph.		strm nextPutAll: trialContents	].! !!SyntaxMorph methodsFor: 'scripting' stamp: 'tk 9/26/2001 06:01'!tearOffTile	"For a SyntaxMorph, this means give a copy of me"	| dup |	dup := self duplicate.	ActiveHand attachMorph: dup.	Preferences tileTranslucentDrag		ifTrue: [^ dup lookTranslucent]		ifFalse: [^ dup align: dup topLeft with: ActiveHand position + self cursorBaseOffset]! !!SyntaxMorph methodsFor: 'selection' stamp: 'di 11/17/2000 08:10'!currentSelectionDo: blockForSelection	| rootTile |	(rootTile := self rootTile) isMethodNode ifFalse:		 [^ blockForSelection value: nil value: nil value: nil].	rootTile valueOfProperty: #selectionSpec ifPresentDo:		[:selectionSpec | ^ blockForSelection							value: selectionSpec first							value: selectionSpec second							value: selectionSpec third].	^ blockForSelection value: nil value: nil value: nil! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 1/17/2001 15:07'!isSelectable	| ss |	"Spacer morphs enclose other morphs with the same parseNode"	self submorphs size > 1 ifTrue: [		ss := self submorphs second.		ss isSyntaxMorph ifTrue: [			ss parseNode == parseNode ifTrue: [				^ self submorphs first class ~~ Morph]]].		"	(self nodeClassIs: SelectorNode) ifTrue: [^ false].	(self nodeClassIs: KeyWordNode) ifTrue: [^ false]."	self isMethodNode ifTrue: [^ false].	parseNode ifNil: [^ false].	^ true! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 7/31/2001 17:18'!scaleColorByUserPref: aColor		| myRoot underLyingColor |	myRoot := self rootTile.	underLyingColor := myRoot ifNil: [Color transparent] ifNotNil: [myRoot color].	[underLyingColor isTransparent and: [(myRoot := myRoot owner) notNil]] whileTrue: [		underLyingColor := myRoot color.	].		"rude hack to get the desired effect before we have an owner"	underLyingColor isTransparent ifTrue: [underLyingColor := Color r: 0.903 g: 1.0 b: 0.903].	^aColor mixed: (ContrastFactor ifNil: [0.3]) with: underLyingColor"Would like to be able to make MethodNode and outer Block be transparent.  This method does not allow that.  Consider (^ myRoot color) inside the whileTrue.  Consider setting underLyingColor to (myRoot valueOfProperty: #deselectedBorderColor ifAbsent: [myRoot color]) in second line."! !!SyntaxMorph methodsFor: 'selection' stamp: 'tk 7/19/2001 17:52'!setDeselectedColor	"The normal color of the tile, stored with the tile"	| deselectedColor deselectedBorderColor |	deselectedColor := self valueOfProperty: #deselectedColor ifAbsent: [nil].	deselectedBorderColor := self valueOfProperty: #deselectedBorderColor ifAbsent: [nil].	deselectedColor ifNotNil: [		deselectedColor := self scaleColorByUserPref: deselectedColor].	deselectedBorderColor ifNotNil: [		deselectedBorderColor := self scaleColorByUserPref: deselectedBorderColor].	self 		color: (deselectedColor ifNil: [Color transparent]);		borderColor: (deselectedBorderColor ifNil: [Color transparent])! !!SyntaxMorph methodsFor: 'submorphs-accessing' stamp: 'tk 1/13/2001 20:41'!findA: aClass	| ans |	"Allow finding on the class of the parseNode"	(ans := super findA: aClass) ifNotNil: [^ ans].	submorphs do: [:ss | 		ss isSyntaxMorph ifTrue: [			ss parseNode class == aClass ifTrue: [^ ss]]].	^ nil! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/23/2001 23:40'!argTypeFor: aSelector	"Answer the type of the argument of this selector.  Return #unknown if not found."	| itsInterface |	aSelector numArgs = 0 		ifTrue: [self inform: aSelector, ' does not take an argument'. ^ #error "7"].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface typeForArgumentNumber: 1! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/15/2001 14:25'!okToBeReplacedBy: aSyntaxMorph	"Return true if it is OK to replace me with aSyntaxMorph.  Enforce the type rules in the old EToy green tiles."	| itsType myType |	(Preferences eToyFriendly or: [Preferences typeCheckingInTileScripting])		ifFalse: [^ true].	"not checking unless one of those prefs is true"	(parseNode class == BlockNode and: [aSyntaxMorph parseNode class == BlockNode]) 		ifTrue: [^ true].	(parseNode class == ReturnNode and: [aSyntaxMorph parseNode class == ReturnNode]) 		ifTrue: [^ true].	parseNode class == KeyWordNode ifTrue: [^ false].	aSyntaxMorph parseNode class == KeyWordNode ifTrue: [^ false].	parseNode class == SelectorNode ifTrue: [^ false].	aSyntaxMorph parseNode class == SelectorNode ifTrue: [^ false].	owner isSyntaxMorph ifFalse: [^ true].	"only within a script"		"Transcript show: aSyntaxMorph resultType printString, ' dropped on ', 			self receiverOrArgType printString; cr.		"	(itsType := aSyntaxMorph resultType) == #unknown ifTrue: [^ true].	(myType := self receiverOrArgType) == #unknown ifTrue: [^ true].		"my type in enclosing message"	^ myType = itsType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'tk 2/9/2001 15:56'!receiverOrArgType	| ty |	"Return my type in my role as a receiver or as an argument.  Ask my enclosing message first, then ask myself.  (If owner accepts any #object, and I am a #point, do return #object.)"	^ (ty := self receiverOrArgTypeAbove) == #unknown		ifTrue: [self resultType]		ifFalse: [ty]! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/27/2001 09:11'!receiverTypeFor: aSelector	"Answer the type of the receiver of this selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [^ #unknown].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface receiverType! !!SyntaxMorph methodsFor: 'type checking' stamp: 'sw 2/24/2001 12:13'!resultTypeFor: aSelector	"Answer the result type of selector.  Return #unknown if not found."	| itsInterface |	aSelector ifNil: [self inform: 'Please tell Ted how you caused this'.		^ #abs "a bogus type"].	itsInterface := self currentVocabulary methodInterfaceAt: aSelector ifAbsent:		[^ #unknown].	^ itsInterface resultType! !!SyntaxMorph methodsFor: 'updating' stamp: 'di 11/13/2000 20:30'!update: aSymbol	| bingo saveOwner newMorph db |	(db := self debugger) ifNil: [^super update: aSymbol].	aSymbol == #contents ifTrue: [		saveOwner := owner.		db removeDependent: self.		markerMorph ifNotNil: [markerMorph delete. markerMorph := nil].		newMorph := db createSyntaxMorph.		self delete.		saveOwner addMorph: newMorph.		saveOwner owner setScrollDeltas.		newMorph update: #contentsSelection.	].	aSymbol == #contentsSelection ifTrue: [		markerMorph ifNil: [			markerMorph := RectangleMorph new.			markerMorph				color: Color transparent;				borderWidth: 2;				borderColor: Color red;				lock.			owner addMorphFront: markerMorph.		].		bingo := parseNode rawSourceRanges keyAtValue: db pcRange ifAbsent: [nil].		self testForNode: bingo andDo: [ :foundMorph | 			markerMorph				position: foundMorph position;				extent: foundMorph extent.			owner owner scrollIntoView: foundMorph bounds extra: 0.5.			^self		].	].	super update: aSymbol! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 22:59'!column: aColor on: aParseNode	| c color |	color := self translateColor: aColor.	(c := self newColumn)		parseNode: aParseNode;		layoutInset: c standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: c stdBorderColor;		wrapCentering: #topLeft;		cellPositioning: c standardCellPositioning.	^c! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 2/26/2001 23:00'!row: aColor on: aParseNode	| r color |	color := self translateColor: aColor.	(r := self newRow)		parseNode: aParseNode;		layoutInset: r standardInset;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: color;		borderWidth: 1;		borderColor: r stdBorderColor;		wrapCentering: #topLeft;		cellPositioning: r standardCellPositioning.	^r! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 5/2/2001 09:59'!setSize: oldExtent andMakeResizable: outerMorph	| tw |	(tw := outerMorph findA: TwoWayScrollPane) ifNil: [^self].	tw hResizing: #spaceFill;		vResizing: #spaceFill;		color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true.	outerMorph 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		cellPositioning: #topLeft.	outerMorph fullBounds.! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 8/23/2003 12:20'!testAll	| source tree total count systNav|"SyntaxMorph testAll"	systNav := self systemNavigation.	count := total := 0.	systNav allBehaviorsDo: [ :aClass | total := total + 1].'Testing all behaviors'	displayProgressAt: Sensor cursorPoint	from: 0 to: total	during: [ :bar |		systNav allBehaviorsDo: [ :aClass |			bar value: (count := count + 1).			aClass selectors do: [ :aSelector |				source := (aClass compiledMethodAt: aSelector) getSourceFromFile.				tree := Compiler new 					parse: source 					in: aClass 					notifying: nil.				tree asMorphicSyntaxUsing: SyntaxMorph.			].		].	].! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 8/23/2003 12:20'!testAllMethodsOver: methodSize 	"MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]"	"Add up the total layout area for syntax morphs representing all  	methods over the given size. This is a stress-test for SyntaxMorph  	layout. A small value for the total area is also a figure of merit in the  	presentation of Squeak source code in general."	"Results:  	#(69 600 180820874 103700) 11/4  	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoff  	Folded wide receivers, don't center keywords any more.  	#(68 600 160033784 127727) 11/9  	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoff  	Folded more messages, dropped extra vertical spacing in blocks.  	#(68 600 109141704 137308) 11/10  	79% build morphs, 6% get source, 8% layout, 7% parse  	Folded more messages, dropped extra horizontal spacing.  	#(68 600 106912968 132171) 11/10  	80% build morphs, ??% get source, 11% layout, 7% parse  	Unfolded keyword messages that will fit on one line.  	#(68 600 96497372 132153) 11/10  	81% build morphs, ??% get source, 8% layout, 8% parse  	After alignment rewrite...  	#(74 600 101082316 244799) 11/12  	76% build morphs, 4% get source, 15% layout, 5% parse  	After alignment rewrite...  	#(74 600 101250620 204972) 11/15  	74% build morphs, 6% get source, 13% layout, 7% parse  	"	| tree source biggies morph stats time area |	biggies := self systemNavigation 				allMethodsSelect: [:cm | cm size > methodSize].	stats := OrderedCollection new.	'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'		displayProgressAt: Sensor cursorPoint		from: 1		to: biggies size		during: [:bar | biggies				withIndexDo: [:methodRef :i | 					bar value: i.					Utilities						setClassAndSelectorFrom: methodRef						in: [:aClass :aSelector | 							source := (aClass compiledMethodAt: aSelector) getSourceFromFile.							time := Time										millisecondsToRun: [tree := Compiler new														parse: source														in: aClass														notifying: nil.											morph := tree asMorphicSyntaxUsing: SyntaxMorph.											area := morph fullBounds area]].					stats add: {methodRef. area. time}]].	^ {{biggies size. methodSize. stats		detectSum: [:a | a second]. stats		detectSum: [:a | a third]}. (stats		asSortedCollection: [:x :y | x third >= y third]) asArray}! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'di 7/30/2001 16:29'!testClass: aClass andMethod: aSelector	| tree |	tree := Compiler new 		parse: (aClass sourceCodeAt: aSelector) 		in: aClass 		notifying: nil.	(tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass;		openInWindow! !!SyntaxUpdatingStringMorph methodsFor: 'drawing' stamp: 'tk 1/31/2002 09:53'!drawOn: aCanvas	| tempForm strm where chars wid spaceWidth putLigature topOfLigature sizeOfLigature colorOfLigature dots charZero canvas f |	tempForm := Form extent: self extent depth: aCanvas depth.	canvas := tempForm getCanvas.	f := self fontToUse.	spaceWidth := f widthOf: Character space.	strm := ReadStream on: contents.	charZero := Character value: 0.	"a marker for center dot "	where := 0@0.	topOfLigature := self height // 2 - 1.	sizeOfLigature := (spaceWidth-2)@(spaceWidth-2).	colorOfLigature := Color black alpha: 0.45	"veryLightGray".	dots := OrderedCollection new.	putLigature := [		dots add: ((where x + 1) @ topOfLigature extent: sizeOfLigature).		where := where + (spaceWidth@0)].	strm peek = charZero ifTrue: [		strm next.		putLigature value].	[strm peek = charZero] whileTrue: [strm next].	[strm atEnd] whileFalse: [		chars := strm upTo: charZero.		wid := f widthOfString: chars.		canvas drawString: chars at: where.		where := where + (wid@0).		strm atEnd ifFalse: [putLigature value.			[strm peek = charZero] whileTrue: [strm next]].	].	aCanvas paintImage: tempForm at: self topLeft.	dots do: [ :each |		aCanvas 			fillRectangle: (each translateBy: self topLeft) 			fillStyle: colorOfLigature.	].! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23'!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24'!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 0!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 10/5/2007 18:16'!initialize	"SystemDictionary initialize"	| oldList |	oldList _ StartUpList.	StartUpList _ OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		FileDirectory  "Enables file stack dump and opens sources."		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList _ ShutDownList.	ShutDownList _ OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!SystemQueryPhrase methodsFor: 'initialization' stamp: 'sw 9/26/2001 03:04'!initialize	"Initialize the receiver.  In this case we primarily seek to undo the damage done by inherited implementors of #initialize"	super initialize.	self removeAllMorphs.	resultType := #Boolean.	self vResizing: #shrinkWrap! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:10'!testAtEnd	| stream |	self assert: self emptyStream atEnd.	stream := self streamOnArray.	self deny: stream atEnd.	stream next: 3.	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:30'!testNextMatchFor	| stream |	stream := self streamOnArray.	self assert: (stream nextMatchFor: 1).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).		stream := self streamOnArray.	self deny: (stream nextMatchFor: false).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:48'!testPeekFor	| stream |	stream := self streamOnArray.	self assert: (stream peekFor: 1).	self assert: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).	stream := self streamOnArray.	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).	self assert: (stream peekFor: 1).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: false).	self assert: (stream peekFor: #(a b c)).		self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).		self assert: (stream atEnd).	self deny: (stream peekFor: nil).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).! !!TGettableStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:54'!testPeekFor2	| stream negative number |	stream := self streamOn: '- 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.	stream := self streamOn: '-145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.		stream := self streamOn: ' 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.		stream := self streamOn: '145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.! !!TGettableStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo	self emptyStream do: [:value | self fail]! !!TGettableStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo2	| stream string |	stream := self streamOnArray.	string := String new.		stream do: [:value | string := string, ' ', value asString].		self assert: string = (' ', 1 asString, ' ', #(a b c) asString, ' ', false asString)! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:23'!testNext	|stream|	stream := self streamOnArray.	self assert: stream next = 1.	self assert: stream next = #(a b c).	self assert: stream next = false.		stream := self streamOnString.	self assert: stream next = $a.	self assert: stream next = $b.	self assert: stream next = $c.	self assert: stream next = $d.	self assert: stream next = $e.	! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:24'!testNexts	self assert: (self emptyStream next: 0) isEmpty.	self assert: (self streamOnArray next: 0) isEmpty.	self assert: (self streamOnArray next: 1) = #(1).	self assert: (self streamOnArray next: 2) = #(1 #(a b c)).	self assert: (self streamOnArray next: 3) = #(1 #(a b c) false).! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:40'!testNexts2	| stream |	stream := self streamOnArray.	self assert: (stream next: 2) = #(1 #(a b c)).	self assert: (stream next: 1) = #(false).! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:35'!testPeek	| stream |	stream := self streamOnArray.		self assert: stream peek = 1.	self deny: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self assert: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self deny: stream peek = #(a b c).	self assert: stream peek = false.		stream next.		"In ANSI Smalltalk Standard Draft, it is said that nil will return nil at the end when using #peek."	self assert: stream peek isNil.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:37'!testPeek2	| stream |	stream := self streamOn: #(nil nil nil).		self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.		"Yes, #peek answers nil when there is no more element to read."	self assert: stream peek isNil.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:41'!testUpTo	| returnValue stream |	returnValue := (self emptyStream upTo: nil).	self assert: returnValue isCollection.	self assert: returnValue isEmpty.		stream := self streamOnArray.	returnValue := stream upTo: #(a b c).	self assert: returnValue = #(1).	self assert: stream peek = false.		stream := self streamOnArray.	returnValue := stream upTo: true.	self assert: returnValue = #(1 #(a b c) false).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:42'!testUpTo2	| returnValue stream |	stream := self streamOnString.	returnValue := stream upTo: $d.	self assert: returnValue = 'abc'.	self assert: stream peek = $e.! !!TGettableStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:17'!testSkipTo	| stream |	stream := self emptyStream.	self deny: (stream skipTo: nil).		stream := self streamOnArray.	self deny: stream atEnd.	self deny: (stream skipTo: nil).	self assert: stream atEnd.		stream := self streamOnArray.	self assert: stream peek = 1.	self assert: (stream skipTo: #(a b c)).	self assert: stream peek = false.	self assert: (stream skipTo: false).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:18'!testSkipTo2	| stream |		stream := self streamOnString.	self assert: (stream skipTo: $b).	self assert: stream peek = $c.	self assert: (stream skipTo: $d).	self assert: stream peek = $e.	self assert: (stream skipTo: $e).	self assert: stream atEnd.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:19'!testBack	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream back = $b.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testBackOnPosition1	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream back = $a.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:20'!testOldBack	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream oldBack = $a.! !!TGettableStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testOldBackOnPosition1	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream oldBack = nil.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:49'!testNextPutAllAppending	| stream |	stream := self emptyStream.	self shouldnt: [		stream			nextPutAll: 'abc'.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:50'!testNextPutAllReplacing	| stream |	stream := self streamOnString.	stream reset.	self shouldnt: [		stream			nextPutAll: 'abc'.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:49'!testNextPutAppending	| stream |	stream := self emptyStream.	self shouldnt: [		stream			nextPut: $a;			nextPut: $b;			nextPut: $c.	] raise: Error.! !!TPuttableStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/9/2007 10:50'!testNextPutReplacing	| stream |	stream := self streamOnArray.	stream reset.	self shouldnt: [		stream			nextPut: $a;			nextPut: $b;			nextPut: $c.	] raise: Error.! !!TReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/6/2007 18:26'!testContents2	"From ANSI Smalltalk Standard draft 1.9: 			it is unspecified whether or not the returned collection [using #contents] is the same object as the backing store collection. However, if the returned collection is not the same object as the stream backing store collection then the class of the returned collection is the same class as would be returned if the message #select: was sent to the backing store collection."			"In Squeak, there is #species to know what class should be used on copy, selection..."	| interval stream streamContents |	interval := 1 to: 32.	stream := self streamOn: interval.	streamContents := stream contents.		(streamContents == interval)		ifFalse: [self assert: streamContents class = Interval new species]! !!TReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 3/7/2007 13:50'!testNew	self should: [self classUnderTest new] raise: Error.! !!TReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/28/2007 15:39'!testOn	self shouldnt: [self streamOn: '  '] raise: Error.	self assert: (self streamOn: '  ') position isZero.! !!TReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:38'!testPosition	| stream |	self assert: self emptyStream position isZero.		stream := self streamOnArray.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.! !!TSequencedStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:32'!testContents	| stream |	self assert: self emptyStream contents = ''.		stream := self streamOnArray.	self assert: stream contents = #(1 #(a b c) false).	stream position: 3.	self assert: stream contents = #(1 #(a b c) false).		stream := self streamOnString.	self assert: stream contents = 'abcde'.	stream setToEnd.	self assert: stream contents = 'abcde'.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:07'!testBackUpTo1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self assert: (stream backUpTo: 'ab').	self assert: stream peek = $g! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:11'!testBackUpToEmptyPattern1	"This test represents the current behavior which is not clearly defined and could be revised."	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self should: [stream backUpTo: ''] raise: Error.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:08'!testBackUpToPatternNotFound1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self deny: (stream backUpTo: 'zz').	self assert: stream position = 0! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:44'!testReset	| stream |	stream := self emptyStream.	stream reset.	self assert: stream position = 0.		stream := self streamOnArray.	stream reset.	self assert: stream position = 0.	self deny: stream atEnd.	stream position: 3.	self assert: stream atEnd.	stream reset.	self assert: stream position = 0.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:41'!testSetPosition	| stream |	stream := self emptyStream.	self should: [stream position: -2] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	stream := self streamOnArray.	self should: [stream position: -1] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	self shouldnt: [stream position: 1] raise: Error.	self shouldnt: [stream position: 2] raise: Error.	"According to ANSI Smalltalk Standard 1.9 Draft, the following should be tested too:	self should: [stream position: 3] raise: Error.		However, I don't see the point of raising an error when positioning at the end.		I prefer testing the absence of error:	"	self shouldnt: [stream position: 3] raise: Error.	self should: [stream position: 4] raise: Error.! !!TSequencedStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:47'!testSetToEnd	| stream |	stream := self emptyStream.	stream setToEnd.	self assert: stream atEnd.		stream := self streamOnArray.	stream setToEnd.	self assert: stream atEnd.	stream position: 1.	self deny: stream atEnd.	stream setToEnd.	self assert: stream atEnd.! !!TStreamTest methodsFor: 'accessing' stamp: 'dc 3/7/2007 14:00'!classUnderTest	self explicitRequirement! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:59'!emptyStream	^ self streamOn: String new! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:57'!streamOnArray	^ self streamOn: (Array with: 1 with: #(a b c) with: false)! !!TStreamTest methodsFor: 'accessing - defaults' stamp: 'dc 2/28/2007 13:57'!streamOnString	^ self streamOn: 'abcde'! !!TStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:55'!streamOn: aCollection	^ self classUnderTest on: aCollection! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:35'!ascent	ascent ifNil:[ascent := ttcDescription ascender * self pixelSize // (ttcDescription ascender - ttcDescription descender) * Scale y].	^ (fallbackFont notNil			and: [fallbackFont ascent > ascent])		ifTrue: [fallbackFont ascent]		ifFalse: [ascent]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:43'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := (ttcDescription descender * self pixelSize // (ttcDescription descender - ttcDescription ascender)) * Scale y + 1].! !!TTCFont methodsFor: 'accessing' stamp: 'dgd 5/19/2007 16:20'!fallbackFont: aFontSetOrNil	aFontSetOrNil == self		ifTrue:[^ self error: 'Invalid fallback font'].	fallbackFont _ aFontSetOrNil.! !!TTCFont methodsFor: 'accessing' stamp: 'ar 11/14/2006 15:44'!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize * Scale y]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!maxAscii	"Answer the max. code point in this font. The name of this method is historical."	^maxAscii ifNil:[ttcDescription size].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:12'!minAscii	"Answer the min. code point in this font. The name of this method is historical."	^ 0.! !!TTCFont methodsFor: 'as yet unclassified' stamp: 'dgd 5/19/2007 16:19'!setupDefaultFallbackFont	| fonts f |	fonts _ TextStyle default fontArray.	f _ fonts first.	1 to: fonts size do: [:i |		self height > (fonts at: i) height ifTrue: [f _ fonts at: i].	].	(f == self)		ifFalse:[ self fallbackFont: f ].	self reset.! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!cache	^cache! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:40'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| form glyphInfo destX destY hereX nextX actualFont |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do: [:charIndex |		self glyphInfoOf: (aString at: charIndex) into: glyphInfo.		form := glyphInfo at: 1.		hereX := glyphInfo at: 2.		nextX := glyphInfo at: 3.		(actualFont := glyphInfo at: 5) ==  aBitBlt lastFont			ifFalse: [actualFont installOn: aBitBlt].		destY := baselineY - (glyphInfo at: 4). 		aBitBlt sourceForm: form.		aBitBlt destX: destX.		aBitBlt destY: destY.		aBitBlt sourceX: hereX; sourceY: 0.		aBitBlt width: nextX - hereX.		aBitBlt height: form height.		aBitBlt copyBits.		destX := destX + (nextX - hereX) + kernDelta.	].	^ destX @ destY! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:26'!installOn: aDisplayContext foregroundColor: fgColor backgroundColor: bgColor	self foregroundColor: fgColor. "install color"	aDisplayContext installTTCFont: self foregroundColor: foregroundColor backgroundColor: bgColor! !!TTCFont methodsFor: 'friend' stamp: 'ar 11/14/2006 15:19'!ttcDescription: aTTCDescription	ttcDescription := aTTCDescription.	self flushCache.! !!TTCFont methodsFor: 'public' stamp: 'ar 6/2/2007 21:16'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	aCharacter charCode > self maxAscii ifTrue: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:19'!at: char put: form	| assoc |	assoc := foregroundColor -> form.	GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: assoc.	cache at: (char asInteger + 1) put: assoc.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!formOf: char	| code form |	char charCode > self maxAscii		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !!TTCFont methodsFor: 'private' stamp: 'ar 11/14/2006 15:43'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| form |	(self hasGlyphOf: aCharacter) ifFalse: [		^ self fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.	].	form := self formOf: aCharacter.	glyphInfoArray at: 1 put: form;		at: 2 put: 0;		at: 3 put: form width;		at: 4 put: ascent "(self ascentOf: aCharacter)";		at: 5 put: self.	^ glyphInfoArray.! !!TTCFont methodsFor: 'private' stamp: 'ar 6/2/2007 21:13'!hasGlyphOf: aCharacter	"Answer whether this font includes a glyph for the given character"	^ aCharacter charCode <= self maxAscii! !!TTCFont methodsFor: 'initialize' stamp: 'ar 11/14/2006 15:17'!flushCache	"Flush the cache of this font"	cache := foregroundColor := colorToCacheMap := nil.! !!TTCFont methodsFor: 'initialize' stamp: 'ar 6/2/2007 21:14'!foregroundColor: fgColor	"Install the given foreground color"	foregroundColor = fgColor ifFalse:[		foregroundColor := fgColor.		colorToCacheMap ifNil:[colorToCacheMap := Dictionary new].		cache := colorToCacheMap at: fgColor ifAbsentPut:[WeakArray new: self maxAscii+1].		ShutdownList ifNotNil:[ShutdownList add: self].	].! !!TTCFont commentStamp: 'nk 4/2/2004 11:32' prior: 0!I represent a font that uses TrueType derived glyph.  Upon a request for glyph for a character through a call to #formOf: (or #widthOf:), I first search corresponding glyph in the cache.  If there is not, it creates a 32bit depth form with the glyph.  The cache is weakly held.  The entries are zapped at full GC.Structure: ttcDescription	TTFontDescription -- The Squeak data structure for a TrueType font data file. pointSize		Number -- Nominal Em size in points. Conversion to pixel sizes depends on the definition of TextStyle class>>pixelsPerInch. foregroundColor	Color -- So far, this font need to know the glyph color in cache. cache			WeakArray of <Color -> <Array(256) of glyph>> derivatives		Array -- stores the fonts in the same family but different emphasis.!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:48'!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	(FileList respondsTo: #registerFileReader:) ifTrue: [		FileList registerFileReader: self	].	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 11/14/2006 15:28'!shutDown	"Flush the glyph cache"	GlyphCacheData atAllPut: nil.	GlyphCacheIndex := 0.	ShutdownList ifNotNil:[ShutdownList do:[:fnt| fnt flushCache]].	ShutdownList := WeakSet new.! !!TTCFont class methodsFor: 'other' stamp: 'ar 11/14/2006 15:19'!recreateCache"	self recreateCache."	self allSubInstances do: [:inst | inst flushCache].	Smalltalk garbageCollect.! !!TTCFontSet methodsFor: 'as yet unclassified' stamp: 'yo 2/12/2007 19:34'!isFontSet	^ true.! !!TTFontDescription methodsFor: 'accessing' stamp: 'ar 6/2/2007 21:15'!size	"Answer the logical number of characters in this font"	^glyphTable size - 1! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 18:00'!processCharMap: assoc	"Process the given character map"	| charTable glyph cmap |	cmap := assoc value.	assoc key = 0 ifTrue: "Unicode table"		[charTable := SparseLargeTable new: cmap size			chunkSize: 256 arrayClass: Array base: 1			defaultValue: glyphs first.		1 to: charTable size do:			[:i |			glyph := glyphs at: (cmap at: i) + 1 ifAbsent: [glyphs first].			charTable at: i put: glyph].		charTable zapDefaultOnlyEntries.		^charTable].	charTable := Array new: 256 withAll: glyphs first. "Initialize with default glyph"	assoc key = 1 ifTrue: "Mac encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: (self macToWin: i) put: glyph]].	assoc key = 3 ifTrue: "Win encoded table"		[1 to: (cmap size min: charTable size) do:			[:i |			glyph := glyphs at: (cmap at: i) + 1.			charTable at: i put: glyph]].	^ charTable! !!TTFontReader methodsFor: 'processing' stamp: 'bf 6/12/2006 16:28'!processCharacterMappingTable: entry	"Read the font's character to glyph index mapping table.	If an appropriate mapping can be found then return an association	with the format identifier and the contents of the table"	| copy initialOffset nSubTables pID sID offset cmap assoc |	initialOffset := entry offset.	entry skip: 2. "Skip table version"	nSubTables := entry nextUShort.	1 to: nSubTables do:[:i|		pID := entry nextUShort.		sID := entry nextUShort.		offset := entry nextULong.		"Check if this is either a Unicode (0), Macintosh (1),		or a Windows (3) encoded table"		(#(0 1 3) includes: pID) ifTrue:[			"Go to the beginning of the table"			copy := entry copy.			copy offset: initialOffset + offset.			cmap := self decodeCmapFmtTable: copy.			(pID = 0 and: [cmap notNil]) "Prefer Unicode encoding over everything else"				ifTrue: [^ pID -> cmap].			assoc := pID -> cmap. "Keep it in case we don't find a better table"		].	].	^assoc! !!TTFontReader methodsFor: 'private' stamp: 'bf 6/12/2006 17:14'!decodeCmapFmtTable: entry	| cmapFmt length cmap firstCode entryCount segCount segments offset code |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		entryCount := segments inject: 0 into: [:max :seg | max max: seg second].		cmap := Array new: entryCount+1 withAll: 0..		segments withIndexDo:			[:seg :si |			seg first to: seg second do:				[:i |				seg last > 0 ifTrue:					["offset to glypthIdArray - this is really C-magic!!"					entry offset: i - seg first - 1 * 2 + seg last + si + si + offset. 					code := entry nextUShort.					code > 0 ifTrue: [code := code + seg third]]				ifFalse:					["simple offset"					code := i + seg third].				cmap at: i + 1 put: code]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TabbedPalette methodsFor: '*eToys-e-toy support' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result := super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: '*eToys-viewer tab' stamp: 'sw 3/3/1999 13:17'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	| aPlayer aViewer oldOwner |	((currentPage isKindOf: Viewer) and: [currentPage scriptedPlayer == aMorph player])		ifTrue:			[^ self].	oldOwner := owner.	self delete.	self visible: false.	aPlayer := aMorph assuredPlayer.	self showNoPalette.	aViewer :=  StandardViewer new initializeFor: aPlayer barHeight: 0.	aViewer enforceTileColorPolicy.	self showNoPalette.	currentPage ifNotNil: [currentPage delete].	self addMorphBack: (currentPage := aViewer beSticky).	self snapToEdgeIfAppropriate.	tabsMorph highlightTab: nil.	self visible: true.	oldOwner addMorphFront: self.	self world startSteppingSubmorphsOf: aViewer.	self layoutChanged! !!TestIndenting methodsFor: 'running' stamp: 'hmm 2/2/2001 14:29'!setUp	| text |	text := 'p	' asText, (Text string: 'word word' attribute: (TextIndent tabs: 1)).	para := text asParagraph! !!TestNewParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 17:41'!setUp	| morph |	morph := TextMorph new contents: 'i i'.	morph fit.	para := morph paragraph! !!TestParagraphFix methodsFor: 'running' stamp: 'hmm 10/1/2000 15:05'!setUp	para := 'i i' asParagraph! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!testValueWithinNonLocalReturnFixReal	"self run: #testValueWithinNonLocalReturnFixReal"	"The real test for the fix is just as obscure as the original problem"	| startTime deltaTime |	self valueWithinNonLocalReturn.	startTime := Time millisecondClockValue.	[[] repeat] valueWithin: 100 milliSeconds onTimeout:[		"This *should* timeout after 100 msecs but the pending process from		the previous invokation will signal timeout after 20 msecs already		which will in turn cut this invokation short."		deltaTime := Time millisecondClockValue - startTime.		self deny: deltaTime < 90.	].! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:38'!testValueWithinNonLocalReturnFixSimply	"self run: #testValueWithinNonLocalReturnFixSimply"	"The simple version to test the fix"	self valueWithinNonLocalReturn.	self shouldnt:[(Delay forMilliseconds: 50) wait] raise: TimedOut.! !!TestValueWithinFix methodsFor: 'tests' stamp: 'ar 8/17/2007 13:37'!valueWithinNonLocalReturn	"Do a non-local return from a valueWithin: block"	[^self] valueWithin: 20 milliSeconds onTimeout:[].! !!Text methodsFor: 'accessing' stamp: 'tk 12/30/97 07:17'!replaceFrom: start to: stop with: aText	| txt |	txt := aText asText.	"might be a string"	string := string copyReplaceFrom: start to: stop with: txt string.	runs := runs copyReplaceFrom: start to: stop with: txt runs! !!Text methodsFor: 'attributes' stamp: 'rbb 2/18/2005 09:14'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	(Preferences browseWithPrettyPrint and: [Preferences colorWhenPrettyPrinting])		ifTrue: [self couldDeriveFromPrettyPrinting ifTrue: [^ self asString]].	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old := priorMethod getSourceFromFile].	(old == nil or: [old unembellished])		ifTrue:			[tell := 'This method contains style for the first time (e.g. bold or colored text).Do you really want to save the style info?'.			answ := (UIManager default 						chooseFrom: #('Save method with style' 'Save method simply')						title: tell).			answ = 2 ifTrue: [^ self asString]]! !!Text methodsFor: 'attributes' stamp: 'sw 12/7/1999 12:31'!unembellished 	"Return true if the only emphases are the default font and bold"	| font1 bold |	font1 := TextFontChange defaultFontChange.	bold := TextEmphasis bold.	Preferences ignoreStyleIfOnlyBold ifFalse:		["Ignore font1 only or font1-bold followed by font1-plain"		^ (runs values = (Array with: (Array with: font1)))		or: [runs values = (Array with: (Array with: font1 with: bold) 								with: (Array with: font1))]].	"If preference is set, then ignore any combo of font1 and bold"	runs withStartStopAndValueDo:		[:start :stop :emphArray |		emphArray do:			[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].	^ true! !!Text methodsFor: 'converting' stamp: 'ar 12/17/2001 00:38'!removeAttributesThat: removalBlock replaceAttributesThat: replaceBlock by: convertBlock	"Enumerate all attributes in the receiver. Remove those passing removalBlock and replace those passing replaceBlock after converting it through convertBlock"	| added removed new |	"Deliberately optimized for the no-op default."	added := removed := nil.	runs withStartStopAndValueDo: [ :start :stop :attribs | 		attribs do: [ :attrib |			(removalBlock value: attrib) ifTrue:[				removed ifNil:[removed := WriteStream on: #()].				removed nextPut: {start. stop. attrib}.			] ifFalse:[				(replaceBlock value: attrib) ifTrue:[					removed ifNil:[removed := WriteStream on: #()].					removed nextPut: {start. stop. attrib}.					new := convertBlock value: attrib.					added ifNil:[added := WriteStream on: #()].					added nextPut: {start. stop. new}.				].			].		].	].	(added == nil and:[removed == nil]) ifTrue:[^self].	"otherwise do the real work"	removed ifNotNil:[removed contents do:[:spec|		self removeAttribute: spec last from: spec first to: spec second]].	added ifNotNil:[added contents do:[:spec|		self addAttribute: spec last from: spec first to: spec second]].! !!Text methodsFor: 'converting' stamp: 'dvf 10/1/2003 02:58'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver starting at index, repStart, in replacementCollection. Do it to both the string and the runs."	| rep newRepRuns |	rep := replacement asText.	"might be a string"	string replaceFrom: start to: stop with: rep string startingAt: repStart.	newRepRuns := rep runs copyFrom: repStart to: repStart + stop - start.	runs := runs copyReplaceFrom: start to: stop with: newRepRuns! !!Text methodsFor: 'converting' stamp: 'nk 9/16/2003 16:46'!withSqueakLineEndings	"Answer a copy of myself in which all sequences of <CR><LF> or <LF> have been changed to <CR>"	| newText |	(string includes: Character lf) ifFalse: [ ^self copy ].	newText := self copyReplaceAll: String crlf with: String cr asTokens: false.	(newText asString includes: Character lf) ifFalse: [ ^newText ].	^newText copyReplaceAll: String lf with: String cr asTokens: false.! !!Text methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copied subrange of the receiver."	| realStart realStop |	stop > self size		ifTrue: [realStop := self size]		"handle selection at end of string"		ifFalse: [realStop := stop].	start < 1		ifTrue: [realStart := 1]			"handle selection before start of string"		ifFalse: [realStart := start].	^Text 		string: (string copyFrom: realStart to: realStop)		runs: (runs copyFrom: realStart to: realStop)! !!Text methodsFor: 'copying' stamp: 'BG 6/12/2003 13:11'!copyReplaceFrom: start to: stop with: aTextOrString	| txt |	txt := aTextOrString asText.	"might be a string"	^self class              string: (string copyReplaceFrom: start to: stop with: txt string)             runs: (runs copyReplaceFrom: start to: stop with: txt runs)! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs :=  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis' stamp: 'ar 12/17/2001 23:48'!alignmentAt: characterIndex ifAbsent: aBlock	| attributes emph |	self size = 0 ifTrue: [^aBlock value].	emph := nil.	attributes := runs at: characterIndex.	attributes do:[:att | (att isKindOf: TextAlignment) ifTrue:[emph := att]].	^ emph ifNil: aBlock ifNotNil:[emph alignment]! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 12:30'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this"	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes := runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 11:32'!attributesAt: characterIndex forStyle: aTextStyle	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: aTextStyle defaultFontIndex)].  "null text tolerates access"	attributes := runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'di 4/1/1999 15:17'!emphasisAt: characterIndex	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes emph |	self size = 0 ifTrue: [^ 0].	"null text tolerates access"	emph := 0.	attributes := runs at: characterIndex.	attributes do: 		[:att | emph := emph bitOr: att emphasisCode].	^ emph	! !!Text methodsFor: 'emphasis' stamp: 'di 11/10/97 13:36'!find: attribute	"Return the first interval over which this attribute applies"	| begin end |	begin := 0.	runs withStartStopAndValueDo:		[:start :stop :attributes |		(attributes includes: attribute)			ifTrue: [begin = 0 ifTrue: [begin := start].					end := stop]			ifFalse: [begin > 0 ifTrue: [^ begin to: end]]].	begin > 0 ifTrue: [^ begin to: end].	^ nil! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 10:58'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle defaultFont].	"null text tolerates access"	attributes := runs at: characterIndex.	font := aTextStyle defaultFont.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font := f]].	^ font! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes := runs at: characterIndex.	fontNumber := 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber := att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'emphasis' stamp: 'md 1/20/2006 17:11'!makeSelectorBold	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser i |	string size = 0 ifTrue: [^ self].	i := 0.	[(string at: (i := i + 1)) isSeparator] whileTrue.	(string at: i) = $[ ifTrue: [^ self].  "block, no selector"	[(parser := Compiler parserClass new) parseSelector: string] on: Error do: [^ self].	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis' stamp: 'sma 2/5/2000 12:03'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	(parser := aClass parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis'!removeAttribute: att from: start to: stop 	"Remove the attribute over the interval start to stop."	runs :=  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes copyWithout: att])! !!Text methodsFor: 'private' stamp: 'tk 12/16/97 14:14'!setString: aString setRunsChecking: aRunArray	"Check runs and do the best you can to make them fit..."	string := aString.	"check the runs"	aRunArray ifNil: [^ aString asText].	(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].	aRunArray runs size = aRunArray values size ifFalse: [^ aString asText].	(aRunArray values includes: #()) ifTrue: [^ aString asText].	"not allowed?"	aRunArray size = aString size ifFalse: [^ aString asText].		runs := aRunArray.! !!Text methodsFor: 'private'!setString: aString setRuns: anArray	string := aString.	runs := anArray! !!Text class methodsFor: 'class initialization' stamp: 'mir 8/3/2004 13:30'!initTextConstants 	"Initialize constants shared by classes associated with text display, e.g., 	Space, Tab, Cr, Bs, ESC."		"1/24/96 sw: in exasperation and confusion, changed cmd-g mapping from 231 to 232 to see if I could gain any relief?!!"	| letter varAndValue tempArray width |	"CtrlA..CtrlZ, Ctrla..Ctrlz"	letter := $A. 	#(		212 230 228 196 194 226 241 243 214 229 200 217 246 			245 216 202 210 239 211 240 197 198 209 215 242 231	 		1 166 228 132 130 12 232 179 150 165 136 153 182 			14 15 138 17 18 19 11 21 134 145 151 178 167 ) do:		[:kbd |		TextConstants at: ('Ctrl', letter asSymbol) asSymbol put: kbd asCharacter.		letter := letter == $Z ifTrue: [$a] ifFalse: [(letter asciiValue + 1) asCharacter]].	varAndValue := #(		Space	32		Tab		9		CR		13		Enter	3		BS		8		BS2		158		ESC		160		Clear 	173	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i) asCharacter].	varAndValue := #(		CtrlDigits 			(159 144 143 128 127 129 131 180 149 135)		CtrlOpenBrackets	(201 7 218 249 219 15)			"lparen gottn by ctrl-:= = 201; should be 213 but can't type that on Mac"			"location of non-character stop conditions"		EndOfRun	257		CrossedX	258			"values for alignment"		LeftFlush	0		RightFlush	1		Centered	2		Justified	3			"subscripts for a marginTabsArray tuple"		LeftMarginTab	1		RightMarginTab	2			"font faces"		Basal	0		Bold	1		Italic	2			"in case font doesn't have a width for space character"			"some plausible numbers-- are they the right ones?"		DefaultSpace			4		DefaultTab				24		DefaultLineGrid			16		DefaultBaseline			12		DefaultFontFamilySize	3	"basal, bold, italic"	).	varAndValue size odd ifTrue: [self error: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i)].	TextConstants at: #DefaultRule	put: Form over.	TextConstants at: #DefaultMask	put: Color black.	width := Display width max: 720.	tempArray := Array new: width // DefaultTab.	1 to: tempArray size do:		[:i | tempArray at: i put: DefaultTab * i].	TextConstants at: #DefaultTabsArray put: tempArray.	tempArray := Array new: (width // DefaultTab) // 2.	1 to: tempArray size do:		[:i | tempArray at: i put: (Array with: (DefaultTab*i) with: (DefaultTab*i))].	TextConstants at: #DefaultMarginTabsArray put: tempArray."Text initTextConstants "! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream := TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!TextAction methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 09:49'!analyze: aString	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:3+4<3+4>Click Here<3+4><3+4>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim param show |	b1 := aString indexOf: $<.	b2 := aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		param := self validate: aString.		param ifNil: [ ^{ nil. nil } ].		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].	"Two parts"	trim := aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] ifFalse: [param]]			ifFalse: ["at the front"				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				param := self validate: (aString copyFrom: b1+1 to: b2-1).				show := param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				show := nil]].	^ Array with: param with: show! !!TextAction class methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!initialize   "TextAction initialize"	Purple := Color r: 0.4 g: 0 b: 1.0! !!TextAlignment methodsFor: 'as yet unclassified' stamp: 'ar 12/15/2001 23:33'!alignment: aNumber	alignment := aNumber.! !!TextColor methodsFor: 'accessing'!color: aColor	color := aColor! !!TextColor methodsFor: 'scanning' stamp: 'tk 12/16/97 09:47'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn str |	strm nextPut: $c.	(nn := color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		str := '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !!TextColor class methodsFor: 'instance creation' stamp: 'sma 3/24/2000 10:49'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit		ifTrue:			[r := (strm next: 3) asNumber.			g := (strm next: 3) asNumber.			b := (strm next: 3) asNumber.			^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:46'!analyze: aString	| list |	list := super analyze: aString.	evalString := list at: 1.	^ list at: 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!evalString: str	evalString := str ! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:06'!scanFrom: strm	"read a doit in the funny format used by Text styles on files. d10 factorial;;  end with two semicolons"	| pos end doit |	pos := strm position.	[strm skipTo: $;. strm peek == $;] whileFalse.	end := strm position - 1.	strm position: pos.	doit := strm next: end-pos.	strm skip: 2.  ";;"	^ self evalString: doit! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode := int.	setMode := true! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode := false! !!TextFieldMorph methodsFor: '*eToys-card & stack' stamp: 'tk 1/6/2001 14:15'!setNewContentsFrom: textOrString	"talk to my text"	| tm |	(tm := self findA: TextMorph) ifNil: [^ nil].	tm valueOfProperty: #cardInstance ifAbsent: ["move it down"		tm setProperty: #cardInstance toValue: (self valueOfProperty: #cardInstance)].	tm valueOfProperty: #holdsSeparateDataForEachInstance ifAbsent: ["move it down"		tm setProperty: #holdsSeparateDataForEachInstance toValue: 			(self valueOfProperty: #holdsSeparateDataForEachInstance)].	^ tm setNewContentsFrom: textOrString! !!TextFieldMorph class methodsFor: '*eToys-instance creation' stamp: 'sw 6/13/2001 22:48'!exampleBackgroundField	"Answer a scrollable background field for a parts bin"	| aMorph |	aMorph := self authoringPrototype.	aMorph contents: 'background field' asText allBold.	aMorph setProperty: #shared toValue: true.	aMorph setNameTo: 'scrollingField1'.	aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.	^ aMorph! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber := int! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font := aFont! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount := anInteger! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text := 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg := text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:10'!dominates: other	"NOTE: The use of active in this code is specific to its use in the method		Text class addAttribute: att toArray: others"	(active and: [other class == self class and: [other kern + kern = 0]])		ifTrue: [active := false.  ^ true].  "can only dominate once"	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 09:59'!kern: kernValue	kern := kernValue.	self reset.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:04'!reset	active := true! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:49'!analyze: aString	| list |	list := super analyze: aString.	classAndMethod := list at: 1.	^ list at: 2! !!TextLink methodsFor: 'as yet unclassified' stamp: 'LC 10/8/2001 10:53'!analyze: aString with: nonMethod	"Initalize this attribute holder with a piece text the user typed into a paragraph.  Returns the text to emphesize (may be different from selection)  Does not return self!!.  nonMethod is what to show when clicked, i.e. the last part of specifier (Comment, Definition, or Hierarchy).  May be of the form:Point<Point>Click Here<Point><Point>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim |	b1 := aString indexOf: $<.	b2 := aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		classAndMethod := self validate: aString, ' ', nonMethod.		^ classAndMethod ifNotNil: [aString]].	"Two parts"	trim := aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [classAndMethod]]			ifFalse: ["at the front"				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				classAndMethod := self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod ifNotNil: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				^ nil]]! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:09'!classAndMethod: aString	classAndMethod := aString! !!TextLink methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 09:50'!validate: specString	"Can this string be decoded to be Class space Method (or Comment, Definition, Hierarchy)? If so, return it in valid format, else nil" 	| list first mid last |	list := specString findTokens: ' 	.|'.	list isEmpty ifTrue: [ ^nil ].	last := list last.	last first isUppercase ifTrue: [		(#('Comment' 'Definition' 'Hierarchy') includes: last) ifFalse: [^ nil].		"Check for 'Rectangle Comment Comment' and remove last one"		(list at: list size - 1 ifAbsent: [^nil]) = last ifTrue: [list := list allButLast]].	list size > 3 ifTrue: [^ nil].	list size < 2 ifTrue: [^ nil].	Symbol hasInterned: list first ifTrue: [:sym | first := sym].	first ifNil: [^ nil].	Smalltalk at: first ifAbsent: [^ nil].	mid := list size = 3 		ifTrue: [(list at: 2) = 'class' ifTrue: ['class '] ifFalse: [^ nil]]		ifFalse: [''].	"OK if method name is not interned -- may not be defined yet"	^ first, ' ', mid, last! !!TextMorph methodsFor: '*eToys-card & stack' stamp: 'sw 5/31/2000 01:18'!newContents: stringOrText fromCard: aCard	"Accept new text contents."	| newText setter |	newText := stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text := newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible.  (this can make the scrollable area too large, though)"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@0)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self holdsSeparateDataForEachInstance		ifTrue:			[setter := self valueOfProperty: #setterSelector.			setter ifNotNil:				[aCard perform: setter with: newText]].	self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: '*eToys-card & stack' stamp: 'tk 1/8/2001 13:14'!setNewContentsFrom: stringOrTextOrNil	"Using stringOrTextOrNil as a guide, set the receiver's contents afresh.  If the input parameter is nil, the a default value stored in a property of the receiver, if any, will supply the new initial content.  This method is only called when a VariableDock is attempting to put a new value.  This is still messy and ill-understood and not ready for prime time."	| defaultValue tt atts |	stringOrTextOrNil ifNotNil: [^ self newContents: stringOrTextOrNil 		fromCard: (self valueOfProperty: #cardInstance)].		   "Well, totally yuk -- emergency measure late on eve of demo"	defaultValue := self valueOfProperty: #defaultValue 					ifAbsent: [atts := text attributesAt: 1.	"Preserve size, emphasis"						tt := text copyReplaceFrom: 1 to: text size								with: 'blankText'.						atts do: [:anAtt | tt addAttribute: anAtt].						tt].	self contents: defaultValue deepCopy wrappedTo: self width.! !!TextMorph methodsFor: '*eToys-e-toy support' stamp: 'sw 9/15/2000 06:14'!getNumericValue	"Obtain a numeric value from the receiver; if no digits, return zero"	| aString |	^ [(aString := text string) asNumber] ifError: [:a :b | ^ aString asInteger ifNil: [0]]! !!TextMorph class methodsFor: '*eToys-parts bin' stamp: 'sw 6/13/2001 22:46'!exampleBackgroundField	"Answer a background field for a parts bin"	| aMorph |	aMorph := TextMorph authoringPrototype.	aMorph contents: 'background field' asText allBold.	aMorph setProperty: #shared toValue: true.	aMorph setNameTo: 'field1'.	aMorph setProperty: #holdsSeparateDataForEachInstance toValue: true.		^ aMorph! !!TextPrintIt methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 13:27'!actOnClickFor: anObject in: aParagraph at: clickPoint editor: editor	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	| result range index |	result := Compiler evaluate: evalString for: anObject logged: false.	result := ' ', result printString,' '.	"figure out where the attribute ends in aParagraph"	index := (aParagraph characterBlockAtPoint: clickPoint) stringIndex.	range := aParagraph text rangeOf: self startingAt: index.	editor selectFrom: range last+1 to: range last.	editor zapSelectionWith: result.	editor selectFrom: range last to: range last + result size.	^ true ! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/2001 11:26'!adjustTargetMargin: aFractionalPoint	| n |	n := (aFractionalPoint * 4) rounded.	myTarget margins: n.	self showSliderFeedback: n.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'md 10/22/2003 15:22'!changeStyle	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNil: [^self].	(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor changeStyleTo: style copy.	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/21/2001 11:07'!changeTargetColorTo: aColor	self applyToWholeText ifTrue: [		lastGlobalColor := aColor	].	self changeSelectionAttributeTo: (TextColor color: aColor)! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/15/2001 12:01'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := self activeTextMorph textStyle fontNamesWithPointSizes.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply ifNil: [^self].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor replaceSelectionWith:		(Text string: self activeEditor selection asString 			attribute: (TextFontChange fontNumber: (aList indexOf: reply))).	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'dgd 8/31/2003 21:56'!rebuild	| buttonColor c |	self removeAllMorphs.	self addAColumn: {		self lockedString: ('Text Properties for {1}' translated format:{myTarget name}).	}.	self addAColumn: {		self paneForApplyToWholeText.	}.	c := self addAColumn: {		self activeTextMorph.	}.	c 		wrapCentering: #topLeft;		color: Color white;		borderWidth: 2;		borderColor: color darker.	self addAColumn: {		self paneForTextColorPicker.	}.	self addARow: {		self paneForAutoFitToggle.	}.	self addARow: {		self paneForWrappingToggle.	}.	self addARow: {		self paneForMargins.	}.	buttonColor := color lighter.	self addARow: {		self inAColumn: {			self addARow: {				self 					buttonNamed: 'Size' translated action: #offerFontMenu color: buttonColor					help: 'font changing' translated.				self 					buttonNamed: 'Style' translated action: #changeStyle color: buttonColor					help: 'font changing' translated.				self 					buttonNamed: 'N' translated action: #changeToNormalText color: buttonColor					help: 'normal text' translated.				self 					buttonNamed: 'B' translated action: #toggleBold color: buttonColor					help: 'bold text' translated.				self 					buttonNamed: 'I' translated action: #toggleItalic color: buttonColor					help: 'italic text' translated.				self 					buttonNamed: 'n' translated action: #toggleNarrow color: buttonColor					help: 'narrow text' translated.				self 					buttonNamed: 'U' translated action: #toggleUnderlined color: buttonColor					help: 'underlined text' translated.				self 					buttonNamed: 'S' translated action: #toggleStruckOut color: buttonColor					help: 'struck out text' translated.				self 					buttonNamed: 'Kern-' translated action: #kernMinus color: buttonColor					help: 'decrease kern' translated.				self 					buttonNamed: 'Kern+' translated action: #kernPlus color: buttonColor					help: 'increase kern' translated.			}.		}.	}.	self addARow: {		self inAColumn: {			self addARow: {				self 					buttonNamed: 'Accept' translated action: #doAccept color: buttonColor					help: 'keep changes made and close panel' translated.				self 					buttonNamed: 'Cancel' translated action: #doCancel color: buttonColor					help: 'cancel changes made and close panel' translated.			}.		}.	}.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/15/2001 11:50'!toggleApplyToWholeText	applyToWholeText := applyToWholeText not.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'RAA 3/16/2001 09:15'!toggleSelectionAttribute: newAttribute	| selText oldAttributes |	self applyToWholeText ifTrue: [self activeEditor selectAll].	selText := self activeEditor selection asText.	oldAttributes := selText attributesAt: 1 forStyle: self activeTextMorph textStyle.	oldAttributes do: [:att |		(att dominates: newAttribute) ifTrue: [newAttribute turnOff]	].	self activeEditor replaceSelectionWith: (selText addAttribute: newAttribute).	self activeTextMorph updateFromParagraph.! !!TextPropertiesMorph methodsFor: 'initialization' stamp: 'nk 2/12/2004 13:06'!initialize	"initialize the state of the receiver"	super initialize.	""	applyToWholeText := true.	myTarget		ifNil: [""			myTarget := TextMorph new openInWorld.			myTarget contents: ''].	activeTextMorph := myTarget copy.	activeTextMorph extent: 300 @ 100;	 			 releaseCachedState.	thingsToRevert		at: #wrapFlag: put: myTarget isWrapped;		 at: #autoFit: put: myTarget isAutoFit;		 at: #margins: put: myTarget margins;		at: #extent: put: myTarget extent.	self rebuild! !!TextSqkPageLink methodsFor: 'as yet unclassified' stamp: 'tk 1/12/1999 12:56'!actOnClickFor: textMorph	"I represent a link to either a SqueakPage in a BookMorph, or a regular url"	| book |	((url endsWith: '.bo') or: [url endsWith: '.sp']) ifFalse: [		^ super actOnClickFor: textMorph].	book := textMorph ownerThatIsA: BookMorph.	book ifNotNil: [book goToPageUrl: url].	"later handle case of page being in another book, not this one"	^ true! !!TextSqkProjectLink methodsFor: 'as yet unclassified' stamp: 'RAA 10/19/2000 16:24'!analyze: aString	^url := aString! !!TextStream methodsFor: 'as yet unclassified' stamp: 'dvf 10/1/2003 02:51'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n := aCollection size.     position + n > writeLimit       ifTrue:        [self growTo: position + n + 10].	collection 		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position := position + n! !!TextStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	| pos1 val |	pos1 := self position.	val := strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !!TextStream methodsFor: 'as yet unclassified' stamp: 'djp 11/6/1999 20:30'!withAttributes: attributes do: streamBlock 	| pos1 val |	pos1 := self position.	val := streamBlock value.	attributes do: [:attribute |		collection			addAttribute: attribute			from: pos1 + 1			to: self position].	^ val! !!TextURL methodsFor: 'as yet unclassified' stamp: 'rbb 2/18/2005 09:24'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		ProjectLoading thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m := anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m := m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	((self confirm: 'open a browser to view this URL?' translated) and: [WebBrowser default notNil]) ifTrue: [		WebBrowser default openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response := (UIManager default 				chooseFrom: (Array with: 'View web page as source' translated									with: 'Cancel' translated)				title:  'Couldn''t find a web browser. View\page as source?' withCRs translated).	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:47'!analyze: aString	| list |	list := super analyze: aString.	url := list at: 1.	^ list at: 2! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:55'!url: aString	url := aString! !!ThumbnailForAllPlayersTool methodsFor: 'stepping' stamp: 'sw 7/28/2004 22:23'!step	"periodic action"	| aMorph |	((aMorph := objectToView costume) notNil and: [aMorph isInWorld]) ifTrue:		[super step]  "don't bother changing my readout to blank when/if object disappears"! !!TileLikeMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor := formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TileMessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 18:25'!printIfNilNotNil: aMorph indent: level	| newNode |	newNode := aMorph parseNode clone.	newNode receiver ifNotNil:		[newNode receiver: newNode receiver ifNilReceiver].	"fudge so it prints right"	(arguments first isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNotNil:				arguments: { arguments second }				on: aMorph indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ newNode morphFromKeywords: #ifNil:				arguments: { arguments first }				on: aMorph indent: level].	^ newNode morphFromKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aMorph indent: level! !!TileMessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 17:15'!printWhileOn: aMorph indent: level	(arguments first isJust: NodeNil) ifTrue: [		selector := SelectorNode new			key: (selector key == #whileTrue:				ifTrue: [#whileTrue] ifFalse: [#whileFalse])			code: #macro.		arguments := Array new	].	self printKeywords: selector key arguments: arguments		on: aMorph indent: level! !!TileMorph methodsFor: 'accessing' stamp: 'di 9/18/97 12:02'!literal: anObject	literal := anObject.	self updateLiteralLabel.	self acceptNewLiteral.		"Show that we are out of date, install is needed"! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:29'!addArrows	| frame |	downArrow := ImageMorph new image: DownPicture.	upArrow := ImageMorph new image: UpPicture.	frame := Morph new color: Color transparent.	frame 		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		hResizing: #shrinkWrap; 		vResizing: #shrinkWrap;		cellInset: 0@1;		layoutInset: 0@1.	frame addMorphBack: upArrow; addMorphBack: downArrow.	self addMorphFront: frame.! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/16/2000 09:48'!addRetractArrow	"Must be situated in a script"	self couldRetract ifNil: [^ self].	retractArrow := ImageMorph new image: RetractPicture.	suffixArrow ifNotNil: [		self addMorph: retractArrow inFrontOf: suffixArrow].	fullBounds := nil.	self extent: self fullBounds extent! !!TileMorph methodsFor: 'arrows' stamp: 'ar 11/2/2000 22:30'!addSuffixArrow	suffixArrow := ImageMorph new image: SuffixPicture.	self addMorphBack: suffixArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'tak 12/5/2004 14:36'!arrowAction: delta 	"Do what is appropriate when an arrow on the tile is pressed; delta will  	be +1 or -1"	| index options |	(type == #literal			and: [literal isNumber])		ifTrue: [self value: literal + delta]		ifFalse: [options := self options						ifNil: [^ self].			index := (options first indexOf: self value)						+ delta.			self				value: (options first atWrap: index).			submorphs last				setBalloonText: (options second atWrap: index)]! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/16/2000 08:59'!couldRetract	"See if it makes sense to retract this tile and the op before it.  Return the phrase that gets retracted, or nil if not allowed."	| phrase pad |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ nil].	(pad := phrase ownerThatIsA: TilePadMorph) ifNil: [^ nil].	(phrase firstSubmorph "goodPad") type == pad type ifFalse: [		phrase submorphs size < 3 ifFalse: [^ nil].	"types should have matched"		"Go up a level"		(phrase := pad ownerThatIsA: PhraseTileMorph) ifNil: [^ nil].		(pad := phrase ownerThatIsA: TilePadMorph) ifNil: [^ nil].		(phrase firstSubmorph "goodPad") type == pad type ifFalse: [^ nil].		].	^ phrase! !!TileMorph methodsFor: 'arrows' stamp: 'ar 9/24/2000 19:11'!deleteLastTwoTiles	"Remove the current suffix (last two tiles) in this line of tiles"	| phrase pad goodPad |	(phrase := self couldRetract) ifNil: [^ self].	pad := phrase ownerThatIsA: TilePadMorph.	goodPad := phrase firstSubmorph.	pad owner addMorphBack: goodPad.	pad delete.	(goodPad lastSubmorph respondsTo: #addSuffixArrow) 		ifTrue: [goodPad lastSubmorph addSuffixArrow; addRetractArrow]		ifFalse: [goodPad lastSubmorph lastSubmorph addSuffixArrow; addRetractArrow].	goodPad topEditor install. "recompile"! !!TileMorph methodsFor: 'arrows' stamp: 'tk 8/10/2000 14:34'!deleteSuffixArrow	suffixArrow delete.	suffixArrow := nil.	retractArrow ifNotNil: ["backward compat"		retractArrow delete.		retractArrow := nil].	self updateLiteralLabel! !!TileMorph methodsFor: 'arrows' stamp: 'sw 1/4/2005 02:09'!phraseForOp: op arg: arg resultType: resultType	"Answer a numeric-valued phrase derived from the receiver, whose extension arrow has just been hit.  Pass along my float-precision."	| phrase srcLabel distLabel |	phrase := self presenter				phraseForReceiver: literal				op: op				arg: 1				resultType: #Number.	srcLabel := self findA: UpdatingStringMorph.	distLabel := phrase submorphs first submorphs first findA: UpdatingStringMorph.	distLabel floatPrecision: srcLabel floatPrecision.	^ phrase! !!TileMorph methodsFor: 'arrows' stamp: 'tak 12/5/2004 15:33'!showSuffixChoices	"The suffix arrow has been hit, so respond appropriately"	| plusPhrase phrase pad outer num |	(phrase := self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plusPhrase := self phraseForOp: #+ arg: 1 resultType: #Number.				plusPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: #+).				owner acceptDroppingMorph: plusPhrase event: self primaryHand lastEvent.				num := plusPhrase firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #Number ifTrue:			[outer := phrase ownerThatIsA: PhraseTileMorph.			pad := self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plusPhrase := self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #Number.					plusPhrase submorphs second submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: #+).					pad acceptDroppingMorph: plusPhrase event: self primaryHand lastEvent.					plusPhrase firstSubmorph removeAllMorphs; addMorph: phrase.	"car's heading"					self deleteSuffixArrow.					pad topEditor install "recompile"]]]].	(phrase topEditor ifNil: [phrase]) enforceTileColorPolicy! !!TileMorph methodsFor: 'arrows' stamp: 'ar 2/12/2001 13:55'!variableDelay: aBlock	| now delay dt |	(self hasProperty: #inVariableDelay) ifTrue:[^self].	nArrowTicks ifNil: [nArrowTicks := 1].	now := Time millisecondClockValue.	aBlock value.	delay := nArrowTicks > 5 ifTrue: [100] ifFalse: [300].	nArrowTicks := nArrowTicks + 1.	dt := Time millisecondClockValue - now max: 0.  "Time it took to do."	dt < delay ifTrue: [		self setProperty: #inVariableDelay toValue: true.		self addAlarm: #removeProperty: withArguments: #(inVariableDelay) after: (delay - dt)].! !!TileMorph methodsFor: 'code generation' stamp: 'sw 8/30/2004 16:34'!acceptNewLiteral	"Tell the scriptEditor who I belong to that I have a new literal value."	| topScript |	topScript := self outermostMorphThat:		[:m | m isKindOf: ScriptEditorMorph].	topScript ifNotNil: [topScript installWithNewLiteral].	(self ownerThatIsA: ViewerLine) ifNotNilDo:		[:aLine |			(self ownerThatIsA: PhraseTileMorph) ifNotNil:				[aLine removeHighlightFeedback.				self layoutChanged.				ActiveWorld doOneSubCycle.				aLine addCommandFeedback]]! !!TileMorph methodsFor: 'code generation'!precedingTileType	"Return the slot reference type of the preceding TileMorph in my owner."	| row i tile |	row := owner submorphs.	i := row indexOf: self.	((i > 1) and: [(tile := row at: i - 1) isKindOf: TileMorph])		ifTrue: [^ tile type]		ifFalse: [^ #unknown].! !!TileMorph methodsFor: 'code generation' stamp: 'sw 9/26/97 10:51'!scriptEdited	"Tell the scriptEditor who I belong to that I have changed.  "	| him |	(him := self outermostMorphThat: [:m| m isKindOf: ScriptEditorMorph])		ifNotNil: [him scriptEdited]! !!TileMorph methodsFor: 'code generation' stamp: 'yo 4/4/2005 16:14'!storeCodeOn: aStream indent: tabCount 	"Store code representing the receiver onto the stream, with the given amount of indentation"	| op playerBearingCode |	playerBearingCode := self playerBearingCode.	"Must determine whom is scripted for what follows to work; if it's ever nil, we've got trouble"	type = #expression 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: operatorOrExpression;				nextPut: $)].	type = #literal 		ifTrue: 			[^aStream				nextPut: $(;				nextPutAll: literal printString;				nextPut: $)].	type == #objRef 		ifTrue: 			[^playerBearingCode == actualObject 				ifTrue: 					["If the object is the method's own 'self' then we MUST, rather than just MAY, put out 'self' rather than the referencer call, though the latter will temporarily work if only one instance of the uniclass exists."					aStream nextPutAll: 'self']				ifFalse: 					[(actualObject isPlayerLike and: [actualObject isSequentialStub]) ifTrue: [						actualObject storeCodeOn: aStream indent: tabCount.					] ifFalse: [						 Preferences capitalizedReferences 						ifTrue: 							["Global dictionary References"							self flag: #deferred.	"Start deploying the meesage-receiver hints soon"							aStream nextPutAll: actualObject uniqueNameForReference]						ifFalse: 							["old class-inst-var-based scheme used  Feb 1998 to Oct 2000, and indeed						ongoing in school year 2000-01 at the open school"							aStream nextPutAll: 'self class '.							aStream 								nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]]]].	type = #operator 		ifTrue: 			[op := ((UpdatingOperators includesKey: operatorOrExpression) 				and: [self precedingTileType = #slotRef]) 					ifTrue: [UpdatingOperators at: operatorOrExpression]					ifFalse: [operatorOrExpression].			^op isEmpty 				ifTrue: [aStream position: aStream position - 1]				ifFalse: [aStream nextPutAll: op]]	"The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType := self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:15'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.actualObject := deepCopier references at: actualObject ifAbsent: [actualObject].! !!TileMorph methodsFor: 'copying' stamp: 'sw 6/4/2001 16:45'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.type := type veryDeepCopyWith: deepCopier.slotName := slotName veryDeepCopyWith: deepCopier.literal := literal veryDeepCopyWith: deepCopier.operatorOrExpression := operatorOrExpression veryDeepCopyWith: deepCopier."actualObject := actualObject.		Weakly copied"downArrow := downArrow veryDeepCopyWith: deepCopier.upArrow := upArrow veryDeepCopyWith: deepCopier.suffixArrow := suffixArrow veryDeepCopyWith: deepCopier.typeColor := typeColor veryDeepCopyWith: deepCopier.lastArrowTick := lastArrowTick veryDeepCopyWith: deepCopier.nArrowTicks := nArrowTicks veryDeepCopyWith: deepCopier.operatorReadoutString := operatorReadoutString veryDeepCopyWith: deepCopier.possessive := possessive veryDeepCopyWith: deepCopier.retractArrow := retractArrow veryDeepCopyWith: deepCopier.vocabularySymbol := vocabularySymbol.  "Weakly copied"vocabulary := nil.   "obsolete - clobbered"! !!TileMorph methodsFor: 'dropping/grabbing' stamp: 'ar 2/9/2001 23:57'!justGrabbedFrom: formerOwner	| editor |	formerOwner ifNil:[^self].	editor := formerOwner topEditor.	editor ifNotNil:[editor scriptEdited].! !!TileMorph methodsFor: 'event handling' stamp: 'ar 2/8/2001 20:07'!handlesMouseDown: evt	"Answer whether the receiver would handle the mouseDown represented by evt"	| aPoint |	aPoint := evt cursorPoint.	(operatorOrExpression notNil and: [upArrow notNil]) ifTrue: [^ true].		"Click on the operator presents list of alternatives"	upArrow ifNotNil: [^true].	suffixArrow ifNotNil: [^true].	retractArrow ifNotNil: [^true].	^ super handlesMouseDown: evt! !!TileMorph methodsFor: 'event handling' stamp: 'tak 12/6/2004 01:28'!mouseDown: evt 	self setProperty: #previousLiteral toValue: self literalFromContents.	self setProperty: #previousPoint toValue: evt position.	self currentHand releaseKeyboardFocus.	evt hand		waitForClicksOrDrag: self		event: evt		selectors: {#mouseStillDown:. nil. nil. #startDrag:}		threshold: 5.	^ super mouseDown: evt! !!TileMorph methodsFor: 'event handling' stamp: 'wiz 9/22/2007 23:46'!mouseMove: evt 	self options		ifNotNil: [^ self showOptions].	(self hasProperty: #previousLiteral)		ifFalse: [^ self].	self currentHand releaseKeyboardFocus.	"Once reviving the value at drag start"	literal := self valueOfProperty: #previousLiteral.	"Then applying delta"	self arrowAction: (self valueOfProperty: #previousPoint) y - evt position y * self arrowDelta abs.	^ super mouseMove: evt! !!TileMorph methodsFor: 'event handling' stamp: 'tak 12/6/2004 01:00'!mouseStillDown: evt 	"See if arrows are being pressed and call arrowAction:..."	| aPoint |	upArrow		ifNil: [^ super mouseStillDown: evt].	aPoint := evt cursorPoint.	(upArrow containsPoint: aPoint)		ifTrue: [^ self				variableDelay: [self arrowAction: self arrowDelta]].	(downArrow containsPoint: aPoint)		ifTrue: [^ self				variableDelay: [self arrowAction: self arrowDelta negated]].	self options		ifNotNil: [^ self showOptions]! !!TileMorph methodsFor: 'events-processing' stamp: 'ar 9/18/2000 18:03'!handlerForMouseDown: anEvent	"Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event"	| aPoint |	upArrow ifNotNil:		[(upArrow bounds containsPoint: (aPoint := anEvent cursorPoint))			ifTrue: [^self].		(downArrow bounds containsPoint: aPoint)			ifTrue: [^self]].	^super handlerForMouseDown: anEvent! !!TileMorph methodsFor: 'e-toy support' stamp: 'sw 6/4/2001 16:48'!adoptVocabulary: aVocabulary	"Set the receiver's vocabulary"	vocabularySymbol := aVocabulary vocabularyName.	self updateWordingToMatchVocabulary.	super adoptVocabulary: aVocabulary! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 9/1/2003 13:35'!bringUpToDate	"Make certain, if the receiver is an object-reference tile, that it shows the current external name of the object, which may just have changed.  This only applies to the Player regime." 	| newLabel |		(type == #objRef and: [actualObject isPlayerLike]) ifTrue:		[newLabel := actualObject externalName.		self isPossessive ifTrue:			[newLabel := newLabel, '''s' translated].		self line1: newLabel]! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:44'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 1 @ 1.	self		typeColor: (Color				r: 0.8				g: 1.0				b: 0.6).	type := #literal.	"#literal, #slotRef, #objRef, #operator, #expression"	slotName := ''.	literal := 1.	self layoutPolicy: TableLayout new.	self cellInset: 2 @ 0.	self layoutInset: 1 @ 0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill! !!TileMorph methodsFor: 'initialization' stamp: 'yo 4/4/2005 14:31'!referToSimilarObject: anObject	"Make the receiver be an object-reference tile whose referent is anObject"	actualObject := anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/28/2000 12:27'!referTo: anObject	"Make the receiver be an object-reference tile whose referent is anObject"	type := #objRef.	typeColor := ScriptingSystem colorForType: anObject basicType.	actualObject := anObject.	self line1: anObject uniqueNameForReference! !!TileMorph methodsFor: 'initialization' stamp: 'sw 3/3/2004 16:28'!retargetFrom: oldPlayer to: newPlayer	"Change the receiver so that if formerly it referred to oldPlayer, it refers to newPlayer instead"	| newLabel |	(type == #objRef  and: [actualObject == oldPlayer]) ifTrue:		[actualObject := newPlayer.		newLabel := actualObject externalName.		self isPossessive ifTrue:			[newLabel := newLabel, '''s' translated].		self line1: newLabel]! !!TileMorph methodsFor: 'initialization'!setExpression: exprString label: labelString	type := #expression.	operatorOrExpression := exprString.	self line1: labelString.! !!TileMorph methodsFor: 'initialization' stamp: 'nk 8/30/2004 08:02'!setLiteral: anObject	"Set the receiver's literal to be anObject.  Create a readout morph and add it to the receiver, deleting any existing one that may be there."	| m already |	already := submorphs detect: [:aSubMorph  | aSubMorph isKindOf: UpdatingStringMorph] ifNone: [nil].	already ifNotNil: [already delete].	type := #literal.	m := UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isString or: [ anObject isText]) ifTrue: [m useStringFormat].	self addMorphBack: m.	self setLiteralInitially: anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/27/2001 04:09'!setOperator: aString andUseWording: wording	"Set the operator symbol from the string provided"	type := #operator.	operatorOrExpression := aString asSymbol. 	self line1: wording.	(ScriptingSystem doesOperatorWantArrows: operatorOrExpression)		ifTrue: [self addArrows].	self updateLiteralLabel	"operatorOrExpression == #heading ifTrue: [self halt]."! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/17/2001 12:17'!setOperatorAndUseArrows: aString	"Set the operator as per aString, and add up/down arrows"	type := #operator.	operatorOrExpression := aString asSymbol. 	self line1: (self currentVocabulary tileWordingForSelector: operatorOrExpression).	self addArrows; updateLiteralLabel.	submorphs last setBalloonText: (ScriptingSystem helpStringForOperator: operatorOrExpression)! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/13/2001 21:58'!setSlotRefOperator: getter	"getter represents the name of a slot that the receiver is to represent; configure the receiver to serve thi duty, and set upthe wording on the tile appropriately"	type := #operator.	operatorOrExpression := getter asSymbol.	self line1:  (self currentEToyVocabulary tileWordingForSelector: operatorOrExpression).	self updateLiteralLabel! !!TileMorph methodsFor: 'initialization' stamp: 'dgd 8/26/2004 12:04'!setToReferTo: anObject	"Set the receiver to bear an object reference to the given object."	self flag: #yo.	type := #objRef.	actualObject := anObject.	self line1: anObject nameForViewer.	self typeColor: (ScriptingSystem colorForType: #Player).	self enforceTileColorPolicy! !!TileMorph methodsFor: 'initialization' stamp: 'yo 7/2/2004 21:44'!updateWordingToMatchVocabulary	"The current vocabulary has changed; change the wording on my face, if appropriate"	| aMethodInterface |	type == #operator ifTrue:		[self line1: (self currentVocabulary tileWordingForSelector: operatorOrExpression).		(ScriptingSystem doesOperatorWantArrows: operatorOrExpression)			ifTrue: [self addArrows].		self updateLiteralLabel.		aMethodInterface := self currentVocabulary methodInterfaceAt: operatorOrExpression			ifAbsent: [				Vocabulary eToyVocabulary					methodInterfaceAt: operatorOrExpression ifAbsent: [^ self]].		self setBalloonText: aMethodInterface documentation.	].	type == #objRef ifTrue: [		self isPossessive			ifTrue: [self bePossessive]			ifFalse: [self labelMorph contents: self actualObject nameForViewer asSymbol translated]].		"submorphs last setBalloonText: aMethodInterface documentation"! !!TileMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:33'!currentVocabulary	"Answer the receiver's current vocabulary"	| outer aVocab |	vocabulary ifNotNil:  "old structures -- bring up to date"		[vocabularySymbol := vocabulary vocabularyName.		vocabulary := nil].	^ vocabularySymbol		ifNotNil:			[Vocabulary vocabularyNamed: vocabularySymbol]		ifNil:			[(outer := self ownerThatIsA: StandardViewer orA: ScriptEditorMorph) 				ifNotNil:					[aVocab := outer currentVocabulary.					vocabularySymbol := aVocab vocabularyName.					aVocab]				ifNil:					[super currentVocabulary]]! !!TileMorph methodsFor: 'misc' stamp: 'dgd 8/30/2003 22:19'!addCustomMenuItems:  aMenu hand: aHandMorph	"Add custom halo menu items to a menu"	| aPlayer |	super addCustomMenuItems: aMenu hand: aHandMorph.	((aPlayer := self associatedPlayer) notNil and:		[aPlayer costume isMorph]) ifTrue:			[aMenu addLine.			aMenu add: 'hand me this object' translated target: self action: #handReferentMorph.			aMenu balloonTextForLastItem: 'This tile refers to an actual graphical object; use this menu item to grab that object.  Caution!!  This may remove the object from a place it really ought to stay.' translated.			aMenu addLine ]! !!TileMorph methodsFor: 'misc' stamp: 'sw 4/9/2001 12:55'!handReferentMorph	"Hand the user the actual morph referred to"	| aMorph surrogate |	((aMorph := actualObject costume) isMorph and:		[aMorph isWorldMorph not])			ifTrue:				[surrogate := CollapsedMorph collapsedMorphOrNilFor: aMorph.				surrogate					ifNotNil:						[surrogate uncollapseToHand]					ifNil:						[ActiveHand attachMorph: aMorph]]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/17/1999 08:02'!minimumWidth	| aWidth |	aWidth := self basicWidth.	upArrow ifNotNil: [aWidth := aWidth + UpArrowAllowance].	suffixArrow ifNotNil: [aWidth := aWidth + SuffixArrowAllowance].	^ aWidth	! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/15/2000 06:00'!setLiteralInitially: anObject	"Establish the initial literal.  Get the label correct, but do *not* send the value back to the target via the setter (unlike #literal:)"	literal := anObject.	self updateLiteralLabel! !!TileMorph methodsFor: 'misc' stamp: 'sw 1/28/2005 00:54'!soundChoices	"Answer a list of sound choices.  This applies only to tiles that have sound-names as their literals, viz. SoundTiles and SoundReadoutTiles."	| aList |	aList := SoundService default sampledSoundChoices asOrderedCollection.	aList removeAllFoundIn: (ScriptingSystem soundNamesToSuppress copyWithout: literal).	^ aList asSortedArray! !!TileMorph methodsFor: 'misc' stamp: 'sw 8/28/2004 15:20'!typeColor: aColor	"Set the receiver's typeColor"	borderColor := ScriptingSystem standardTileBorderColor.	typeColor := aColor.	color := ScriptingSystem uniformTileInteriorColor ! !!TileMorph methodsFor: 'mouse handling' stamp: 'sw 11/22/2000 10:50'!presentOperatorAlternatives: evt	"The receiver is a tile that represents an operator; a click on the receiver's label will pop up a menu of alternative operator choices"	| result ops |	((ops := ScriptingSystem arithmeticalOperatorsAndHelpStrings first) includes: operatorOrExpression) ifFalse:		[((ops := ScriptingSystem numericComparitorsAndHelpStrings first) includes: operatorOrExpression)			ifFalse: [^ self]].			(result := (SelectionMenu selections: ops) startUp) ifNotNil:		[self setOperatorAndUseArrows: result asString.		self scriptEdited]! !!TileMorph methodsFor: 'mouse handling' stamp: 'yo 3/14/2005 10:27'!showOptions	"The receiver is a tile that represents an operator; a click on the 	receiver's label will pop up a menu of alternative operator choices"	| result menuChoices word |	menuChoices := (self options first collect: [:each | each asString translated]) collect: [:each | 							word := self currentVocabulary translatedWordingFor: each asSymbol.							word isEmpty								ifTrue: ['<-']								ifFalse: [word]].	result := (SelectionMenu labelList: menuChoices lines: nil selections: self options first) startUp.	result 		ifNotNil: [self value: result.			self scriptEdited]! !!TileMorph methodsFor: 'player viewer' stamp: 'sw 9/13/2001 21:58'!updateLiteralLabel	"Update the wording emblazoned on the tile, if needed"	| myLabel |	(myLabel := self labelMorph) ifNil: [^ self].	myLabel acceptValue:		(type == #literal			ifTrue:				[literal] 			ifFalse: [operatorReadoutString 				ifNil:		[self currentEToyVocabulary tileWordingForSelector: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	self changed.! !!TileMorph methodsFor: 'tiles from method' stamp: 'tk 8/6/1999 16:00'!selectorTile: msgNode in: aScriptor	| sel selTile |	"Make a selector (operator) tile"	sel := msgNode selector key.	sel == #color:sees: ifTrue: [		selTile := (Viewer new) colorSeesPhrase submorphs second.	"ColorSeer tile"		selTile colorSwatchColor: msgNode arguments first eval.		^ selTile].	^ self setOperator: sel! !!TileMorph methodsFor: 'private' stamp: 'ar 11/2/2000 19:21'!convertAlignment	"Convert the receiver's alignment rules"	| where frame |	owner ifNotNil:[		owner class == TilePadMorph ifTrue:[			owner layoutPolicy: TableLayout new.			owner hResizing: #shrinkWrap.			owner vResizing: #spaceFill.		].	].	self layoutPolicy: TableLayout new.	self cellInset: 2@0.	self layoutInset: 1@0.	self listDirection: #leftToRight.	self wrapCentering: #center.	self hResizing: #shrinkWrap.	self vResizing: #spaceFill.	"Now convert up and down arrow"	(upArrow notNil and:[upArrow owner == self "e.g., not converted"		and:[downArrow notNil and:[downArrow owner == self]]]) ifTrue:[			"where to insert the frame"			where := (submorphs indexOf: upArrow) min: (submorphs indexOf: downArrow).			frame := Morph new color: Color transparent.			frame 				layoutPolicy: TableLayout new;				listDirection: #topToBottom;				hResizing: #shrinkWrap; 				vResizing: #shrinkWrap;				cellInset: 0@1;				layoutInset: 0@1.			self privateAddMorph: frame atIndex: where.			frame addMorphBack: upArrow; addMorphBack: downArrow.		].! !!TileMorph methodsFor: 'private' stamp: 'sw 10/30/2000 09:00'!line1: line1	"Emblazon the receiver with the requested label.  If the receiver already has a label, make the new label be of the same class"	| m desiredW classToUse lab |	classToUse := (lab := self labelMorph) ifNotNil: [lab class] ifNil: [StringMorph].	self removeAllMorphs.	m := classToUse contents: line1 font: ScriptingSystem fontForTiles.	desiredW := m width + 6.	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	m position: self center - (m extent // 2).	self addMorph: m.! !!TileMorph methodsFor: 'private' stamp: 'tk 8/14/2000 13:32'!test	| pos hh |	"Set the position of all my submorphs.  Compute my bounds.  Caller must call layoutChanged or set fullBounds to nil."	fullBounds ifNil: [		pos := self topLeft.		self submorphsDo: [:sub | 			hh := (self class defaultH - sub height) // 2.	"center in Y"			sub privateBounds: (pos + (2@hh) extent: sub extent).			pos x: (sub right min: 1200)].	"2 pixels spacing on left"		bounds := bounds topLeft corner: pos + (2 @ self class defaultH).		fullBounds := bounds.		].	owner class == TilePadMorph ifTrue: [owner bounds: bounds].	^ fullBounds! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 17:30'!fixCaretForms	"TileMorph fixCaretForms"	"UpPicture storeString"	"DownPicture storeString"	UpPicture :=  Form	extent: 9@8	depth: 16	fromArray: #( 0 0 60817408 0 0 0 0 60818336 0 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 60818336 60818336 60818336 0 928 60818336 60818336 60818336 0 928 60818336 60818336 60818336 60817408 60818336 60818336 60818336 60818336 60817408)	offset: 0@0.	DownPicture := Form	extent: 9@8	depth: 16	fromArray: #( 60818336 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 0 0 60818336 60818336 60818336 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 0 60818336 0 0 0 0 60817408 0 0)	offset: 0@8.	SuffixPicture :=  Form	extent: 10@8	depth: 16	fromArray: #( 928 0 0 0 0 60818336 60818336 0 0 0 60818336 60818336 60818336 60817408 0 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 0 0)	offset: 0@0! !!TileMorph class methodsFor: 'class initialization' stamp: 'tk 8/15/2000 11:00'!initialize	"TileMorph readInArrowGraphics    -- call manually if necessary to bring graphics forward"	"TileMorph initialize"	UpdatingOperators := Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.	RetractPicture ifNil: [		RetractPicture := (SuffixPicture flipBy: #horizontal centerAt: (SuffixPicture center))].	SuffixArrowAllowance := 5 + SuffixPicture width + RetractPicture width.	UpArrowAllowance := 10.! !!TileMorph class methodsFor: 'class initialization' stamp: 'mdr 9/4/2000 11:06'!readInArrowGraphics	"TileMorph readInArrowGraphics"	| obj |	obj := (FileStream readOnlyFileNamed: 'tile inc arrow.morph') fileInObjectAndCode.	UpPicture := obj form.	obj := (FileStream readOnlyFileNamed: 'tile dec arrow.morph') fileInObjectAndCode.	DownPicture := obj form.	obj := (FileStream readOnlyFileNamed: 'tile suffix arrow.morph')fileInObjectAndCode.	SuffixPicture := obj form.! !!TilePadMorph methodsFor: 'layout' stamp: 'sw 1/6/2005 03:25'!acceptDroppingMorph: aMorph event: evt 	"Accept the given morph within my bowels"	| editor wasPossessive morphToUse |	wasPossessive := submorphs notEmpty and: [submorphs first isPossessive].	morphToUse := self morphToDropFrom: aMorph.	self prepareToUndoDropOf: morphToUse.	self removeAllMorphs.	morphToUse position: self position.	self addMorph: morphToUse.	wasPossessive ifTrue: [morphToUse bePossessive].	morphToUse lastTile addRetractArrow.	"if can"	(editor := self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'ar 8/16/2001 13:30'!isColorConstant: aParseNode	"Is this a Color constant, of the form (MessageNode (VariableNode Color->Color) (SelectorNode #r:g:b:) (LiteralNode LiteralNode LiteralNode))"	| rec |	((rec := aParseNode receiver) isKindOf: VariableNode) ifFalse: [^ false].	rec key isVariableBinding ifFalse: [^ false].	rec key value == Color ifFalse: [^ false].	aParseNode selector key == #r:g:b: ifFalse: [^ false].	aParseNode arguments  size = 3 ifFalse: [^ false].	^ true! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'tk 8/3/1999 13:25'!isOutsideRef: aParseNode	"Is this a reference to an outside Player, of the form (self class refUnscriptedPlayer1)?(MessageNode (VariableNode 'self') (SelectorNode 'class')) (SelectorNode 'refUnscriptedPlayer1')"	| rec |	((rec := aParseNode receiver) isKindOf: MessageNode) ifFalse: [^ false].	rec receiver isSelfPseudoVariable ifFalse: [^ false].	rec selector key == #class ifFalse: [^ false].	aParseNode selector key numArgs = 0 ifFalse: [^ false].	(aParseNode selector key beginsWith: 'ref') ifFalse: [^ false].	^ true! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 5/1/2005 03:42'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| vwr |	(aMorph isKindOf: WatcherWrapper)		ifTrue: [^ aMorph getterTilesForDrop].	^ ((self type capitalized = #Graphic)  "Special-case requested by Alan 4/30/05"		and: [aMorph isKindOf: TileMorph] and: [aMorph resultType = #Player])			ifFalse:				[aMorph]			ifTrue:				[vwr := CategoryViewer new initializeFor: aMorph associatedPlayer categoryChoice: #basic.				vwr getterTilesFor: (Utilities getterSelectorFor: #graphic)  type: #Graphic]! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'sw 9/17/1999 08:03'!setType: aSymbol	type := aSymbol.	self color: (ScriptingSystem colorForType: type).	self extent: (self basicWidth @ TileMorph defaultH)! !!TilePadMorph methodsFor: 'mouse' stamp: 'sw 5/1/2005 03:17'!canAccept: aMorph	"Answer whether this pad can accept the given morph"	| itsType myType |	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isKindOf: TileMorph orOf: WatcherWrapper]) 		ifTrue:			[^ ((itsType := aMorph resultType capitalized) = (myType := self type capitalized)) or:				[(myType = #Graphic) and: [itsType = #Player]]].	^ false! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount	"Private - only used by Time class."	seconds _ secondCount.	nanos _ 0! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Time class."	seconds _ secondCount.	nanos _ nanoCount! !!Time methodsFor: 'private' stamp: 'gk 8/30/2006 23:28'!ticks: anArray	"ticks is an Array: { days. seconds. nanoSeconds }"	seconds _ anArray at: 2.	nanos _ anArray at: 3! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:17'!milliSecondsSinceMidnight	^ DateAndTime milliSecondsSinceMidnight! !!Time class methodsFor: 'ansi protocol' stamp: 'kph 12/9/2006 10:18'!now	"Answer a Time representing the time right now - this is a 24 hour clock."	| ms |		ms := self milliSecondsSinceMidnight.	^ self seconds:  (ms // 1000) nanoSeconds: (ms \\ 1000) * 1000000! !!Time class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 00:39'!seconds: seconds	"Answer a Time from midnight."	^ self basicNew ticks: (Duration seconds: seconds) ticks! !!Time class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 23:29'!seconds: seconds nanoSeconds: nanoCount	"Answer a Time from midnight."	^ self basicNew		ticks: (Duration seconds: seconds nanoSeconds: nanoCount) ticks! !!Time class methodsFor: 'clock' stamp: 'kph 12/14/2006 01:43'!secondsWhenClockTicks	"waits for the moment when a new second begins"	| lastSecond delay |	delay :=  Delay forMilliseconds: 1.	lastSecond _ self primSecondsClock.	[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ]. 	^ lastSecond + 1! !!TimeTest methodsFor: 'Tests' stamp: 'gk 8/31/2006 00:47'!testSqueakInquiries	| timewords totalseconds condensed corrected |	self assert: 		(self timeClass namesForTimes: #(2 10000023 10000026))			= #('January, 1901' 'April, 1901, 4/26/1901, 5:47 pm' 'April, 1901, 4/26/1901, 5:47 pm').	timewords := #(0.5 30 62 130 4000 10000 60000 86401) 		collect: [ :ss | self timeClass humanWordsForSecondsAgo: ss ].	self assert: 		timewords = #('a second ago' '30 seconds ago' 'a minute ago' '2 minutes ago' 			'an hour ago' '2 hours ago' '16 hours ago' 'yesterday').	totalseconds :=  self timeClass totalSeconds.	condensed := self timeClass condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [:tt | totalseconds - tt]).	corrected := condensed collect: [ :e | totalseconds - e ].	self		assert: (corrected includesAllOf: #(20 400 401 20000 40000 45000 200000)).! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 5/8/2007 13:51'!allClassVarNames	^#()! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/23/2007 11:13'!allSubclasses	^ Array new! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/26/2007 16:51'!classVarNames	^#()! !!TraitBehavior methodsFor: 'class compatibility' stamp: 'dc 7/23/2007 11:13'!subclasses	^ Array new! !!TraitTest methodsFor: 'testing' stamp: 'ms 5/8/2007 19:23'!testAllClassVarNames			self assert: self t1 allClassVarNames isEmpty! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/8/1998 13:12'!open	| openCount |	openCount := 0.	self dependents do:		[:d | ((d isKindOf: PluggableTextView) or:			[d isKindOf: PluggableTextMorph]) ifTrue: [openCount := openCount + 1]].	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window := (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'sma 4/30/2000 10:16'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ (self openAsMorphLabel: aString) openInWorld].	topView := (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView := PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'private' stamp: 'mir 1/11/2000 11:41'!semaphore	^AccessSema ifNil:[AccessSema := Semaphore forMutualExclusion]! !!TranscriptStream class methodsFor: 'as yet unclassified' stamp: 'di 5/8/1998 13:51'!new	^ self on: (String new: 1000)"INSTALLING:TextCollector allInstances do:	[:t | t breakDependents.	t become: TranscriptStream new].TESTING: (Execute this text in a workspace)Do this first...	tt := TranscriptStream new.	tt openLabel: 'Transcript test 1'.Then this will open a second view -- ooooh...	tt openLabel: 'Transcript test 2'.And finally make them do something...	tt clear.	[Sensor anyButtonPressed] whileFalse:		[1 to: 20 do: [:i | tt print: (2 raisedTo: i-1); cr; endEntry]]."! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:44'!endEntry	| c d cb |	c := self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue:		["Handle case of user resizing physical window"		DisplayScreen startUp.		frame := frame intersect: Display boundingBox.		^ self clear; show: c].	para setWithText: c asText		style: TextStyle default		compositionRectangle: ((frame insetBy: 4) withHeight: 9999)		clippingRectangle: frame		foreColor: self black backColor: self white.	d := para compositionRectangle bottom - frame bottom.	d > 0 ifTrue:		["Scroll up to keep all contents visible"		cb := para characterBlockAtPoint: para compositionRectangle topLeft											+ (0@(d+para lineGrid)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit:= position:= collection size.		^ self endEntry].	para display! !!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11'!confirm: queryString 	| choice |	[true]		whileTrue: 			[choice := self request: queryString , 'Please type yes or no followed by return'.			choice first asUppercase = $Y ifTrue: [^ true].			choice first asUppercase = $N ifTrue: [^ false]]! !!Transcripter methodsFor: 'command line' stamp: 'di 11/3/2000 18:52'!readEvalPrint	| line okToRevert |	okToRevert := true.	[#('quit' 'exit' 'done' ) includes: (line := self request: '>')]		whileFalse:		[line = 'revert'		ifTrue: [okToRevert			ifTrue: [Utilities revertLastMethodSubmission.					self cr; show: 'reverted: ' , Utilities mostRecentlySubmittedMessage.					okToRevert := false]			ifFalse: [self cr; show: 'Only one level of revert currently supported']]		ifFalse: [self cr; show: ([Compiler evaluate: line] ifError: [:err :ex | err])]]! !!Transcripter methodsFor: 'command line' stamp: 'sma 2/26/2000 19:39'!request: prompt	| startPos char contents | 	self cr; show: prompt.	startPos := position.	[[Sensor keyboardPressed] whileFalse.	(char := Sensor keyboard) = Character cr]		whileFalse:		[char = Character backspace			ifTrue: [readLimit := position := (position - 1 max: startPos)]			ifFalse: [self nextPut: char].		self endEntry].	contents := self contents.	^ contents copyFrom: startPos + 1 to: contents size! !!Transcripter methodsFor: 'initialization' stamp: 'di 8/14/97 12:44'!initInFrame: rect	frame := rect insetBy: 2.  "Leave room for border"	para := Paragraph withText: self contents asText				style: TextStyle default				compositionRectangle: ((frame insetBy: 4) withHeight: 9999)				clippingRectangle: frame				foreColor: self black backColor: self white! !!Transcripter class methodsFor: 'instance creation' stamp: 'di 8/14/97 12:09'!newInFrame: frame"(Transcripter newInFrame: (0@0 extent: 100@200))	nextPutAll: 'Hello there'; endEntry;	cr; print: 355.0/113; endEntry;	readEvalPrint."	| transcript |	transcript := self on: (String new: 100).	transcript initInFrame: frame.	^ transcript clear! !!Transcripter class methodsFor: 'instance creation' stamp: 'ar 11/16/1999 20:16'!startTranscriptProcess   "Transcripter startTranscriptProcess"	| activeProcess |	Transcript := self newInFrame: Display boundingBox.	activeProcess := [Transcript readEvalPrint.					Smalltalk processShutDownList: true; quitPrimitive]						newProcess					priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive! !!TransformMorph methodsFor: 'geometry' stamp: 'ge 9/6/2006 17:51'!numberOfItemsPotentiallyInViewWith: submorphCount	"Answer the number of items that could potentially be viewed in full,	computed as my visible height divided by the average height of my submorphs.	Ignore visibility of submorphs."	^self innerBounds height // (self localSubmorphBounds height / submorphCount)! !!TransformationMorph methodsFor: 'accessing' stamp: 'wiz 12/7/2006 19:10'!forwardDirection	"Return the rendee's forward direction. 	If I have no rendee then return 0.0 degrees "	| rendee |	( rendee := self renderedMorph) == self  ifTrue: [ ^ 0.0 ] .		^ rendee forwardDirection! !!TransformationMorph methodsFor: 'classification' stamp: 'wiz 12/7/2006 14:05'!renderedMorph"We are a renderer. Answer appropriately."submorphs isEmpty ifTrue: [^self].	^self firstSubmorph renderedMorph! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 19:10'!forwardDirection: degrees "If we have a rendee set its forward direction. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee forwardDirection: degrees! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 12/7/2006 16:30'!heading	"End recusion when necessary."	| rendee |	(rendee := self renderedMorph) == self ifTrue: [ ^0.0 ] .	^ rendee heading! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'wiz 4/18/2007 01:16'!heading: newHeading "If we have a rendee set its heading. Else do nothing." | rendee |( rendee := self renderedMorph) == self ifTrue: [ ^ self  ] .	^rendee heading: newHeading! !!TransformationMorph methodsFor: 'testing' stamp: 'wiz 11/24/2006 00:09'!isStickysubmorphs isEmpty ifFalse: [ ^ 	submorphs first isSticky ] .	^false! !!TypeListTile methodsFor: 'accessing' stamp: 'tak 12/6/2004 02:50'!value: anObject 	| scriptEditor |	super value: anObject.	(scriptEditor := self ownerThatIsA: ScriptEditorMorph)		ifNotNil: [scriptEditor setParameterType: anObject]! !!TypeListTile methodsFor: 'arrows' stamp: 'em 3/29/2005 15:01'!addMenuIcon	"Add a little menu icon; store it in my suffixArrow slot"	suffixArrow := ImageMorph new image: (ScriptingSystem formAtKey: #MenuTriangle).	suffixArrow setBalloonText: 'click here to choose a new type for this parameter' translated.	self addMorphBack: suffixArrow! !!TypeListTile methodsFor: 'mouse handling' stamp: 'tak 12/6/2004 02:43'!showOptions	| topScript |	suffixArrow		ifNotNil: [(suffixArrow bounds containsPoint: ActiveHand cursorPoint)				ifTrue: [^ super showOptions]].	topScript := self				outermostMorphThat: [:m | m isKindOf: ScriptEditorMorph].	topScript		ifNotNil: [topScript handUserParameterTile]! !!TypeListTile methodsFor: 'user interface' stamp: 'sw 7/19/2002 14:48'!acceptNewLiteral: aLiteral	"Accept the new literal"	| scriptEditor |	super acceptNewLiteral: aLiteral.	(scriptEditor := self ownerThatIsA: ScriptEditorMorph) ifNotNil:			[scriptEditor setParameterType: aLiteral asSymbol]! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!addPackageName: name	packageNames add: name! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!ownsPackageName: name	^packageNames includes: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!email: aString	email _ aString! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!password	^password! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!password: anObject	password _ anObject! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!username	^username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!username: anObject	username _ anObject! !!UAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 18:02'!initialize	username _ 'joeblow'.	password _ ''.	packageNames _ Set new.! !!UAccount methodsFor: 'printing' stamp: 'ls 2/15/2005 23:44'!printOn: aStream	aStream nextPutAll: 'Account: ', username! !!UAccount commentStamp: '<historical>' prior: 0!An account as used in the standard UPolicy's.!!UAccountEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:52'!acceptFields	fields do: [ :f | f accept ]! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:40'!morphicView	| win column nameRow submitButton passwordRow password1Row password2Row emailRow submitButtonHolder |	window ifNotNil: [^window].	win := SystemWindow labelled: 'Account Editor'.	win model: self.	column := AlignmentMorph newColumn.	win addMorph: column frame: (0 @ 0 extent: 1 @ 1).	nameRow := UInterfaceUtilities 				makeFieldRowNamed: 'name:'				getSelector: #username				setSelector: nil				isPassword: false				for: self.	column addMorphBack: nameRow.	passwordRow := UInterfaceUtilities 				makeFieldRowNamed: 'password:'				getSelector: #password				setSelector: #password:				isPassword: true				for: self.	column addMorphBack: passwordRow.	password1Row := UInterfaceUtilities 				makeFieldRowNamed: 'new password'				getSelector: #password1				setSelector: #password1:				isPassword: true				for: self.	column addMorphBack: password1Row.	password2Row := UInterfaceUtilities 				makeFieldRowNamed: 'confirm:'				getSelector: #password2				setSelector: #password2:				isPassword: true				for: self.	column addMorphBack: password2Row.	emailRow := UInterfaceUtilities 				makeFieldRowNamed: 'email:'				getSelector: #newEmail				setSelector: #newEmail:				isPassword: false				for: self.	column addMorphBack: emailRow.	submitButtonHolder := Morph new.	"necessary to keep SystemWindow from screwing up the colors of the button"	submitButtonHolder		layoutPolicy: TableLayout new;		hResizing: #spaceFill;		borderColor: self defaultBackgroundColor.	submitButton := UInterfaceUtilities 				makeButtonWithAction: #submit				andLabel: 'Submit'				for: self.	submitButton		useSquareCorners;		borderWidth: 0.	submitButtonHolder addMorph: submitButton.	column addMorphBack: submitButtonHolder.	^window := win! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:38'!openInMorphic	^self morphicView openInWorldExtent:  251@263! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:12'!returnTrue	^true! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:52'!submit	self acceptFields.	newPassword = newPassword2 ifFalse: [		^self inform: 'new passwords do not match!!' ].	whenDone value: password value: newPassword value: newEmail	! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:52'!newEmail	^newEmail! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:53'!newEmail: anObject	newEmail _ anObject! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!password	^password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1	^newPassword! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1: aString	newPassword _ aString asString.	self changed: #password1.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2	^newPassword2! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2: aString	newPassword2 _ aString asString.	self changed: #password2.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 2/13/2005 16:50'!password: aString	password _ aString.	self changed: #password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!username	^username! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 18:01'!window	^window! !!UAccountEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:40'!username: username0  password: password0  email: email0  whenDone: aBlock	username _ username0.	password _ password0.	newPassword _ ''.	newPassword2 _ ''.	newEmail _ email0.	whenDone _ aBlock.! !!UAccountEditor commentStamp: '<historical>' prior: 0!A tool for editing an account!!UAccountEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UAccountEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:41'!username: username0  password: password0  email: email0  whenDone: aBlock	^self basicNew		username: username0  password: password0  email: email0  whenDone: aBlock;		yourself! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:56'!components: anObject	components _ anObject.	components do: [ :c | c addDependent:  self ].! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:50'!standardUniverses	^Array streamContents: [ :str |		components do: [ :comp |			str nextPutAll: comp standardUniverses  ] ]! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:09'!packages	^Array streamContents: [ :pstr |		components do: [ :univ |			pstr nextPutAll: univ packages ] ]! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:58'!updatePackagesViaWWW	components do: [ :component | component updatePackagesViaWWW ]! !!UCompoundUniverse methodsFor: 'updating' stamp: 'ls 2/13/2005 14:57'!update: aSymbol	aSymbol = #packages ifTrue: [ self changed: #packages ].! !!UCompoundUniverse commentStamp: 'ls 7/29/2004 18:48' prior: 0!A universe that is the union of other universes.!!UCompoundUniverse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:47'!composedOf: universes	^self new		components: universes;		yourself! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:19'!includesPackageNamed: name	^self installedPackages anySatisfy: [ :p | p name = name ]! !!UConfiguration methodsFor: 'packages' stamp: 'ls 8/26/2007 12:25'!includesPackageSpec: packageSpec	^self installedPackages anySatisfy: [ :p | p packageSpec = packageSpec ]! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/27/2004 22:02'!installedPackages	^installedPackages! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:18'!packageNamed: name	^self installedPackages detect: [ :p | p name = name ]! !!UConfiguration methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:55'!initialize	installedPackages _ Set new.! !!UConfiguration methodsFor: 'installing' stamp: 'ls 7/27/2004 21:55'!installPackage: aPackage	| matchingPackages |	matchingPackages _ installedPackages select: [ :p | p name = aPackage name ].	installedPackages removeAll: matchingPackages.	aPackage install.	installedPackages add: aPackage.	! !!UConfiguration commentStamp: '<historical>' prior: 0!One configuration of packages.!!UConfiguration class methodsFor: 'system' stamp: 'ls 7/27/2004 21:57'!forSystem	"return a configuration describing the currently running system"	^SystemConfiguration ifNil: [ SystemConfiguration _ self new ].	! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:30'!allCategories	^ (universe packages collect: [:package | package category])			asSet			asSortedCollection: [:cat1 :cat2 | cat1 asString < cat2 asString]! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:38'!allPackages	^ universe packageNames asSortedCollection.! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/22/2007 12:27'!allPossibleUpgrades	^ universe packageNames		inject: OrderedCollection new		into: [ :upgrades :name |			(configuration includesPackageNamed: name)			ifTrue: [| cpack mypack |				cpack := configuration packageNamed: name.				mypack := universe newestPackageNamed: name.				(mypack version > cpack version)					ifTrue: [upgrades add: mypack]].								upgrades].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:39'!installedPackageVersions	^ configuration installedPackages 		asSortedCollection: [:p1 :p2 | p1 name < p2 name].! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:36'!packageVersionsForPackage: aPackageName	^ (universe packages		select: [:package | package name = aPackageName])		asSortedCollection: [:p1 :p2 | p1 version < p2 version].	! !!UGlobalInstaller methodsFor: 'accessing dynamic' stamp: 'dc 4/19/2007 14:37'!packagesForCategory: aCategory	^ (universe packages		select: [:package | package category = aCategory]		thenCollect: [:package | package name])		asSortedCollection ! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'dc 4/21/2007 12:25'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider |	newPackages := Set new.	packagesToConsider := OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ]		whileFalse: [| package |			package := packagesToConsider removeFirst.			(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName |				((configuration includesPackageNamed: depName) not and: [ selectedPackageVersions noneSatisfy: [ :p | p name = depName  ] ])				ifTrue: [					"the dependency is needed but is not installed or planned to be installed"					(universe hasPackageNamed: depName) ifTrue: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (universe newestPackageNamed: depName) ]					ifFalse: [						^errorBlock value: depName ] ] ] ] ].		^newPackages! !!UGlobalInstaller methodsFor: 'private - package selection' stamp: 'dc 4/21/2007 13:13'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^ orderedPackages! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/21/2007 12:43'!anyPackageSelected	^ selectedPackageVersions notEmpty! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/22/2007 12:23'!containsAnyUpgrade	^ self allPossibleUpgrades notEmpty ! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:30'!isPackageInstalled: aPackage	^ self installedPackageVersions anySatisfy: [:packageVersion | packageVersion name =  aPackage]! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:05'!isPackageSelected: aPackageName	^ self selectedPackageVersions		anySatisfy: [:packageVersion | packageVersion name = aPackageName ]! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 4/19/2007 17:29'!isPackageVersionInstalled: aPackageVersion	^ self installedPackageVersions includes: aPackageVersion! !!UGlobalInstaller methodsFor: 'testing' stamp: 'dc 5/28/2007 11:27'!isPackageVersionSelected: aPackageVersion	^ selectedPackageVersions includes: aPackageVersion! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!configuration: aConfiguration 	configuration := aConfiguration! !!UGlobalInstaller methodsFor: 'private' stamp: 'dc 4/19/2007 14:13'!universe: aUniverse 	universe := aUniverse! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:51'!deselectPackageNamed: aPackageName	self selectedPackageVersions 		removeAllSuchThat: [:package | package name = aPackageName ]! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:47'!deselectPackageVersion: aPackageVersion	self selectedPackageVersions 		remove: aPackageVersion  ifAbsent: nil! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 13:15'!doInstall	| orderedPackages |	self anyPackageSelected not ifTrue: [^self].	orderedPackages := self orderPackagesByDependency: selectedPackageVersions.	orderedPackages		do: [ :p | 				Utilities informUser: 'installing ', p printString						during: [configuration installPackage: p] ].	self initializeSelectedPackageVersions.! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 12:20'!planToInstallPackage: initialPackage	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	| newPackages |	"find all packages needed to install this one"	newPackages := self allPackagesNeededToInstall: initialPackage						orIfImpossible: [ :missingDep |								^self notify: 'could not find necessary package: ', missingDep ].		selectedPackageVersions removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | selectedPackageVersions add: p ].! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:54'!planToInstallPackageNamed: aPackageName	self planToInstallPackage: (universe newestPackageNamed: aPackageName)! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/21/2007 15:01'!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UGlobalInstaller methodsFor: 'actions' stamp: 'dc 4/22/2007 12:27'!selectAllUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self allPossibleUpgrades 		do: [:package | self planToInstallPackage: package]! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initialize	super initialize.	self initializeSelectedPackageVersions! !!UGlobalInstaller methodsFor: 'initialize-release' stamp: 'dc 4/21/2007 13:12'!initializeSelectedPackageVersions	selectedPackageVersions := Set new! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'dc 4/21/2007 12:41'!selectedPackageVersions	^ selectedPackageVersions! !!UGlobalInstaller methodsFor: 'accessing' stamp: 'ls 6/3/2007 10:34'!universe	^universe! !!UGlobalInstaller commentStamp: 'dc 7/24/2007 11:43' prior: 0!I'm used by universe browsers to keep track of the configuration, the universe, the selected packages... I provide features to install new packages, to upgrade the system...!!UGlobalInstaller class methodsFor: 'instance-creation' stamp: 'dc 4/19/2007 14:11'!universe: aUniverse	^ self universe: aUniverse configuration: UConfiguration forSystem ! !!UGlobalInstaller class methodsFor: 'instance-creation' stamp: 'dc 4/19/2007 14:12'!universe: aUniverse configuration: aConfiguration	^ self new		universe: aUniverse;		configuration: aConfiguration;		yourself! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 1/16/2005 14:11'!setUp	| package |	universe _ UStandardUniverse new.		package _ UPackage new.	package name: 'A'.	package addDependency: 'B'.	universe addPackage: package.		package _ UPackage new.	package name: 'B'.	package addDependency: 'C'.	universe addPackage: package.		package _ UPackage new.	package name: 'C'.	package addDependency: 'D'.	package addDependency: 'E'.	universe addPackage: package.		package _ UPackage new.	package name: 'D'.	universe addPackage: package.		package _ UPackage new.	package name: 'E'.	universe addPackage: package.	package _ UPackage new.	package name: 'Broken'.	package addDependency: 'NonExistent'.	universe addPackage: package.	! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 8/14/2007 21:41'!testBasicDependency	| installer neededPackages |	installer := UGlobalInstaller universe: universe.	neededPackages := installer 				allPackagesNeededToInstall: (universe newestPackageNamed: 'A')				orIfImpossible: [:ign | self error: 'dependency not found'].	self should: [neededPackages size = 5].			installer := UGlobalInstaller universe: universe.	neededPackages := installer 				allPackagesNeededToInstall: (universe newestPackageNamed: 'B')				orIfImpossible: [:ign | self error: 'dependency not found'].	self should: [neededPackages size = 4]! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 8/14/2007 21:42'!testBrokenDependency	| installer neededPackages |	installer := UGlobalInstaller universe: universe.	neededPackages _ installer allPackagesNeededToInstall: (universe newestPackageNamed: 'Broken')  orIfImpossible: [ :ign | nil ].	self should: [ neededPackages isNil ].	! !!UIFileOut methodsFor: 'testing' stamp: 'ls 9/4/2004 14:02'!handlesFilename: filename	^#('.cs' '.st' '.st.gz' '.cs.gz') anySatisfy: [ :ending | filename endsWith: ending ]! !!UIFileOut methodsFor: 'installing' stamp: 'ls 7/29/2004 20:01'!install: inStream  usingBaseName: basename	"find a changeset name that is not used"	| num changesetName stream |	num _ 0.	[  	changesetName _ basename.	   	num > 0 ifTrue:[ changesetName _ changesetName, '-', num printString. ].		(ChangeSorter changeSetNamed: changesetName) notNil ]	whileTrue: [ num _ num + 1 ].		"decompress if necessary"	inStream peek asInteger = 16r1F		ifTrue: [ stream _ ReadStream on: ((GZipReadStream on: inStream) upToEnd) asString ]		ifFalse: [ stream _ inStream ].			ChangeSorter newChangesFromStream: stream named: changesetName! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:45'!handlesFileEnding: ending	ending = 'mcz' ifTrue: [ ^true ].	(ending = 'mcm' and: [ self isMCMReaderAvailable ]) ifTrue: [ ^true ].	^false! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:44'!isMCMReaderAvailable	^ Smalltalk includesKey: self mcmReaderClassName! !!UIMonticello methodsFor: 'testing' stamp: 'ls 8/19/2007 12:44'!mcmReaderClassName	^ #MCMcmReader! !!UIMonticello methodsFor: 'installing' stamp: 'ls 8/19/2007 12:47'!installFileNamed: filename 	(filename asLowercase endsWith: '.mcm') 		ifTrue: [^ self mcmReader loadVersionFile: filename].	Smalltalk at: #MCMczReader		ifPresent: [:reader | ^ reader loadVersionFile: filename].	MczInstaller installFileNamed: filename! !!UIMonticello methodsFor: 'installing' stamp: 'ls 8/19/2007 12:46'!mcmReader	^ Smalltalk at: self mcmReaderClassName! !!UIMpeg methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('mpg' 'mpeg') includes: ending! !!UIMpeg methodsFor: 'installing' stamp: 'ls 7/29/2004 11:39'!install: stream usingBasename: basename	| movieDir movieFile |	movieDir := FileDirectory default directoryNamed: 'movies'.	movieDir assureExistence.		movieDir removeFileNamed: basename.		movieFile _ movieDir newFileNamed: basename, '.mpeg'.	stream binary.  movieFile binary.	movieFile nextPutAll: stream upToEnd.	movieFile close.		Smalltalk at: #MPEGMoviePlayerMorph ifPresent: [ :player |		player playFile: (movieDir fullNameFor: basename, '.mpeg') ]! !!UIProject methodsFor: 'testing' stamp: 'ls 7/29/2004 11:05'!handlesFileEnding: ending	^#('pr') includes: ending! !!UIProject methodsFor: 'installing' stamp: 'ls 9/18/2004 18:18'!installFileNamed: filename	FileDirectory splitName: filename to: [ :path :base |		[ 				ProjectViewMorph openFromDirectory: (FileDirectory on: path) andFileName: base		] on: ProjectEntryNotification do:		[ :ex |			"don't enter it" ] ]! !!UISar methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('sar') includes: ending! !!UISar methodsFor: 'installing' stamp: 'ls 7/29/2004 11:44'!installFileNamed: filename	SARInstaller installSAR: filename! !!UInterfaceUtilities commentStamp: 'ls 2/13/2005 17:22' prior: 0!This class holds miscellaneous bits of code used to build user interfaces in the various Universes tools.!!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString for: model	^(PluggableButtonMorph on: model getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: model defaultBackgroundColor offColor: model defaultBackgroundColor muchLighter;		yourself! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:41'!makeButtonWithAction: selector  andLabel: aString for: model	^self makeButtonWithAction: selector andGetState: #returnTrue  andLabel: aString	for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:34'!makeFieldGet: getSelector  set: setSelector  for: model	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: model text: getSelector accept: setSelector.	field height: fieldHeight.	field hResizing: #spaceFill.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.	model noteField: field.	^field! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:42'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector for: model	^self makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: false for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:36'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: isPassword for: model	| row field |	row _ AlignmentMorph newRow.	row color: Color transparent.	row cellInset: 3@0.		field _ self makeFieldGet: getSelector set: setSelector for: model.	isPassword ifTrue:[		field font: (StrikeFont passwordFontSize: TextStyle default defaultFont pointSize) ].	row addMorph: (StringMorph contents: fieldName).	row addMorphBack: field.	^row! !!UMAddAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 21:46'!applyToServer: server forConnection: connection	server connection: connection requestedAccountWithUsername: username password: password email: email! !!UMAddAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:34'!asStringArray	^{'addaccount' . username . password . email}! !!UMAddAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:33'!username: username0  password: password0  email: email0	username _ username0.	password _ password0.	email _ email0.	! !!UMAddAccount methodsFor: 'logging' stamp: 'ls 5/28/2007 17:24'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'AddAccount ', username, ' ', email! !!UMAddAccount commentStamp: '<historical>' prior: 0!A request to add a user account.!!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!fromStringArray: stringArray	^self username: stringArray second password: stringArray third email: stringArray fourth! !!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!username: username  password: password  email: email	^self basicNew username: username  password: password  email: email! !!UMAddPackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:03'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toAddPackage: package! !!UMAddPackage methodsFor: 'converting' stamp: 'ls 7/28/2004 16:56'!asStringArray	^{'addpackage' . username . password },	  package stringArrayEncoding! !!UMAddPackage methodsFor: 'printing' stamp: 'ls 1/13/2007 21:24'!printOn: aStream	aStream 		print: self class;		nextPutAll: ' (';		print: package;		nextPutAll: ')'! !!UMAddPackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:37'!username: username0 password: password0 package: package0	username _ username0.	password _ password0.	package _ package0.	! !!UMAddPackage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:43'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'AddPackage ', username, ' ', package name, '/', package version printString! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:07'!fromStringArray: array	^self username: array second password: array third package: (UPackage decodeFromStringStream: (ReadStream on: (array allButFirst: 3)))! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:37'!username: username password: password package: package	^self basicNew username: username password: password package: package! !!UMConnectionFailed commentStamp: '<historical>' prior: 0!An error in establishing a connection to a server.!!UMEditAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:55'!applyToServer: server forConnection: connection	server connection: connection requestedAccountChangeForUsername: username password: password newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:36'!asStringArray	^{'editaccount' . username . password . newPassword . newEmail}! !!UMEditAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:36'!username: username0  password: password0  newPassword: newPassword0 newEmail: newEmail0	username _ username0.	password _ password0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMEditAccount commentStamp: '<historical>' prior: 0!A request to change the password or email of an account.!!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:38'!fromStringArray: array	^self username: array second password: array third newPassword: array fourth newEmail: array fifth! !!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:36'!username: username  password: password  newPassword: newPassword newEmail: newEmail	^self basicNew username: username  password: password  newPassword: newPassword newEmail: newEmail! !!UMEditedAccount methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 17:59'!applyToEditor: editor	editor accountUpdatedWithUsername: username  password:  newPassword  email: newEmail! !!UMEditedAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 17:37'!asStringArray	^{'editedaccount' . username . newPassword . newEmail }! !!UMEditedAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:36'!username: username0  newPassword: newPassword0  newEmail: newEmail0	username _ username0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMEditedAccount commentStamp: '<historical>' prior: 0!Notification that an account has been successfully edited.!!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:38'!fromStringArray: array	^self username: array second newPassword: array third newEmail: array fourth! !!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:37'!username: username  newPassword: newPassword  newEmail: newEmail	^self basicNew		username: username  newPassword: newPassword  newEmail: newEmail;		yourself! !!UMError methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 21:58'!applyToEditor: editor	"the inform: is deferred, because otherwise the editor can stop stepping!!"	WorldState addDeferredUIMessage: [ editor inform: 'Error: ', description ]! !!UMError methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:35'!applyToServer: server forConnection: connection	"if the client sends an error back, then the connection is really messed up"	server destroyConnection: connection	! !!UMError methodsFor: 'converting' stamp: 'ls 7/28/2004 13:36'!asStringArray	^{'error' . description }! !!UMError methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 13:26'!description: aString	description := aString! !!UMError commentStamp: '<historical>' prior: 0!An error message from the server to the client.!!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 13:33'!description: aString	^self basicNew		description: aString;		yourself! !!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:02'!fromStringArray: array	^self description: array second! !!UMMalformed methodsFor: 'converting' stamp: 'ls 7/28/2004 11:31'!asStringArray	^self error: 'a malformed packet cannot be converted to a string array'! !!UMMalformed methodsFor: 'accessing' stamp: 'ls 7/28/2004 11:45'!stringArray: anObject	stringArray _ anObject! !!UMMalformed commentStamp: '<historical>' prior: 0!a malformed packet!!UMMalformed class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:30'!fromStringArray: array	^self basicNew stringArray: array; yourself! !!UMPackageAdded methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient packageAdded: package! !!UMPackageAdded methodsFor: '*universes-editor' stamp: 'ls 7/30/2004 15:38'!applyToEditor: editor	editor closeEditorForPackage: package.! !!UMPackageAdded methodsFor: 'converting' stamp: 'ls 7/28/2004 15:07'!asStringArray	^#('packageadded'), package stringArrayEncoding! !!UMPackageAdded methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:59'!package: aPackage	package _ aPackage! !!UMPackageAdded commentStamp: 'ls 7/28/2004 15:08' prior: 0!A message declaring that a package has been added to the universe.!!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!fromStringArray: array	| str |	str _ ReadStream on: array.	str next.	^self package: (UPackage decodeFromStringStream: str)! !!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!package: aPackage	^self basicNew		package: aPackage;		yourself! !!UMPackageList methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient newPackageList: packages! !!UMPackageList methodsFor: 'converting' stamp: 'ls 7/28/2004 15:04'!asStringArray	^Array streamContents: [ :str |		str nextPut: 'packages'.		str nextPut: packages size printString.		packages do: [ :pack |			str nextPutAll: pack stringArrayEncoding ]. ].! !!UMPackageList methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	packages _ aCollection! !!UMPackageList commentStamp: '<historical>' prior: 0!A message describing a list of packages that are in the server's universe.!!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:05'!fromStringArray: array	| str packages numPackages |	str _ ReadStream on: array.	str next.  "skip the 'packages' designation".	packages _ OrderedCollection new.	numPackages _ Integer readFromString: str next.	numPackages timesRepeat: [		packages add: (UPackage decodeFromStringStream: str) ].			^self packages: packages! !!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	^self basicNew		packages: aCollection;		yourself! !!UMPackageRemoved methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:02'!applyToClient: aClient	aClient removedPackageNamed: packageName  withVersion: version! !!UMPackageRemoved methodsFor: 'converting' stamp: 'ls 7/28/2004 14:57'!asStringArray	^{'packageremoved' . packageName . version printString }! !!UMPackageRemoved methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:57'!packageName: aString  version: aVersion	packageName _ aString.	version _ aVersion.! !!UMPackageRemoved commentStamp: '<historical>' prior: 0!A message claiming that a package has been removed.!!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!fromStringArray: array	^self packageName: array second version: (UVersion readFromString: array third)! !!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!packageName: aString version: aVersion	^self basicNew		packageName: aString version: aVersion;		yourself! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToClient: client! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToEditor: editor! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToMultiServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'converting' stamp: 'ls 2/15/2005 21:41'!asStringArray	^{'protocolversion' . version asString}! !!UMProtocolVersion methodsFor: 'attributes' stamp: 'ls 2/15/2005 21:40'!version	^version! !!UMProtocolVersion methodsFor: 'initialize-release' stamp: 'ls 2/15/2005 21:39'!version: anInteger	version _ anInteger! !!UMProtocolVersion commentStamp: '<historical>' prior: 0!Tell the receiver what protocol version the sender understands.  The receiver should not send messages back which use a newer protocol version.!!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!fromStringArray: array	^self version: (Integer readFromString: array second)! !!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!version: anInteger	^self new version: anInteger; yourself! !!UMRemovePackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:20'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toRemovePackageNamed: packageName withVersion: packageVersion! !!UMRemovePackage methodsFor: 'converting' stamp: 'ls 7/29/2004 15:46'!asStringArray	^{'removepackage' . username . password . packageName . packageVersion printString }! !!UMRemovePackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:39'!username: username0 password: password0 packageName: packageName0 packageVersion: packageVersion0	username _ username0.	password _ password0.	packageName _ packageName0.	packageVersion _ packageVersion0.	! !!UMRemovePackage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:43'!maybeLogMessage	"Return a string for logging this message, if there is one"	^'RemovePackage ', username, ' ', packageName, '/', packageVersion printString! !!UMRemovePackage commentStamp: '<historical>' prior: 0!A request to remove a package from a universe.!!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:26'!fromStringArray: array	^self username: array second password: array third packageName: array fourth packageVersion: (UVersion readFromString: array fifth)! !!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:41'!username: username password: password packageName: packageName packageVersion: packageVersion	^self basicNew username: username password: password packageName: packageName packageVersion: packageVersion! !!UMRequestPackages methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:08'!applyToServer: server forConnection: connection	connection nextPut: (UMPackageList packages: server universe packages) asStringArray! !!UMRequestPackages methodsFor: 'converting' stamp: 'ls 7/28/2004 11:59'!asStringArray	^#('requestpackages')! !!UMRequestPackages commentStamp: '<historical>' prior: 0!A package requesting that a copy of all packages in the server's universe.!!UMRequestPackages class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:59'!fromStringArray: array	^self basicNew! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server forConnection: connection	server switchConnection: connection toServerNamed: shortName! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 8/26/2007 12:05'!applyToServer: server forConnection: connection	"do nothing"! !!UMSelectServer methodsFor: 'converting' stamp: 'ls 2/13/2005 16:06'!asStringArray	^{'selectserver' . shortName}! !!UMSelectServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 16:12'!shortName: aString	shortName _ aString! !!UMSelectServer commentStamp: 'ls 2/13/2005 16:05' prior: 0!A request to a multi-server, to select the server for a specific universe.  Subsequent messages should be directed to the selected universe instead of to the specific universes.!!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!fromStringArray: stringArray	^self shortName: stringArray second! !!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!shortName: aString	^self new		shortName: aString;		yourself! !!UMessage methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:00'!applyToClient: aClient	"apply this message to a UUniverseClient"	! !!UMessage methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 15:40'!applyToEditor: editor	! !!UMessage methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server  forConnection: connection	connection nextPut: (UMError description: 'message inappropriate for multi-server') asStringArray! !!UMessage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:25'!applyToServer: server  forConnection: connectionself inspect.	connection nextPut: (UMError description: 'message inappropriate for server') asStringArray! !!UMessage methodsFor: 'converting' stamp: 'ls 7/28/2004 11:30'!asStringArray	^self subclassResponsibility! !!UMessage methodsFor: 'logging' stamp: 'ls 5/28/2007 17:22'!maybeLogMessage	"Return a string for logging this message, if there is one"	^nil! !!UMessage commentStamp: '<historical>' prior: 0!A message that can be sent to or from a UServer.  All instances may be converted to an array of strings, and that array of strings may be parsed back with fromStringArray:.!!UMessage class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:41'!fromStringArray: array	| class |	class _ nil.	array first = 'requestpackages' ifTrue: [ class _ UMRequestPackages ].	array first = 'packages' ifTrue: [ class _ UMPackageList ].	array first = 'error' ifTrue: [ class _ UMError ].	array first = 'addaccount' ifTrue: [ class _ UMAddAccount ].	array first = 'addpackage' ifTrue: [ class _ UMAddPackage ].	array first = 'editaccount' ifTrue: [ class _ UMEditAccount ].	array first = 'editedaccount' ifTrue: [ class _ UMEditedAccount ].	array first = 'packageadded' ifTrue: [ class _ UMPackageAdded ].	array first = 'packageremoved' ifTrue: [ class _ UMPackageRemoved ].	array first = 'removepackage' ifTrue: [ class _ UMRemovePackage ].	array first = 'selectserver' ifTrue: [ class _ UMSelectServer ].	array first = 'protocolversion' ifTrue: [ class _ UMProtocolVersion ].	class ifNil: [			^UMMalformed fromStringArray: array ].		^[ class fromStringArray: array ] on: Error do: [ :ex | UMMalformed fromStringArray: array ]! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:33'!destroy	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:34'!isConnected	^hasBeenWritten not! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!nextOrNil	hasBeenRead ifTrue:[ ^nil ].	hasBeenRead _ true.	^inputMessage! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:53'!nextPut: anObject	outputQueue nextPut: anObject.	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!processIO! !!UOneShotConnection methodsFor: 'initialize-release' stamp: 'ls 8/2/2004 16:33'!initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue	inputMessage _ inMessage0.	outputQueue _ aSharedQueue.	hasBeenRead _ false.	hasBeenWritten _ false.! !!UOneShotConnection commentStamp: '<historical>' prior: 0!A fake StringSocket used to integrate a UUniverseServer with an HTTP server.A OneShotConnection has exactly one input message and only accepts one output message.  It puts the supplied output message onto a SharedQueue and then disconnects itself.!!UOneShotConnection class methodsFor: 'instance creation' stamp: 'ls 8/2/2004 16:31'!withInMessage: inMessage0  andOutQueue: aSharedQueue	^self basicNew		initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue;		yourself! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59'!addUser: user withPassword: password andEmail: email	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 3/11/2007 00:04'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	"the changes must be made on the server, not over the standard protocol"	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!package: package mayBeAddedBy: user withPassword: password	^(user = masterUser and: [ password = masterPassword ])		ifTrue: [ UPolicyResponse allowed ]		ifFalse: [ UPolicyResponse denied ]! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	(user = masterUser and: [ password = masterPassword ])		ifTrue: [ ^UPolicyResponse allowed ]		ifFalse: [ ^UPolicyResponse denied ]! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterPassword: password	masterPassword _ password! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterUser: userName	masterUser _ userName! !!UPStable commentStamp: '<historical>' prior: 0!A policy somewhat suitable for stable versions.  All updates must come through a single master userid and password.!!UPWild methodsFor: 'policies' stamp: 'ls 5/13/2007 10:04'!addUser: username withPassword: password  andEmail: email	| newAccount |	(accounts anySatisfy: [ :acc | acc username = username]) ifTrue: [		"already an account here"		^UPolicyResponse denied: 'account already exists' ].	superUser ifNotNil: [		superUser username = username ifTrue: [			"cannot create an account with the superuser's name"			^UPolicyResponse denied: 'same account name as the superuser' ] ].			(self class isReasonableUsername: username) ifFalse: [		^UPolicyResponse denied: 'invalid account name' ].		newAccount _ UAccount new.	newAccount username: username.	newAccount password: password.	newAccount email: email.		accounts add: newAccount.	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 2/13/2005 16:38'!changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail	| account |	account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'username not present or password does not match' ].		newPassword isEmpty ifFalse: [account password: newPassword ].	newEmail isEmpty ifFalse: [account email: newEmail ].	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 21:34'!package: aPackage  mayBeAddedBy: username  withPassword: password	^self tryToGivePackageName: aPackage name toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:15'!packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password	^self tryToGivePackageName: packageName toUsername: username withPassword: password! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 21:35'!initialize	accounts _ OrderedCollection new! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 4/14/2007 18:39'!superUser: anAccount	superUser ifNotNil: [		accounts remove: superUser ].	superUser := anAccount.	accounts add: superUser.	! !!UPWild methodsFor: 'account assignment' stamp: 'ls 7/28/2004 18:14'!findAccount: username withPassword: password	| account |	account _ accounts detect: [ :acc | acc username = username] ifNone: [		"no such account"		^nil ].		account password = password ifFalse:[		"wrong password"		^nil ].		^account! !!UPWild methodsFor: 'account assignment' stamp: 'ls 4/14/2007 18:40'!tryToGivePackageName: packageName toUsername: username  withPassword: password	| account |	(self class isReasonablePackageName: packageName) ifFalse: [		^UPolicyResponse denied: 'invalid package name' ].		account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'incorrect password or no such user' ].	account == superUser ifTrue: [		^UPolicyResponse allowed ].	(account ownsPackageName: packageName) ifTrue: [		^UPolicyResponse allowed ].		(accounts anySatisfy: [ :acc | acc ownsPackageName: packageName ]) ifTrue: [		^UPolicyResponse denied: 'package is owned by another' ].		account addPackageName: packageName.	^UPolicyResponse allowed! !!UPWild commentStamp: 'ls 4/14/2007 18:34' prior: 0!This is the wild-n-wooly policy.  Anyone may create a new account, and the first person to try to add or remove a package with a given name comes to exclusively own that package name.  Only the owner of a package name may make changes to packages with that name.As an exception, the supuser/suppassword may be used to change any package.  This is intended to allow a universe manager to override decisions made by package owners.!!UPWild class methodsFor: 'reasonable names' stamp: 'ls 7/29/2004 16:51'!isReasonablePackageName: aString	^aString allSatisfy: [ :c | c isAlphaNumeric or: [ ' -.' includes: c ]]! !!UPWild class methodsFor: 'reasonable names' stamp: 'ls 2/15/2005 23:45'!isReasonableUsername: aString	^aString isEmpty not and: [ aString allSatisfy: [ :c | c isAlphaNumeric ] ]! !!UPackage methodsFor: 'comparing' stamp: 'ls 8/26/2007 11:39'!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self category = anotherPackage category ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self squeakMapID = anotherPackage squeakMapID ifFalse: [ ^false ].	self url asString = anotherPackage url asString ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage toText = anotherPackage homepage toText]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'comparing' stamp: 'ls 7/28/2004 09:58'!hash	^self name hash bitXor: self version hash! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:34'!isUPackage	^true! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:19'!addDependency: aString	depends add: aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 11:10'!category: aPackageCategory	category := aPackageCategory! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 1/13/2007 14:41'!categoryString: aString	self category: (UPackageCategory readFromString: aString).! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 15:39'!depends: aCollection	depends _ Set withAll: aCollection! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!description: aString	description _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:20'!homepage: aURL	homepage _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/5/2007 12:28'!initialize	name := '(unnamed package)'.	version := UVersion readFromString: '0'.	category := self defaultCategory.	depends := Set new.	provides := Set new.	description := ''.	url := nil.	homepage := nil.	maintainer := ''! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:32'!maintainer: aString	maintainer _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!name: aString	name _ aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27'!provides: aCollection	provides _ Set withAll: aCollection! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 8/26/2007 11:38'!squeakMapID: aUUID 	squeakMapID := aUUID! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:18'!url: aURL	url _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!version: aVersion	version _ aVersion.	! !!UPackage methodsFor: 'accessing' stamp: 'ls 11/26/2006 10:54'!category	^ category ifNil: [self defaultCategory]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!depends	^depends! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!description	^description! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05'!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33'!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!name	^name! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 09:18'!packageSpec	^UPackageSpec name: name version: version! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29'!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 8/26/2007 11:37'!squeakMapID	^ squeakMapID! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30'!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32'!version	^version! !!UPackage methodsFor: 'miscellania' stamp: 'ls 11/26/2006 11:07'!defaultCategory	^ UPackageCategory withComponents: #('Uncategorized' )! !!UPackage methodsFor: 'installing' stamp: 'ls 5/13/2007 18:10'!cachedCopyFilename	"Download the package to a local cache, if it is not already in the cache.  Return the filename of the file in the cache.  If the package has no URL, download nothing and return nil."	| filename doc file downloadDir |	self url ifNil: [ ^nil ].		downloadDir _ FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename _ self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc _ url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file _ downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].	^ (downloadDir fullNameFor: filename).! !!UPackage methodsFor: 'installing' stamp: 'dc 7/24/2007 11:40'!install	self url ifNil: [^ self].	UPackageInstaller installFileNamed: self cachedCopyFilename! !!UPackage methodsFor: 'testing' stamp: 'ls 12/31/2006 16:11'!isPackageCategory	^false! !!UPackage methodsFor: 'printing' stamp: 'ls 8/31/2007 12:25'!longDescription	^Text streamContents: [ :str |		str nextPutAll: self description; cr; cr.		str nextPutAll: 'Category: '; print: self category; cr.		self provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self  depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self  depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self  maintainer); cr.		str nextPutAll: 'Downloads from: '.		self  url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self  url asString ].		str cr.		self  homepage ifNotNil: [			str nextPutAll: 'Homepage: '.			str nextPutAll: (Text string: self homepage asString attribute: (TextURL new url: self homepage asString)).			str cr].		self squeakMapID ifNotNil: [			| smurl |			str nextPutAll: 'SqueakMap UUID: ', self squeakMapID asString, String cr.			smurl := 'http://map.squeak.org/package/', self squeakMapID asString.			str nextPutAll: (Text string: '[browse SqueakMap web page]' attribute: (TextURL new url: smurl)).			str cr.						str nextPutAll: (Text string: '[open SqueakMap browser]' attribute: (TextDoIt evalString: 'USqueakMapUtil browsePackageID: (UUID fromString: ''', self squeakMapID asString, ''')')).			str cr.			]. ] .! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackage methodsFor: 'serializing' stamp: 'ls 2/13/2005 13:29'!printXMLPackageList: names on: stream	names do: [ :n |		stream nextPutAll: ' <packagename>'; nextPutAll: n escapeEntities; nextPutAll: '</packagename>' ].! !!UPackage methodsFor: 'serializing' stamp: 'ls 8/26/2007 11:40'!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<category>'; print: self category; nextPutAll: '</category>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr.		self url ifNotNil: [			str nextPutAll: '<url>'; nextPutAll: self url toText escapeEntities; nextPutAll: '</url>'; cr ].		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage toText escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		squeakMapID ifNotNil: [			str nextPutAll: '<squeakMapID>'.			str nextPutAll: squeakMapID asString.			str nextPutAll: '</squeakMapID>'.			].		str nextPutAll: '</package>'; cr. ]! !!UPackage methodsFor: '*universes-messages' stamp: 'ls 8/26/2007 11:46'!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: (self url ifNil: [ '(no download url)' ] ifNotNil: [ self url toText ]);			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage toText ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: 0 printString;  "legacy conflicts field"			nextPut: self category printString;			nextPut: (self squeakMapID ifNil: [''] ifNotNil: [self squeakMapID asString])].! !!UPackage commentStamp: 'ls 7/27/2004 21:20' prior: 0!One release of one package.!!UPackage class methodsFor: '*universes-messages' stamp: 'ls 8/26/2007 12:01'!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts urlString |	package _ self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	urlString := str next.	(urlString withBlanksTrimmed beginsWith: '(') ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [			package url: (Url absoluteFromText: urlString) ] ].	homePageText _ str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides _ Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends _ Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts _ Integer readFromString: str next. 	str next: numConflicts.  "skip them"	str atEnd ifFalse: [		package category: (UPackageCategory readFromString: str next)].		str atEnd ifFalse: [		| idstr |		idstr := str next.		idstr isEmpty ifFalse: [			package squeakMapID:  (UUID fromString: idstr) ].		].		^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 8/26/2007 12:01'!decodeFromXMLElement: doc	| package urlString |	package _ self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	urlString _ self getXMLPartNamed: 'url' from: doc.	urlString isEmpty ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [	 		package url: (Url absoluteFromText: urlString). ] ].	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	(doc elementAt: 'category') ifNotNil: [		package category: (UPackageCategory readFromString: (self getXMLPartNamed: 'category' from: doc ))].	(doc elementAt: 'squeakMapID') ifNotNil: [		| idstr |		idstr := self getXMLPartNamed: 'squeakMapID' from: doc.		idstr isEmpty ifFalse: [			package squeakMapID: (UUID fromString: idstr)]].	^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:24'!decodePackagesFromXMLStream: stream	| doc |	doc _ XMLDOMParser parseDocumentFrom: stream.	^doc elements collect: [ :element | self decodeFromXMLElement: element ].! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:12'!getXMLPackageList: listname from: element	| listElement |	listElement _ element elementAt: listname.	listElement ifNil: [ ^#() ].	^listElement elements collect: [ :nameXML |		nameXML contents first string ]! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/2/2007 15:00'!getXMLPartNamed: partName  from: xmlDoc	| element |	element _ xmlDoc elementAt: partName.	(element isNil or: [ element contents isEmpty ]) ifTrue:[ ^ '' ].	^element contents first string! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:41'!readPackageListFromFileNamed: filename	| file packages |	file _ FileStream readOnlyFileNamed: filename.	packages _ self decodePackagesFromXMLStream: file.	file close.	^packages! !!UPackage class methodsFor: 'saving' stamp: 'ls 2/13/2005 14:47'!savePackageList: packageList  onFileNamed: filename	| tmpName file |	tmpName _ filename, 'tmp'.	FileDirectory default deleteFileNamed: tmpName ifAbsent:  [].	file _ FileStream fileNamed: tmpName.	packageList do: [ :package |		file nextPutAll: package xmlForExport ].	file close.	FileDirectory default rename: tmpName toBe: filename.! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 12/31/2006 16:10'!= aCategory	^aCategory isPackageCategory and: [		components = aCategory components ]! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06'!hash	^components hash! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^true! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05'!components	^components! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize	components := #()! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize: anArrayOfStrings	components := anArrayOfStrings! !!UPackageCategory methodsFor: 'testing' stamp: 'ls 12/31/2006 16:10'!isPackageCategory	^true! !!UPackageCategory methodsFor: 'subcategories' stamp: 'ls 11/26/2006 12:20'!isSubcategoryOf: prefix	components isEmpty ifTrue: [ ^false ].	^components allButLast = prefix components! !!UPackageCategory methodsFor: 'printing' stamp: 'ls 11/26/2006 11:04'!printOn: aStream	components do: [ :comp |		aStream nextPutAll: comp ]	separatedBy: [ aStream nextPut: $/ ]! !!UPackageCategory commentStamp: 'ls 11/26/2006 10:59' prior: 0!A category for a package.!!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:03'!readFrom: aStream	"[UPackageCategory readFromString: 'Core/Umbrella Packages']"	| comps nextComp |	comps := OrderedCollection new.	[aStream atEnd] whileFalse: [		nextComp := (aStream upTo: $/) withBlanksTrimmed.		nextComp isEmpty ifFalse: [			comps add: nextComp ] ].		^self withComponents: comps! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 12:21'!root	^self withComponents: #()! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:05'!withComponents: anArrayOfStrings	^self basicNew initialize: (Array withAll: anArrayOfStrings)! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:41'!acceptFields	fields do: [ :f | f accept ]! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:30'!guessSqueakMapID	| squeakmap map smpackage |	self acceptFields.	squeakmap := Smalltalk at: #SMSqueakMap ifAbsent: [		^self inform: 'SqueakMap not loaded, cannot guess'].	map := squeakmap default.	smpackage := map packages detect: [ :smp | smp name = self packageName ] ifNone: [		^self inform: 'could not find a SqueakMap package named ', self packageName].	self smidString: smpackage id asString	! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:34'!makeFieldGet: getSelector  set: setSelector	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: self text: getSelector accept: setSelector.	field extent: 200@fieldHeight.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.		fields ifNil: [ fields _ OrderedCollection new].	fields add: field.		^field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:25'!makeGuessSMIDButton	^(UInterfaceUtilities makeButtonWithAction: #guessSqueakMapID  andLabel: 'guess' for: self)		hResizing: #shrinkWrap! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:24'!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow maintainerRow categoryRow smidRow |	window ifNotNil: [ ^window ].	win _ SystemWindow labelled: 'Package Editor'.	win model: self.	column _ AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow _ UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		categoryRow _ UInterfaceUtilities makeFieldRowNamed: 'category:' getSelector: #categoryString setSelector: #categoryString: for: self.	column addMorphBack: categoryRow.		maintainerRow _ UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: maintainerRow.		homepageRow _ UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.		smidRow _ UInterfaceUtilities makeFieldRowNamed: 'SqueakMap ID:' getSelector: #smidString setSelector: #smidString: for: self.	smidRow addMorphBack: self makeGuessSMIDButton.	column addMorphBack: smidRow.			urlRow _ UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow _ UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow _ UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField _ self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton _ UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window _ win! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:21'!openInMorphic	^self morphicView openInWorldExtent:  592@557! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:05'!returnTrue	^true! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:43'!submit	self acceptFields.	whenComplete value: package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 11/26/2006 11:22'!categoryString	^package category printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 1/13/2007 14:41'!categoryString: aText 	package categoryString: aText asString.	self changed: #categoryString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!dependsString	^self stringForPackageNames: package depends! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!dependsString: aString 	package depends: (self packageNamesFromString: aString).	self changed: #dependsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:40'!description	^package description! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:41'!description: aString	package description: aString asString.	self changed: #description.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!homepageString	^package homepage		ifNil: [ '' ]		ifNotNil: [ package homepage toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:01'!homepageString: newHomePage	newHomePage asString = ''		ifTrue: [ package homepage: nil ]		ifFalse: [ package homepage: (Url absoluteFromText: newHomePage asString) ].	self changed: #homepageString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!maintainer	^package maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!maintainer: aStringOrText 	package maintainer: aStringOrText asString.	self changed: #maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:45'!package	^package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:38'!packageName	^package name! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:43'!packageName: aString	package name: aString asString.	self changed: #packageName.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!packageNamesFromString: aString 	| depNames |	depNames := aString asString findTokens: ','.	depNames := depNames collect: [:d | d withBlanksTrimmed].	^depNames! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString	^self stringForPackageNames: package provides! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString: aString 	package provides: (self packageNamesFromString: aString).	self changed: #providesString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 8/26/2007 11:37'!smidString	^package squeakMapID		ifNil: ['']		ifNotNil: [package squeakMapID asString ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 8/26/2007 11:43'!smidString: aStringOrText 	| id str |	str := aStringOrText asString withBlanksTrimmed.	id := str isEmpty ifTrue: [nil] ifFalse: [UUID fromString: str].	package squeakMapID: id.	self changed: #smidString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!stringForPackageNames: depends 	| first |	first := true.	^String streamContents: 			[:str | 			depends do: 					[:depName | 					first ifTrue: [first := false] ifFalse: [str nextPutAll: ', '].					str nextPutAll: depName]]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/20/2006 18:36'!urlString	^package url ifNotNil: [ package url toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/25/2006 15:18'!urlString: aString	| url trimmedString |	trimmedString := aString asString withBlanksTrimmed.	url := (trimmedString isEmpty or: [ trimmedString beginsWith: '(' ])		ifTrue: [ nil ]		ifFalse: [ Url absoluteFromText: trimmedString ].	package url: url.	self changed: #urlString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString	^package version printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString: aString	package version: (UVersion readFromString: aString).	self changed: #versionString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 17:12'!window	^window! !!UPackageEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	package _ aPackage.	whenComplete _ aBlock.	! !!UPackageEditor commentStamp: '<historical>' prior: 0!A simple GUI for editing a package and then doing something with it.!!UPackageEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UPackageEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	^self basicNew		package: aPackage  whenComplete: aBlock;		yourself! !!UPackageInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:02'!= anInstaller	^self class = anInstaller class! !!UPackageInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:03'!hash	^self class hash! !!UPackageInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 10:59'!handlesFileEnding: anEnding	^false! !!UPackageInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 11:08'!handlesFilename: filename	^self handlesFileEnding: (FileDirectory extensionFor: filename)	! !!UPackageInstaller methodsFor: 'installing' stamp: 'ls 7/29/2004 11:06'!install: stream  usingBaseName: baseName	self subclassResponsibility! !!UPackageInstaller methodsFor: 'installing' stamp: 'ls 9/4/2004 15:02'!installFileNamed: filename	| stream baseName |	stream _ (FileStream readOnlyFileNamed: filename).	baseName _ (FileDirectory splitName: filename to: [:path :base|base]) copyUpTo: $. .	self install: stream usingBaseName: baseName.	stream close.	! !!UPackageInstaller commentStamp: '<historical>' prior: 0!A simply hierarchy for loading Squeak content in various formats.!!UPackageInstaller class methodsFor: 'initialization' stamp: 'ls 7/29/2004 11:09'!initialize	Installers ifNil: [ Installers _ Set new ].		{UIFileOut. UIMonticello. UIMpeg. UIProject. UISar} do: [ :c |		self registerInstaller: c new ]! !!UPackageInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installFileNamed: filename	(self installerForFilename: filename) installFileNamed: filename! !!UPackageInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installerForFilename: filename	^self registeredInstallers detect: [ :i | i handlesFilename: filename ] ifNone: [ self error: 'no installer handles file ', filename ].! !!UPackageInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:02'!registerInstaller: installer	Installers add: installer! !!UPackageInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:11'!registeredInstallers	^Installers asArray! !!UPackageSerializer commentStamp: 'ls 2/13/2005 12:49' prior: 0!A class for loading and saving lists of packages!!UPackageSpec methodsFor: 'comparison' stamp: 'ls 8/26/2007 09:11'!= aPackageSpec	^(aPackageSpec isKindOf: UPackageSpec) and: [		aPackageSpec name = name and: [			aPackageSpec version = version ]]! !!UPackageSpec methodsFor: 'comparison' stamp: 'ls 8/26/2007 09:18'!hash	^name hash bitXor: version hash! !!UPackageSpec methodsFor: 'initialization' stamp: 'ls 8/26/2007 09:10'!initialize	super initialize.	name := '(unnamed)'.	version = UVersion readFromString: '0'! !!UPackageSpec methodsFor: 'initialization' stamp: 'ls 8/26/2007 09:14'!name: aString version: aUVersionOrString	name := aString.	version := aUVersionOrString asUVersion.	! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!name	^name! !!UPackageSpec methodsFor: 'attributes' stamp: 'ls 8/26/2007 09:11'!version	^version! !!UPackageSpec methodsFor: 'printing' stamp: 'ls 8/26/2007 09:17'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: '/';		print: version! !!UPackageSpec commentStamp: 'ls 8/26/2007 09:09' prior: 0!The information needed to identify a package within a universe: a name plus a version.!!UPackageSpec class methodsFor: 'instance creation' stamp: 'ls 8/26/2007 09:14'!name: aString version: aUVersionOrString 	^ self basicNew name: aString version: aUVersionOrString! !!UPackageSpec class methodsFor: 'instance creation' stamp: 'ls 8/26/2007 09:13'!new	^self error: 'create instances with name:version:'! !!UPackageTestCase methodsFor: 'setup' stamp: 'ls 11/26/2006 11:10'!setUp	p1 _ UPackage new.	p1 name: 'Scamper'.	p1 category: (UPackageCategory withComponents: #('Networking')).	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 _ p1 deepCopy.! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 8/26/2007 12:00'!testCompare	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 homepage: 'http://www.squeakland.org' asUrl.	self shouldnt: [ p1 = p2 ].	p2 homepage: p1 homepage.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p1 homepage: nil.	p2 homepage: nil.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 maintainer: 'Jane'.	self shouldnt: [ p1 = p2 ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:59'!testEncoding	self should: [ p1 = (UPackage decodeFromStringStream: (ReadStream on: p1 stringArrayEncoding)) ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 11/26/2006 10:50'!testXML	| xmlString stream readp1 readp2 readPackages readp3 |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString _ String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport.					str nextPutAll: '<package><name>IRCe</name><version>10.7.6</version><description>This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html</description><url>http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz</url><maintainer></maintainer><provides></provides><depends></depends><conflicts></conflicts></package>' ].	stream _ ReadStream on: xmlString.	readPackages _ UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 3 ].	readp1 _ readPackages first.	readp2 _ readPackages second.	readp3 _ readPackages third.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].	self should: [ readp3 name = 'IRCe'].	self should: [ readp3 version = (UVersion readFromString: '10.7.6')].	! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy commentStamp: '<historical>' prior: 0!A policy that allows anything.!!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy commentStamp: '<historical>' prior: 0!A policy for manipulations on a universe.  All of the methods return 'true' on success or on allowing the requested operation, or 'false' on an error or if the operation is not allowed.  By default everything is disallowed.Note that since policy is completely implemented on the server, there is no requirement that a particular UUniverse has a policy describable with this class or a subclass.  A particular server can always modify UUniverseServer to implement an arbitrary policy.!!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed	^allowed! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed: anObject	allowed _ anObject! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:58'!reason	^reason! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!reason: anObject	reason _ anObject! !!UPolicyResponse commentStamp: '<historical>' prior: 0!A response to a policy query.!!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!allowed	^self allowed: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 10:34'!allowed: reason	^self allowed: true  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!allowed: aBoolean  reason: aReason	^self basicNew		allowed: aBoolean;		reason: (aReason ifNil: ['no reason given']);		yourself! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!denied	^self denied: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 17:58'!denied: reason	^self allowed: false  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!new	self shouldNotImplement ! !!UServerStepperMorph methodsFor: 'closing' stamp: 'ls 2/13/2005 15:20'!delete	super delete.	server stopListening.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:19'!server: aServer	server _ aServer! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 8/14/2007 20:58'!step	server ifNotNil: [ server step ].! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!stepTime	^10! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!wantsSteps	^true! !!UServerStepperMorph commentStamp: '<historical>' prior: 0!A morph that simply steps a UniverseServer continuously.!!USqueakMapUtil commentStamp: 'ls 8/31/2007 12:16' prior: 0!Utilities for interfacing to SqueakMap.!!USqueakMapUtil class methodsFor: 'browsing' stamp: 'ls 8/31/2007 12:18'!browsePackageID: packageID	"open a SqueakMap browser on the specified package ID"	Smalltalk at: #SMLoader ifPresent: [ :smloaderClass |		| loader |		loader := smloaderClass open.		loader selectedItemWrapper: (loader packageWrapperList detect: [:pw | pwwithoutListWrapper id = packageID])]! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!addPackage: aPackage	"make sure that we end up with no two packages with the same name and version"	packages removeAllSuchThat: [ :p | p name = aPackage name and: [ p version = aPackage version ] ].		"now add the new package"	packages add: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!removePackage: aPackage	packages remove: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/15/2005 22:42'!updatePackagesViaWWW	| rawPackageList newPackages |	packagesURL ifNil: [ ^self ].	rawPackageList _ packagesURL retrieveContents content.	(rawPackageList withBlanksTrimmed beginsWith: '<') ifFalse: [		"it is possible that the universe is completely empty, but more likely there was an error retrieving the document"		^self ].	newPackages _ UPackage decodePackagesFromXMLStream: (ReadStream on: rawPackageList).	self packages: newPackages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 8/26/2007 11:57'!initialize	super initialize.	shortName := 'silly'.	serverName := 'localhost'.	serverPort := 6770.	packages := Set new.! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:01'!packages: aCollection	packages _ Set new.	packages addAll: aCollection.	self changed: #packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:12'!packagesURL: aURL	packagesURL _ aURL! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverName: aString		serverName _ aString! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverPort: port	serverPort _ port! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 1/16/2005 14:07'!packages	^packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:13'!packagesURL	"a URL from which the list of packages may be downloaded"	^packagesURL! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverName	^serverName! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverPort	^serverPort! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:09'!standardUniverses	^{self}! !!UStandardUniverse commentStamp: 'ls 7/28/2004 10:36' prior: 0!A universe that looks to one single server for authoritative information.!!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:47'!fromSystemClipboard: aString	^aString utf8ToSqueak! !!UTF8ClipboardInterpreter methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2007 18:48'!toSystemClipboard: aString	^aString squeakToUtf8! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/29/2004 19:09'!addPackages: newPackages	newPackages do: [ :p | self addPackage: p ]! !!UUniverse methodsFor: 'packages' stamp: 'tonyg 2/24/2005 20:14'!buildPackageCache	self packages do: [ :p | p cachedCopyFilename ].! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!hasPackageNamed: name	^self packages anySatisfy: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/28/2004 17:17'!newestPackageNamed: name	| potentials sorted |	potentials _ self packagesNamed: name.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].	^sorted last! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!packageNames	| names |	names _ Set new.	self packages do: [ :p | names add: p name ].	^names! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:08'!packages	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:07'!packagesNamed: name	^self packages select: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!removePackageNamed: packageName withVersion: version	| packagesToRemove |	packagesToRemove _ self packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p | self removePackage: p ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:56'!updatePackagesViaWWW	"update the packages in this universe by downloading them from the universe's URL"	^self subclassResponsibility! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:10'!description	"The description is a one-line description of the universe for human consumption."	^description! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:46'!shortName	"A short, computer-friendly alphanumeric identifier"	^shortName! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/15/2005 21:49'!standardUniverses	"return a list of standard universes within the receiver.  See class UStandardUniverse"	^self subclassResponsibility! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 16:16'!description: aString	description _ aString! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07'!initialize	description _ 'some universe'.! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:10'!shortName: aString	shortName _ aString! !!UUniverse commentStamp: 'ls 2/13/2005 11:10' prior: 0!Abstract.  One "package universe".  A package universe is an evolving set of packages that multiple people can participate in.  Each Squeak image is a member of exactly one universe.!!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 13:36'!betaUniverse 	"[UUniverse switchSystemToUniverse: UUniverse betaUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'beta';		description: 'Beta Development';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/beta.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 13:40'!betadevUniverse	"a combination of normal plus beta packages"	"[UUniverse switchSystemToUniverse: UUniverse betadevUniverse]"	^UCompoundUniverse composedOf: {		self developmentUniverse.		self betaUniverse	}! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 11:34'!developmentUniverse 	"[UUniverse switchSystemToUniverse: UUniverse developmentUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'development';		description: 'Development';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/development.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/13/2005 12:45'!exampleCompoundUniverse	"[UUniverse switchSystemToUniverse: UUniverse exampleCompoundUniverse]"	^(UCompoundUniverse composedOf: {		self developmentUniverse.		self homeMoviesUniverse	}) description: 'example compound universe'; yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 13:22'!homeMoviesUniverse 	"[UUniverse switchSystemToUniverse: UUniverse homeMoviesUniverse]"	^UStandardUniverse new		shortName: 'homemovies';		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/homemovies.packages' asUrl;		description: 'Home Movies';		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 10/7/2007 14:05'!squeak310Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak310Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.10';		description: 'Squeak 3.10';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak3.10.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 13:22'!squeak37Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak37Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak37';		description: 'Squeak 3.7';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak37.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 3/22/2007 11:34'!squeak39Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak39Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.9';		description: 'Squeak 3.9';		packagesURL: 'http://universes.dnsalias.net/~universes/repositories/squeak3.9.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'class initialization' stamp: 'ls 2/15/2005 23:42'!initialize	"fix up old instances, to have a proper packagesURL"	"this method should be deleted, after suitable time has passed to allow for upgrades"	self allSubInstancesDo: [ :universe |		universe class == UStandardUniverse ifTrue: [			universe packagesURL == nil ifTrue: [				"no URL specified.  guess...."				universe serverPort = 4129 ifTrue: [					universe shortName: 'development'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 8940 ifTrue: [ 					universe shortName: 'homevideos'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 7273 ifTrue: [ 					universe shortName: 'squeak37'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ]. ] ] ]! !!UUniverse class methodsFor: 'system' stamp: 'ls 7/29/2004 18:54'!switchSystemToUniverse: aUniverse	SystemUniverse _ aUniverse! !!UUniverse class methodsFor: 'system' stamp: 'ls 2/13/2005 12:44'!systemUniverse	"return the universe this image uses"	^SystemUniverse ifNil: [ SystemUniverse _ self developmentUniverse ]! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:10'!chooseUpgrades	"select packages that appear to be upgrades of packages that are already installed"	self installSet selectAllUpgrades.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:13'!doInstall	self installSet anyPackageSelected ifFalse: [		^self inform: 'no packages selected to install' ].	self installSet doInstall.			self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:30'!installSelectedPackage	self anyPackageSelected ifFalse: [ ^self ].	self installSet planToInstallPackage: self selectedPackage.			self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 8/14/2007 21:06'!installSet	^installSet ifNil: [ installSet :=		UGlobalInstaller universe: universe configuration: configuration	]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:56'!anyPackageSelected	^ selectedPackage notNil! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:16'!anyPackagesToInstall	^self installSet anyPackageSelected ! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:26'!canMarkSelectionForInstallation	^self anyPackageSelected and: [ 		(self installSet isPackageVersionSelected: self selectedPackage) not and: [			(self installSet isPackageVersionInstalled: self selectedPackage) not ]]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:23'!categories	^((self sortedPackages collect: [ :p | p category])		asSet		asSortedCollection: [ :p1 :p2 | p1 asString < p2 asString])		asArray! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:35'!categoriesAndPackagesIn: categoryPrefix	| categories packages |	categories := self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ].	packages := self sortedPackages select: [ :p | p category = categoryPrefix ].	^categories, packages! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:34'!isCategory: anObject	^anObject isUPackageCategory! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48'!packageDescriptions	^ self sortedPackages collect: [:p | self packageOneLineDescription: p]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/26/2007 12:25'!packageOneLineDescription: p 	| commentary |	p isUPackage ifFalse: [ ^p printString ].	commentary := ''.	(self installSet isPackageVersionSelected: p) ifTrue: [commentary := '(to install) '].	(configuration includesPackageSpec: p packageSpec) 		ifTrue: [commentary := '(installed) '].	^ commentary , p printString! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 8/14/2007 21:21'!packagesChanged	self installSet initializeSelectedPackageVersions.  "the selected packages may not be there any more!!"	self selectPackageOrCategory:   nil.		self changed: #packageDescriptions.  self flag: #lex.  "only for compatibility with old, open GUI windows"	self changed: #rootCategoriesAndPackages.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:24'!rootCategoriesAndPackages	^self categoriesAndPackagesIn: (UPackageCategory root)! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13'!selectPackageOrCategory: packageOrCategory	selectedPackage := 		packageOrCategory isUPackage			ifTrue: [ packageOrCategory ]			ifFalse: [ nil ].	self changed: #selectedPackage.	self changed: #selectedPackageDescription.	self changed: #canMarkSelectionForInstallation.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:55'!selectedPackage	^selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'dc 3/22/2007 14:22'!selectedPackageDescription	self anyPackageSelected ifFalse: [ ^ '' ].	^ self selectedPackage longDescription 	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:58'!selectedPackageIndex	self flag: #lex.  "only present in case people have existing browser windows open"	^self sortedPackages indexOf: selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 13:02'!selectedPackageIndex: anIndex	self flag: #lex.  "only present in case people have existing browser windows open"	self selectPackageOrCategory:		(anIndex = 0 ifTrue: [ nil ] ifFalse: [ self sortedPackages at: anIndex ]).	self changed: #selectedPackageIndex	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:25'!sortedPackages	| packages |	packages := Set new.	packages addAll: universe packages.	packages addAll: configuration installedPackages.		^packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:19'!subcategoriesOf: categoryPrefix	^self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 15:12'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:58'!configuration: aConfiguration	configuration _ aConfiguration! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 8/14/2007 21:18'!initialize	configuration := UConfiguration forSystem.	self universe: UUniverse systemUniverse! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:12'!universe: aUniverse	universe _ aUniverse.	universe addDependent: self.! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 12:50'!morphicView	| win packageList installButton doInstallButton buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win _ SystemWindow labelled: 'Universe'.	win model: self.			packageList _ 		PluggableTreeMorph new			model:  self;			name: 'package list';			getRootsSelector: #rootCategoriesAndPackages; 			hasChildrenSelector: #isCategory:; 			getChildrenSelector: #categoriesAndPackagesIn:;			setSelectedSelector: #selectPackageOrCategory:;			getLabelSelector: #packageOneLineDescription:.	win addMorph: packageList frame: ((0@0) extent: (0.5@0.9)).		installButtonHolder _ Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton _ self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea _ PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList _ AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0) extent: (0.5@0.4)).			installButton _ self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton _ self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton _ self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:19'!open	self morphicView openInWorld! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!returnTrue	"return true; used for buttons that are always enabled"	^true! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 13:04'!titleAreaText	self flag: #lex.  "this is only present to support browser windows that are already open"	^universe shortName! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'ls 11/26/2006 12:53'!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UUniverseBrowser commentStamp: '<historical>' prior: 0!A tool to support one-click installs and upgrades of packages within a universe.!!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 14:53'!forUniverse: aUniverse	^self new universe: aUniverse; yourself! !!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:15'!open	^self new open! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:50'!initialize	#('Package Browser (basic)' 'Universe Browser') do: [:oldName |		TheWorldMenu unregisterOpenCommand: oldName ].		TheWorldMenu registerOpenCommand: {'Universe Browser (basic)'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Browser (basic)'! !!UUniverseBrowser class methodsFor: 'dependencies' stamp: 'ls 7/29/2004 15:16'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages _ Set new.	orderedPackages _ OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^orderedPackages! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:10'!disconnect	"explicitly close the connection"	socket ifNotNil: [ socket destroy.  socket _ nil ].	stringSocket ifNotNil: [ stringSocket destroy.  stringSocket _ nil ].! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:33'!receivedMessagesDo: aBlock	"check for new messages, and then evaluate aBlock for each message that is currently available"	self processIO.	[ inMessages isEmpty ] whileFalse: [		aBlock value: inMessages removeFirst ]! !!UUniverseClient methodsFor: 'public' stamp: 'ls 2/13/2005 15:18'!sendMessage: aMessage	"send the specified message to the server"	outMessages add: aMessage! !!UUniverseClient methodsFor: 'initialization' stamp: 'ls 8/5/2004 17:16'!initialize: aUniverse	universe _ aUniverse.		inMessages _ OrderedCollection new.	outMessages _ OrderedCollection new.		lastConnectionStart _ DateAndTime epoch.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 8/4/2004 15:46'!newInMessage: aMessage	aMessage applyToClient: self.	inMessages add: aMessage.	! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 2/15/2005 21:44'!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket _ nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket _ StringSocket on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket _ nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg _ stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 7/30/2004 15:31'!startConnecting	"start a new connection to the server"	self disconnect.		lastConnectionStart _ DateAndTime now.		socket _ Socket newTCP.	socket connectTo: (NetNameResolver addressForName: universe serverName) port: universe serverPort.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 1/13/2007 14:47'!waitForMessage	"return the next message from the server, waiting if necessary.  Many clients will find this method less convenient than polling on the non-blocking receivedMessagesDo:."	[		self receivedMessagesDo: [ :m | ^m ].		(Delay forMilliseconds: 100) wait.	] repeat.! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 14:59'!newPackageList: newPackages	universe packages: newPackages.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:00'!packageAdded: newPackage	universe addPackage: newPackage! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:02'!removedPackageNamed: packageName  withVersion: version	universe removePackageNamed: packageName  withVersion: version! !!UUniverseClient commentStamp: 'ls 7/30/2004 14:58' prior: 0!A client for talking to a universe server.The universe must be a UStandardUniverse.  The client will track update the universe automatically as messages come in.!!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!new	^self forUniverse: UUniverse systemUniverse! !!UUniverseClient class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 15:45'!initialize	Preferences removePreference: #universesUsesHTTP ! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!acceptFields	fields do: [ :f | f accept ]! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:58'!closeAccountEditor	accountEditor ifNil: [ ^self ].	accountEditor window delete.	accountEditor _ nil.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:12'!closeEditorForPackage: package	| matchingEditors |	matchingEditors _ packageEditors select: [ :p | p package = package ].	matchingEditors do: [ :editor |		editor window delete.		packageEditors remove: editor ].! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:02'!morphicView	| win universeDescription buttonList usernameRow passwordRow button  usernamePasswordArea packageList |	win _ SystemWindow labelled: 'Universe Editor'.	win model: self.		universeDescription := PluggableTextMorph on: self text: #universeDescription accept: nil.	universeDescription hideScrollBarsIndefinitely.	win addMorph: universeDescription frame: (0@0 extent: 1@0.1).		buttonList _ AlignmentMorph newColumn.	buttonList cellInset: 0@3.	win addMorph: buttonList frame: (0@0.5 extent: 0.5@0.5).			usernamePasswordArea _ AlignmentMorph newColumn.	win addMorph: usernamePasswordArea frame: (0@0.1 extent: 0.5@0.4).	usernameRow _ UInterfaceUtilities makeFieldRowNamed: 'username' getSelector: #username setSelector: #username: for: self.	usernamePasswordArea addMorphBack: usernameRow.		passwordRow _ UInterfaceUtilities makeFieldRowNamed: 'password:' getSelector: #password setSelector: #password: isPassword: true for: self.	usernamePasswordArea addMorphBack: passwordRow.		button _ self makeButtonWithAction: #createAccount andLabel: 'createAccount'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #editAccount andLabel: 'edit account'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackage andLabel: 'new package'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackageVersion andGetState: #anyPackageSelected andLabel: 'new package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #removeVersion andGetState: #anyPackageSelected andLabel: 'remove package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #requestPackageList andLabel: 'update package list'.	buttonList addMorphBack: button.	packageList _ PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	win addMorph: packageList frame: ((0.5@0.1) extent: (0.5@0.9)).		^win! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:27'!open	self morphicView openInWorld.	"self requestPackageList."! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!returnTrue	^true! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 7/28/2004 18:00'!accountUpdatedWithUsername: newUsername  password:  newPassword  email: newEmail	self acceptFields.	username _ newUsername.	password _ newPassword.	email _ newEmail.		self changed: #username.	self changed: #password.	self changed: #email.		self closeAccountEditor! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:31'!createAccount	self acceptFields.	email _ FillInTheBlankMorph request: 'your email address?'.	email = '' ifTrue: [ ^self ].	self sendMessage: (UMAddAccount username: username password: password email: email).	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:52'!editAccount	| editor |	self acceptFields.	self closeAccountEditor.		editor _ UAccountEditor		username: username		password: password		email:  ''		whenDone: [ :oldPassword :newPassword :newEmail |			password _ oldPassword.			self sendMessage: (UMEditAccount username: username password: password newPassword: newPassword newEmail: newEmail) ].			editor openInMorphic.		accountEditor _ editor.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:25'!anyPackageSelected	^selectedPackageIndex > 0! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:26'!packageDescriptions	^self sortedPackages collect: [ :p |				p printString. ]! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13'!packagesChanged	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 7/29/2004 16:23'!requestPackageList	self sendMessage: (UMRequestPackages new).	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackage	^self sortedPackages at: self selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex	^selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex: anInteger	selectedPackageIndex _ anInteger.	self changed: #selectedPackageIndex.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!sortedPackages	^universe packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!createNewPackage	| package |	package := UPackage new.	Utilities authorInitialsPerSe ifNotNil: [		package maintainer: Utilities authorInitialsPerSe	].	^package! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!newPackage	| editor |	self acceptFields.	editor _ UPackageEditor package: self createNewPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/15/2005 22:06'!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.		newPackage _ package deepCopy.	newPackage version: (UVersion readFromString: (newPackage version asString, 'new')).	editor _ UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/13/2005 17:20'!removeVersion	| package |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.	(self confirm: ('Delete ', 	package printString, '?')) ifFalse: [		^self ].	self sendMessage: (UMRemovePackage username: username password: password packageName: package name packageVersion: package version).! !!UUniverseEditor methodsFor: 'initialization' stamp: 'ls 2/13/2005 17:16'!initialize: universe0	universe _ universe0.	universe addDependent: self.	client _ UUniverseClient forUniverse: universe.	username _ Utilities authorInitialsPerSe.	password _ ''.		packageEditors _ Set new.	selectedPackageIndex _ 0.! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:54'!password	^password! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:18'!password: aString	password _ aString asString.	^true! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/29/2004 16:21'!universeDescription 	^universe description! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:53'!username	^username! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:13'!username: aString	username _ aString asString.	^true! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 2/13/2005 17:16'!processNetworking	client receivedMessagesDo: [ :message |		message applyToEditor: self ].! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 7/30/2004 15:40'!sendMessage: aMessage	client sendMessage: aMessage.	! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!step	self processNetworking! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!stepTimeIn: window	^10! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!wantsSteps	^true! !!UUniverseEditor commentStamp: '<historical>' prior: 0!A tool for editing a remote universe.!!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 10:23'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!new	| choice choices |	choices := UUniverse systemUniverse standardUniverses asArray.	choices isEmpty ifTrue: [ ^self error: 'no standard universes installed' ].	choices size = 1 ifTrue: [		choice _ choices anyOne ]	ifFalse: [		| menu |		menu _			SelectionMenu				labels: (choices collect: [ :u | u description ])				selections: choices.		choice _ menu startUpWithCaption: 'edit which universe?'.		choice ifNil: [ ^self ] ].		^self forUniverse: choice! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!open	^self new open! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!initialize	TheWorldMenu unregisterOpenCommand: 'Package Universe Editor'.	TheWorldMenu registerOpenCommand: {'Universe Editor'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 8/19/2007 12:30'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Editor'! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:32'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		"process all incoming messages.  Note that some messages move the connection to one of the subsidiary servers, so be careful not to process messages after that happens"	aConnection processIO.	[ 	(connections includes: aConnection) and: [			message _ aConnection nextOrNil.	 	 	message notNil ]	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	(connections includes: aConnection) ifFalse: [ ^self ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:51'!processNetworking	self checkForNewConnections.	self processConnections.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: port queueLength: 5.	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!addServer: server	servers add: server! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:49'!addServers: newServers	newServers do: [ :s | self addServer: s ]! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!initialize	servers _ Set new.	port _ UUniverseMultiServer defaultPort.	connections _ Set new.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 14:34'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToMultiServer: self forConnection: connection.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 16:18'!switchConnection: aConnection  toServerNamed: serverName	| server |	server _ servers detect: [ :s | s universe shortName = serverName ] ifNone: [		aConnection nextPut: (UMError description: 'no such server here') asStringArray.		^self ].	server acceptConnection: aConnection.	connections remove: aConnection.! !!UUniverseMultiServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 14:50'!step	self processNetworking.	servers do: [ :server | server step ].! !!UUniverseMultiServer commentStamp: 'ls 2/13/2005 14:51' prior: 0!A multi-server server.  This listens on one port, and dispatches to whichever universe was requested.An active server needs someone to call #step periodically on it, in order for it to process networking, save checkpoints, etc.!!UUniverseMultiServer class methodsFor: 'defaults' stamp: 'ls 2/13/2005 14:32'!defaultPort	^3702! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 11:02'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:15'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 8/3/2004 18:10'!comancheServiceName	^'universe server on ', universe serverPort printString! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:47'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 21:28'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		aConnection processIO.	[ 	message _ aConnection nextOrNil.	  	message notNil	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:43'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/13/2005 15:19'!processNetworking	self checkForNewConnections.	self processConnections.	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:21'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: universe serverPort queueLength: 5.	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:41'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountChangeForUsername: username  password: password  newPassword: newPassword newEmail: newEmail	| response |	response _ policy changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail.	response allowed ifFalse: [		^self			sendError: 'changing account for ', username, ' failed (', response reason, ')'			onConnection: connection].			self sendMessage: (UMEditedAccount username: username newPassword: newPassword newEmail: newEmail) onConnection: connection! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountWithUsername: username  password: password  email: email 	| response |	response _ policy addUser: username withPassword: password andEmail: email.	response allowed ifFalse: [		self			sendError: 'adding account for ', username, ' failed (', response reason, ')'			onConnection: connection].! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toAddPackage: package	| response |	response _ policy package: package mayBeAddedBy: username withPassword: password.		response allowed		ifFalse: [			^self 				sendError: 'adding package ', package name, ' failed (', response reason, ')'				onConnection: connection].			universe addPackage: package.	self sendMessage: (UMPackageAdded package: package) onConnection: connection.! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toRemovePackageNamed: packageName withVersion: version	| packagesToRemove response |	response _ policy packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password.		response allowed ifFalse: [		^self 			sendError: 'removing package ', packageName, ' failed (', response reason, ')' 			onConnection: connection].			packagesToRemove := universe packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p |		universe removePackage: p ].		self sendMessage: (UMPackageRemoved packageName: packageName version: version) onConnection: connection.! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:20'!initializeForUniverse: aUniverse	universe _ aUniverse.	policy _ UPolicy new.	connectionQueue _ nil.	connections _ Set new.! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 13:44'!packageListFilename: filename	packageListFilename _ filename! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:32'!policy: aPolicy	policy _ aPolicy! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 09:16'!saveDirectory: aDirectory	saveDirectory _ aDirectory! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 7/29/2004 09:25'!loadFromCheckpoint	"reload from a checkpoint"	| file savedObject |	(saveDirectory isAFileNamed: 'checkpoint')		ifTrue: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint' ]		ifFalse: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint.die' ].	savedObject := file fileInObjectAndCode.	file close.		universe := savedObject first.	policy := savedObject second.	! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 15:23'!possiblySaveCheckpointAndPackageList	saveDirectory ifNil: [^self].	(lastSaveTime isNil 		or: [DateAndTime now - lastSaveTime > (Duration minutes: 30)]) 			ifTrue: 				[self saveCheckpoint.				self savePackageList.				lastSaveTime := DateAndTime now]! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:43'!saveCheckpoint	"save a checkpoint"	| tmpFile |	saveDirectory deleteFileNamed: 'checkpoint.tmp'.		tmpFile := saveDirectory newFileNamed: 'checkpoint.tmp'.	(SmartRefStream on: tmpFile) nextPut: {universe.policy}; close.		saveDirectory deleteFileNamed: 'checkpoint.die'.	saveDirectory rename: 'checkpoint.tmp' toBe: 'checkpoint'.		saveDirectory deleteFileNamed: 'checkpoint.die'.	! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:44'!savePackageList	packageListFilename ifNotNil: [		UPackage savePackageList: universe packages onFileNamed: packageListFilename ]! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 8/2/2004 17:15'!openStepperMorph	(UServerStepperMorph new server: self; yourself) openInWorld! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 15:23'!step	"do any necessary periodic work, including polling the network connections"	self processNetworking.	self possiblySaveCheckpointAndPackageList! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 5/28/2007 17:32'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToServer: self forConnection: connection.	self logMessage: message.	! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 14:49'!sendError: description onConnection: stringSocket	self sendMessage: (UMError description: description) onConnection: stringSocket! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 11:48'!sendMessage: aMessage  onConnection: connection	connection nextPut: aMessage asStringArray  ! !!UUniverseServer methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:08'!universe	^universe! !!UUniverseServer methodsFor: 'logging' stamp: 'ls 5/30/2007 11:40'!logMessage: message	| line |	logfile ifNil: [ ^self ].	line := message maybeLogMessage.	line ifNil: [ ^self ].	logfile		print: DateAndTime now;		space;		nextPutAll: line; 		cr.	logfile flush.! !!UUniverseServer methodsFor: 'logging' stamp: 'ls 5/28/2007 17:27'!logToFileNamed: filename	logfile := FileStream fileNamed: filename.	logfile setToEnd.	! !!UUniverseServer commentStamp: 'ls 2/13/2005 13:45' prior: 0!A server holding the authoratative information about a universe.  Clients may make requests to view and update the universe.The server does not manage its own thread; it requires that processNetworking is called periodically.!!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 09:29'!forSaveDirectory: aDirectory	| universe |	universe _ self forUniverse: UUniverse new.	universe saveDirectory: aDirectory.	universe loadFromCheckpoint.	^universe! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!forUniverse: universe	^self basicNew initializeForUniverse: universe.	! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!new	^self shouldNotImplement ! !!UUtilities commentStamp: 'ls 7/28/2004 10:35' prior: 0!Universe miscellania that belong to no particular object.!!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15'!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31'!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02'!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33'!components	^components! !!UVersion methodsFor: 'initialization' stamp: 'ls 7/27/2004 17:27'!components: aCollection	components _ aCollection! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28'!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!UVersion methodsFor: 'conversion' stamp: 'ls 8/26/2007 09:15'!asUVersion	^self! !!UVersion commentStamp: '<historical>' prior: 0!A relatively simple hierarchical version number.!!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:24'!fromComponents: components	^self basicNew components: components; yourself! !!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:27'!readFrom: stream	| components |	components _ OrderedCollection new.	[ stream atEnd ] whileFalse: [		stream peek isDigit ifTrue: [			components add: (Integer readFrom: stream) ]		ifFalse: [			components add: (String streamContents: [ :compStr |				[ stream atEnd not and: [ stream peek isDigit not ] ] whileTrue: [					compStr nextPut: stream next ] ]) ] ].			^self fromComponents: components! !!UVersionTestCase methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:12'!setUp	typicalVersions := #(		'1'		'2'		'1.5.7'		'1.5.8'		'1.6.2'		'1.5'		'1.5a'		'1.5b'		'1.6'		'alpha'		'beta'	) collect: [ :str | UVersion readFromString: str ].	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:19'!testCompare	self should: [ (UVersion readFromString: '1') < (UVersion readFromString: '2') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.5.8') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.6.2') ].	self should: [ (UVersion readFromString: '1.5') < (UVersion readFromString: '1.5a') ].	self should: [ (UVersion readFromString: '1.5a') < (UVersion readFromString: '1.5b') ].	self should: [ (UVersion readFromString: '1.5b') < (UVersion readFromString: '1.6') ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:24'!testFullOrder	"check that all versions are in some order"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [				(v1 < v2)				or: [ (v2 < v1) 				or: [ v1 = v2 ] ] ] ] ]	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/28/2004 09:59'!testHash	typicalVersions do: [ :v |		self should: [ v hash = v copy hash ] ].		self should: [ (UVersion readFromString: '1.5a') hash = (UVersion readFromString: '1.5a') hash ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:23'!testReversedComparisons	"check that it is never the case that v1<v2 and v2<v1"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [ (v1 < v2) not  or:  [  (v2 < v1) not ] ] ] ].	! !!UniclassScript methodsFor: 'access' stamp: 'sw 12/15/2004 20:46'!playerClass	"Answer the playerClass associated with the receiver"	^ playerClass ifNil:		[playerClass := currentScriptEditor playerScripted ifNotNil: [currentScriptEditor playerScripted class]]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/30/2001 11:37'!convertFromUserScript: aUserScript	"The argument represents an old UserScript object.  convert it over"	defaultStatus := aUserScript status.	isTextuallyCoded := aUserScript isTextuallyCoded.	currentScriptEditor := aUserScript currentScriptEditor.	formerScriptingTiles :=  aUserScript formerScriptEditors ifNotNil:		[aUserScript formerScriptEditors collect:			[:aScriptEditor |				Array with: aScriptEditor timeStamp with: aScriptEditor submorphs allButFirst]]! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 1/26/2001 16:44'!initialize	"Initialize the receiver by setting its inst vars to default values"	super initialize.	isTextuallyCoded := false! !!UniclassScript methodsFor: 'initialization' stamp: 'sw 7/2/2002 14:13'!playerClass: aPlayerClass selector: aSelector	"Set the playerClass and selector of the receiver"	super playerClass: aPlayerClass selector: aSelector.	aSelector numArgs = 1 ifTrue:		[argumentVariables := {Variable new name: 'parameter' type: #Number}]! !!UniclassScript methodsFor: 'initialize-release' stamp: 'RAA 5/18/2001 13:25'!releaseCachedState	"release all non-showing scriptors.  What do we do about versions????"	"18 May 2001 - get more aggressive in dropping stuff"	formerScriptingTiles := OrderedCollection new.	currentScriptEditor ifNil: [^ self].	true ifTrue: [^ self].	"<<< to test the reconstruction of scripts, change to false"	currentScriptEditor world ifNil: ["not showing"		currentScriptEditor := nil]! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 1/23/2001 17:12'!currentScriptEditor: anEditor	"Set the receiver's currentScriptEditor as indicated"	currentScriptEditor := anEditor! !!UniclassScript methodsFor: 'script editor' stamp: 'sw 7/20/2002 14:27'!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor := (self playerClass includesSelector: selector) 			ifTrue:				[Preferences universalTiles					ifFalse:						[self error: 'duplicate selector'].				ScriptEditorMorph new fromExistingMethod: selector forPlayer: aPlayer]			ifFalse:				[ScriptEditorMorph new setMorph: aPlayer costume scriptName: selector].		(defaultStatus == #ticking and: [selector numArgs == 0]) ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'textually coded' stamp: 'sw 3/28/2002 00:39'!becomeTextuallyCoded	"Transform the receiver into one which is textually coded"	isTextuallyCoded := true.	lastSourceString := (playerClass compiledMethodAt: selector) decompileString 		"Save this to compare when going back to tiles"! !!UniclassScript methodsFor: 'updating' stamp: 'sw 2/16/2001 00:46'!revertToLastSavedTileVersionFor: anEditor	"revert to the last saved tile version"	Preferences universalTiles		ifFalse:			[formerScriptingTiles isEmptyOrNil ifFalse:				[anEditor reinsertSavedTiles: formerScriptingTiles last second]]		ifTrue:			[anEditor removeAllButFirstSubmorph.			anEditor insertUniversalTiles].	anEditor showingMethodPane: false.	isTextuallyCoded := false! !!UniclassScript methodsFor: 'updating' stamp: 'sw 2/18/2001 18:27'!saveScriptVersion: timeStamp	"Save the tile script version by appending a pair of the form		<time stamp>     <morph list>to my list of former scripting tiles.  The morph-list will get copied back into the Scriptor following restoration.  Only applies to classic tiles."	Preferences universalTiles ifFalse:  "the following only applies to Classic tiles"		[(currentScriptEditor notNil and: [currentScriptEditor showingMethodPane not]) ifTrue:				[formerScriptingTiles ifNil: [formerScriptingTiles := OrderedCollection new].				formerScriptingTiles add:					(Array with: timeStamp						with: (currentScriptEditor submorphs allButFirst collect: [:m | m veryDeepCopy])).				formerScriptingTiles size > 100 ifTrue: [^ self halt: 'apparent runaway versions, proceed at your own risk.']]]! !!UniclassScript methodsFor: 'versions' stamp: 'di 2/19/2001 10:09'!recreateScriptFrom: anEditor	"Used to revert to old tiles"	formerScriptingTiles isEmptyOrNil ifTrue: [^ self].	anEditor reinsertSavedTiles: formerScriptingTiles last second.	isTextuallyCoded := false! !!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 0!This class holds the entry points for the utility functions around characters.!!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:55'!isDigit: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Nd! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:56'!isLetter: char 	| value codeCat |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (codeCat := GeneralCategory at: value + 1) >= Ll		and: [codeCat <= Lu]! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:57'!isLowercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Ll! !!Unicode class methodsFor: 'character classification' stamp: 'kwl 6/30/2006 02:58'!isUppercase: char 	| value |	value := char charCode.	value > (GeneralCategory size - 1)		ifTrue: [^ false].	^ (GeneralCategory at: value + 1)		= Lu! !!Unicode class methodsFor: 'class initialization' stamp: 'kwl 6/30/2006 02:53'!initialize	" Unicode initialize "	(self classPool keys		select: [:sym | sym size = 2 and: sym first isUppercase and: sym last isLowercase]) asSortedCollection		inject: 1		into: [:index :sym | sym = #Cn				ifTrue: [self classPool at: sym put: 0. index]				ifFalse: [self classPool at: sym put: index. index + 1]]! !!UnimplementedCallBugz methodsFor: 'as yet unclassified' stamp: 'wiz 5/3/2007 19:53'!testPolyIntersect"self run: #testPolyIntersect"self shouldnt: [ PolygonMorph initializedInstance 					intersects: ( Rectangle center: Display center 											extent: 100 asPoint ) ] 	raise: Error .! !!UnscriptedPlayer methodsFor: 'viewer' stamp: 'sw 1/30/2001 22:43'!assureUniClass	"Create a uniclass and become the receiver into it"	| anInstance |	anInstance := self rootClassForUniclasses instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer class methodsFor: 'namespace' stamp: 'sw 9/30/1998 09:05'!referenceSelectorFor: anObject	"The use of this is for immediate evaluation of lines of script in a Viewer.  The class inst var 'ephemeralPlayerRef' is constantly reused for this purpose."	ephemeralPlayerRef := anObject.	^ 'ephemeralPlayerRef'! !!UpdatingMenuItemMorph methodsFor: 'wording' stamp: 'wiz 2/11/2008 16:52'!target: anObject"For us if the old target and wording provider are the same update both."target = wordingProvider 	ifTrue: [ wordingProvider := target := anObject ]	ifFalse: [  target := anObject ] .! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents: c	contents := c! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector := aSymbol.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector: aSymbol	putSelector := aSymbol! !!UpdatingRectangleMorph methodsFor: 'accessing'!target: anObject	target := anObject.! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].! !!UpdatingRectangleMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:17'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied"lastValue := lastValue veryDeepCopyWith: deepCopier."getSelector := getSelector.		a Symbol""putSelector := putSelector.		a Symbol"contents := contents veryDeepCopyWith: deepCopier.! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 3/23/2001 23:26'!setTargetColor: aColor	"Set my target's color as indicated"	putSelector ifNotNil:		[self color: aColor.		contents := aColor.		self valueProvider perform: self putSelector withArguments: (Array with: aColor)]! !!UpdatingRectangleMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:27'!step	| s |	super step.	s := self readFromTarget.	s = contents ifFalse:		[self contents: s.		self color: s]! !!UpdatingStringMorph methodsFor: '*eToys-target access' stamp: 'sw 3/7/2004 15:49'!hasStructureOfComplexWatcher	"Answer whether the receiver has precisely the structure of a so-called complex watcher, as used in the etoy system."	| top |	top := (self owner ifNil: [^ false]) owner.	^ ((((top isMemberOf: AlignmentMorph)		and: [top submorphs size = 4])			and: [top submorphs first isMemberOf: TileMorph])				and: [top submorphs third isMemberOf: AlignmentMorph])! !!UserCustomEventNameType methodsFor: 'queries' stamp: 'nk 9/26/2003 23:36'!choices	"Answer an alphabetized list of known user custom event selectors"	| choices |	choices := ScriptingSystem userCustomEventNames.	^choices isEmpty ifTrue: [ #('no event') ] ifFalse: [ choices ]! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/29/98 22:55'!currentScriptEditor: anEditor	currentScriptEditor := anEditor! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/23/2001 11:28'!instantiatedScriptEditor	"Return the current script editor, creating it if necessary"	self isTextuallyCoded ifTrue:			[^ (player costume pasteUpMorph ifNil: [player costume "the world, backstop"]) scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor := (player class includesSelector: selector) 			ifTrue: [ScriptEditorMorph new 				fromExistingMethod: selector 				forPlayer: player]			ifFalse: [ScriptEditorMorph new				setMorph: player costume				scriptName: selector].		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!UserScript methodsFor: 'script editor' stamp: 'tk 11/30/2000 16:32'!releaseCachedState	"release all non-showing scriptors.  What do we do about versions????"	self isTextuallyCoded ifTrue: [formerScriptEditors := OrderedCollection new].		"to test new tiles.  We 'commit' to current script."	currentScriptEditor ifNil: [^ self].	true ifTrue: [^ self].	"<<< to test the reconstruction of scripts, change to false"	currentScriptEditor world ifNil: ["not showing"		currentScriptEditor := nil].! !!UserScript methodsFor: 'textually coded' stamp: 'sw 5/19/1998 14:13'!becomeTextuallyCoded	currentScriptEditor := #textuallyCoded! !!UserScript methodsFor: 'updating' stamp: 'sw 1/22/2001 16:45'!updateToPlayer: aPlayer	"Set aPlayer as the current player referenced by the receiver and its script editor"	(currentScriptEditor notNil and: [currentScriptEditor ~~ #textuallyCoded]) ifTrue:		[currentScriptEditor updateToPlayer: aPlayer].	player := aPlayer! !!UserScript methodsFor: 'versions' stamp: 'sw 10/30/2000 08:54'!revertScriptVersionFrom: anEditor installing: aSavedEditor	"Replace anEditor with a brought-up-to-date version of aSavedEditor"	| aPosition oldOwner |	aPosition := anEditor position.	oldOwner := anEditor topRendererOrSelf owner.	anEditor delete.	currentScriptEditor := aSavedEditor bringUpToDate install.	player costume viewAfreshIn: oldOwner showingScript: selector at: aPosition! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:51'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| listContents version versIndex |	listContents _ self parseListContents: list.	version _ SystemVersion current version.		versIndex _ (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue: [^ Array new].		"abort"	^ (listContents at: versIndex) last! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:45'!newUpdatesOn: serverList special: indexPrefix throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber _ aNumber ifNil: [99999].	out _ OrderedCollection new.	existing _ SystemVersion current updates.	serverList do: [:server |		doc _ HTTPClient httpGet: 'http://' , server,indexPrefix,'updates.list'.				"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: raw.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber _ ff initialIntegerOrNil. 				(existing includes: itsNumber)					ifFalse:						[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: 'http://' , server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char _ doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	self inform: 'All code update servers seem to be unavailable'.	^ out! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'sw 1/28/1999 12:35'!contents: newContents	contents := newContents.	self contentsChanged! !!VariableDock methodsFor: 'getters and setters' stamp: 'sw 10/30/2000 10:55'!computePlayerGetterAndSetterSelectors	"Compute and remember the getter and setter selectors for obtaining and setting values from the player instance"	playerGetSelector := Utilities getterSelectorFor: variableName.	playerPutSelector := Utilities setterSelectorFor: variableName! !!VariableDock methodsFor: 'initialization' stamp: 'sw 10/30/2000 08:52'!variableName: aSymbol type: aType definingMorph: aMorph morphGetSelector: getterSymbol morphPutSelector: putterSymbol	"Initialize the receiver as indicated"	variableName := aSymbol asSymbol.	type := aType.	definingMorph := aMorph.	morphGetSelector := getterSymbol.	morphPutSelector := putterSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableDock methodsFor: 'name' stamp: 'sw 10/30/2000 08:51'!variableName: aSymbol	"Set the receiver's variableName as indicated, and recompute corresponding getters and setters"	variableName := aSymbol asSymbol.	self computePlayerGetterAndSetterSelectors! !!VariableNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:53'!explanation	self isSelfPseudoVariable ifTrue: [^'the pseudo variable <self> (refers to the receiver)'].	^(#('instance' 'temporary' 'LIT3' 'global') 			at: self type 			ifAbsent: ['UNK',self type printString]),' variable <',self name,'>'			"LdInstType := 1.	LdTempType := 2.	LdLitType := 3.	LdLitIndType := 4."! !!VariableNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:54'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		index := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		index := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor := Color white]].	insideColor := aColor! !!View methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border widths of the receiver. These arguments represent the left, 	right, top, and bottom border widths."	borderWidth :=			Rectangle				left: anInteger1				right: anInteger2				top: anInteger3				bottom: anInteger4.	self unlock! !!View methodsFor: 'bordering'!foregroundColor: aColor	borderColor := aColor! !!View methodsFor: 'controller access'!model: aModel controller: aController 	"Set the receiver's model to aModel, add the receiver to aModel's list of 	dependents, and set the receiver's controller to aController. Subsequent 	changes to aModel (see Model|change) will result in View|update: 	messages being sent to the receiver. #NoControllerAllowed for the value 	of aController indicates that no default controller is available; nil for the 	value of aController indicates that the default controller is to be used 	when needed. If aController is neither #NoControllerAllowed nor nil, its 	view is set to the receiver and its model is set to aModel."	model ~~ nil & (model ~~ aModel)		ifTrue: [model removeDependent: self].	aModel ~~ nil & (aModel ~~ model)		ifTrue: [aModel addDependent: self].	model := aModel.	aController ~~ nil		ifTrue: 			[aController view: self.			aController model: aModel].	controller := aController! !!View methodsFor: 'display box access'!computeBoundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of the 	receiver's subViews. If the receiver has no subViews, then the bounding 	box is the receiver's window. Subclasses should redefine 	View|boundingBox if a more suitable default for the case of no subViews 	is available."	| aRectangle |	subViews isEmpty ifTrue: [^self getWindow].	aRectangle := self firstSubView transform: self firstSubView boundingBox.	subViews do: 		[:aView | 		aRectangle := aRectangle merge: (aView transform: aView boundingBox).].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'display box access' stamp: 'acg 2/23/2000 00:08'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: [insetDisplayBox := self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'display transformation'!displayTransformation	"Answer a WindowingTransformation that is the result of composing all 	local transformations in the receiver's superView chain with the 	receiver's own local transformation. The resulting transformation 	transforms objects in the receiver's coordinate system into objects in the 	display screen coordinate system."	displayTransformation == nil		ifTrue: [displayTransformation := self computeDisplayTransformation].	^displayTransformation! !!View methodsFor: 'displaying'!displayClippingTo: rect	| bigRect |	bigRect := rect insetBy: -1.	self clippingTo: bigRect do: [Display clippingTo: bigRect do: [self display]]! !!View methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	self resetSubViews.	transformation := WindowingTransformation identity.	self borderWidth: 0! !!View methodsFor: 'initialize-release'!release	"Remove the receiver from its model's list of dependents (if the model	exists), and release all of its subViews. It is used to break possible cycles	in the receiver and should be sent when the receiver is no longer needed.	Subclasses should include 'super release.' when redefining release."	model removeDependent: self.	model := nil.	controller release.	controller := nil.	subViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].	subViews := nil.	superView := nil! !!View methodsFor: 'initialize-release'!setDefaultBackgroundColor	"Obtain the background color from the receiver's model, unless the #uniformWindowColors preference is set to true, in which case obtain it from generic Object; and install it as the receiver's background color.  5/1/96 sw"	| colorToUse |	colorToUse := Preferences uniformWindowColors		ifTrue:			[Object new defaultBackgroundColor]		ifFalse:			[model defaultBackgroundColor].	self backgroundColor: colorToUse! !!View methodsFor: 'lock access'!lock	"'Lock' the receiver and all of its subViews (see View|isLocked). This has 	the effect of computing and storing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews. The locking 	and unlocking of a View is handled automatically by the internal 	methods of the View, but can also be done explicitly if desired."	self isLocked ifTrue: [^self].	displayTransformation := self computeDisplayTransformation.	insetDisplayBox := self computeInsetDisplayBox.	subViews do: [:aSubView | aSubView lock]! !!View methodsFor: 'lock access'!unlock	"Unlock the receiver and all of its subViews (see View|isUnlocked). This 	has the effect of forcing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews to be 	recomputed the next time they are referenced. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired."	self isUnlocked ifTrue: [^self].	displayTransformation := nil.	insetDisplayBox := nil.	subViews do: [:aSubView | aSubView unlock]! !!View methodsFor: 'miscellaneous' stamp: 'JMM 10/21/2003 18:12'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click delay |	delay := Delay forMilliseconds: 10.	frame := startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click := false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[delay wait.		click := click | Sensor anyButtonPressed.		newFrame := newFrameBlock value: frame.		newFrame := newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame := newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!View methodsFor: 'scrolling'!scrollBy: aPoint 	"The x component of aPoint specifies the amount of scrolling in the x 	direction; the y component specifies the amount of scrolling in the y 	direction. The amounts are specified in the receiver's local coordinate 	system. Scroll the receiver up or down, left or right. The window of the 	receiver is kept stationary and the subViews and other objects in the 	receiver are translated relative to it. Scrolling doesn't change the 	insetDisplayBox or the viewport since the change in the transformation 	is canceled by the change in the window. In other words, all display 	objects in the view, except the window, are translated by the scrolling 	operation.	Note: subclasses may override to return false if no scrolling takes place."	| aRectangle |	aRectangle := insetDisplayBox.	transformation := transformation scrollBy: aPoint.	window := self getWindow translateBy: aPoint x negated @ aPoint y negated.	self unlock.	insetDisplayBox := aRectangle.	^ true! !!View methodsFor: 'subView access'!resetSubViews	"Set the list of subviews to an empty collection."		subViews := OrderedCollection new! !!View methodsFor: 'testing'!isObscured	| topController displayRect |	(topController := self topView controller)		== ScheduledControllers activeController			ifTrue: [^false].	displayRect := self insetDisplayBox.	ScheduledControllers scheduledControllers do: [:ctrlr |		ctrlr == topController ifTrue: [^false].		(displayRect intersects: ctrlr view insetDisplayBox)			ifTrue: [^true]].	self error: 'not in ScheduledControllers'.	^false! !!View methodsFor: 'window access'!defaultWindow	"Build the minimum Rectangle that encloses all the windows of the 	receiver's subViews. The answer is a Rectangle obtained by expanding 	this minimal Rectangle by the borderWidth of the receiver. If the 	receiver has no subViews, then a Rectangle enclosing the entire display 	screen is answered. It is used internally by View methods if no window 	has been specified for the View. Specialized subclasses of View should 	redefine View|defaultWindow to handle the default case for instances 	that have no subViews."	| aRectangle |	subViews isEmpty ifTrue: [^DisplayScreen boundingBox].	aRectangle := self firstSubView viewport.	subViews do: [:aView | aRectangle := aRectangle merge: aView viewport].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'private'!getViewport	"Answer the Rectangle representing the View's viewport (in the	coordinate system of the superclass). If no viewport has been specified,	the View's window transformed into the superView's coordinate system is	saved and returned. It should be used by methods of View and subclasses	(instead of directly referring to the viewport) unless it is known that a	viewport actually exists. It should not be used outside of View or	subclasses because the viewport is not sharable."	viewport == nil ifTrue: [viewport := (self transform: self getWindow) truncated].	^viewport! !!View methodsFor: 'private'!setTransformation: aTransformation 	"Set the View's local transformation to aTransformation, unlock the View 	(see View|unlock), and set the viewport to undefined (this forces it to be 	recomputed when needed). Should be used instead of setting the 	transformation directly."	transformation := aTransformation.	self unlock.	viewport := nil! !!View methodsFor: 'private'!setWindow: aWindow 	"Set the View's window to aWindow and unlock the View (see	View|unlock). View|setWindow should be used by methods of View and	subclasses to set the View window (rather than directly setting the	instance variable) to insure that the View is unlocked."	window := aWindow.	viewport := nil.	self unlock! !!View methodsFor: 'private'!superView: aView 	"Set the View's superView to aView and unlock the View (see	View|unlock). It is sent by View|addSubView: in order to properly set all	the links."	superView := aView.	self unlock! !!Viewer methodsFor: 'access' stamp: 'sw 10/20/1998 13:20'!scriptedPlayer: aPlayer	scriptedPlayer := aPlayer! !!Viewer methodsFor: 'commands' stamp: 'yo 1/14/2005 19:57'!chooseVocabulary	"Put up a menu allowing the user to specify which protocol to use in this viewer"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a vocabulary' translated.	"aMenu addStayUpItem."  "For debugging only"	Vocabulary allStandardVocabularies do:		[:aVocabulary |			(scriptedPlayer class implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					aVocabulary == self currentVocabulary ifTrue:						[aMenu lastItem color: Color blue]. 					aMenu balloonTextForLastItem: aVocabulary documentation]].	aMenu popUpInWorld: self currentWorld! !!Viewer methodsFor: 'commands' stamp: 'sw 1/26/2001 15:26'!newPermanentScript	"Create a new, empty script and attach it to the hand"	| aMorph |	self scriptedPlayer assureUniClass.	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newPermanentScript toValue: true.	aMorph setProperty: #newPermanentPlayer toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!Viewer methodsFor: 'commands' stamp: 'nb 6/17/2003 12:25'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList := (aPlayer := scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ Beeper beep].	itsCurrent := aPlayer costume renderedMorph.	anIndex := aList indexOf: itsCurrent ifAbsent: [nil].	newIndex := anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex := 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !!Viewer methodsFor: 'commands' stamp: 'nb 6/17/2003 12:25'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList := (aPlayer := scriptedPlayer) availableCostumesForArrows.	aList isEmptyOrNil ifTrue: [^ Beeper beep].	itsCurrent := aPlayer costume renderedMorph.	anIndex := aList indexOf: itsCurrent ifAbsent: [nil].	newIndex := anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex := aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter ifNotNil: [self presenter updateViewer: self]! !!Viewer methodsFor: 'copying' stamp: 'tk 1/7/1999 17:01'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.scriptedPlayer := deepCopier references at: scriptedPlayer ifAbsent: [scriptedPlayer].! !!Viewer methodsFor: 'copying' stamp: 'tk 1/8/1999 07:42'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.scriptedPlayer := scriptedPlayer.		"Weakly copied"	"Store into it to satisfy checkVariables"! !!Viewer methodsFor: 'queries'!aboutMethod: aSelector 	"Give the user documentation for the selector"	| aClass help |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	help := aClass firstCommentAt: aSelector.	help		ifNotNil: [self				inform: (help string withNoLineLongerThan: 25)]! !!Viewer methodsFor: 'queries'!browseMethodFull: aSelector 	"Open a traditional browser on aSelector, in whatever class implements 	aSelector "	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	Browser fullOnClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries' stamp: 'sd 1/16/2004 21:10'!browseMethodInheritance: aSelector 	"Open an inheritance browser on aSelector"	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	self systemNavigation methodHierarchyBrowserForClass: aClass selector: aSelector! !!Viewer methodsFor: 'queries'!browseVersionsOf: aSelector 	"Open a browser on versions of aSelector"	| aClass |	aClass := scriptedPlayer class whichClassIncludesSelector: aSelector.	Utilities browseVersionsForClass: aClass selector: aSelector! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:01'!angleToPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaAngleToTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 9/28/2004 18:24'!bounceOnColorPhrase	| outerPhrase bounceOn |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	bounceOn := KedamaBounceOnColorTile new.	"upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	outerPhrase addMorphBack: bounceOn.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 9/27/2004 15:07'!bounceOnPhrase	| outerPhrase upHill |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	upHill := KedamaBounceOnTile new.	"upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer)."	outerPhrase addMorphBack: upHill.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 10/12/2004 22:56'!colorComponentPhraseFor: componentName	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaGetColorComponentTile new.	getTile componentName: componentName.	getTile setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:01'!distanceToPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaDistanceToTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:02'!patchUphillPhrase	| outerPhrase upHill |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	upHill := KedamaUpHillTile new.	upHill setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: upHill.	^outerPhrase.! !!Viewer methodsFor: 'special phrases' stamp: 'yo 6/18/2004 16:50'!patchValuePhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Number				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaGetPixelValueTile new.	getTile setPatchDefaultTo: (scriptedPlayer defaultPatchPlayer).	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'dgd 2/22/2003 19:02'!seesColorPhrase	"In classic tiles, answer a complete phrase that represents the seesColor test"	| outerPhrase seesColorTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Boolean				rcvrType: #Player				argType: #Color.	"temp dummy"	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs second) delete.	"operator"	seesColorTile := TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs second) goBehind.	"Make it third"	"	selfTile := self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new 				typeColor: (ScriptingSystem colorForType: #Color)).	^outerPhrase! !!Viewer methodsFor: 'special phrases' stamp: 'yo 3/7/2005 08:39'!turtleOfPhrase	| outerPhrase getTile |	outerPhrase := PhraseTileMorph new 				setOperator: #+				type: #Player				rcvrType: #Player				argType: #Color.	"temp dummy"	(outerPhrase submorphs second) delete.	"operator"	(outerPhrase submorphs second) delete.	"color"	getTile := KedamaTurtleOfTile new.	outerPhrase addMorphBack: getTile.	^outerPhrase! !!Viewer methodsFor: 'transition' stamp: 'sw 11/5/1998 15:48'!noteDeletionOf: aMorph	| pal |	aMorph player == scriptedPlayer ifTrue:		[(pal := self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!ViewerEntry methodsFor: 'menu' stamp: 'sw 11/9/1998 13:57'!codePaneMenu: aMenu shifted: shifted	^ aMenu 		labels: 'menueventuallywillbeuseful'		lines: #(1)		selections: #(beep flash beep flash beep)! !!ViewerEntry methodsFor: 'contents' stamp: 'nb 6/17/2003 12:25'!contents: c notifying: k	"later, spruce this up so that it can accept input such as new method source"	| info |	(info := self userSlotInformation)		ifNotNil:			[info documentation: c.			^ true].	Beeper beep.	^ false! !!ViewerEntry methodsFor: 'contents' stamp: 'sw 11/5/1998 09:31'!contentsSelection	"Not well understood why this needs to be here!!"	^ 1 to: 0! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:32'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 1.0		g: 0.985		b: 0.985! !!ViewerEntry methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:07'!initialize"initialize the state of the receiver"	super initialize.""	self layoutInset: 0! !!ViewerEntry methodsFor: 'access' stamp: 'sw 11/5/1998 10:09'!entryType	^ self viewerRow entryType! !!ViewerEntry methodsFor: 'access' stamp: 'sw 12/28/1998 13:01'!playerBearingCode	^ owner owner scriptedPlayer! !!ViewerEntry methodsFor: 'access' stamp: 'sw 11/5/1998 10:09'!viewerRow	"Answer the ViewerRow object, that contains the controls and the phraseTile"	^ submorphs first! !!ViewerEntry methodsFor: 'slot' stamp: 'sw 1/13/1999 12:57'!slotName	"Assuming the receiver represents a slot, return its name"	^  self viewerRow elementSymbol! !!ViewerEntry methodsFor: 'slot' stamp: 'sw 12/28/1998 12:50'!userSlotInformation	"If the receiver represents a user-defined slot, then return its info; if not, retun nil"	| aSlotName info |	((self entryType == #systemSlot) or: [self entryType == #userSlot])		ifFalse:			[^ nil].	aSlotName := self slotName.	^ ((info := self playerBearingCode slotInfo) includesKey: aSlotName)		ifTrue:			[info at: aSlotName]		ifFalse:			[nil]! !!ViewerLine methodsFor: 'access' stamp: 'sw 10/30/2001 12:43'!elementSymbol: aSymbol	"Set the element symbol"	elementSymbol := aSymbol! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/1/2005 10:55'!morphsBearingPlayers	| c |	c := OrderedCollection new.	self allMorphsWithPlayersDo: [:e :p | c add: e].	^ c asArray.! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/6/2005 14:59'!replacePlayerInReadoutWith: aPlayer 	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.	self allMorphsDo: [:e |		((e isMemberOf: UpdatingStringMorph) or: [e isMemberOf: UpdatingRectangleMorph]) ifTrue: [			e target isPlayerLike ifTrue: [				e target: aPlayer			].		].	].! !!ViewerLine methodsFor: 'access' stamp: 'yo 4/6/2005 14:59'!replacePlayerWith: aPlayer	| tile |	tile := self firstMorphBearingKedamaPlayer.	tile ifNil: [^ self].	(tile isMemberOf: TileMorph) ifFalse: [^ self].	tile type = #objRef ifFalse: [^ self].	tile referToSimilarObject: aPlayer.! !!ViewerLine methodsFor: 'slot' stamp: 'sw 6/6/2003 21:47'!addCommandFeedback	"Add screen feedback showing what would be torn off in a drag"	| aMorph |	aMorph := RectangleMorph new bounds: ((submorphs fourth topLeft - (2@1)) corner: (submorphs last bottomRight) + (2@0)).	aMorph useRoundedCorners; beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph! !!ViewerLine methodsFor: 'slot' stamp: 'sw 8/31/2004 23:50'!addGetterFeedback	"Add feedback during mouseover of a getter"	| aMorph endMorph |	endMorph :=		(#(touchesA: #seesColor: #overlaps:) includes: self elementSymbol)			ifTrue:				[submorphs eighth]			ifFalse:				[submorphs sixth].	aMorph := RectangleMorph new useRoundedCorners bounds: ((submorphs fourth topLeft - (2@-1)) corner: (endMorph bottomRight + (2@-1))).	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.355 b: 0.839); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph"Color fromUser (Color r: 1.0 g: 0.355 b: 0.839)"! !!ViewerLine methodsFor: 'slot' stamp: 'sw 5/22/2003 04:30'!addSetterFeedback	"Add screen feedback showing what would be torn off to make a setter"	| aMorph |	aMorph := RectangleMorph new bounds: ((submorphs fourth topLeft - (2@1)) corner: (submorphs last bottomRight) + (2@0)).	aMorph useRoundedCorners; beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.548 b: 0.452); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph! !!ViewerRow methodsFor: 'access' stamp: 'sw 2/1/1999 13:00'!elementSymbol	^ elementSymbol! !!ViewerRow methodsFor: 'access' stamp: 'sw 1/13/1999 12:47'!elementSymbol: aSymbol	elementSymbol := aSymbol! !!ViewerRow methodsFor: 'access' stamp: 'sw 5/25/2001 10:36'!entryType	"Answer one of: #systemSlot #userSlot #systemScript #userScript"	^ self playerBearingCode elementTypeFor: elementSymbol vocabulary: self currentVocabulary! !!ViewerRow methodsFor: 'access' stamp: 'sw 12/28/1998 13:10'!playerBearingCode	^ owner playerBearingCode! !!ViewerRow methodsFor: 'initialization' stamp: 'ar 11/9/2000 20:44'!initialize	super initialize.	self layoutInset: 1! !!Vocabulary methodsFor: '*eToys-queries' stamp: 'yo 2/19/2005 23:41'!tileWordingForSelector: aSelector	"Answer the wording to emblazon on tiles representing aSelector"	| anInterface inherent |	anInterface := self methodInterfaceAt: aSelector asSymbol ifAbsent:		[inherent := Utilities inherentSelectorForGetter: aSelector.		^ inherent			ifNil:				[self translatedWordingFor: aSelector]			ifNotNil:				[inherent translated]].	^ anInterface wording! !!Vocabulary class methodsFor: '*eToys-type vocabularies' stamp: 'mir 7/15/2004 10:54'!newWonderlandVocabulary	"Answer a Wonderland vocabulary -- highly experimental"	| aVocabulary  |	"Vocabulary newWonderlandVocabulary"	aVocabulary := Vocabulary new vocabularyName: #Wonderland.	aVocabulary documentation: 'A simple vocabulary for scripting Alice objects'.	aVocabulary initializeFromTable:  #(		(color color: () Color (basic color) 'The color of the object' unused updating)		"--"		(getX setX: () Number (basic geometry) 'The x position' unused updating)		(getY setY: () Number (basic geometry) 'The y position' unused updating)		(getZ setZ: () Number (basic geometry) 'The z position' unused updating)		"--"		(width setWidth: () Number (geometry) 'The width of the object' unused updating)		(height setHeight: () Number (geometry) 'The height of the object' unused updating)		(depth setDepth: () Number (geometry) 'The depth of the object' unused updating)		"--"		(heading setHeading: () Number (basic geometry) 'The heading of the object' unused updating)		(forwardBy: unused ((distance Number)) none (basic motion) 'Moves the object by the specified distance' 'forward by')		(turnBy: unused ((angle Number)) none (basic motion) 'Turns the object by the specified number of degrees' 'turn by')		(graphic setGraphic: () Graphic (basic graphics) 'The picture currently being worn' unused updating)		(animationIndex setAnimationIndex: () Number (graphics) 'The index in the object''s animation chain' unused updating)		(emptyScript unused () none (scripts) 'The empty script')		(distanceToCamera setDistanceToCamera: () Number (geometry) 'The distance of the object from the camera' unused updating)		(distanceTo: unused ((target Player)) Number (geometry) 'The distance of the object to the given target')	).	^ aVocabulary! !!WatcherWrapper methodsFor: 'accessing' stamp: 'sw 1/6/2005 04:18'!getterTilesForDrop	"Answer getter tiles to use if there is an attempt to drop me onto a tile pad"	| aCategoryViewer |	aCategoryViewer := CategoryViewer new initializeFor: player categoryChoice: #basic.	^ aCategoryViewer getterTilesFor: (Utilities getterSelectorFor: variableName)  type: self resultType! !!WatcherWrapper methodsFor: 'initialization' stamp: 'tak 4/6/2005 13:07'!player: aPlayer variableName: aVariableName	"Set up my initial state"	player := aPlayer.	variableName := aVariableName.	self reconstituteName! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject := WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported :=false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported := (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'private' stamp: 'di 5/21/2001 21:49'!finalizationProcess	[true] whileTrue:		[FinalizationSemaphore wait.		FinalizationLock critical:			[FinalizationDependents do:				[:weakDependent |				weakDependent ifNotNil:					[weakDependent finalizeValues.					"***Following statement is required to keep weakDependent					from holding onto its value as garbage.***"					weakDependent := nil]]]			ifError:			[:msg :rcvr | rcvr error: msg].		].! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish hash |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ar 7/1/2003 15:15'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish hash |	finish := array size.	finish > 4096		ifTrue: [hash := anObject identityHash * (finish // 4096)]		ifFalse: [hash := anObject identityHash].	start := (hash \\ array size) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index := self findElementOrNil: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:00'!finalizeValues	"remove all nil keys and rehash the receiver afterwards"	| assoc |	1 to: array size do:[:i|		assoc := array at: i.		(assoc notNil and:[assoc key == nil]) ifTrue:[array at: i put: nil].	].	self rehash.! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 10/21/2000 20:01'!finalizeValues: finiObjects	"Remove all associations with key == nil and value is in finiObjects.	This method is folded with #rehash for efficiency."	| oldArray assoc newIndex |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do:[:i|		assoc := oldArray at: i.		assoc ifNotNil:[			(assoc key == nil and:[finiObjects includes: assoc value]) ifFalse:[				newIndex := self scanForNil: assoc key.				self atNewIndex: newIndex put: assoc].		].	].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:56'!rehash	"Rehash the receiver. Reimplemented to allow for multiple nil keys"	| oldArray assoc newIndex |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do:[:i|		assoc := oldArray at: i.		assoc ifNotNil:[			newIndex := self scanForNil: assoc key.			self atNewIndex: newIndex put: assoc.		].	].! !!WeakKeyDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"ar 10/21/2000: The method has been copied to this location to indicate that whenever #scanFor: changes #scanForNil: must be changed in the receiver as well."	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 10/21/2000 19:46'!scanForNil: anObject	"Private. Scan the key array for the first slot containing nil (indicating an empty slot). Answer the index of that slot."	| start finish |	start := (anObject hash \\ array size) + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | (array at: index) == nil ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:15'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: newObject.	((array at: index) == flag or: [(array at: index) isNil])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakSet methodsFor: 'public' stamp: 'nk 3/11/2002 20:35'!collect: aBlock	| each newSet |	newSet := self species new: self size.	tally = 0 ifTrue: [^newSet ].	1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [newSet add: (aBlock value: each)]		].	^newSet! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:46'!do: aBlock	| each |	tally = 0 ifTrue: [^self].	1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/30/2000 13:13'!do: aBlock after: anElement	| each startIndex |	tally = 0 ifTrue: [^self].	startIndex := anElement ifNil: [1] ifNotNil:		[self findElementOrNil: anElement].	startIndex + 1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 16:02'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index element |	^(index := self scanFor: anObject) = 0		ifFalse: [(element := array at: index) == flag ifFalse: [element]]! !!WeakSet methodsFor: 'public' stamp: 'di 2/3/2001 16:46'!printElementsOn: aStream	| oldPos |	aStream nextPut: $(.	oldPos := aStream position.	self do: [:element | aStream print: element; space].	aStream position > oldPos ifTrue: [aStream skip: -1 "remove the extra space"].	aStream nextPut: $)! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:08'!remove: oldObject ifAbsent: aBlock	| index |	index := self findElementOrNil: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally := tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!WeakSet methodsFor: 'public' stamp: 'SqR 8/23/2000 15:17'!slowSize	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	tally := array inject: 0 into:		[:total :each | (each == nil or: [each == flag])			ifTrue: [total] ifFalse: [total + 1]].	^tally! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 14:30'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex := index.	length := array size.	[oldIndex = length			ifTrue: [oldIndex := 1]			ifFalse: [oldIndex := oldIndex + 1].	(element := self keyAt: oldIndex) == flag]		whileFalse: 			[newIndex := self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!WeakSet methodsFor: 'private' stamp: 'SqR 8/23/2000 15:43'!growTo: anInteger	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := WeakArray new: anInteger.	array atAllPut: flag.	tally := 0.	oldElements do:		[:each | (each == flag or: [each == nil]) ifFalse: [self noCheckAdd: each]]! !!WeakSet methodsFor: 'private' stamp: 'nice 4/4/2006 22:09'!initialize: n	"Initialize array to an array size of n"	flag := Object new.	array := WeakArray new: n.	array atAllPut: flag.	tally := 0! !!WeakSet methodsFor: 'private' stamp: 'md 10/5/2005 15:44'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == flag or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'private' stamp: 'yo 11/11/2002 23:10'!scanForLoadedSymbol: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start := (anObject hash \\ array size) + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == flag or: [element asString = anObject asString])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'r++ 5/27/2000 18:11'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key := aKey.	self value: anObject! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self findElementOrNil: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!Week class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 15:10'!starting: aDateAndTime duration: aDuration	"Override - the duration is always one week.	 Week will start from the Week class>>startDay"	| midnight delta adjusted |	midnight _ aDateAndTime asDateAndTime midnight.	delta _ ((midnight dayOfWeek + 7 - (DayNames indexOf: self startDay)) rem: 7) abs.	adjusted _ midnight - (Duration days: delta seconds: 0).	^ super starting: adjusted duration: (Duration weeks: 1).! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!= anObject	^self species == anObject species and: [		self wideCharacterMap = anObject wideCharacterMap ]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/10/2006 00:26'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 8. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 22:27'!hash	^self map hash! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:29'!species	^self hasWideCharacters		ifTrue: [WideCharacterSet]		ifFalse: [CharacterSet]! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 5/9/2006 23:14'!wideCharacterMap	^map! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: [WordArray new: 2048].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/10/2006 00:21'!do: aBlock 	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | aBlock						value: (Character value: ((high bitShift: 16) bitOr: low))]]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:49'!includes: aCharacter 	| val high low |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	^(self		bitmap: (map				at: high				ifAbsent: [^ false])		at: low) isZero not! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 22:45'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := (map				at: high				ifAbsent: [^ aCharacter]) self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 5/9/2006 23:00'!size	| size |	size := 0.	map		keysAndValuesDo: [:high :lowmap | self				bitmap: lowmap				do: [:low | size := size + 1]].	^ size! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/10/2006 00:10'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:46'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 5/9/2006 22:47'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -5.	bitIndex := shortInteger bitAnd: 16r1F.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!WideCharacterSet methodsFor: 'testing' stamp: 'nice 5/9/2006 23:25'!hasWideCharacters	"Answer true if i contain any wide character"		self do: [:e | e asciiValue >= 256 ifTrue: [^true]].	^false! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 5/9/2006 22:31'!initialize	map := Dictionary new.! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 3/23/2007 02:29'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self! !!WideCharacterSet commentStamp: 'nice 5/9/2006 23:33' prior: 0!WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.Implementation should be efficient in memory if sets are sufficently sparse.Wide Characters are at most 32bits.We split them into 16 highBits and 16 lowBits.map is a dictionary key: 16 highBits value: map of 16 lowBits.Maps of lowBits  are stored as arrays of bits in a WordArray.If a bit is set to 1, this indicate that corresponding character is present.Only 2048 entries are necessary in each lowmap.And only lowmap corresponding to a present high value are stored.!!WideString methodsFor: 'accessing' stamp: 'yo 10/31/2002 22:29'!byteAt: index	| d r |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	^ (self wordAt: d) digitAt: ((4 - r) + 1).! !!WideString methodsFor: 'accessing' stamp: 'yo 11/3/2002 13:19'!byteAt: index put: aByte	| d r w |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	w := (self wordAt: d) bitAnd: ((16rFF<<((4 - r)*8)) bitInvert32).	w := w + (aByte<<((4 - r)*8)).	self basicAt: d put: w.	^ aByte.! !!WideString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:46'!asFourCode	| result |	self size = 1 ifFalse: [^self error: 'must be exactly four octets'].	result := self basicAt: 1.	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!WideString methodsFor: 'converting' stamp: 'yo 8/28/2002 14:47'!asPacked	self inject: 0 into: [:pack :next | pack := pack * 16r100000000 + next asInteger].! !!WideString methodsFor: 'converting' stamp: 'yo 3/14/2005 11:41'!copyFrom: start to: stop	| n |	n := super copyFrom: start to: stop.	n isOctetString ifTrue: [^ n asOctetString].	^ n.! !!WideString methodsFor: 'private' stamp: 'ar 4/9/2005 22:31'!mutateJISX0208StringToUnicode	| c |	1 to: self size do: [:i |		c := self at: i.		(c leadingChar = JISX0208 leadingChar or: [			c leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [			self basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.		]	].! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:01'!allMethodsWithEncodingTag: encodingTag	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								(self string: (class sourceCodeAt: s) asString hasEncoding: encodingTag) ifTrue: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/12/2003 17:14'!allMultiStringMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								((class sourceCodeAt: s) asString isOctetString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'enumeration' stamp: 'yo 8/27/2003 07:00'!allNonAsciiMethods  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| list adder num i |	list := Set new.	adder := [ :mrClass :mrSel |		list add: (			MethodReference new				setStandardClass: mrClass				methodSymbol: mrSel		)	].	num := CompiledMethod allInstances size.	i := 0.	'processing...' displayProgressAt: Sensor cursorPoint from: 0 to: num during: [:bar |		SystemNavigation new allBehaviorsDo: [ :class |			class selectors do: [:s |				bar value: (i := i + 1).								((class sourceCodeAt: s) asString isAsciiString) ifFalse: [					adder value: class value: s.				]			]		]	].	^ list.! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 19:38'!fromByteArray: aByteArray 	| inst |	aByteArray size \\ 4 = 0 ifFalse: [^ ByteString fromByteArray: aByteArray ].	inst := self new: aByteArray size // 4.	4 to: aByteArray size by: 4 do: [:i |		inst basicAt: i // 4			put: ((aByteArray at: i - 3) << 24) + 				((aByteArray at: i - 2) << 16) +				 ((aByteArray at: i - 1) << 8) +				(aByteArray at: i)	].	^ inst! !!WideString class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:00'!fromISO2022JPString: string 	| tempFileName stream contents |	tempFileName := Time millisecondClockValue printString , '.txt'.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	stream := StandardFileStream fileNamed: tempFileName.	[stream nextPutAll: string]		ensure: [stream close].	stream := FileStream fileNamed: tempFileName.	contents := stream contentsOfEntireFile.	FileDirectory default deleteFileNamed: tempFileName ifAbsent: [].	^ contents! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 19:58'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s val |	s := self new: 1.	val := (((aLong digitAt: 4) << 24) bitOr:((aLong digitAt: 3) << 16))				bitOr: (((aLong digitAt: 2) << 8) bitOr: (aLong digitAt: 1)).	s basicAt: 1 put: val.	^ s."WideString fromPacked: 'TEXT' asPacked"! !!WideString class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:39'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."	| inst |	(aString isMemberOf: self) ifTrue: [		^ aString copy.	].	inst := self new: aString size.	1 to: aString size do: [:pos |		inst basicAt: pos put: (aString basicAt: pos).	].	^ inst.! !!WideString class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 20:00'!from: aString 	| newString |	(aString isMemberOf: self)		ifTrue: [^ aString copy].	newString := self new: aString size.	1 to: aString size do: [:index | newString basicAt: index put: (aString basicAt: index)].	^ newString! !!WideStringTest methodsFor: 'tests - substrings' stamp: 'nice 3/23/2007 01:52'!testSubstrings	"this is related to http://bugs.squeak.org/view.php?id=6367"		| w1 w2 |	w1 := WideString with: 401 asCharacter with: $a with: 402 asCharacter with: $b.	w2 := WideString with: 403 asCharacter with: 404 asCharacter.	self assert: w1 substrings first = w1.	self assert: (w1 , ' ' , w2) substrings size = 2.	self assert: (w1 , ' ' , w2) substrings last = w2.! !!WideSymbol methodsFor: 'accessing' stamp: 'ar 4/10/2005 23:38'!byteAt: index	| d r |	d := (index + 3) // 4.	r := (index - 1) \\ 4 + 1.	^ (self wordAt: d) digitAt: ((4 - r) + 1).! !!WideSymbol methodsFor: 'private' stamp: 'ar 4/12/2005 14:12'!fixUponLoad: aProject seg: anImageSegment	"We are in an old project that is being loaded from disk. 	Fix up conventions that have changed."	| ms |	"Yoshiki did not put MultiSymbols into outPointers in older images!!	When all old images are gone, remove this method."	ms := Symbol intern: self asString.	self == ms ifFalse: [		"For a project from older m17n image, this is necessary."		self becomeForward: ms.		aProject projectParameters at: #MultiSymbolInWrongPlace put: true	].	"MultiString>>capitalized was not implemented correctly. 	Fix eventual accessors and mutators here."	((self beginsWith: 'get')		and:[(self at: 4) asInteger < 256		and:[(self at: 4) isLowercase]]) ifTrue:[			ms := self asString.			ms at: 4 put: (ms at: 4) asUppercase.			ms := ms asSymbol.			self becomeForward: ms.			aProject projectParameters at: #MultiSymbolInWrongPlace put: true.		].	((self beginsWith: 'set')		and:[(self at: 4) asInteger < 256		and:[(self at: 4) isLowercase		and:[self last = $:		and:[(self occurrencesOf: $:) = 1]]]]) ifTrue:[			ms := self asString.			ms at: 4 put: (ms at: 4) asUppercase.			ms := ms asSymbol.			self becomeForward: ms.			aProject projectParameters at: #MultiSymbolInWrongPlace put: true.		].	^ super fixUponLoad: aProject seg: anImageSegment	"me, not the label"! !!WideSymbol methodsFor: 'private' stamp: 'yo 7/29/2005 21:53'!mutateJISX0208StringToUnicode	| c |	1 to: self size do: [:i |		c := self at: i.		(c leadingChar = JISX0208 leadingChar or: [			c leadingChar = (JISX0208 leadingChar bitShift: 2)]) ifTrue: [			self basicAt: i put: (Character leadingChar: JapaneseEnvironment leadingChar code: (c asUnicode)) asciiValue.		]	].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07'!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!WindowingTransformation methodsFor: 'applying transform'!applyInverseTo: anObject 	"Apply the inverse of the receiver to anObject and answer the result. 	Used to map some object in destination coordinates to one in source 	coordinates."	| transformedObject |	transformedObject := anObject translateBy: translation x negated @ translation y negated.	scale == nil		ifFalse: [transformedObject := transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!applyTo: anObject 	"Apply the receiver to anObject and answer the result. Used to map some 	object in source coordinates to one in destination coordinates."	| transformedObject |	scale == nil		ifTrue: [transformedObject := anObject]		ifFalse: [transformedObject := anObject scaleBy: scale].	transformedObject := transformedObject translateBy: translation.	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!compose: aTransformation 	"Answer a WindowingTransformation that is the composition of the 	receiver and aTransformation. The effect of applying the resulting 	WindowingTransformation to an object is the same as that of first 	applying aTransformation to the object and then applying the receiver to 	its result."	| aTransformationScale newScale newTranslation |	aTransformationScale := aTransformation scale.	scale == nil		ifTrue: 			[aTransformation noScale				ifTrue: [newScale := nil]				ifFalse: [newScale := aTransformationScale].			newTranslation := translation + aTransformation translation]		ifFalse: 			[aTransformation noScale				ifTrue: [newScale := scale]				ifFalse: [newScale := scale * aTransformationScale].			newTranslation := translation + (scale * aTransformation translation)].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'scrolling'!scrollBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint scaled by 	the current scale. It is used when the translation is known in source 	coordinates, rather than scaled source coordinates (see 	WindowingTransformation|translateBy:). An example is that of scrolling 	objects with respect to a stationary window in the source coordinate 	system. If no scaling is in effect (scale = nil), then 	WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	| newTranslation |	scale == nil		ifTrue: [newTranslation := aPoint]		ifFalse: [newTranslation := scale * aPoint].	^self translateBy: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!scaleBy: aScale 	"Answer a WindowingTransformation with the scale and translation of 	the receiver both scaled by aScale."	| checkedScale newScale newTranslation |	aScale == nil		ifTrue: 			[newScale := scale.			newTranslation := translation]		ifFalse: 			[checkedScale := self checkScale: aScale.			scale == nil				ifTrue: [newScale := checkedScale]				ifFalse: [newScale := scale * checkedScale].			newTranslation := checkedScale * translation].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'private'!checkScale: aScale	"Convert aScale to the internal format of a floating-point Point." 	| checkedScale |	checkedScale := aScale asPoint.	^checkedScale x asFloat @ checkedScale y asFloat! !!WindowingTransformation methodsFor: 'private'!setScale: aScale translation: aTranslation 	"Sets the scale to aScale and the translation to aTranslation."	scale := aScale.	translation := aTranslation! !!WindowingTransformation class methodsFor: 'instance creation'!window: aWindow viewport: aViewport 	"Answer an instance of me with a scale and translation based on 	aWindow and aViewport. The scale and translation are computed such 	that aWindow, when transformed, coincides with aViewport."	| scale translation |	aViewport width = aWindow width & (aViewport height = aWindow height)		ifTrue:			[scale := nil]		ifFalse:			[scale := aViewport width asFloat / aWindow width asFloat						@ (aViewport height asFloat / aWindow height asFloat)].	scale == nil		ifTrue: [translation := aViewport left - aWindow left								@ (aViewport top - aWindow top)]		ifFalse: [translation := aViewport left - (scale x * aWindow left)								@ (aViewport top - (scale y * aWindow top))].	^self new setScale: scale translation: translation! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:52'!* other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primMulScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primMulScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primMulArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 14:58'!+ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primAddScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primAddScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primAddArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primAddArray: self and: other into: result.	].	^ super + other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:52'!- other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primSubScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primSubScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primSubArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primSubArray: self and: other into: result.	].	^ super - other.! !!WordArray methodsFor: 'array arithmetic' stamp: 'yo 10/25/2004 15:53'!/ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primDivScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primDivScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primDivArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primDivArray: self and: other into: result.	].	^ super / other.! !!WordArray class methodsFor: 'as yet unclassified' stamp: 'RAA 5/17/2001 16:07'!bobsTest	| wa s1 s2 wa2 answer rawData |"WordArray bobsTest"	answer := OrderedCollection new.	wa := WordArray with: 16r01020304 with: 16r05060708.	{false. true} do: [ :pad |		0 to: 3 do: [ :skip |			s1 := RWBinaryOrTextStream on: ByteArray new.			s1 next: skip put: 0.		"start at varying positions"			wa writeOn: s1.			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"			rawData := s1 contents.			s2 := RWBinaryOrTextStream with: rawData.			s2 reset.			s2 skip: skip.			"get to beginning of object"			wa2 := WordArray newFromStream: s2.			answer add: {				rawData size. 				skip. 				wa2 = wa. 				wa2 asArray collect: [ :each | each radix: 16]			}		].	].	^answer explore! !!Workspace methodsFor: 'variable declarations' stamp: 'sumim 11/26/2006 03:52'!mustDeclareVariableWording		^ mustDeclareVariables not		ifTrue: ['<yes> automatically create variable declaration' translated]		ifFalse: ['<no> automatically create variable declaration' translated]! !!WriteStream methodsFor: 'accessing'!contents	readLimit := readLimit max: position.	^collection copyFrom: 1 to: position! !!WriteStream methodsFor: 'accessing' stamp: 'dc 2/11/2007 14:18'!ensureEndsWith: anObject	"Append anObject to the receiver IFF there is not one on the end."	(position > 0 and: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/26/2003 08:01'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd |	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex].	newEnd _ position + anInteger.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.	position _ newEnd.	^aCollection! !!WriteStream methodsFor: 'accessing' stamp: 'ar 4/12/2005 17:34'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	((collection class == ByteString) and: [		anObject isCharacter and:[anObject isOctetCharacter not]]) ifTrue: [			collection := (WideString from: collection).			^self nextPut: anObject.	].	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position := position + 1.			^collection at: position put: anObject]! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position _ newEnd.! !!WriteStream methodsFor: 'accessing'!size	^readLimit := readLimit max: position! !!WriteStream methodsFor: 'character writing' stamp: 'dc 2/11/2007 14:18'!ensureASpace	"Append a space character to the receiver IFF there is not one on the end."	self ensureEndsWith: Character space! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'yo 8/13/2003 12:18'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator := $!!.	remainder := aString.	[(i := remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder := remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder.	aString includesUnifiedCharacter ifTrue: [		self nextPut: terminator.		self nextPutAll: ']lang['.		aString writeLeadingCharRunsOn: self.	].	self nextPut: terminator.! !!WriteStream methodsFor: 'positioning'!position: anInteger 	"Refer to the comment in PositionableStream|position:."	readLimit := readLimit max: position.	super position: anInteger! !!WriteStream methodsFor: 'positioning'!reset 	"Refer to the comment in PositionableStream|reset."	readLimit := readLimit max: position.	position := 0! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit := position := 0.! !!WriteStream methodsFor: 'positioning' stamp: 'ajh 5/25/2001 20:19'!setToEnd 	"Refer to the comment in PositionableStream|setToEnd."	readLimit := readLimit max: position.	super setToEnd.! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:50'!braceArray: anArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	collection := anArray.	position := 0.	readLimit := 0.	writeLimit := anArray size.! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger   " anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize _ collection size.     newSize := anInteger + (oldSize // 4 max: 20).	grownCollection _ collection class new: newSize.	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit _ collection size.! !!WriteStream methodsFor: 'private'!on: aCollection	super on: aCollection.	readLimit := 0.	writeLimit := aCollection size! !!WriteStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection := aCollection.	readLimit := 		writeLimit := lastIndex > (len := collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position := firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!WriteStream methodsFor: 'private' stamp: 'md 2/24/2006 19:50'!pastEndPut: anObject	"Grow the collection by creating a new bigger collection and then	copy over the contents from the old one. We grow by doubling the size	but the growth is kept between 20 and 1000000.	Finally we put <anObject> at the current write position."	| oldSize grownCollection |	oldSize := collection size.	grownCollection := collection class new: oldSize + ((oldSize max: 20) min: 1000000).	collection := grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit := collection size.	collection at: (position := position + 1) put: anObject.	"return the argument - added by kwl"	^ anObject! !!WriteStream methodsFor: 'private'!with: aCollection	super on: aCollection.	position := readLimit := writeLimit := aCollection size! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:22'!testCr	"self debug: #testCr"		| stream |	stream := WriteStream on: 'stream'.	stream cr.	self assert: stream last = Character cr.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:26'!testCrTab	"self debug: #testCrTab"		| stream |	stream := WriteStream on: 'stream'.	stream crtab.	self assert: (stream contents last: 2) = (String with: Character cr with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:28'!testCrTabs	"self debug: #testCrTabs"		| stream |	stream := WriteStream on: 'stream'.	stream crtab: 2.	self assert: (stream contents last: 3) = (String with: Character cr with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:14'!testEnsureASpace	"self debug: #testEnsureASpace"	| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test'.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.		"Manually put a space and verify there are no 2 consecutive spaces"	stream := WriteStream on: String new.	stream nextPutAll: 'this is a test '.	stream ensureASpace.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents = 'this is a test for WriteStreamTest'.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/11/2007 14:17'!testEnsureASpace2	"self debug: #testEnsureASpace2"	| stream |	stream := WriteStream on: String new.	stream ensureASpace.	self assert: stream contents = ' '.	! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:29'!testEnsureNoSpace	"self debug: #testEnsureNoSpace"		| stream |	stream := WriteStream with: 'stream'.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: 'stream '.	stream ensureNoSpace.	self assert: stream contents = 'stream'.		stream := WriteStream with: ' '.	stream ensureNoSpace.	self assert: stream contents = ''.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:39'!testSpace	"self debug: #testSpace"		| stream |	stream := WriteStream on: 'stream'.	stream space.	self assert: stream last = Character space.! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:40'!testSpaces	"self debug: #testSpaces"		| stream |	stream := WriteStream on: 'stream'.	stream space: 3.	self assert: (stream contents last: 3) = '   '! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:42'!testTab	"self debug: #testTab"		| stream |	stream := WriteStream on: 'stream'.	stream tab.	self assert: (stream contents last) = Character tab! !!WriteStreamTest methodsFor: 'tests - character writing' stamp: 'dc 2/14/2007 14:41'!testTabs	"self debug: #testTabs"		| stream |	stream := WriteStream on: 'stream'.	stream tab: 3.	self assert: (stream contents last: 3) = (String with: Character tab with: Character tab with: Character tab)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingOn	"self debug: #testInstanciationUsingOn"	| stream |	stream := WriteStream on: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/11/2007 13:59'!testInstanciationUsingWith	"self debug: #testInstanciationUsingWith"	| stream |	stream := WriteStream with: #(1 2).	stream nextPut: 3.	self assert: stream contents = #(1 2 3)! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 09:24'!testNew	self should: [WriteStream new] raise: Error. ! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:15'!testNextPutAllDifferentFromNextPuts	"self debug: #testNextPutAllDifferentFromNextPuts"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		"nextPutAll verifies the size of the parameter and directly grows the underlying collection of the required size."	|string stream|		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPutAll: 'abc'.	self assert: string = 'z'. "string hasn't been modified because #nextPutAll: detects that 'abc' is bigger than the underlying collection. Thus, it starts by creating a new collection and doesn't modify our variable."		string := String withAll: 'z'.	stream := WriteStream on: string.	stream nextPut: $a; nextPut: $b; nextPut: $c.	self assert: string = 'a'. "The first #nextPut: has no problem and replaces $z by $a in the string. Others will detect that string is too small."! !!WriteStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/24/2007 18:05'!testStreamUseGivenCollection	"self debug: #testStreamUseGivenCollection"		"When a stream is created on a collection, it tries to keep using that collection instead of copying. See thread with title 'Very strange bug on Streams and probably compiler' (Feb 14 2007) on the squeak-dev mailing list."		|string stream|		string := String withAll: 'erased'.	stream := WriteStream on: string.	self assert: string = 'erased'.		stream nextPutAll: 'test'.	self assert: string = 'tested'. "Begining of 'erased' has been replaced by 'test'".! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:12'!testNextPut	"self debug: #testNextPut"	| stream |	stream := WriteStream on: String new.	stream		nextPut: $t;		nextPut: $e;		nextPut: $s;		nextPut: $t.	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPut2	"self debug: #testNextPut2"	| stream |	stream := WriteStream with: 'test'.	stream nextPut: $s.	self assert: stream contents = 'tests'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:13'!testNextPutAll	"self debug: #testNextPutAll"	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: #($t $e $s $t).	self assert: stream contents = 'test'! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'sd 6/5/2005 09:24'!testSetToEnd	| string stream |	string := 'hello'.	stream := WriteStream with: ''.	stream nextPutAll: string.	self assert: stream position = string size.	stream setToEnd.	self assert: stream position = string size.	self assert: stream contents = string! !!WriteStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/14/2007 14:19'!testSize	"self debug: #testSize"	| string streamEmpty streamFull |	string := 'a string'.	streamEmpty := WriteStream on: string.	streamFull := WriteStream with: 'a string'.		self assert: streamEmpty size = 0.	self assert: streamFull size = 8.		streamEmpty nextPut: $..	streamFull nextPut: $..	self assert: streamEmpty size = 1.	self assert: streamFull size = (string size + 1).! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:48'!testPosition	"self debug: #testPosition"		| stream |	stream := WriteStream with: 'an elephant'.	stream position: 6.	self assert: stream contents = 'an ele'.	stream nextPutAll: 'vator'.	stream assert: stream contents = 'an elevator'! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/14/2007 14:52'!testPosition2	"self debug: #testPosition2"		| stream |	stream := WriteStream with: ''.	self should: [stream position: 2] raise: Error.	self should: [stream position: -2] raise: Error.	stream := WriteStream with: 'a test'.	self shouldnt: [stream position: 2] raise: Error.	self should: [stream position: 7] raise: Error.	self should: [stream position: -2] raise: Error.! !!WriteStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/24/2007 17:55'!testReset	"self debug: #testReset"	|stream stream2|	stream := WriteStream with: 'a test ' copy.	stream reset.	stream nextPutAll: 'to test'.	self assert: stream contents = 'to test'.	stream2 := WriteStream with: 'a test ' copy.	stream2 nextPutAll: 'to test'.	self assert: stream2 contents = 'a test to test'! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/27/2007 16:20'!testIsEmpty	| stream |	stream := WriteStream on: String new.	self assert: stream isEmpty.	stream nextPut: $a.	self deny: stream isEmpty.	stream reset.	self deny: stream isEmpty.! !!WriteStreamTest methodsFor: 'tests - testing' stamp: 'edc 4/12/2007 07:01'!testIsEmpty2    self assert: (WriteStream on: (String new: 100)) isEmpty! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement _ XMLStringNode string: aString.	self top addContent: newElement.! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/17/2002 13:13'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:19'!endDocument	self pop.	super endDocument! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement _ self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement _ self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement _ XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 11/30/2000 18:14'!startDocument	self document: XMLDocument new.	self push: self document ! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement _ XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement _ namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement _ XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 6/16/2003 17:20'!defaultNamespace	^self top		ifNotNil: [self top namespace]! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop _ self stack removeLast.	entity _ oldTop.	^oldTop! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity _ anObject! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 8/14/2000 18:28'!stack	^stack! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 11:46'!top	^self stack isEmpty		ifTrue: [nil]		ifFalse: [self stack last]! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/5/2003 19:29'!domDocument	[self startDocument; parseDocument]		ensure: [self driver stream close].	^document! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop _ self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 12/21/2000 14:02'!nextEntityStart	[self driver nextEntity.	self stack isEmpty] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental	^incremental! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental _ aBoolean! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack _ OrderedCollection new.	incremental _ false! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 8/14/2000 18:36'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 12/7/2000 16:29'!parseDocumentFrom: aStream	^(super parseDocumentFrom: aStream) document! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd	^dtd! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd _ aDTD! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 5/16/2003 14:09'!encoding		^encoding ifNil: ['UTF-8']! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding _ aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup		^requiredMarkup! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup _ aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version		^version! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version _ aString! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer _ XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLDocument methodsFor: 'printing' stamp: 'mir 5/16/2003 14:08'!printXMLOn: writer	version ifNotNil: [writer xmlDeclaration: self version encoding: self encoding].	super printXMLOn: writer! !!XMLElement methodsFor: 'initialize' stamp: 'mir 8/14/2000 17:58'!addContent: contentString	self contents add: contentString! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name _ aString asSymbol! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes _ newAttributes! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName	^self attributeAt: attributeName ifAbsent: [nil]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName ifAbsent: aBlock	^self attributes at: attributeName ifAbsent: [^aBlock value]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:24'!attributeAt: attributeName put: attributeValue	self attributes at: attributeName asSymbol put: attributeValue! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes _ Dictionary new]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 3/7/2000 16:24'!characterData	^self contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:27'!contentString	^(self contents size == 1		and: [self contents first isKindOf: XMLStringNode])		ifTrue: [self contents first string]		ifFalse: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/18/2003 13:47'!contentStringAt: entityName	^(self elementAt: entityName ifAbsent: [^'']) contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 8/14/2000 17:58'!contents	contents ifNil: [contents _ OrderedCollection new].	^contents! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!name	^ self qualifiedName! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!tag	^ self name asSymbol! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/5/2003 12:02'!valueFor: aSymbol 	^self valueFor: aSymbol ifAbsent: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:28'!valueFor: aSymbol ifAbsent: aBlock 	^self attributes at: aSymbol ifAbsent: aBlock! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/25/2000 11:15'!contentsDo: aBlock	contents		ifNotNil: [			self contents do: [:each | aBlock value: each]]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag.	If it is not the receiver, pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [^self].	^super firstTagNamed: aSymbol ! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that allows	the block to evaluate to true. Pass the message on"	((self localName == aSymbol		or: [self tag == aSymbol]) 		and: [aBlock value: self])		ifTrue: [^self].	^super firstTagNamed: aSymbol with: aBlock.! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:33'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver	if the receiver tag equals aSymbol. Pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [self contentsDo: aBlock].	super tagsNamed: aSymbol contentsDo: aBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol do: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Continue the search"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol do: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Then recurse through all the children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver.	For each of the receivers children do the same. Do not go beyond direct children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock! !!XMLElement methodsFor: 'testing' stamp: 'mir 3/6/2002 10:48'!isEmpty	^self elements isEmpty		and: [self contents isEmpty]! !!XMLElement methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^true! !!XMLElement methodsFor: 'name space' stamp: 'sd 5/25/2003 18:24'!localName	^ name! !!XMLElement methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!qualifiedName	^self namespace		ifNil: [self localName]		ifNotNil: [self namespace , ':' , self localName]! !!XMLElement methodsFor: 'printing' stamp: 'mir 1/17/2002 16:58'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty and: [self attributes isEmpty not]])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self contentsDo: [:content | content printXMLOn: writer].			super printXMLOn: writer.			writer endTag: self name]! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 3/7/2000 16:33'!named: aString	^self new name: aString! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:01'!named: aString attributes: attributeList	^self new		name: aString;		setAttributes: attributeList! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 15:21'!named: aString namespace: ns uri: uri attributes: attributeList	^self new		name: aString;		namespace: ns uri: uri;		setAttributes: attributeList! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 15:51'!currentScope	^self scope last! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 16:08'!establishLocalBindings	(self currentScope at: 2)		ifNil: [			currentBindings := currentBindings copy.			self currentScope at: 2 put: currentBindings]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:25'!initScope	scope := OrderedCollection new: 20.	currentBindings := Dictionary new.	scope addLast: {'http://www.w3.org/TR/REC-xml-names'. currentBindings. nil. }.! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases _ Set new.	uri _ self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:26'!scope	scope ifNil: [self initScope].	^scope! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/16/2003 16:37'!declareNamespace: ns uri: uri	"Declare the given name space prefix with the given URL"	ns = 'xmlns'		ifTrue: [^self defaultNamespace: uri].	self establishLocalBindings.	currentBindings removeKey: ns ifAbsent: [].	currentBindings at: ns put: uri! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/5/2003 19:28'!enterScope	self scope addLast: { self defaultNamespace. nil. currentBindings. }! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/4/2003 16:05'!leaveScope	| leftScope |	leftScope := self scope removeLast.	currentBindings := (self currentScope at: 2) ifNil: [leftScope at: 3]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:22'!defaultNamespace	^self currentScope first! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self currentScope at: 1 put: ns! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'sd 5/28/2003 09:33'!namespaceURIOf: ns	"Retrieve the URI of the given namespace prefix, if it is defined. A nil namespace	returns the global namespace"	^ self namespaceURIOf: ns ifAbsent: [ nil ]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 13:33'!namespaceURIOf: ns ifAbsent: aBlock	"Retrieve the URI of the given namespace prefix, if it is defined. 	A nil namespace returns the default namespace. 	If no namespace can be found the value of the block is returned"	^ns		ifNil: [self defaultNamespace]		ifNotNil: [currentBindings at: ns ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:32'!namespaces	^currentBindings! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'mir 6/5/2003 17:16'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"	| namespace localName |	attributeList keysDo: [:attrName |		self splitName: attrName into: [:ns :ln |			namespace _ ns.			localName _ ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLNode methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:44'!addContent: contentString	SAXParseException signal: 'Illegal string data.'! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 1/17/2002 14:49'!contentsDo: aBlock! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:56'!elementsDo: aBlock! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:52'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	| answer |	self elementsDo: [:node | (answer _ node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	| answer |	self elementsDo: [:node |		(answer _ node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDo: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDoAndRecurse: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match and recurse"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver.	The receiver has no tag, so pass the message on"	self elementsDo: [:each | each tagsNamed: aSymbol contentsDo: aBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol do: aOneArgumentBlock	"Search for nodes with tag aSymbol. When encountered evaluate aOneArgumentBlock"	self elementsDo: [:each | each tagsNamed: aSymbol do: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'SqR 7/2/2000 15:58'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"Handled only by XMLTagNode subclass"! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isText	^false! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printOn: stream	self printXMLOn: (XMLWriter on: stream)! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printXMLOn: writer	self subclassResponsibility! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 11:01'!addElement: element	self elements add: element! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:22'!addEntity: entityName value: entityValue	self entities add: entityName->entityValue! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:46'!elementAt: entityName	^self elementAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/25/2003 13:27'!elementAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each name = entityName or: [each localName = entityName]] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName	^self elementUnqualifiedAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:54'!elements	elements ifNil: [elements _ OrderedCollection new].	^elements! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:50'!topElement	^self elements first! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:45'!elementsDo: aBlock	elements		ifNotNil: [			self elements do: [:each | aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespace	^ namespace! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace _ ns.	uri _ u! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespaceURI	^ uri! !!XMLNodeWithElements methodsFor: 'printing' stamp: 'mir 3/6/2002 10:49'!printXMLOn: writer	self elementsDo: [:element | element printXMLOn: writer]! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data	^data! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data _ aString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target	^target! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target _ aString! !!XMLPI methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^true! !!XMLPI methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pi: self target data: self data! !!XMLPI class methodsFor: 'instance creation' stamp: 'mir 1/17/2002 13:03'!target: targetName data: aString	^self new		target: targetName;		data: aString! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:51'!attribute: aSymbol value: aString	"This method is called for each attribute/value pair in a start tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!beginStartTag: aSymbol asPI: aBoolean	"This method is called for at the beginning of a start tag.	The asPI parameter defines whether or not the tag is a 'processing	instruction' rather than a 'normal' tag."	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endStartTag: aSymbol	"This method is called at the end of the start tag after all of the	attributes have been processed"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endTag: aSymbol	"This method is called when the parser encounters either an	end tag or the end of a unary tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!text: aString	"This method is called for the blocks of text between tags.	It preserves whitespace, but has all of the enclosed entities expanded"	^self subclassResponsibility! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handleCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleEndTag: aString	self endTag: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handlePCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleStartTag: tagName attributes: attributes	self beginStartTag: tagName asPI: false.	attributes keysAndValuesDo: [:key :value |		self attribute: key value: value].	self endStartTag: tagName! !!XMLStringNode methodsFor: 'accessing'!characterData	^self string! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string	^string ifNil: ['']! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string _ aString! !!XMLStringNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:27'!isText	^true! !!XMLStringNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pcData: self string! !!XMLStringNode class methodsFor: 'instance creation' stamp: 'mir 10/25/2000 11:30'!string: aString	^self new string: aString! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:58'!atEnd	nestedStreams == nil		ifTrue: [^peekChar == nil and: [stream atEnd]].	^stream atEnd		ifTrue: [			self popNestingLevel.			self atEnd]		ifFalse: [false]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:59'!checkNestedStream	nestedStreams == nil		ifFalse: [(peekChar == nil and: [self stream atEnd])			ifTrue: [				self popNestingLevel.				self checkNestedStream]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/28/2001 16:45'!hasNestedStreams	^nestedStreams notNil! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar _ stream next]		ifNotNil: [			nextChar _ peekChar.			peekChar _ nil.			^nextChar].	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:27'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	nextChar _ nil.	[peekChar _ self peek.	peekChar		ifNotNil: [			[peekChar == $ 				and: [nextChar == $ ]]				whileTrue: [peekChar _ self next]].	(nextChar _ self next) == delimiter]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/9/2002 15:29'!nextUpToAll: delimitingString	| string |	self unpeek.	string _ self stream upToAll: delimitingString.	self stream skip: delimitingString size negated.	(self stream next: delimitingString size) = delimitingString		ifFalse: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar _ stream next]		ifNotNil: [^peekChar]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams _ nil]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:50'!pushBack: aString	| pushBackString |	pushBackString _ peekChar		ifNil: [aString]		ifNotNil: [peekChar asString , aString].	peekChar _ nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:54'!pushStream: newStream	"Continue parsing from the new nested stream."	self unpeek.	self nestedStreams addLast: self stream.	self stream: newStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:54'!skipSeparators	| nextChar |	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1]]		whileFalse: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/17/2002 14:31'!topStream	^self hasNestedStreams		ifTrue: [self nestedStreams first]		ifFalse: [self stream]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:45'!unpeek	peekChar		ifNotNil: [			self stream pushBack: (String with: peekChar).			peekChar _ nil]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar _ self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString _ self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/16/2000 21:41'!conditionalInclude: conditionalKeyword	conditionalKeyword = 'INCLUDE'		ifTrue: [^true].	conditionalKeyword = 'IGNORE'		ifTrue: [^false].	^self conditionalInclude: (self parameterEntity: conditionalKeyword) value! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName _ self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue _ self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:34'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream _ attributeBuffer reset.	[	nextPeek _ nextChar _ self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata _ self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar _ self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword _ self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base _ self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue _ [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string _ self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:27'!nextEndTag	| string |	"Skip /"	self next.	self skipSeparators.	string _ self nextTrimmedBlanksUpTo: $>.	"string _ (self nextUpTo: $>) withBlanksTrimmed."	self handleEndTag: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'cwp 6/17/2003 21:04'!nextEntity	"return the next XMLnode, or nil if there are no more"	"branch, depending on what the first character is"	self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [self nextPCData]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream _ WriteStream on: (String new).	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek _ nextChar _ self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					nextChar _ self handleEntity: referenceString in: #entityValue.					nextPeek _ nextChar _ self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section _ self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 19:56'!nextLiteral	| resultStream nextChar resultString |	resultStream _ (String new: 10) writeStream.	((nextChar _ self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[nextChar _ self peek.	(LiteralChars at: nextChar asciiValue+1)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar _ self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString _ resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:10'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar _ self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters at: nextChar asciiValue] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer"	^nameBuffer contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar _ self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar _ self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:01'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream _ (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget _ self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData _ self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextPubidLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextSystemLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName _ self nextName.	self skipSeparators.	attributes _ Dictionary new: 33.	namespaces _ Dictionary new: 5.	[(nextChar _ self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/9/2005 09:43'!nextWhitespace	| nextChar resultStream resultString|	resultStream _ (String new: 10) writeStream.	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1 ifAbsent:[true]]]		whileFalse: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString _ resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 14:52'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes _ Dictionary new.	namespaces _ Dictionary new.	[(nextChar _ self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	self handleXMLDecl: attributes namespaces: namespaces! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 6/29/2001 00:08'!endDocTypeDecl	"Skip ]>"	self next; next.	^nil! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType _ self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar _ self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass _ self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName _ self nextLiteral.	self skipSeparators.	entityDef _ (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference _ referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType _ self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId _ self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId _ self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir _ self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType _ self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/4/2002 11:05'!skipMarkupDeclaration	self skipUpTo: $>! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup _ false! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize _ writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 12/7/2000 16:46'!log: aString	"Transcript show: aString; cr"! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams _ OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!parsingMarkup	^parsingMarkup! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString _ self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value _ 0.	digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value _ digit.	[digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value _ value * base + digit]		] repeat.	^ value! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup _ true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream	^stream! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream _ newStream! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities _ self initEntities].	^entities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 13:53'!entity: refName	^self validating		ifTrue: [self entities			at: refName			ifAbsentPut: [self parseError: 'XML undefined entity ' , refName printString]]		ifFalse: [DTDEntityDeclaration name: refName value: '']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:43'!entity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self entities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities _ Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntity: refName	^self entities		at: refName		ifAbsentPut: ['']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity _ self entity: referenceString.	entityValue _ entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue _ entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 8/17/2004 16:52'!initEntities	| ents |	ents _ Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: $&);		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: $");		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: $');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: $>);		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: $<).	^ents! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities _ Dictionary new].	^parameterEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:40'!parameterEntity: refName	^self parameterEntities		at: refName		ifAbsent: [self parseError: 'XML undefined parameter entity ' , refName printString]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:42'!parameterEntity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self parameterEntities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 5/14/2003 18:27'!errorExpected: expectedString	| actualString |	actualString := ''.	self atEnd		ifFalse: [			[actualString := self next: 20]				on: Error				do: [:ex | ]].	self parseError: 'XML expected ' , expectedString printString , ': ' , actualString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/9/2002 15:26'!malformedError: errorString	SAXMalformedException signal: errorString! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/8/2002 15:37'!parseError: errorString	SAXParseException signal: errorString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 11/13/2000 16:04'!handleCData: aString	self log: 'CData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:37'!handleComment: aString	self log: 'Comment: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:27'!handleEndDocument	self log: 'End Doc '! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handleEndTag: aString	self log: 'End tag: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handlePCData: aString	self log: 'PCData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 12/11/2000 16:10'!handlePI: piTarget data: piData	self log: 'PI: ' , piTarget , ' data ' , piData! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:26'!handleStartDocument	self log: 'Start Doc'! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:39'!handleStartTag: tagName attributes: attributes	self log: 'Start tag: ' , tagName.	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 21:08'!handleWhitespace: aString	self log: 'Whitespace: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 6/5/2003 14:53'!handleXMLDecl: attributes namespaces: namespaces	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup _ false.	validating _ false.	attributeBuffer _ WriteStream on: (String new: 128).	nameBuffer _ WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 6/28/2001 16:51'!parseStream: aStream	self stream: aStream! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating _ aBoolean! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 6/5/2003 16:33'!usesNamespaces	^false! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 1/14/2002 17:51'!validating	^validating! !!XMLTokenizer commentStamp: '<historical>' prior: 0!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 12/19/2005 16:10'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer _ XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer _ XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 3/14/2003 22:54'!initialize	"XMLTokenizer initialize"	| nameDelimiters |	CharEscapes _ #( $& $" $' $> $< ) asSet.	SeparatorTable  _ Array new: 256.	SeparatorTable atAllPut: true.	#(9 10 12 13 32) do: [:each | SeparatorTable at: each+1 put: false].	LiteralChars _ Array new: 256.	LiteralChars atAllPut: false.	':-_.' do: [:each | LiteralChars at: each asciiValue put: true].	1 to: 256 do: [:i | ((i-1) asCharacter isDigit or: [(i-1) asCharacter isLetter])		ifTrue: [LiteralChars at: i put: true]].	nameDelimiters _ #(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger").	NameDelimiters _ Array new: 256.	NameDelimiters atAllPut: false.	nameDelimiters do: [:each | NameDelimiters at: each put: true].	DigitTable _ Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 1/15/2002 21:39'!isCharEscape: aChar	^CharEscapes includes: aChar! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 8/2/2000 19:25'!new	^super new initialize! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 07:58'!on: aStream	^self new parseStream: aStream! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:04'!attribute: attributeName value: attributeValue	self stream		space;		nextPutAll: attributeName.	self		eq;		putAsXMLString: attributeValue! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:55'!cdata: aString	self startCData.	self stream nextPutAll: aString.	self endCData! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!comment: aString	self startComment.	self stream nextPutAll: aString.	self endComment! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!endEmptyTag: tagName	self popTag: tagName.	self stream nextPutAll: '/>'.	self canonical		ifFalse: [self stream space]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 15:25'!endTag	self stream nextPutAll: '>'.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:52'!endTag: tagName	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:46'!endTag: tagName xmlns: xmlns	self popTag: tagName.	self stream		nextPutAll: '</'.	(xmlns notNil		and: [xmlns ~= self defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	stream nextPutAll: tagName.	self endTag.! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:13'!flush	self stream flush! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 12/15/2002 15:56'!pcData: aString	| lastIndex nextIndex |	lastIndex := 1.	"Unroll the first search to avoid copying"	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self stream nextPutAll: aString].	[self stream nextPutAll: (aString copyFrom: lastIndex to: nextIndex-1).	self stream nextPutAll: (XMLTranslation at: (aString at: nextIndex)).	lastIndex := nextIndex + 1.	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0] whileFalse.	self stream nextPutAll: (aString copyFrom: lastIndex to: aString size).! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/11/2000 16:12'!pi: piTarget data: piData	self startPI: piTarget.	self stream nextPutAll: piData.	self endPI! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 1/17/2002 17:07'!startElement: elementName attributeList: attributeList	self canonical		ifFalse: [self stream cr].	self startTag: elementName.	attributeList keys asSortedCollection do: [:key |		self attribute: key value: (attributeList at: key)]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:51'!startTag: tagName	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:10'!startTag: tagName xmlns: xmlns	self stream		nextPut: $<.	(xmlns notNil		and: [xmlns ~= self scope defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	self stream		nextPutAll: tagName.	"self canonical		ifFalse: [self stream space]."	self pushTag: tagName! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 12:17'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical	^canonical! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical _ aBoolean! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream	^stream! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream _ aStream! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:09'!declareNamespace: ns uri: uri	self scope declareNamespace: ns uri: uri! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace	^self scope defaultNamespace! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self scope defaultNamespace: ns! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:02'!enterScope	self scope enterScope! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:47'!leaveScope	self scope leaveScope! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endCData	self stream nextPutAll: ']]>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endComment	self stream nextPutAll: ' -->'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 5/20/2003 12:13'!endPI	self stream nextPutAll: ' ?>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startCData	self stream nextPutAll: '<!![CDATA['! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startComment	self stream nextPutAll: '<-- '! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startPI: identifier	self stream		nextPutAll: '<?';		nextPutAll: identifier;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 8/8/2000 18:13'!endDecl: type	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!endDeclaration	self stream		cr;		nextPut: $].	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type named: aString	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space;		nextPutAll: aString;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDeclaration: dtdName	self startDecl: 'DOCTYPE' named: dtdName.	self stream		nextPut: $[;		cr! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/8/2000 18:00'!eq	self stream nextPut: $=! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop _ self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:18'!pushTag: tagName	self stack add: tagName! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/11/2000 16:24'!putAsXMLString: aValue	self stream nextPut: $".	self pcData: aValue.	self stream nextPut: $"! !!XMLWriter methodsFor: 'private' stamp: 'mir 6/24/2003 14:22'!scope	^scope! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/8/2000 17:02'!stack	^stack! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 6/24/2003 13:41'!initialize	stack _ OrderedCollection new.	canonical _ false.	scope := XMLNamespaceScope new! !!XMLWriter class methodsFor: 'class initialization' stamp: 'ar 12/13/2002 01:04'!initialize	"XMLWriter initialize"	XMLTranslation := Dictionary new.	XMLTranslation		at: Character cr put: '&#13;';		at: Character lf put: '&#10;';		at: Character tab put: '&#9;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;';"		at: $' put: '&apos;'; "		at: $" put: '&quot;'.	XMLTranslationMap := ByteArray new: 256.	XMLTranslation keysDo:[:ch| XMLTranslationMap at: ch asciiValue+1 put: 1].! !!XMLWriter class methodsFor: 'instance creation' stamp: 'mir 12/8/2000 17:54'!on: aStream	^self basicNew initialize stream: aStream! !Smalltalk condenseChanges!Smalltalk garbageCollect!----SNAPSHOT----an Array(26 May 2008 6:49:21 pm) Squeak3.10.1-7175-basic.4.image priorSource: 1849455!----STARTUP----an Array(29 May 2008 11:26:57 am) as /home/ken/projects/squeak/3.10/temp2/Squeak3.10.1-7175-basic.image!Smalltalk garbageCollect!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!DisplayScreen actualScreenSize!Smalltalk garbageCollect!----SNAPSHOT----an Array(29 May 2008 11:47:30 am) Squeak3.10.1-7175-basic-new.image priorSource: 1849510!----STARTUP----an Array(29 May 2008 11:48:10 am) as /home/ken/projects/squeak/3.10/temp2/Squeak3.10.1-7175-basic-new.image!----QUIT/NOSAVE----an Array(29 May 2008 11:49:26 am) Squeak3.10.1-7175-basic-new.image priorSource: 1850120!