'From Squeak 1.18 of December 12, 1996 on 13 December 1996 at 2:23:53 pm'!


!AbstractSound methodsFor: 'playing'!
playSampleCount: n into: aSoundBuffer startingAt: startIndex stereo: stereoFlag
	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."

	| leftRightPan samplesBetweenControlUpdates pastEnd i remainingSamples count |
	stereoFlag ifTrue: [leftRightPan _ 500] ifFalse: [leftRightPan _ 1000].
	samplesBetweenControlUpdates _ self samplingRate // self controlRate.
	pastEnd _ startIndex + n.  "index just index of after last sample"
	i _ startIndex.
	[i < pastEnd] whileTrue: [
		remainingSamples _ self samplesRemaining.
		remainingSamples <= 0 ifTrue: [ ^ self ].
		count _ pastEnd - i.
		samplesUntilNextControl < count ifTrue: [ count _ samplesUntilNextControl ].
		remainingSamples < count		ifTrue: [ count _ remainingSamples ].
		self mixSampleCount: count into: aSoundBuffer startingAt: i pan: leftRightPan.
		samplesUntilNextControl _ samplesUntilNextControl - count.
		samplesUntilNextControl <= 0 ifTrue: [
			self doControl.
			samplesUntilNextControl _ samplesBetweenControlUpdates.
		].
		i _ i + count.
	].
! !
!AbstractSound class methodsFor: 'primitive generation'!
cCodeForSoundPrimitives
	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."

	^ CCodeGenerator new codeStringForPrimitives: #(
		(WaveTableSound mixSampleCount:into:startingAt:pan:)
		(FMSound mixSampleCount:into:startingAt:pan:)
		(PluckedSound mixSampleCount:into:startingAt:pan:)
	).
! !
!Array2D methodsFor: 'access'!
atCol: i put: list
    "Put in a whole column.
     hold first index constant"

    list size = self height ifFalse: [self error: 'wrong size'].
    list doWithIndex: [:value :j |
        self at: i at: j put: value].!
atRow: j put: list
    "Put in a whole row.
     hold second index constant"

    list size = self width ifFalse: [self error: 'wrong size'].
    list doWithIndex: [:value :i |
        self at: i at: j put: value].! !
!AssignmentNode methodsFor: 'C translation'!
asTranslatorNode
	^TAssignmentNode new
		setVariable: variable asTranslatorNode
		expression: value asTranslatorNode! !
!Behavior methodsFor: 'testing'!
instSize
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver."

	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange"
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	When we revise the image format, it should become...
	^ ((format bitShift: -1) bitAnd: 16rFF) - 1
	Note also that every other method in this category will require
	2 bits more of right shift after the change.
"
	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !
!Behavior methodsFor: 'creating method dictionary'!
compile: code notifying: requestor 
	"Compile the argument, code, as source code in the context of the 
	receiver and insEtall the result in the receiver's method dictionary. The 
	second argument, requestor, is to be notified if an error occurs. The 
	argument code is either a striEng or an object that converts to a string or 
	a PEositionableStrean an object that converts to a string. This method 
	also saves the source code."

	| method selector methodNode |
	method _ self
		compile: code
		notifying: requestor
		trailer: #(0 0 0 )
		ifFail: [^nil]
		elseSetSelectorAndNode: 
			[:sel :parseNode | selector _ sel.  methodNode _ parseNode].
	method putSource: code asString fromParseNode: methodNode inFile: 2.
	^selector!
recompile: selector from: oldClass
	"Compile the method associated with selector in the receiver's method dictionary."
	| method trailer methodNode |
	method _ self compiledMethodAt: selector.
	trailer _ (method size - 2 to: method size) collect: [:i | method at: i].
	methodNode _ self compilerClass new
				compile: (oldClass sourceCodeAt: selector)
				in: self
				notifying: nil
				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"
	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].
	self addSelector: selector withMethod: (methodNode generate: trailer).
! !
!Behavior methodsFor: 'instance creation'!
new
	"Answer a new instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."
	"Essential Primitive. See Object documentation whatIsAPrimitive."

	<primitive: 70>
	self isVariable ifTrue: [^ self basicNew: 0].
	"space must be low"
	Smalltalk signalLowSpace.
	^ self basicNew  "retry if user proceeds"
!
new: anInteger 
	"Primitive. Answer an instance of the receiver (which is a class) with the 
	number of indexable variables specified by the argument, anInteger. Fail 
	if the class is not indexable or if the argument is not a positive Integer. 
	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 71>
	(anInteger isInteger and: [anInteger >= 0]) ifTrue: [
		"arg okay; space must be low"
		Smalltalk signalLowSpace.
		^ self basicNew: anInteger  "retry if user proceeds"
	].
	self primitiveFailed! !
!Behavior methodsFor: 'accessing class hierarchy'!
allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 
	"Walk the tree of subclasses, giving the class and its level"
	| subclassNames subclass |
	classAndLevelBlock value: self value: level.
	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"
	"Visit subclasses in alphabetical order"
	subclassNames _ SortedCollection new.
	self subclassesDo: [:subC | subclassNames add: subC name].
	subclassNames do:
		[:name | (Smalltalk at: name)
			allSubclassesWithLevelDo: classAndLevelBlock
			startingLevel: level+1]! !
!Behavior methodsFor: 'accessing method dictionary'!
sourceCodeAt: selector

	^ (methodDict at: selector) getSourceFor: selector in: self! !
!Behavior methodsFor: 'private'!
format: nInstVars variable: isVar words: isWords pointers: isPointers 
	"Set the format for the receiver (a Class)."
	| cClass instSpec sizeHiBits |
	self flag: #instSizeChange.
"
Smalltalk browseAllCallsOn: #instSizeChange.
Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.
Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.
"
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	For now the format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>
	But when we revise the image format, it should become...
		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>
"
	sizeHiBits _ (nInstVars+1) // 64.
	cClass _ 0.  "for now"
	instSpec _ isPointers
		ifTrue: [isVar
				ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]
				ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]
		ifFalse: [isWords ifTrue: [6] ifFalse: [8]].
	format _ sizeHiBits.
	format _ (format bitShift: 5) + cClass.
	format _ (format bitShift: 4) + instSpec.
	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"
	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"
! !
!BitBlt methodsFor: 'accessing'!
colorMap
	^ colorMap!
destX: x destY: y width: w height: h
	"Combined init message saves 3 sends from DisplayScanner"
	destX _ x.
	destY _ y.
	width _ w.
	height _ h.! !
!BitBlt methodsFor: 'copying'!
copyBits
	"Primitive. Perform the movement of bits from the source form to the 
	destination form. Fail if any variables are not of the right type (Integer 
	or Form) or if the combination rule is not implemented. 
	In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord
"
	<primitive: 96>
	"Set the variables and try again (BitBlt|copyBitsAgain, also a Primitive)."
	combinationRule = Form paint ifTrue: [^ self paintBits].
	combinationRule = Form erase1bitShape ifTrue: [^ self eraseBits].
	destX _ destX asInteger.
	destY _ destY asInteger.
	width _ width asInteger.
	height _ height asInteger.
	sourceX _ sourceX asInteger.
	sourceY _ sourceY asInteger.
	clipX _ clipX asInteger.
	clipY _ clipY asInteger.
	clipWidth _ clipWidth asInteger.
	clipHeight _ clipHeight asInteger.
	^ self copyBitsAgain! !
!BitBlt methodsFor: 'private'!
paintBits
	"Perform the paint operation, which requires two calls to BitBlt."
	| color oldMap saveRule |
	sourceForm depth = 1 ifFalse: 
		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].
	saveRule _ combinationRule.
	color _ halftoneForm.  halftoneForm _ nil.
	oldMap _ colorMap.
	"Map 1's to ALL ones, not just one"
	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).
	combinationRule _ Form erase.
	self copyBits. 		"Erase the dest wherever the source is 1"
	halftoneForm _ color.
	combinationRule _ Form under.
	self copyBits.	"then OR, with whatever color, into the hole"
	colorMap _ oldMap.
	combinationRule _ saveRule

" | dot |
dot _ Form dotOfSize: 32.
((BitBlt destForm: Display
		sourceForm: dot
		fillColor: Color lightGray
		combinationRule: Form paint
		destOrigin: Sensor cursorPoint
		sourceOrigin: 0@0
		extent: dot extent
		clipRect: Display boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !

BitBltSimulation comment:
'This class implements BitBlt, much as specified in the Blue Book spec.

Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.

Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.

In addition to the original 16 combination rules, this BitBlt supports
	16	fail (to simulate paint)
	17	fail (to simulate mask)
	18	sourceWord + destinationWord
	19	sourceWord - destinationWord
	20	rgbAdd: sourceWord with: destinationWord
	21	rgbSub: sourceWord with: destinationWord
	22	rgbDiff: sourceWord with: destinationWord
	23	tallyIntoMap: destinationWord
	24	alphaBlend: sourceWord with: destinationWord
	25	pixPaint: sourceWord with: destinationWord
	26	pixMask: sourceWord with: destinationWord

This implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.
'!
!BitBltSimulation methodsFor: 'interpreter interface'!
drawLoopX: xDelta Y: yDelta 
	"This is the primitive implementation of the line-drawing loop"
	| dx1 dy1 px py P affL affR affT affB |
	xDelta > 0
		ifTrue: [dx1 _ 1]
		ifFalse: [xDelta = 0
				ifTrue: [dx1 _ 0]
				ifFalse: [dx1 _ -1]].
	yDelta > 0
		ifTrue: [dy1 _ 1]
		ifFalse: [yDelta = 0
				ifTrue: [dy1 _ 0]
				ifFalse: [dy1 _ -1]].
	px _ yDelta abs.
	py _ xDelta abs.
	self copyBits.
	affL _ affectedL.
	affR _ affectedR.
	affT _ affectedT.
	affB _ affectedB.
	py > px
		ifTrue: 
			["more horizontal"
			P _ py // 2.
			1 to: py do: 
				[:i |
				destX _ destX + dx1.
				(P _ P - px) < 0 ifTrue: 
						[destY _ destY + dy1.
						P _ P + py].
				self copyBits]]
		ifFalse: 
			["more vertical"
			P _ px // 2.
			1 to: px do:
				[:i |
				destY _ destY + dy1.
				(P _ P - py) < 0 ifTrue: 
						[destX _ destX + dx1.
						P _ P + px].
				self copyBits]].

	"Compute affected rect from start, end"
	affectedL _ affL min: affectedL.
	affectedR _ affR max: affectedR.
	affectedT _ affT min: affectedT.
	affectedB _ affB max: affectedB.

	"store destX, Y back"	
	interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.
	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.!
loadBitBltFrom: bbObj
	"Load context from BitBlt instance.  Return false if anything is amiss"
	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping
		-- once it works!!"
	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |
	bitBltOop _ bbObj.
	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.
	(interpreterProxy failed
		or: [combinationRule < 0 or: [combinationRule > 26]])
		 ifTrue: [^ false  "operation out of range"].
	(combinationRule >= 16 and: [combinationRule <= 17])
		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].
	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.
	noSource _ self ignoreSourceOrHalftone: sourceForm.
	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.
	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.

	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.
		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])
			ifFalse: [^ false].
		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.
		destBitsSize _ interpreterProxy byteLengthOf: destBits.
		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.
		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.
		(destWidth >= 0 and: [destHeight >= 0])
			ifFalse: [^ false].
		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.
		pixPerWord _ 32 // destPixSize.
		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.
		((interpreterProxy isWordsOrBytes: destBits)
			and: [destBitsSize = (destRaster * destHeight * 4)])
			ifFalse: [^ false].	
	destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bitBltOop.
	destY _ interpreterProxy fetchInteger: BBDestYIndex ofObject: bitBltOop.
	width _ interpreterProxy fetchInteger: BBWidthIndex ofObject: bitBltOop.
	height _ interpreterProxy fetchInteger: BBHeightIndex ofObject: bitBltOop.
		interpreterProxy failed ifTrue: [^ false  "non-integer value"].

	noSource ifTrue:
		[sourceX _ sourceY _ 0]
		ifFalse: 
		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])
			ifFalse: [^ false].
		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.
		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.
		srcWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: sourceForm.
		srcHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: sourceForm.
		(srcWidth >= 0 and: [srcHeight >= 0])
			ifFalse: [^ false].
		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.
		sourcePixPerWord _ 32 // sourcePixSize.
		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.
		((interpreterProxy isWordsOrBytes: sourceBits)
			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])
			ifFalse: [^ false].
		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.
		"ColorMap, if not nil, must be longWords, and 
		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 
		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."
		colorMap = interpreterProxy nilObject ifFalse:
			[(interpreterProxy isWords: colorMap)
			ifTrue:
			[cmSize _ interpreterProxy lengthOf: colorMap.
			cmBitsPerColor _ 0.
			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].
			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].
			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].
			interpreterProxy primIndex ~= 147 ifTrue:
				["WarpBlt has different checks on the color map"
				sourcePixSize <= 8
				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]
				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]
			]
			ifFalse: [^ false]].
		sourceX _ interpreterProxy fetchInteger: BBSourceXIndex ofObject: bitBltOop.
		sourceY _ interpreterProxy fetchInteger: BBSourceYIndex ofObject: bitBltOop].

	noHalftone ifFalse: 
		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])
		ifTrue:
		["Old-style 32xN monochrome halftone Forms"
		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.
		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.
		(interpreterProxy isWords: halftoneBits)
			ifFalse: [noHalftone _ true]]
		ifFalse:
		["New spec accepts, basically, a word array"
		((interpreterProxy isPointers: halftoneForm) not
			and: [interpreterProxy isWords: halftoneForm])
			ifFalse: [^ false].
		halftoneBits _ halftoneForm.
		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].
	halftoneBase _ halftoneBits + 4].

	clipX _ interpreterProxy fetchInteger: BBClipXIndex ofObject: bitBltOop.
	clipY _ interpreterProxy fetchInteger: BBClipYIndex ofObject: bitBltOop.
	clipWidth _ interpreterProxy fetchInteger: BBClipWidthIndex ofObject: bitBltOop.
	clipHeight _ interpreterProxy fetchInteger: BBClipHeightIndex ofObject: bitBltOop.
		interpreterProxy failed ifTrue: [^ false  "non-integer value"].
	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].
	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].
	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].
	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].

	^ true!
loadScannerFrom: bbObj
	start: start stop: stop string: string rightX: rightX
	stopArray: stopArray displayFlag: displayFlag

	"Load arguments and Scanner state"
	scanStart _ start.
	scanStop _ stop.
	scanString _ string.
	scanRightX _ rightX.
	scanStopArray _ stopArray.
	scanDisplayFlag _ displayFlag.
	interpreterProxy success: (
		(interpreterProxy isPointers: scanStopArray)
			and: [(interpreterProxy lengthOf: scanStopArray) >= 1]).
	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.
	interpreterProxy success: (
		(interpreterProxy isPointers: scanXTable)
			and: [(interpreterProxy lengthOf: scanXTable) >= 1]).

	"width and sourceX may not be set..."
	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.
	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.

	"Now load BitBlt state if displaying"
	scanDisplayFlag
		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]
		ifFalse: [bitBltOop _ bbObj.
				destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bbObj].
	^interpreterProxy failed not!
scanCharacters

	| left top lastIndex charVal ascii sourceX2 nextDestX |
	scanDisplayFlag ifTrue:
		[self clipRange.  "Need to get true x, y for affectedRectangle"
		left _ dx.
		top _ dy].
	lastIndex _ scanStart.
	[lastIndex <= scanStop]
		whileTrue: [
			charVal _ interpreterProxy stObject: scanString at: lastIndex.
			ascii _ interpreterProxy integerValueOf: charVal.
			interpreterProxy failed ifTrue: [^ nil].
			stopCode _ interpreterProxy stObject: scanStopArray at: ascii + 1.
			interpreterProxy failed ifTrue: [^ nil].
			stopCode = interpreterProxy nilObject
				ifFalse: [^ self returnAt: ascii + 1
							 lastIndex: lastIndex
								  left: left
								  top: top].
			sourceX _ interpreterProxy stObject: scanXTable at: ascii + 1.
			sourceX2 _ interpreterProxy stObject: scanXTable at: ascii + 2.
			interpreterProxy failed ifTrue: [^ nil].
			(interpreterProxy isIntegerObject: sourceX) & (interpreterProxy isIntegerObject: sourceX2)
				ifTrue: [sourceX _ interpreterProxy integerValueOf: sourceX.
						sourceX2 _ interpreterProxy integerValueOf: sourceX2]
				ifFalse: [interpreterProxy primitiveFail. ^ nil].
			nextDestX _ destX + (width _ sourceX2 - sourceX).
			nextDestX > scanRightX
				ifTrue: [^ self returnAt: CrossedX
							 lastIndex: lastIndex
								  left: left
								  top: top].
			scanDisplayFlag ifTrue: [self copyBits].
			destX _ nextDestX.
			interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.
			lastIndex _ lastIndex + 1].
	self returnAt: EndOfRun
		 lastIndex: scanStop
			  left: left
			  top: top!
setInterpreter: anInterpreter
	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."

	interpreterProxy _ anInterpreter.! !
!BitBltSimulation methodsFor: 'accessing'!
affectedBottom

	^affectedB!
affectedLeft

	^affectedL!
affectedRight

	^affectedR!
affectedTop

	^affectedT!
stopReason

	^stopCode!
targetForm
	"Return the destination form of a copyBits or scanCharacters operation."

	^destForm! !
!BitBltSimulation methodsFor: 'setup'!
checkSourceOverlap
	| t |
	"check for possible overlap of source and destination"
	(sourceForm = destForm and: [dy >= sy]) ifTrue:
		[dy > sy ifTrue:
			["have to start at bottom"
			vDir _ -1.
			sy _ sy + bbH - 1.
			dy _ dy + bbH - 1]
		ifFalse:
			[dx > sx ifTrue:
				["y's are equal, but x's are backward"
				hDir _ -1.
				sx _ sx + bbW - 1.
				"start at right"
				dx _ dx + bbW - 1.
				"and fix up masks"
				nWords > 1 ifTrue: 
					[t _ mask1.
					mask1 _ mask2.
					mask2 _ t]]].
		"Dest inits may be affected by this change"
		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).
		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]!
clipRange
	"clip and adjust source origin and extent appropriately"
	"first in x"
	destX >= clipX
		ifTrue: [sx _ sourceX.
				dx _ destX.
				bbW _ width]
		ifFalse: [sx _ sourceX + (clipX - destX).
				bbW _ width - (clipX - destX).
				dx _ clipX].
	(dx + bbW) > (clipX + clipWidth)
		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].
	"then in y"
	destY >= clipY
		ifTrue: [sy _ sourceY.
				dy _ destY.
				bbH _ height]
		ifFalse: [sy _ sourceY + clipY - destY.
				bbH _ height - (clipY - destY).
				dy _ clipY].
	(dy + bbH) > (clipY + clipHeight)
		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].
	noSource ifTrue: [^ nil].
	sx < 0
		ifTrue: [dx _ dx - sx.
				bbW _ bbW + sx.
				sx _ 0].
	sx + bbW > srcWidth
		ifTrue: [bbW _ bbW - (sx + bbW - srcWidth)].
	sy < 0
		ifTrue: [dy _ dy - sy.
				bbH _ bbH + sy.
				sy _ 0].
	sy + bbH > srcHeight
		ifTrue: [bbH _ bbH - (sy + bbH - srcHeight)]!
copyBits
	self clipRange.
	(bbW <= 0 or: [bbH <= 0]) ifTrue:
		["zero width or height; noop"
		affectedL _ affectedR _ affectedT _ affectedB _ 0.
		^ nil].
 
	self destMaskAndPointerInit.
	bitCount _ 0.
	noSource
		ifTrue: [self copyLoopNoSource]
		ifFalse: [self checkSourceOverlap.
				(sourcePixSize ~= destPixSize
					or: [colorMap ~= interpreterProxy nilObject])
					ifTrue: [self copyLoopPixMap]
					ifFalse: [self sourceSkewAndPointerInit.
							self copyLoop]].
 
	combinationRule = 22 ifTrue:
		["zero width and height; return the count"
		affectedL _ affectedR _ affectedT _ affectedB _ 0.
		interpreterProxy pop: 1.
		^ interpreterProxy pushInteger: bitCount].
 
	hDir > 0
		ifTrue: [affectedL _ dx.
				affectedR _ dx + bbW]
		ifFalse: [affectedL _ dx - bbW + 1.
				affectedR _ dx + 1].
	vDir > 0
		ifTrue: [affectedT _ dy.
				affectedB _ dy + bbH]
		ifFalse: [affectedT _ dy - bbH + 1.
				affectedB _ dy + 1]!
destMaskAndPointerInit
	"Compute masks for left and right destination words"
	| startBits pixPerM1 endBits |
	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"
	"how many pixels in first word"
	startBits _ pixPerWord - (dx bitAnd: pixPerM1).
	mask1 _ AllOnes >> (32 - (startBits*destPixSize)).
	"how many pixels in last word"
	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.
	mask2 _ AllOnes << (32 - (endBits*destPixSize)).
	"determine number of words stored per line; merge masks if only 1"
	bbW < startBits
		ifTrue: [mask1 _ mask1 bitAnd: mask2.
				mask2 _ 0.
				nWords _ 1]
		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // pixPerWord + 1].
	hDir _ vDir _ 1. "defaults for no overlap with source"

	"calculate byte addr and delta, based on first word of data"
	"Note raster and nwords are longs, not bytes"
	destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).
	destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir)).  "byte addr delta"!
ignoreSourceOrHalftone: formPointer

	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].
	combinationRule = 0 ifTrue: [ ^true ].
	combinationRule = 5 ifTrue: [ ^true ].
	combinationRule = 10 ifTrue: [ ^true ].
	combinationRule = 15 ifTrue: [ ^true ].
	^false!
returnAt: stopIndex lastIndex: lastIndex left: left top: top

	stopCode _ interpreterProxy stObject: scanStopArray at: stopIndex.
	interpreterProxy failed ifTrue: [^ nil].
	interpreterProxy storeInteger: BBLastIndex ofObject: bitBltOop withValue: lastIndex.
	scanDisplayFlag ifTrue: [
		"Now we know extent of affected rectangle"
		affectedL _ left.
		affectedR _ bbW + dx.
		affectedT _ top.
		affectedB _ bbH + dy.
	].!
sourceSkewAndPointerInit
	"This is only used when source and dest are same depth,
	ie, when the barrel-shift copy loop is used."
	| dWid sxLowBits dxLowBits pixPerM1 |
	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"
	sxLowBits _ sx bitAnd: pixPerM1.
	dxLowBits _ dx bitAnd: pixPerM1.
	"check if need to preload buffer
	(i.e., two words of source needed for first word of destination)"
	hDir > 0 ifTrue:
		["n Bits stored in 1st word of dest"
		dWid _ bbW min: pixPerWord - dxLowBits.
		preload _ (sxLowBits + dWid) > pixPerM1]
	ifFalse:
		[dWid _ bbW min: dxLowBits + 1.
		preload _ (sxLowBits - dWid + 1) < 0].

	"calculate right-shift skew from source to dest"
	skew _ (sxLowBits - dxLowBits) * destPixSize.  " -32..32 "
	preload ifTrue: 
		[skew < 0
			ifTrue: [skew _ skew+32]
			ifFalse: [skew _ skew-32]].

	"Calc byte addr and delta from longWord info"
	sourceIndex _ (sourceBits + 4) + (sy * sourceRaster + (sx // (32//sourcePixSize)) *4).
	"calculate increments from end of 1 line to start of next"
	sourceDelta _ 4 * ((sourceRaster * vDir) - (nWords * hDir)).
	preload ifTrue:
		["Compensate for extra source word fetched"
		sourceDelta _ sourceDelta - (4*hDir)].!
warpBits
	| ns |
	ns _ noSource.  noSource _ true.
		self clipRange.  "noSource suppresses sourceRect clipping"
		noSource _ ns.
	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:
		["zero width or height; noop"
		affectedL _ affectedR _ affectedT _ affectedB _ 0.
		^ nil].
 
	self destMaskAndPointerInit.
	self warpLoop.
 
	hDir > 0
		ifTrue: [affectedL _ dx.
				affectedR _ dx + bbW]
		ifFalse: [affectedL _ dx - bbW + 1.
				affectedR _ dx + 1].
	vDir > 0
		ifTrue: [affectedT _ dy.
				affectedB _ dy + bbH]
		ifFalse: [affectedT _ dy - bbH + 1.
				affectedB _ dy + 1]! !
!BitBltSimulation methodsFor: 'inner loop'!
copyLoop 
	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask |
	"This version of the inner loop assumes noSource = false."

	hInc _ hDir*4.  "Byte delta"
	"degenerate skew fixed for Sparc. 10/20/96 ikp"
	skew == -32
		ifTrue: [skew _ unskew _ skewMask _ 0]
		ifFalse: [skew < 0
			ifTrue:
				[unskew _ skew+32.
				skewMask _ AllOnes << (0-skew)]
			ifFalse:
				[skew == 0
					ifTrue:
						[unskew _ 0.
						skewMask _ AllOnes]
					ifFalse:
						[unskew _ skew-32.
						skewMask _ AllOnes >> skew]]].
	notSkewMask _ skewMask bitInvert32.
	noHalftone
		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]
		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].
	y _ dy.
	1 to: bbH do: "here is the vertical loop"
		[ :i |
		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"
			[halftoneWord _ interpreterProxy longAt:
						(halftoneBase + (y \\ halftoneHeight * 4)).
			y _ y + vDir].
		preload ifTrue:
			["load the 64-bit shifter"
			prevWord _ interpreterProxy longAt: sourceIndex.
			sourceIndex _ sourceIndex + hInc]
			ifFalse:
			[prevWord _ 0].

	"Note: the horizontal loop has been expanded into three parts for speed:"

			"This first section requires masking of the destination store..."
			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"
			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)
							bitOr:  "32-bit rotate"
						((thisWord bitAnd: skewMask) bitShift: skew).
			prevWord _ thisWord.
			sourceIndex _ sourceIndex + hInc.
			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)
								with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex
				put: ((mask1 bitAnd: mergeWord)
					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + hInc.

		"This central horizontal loop requires no store masking"
combinationRule = 3
ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"
			[ :word |
			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"
			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)
							bitOr:  "32-bit rotate"
						((thisWord bitAnd: skewMask) bitShift: skew).
			prevWord _ thisWord.
			sourceIndex _ sourceIndex + hInc.
			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).
			destIndex _ destIndex + hInc]
] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"
			[ :word |
			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"
			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)
							bitOr:  "32-bit rotate"
						((thisWord bitAnd: skewMask) bitShift: skew).
			prevWord _ thisWord.
			sourceIndex _ sourceIndex + hInc.
			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)
								with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex put: mergeWord.
			destIndex _ destIndex + hInc]
].

		"This last section, if used, requires masking of the destination store..."
		nWords > 1 ifTrue:
			[thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"
			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)
							bitOr:  "32-bit rotate"
						((thisWord bitAnd: skewMask) bitShift: skew).
			prevWord _ thisWord.
			sourceIndex _ sourceIndex + hInc.
			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)
								with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex
				put: ((mask2 bitAnd: mergeWord)
					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + hInc].

	sourceIndex _ sourceIndex + sourceDelta.
	destIndex _ destIndex + destDelta]!
copyLoopNoSource
	| halftoneWord mergeWord |
	"Faster copyLoop when source not used.  hDir and vDir are both
	positive, and perload and skew are unused"

	1 to: bbH do: "here is the vertical loop"
		[ :i |
		noHalftone
			ifTrue: [halftoneWord _ AllOnes]
			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].

	"Note: the horizontal loop has been expanded into three parts for speed:"

			"This first section requires masking of the destination store..."
			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex
				put: ((mask1 bitAnd: mergeWord)
					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + 4.

		"This central horizontal loop requires no store masking"
combinationRule = 3
ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"
			[ :word |
			interpreterProxy longAt: destIndex put: halftoneWord.
			destIndex _ destIndex + 4].
] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"
			[ :word |
			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex put: mergeWord.
			destIndex _ destIndex + 4].

].

		"This last section, if used, requires masking of the destination store..."
		nWords > 1 ifTrue:
			[mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).
			interpreterProxy longAt: destIndex
				put: ((mask2 bitAnd: mergeWord)
					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + 4].

	destIndex _ destIndex + destDelta]!
copyLoopPixMap
	| skewWord halftoneWord mergeWord destMask srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap |
	"This version of the inner loop maps source pixels
	to a destination form with different depth.  Because it is already
	unweildy, the loop is not unrolled as in the other versions.
	Preload, skew and skewMask are all overlooked, since pickSourcePixels
	delivers its destination word already properly aligned.
	Note that pickSourcePixels could be copied in-line at the top of
	the horizontal loop, and some of its inits moved out of the loop."

	"Additional inits peculiar to unequal source and dest pix size..."
	srcPixPerWord _ 32//sourcePixSize.
	sourcePixMask _ (1 bitShift: sourcePixSize) - 1.
	destPixMask _ (1 bitShift: destPixSize) - 1.
	nullMap _ colorMap = interpreterProxy nilObject.
	sourceIndex _ (sourceBits + 4) +
					(sy * sourceRaster + (sx // srcPixPerWord) *4).
	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).
	bbW < scrStartBits
		ifTrue: [nSourceIncs _ 0]
		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].
	sourceDelta _ (sourceRaster - nSourceIncs) * 4.

	"Note following two items were already calculated in destmask setup!!"
	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).
	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.

	1 to: bbH do: "here is the vertical loop"
		[ :i |
		noHalftone
			ifTrue: [halftoneWord _ AllOnes]
			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].
		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.
		destMask _ mask1.
		"pick up first word"
		bbW < startBits
			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.
					skewWord _ skewWord
							bitShift: (startBits - bbW)*destPixSize]
			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]. 

		"Here is the horizontal loop..."
		1 to: nWords do: "here is the inner horizontal loop"
			[ :word |
			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)
				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).
			interpreterProxy longAt: destIndex
				put: ((destMask bitAnd: mergeWord)
					bitOr:
					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + 4.
			word >= (nWords - 1) ifTrue:
				[word = nWords ifFalse:
					["set mask for last word in this row"
					destMask _ mask2.
					skewWord _ self pickSourcePixels: endBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.
					skewWord _ skewWord
							bitShift: (pixPerWord-endBits)*destPixSize]]
				ifFalse: 
				["use fullword mask for inner loop"
				destMask _ AllOnes.
				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].

	sourceIndex _ sourceIndex + sourceDelta.
	destIndex _ destIndex + destDelta]!
deltaFrom: x1 to: x2 nSteps: n
	"Utility routine for computing Warp increments.
	Takes care to deal with 0...N meaning pixels 0 through N-1"
	| delta |  "assume n >= 1"
	delta _ x2 - x1.
	delta > 0 ifTrue: [^ delta - 1 // n]  "Shrink by 1 so never hit pix N"
		ifFalse: [delta = 0 ifTrue: [^ 0]
			ifFalse: [^ delta + 2 // n]]  "Same for neg delta, but shrink
										by 2 because start is offset by 1"!
warpLoop
	| skewWord halftoneWord mergeWord destMask startBits
	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy
	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps |

	"This version of the inner loop traverses an arbirary quadrilateral
	source, thus producing a general affine transformation."
 
	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)
		ifFalse: [^ interpreterProxy primitiveFail].
	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].

	pAx _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.
	deltaP12x _ self deltaFrom: pAx
			to: (interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop)
			nSteps: nSteps.
	deltaP12x < 0 ifTrue: [pAx _ pAx - 1].

	pAy _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.
	deltaP12y _ self deltaFrom: pAy
			to: (interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop)
			nSteps: nSteps.
	deltaP12y < 0 ifTrue: [pAy _ pAy - 1].

	pBx _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.
	deltaP43x _ self deltaFrom: pBx
			to: (interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop)
			nSteps: nSteps.
	deltaP43x < 0 ifTrue: [pBx _ pBx - 1].

	pBy _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.
	deltaP43y _ self deltaFrom: pBy
			to: (interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop)
			nSteps: nSteps.
	deltaP43y < 0 ifTrue: [pBy _ pBy - 1].

	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"
	interpreterProxy argCount = 2
		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.
				sourceMapOop _ interpreterProxy stackValue: 0.
				sourceMapOop = interpreterProxy nilObject
				ifTrue: [destPixSize < 16 ifTrue:
					["color map is required to smooth non-RGB dest"
					^ interpreterProxy primitiveFail]]
				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)
							< (1 << sourcePixSize) ifTrue:
					["sourceMap must be long enough for sourcePixSize"
					^ interpreterProxy primitiveFail]]]
		ifFalse: [smoothingCount _ 1.
				sourceMapOop _ interpreterProxy nilObject].
	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).
	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1].
 
	1 to: bbH do:
		[ :i |		"here is the vertical loop..."
		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps.
 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pAx - 1].
		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps.
 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pAy - 1].

		noHalftone
			ifTrue: [halftoneWord _ AllOnes]
			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].
		destMask _ mask1.
		"pick up first word"
		bbW < startBits
			ifTrue: [skewWord _ self warpSourcePixels: bbW
									xDeltah: xDelta yDeltah: yDelta
									xDeltav: deltaP12x yDeltav: deltaP12y
									smoothing: smoothingCount sourceMap: sourceMapOop.
					skewWord _ skewWord
							bitShift: (startBits - bbW)*destPixSize]
			ifFalse: [skewWord _ self warpSourcePixels: startBits
									xDeltah: xDelta yDeltah: yDelta
									xDeltav: deltaP12x yDeltav: deltaP12y
									smoothing: smoothingCount sourceMap: sourceMapOop].
 
		1 to: nWords do:
			[ :word |		"here is the inner horizontal loop..."
			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)
				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).
			interpreterProxy longAt: destIndex
				put: ((destMask bitAnd: mergeWord)
					bitOr:
					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).
			destIndex _ destIndex + 4.
			word >= (nWords - 1) ifTrue:
				[word = nWords ifFalse:
					["set mask for last word in this row"
					destMask _ mask2.
					skewWord _ self warpSourcePixels: pixPerWord
									xDeltah: xDelta yDeltah: yDelta
									xDeltav: deltaP12x yDeltav: deltaP12y
									smoothing: smoothingCount sourceMap: sourceMapOop]]
				ifFalse:
				["use fullword mask for inner loop"
				destMask _ AllOnes.
				skewWord _ self warpSourcePixels: pixPerWord
									xDeltah: xDelta yDeltah: yDelta
									xDeltav: deltaP12x yDeltav: deltaP12y
									smoothing: smoothingCount sourceMap: sourceMapOop].
		].
	pAx _ pAx + deltaP12x.
	pAy _ pAy + deltaP12y.
	pBx _ pBx + deltaP43x.
	pBy _ pBy + deltaP43y.
	destIndex _ destIndex + destDelta]! !
!BitBltSimulation methodsFor: 'translation support'!
cCode: codeString
	"For translation only; noop when running in Smalltalk."

	^ codeString! !
!BitBltSimulation methodsFor: 'combination rules'!
alphaBlend: sourceWord with: destinationWord
	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.
	The source is assumed to have 255*alpha in the high 8 bits of each pixel,
	while the high 8 bits of the destinationWord will be ignored.
	The blend produced is alpha*source + (1-alpha)*dest, with
	the computation being performed independently on each color
	component.  The high byte of the result will be 0."
	| alpha unAlpha colorMask result blend shift |
	alpha _ sourceWord >> 24.  "High 8 bits of source pixel"
	unAlpha _ 255 - alpha.
	colorMask _ 16rFF.
	result _ 0.
	1 to: 3 do:
		[:i | shift _ (i-1)*8.
		blend _ (((sourceWord>>shift bitAnd: colorMask) * alpha)
					+ ((destinationWord>>shift bitAnd: colorMask) * unAlpha))
			 	+ 254 // 255 bitAnd: colorMask.
		result _ result bitOr: blend<<shift].
	^ result
!
merge: sourceWord with: destinationWord
"
	^ self dispatchOn: combinationRule
		with: sourceWord with: destinationWord
		in: RuleTable.
"
	"These are the combination rules..."
combinationRule < 16 ifTrue:
[combinationRule < 8 ifTrue:
	[combinationRule < 4 ifTrue:
		[combinationRule < 2 ifTrue:
			[combinationRule < 1 ifTrue:
				["0" ^ 0]
				ifFalse:
				["1" ^ sourceWord bitAnd: destinationWord]]
			ifFalse:
			[combinationRule < 3 ifTrue:
				["2" ^ sourceWord bitAnd: destinationWord bitInvert32]
				ifFalse:
				["3" ^ sourceWord]]]
		ifFalse:
		[combinationRule < 6 ifTrue:
			[combinationRule < 5 ifTrue:
				["4" ^ sourceWord bitInvert32 bitAnd: destinationWord]
				ifFalse:
				["5" ^ destinationWord]]
			ifFalse:
			[combinationRule < 7 ifTrue:
				["6" ^ sourceWord bitXor: destinationWord]
				ifFalse:
				["7" ^ sourceWord bitOr: destinationWord]]]]
	ifFalse:
	[combinationRule < 12 ifTrue:
		[combinationRule < 10 ifTrue:
			[combinationRule < 9 ifTrue:
				["8" ^ sourceWord bitInvert32 bitAnd: destinationWord bitInvert32]
				ifFalse:
				["9" ^ sourceWord bitInvert32 bitXor: destinationWord]]
			ifFalse:
			[combinationRule < 11 ifTrue:
				["10" ^ destinationWord bitInvert32]
				ifFalse:
				["11" ^ sourceWord bitOr: destinationWord bitInvert32]]]
		ifFalse:
		[combinationRule < 14 ifTrue:
			[combinationRule < 13 ifTrue:
				["12" ^ sourceWord bitInvert32]
				ifFalse:
				["13" ^ sourceWord bitInvert32 bitOr: destinationWord]]
			ifFalse:
			[combinationRule < 15 ifTrue:
				["14" ^ sourceWord bitInvert32 bitOr: destinationWord bitInvert32]
				ifFalse:
				["15" ^ destinationWord]]]]]
ifFalse:
[combinationRule < 24 ifTrue:
	[combinationRule < 20 ifTrue:
		[combinationRule < 18 ifTrue:
			[combinationRule < 17 ifTrue:
				["16" ^ destinationWord "no op"]
				ifFalse:
				["17" ^ destinationWord "no op"]]
			ifFalse:
			[combinationRule < 19 ifTrue:
				["18" ^ sourceWord + destinationWord]
				ifFalse:
				["19" ^ sourceWord - destinationWord]]]
		ifFalse:
		[combinationRule < 22 ifTrue:
			[combinationRule < 21 ifTrue:
				["20" ^ self rgbAdd: sourceWord with: destinationWord]
				ifFalse:
				["21" ^ self rgbSub: sourceWord with: destinationWord]]
			ifFalse:
			[combinationRule < 23 ifTrue:
				["22" ^ self rgbDiff: sourceWord with: destinationWord]
				ifFalse:
				["23" ^ self tallyIntoMap: destinationWord]]]]
	ifFalse:
	[combinationRule < 28 ifTrue:
		[combinationRule < 26 ifTrue:
			[combinationRule < 25 ifTrue:
				["24" ^ self alphaBlend: sourceWord with: destinationWord]
				ifFalse:
				["25"  ^ self pixPaint: sourceWord with: destinationWord]]
			ifFalse:
			[combinationRule < 27 ifTrue:
				["26" ^ self pixMask: sourceWord with: destinationWord]
				ifFalse:
				["27" ^ destinationWord "no op"]]]
		ifFalse:
		[combinationRule < 30 ifTrue:
			[combinationRule < 29 ifTrue:
				["28" ^ destinationWord "no op"]
				ifFalse:
				["29" ^ destinationWord "no op"]]
			ifFalse:
			[combinationRule < 31 ifTrue:
				["30" ^ destinationWord "no op"]
				ifFalse:
				["31" ^ destinationWord "no op"]]]]]!
partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts
	"Add word1 to word2 as nParts partitions of nBits each.
	This is useful for packed pixels, or packed colors"
	| mask sum result |
	mask _ (1 << nBits) - 1.  "partition mask starts at the right"
	result _ 0.
	1 to: nParts do:
		[:i |
		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).
		sum <= mask  "result must not carry out of partition"
			ifTrue: [result _ result bitOr: sum]
			ifFalse: [result _ result bitOr: mask].
		mask _ mask << nBits  "slide left to next partition"].
	^ result
!
partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts
	"AND word1 to word2 as nParts partitions of nBits each.
	Any field of word1 not all-ones is treated as all-zeroes.
	Used for erasing, eg, brush shapes prior to ORing in a color"
	| mask result |
	mask _ (1 << nBits) - 1.  "partition mask starts at the right"
	result _ 0.
	1 to: nParts do:
		[:i |
		(word1 bitAnd: mask) = mask
			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].
		mask _ mask << nBits  "slide left to next partition"].
	^ result
!
partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts
	"Subtract word1 from word2 as nParts partitions of nBits each.
	This is useful for packed pixels, or packed colors"
	| mask result p1 p2 |
	mask _ (1 << nBits) - 1.  "partition mask starts at the right"
	result _ 0.
	1 to: nParts do:
		[:i |
		p1 _ word1 bitAnd: mask.
		p2 _ word2 bitAnd: mask.
		p1 < p2  "result is really abs value of thedifference"
			ifTrue: [result _ result bitOr: p2 - p1]
			ifFalse: [result _ result bitOr: p1 - p2].
		mask _ mask << nBits  "slide left to next partition"].
	^ result
!
pixMask: sourceWord with: destinationWord
	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord
					nBits: destPixSize nPartitions: pixPerWord!
pixPaint: sourceWord with: destinationWord
	^ sourceWord bitOr:
		(self partitionedAND: sourceWord bitInvert32 to: destinationWord
						nBits: destPixSize nPartitions: pixPerWord)!
rgbAdd: sourceWord with: destinationWord
	destPixSize < 16 ifTrue:
		["Add each pixel separately"
		^ self partitionedAdd: sourceWord to: destinationWord
						nBits: destPixSize nPartitions: pixPerWord].
	destPixSize = 16 ifTrue:
		["Add RGB components of each pixel separately"
		^ (self partitionedAdd: sourceWord to: destinationWord
						nBits: 5 nPartitions: 3)
		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16
						nBits: 5 nPartitions: 3) << 16)]
	ifFalse:
		["Add RGB components of the pixel separately"
		^ self partitionedAdd: sourceWord to: destinationWord
						nBits: 8 nPartitions: 3]!
rgbDiff: sourceWord with: destinationWord
	"Subract the pixels in the source and destination, color by color,
	and return the sum of the absolute value of all the differences.
	For non-rgb, XOR the two and return the number of differing pixels.
	Note that the region is not clipped to bit boundaries, but only to the
	nearest (enclosing) word.  This is because copyLoop does not do
	pre-merge masking.  For accurate results, you must subtract the
	values obtained from the left and right fringes."
	| diff pixMask |
	destPixSize < 16 ifTrue:
		["Just xor and count differing bits if not RGB"
		diff _ sourceWord bitXor: destinationWord.
		pixMask _ (1 bitShift: destPixSize) - 1.
		[diff = 0] whileFalse:
			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].
			diff _ diff >> destPixSize].
		^ destinationWord "for no effect"].
 	destPixSize = 16
		ifTrue:
		[diff _ (self partitionedSub: sourceWord from: destinationWord
						nBits: 5 nPartitions: 3).
		bitCount _ bitCount + (diff bitAnd: 16r1F)
							+ (diff>>5 bitAnd: 16r1F)
							+ (diff>>10 bitAnd: 16r1F).
		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16
						nBits: 5 nPartitions: 3).
		bitCount _ bitCount + (diff bitAnd: 16r1F)
							+ (diff>>5 bitAnd: 16r1F)
							+ (diff>>10 bitAnd: 16r1F)]
		ifFalse:
		[diff _ (self partitionedSub: sourceWord from: destinationWord
						nBits: 8 nPartitions: 3).
		bitCount _ bitCount + (diff bitAnd: 16rFF)
							+ (diff>>8 bitAnd: 16rFF)
							+ (diff>>16 bitAnd: 16rFF)].
	^ destinationWord  "For no effect on dest"!
rgbSub: sourceWord with: destinationWord
	destPixSize < 16 ifTrue:
		["Sub each pixel separately"
		^ self partitionedSub: sourceWord from: destinationWord
						nBits: destPixSize nPartitions: pixPerWord].
	destPixSize = 16 ifTrue:
		["Sub RGB components of each pixel separately"
		^ (self partitionedSub: sourceWord from: destinationWord
						nBits: 5 nPartitions: 3)
		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16
						nBits: 5 nPartitions: 3) << 16)]
	ifFalse:
		["Sub RGB components of the pixel separately"
		^ self partitionedSub: sourceWord from: destinationWord
						nBits: 8 nPartitions: 3]!
tallyIntoMap: destinationWord
	"Tally pixels into the color map.  Note that the source should be 
	specified = destination, in order for the proper color map checks 
	to be performed at setup.
	Note that the region is not clipped to bit boundaries, but only to the
	nearest (enclosing) word.  This is because copyLoop does not do
	pre-merge masking.  For accurate results, you must subtract the
	values obtained from the left and right fringes."
	| mapIndex pixMask shiftWord |
	colorMap = interpreterProxy nilObject
		ifTrue: [^ destinationWord "no op"].
	destPixSize < 16 ifTrue:
		["loop through all packed pixels."
		pixMask _ (1<<destPixSize) - 1.
		shiftWord _ destinationWord.
		1 to: pixPerWord do:
			[:i |
			mapIndex _ shiftWord bitAnd: pixMask.
			interpreterProxy storeWord: mapIndex ofObject: colorMap
				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.
			shiftWord _ shiftWord >> destPixSize].
		^ destinationWord].
	destPixSize = 16 ifTrue:
		["Two pixels  Tally the right half..."
		mapIndex _ self rgbMap: destinationWord from: 5 to: cmBitsPerColor.
		interpreterProxy storeWord: mapIndex ofObject: colorMap
			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.
		"... and then left half"
		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.
		interpreterProxy storeWord: mapIndex ofObject: colorMap
			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]
	ifFalse:
		["Just one pixel."
		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.
		interpreterProxy storeWord: mapIndex ofObject: colorMap
			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].
	^ destinationWord  "For no effect on dest"! !
!BitBltSimulation methodsFor: 'pixel mapping'!
pickSourcePixels: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask
	"This is intended to be expanded in-line; it merely calls the others"
	sourcePixSize >= 16 ifTrue:
		[^ self pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask].
	nullMap ifTrue:
		[^ self pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask].
	^ self pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask!
pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask
	"This version of pickSourcePixels is for sourcePixSize <= 8
		and colorMap notNil"
	"Pick nPix pixels from the source, mapped by the
	color map, and right-justify them in the resulting destWord."
	| sourceWord destWord sourcePix destPix |
	sourceWord _ (interpreterProxy longAt: sourceIndex).
	destWord _ 0.
	1 to: nPix do:
		[:i |
		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)
					bitAnd: sourcePixMask.
		"look up sourcePix in colorMap"
		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.
		destWord _ (destWord << destPixSize) bitOr: destPix.
		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:
			[srcBitIndex _ srcBitIndex - 32.
			sourceIndex _ sourceIndex + 4.
			sourceWord _ interpreterProxy longAt: sourceIndex]].
	^ destWord!
pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask
	"This version of pickSourcePixels is for colorMap==nil.
		SourcePixelSize is also known to be 8 bits or less."
	"With no color map, pixels are just masked or zero-filled."
	| sourceWord destWord sourcePix |
	sourceWord _ (interpreterProxy longAt: sourceIndex).
	destWord _ 0.
	1 to: nPix do:
		[:i |
		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)
					bitAnd: sourcePixMask.
		destWord _ (destWord << destPixSize) 
					bitOr: (sourcePix bitAnd: destPixMask).
		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:
			[srcBitIndex _ srcBitIndex - 32.
			sourceIndex _ sourceIndex + 4.
			sourceWord _ interpreterProxy longAt: sourceIndex]].
	^ destWord!
pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask
	"This version of pickSourcePixels is for destPixSize >= 16"
	"Pick nPix pixels from the source, mapped by the
	color map, and right-justify them in the resulting destWord.
	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.
	With no color map, pixels are just masked or zero-filled or
	if 16- or 32-bit pixels, the r, g, and b are so treated individually."
	| sourceWord destWord sourcePix destPix |
	sourceWord _ (interpreterProxy longAt: sourceIndex).
	destWord _ 0.
	1 to: nPix do:
		[:i |
		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)
					bitAnd: sourcePixMask.
		nullMap
		ifTrue:
			["Map between RGB pixels"
			sourcePixSize = 16
				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]
				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]
		ifFalse:
			["RGB pixels first get reduced to cmBitsPerColor"
			sourcePixSize = 16
				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]
				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].
			"Then look up sourcePix in colorMap"
			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].
		destWord _ (destWord << destPixSize) bitOr: destPix.
		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:
			[srcBitIndex _ srcBitIndex - 32.
			sourceIndex _ sourceIndex + 4.
			sourceWord _ interpreterProxy longAt: sourceIndex]].
	^ destWord!
rgbMap: sourcePixel from: nBitsIn to: nBitsOut
	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."
	| mask d srcPix destPix |
	(d _ nBitsOut - nBitsIn) > 0
		ifTrue:
			["Expand to more bits by zero-fill"
			mask _ (1 << nBitsIn) - 1.  "Transfer mask"
			srcPix _ sourcePixel << d.
			mask _ mask << d.
			destPix _ srcPix bitAnd: mask.
			mask _ mask << nBitsOut.
			srcPix _ srcPix << d.
			^ destPix + (srcPix bitAnd: mask)
				 	+ (srcPix << d bitAnd: mask << nBitsOut)]
		ifFalse:
			["Compress to fewer bits by truncation"
			d = 0 ifTrue: [^ sourcePixel].
			d _ nBitsIn - nBitsOut.
			mask _ (1 << nBitsOut) - 1.  "Transfer mask"
			srcPix _ sourcePixel >> d.
			destPix _ srcPix bitAnd: mask.
			mask _ mask << nBitsOut.
			srcPix _ srcPix >> d.
			^ destPix + (srcPix bitAnd: mask)
					+ (srcPix >> d bitAnd: mask << nBitsOut)]
!
smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv
	pixPerWord: srcPixPerWord pixelMask: sourcePixMask
	sourceMap: sourceMap
	| sourcePix r g b x y rgb bitsPerColor d nPix |
	r _ g _ b _ 0.  "Separate r, g, b components"
	nPix _ n*n.
	x _ xf.  y _ yf.
	0 to: n-1 do:
		[:i |
		0 to: n-1 do:
			[:j |
			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint
									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint
									pixPerWord: srcPixPerWord)
									bitAnd: sourcePixMask.
			sourcePixSize < 16
				ifTrue: ["Get 24-bit RGB values from sourcemap table"
						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]
				ifFalse: ["Already in RGB format"
						sourcePixSize = 32
						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]
						ifFalse: ["Note could be faster"
								rgb _ self rgbMap: sourcePix from: 5 to: 8]].
			r _ r + ((rgb >> 16) bitAnd: 16rFF).
			g _ g + ((rgb >> 8) bitAnd: 16rFF).
			b _ b + (rgb bitAnd: 16rFF).
			].
		].
	colorMap ~= interpreterProxy nilObject
		ifTrue: [bitsPerColor _ cmBitsPerColor]
		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].
				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].
	d _ 8 - bitsPerColor.
	rgb _ ((r // nPix >> d) << (bitsPerColor*2))
		+ ((g // nPix >> d) << bitsPerColor)
		+ ((b // nPix >> d)).
	colorMap ~= interpreterProxy nilObject
		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]
		ifFalse: [^ rgb]
!
sourcePixAtX: x y: y pixPerWord: srcPixPerWord
	| sourceWord index |
	(x < 0 or: [x >= srcWidth]) ifTrue: [^ 0].
	(y < 0 or: [y >= srcHeight]) ifTrue: [^ 0].
	index _ (y * sourceRaster + (x // srcPixPerWord) *4).
												"4 = BaseHeaderSize"
	sourceWord _ interpreterProxy longAt: sourceBits + 4 + index.
	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))!
warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah
	xDeltav: xDeltav yDeltav: yDeltav
	smoothing: n sourceMap: sourceMapOop
	"Pick nPix pixels using these x- and y-incs, and map color if necess."

	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |
	sourcePixMask _ (1 << sourcePixSize) - 1.
	srcPixPerWord _ 32 // sourcePixSize.
	destPixMask _ (1 << destPixSize) - 1.
	destWord _ 0.
	1 to: nPix do:
		[:i |
		n > 1
		ifTrue:
			["Average n pixels and compute dest pixel from color map"
			destPix _ (self smoothPix: n atXf: sx yf: sy
				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n
				pixPerWord: srcPixPerWord pixelMask: sourcePixMask
				sourceMap: sourceMapOop)
					bitAnd: destPixMask]
		ifFalse:
			["No smoothing -- just pick pixel and map if difft depths or color map supplied"
			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint
									y: sy >> BinaryPoint
									pixPerWord: srcPixPerWord)
						bitAnd: sourcePixMask.
			colorMap = interpreterProxy nilObject
				ifTrue:
				[destPixSize = sourcePixSize
				ifTrue:
					[destPix _ sourcePix]
				ifFalse:
					[sourcePixSize >= 16 ifTrue:
						["Map between RGB pixels"
						sourcePixSize = 16
							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]
							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]
					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]
			ifFalse:
				[sourcePixSize >= 16 ifTrue:
					["RGB pixels first get reduced to cmBitsPerColor"
					sourcePixSize = 16
						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]
						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].
				"Then look up sourcePix in colorMap"
				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].
		destWord _ (destWord << destPixSize) bitOr: destPix.
		sx _ sx + xDeltah.
		sy _ sy + yDeltah.
		].
	^ destWord! !
!BitBltSimulation class methodsFor: 'initialization'!
initialize
	"BitBltSimulation initialize"
 
	"Mask constants"
	AllOnes _ 16rFFFFFFFF.
	BinaryPoint _ 14.
	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation"
 
	"Indices into stopConditions for scanning"
	EndOfRun _ 257.
	CrossedX _ 258.
 
	"Form fields"
	FormBitsIndex _ 0.
	FormWidthIndex _ 1.
	FormHeightIndex _ 2.
	FormDepthIndex _ 3.
 
	"BitBlt fields"
	BBDestFormIndex _ 0.
	BBSourceFormIndex _ 1.
	BBHalftoneFormIndex _ 2.
	BBRuleIndex _ 3.
	BBDestXIndex _ 4.
	BBDestYIndex _ 5.
	BBWidthIndex _ 6.
	BBHeightIndex _ 7.
	BBSourceXIndex _ 8.
	BBSourceYIndex _ 9.
	BBClipXIndex _ 10.
	BBClipYIndex _ 11.
	BBClipWidthIndex _ 12.
	BBClipHeightIndex _ 13.
	BBColorMapIndex _ 14.
	BBWarpBase _ 15.
	BBLastIndex _ 15.
	BBXTableIndex _ 16.!
test2  "BitBltSimulation test2"
	| f |
	Display fillWhite: (0@0 extent: 300@140).
	1 to: 12 do:
		[:i | f _ (Form extent: i@5) fillBlack.
		0 to: 20 do:
			[:x | f displayOn: Display
					at: (x*13) @ (i*10)]]!
timingTest: extent  "BitBltSimulation timingTest: 640@480"
	| f f2 map |
	f _ Form extent: extent depth: 8.
	f2 _ Form extent: extent depth: 8.
	map _ Bitmap new: 1 << f2 depth.
	^ Array with:
	(Time millisecondsToRun: [100 timesRepeat:
		[f fillWithColor: Color white]])
	with:
	(Time millisecondsToRun: [100 timesRepeat:
		[f copy: f boundingBox from: 0@0 in: f2 rule: Form over]])
	with:
	(Time millisecondsToRun: [100 timesRepeat:
		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])! !
!BitBltSimulation class methodsFor: 'translation'!
declareCVarsIn: aCCodeGenerator

	"Nothing to declare..."! !
!BitEditor methodsFor: 'control defaults'!
redButtonActivity
	| formPoint displayPoint |
	model depth = 1 ifTrue:
		["If this is just a black&white form, then set the color to be
		the opposite of what it was where the mouse was clicked"
		formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.
		color _ 1-(view workingForm pixelValueAt: formPoint).
		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].
	[sensor redButtonPressed]
	  whileTrue: 
		[formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.
		displayPoint _ view displayTransform: formPoint.
		squareForm 
			displayOn: Display
			at: displayPoint 
			clippingBox: view insetDisplayBox 
			rule: Form over
			fillColor: nil.
		view changeValueAt: formPoint put: color]! !
!BitEditor class methodsFor: 'private'!
buildColorMenu: extent colorCount: nColors
	"See BitEditor magnifyWithSmall."

	| menuView form aSwitchView
	button formExtent highlightForm color leftOffset |
	menuView _ FormMenuView new.
	menuView window: (0@0 corner: extent).
	formExtent _ 30@30 min: extent//(nColors*2+1@2).  "compute this better"
	leftOffset _ extent x-(nColors*2-1*formExtent x)//2.
	highlightForm _ Form extent: formExtent.
	highlightForm borderWidth: 4.
	1 to: nColors do:
		[:index | 
		color _ (nColors=1
			ifTrue: [#(black)]
			ifFalse: [#(black gray)]) at: index.
		form _ Form extent: formExtent.
		form fill: form boundingBox fillColor: (Color perform: color).
		form borderWidth: 5.
		form border: form boundingBox width: 4 fillColor: form white.
		button _ Button new.
		index = 1 ifTrue:
			[button onAction: [menuView model setColor: Color fromUser]]
			ifFalse:
			[button onAction: [menuView model setTransparentColor]].

		aSwitchView _ SwitchView new model: button.
		aSwitchView key: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index).
		aSwitchView label: form.
		aSwitchView window: (0@0 extent: form extent).
		aSwitchView translateBy: (index-1*2*form width+leftOffset) @ (form height//2).
		aSwitchView highlightForm: highlightForm.
	
		aSwitchView borderWidth: 1.
		aSwitchView controller selector: #turnOn.
		menuView addSubView: aSwitchView].
	^menuView!
locateMagnifiedView: aForm scale: scaleFactor
	"Answer a rectangle at the location where the scaled view of the form,
	aForm, should be displayed."

	^ Rectangle originFromUser: (aForm extent * scaleFactor + (0@50)).
	! !
!BlockNode methodsFor: 'code generation'!
emitForValue: stack on: aStream

	aStream nextPut: LdThisContext.
	stack push: 1.
	nArgsNode emitForValue: stack on: aStream.
	remoteCopyNode
		emit: stack
		args: 1
		on: aStream.
	"Force a two byte jump."
	self emitLong: size code: JmpLong on: aStream.
	stack push: arguments size.
	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].
	self emitForEvaluatedValue: stack on: aStream.
	self returns ifFalse: [aStream nextPut: EndRemote].
	stack pop: 1! !
!BlockNode methodsFor: 'printing'!
printStatementsOn: aStream indent: levelOrZero
	| len shown thisStatement level |
	level _ 1 max: levelOrZero.
	comment == nil
		ifFalse: 
			[self printCommentOn: aStream indent: level.
			aStream crtab: level].
	len _ shown _ statements size.
	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])
		ifTrue: [shown _ 1 max: shown - 1]
		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])
					ifTrue: [shown _ shown - 1]].
	1 to: shown do: 
		[:i | 
		thisStatement _ statements at: i.
		thisStatement printOn: aStream indent: level.
		i < shown ifTrue: [aStream nextPut: $.; crtab: level].
		thisStatement comment size > 0
			ifTrue: 
				[i = shown ifTrue: [aStream crtab: level].
				thisStatement printCommentOn: aStream indent: level.
				i < shown ifTrue: [aStream crtab: level]]]! !
!BlockNode methodsFor: 'C translation'!
asTranslatorNode
	| statementList newS |
	statementList _ OrderedCollection new.
	statements do: [ :s |
		newS _ s asTranslatorNode.
		newS isStmtList ifTrue: [
			"inline the statement list returned when a CascadeNode is translated"
			statementList addAll: newS statements.
		] ifFalse: [
			statementList add: newS.
		].
	].
	^TStmtListNode new
		setArguments: (arguments asArray collect: [ :arg | arg key ])
		statements: statementList! !
!BraceNode methodsFor: 'code generation'!
emitForValue: stack on: aStream
	"elem1, ..., elemN, collectionClass, N, fromBraceStack:"

	elements do: [:element | element emitForValue: stack on: aStream].
	collClassNode emitForValue: stack on: aStream.
	nElementsNode emitForValue: stack on: aStream.
	fromBraceStackNode emit: stack args: 1 on: aStream.
	stack pop: elements size! !
!Browser methodsFor: 'system category functions'!
browseAllClasses
	"Create and schedule a new browser on all classes alphabetically."
	| newBrowser view |
	newBrowser _ HierarchyBrowser new initAlphabeticListing.
	BrowserView openBrowserView: (BrowserView systemCategoryBrowser: newBrowser editString: nil)
		label: 'All Classes Alphabetically'! !
!Browser methodsFor: 'class list'!
classListIndex: anInteger 
        "Set anInteger to be the index of the current class selection."

        | className |
classListIndex _ anInteger.
        self setClassOrganizer.
        messageCategoryListIndex _ 0.
        messageListIndex _ 0.
        editSelection _ anInteger = 0
                        ifTrue: [metaClassIndicated
                                ifTrue: [#none]
                                ifFalse: [#newClass]]
                        ifFalse: [#editClass].
        contents _ nil.
        self selectedClass isNil
                ifFalse: [className _ self selectedClass name.
					(RecentClasses includes: className)
                                ifTrue: [RecentClasses remove: className].
                        RecentClasses addFirst: className.
                        RecentClasses size > 16
                                ifTrue: [RecentClasses removeLast]].
        self changed: #classSelectionChanged!
hierarchy
        "Display the inheritance hierarchy of the receiver's selected class."

        classListIndex = 0 ifTrue: [^ self].
        self okToChange ifFalse: [^ self].
        self messageCategoryListIndex: 0.
        editSelection := #hierarchy.
        self changed: #editComment.
        ^ self!
recent
	"Let the user select from a list of recently visited classes."
	| className class |
	className := (SelectionMenu selections:
					(RecentClasses select: [:n | Smalltalk includesKey: n])) startUp.
	className == nil ifTrue: [^ self].
	class := Smalltalk at: className.
	self systemCategoryListIndex: (self systemCategoryList indexOf: class category).
	self classListIndex: (self classList indexOf: class name)!
selectClass: classNotMeta
	self classListIndex: (self classList findFirst: [:each | each == classNotMeta name])!
spawnHierarchy
        "Create and schedule a new class hierarchy browser on the currently selected class or meta."
        | newBrowser view |
        classListIndex = 0 ifTrue: [^ self].
        newBrowser _ HierarchyBrowser new initHierarchyForClass: self selectedClass 
                        meta: metaClassIndicated.
        view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.
        Browser postOpenSuggestion: (Array with: self selectedClassOrMetaClass 
                        with: self selectedMessageName).
        BrowserView openBrowserView: view
                label: self selectedClassName , ' hierarchy'! !
!Browser methodsFor: 'class functions'!
spawnProtocol
        "Create and schedule a new protocol browser on the currently selected class or meta."

        classListIndex = 0 ifTrue: [^ self].
        ProtocolBrowser openSubProtocolForClass: self selectedClass ! !
!Browser methodsFor: 'message functions'!
methodHierarchy 
	"Create and schedule a message set browser on all implementors of the 
	currently selected message selector. Do nothing if no message is selected."
	| sel list tab stab |
	messageListIndex = 0 ifTrue: [^ self].
	sel _ self selectedMessageName.
	list _ OrderedCollection new.
	tab _ ''.
	self selectedClassOrMetaClass allSuperclasses reverseDo:
		[:cl |
		(cl includesSelector: sel) ifTrue:
			[list addLast: tab , cl name, ' ', sel].
		tab _ tab , '  '].
	self selectedClassOrMetaClass allSubclassesWithLevelDo:
		[:cl :level |
		(cl includesSelector: sel) ifTrue:
			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].
			list addLast: tab , stab , cl name, ' ', sel]]
	 	startingLevel: 0.
	Smalltalk browseMessageList: list
		name: 'Inheritance of ' , self selectedMessageName! !
!Browser class methodsFor: 'instance creation'!
newOnClass: aClass 
	"Open a new class browser on this class."
	| index newBrowser |
	newBrowser _ Browser new.
	newBrowser systemCategoryListIndex:
		(index _ SystemOrganization numberOfCategoryOfElement: aClass name).
	newBrowser classListIndex: ((SystemOrganization listAtCategoryNumber: index)
			findFirst: [:each | each == aClass name]).
	newBrowser metaClassIndicated: false.
	BrowserView openClassBrowser: newBrowser editString: nil label: 'Class Browser:', aClass name! !
!Browser class methodsFor: 'class initialization'!
initialize
        "Browser initialize"

        RecentClasses := OrderedCollection new! !
!BrowserCodeController methodsFor: 'menu messages'!
explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil."

	| string tiVars cgVars selectors delimitors numbers sorry reply |
	Cursor execute
		showWhile: 
			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.
			sorry _ sorry , (model isUnlocked
							ifTrue: ['"']
							ifFalse: ['  Also, please cancel or accept."']).
			(string _ self selection asString) isEmpty
				ifTrue: [reply _ '']
				ifFalse: 
					[string _ self explainScan: string.
					"Remove space, tab, cr"
					"Temps and Instance vars need only test strings that are 
					all  
					letters"
					(string detect: [:char | (char isLetter or: [char isDigit]) not]
						ifNone: [])
						~~ nil
						ifFalse: 
							[tiVars _ self explainTemp: string.
							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].
					(tiVars == nil and: [model class == Browser])
						ifTrue: [tiVars _ model explainSpecial: string].
					tiVars == nil
						ifTrue: [tiVars _ '']
						ifFalse: [tiVars _ tiVars , NewLine].
					"Context, Class, Pool, and Global vars, and Selectors need 
					only test symbols"
					(Symbol hasInterned: string ifTrue: [:symbol | symbol])
						ifTrue: 
							[cgVars _ self explainCtxt: symbol.
							cgVars == nil
								ifTrue: 
									[cgVars _ self explainClass: symbol.
									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].
							"See if it is a Selector (sent here or not)"
							selectors _ self explainMySel: symbol.
							selectors == nil
								ifTrue: 
									[selectors _ self explainPartSel: string.
									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]
						ifFalse: [selectors _ self explainPartSel: string].
					cgVars == nil
						ifTrue: [cgVars _ '']
						ifFalse: [cgVars _ cgVars , NewLine].
					selectors == nil
						ifTrue: [selectors _ '']
						ifFalse: [selectors _ selectors , NewLine].
					string size = 1
						ifTrue: ["single special characters"
							delimitors _ self explainChar: string]
						ifFalse: ["matched delimitors"
							delimitors _ self explainDelimitor: string].
					numbers _ self explainNumber: string.
					numbers == nil ifTrue: [numbers _ ''].
					delimitors == nil ifTrue: [delimitors _ ''].
					reply _ tiVars , cgVars , selectors , delimitors , numbers].
			reply size = 0 ifTrue: [reply _ sorry].
			self afterSelectionInsertAndSelect: reply]!
format
	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "

	| selectedClass aCompiler newText locked |
	locked _ model isLocked.
	model messageListIndex = 0 | locked ifTrue: [^view flash].
	selectedClass _ model selectedClassOrMetaClass.
	Cursor execute showWhile: 
		[aCompiler _ selectedClass compilerClass new.
		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.
		newText _ aCompiler
			format: model contents
			in: selectedClass
			notifying: self.
		newText == nil ifFalse: 
			[self replaceSelectionWith:
				(newText asText makeSelectorBoldIn: selectedClass).
			self selectAt: 1]].
	locked ifFalse: [self unlockModel] !
showBytecodes
	"Show the bytecodes of the selected method."

	| selectedClass newText |
	(model messageListIndex = 0) | (model isLocked) ifTrue: [
		^view flash.
	].

	selectedClass _ model selectedClassOrMetaClass.
	Cursor execute showWhile: [
		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.
		newText _ (selectedClass compiledMethodAt: model selectedMessageName) symbolic asText.
		self replaceSelectionWith: newText.
		self selectAt: 1.
	].

	self unlockModel.! !
!BrowserCodeController methodsFor: 'private'!
explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| class reply classes |
	class _ model selectedClass.
	class == nil ifTrue: [^nil].	  "no class is selected"
	(class isKindOf: Metaclass) ifTrue: [class _ class soleInstance].
	classes _ (Array with: class) , class allSuperclasses.

	"class variables"
	reply _ classes detect: [:each | (each classVarNames
			detect: [:name | symbol = name] ifNone: [])
			~~ nil] ifNone: [].
	reply == nil ifFalse: [^'"is a class variable; defined in class ' , reply printString, '"', NewLine,
		'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].

	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]
			ifNone: []) ~~ nil].
	reply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].
	reply == nil
		ifFalse: 
			[classes _ WriteStream on: Array new.
			Smalltalk allBehaviorsDo: [:each |
					(each sharedPools detect: [:pool | pool == reply] ifNone: [])
					~~ nil ifTrue: [classes nextPut: each]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^'"is a pool variable from the pool ' , (Smalltalk keyAtValue: reply),
			', which is used by the following classes ' , classes contents printString , '"', NewLine,
			'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtValue: reply) printString,
			' associationAt: #', symbol, ').'].
	^nil!
explainGlobal: symbol 
	"Is symbol a global variable?"
	| reply classes |
	reply _ Smalltalk at: symbol ifAbsent: [^nil].
	(reply isKindOf: Behavior)
		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,
			'."', NewLine, 'Browser newOnClass: ' , symbol , '.'].
	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].
	reply class == Dictionary
		ifTrue: 
			[classes _ Set new.
			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]
					ifNone: [])
					~~ nil ifTrue: [classes add: each]].
			classes _ classes printString.
			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].
	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'!
explainInst: string 
	"Is string an instance variable of this class?"
	| classes |
	model selectedClassOrMetaClass == nil ifTrue: [^nil].	  "no class is selected"
	classes _ (Array with: model selectedClassOrMetaClass)
				, model selectedClassOrMetaClass allSuperclasses.
	classes _ classes detect: [:each | (each instVarNames
			detect: [:name | name = string] ifNone: [])
			~~ nil] ifNone: [^nil].
	classes _ classes printString.
	^ '"is an instance variable of the receiver; defined in class ' , classes , '"',
		NewLine , classes , ' browseAllAccessesTo: ''' , string , '''.'!
explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"

	| lits whole reply classes s |
	model messageListIndex = 0 ifTrue: [^nil].  "not in a message"
	string last == $: ifFalse: [^nil].
	"Name of this method"
	lits _ Array with: model selectedMessageName.
	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: []) ~~ nil]
				ifNone: []) ~~ nil
		ifTrue: [reply _ ', which is the selector of this very method!!'.
			s _ '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''."']
		ifFalse: 
			["Selectors called from this method"
			lits _ (model selectedClassOrMetaClass compiledMethodAt:
				model selectedMessageName) messages.
			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]
							ifNone: []) ~~ nil]
						ifNone: []) ~~ nil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply _ '.'.
			s _ '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''."'].
	classes _ Smalltalk allClassesImplementing: whole.
	classes size > 12
		ifTrue: [classes _ 'many classes']
		ifFalse: [classes _ 'these classes ' , classes printString].
	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !
!BrowserView class methodsFor: 'instance creation'!
instanceBrowserViewOn: aBrowser
	"Answer an instance of me on the model, aBrowser, which looks at a user-defined instance-class. The view has three subviews.  3/11/96 sw"

	| browserView  messageCategoryListView messageListView browserCodeView |

	browserView _ self new model: aBrowser.
	messageCategoryListView _ self buildMessageCategoryListView: aBrowser.
	messageListView _ self buildMessageListView: aBrowser.
	browserCodeView _ self buildBrowserCodeView: aBrowser editString: nil.

	browserView addSubView: messageCategoryListView.
	browserView addSubView: messageListView.
	browserView addSubView: browserCodeView.

	messageListView 
		align: messageListView viewport topLeft 
		with: messageCategoryListView viewport topRight.

	browserCodeView 
		window: browserCodeView window 
		viewport: (messageCategoryListView viewport bottomLeft 
					corner: messageListView viewport bottomRight + (0 @ 110)).

	^ browserView! !
!ByteArray methodsFor: 'accessing'!
asString
	"Convert to a String with Characters for each byte.
	Fast code uses primitive that avoids character conversion"

	^ (String new: self size) replaceFrom: 1 to: self size with: self! !
!ByteArray methodsFor: 'private'!
printOn: aStream 
	"Refer to the comment in Object|printOn:."

	| tooMany |
	tooMany _ aStream position + self maxPrint.
	aStream nextPutAll: self class name, ' ('.
	self do: 
		[:element | 
		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].
		aStream nextPutAll: element asCharacter hex; space].
	aStream nextPut: $)! !
!CascadeNode methodsFor: 'C translation'!
asTranslatorNode
	^TStmtListNode new
		setArguments: #()
		statements: (messages collect:
			[ :msg | msg asTranslatorNode receiver: receiver asTranslatorNode ])! !

CCodeGenerator comment:
'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing

	Interpreter translate: ''InterpTest.c'' doInlining: true.

(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!
!CCodeGenerator methodsFor: 'public'!
addClass: aClass
	"Add the variables and methods of the given class to the code base."
	| source |
	self checkClassForNameConflicts: aClass.
	aClass classPool associationsDo: [ :assoc |
		constants at: assoc key put: (TConstantNode new setValue: assoc value).
	].
	variables addAll: aClass instVarNames.
'Adding Class ' , aClass name , '...'
displayProgressAt: Sensor cursorPoint
from: 0 to: aClass selectors size
during: [:bar |
	aClass selectors doWithIndex: [ :sel :i | bar value: i.
		source _ aClass sourceCodeAt: sel.
		self addMethod: ((Compiler new parse: source in: aClass notifying: nil) asTMethodFromClass: aClass).
	]].!
codeString
	"Return a string containing all the C code for the code base. Used for testing."

	| stream |
	stream _ ReadWriteStream on: (String new: 1000).
	self emitCCodeOn: stream doInlining: true.
	^stream contents!
codeStringForPrimitives: classAndSelectorList
	"CCodeGenerator new codeStringForPrimitives: #(
		(FMSound mixSampleCount:into:startingAt:)
	)"

	| sel aClass source s verbose meth |
	self initialize.
	classAndSelectorList do: [ :classAndSelector |
		aClass _ Smalltalk at: (classAndSelector at: 1).
		sel _ classAndSelector at: 2.
		source _ aClass sourceCodeAt: sel.
		meth _ ((Compiler new parse: source in: aClass notifying: nil)
				asTMethodFromClass: aClass).
		meth preparePrimitiveInClass: aClass.
		self addMethod: meth.
	].
	s _ ReadWriteStream on: (String new: 1000).

	"method preparation"
	verbose _ false.
	self prepareMethods.
	verbose ifTrue: [
		self printUnboundCallWarnings.
		self printUnboundVariableReferenceWarnings.
		Transcript cr.
	].

	"code generation"
	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].
	self emitCHeaderForPrimitivesOn: s.
	self emitCVariablesOn: s.
	self emitCFunctionPrototypesOn: s.
	methods do: [ :m | m emitCCodeOn: s generator: self ].
	^ s contents!
globalsAsSet
	"Used by the inliner to avoid name clashes with global variables."

	((variablesSetCache == nil) or:
	 [variablesSetCache size ~= variables size]) ifTrue: [
		variablesSetCache _ variables asSet.
	].
	^ variablesSetCache!
initialize

	translationDict _ Dictionary new.
	inlineList _ Array new.
	constants _ Dictionary new.
	variables _ OrderedCollection new.
	variableDeclarations _ Dictionary new.
	methods _ Dictionary new.
	self initializeCTranslationDictionary.!
storeCodeOnFile: fileName doInlining: inlineFlag
	"Store C code for this code base on the given file."

	| stream |
	stream _ FileStream fileNamed: fileName.
	self emitCCodeOn: stream doInlining: inlineFlag.
	stream close.!
var: varName declareC: declarationString
	"Record the given C declaration for a global variable."

	variableDeclarations at: varName put: declarationString.! !
!CCodeGenerator methodsFor: 'error notification'!
checkClassForNameConflicts: aClass
	"Verify that the given class does not have constant, variable, or method names that conflict with those of previously added classes. Raise an error if a conflict is found, otherwise just return."

	"check for constant name collisions"
	aClass classPool associationsDo: [ :assoc |
		(constants includesKey: assoc key) ifTrue: [
			self error: 'Constant was defined in a previously added class: ', assoc key.
		].
	].

	"check for instance variable name collisions"
	aClass instVarNames do: [ :varName |
		(variables includes: varName) ifTrue: [
			self error: 'Instance variable was defined in a previously added class: ', varName.
		].
	].

	"check for method name collisions"
	aClass selectors do: [ :sel |
		(methods includesKey: sel) ifTrue: [
			self error: 'Method was defined in a previously added class: ', sel.
		].
	].!
printUnboundCallWarnings
	"Print a warning message for every unbound method call in the code base."

	| knownSelectors undefinedCalls |
	undefinedCalls _ Dictionary new.
	knownSelectors _ translationDict keys asSet.
	knownSelectors add: #error:.
	methods do: [ :m | knownSelectors add: m selector ].
	methods do: [ :m |
		m allCalls do: [ :sel |
			(knownSelectors includes: sel) ifFalse: [
				(undefinedCalls includesKey: sel)
					ifTrue: [ (undefinedCalls at: sel) add: m selector ]
					ifFalse: [ undefinedCalls at: sel put: (OrderedCollection with: m selector) ].
			].
		].
	].

	Transcript cr.
	undefinedCalls keys asSortedCollection do: [ :undefined |
		Transcript show: undefined, ' -- undefined method sent by:'; cr.
		(undefinedCalls at: undefined) do: [ :caller |
			Transcript tab; show: caller; cr.
		].
	].!
printUnboundVariableReferenceWarnings
	"Print a warning message for every unbound variable reference in the code base."

	| undefinedRefs globalVars knownVars |
	undefinedRefs _ Dictionary new.
	globalVars _ Set new: 100.
	globalVars addAll: variables.
	methods do: [ :m |
		knownVars _ globalVars copy.
		m args do: [ :var | knownVars add: var ].
		m locals do: [ :var | knownVars add: var ].
		m freeVariableReferences do: [ :varName |
			(knownVars includes: varName) ifFalse: [
				(undefinedRefs includesKey: varName)
					ifTrue: [ (undefinedRefs at: varName) add: m selector ]
					ifFalse: [ undefinedRefs at: varName put: (OrderedCollection with: m selector) ].
			].
		].
	].

	Transcript cr.
	undefinedRefs keys asSortedCollection do: [ :var |
		Transcript show: var, ' -- undefined variable used in:'; cr.
		(undefinedRefs at: var) do: [ :sel |
			Transcript tab; show: sel; cr.
		].
	].! !
!CCodeGenerator methodsFor: 'inlining'!
collectInlineList
	"Make a list of methods that should be inlined."
	"Details: The method must not include any inline C, since the translator cannot currently map variable names in inlined C code. Methods to be inlined must be small or called from only one place."

	| callsOf hasCCode nodeCount senderCount methodsWithCCode |
	methodsWithCCode _ Set new: methods size.

	"build dictionary to record the number of calls to each method"
	callsOf _ Dictionary new: methods size * 2.
	methods keys do: [ :sel | callsOf at: sel put: 0 ].

	"For each method, scan its parse tree once to:
		1. determine if the method contains C code or declarations
		2. determine how many nodes it has
		3. increment the sender counts of the methods it calls
		4. determine if it includes any C declarations or code"
	inlineList _ Set new: methods size * 2.
	methods do: [ :m |
		(translationDict includesKey: m selector) ifTrue: [
			hasCCode _ true.
		] ifFalse: [
			hasCCode _ m declarations size > 0.
			nodeCount _ 0.
			m parseTree nodesDo: [ :node |
				node isSend ifTrue: [
					sel _ node selector.
					sel = #cCode: ifTrue: [ hasCCode _ true ].
					senderCount _ callsOf at: sel ifAbsent: [ nil ].
					nil = senderCount ifFalse: [
						callsOf at: sel put: senderCount + 1.
					].
				].
				nodeCount _ nodeCount + 1.
			].
		].
		hasCCode ifTrue: [
			methodsWithCCode add: m selector.
		] ifFalse: [
			(nodeCount < 40) ifTrue: [ inlineList add: m selector ].
		].
	].

	callsOf associationsDo: [ :assoc |
		((assoc value = 1) and: [(methodsWithCCode includes: assoc key) not]) ifTrue: [
			inlineList add: assoc key.
		].
	].!
doInline: selList
	"Inline calls to the given methods (if possible) even if it is over the size threshold."

	| m |
	selList do: [ :sel |
		(translationDict includesKey: sel) ifTrue: [ ^self ].
		m _ self methodNamed: sel.
		((m ~= nil) and: [m hasNoCCode]) ifTrue: [
			inlineList add: sel.
		].
	].!
doInlining
	"Inline the bodies of all methods that are suitable for inlining."
	"Interpreter translate: 'InterpTest.c' doInlining: true"

	| progress pass |
	self collectInlineList.
	self doInline: #(
		allocateChunk:
		assertClassOf:is:
		internalFetchContextRegisters:
		fetchContextRegisters:
		storeContextRegisters:
		returnValue:to:
		recycleContextIfPossible:methodContextClass: 
		lookupInMethodCacheSel:class:
		sourcePixAtX:y:pixPerWord:
		sendSelectorToClass:
		internalSendSelector:argumentCount:
		stObject:at:
		stObject:at:put:
		sufficientSpaceToInstantiate:indexableSize:
		sufficientSpaceToAllocate:
		booleanCheat:
		findNewMethodInClass:
		objectAfter:
		objectAfterWhileForwarding:
		remapFieldsAndClassOf:
		lastPointerWhileForwarding:
		lastPointerOf:
		initForwardBlock:mapping:to:
		extraHeaderBytes:
		allocate:headerSize:h1:h2:h3:fill:
		allocateOrRecycleContext:
		recycleContextIfPossible:
		fetchClassOf:
		subscript:with:
		lengthOf:
		subscript:with:storing:
		merge:with:
		rgbMap:from:to:
		extendedStoreBytecode
		returnToActiveContext:
		transfer:fromIndex:ofObject:toIndex:ofObject:
	).
	self doNotInline: #(
		clone:
		addToMethodCacheSel:class:method:primIndex:
		externalSendSelector:argumentCount:
		rgbAdd:with:  "complex BitBlt functions"
		rgbSub:with:
		rgbDiff:with:
		tallyIntoMap:
		pixPaint:with:
		pixMask:with:
		alphaBlend:with:
		lowestFreeAfter:
		sufficientSpaceAfterGC:
		instantiateClass:indexableSize:
		loadScannerFrom:start:stop:string:rightX:stopArray:displayFlag:
		beRootIfOld:
		checkForInterrupts
		activateNewMethod
		commonSelectorPrimitive:
		fullGC
		incrementalGC
		markPhase
		sweepPhase
		incCompBody
		fwdTableInit
		mapPointersInObjectsFrom:to:
		remap:
		incCompMove
		synchronousSignal:
		resume:
		initializeObjectMemory:
		copyLoop
		copyLoopNoSource
		copyLoopPixMap
		accessibleObjectAfter:
		executeNewMethod:
		fetchInteger:ofObject:
		fetchWordLengthOf:
		possibleRootStoreInto:value:
	).

	self flag: #jhm.
	self doNotInline: Interpreter primitiveTable.

	progress _ true.
	pass _ 0.
	[progress] whileTrue: [
		"repeatedly attempt to inline methods until no further progress is made"
		progress _ false.
		'Inlining pass #' , (pass _ pass+1) printString , '...'
			displayProgressAt: Sensor cursorPoint
			from: 0 to: methods size
			during: [:bar |
				methods doWithIndex:
					[ :m :i | bar value: i.
					(m tryToInlineMethodsIn: self)
						ifTrue: [ progress _ true ]]].
	].
	self inlineDispatchesInMethodNamed: #interpret
		localizingVars: #(currentBytecode localIP localSP).
	self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP)
		except: #interpret.
!
doNotInline: selList
	"Remove the methods with the given selectors from the list of methods to be inlined."

	selList do: [ :sel |
		inlineList remove: sel ifAbsent: [].
	].!
inlineDispatchesInMethodNamed: selector localizingVars: varsList
	"Inline dispatches (case statements) in the method with the given name."

	| m |
	m _ self methodNamed: selector.
	m = nil ifFalse: [
		m inlineCaseStatementBranchesIn: self localizingVars: varsList.
		m parseTree nodesDo: [ :n |
			n isCaseStmt ifTrue: [
				n customizeShortCasesForDispatchVar: #currentBytecode.
			].
		].
	].
	variables _ variables asOrderedCollection.
	varsList do: [ :v | variables remove: v asString ifAbsent: [] ].
!
mayInline: sel
	"Answer true if the method with the given selector may be inlined."

	^ inlineList includes: sel!
methodStatsString
	"Return a string describing the size, # of locals, and # of senders of each method. Note methods that have inline C code or C declarations."

	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount s calls registers selr |
	methodsWithCCode _ Set new: methods size.
	sizesOf _ Dictionary new: methods size * 2.  "selector -> nodeCount"
	callsOf _ Dictionary new: methods size * 2.  "selector -> senderCount"

	"For each method, scan its parse tree once to:
		1. determine if the method contains C code or declarations
		2. determine how many nodes it has
		3. increment the sender counts of the methods it calls
		4. determine if it includes any C declarations or code"

	methods do: [ :m |
		(translationDict includesKey: m selector) ifTrue: [
			hasCCode _ true.
		] ifFalse: [
			hasCCode _ m declarations size > 0.
			nodeCount _ 0.
			m parseTree nodesDo: [ :node |
				node isSend ifTrue: [
					selr _ node selector.
					selr = #cCode: ifTrue: [ hasCCode _ true ].
					senderCount _ callsOf at: selr ifAbsent: [ 0 ].
					callsOf at: selr put: senderCount + 1.
				].
				nodeCount _ nodeCount + 1.
			].
		].
		hasCCode ifTrue: [ methodsWithCCode add: m selector ].
		sizesOf at: m selector put: nodeCount.
	].

	s _ WriteStream on: (String new: 5000).
	methods keys asSortedCollection do: [ :sel |
		m _ methods at: sel.
		registers _ m locals size + m args size.
		calls _ callsOf at: sel ifAbsent: [0].
		registers > 11 ifTrue: [
			s nextPutAll: sel; tab.
			s nextPutAll: (sizesOf at: sel) printString; tab.
			s nextPutAll: calls printString; tab.
			s nextPutAll: registers printString; tab.
			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].
		s cr.
		].
	].
	^ s contents!
removeMethodsReferingToGlobals: varList except: methodName
	"Remove any methods (presumably inlined) that still contain references to the given obsolete global variables."

	| varListAsStrings removeIt mVars |
	varListAsStrings _ varList collect: [ :sym | sym asString ].
	methods keys copy do: [ :sel |
		removeIt _ false.
		mVars _ (self methodNamed: sel) freeVariableReferences asSet.
		varListAsStrings do: [ :v |
			(mVars includes: v) ifTrue: [ removeIt _ true ].
		].
		(removeIt and: [sel ~= methodName]) ifTrue: [
			methods removeKey: sel ifAbsent: [].
		].
	].! !
!CCodeGenerator methodsFor: 'utilities'!
addMethod: aTMethod
	"Add the given method to the code base."

	(methods includesKey:  aTMethod selector) ifTrue: [
		self error: 'Method name conflict: ', aTMethod selector.
	].
	methods at: aTMethod selector put: aTMethod.!
builtin: sel
	"Answer true if the given selector is one of the builtin selectors."

	((sel = #longAt:) or: [(sel = #longAt:put:) or: [sel = #error:]]) ifTrue: [ ^true ].
	((sel = #byteAt:) or: [sel = #byteAt:put:]) ifTrue: [ ^true ].
	^translationDict includesKey: sel!
cCodeForMethod: selector
	"Answer a string containing the C code for the given method."
	"Example:
		((CCodeGenerator new initialize addClass: TestCClass1; prepareMethods)
			cCodeForMethod: #ifTests)"

	| m s |
	m _ self methodNamed: selector.
	m = nil ifTrue: [ self error: 'method not found in code base: ', selector ].

	s _ (ReadWriteStream on: '').
	m emitCCodeOn: s generator: self.
	^ s contents!
emitBuiltinConstructFor: msgNode on: aStream level: level
	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."

	| action |
	action _ translationDict at: msgNode selector ifAbsent: [ ^false ].
	self perform: action with: msgNode with: aStream with: level.
	^true!
methodNamed: selector
	"Answer the method in the code base with the given selector."

	^ methods at: selector ifAbsent: [ nil ]!
methodsReferringToGlobal: v
	"Return a collection of methods that refer to the given global variable."

	| out |
	out _ OrderedCollection new.
	methods associationsDo: [ :assoc |
		(assoc value freeVariableReferences includes: v) ifTrue: [
			out add: assoc key.
		].
	].
	^ out!
methodsThatCanInvoke: aSelectorList
	"Return a set of methods that can invoke one of the given selectors, either directly or via a sequence of intermediate methods."

	| out todo sel mSelector |
	out _ Set new.
	todo _ aSelectorList copy asOrderedCollection.
	[todo isEmpty] whileFalse: [
		sel _ todo removeFirst.
		out add: sel.
		methods do: [ :m |
			(m allCalls includes: sel) ifTrue: [
				mSelector _ m selector.
				((out includes: mSelector) or:
				 [todo includes: mSelector]) ifFalse: [
					todo add: mSelector.
				].
			].
		].
	].
	^ out
	!
prepareMethods
	"Prepare methods for browsing."

	| globals |
	globals _ Set new: 200.
	globals addAll: variables.
	methods do: [ :m |
		(m locals, m args) do: [ :var |
			(globals includes: var) ifTrue: [
				self error: 'Local variable name may mask global when inlining: ', var.
			].
			(methods includesKey: var) ifTrue: [
				self error: 'Local variable name may mask method when inlining: ', var.
			].	
		].
		m bindClassVariablesIn: constants.
		m prepareMethodIn: self.
	].!
reportRecursiveMethods
	"Report in transcript all methods that can call themselves directly or indirectly or via a chain of N intermediate methods."

	| visited calls newCalls sel called |
	methods do: [: m |
		visited _ translationDict keys asSet.
		calls _ m allCalls asOrderedCollection.
		5 timesRepeat: [
			newCalls _ Set new: 50.
			[calls isEmpty] whileFalse: [
				sel _ calls removeFirst.
				sel = m selector ifTrue: [
					Transcript show: m selector, ' is recursive'; cr.
				] ifFalse: [
					(visited includes: sel) ifFalse: [
						called _ self methodNamed: sel.
						called = nil ifFalse: [ newCalls addAll: called allCalls ].
					].
					visited add: sel.
				].
			].
			calls _ newCalls asOrderedCollection.
		].
	].!
unreachableMethods
	"Return a collection of methods that are never invoked."

	| sent out |
	sent _ Set new.
	methods do: [ :m |
		sent addAll: m allCalls.
	].

	out _ OrderedCollection new.
	methods keys do: [ :sel |
		(sent includes: sel) ifFalse: [ out add: sel ].
	].
	^ out! !
!CCodeGenerator methodsFor: 'C code generator'!
cFunctionNameFor: aSelector
	"Create a C function name from the given selector by omitting colons."

	^aSelector copyWithout: $:!
cLiteralFor: anObject
	"Return a string representing the C literal value for the given object."
	| s |
	(anObject isKindOf: Integer) ifTrue: [^ anObject printString ].
	(anObject isKindOf: String) ifTrue: [^ '"', anObject, '"' ].
	(anObject isKindOf: Float) ifTrue: [^ anObject printString ].
	anObject == nil ifTrue: [^ 'null' ].
	Transcript show:
		'Warning: A Smalltalk literal could not be translated into a C constant'; cr.
	^'"XXX UNTRANSLATABLE CONSTANT XXX"'!
emitCCodeOn: aStream doInlining: inlineFlag
	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."

	| verbose |
	"method preparation"
	verbose _ false.
	self prepareMethods.
	verbose ifTrue: [
		self printUnboundCallWarnings.
		self printUnboundVariableReferenceWarnings.
		Transcript cr.
	].
	inlineFlag ifTrue: [ self doInlining ].

	"code generation"
	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].
	self emitCHeaderOn: aStream.
	self emitCVariablesOn: aStream.
	self emitCFunctionPrototypesOn: aStream.
'Writing Translated Code...'
displayProgressAt: Sensor cursorPoint
from: 0 to: methods size
during: [:bar |
	methods doWithIndex: [ :m :i | bar value: i.
		m emitCCodeOn: aStream generator: self.
]].!
emitCExpression: aParseNode on: aStream
	"Emit C code for the expression described by the given parse node."

	aParseNode isLeaf ifTrue: [
		"omit parens"
		aParseNode emitCCodeOn: aStream level: 0 generator: self.
	] ifFalse: [
		aStream nextPut: $(.
		aParseNode emitCCodeOn: aStream level: 0 generator: self.
		aStream nextPut: $).
	].!
emitCFunctionPrototypesOn: aStream
	"Store prototype declarations for all non-inlined methods on the given stream."

	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.
	methods do: [ :m |
		m emitCFunctionPrototype: aStream generator: self.
		aStream nextPutAll: ';'; cr.
	].!
emitCHeaderForPrimitivesOn: aStream
	"Write a C file header for compiled primitives onto the given stream."

	aStream nextPutAll: '/* Automatically generated from Squeak on '.
	aStream nextPutAll: Time dateAndTimeNow printString.
	aStream nextPutAll: ' */'; cr; cr.

	aStream nextPutAll: '#include "sq.h"'; cr; cr.

	aStream nextPutAll: '
/* Memory Access Macros */
#define byteAt(i) (*((unsigned char *) (i)))
#define byteAtput(i, val) (*((unsigned char *) (i)) = val)
#define longAt(i) (*((int *) (i)))
#define longAtput(i, val) (*((int *) (i)) = val)

/*** Imported Variables ***/
extern int stackPointer;
extern int successFlag;
'.
	aStream cr.!
emitCHeaderOn: aStream
	"Write a C file header onto the given stream."

	aStream nextPutAll: '/* Automatically generated from Squeak on '.
	aStream nextPutAll: Time dateAndTimeNow printString.
	aStream nextPutAll: ' */'; cr; cr.

	aStream nextPutAll: '#include "sq.h"'; cr; cr.

	aStream nextPutAll: '
/* memory access macros */
#define byteAt(i) (*((unsigned char *) (i)))
#define byteAtput(i, val) (*((unsigned char *) (i)) = val)
#define longAt(i) (*((int *) (i)))
#define longAtput(i, val) (*((int *) (i)) = val)

int printCallStack(void);
void error(char *s);
void error(char *s) {
	/* Print an error message and exit. */
	static int printingStack = false;

	printf("\n%s\n\n", s);
	if (!!printingStack) {
		/* flag prevents recursive error when trying to print a broken stack */
		printingStack = true;
		printCallStack();
	}
	exit(-1);
}
'.
	aStream cr.!
emitCTestBlock: aBlockNode on: aStream
	"Emit C code for the given block node to be used as a loop test."

	aBlockNode statements size > 1 ifTrue: [
		aBlockNode emitCCodeOn: aStream level: 0 generator: self.
	] ifFalse: [
		aBlockNode statements first emitCCodeOn: aStream level: 0 generator: self.
	].!
emitCVariablesOn: aStream
	"Store the global variable declarations on the given stream."

	aStream nextPutAll: '/*** Variables ***/'; cr.
	variables asSortedCollection do: [ :var |
		(variableDeclarations includesKey: var) ifTrue: [
			aStream nextPutAll: (variableDeclarations at: var), ';'; cr.
		] ifFalse: [
			"default variable declaration"
			aStream nextPutAll: 'int ', var, ';'; cr.
		].
	].
	aStream cr.! !
!CCodeGenerator methodsFor: 'C translation'!
generateAnd: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' && '.
	self emitCExpression: msgNode args first on: aStream.!
generateAt: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: '['.
	msgNode args first emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: ']'.!
generateAtPut: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: '['.
	msgNode args first emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: '] = '.
	self emitCExpression: msgNode args last on: aStream.!
generateBitAnd: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' & '.
	self emitCExpression: msgNode args first on: aStream.!
generateBitInvert32: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '~'.
	self emitCExpression: msgNode receiver on: aStream.!
generateBitOr: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' | '.
	self emitCExpression: msgNode args first on: aStream.!
generateBitShift: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	| arg rcvr |
	arg _ msgNode args first.
	rcvr _ msgNode receiver.
	arg isConstant ifTrue: [
		"bit shift amount is a constant"
		aStream nextPutAll: '((unsigned) '.
		self emitCExpression: rcvr on: aStream.
		arg value < 0 ifTrue: [
			aStream nextPutAll: ' >> ', arg value negated printString.
		] ifFalse: [
			aStream nextPutAll: ' << ', arg value printString.
		].
		aStream nextPutAll: ')'.
	] ifFalse: [
		"bit shift amount is an expression"
		aStream nextPutAll: '(('.
		self emitCExpression: arg on: aStream.
		aStream nextPutAll: ' < 0) ? ((unsigned) '.
		self emitCExpression: rcvr on: aStream.
		aStream nextPutAll: ' >> -'.
		self emitCExpression: arg on: aStream.
		aStream nextPutAll: ') : ((unsigned) '.
		self emitCExpression: rcvr on: aStream.
		aStream nextPutAll: ' << '.
		self emitCExpression: arg on: aStream.
		aStream nextPutAll: '))'.
	].!
generateBitXor: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' ^ '.
	self emitCExpression: msgNode args first on: aStream.!
generateDivide: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' / '.
	self emitCExpression: msgNode args first on: aStream.!
generateEqual: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' == '.
	self emitCExpression: msgNode args first on: aStream.!
generateGreaterThan: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' > '.
	self emitCExpression: msgNode args first on: aStream.!
generateGreaterThanOrEqual: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' >= '.
	self emitCExpression: msgNode args first on: aStream.!
generateIfFalse: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."
	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably
	 to help with inlining later. Taking the last agument should do the correct
	 thing even if your compiler is different."

	aStream nextPutAll: 'if (!!('.
	msgNode receiver emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: ')) {'; cr.
	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateIfFalseIfTrue: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."
	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,
       presumably to help with inlining later. That is, the first argument
       is the block to be evaluated if the condition is true."

	aStream nextPutAll: 'if ('.
	msgNode receiver emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: ') {'; cr.
	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '} else {'; cr.
	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateIfTrue: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: 'if ('.
	msgNode receiver emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: ') {'; cr.
	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateIfTrueIfFalse: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: 'if ('.
	msgNode receiver emitCCodeOn: aStream level: level generator: self.
	aStream nextPutAll: ') {'; cr.
	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '} else {'; cr.
	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateInlineCCode: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: msgNode args first value.!
generateIntegerObjectOf: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '(('.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ' << 1) | 1)'.!
generateIntegerValueOf: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '('.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ' >> 1)'.!
generateIsIntegerObject: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '(('.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ' & 1) == 1)'.!
generateIsNil: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' == '.
	aStream nextPutAll: (self cLiteralFor: nil).!
generateLessThan: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' < '.
	self emitCExpression: msgNode args first on: aStream.!
generateLessThanOrEqual: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' <= '.
	self emitCExpression: msgNode args first on: aStream.!
generateMax: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '(('.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' < '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ') ? '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ' : '.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ')'.!
generateMin: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '(('.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' < '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ') ? '.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' : '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: ')'.!
generateMinus: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' - '.
	self emitCExpression: msgNode args first on: aStream.!
generateModulo: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' % '.
	self emitCExpression: msgNode args first on: aStream.!
generateNot: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '!!'.
	self emitCExpression: msgNode receiver on: aStream.!
generateNotEqual: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' !!= '.
	self emitCExpression: msgNode args first on: aStream.!
generateNotNil: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' !!= '.
	aStream nextPutAll: (self cLiteralFor: nil).!
generateOr: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' || '.
	self emitCExpression: msgNode args first on: aStream.!
generatePlus: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' + '.
	self emitCExpression: msgNode args first on: aStream.!
generatePreDecrement: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	| varNode |
	varNode _ msgNode receiver.
	varNode isVariable
		ifFalse: [ self error: 'preDecrement can only be applied to variables' ].
	aStream nextPutAll: '--'.
	aStream nextPutAll: varNode name.
!
generatePreIncrement: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	| varNode |
	varNode _ msgNode receiver.
	varNode isVariable
		ifFalse: [ self error: 'preIncrement can only be applied to variables' ].
	aStream nextPutAll: '++'.
	aStream nextPutAll: varNode name.
!
generateSequentialAnd: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' && ('.
	self emitCTestBlock: msgNode args first on: aStream.
	aStream nextPutAll: ')'.!
generateSequentialOr: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."
	"Note: PP 2.3 compiler produces two arguments for or:, presumably
	 to help with inlining later. Taking the last agument should do the correct
	 thing even if your compiler is different."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' || ('.
	self emitCTestBlock: msgNode args last on: aStream.
	aStream nextPutAll: ')'.!
generateShiftLeft: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' << '.
	self emitCExpression: msgNode args first on: aStream.!
generateShiftRight: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: '((unsigned) '.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ')'.
	aStream nextPutAll: ' >> '.
	self emitCExpression: msgNode args first on: aStream.!
generateTimes: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: ' * '.
	self emitCExpression: msgNode args first on: aStream.!
generateToByDo: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	| iterationVar |
	(msgNode args last args size = 1) ifFalse: [
		self error: 'wrong number of block arguments'.
	].
	iterationVar _ msgNode args last args first.
	aStream nextPutAll: 'for (', iterationVar, ' = '.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: '; ', iterationVar, ' <= '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: '; ', iterationVar, ' += '.
	self emitCExpression: (msgNode args at: 2) on: aStream.
	aStream nextPutAll: ') {'; cr.
	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateToDo: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	| iterationVar |
	(msgNode args last args size = 1) ifFalse: [
		self error: 'wrong number of block arguments'.
	].
	iterationVar _ msgNode args last args first.
	aStream nextPutAll: 'for (', iterationVar, ' = '.
	self emitCExpression: msgNode receiver on: aStream.
	aStream nextPutAll: '; ', iterationVar, ' <= '.
	self emitCExpression: msgNode args first on: aStream.
	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.
	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateWhileFalse: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: 'while (!!('.
	self emitCTestBlock: msgNode receiver on: aStream.
	aStream nextPutAll: ')) {'; cr.
	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
generateWhileTrue: msgNode on: aStream indent: level
	"Generate the C code for this message onto the given stream."

	aStream nextPutAll: 'while ('.
	self emitCTestBlock: msgNode receiver on: aStream.
	aStream nextPutAll: ') {'; cr.
	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
initializeCTranslationDictionary 
	"Initialize the dictionary mapping message names to actions for C code generation."

	| pairs |
	translationDict _ Dictionary new: 200.
	pairs _ #(
	#&				#generateAnd:on:indent:
	#|				#generateOr:on:indent:
	#and:			#generateSequentialAnd:on:indent:
	#or:			#generateSequentialOr:on:indent:
	#not			#generateNot:on:indent:

	#+				#generatePlus:on:indent:
	#-				#generateMinus:on:indent:
	#*				#generateTimes:on:indent:
	#//				#generateDivide:on:indent:
	#\\				#generateModulo:on:indent:
	#<<				#generateShiftLeft:on:indent:
	#>>				#generateShiftRight:on:indent:
	#min:			#generateMin:on:indent:
	#max:			#generateMax:on:indent:

	#bitAnd:		#generateBitAnd:on:indent:
	#bitOr:			#generateBitOr:on:indent:
	#bitXor:			#generateBitXor:on:indent:
	#bitShift:		#generateBitShift:on:indent:
	#bitInvert32	#generateBitInvert32:on:indent:

	#<				#generateLessThan:on:indent:
	#<=				#generateLessThanOrEqual:on:indent:
	#=				#generateEqual:on:indent:
	#>				#generateGreaterThan:on:indent:
	#>=				#generateGreaterThanOrEqual:on:indent:
	#~=			#generateNotEqual:on:indent:
	#==				#generateEqual:on:indent:
	#isNil			#generateIsNil:on:indent:
	#notNil			#generateNotNil:on:indent:

	#whileTrue:	#generateWhileTrue:on:indent:
	#whileFalse:	#generateWhileFalse:on:indent:
	#to:do:			#generateToDo:on:indent:
	#to:by:do:		#generateToByDo:on:indent:

	#ifTrue:		#generateIfTrue:on:indent:
	#ifFalse:		#generateIfFalse:on:indent:
	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:
	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:

	#at:				#generateAt:on:indent:
	#at:put:			#generateAtPut:on:indent:

	#integerValueOf:	#generateIntegerValueOf:on:indent:
	#integerObjectOf:	#generateIntegerObjectOf:on:indent:
	#isIntegerObject:	#generateIsIntegerObject:on:indent:
	#cCode:				#generateInlineCCode:on:indent:
	#preIncrement		#generatePreIncrement:on:indent:
	#preDecrement		#generatePreDecrement:on:indent:
	).

	1 to: pairs size by: 2 do: [ :i |
		translationDict at: (pairs at: i) put: (pairs at: i + 1).
	].! !
!CCodeGenerator class methodsFor: 'removing from system'!
removeCompilerMethods
	"Before removing the C code generator classes from the system, use this method to remove the compiler node methods that support it. This avoids leaving dangling references to C code generator classes in the compiler node classes."

	ParseNode withAllSubclasses do: [ :nodeClass |
		nodeClass removeCategory: 'C translation'.
	].
	AbstractSound class removeCategory: 'primitive generation'.! !
!ChangeList class methodsFor: 'public access'!
browseRecentLog    "ChangeList browseRecentLog"
	"Prompt with a menu of how far back to go"
	| end changesFile banners positions pos chunk i |
	changesFile _ (SourceFiles at: 2) readOnlyCopy.
	banners _ OrderedCollection new.
	positions _ OrderedCollection new.
	end _ changesFile size.
	pos _ Smalltalk lastQuitLogPosition.
	[pos = 0 or: [banners size > 20]] whileFalse:
		[changesFile position: pos.
		chunk _ changesFile nextChunk.
		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
		i > 0 ifTrue: [positions addLast: pos.
					banners addLast: (chunk copyFrom: 5 to: i-2).
					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]
			ifFalse: [pos _ 0]].
	changesFile close.
	pos _ (SelectionMenu labelList: banners reversed selections: positions reversed)
				startUpWithCaption: 'Browse as far back as...'.
	pos == nil ifTrue: [^ self].
	self browseRecent: end-pos! !

ChangeSet comment:
'My instances keep track of the changes made to a system, so the user can make an incremental fileOut. The order in which changes are made is not remembered.
11/25/96 sw: added preamble and postscript -- two strings that can serve as prefix and suffix to the fileout of the changeset.'!
!ChangeSet methodsFor: 'initialize-release'!
clear 
	"Reset the receiver to be empty.  11/26/96 sw"

	classChanges _ Dictionary new.
	methodChanges _ Dictionary new.
	classRemoves _ Set new.
	preamble _ nil.
	postscript _ nil!
editPostscript
	"edit the receiver's postscript, in a separate window.  11/27/96 sw"

	self assurePostscriptExists.
	StringHolderView open: postscript label: 'Postscript for ChangeSet named ', name! !
!ChangeSet methodsFor: 'fileIn/Out'!
assurePostscriptExists
	"Make sure there is a StringHolder holding the postscript.  11/27/96 sw"

	postscript == nil ifTrue: [postscript _ StringHolder new contents: '']!
assurePreambleExists
	"Make sure there is a StringHolder holding the preamble.  11/27/96 sw
	 12/4/96 sw: if it's found to have reverted to empty contents, put up the template"

	(preamble == nil or: [preamble contents size == 0])
		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]!
fileOut
	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time.  1/18/96 sw
 2/4/96 sw: show write cursor
	5/30/96 sw: put a dot before the date/time stamp"

	| file |
	Cursor write showWhile:
		[file _ FileStream newFileNamed: ((self name, '.', Utilities dateTimeSuffix, '.cs') truncateTo: 27).
		file header; timeStamp.
		self fileOutPreambleOn: file.
		self fileOutOn: file.
		self fileOutPostscriptOn: file.
		file trailer; close]!
fileOutPostscriptOn: stream 
	"If the receiver has a postscript, put it out onto the stream.  11/25/96 sw"

	| aString |
	((aString _ self postscriptString) size > 0)
		ifTrue:
			[stream nextChunkPut: aString "surroundedBySingleQuotes".
			stream cr; cr]!
fileOutPreambleOn: stream 
	"If the receiver has a preamble, put it out onto the stream.  11/25/96 sw"

	| aString |
	((aString _ self preambleString) size > 0)
		ifTrue:
			[stream nextChunkPut: aString "surroundedBySingleQuotes".
			stream cr; cr]!
postscriptString
	"Answer the string representing the postscript.  11/27/96 sw"

	self assurePostscriptExists.
	^ postscript contents!
postscriptString: aString
	"Establish aString as the new contents of the postscript.  11/27/96 sw"

	postscript _ StringHolder new contents: aString!
preambleString
	"Answer the string representing the preamble.  11/27/96 sw"

	^ preamble == nil
		ifTrue:
			[preamble]
		ifFalse:
			[preamble contents]!
preambleString: aString
	"Establish aString as the new contents of the preamble.  11/27/96 sw"

	preamble _ StringHolder new contents: aString!
preambleTemplate
	"Answer a string that will form the default contents for a change set's preamble.  Just a first stab at what the content should be.12/3/96 sw"

	| aStream |
	aStream _ ReadWriteStream on: ''.
	aStream nextPutAll: '"Change Set:'.
	aStream tab;tab; nextPutAll: self name.
	aStream cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.
	aStream cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: 'Your Name'.
	aStream cr; cr; nextPutAll: '<your descriptive text goes here>"'.
	^ aStream contents
"Smalltalk changes preambleTemplate"! !
!ChangeSet methodsFor: 'private'!
fileOutClassChanges: class on: stream 
	"Write out class changes, i.e. new class, definition, comment, renaming.
	 10/28/96 sw: put out a rename indicator that won't halt if class of old name not there."

	(self atClass: class includes: #add) ifTrue:
		[stream cr.
		class fileOutOn: stream.
		stream cr].

	(self atClass: class includes: #rename) ifTrue:
		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].

	(self atClass: class includes: #change) ifTrue:
		[stream emphasis: 5; nextChunkPut: class definition; cr; emphasis: 1].

	(self atClass: class includes: #comment) ifTrue:
		[class organization putCommentOnFile: stream
			numbered: nil moveSource: false.
		stream cr].

	(self atClass: class includes: #reorganize) ifTrue:
		[class fileOutOrganizationOn: stream.
		stream cr]!
fileOutClassModifications: class on: stream 
	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes.  5/15/96 sw
	 10/28/96 sw: put out a rename indicator that won't halt if class of old name not there."

	(self atClass: class includes: #rename) ifTrue:
		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].

	(self atClass: class includes: #comment) ifTrue:
		[class organization putCommentOnFile: stream
			numbered: nil moveSource: false.
		stream cr].

	(self atClass: class includes: #reorganize) ifTrue:
		[class fileOutOrganizationOn: stream.
		stream cr]! !
!ChangeSet methodsFor: 'accessing'!
editPreamble
	"edit the receiver's preamble, in a separate window.  11/27/96 sw"

	self assurePreambleExists.
	StringHolderView open: preamble label: 'Preamble for ChangeSet named ', name! !
!ChangeSorter methodsFor: 'creation'!
initialize
	"Initialize the receiver to look at the current change set.  11/26/96 sw"

	self initializeFor: Smalltalk changes!
initializeFor: aChangeSet
	"Initialize the receiver and have it start out life looking at aChangeSet.  11/26/96 sw"

	myChangeSet _ aChangeSet.	
	classList _ CngsClassList new.
	classList parent: self.
	messageList _ CngsMsgList new.
	messageList parent: self.
	MsgListMenu == nil ifTrue: [self class initialize].
	classList list: #().
	messageList list: #().
!
open  "ChangeSorter new open"
	| topView |
	self initialize.
	topView _ StandardSystemView new.
	topView model: self.
	topView label: self label.
	topView minimumSize: 360@360.
	self openView: topView offsetBy: 0@0.
	topView controller open		"Let the show begin"!
openView: topView
	"Create change sorter on one changeSet only.  Two of these in a DualChangeSorter."
	| classView messageView codeView |

	buttonView _ SwitchView new.
	buttonView model: self controller: TriggerController new.
	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.
	buttonView selector: #whatPolarity.
	buttonView controller selector: #cngSetActivity.
	buttonView window: (0 @ 0 extent: 360 @ 20).
	buttonView label: myChangeSet name asParagraph.

	classView _ GeneralListView new.
	classView controllerClass: GeneralListController.
	classView model: classList.
	classView window: (0 @ 0 extent: 180 @ 160).
	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
	classView controller yellowButtonMenu: ClassMenu 
		yellowButtonMessages: ClassSelectors.
	classList controller: classView controller.


	messageView _ GeneralListView new.
	messageView controllerClass: GeneralListController.
	messageView model: messageList.
	messageView window: (0 @ 0 extent: 180 @ 160).
	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
	messageView controller yellowButtonMenu: MsgListMenu 
		yellowButtonMessages: MsgListSelectors.
	messageList controller: messageView controller.

	codeView _ BrowserCodeView new.
	codeView model: self.
	codeView window: (0 @ 0 extent: 360 @ 180).
	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.

	topView addSubView: buttonView.
	topView addSubView: classView below: buttonView.
	topView addSubView: messageView toRightOf: classView.
	topView addSubView: codeView below: classView.
"
	classView 
		align: classView viewport topLeft 	
		with: buttonView viewport bottomLeft.
	messageView 
		align: messageView viewport topLeft 	
		with: classView viewport topRight.
	codeView 
		align: codeView viewport topLeft 	
		with: classView viewport bottomLeft.
"!
openView: topView offsetBy: offset
	"Create change sorter on one changeSet with 0@0.
	Two of these in a DualChangeSorter, right one is offset by 360@0."
	| classView messageView codeView |
	buttonView _ SwitchView new.
	buttonView model: self controller: TriggerController new.
	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.
	buttonView selector: #whatPolarity.
	buttonView controller selector: #cngSetActivity.
	buttonView window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).
	buttonView label: myChangeSet name asParagraph.

	classView _ GeneralListView new.
	classView controllerClass: GeneralListController.
	classView model: classList.
	classView window: (0 @ 0 extent: 180 @ 160).
	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
	classView controller yellowButtonMenu: ClassMenu 
		yellowButtonMessages: ClassSelectors.
	classList controller: classView controller.

	messageView _ GeneralListView new.
	messageView controllerClass: GeneralListController.
	messageView model: messageList.
	messageView window: (0 @ 0 extent: 180 @ 160).
	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
	messageView controller yellowButtonMenu: MsgListMenu 
		yellowButtonMessages: MsgListSelectors.
	messageList controller: messageView controller.

	codeView _ BrowserCodeView new.
	codeView model: self.
	codeView window: (0 @ 0 extent: 360 @ 180).
	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.

	topView addSubView: buttonView.
	topView addSubView: classView below: buttonView.
	topView addSubView: messageView toRightOf: classView.
	topView addSubView: codeView below: classView.
! !
!ChangeSorter methodsFor: 'change set menu'!
clearChangeSet
	"Clear out the current change set, after getting a confirmation.  11/26/96 sw"

	| message |

	myChangeSet isEmpty ifFalse:
		[message _ 'Are you certain that you want to 
forget all the changes in this set?'.
		(self confirm: message) ifFalse: [^ self]].
	myChangeSet clear.
	self launch!
editPostscript
	"Allow the user to edit the receiver's change-set's postscript -- in a separate window at present.  11/27/96 sw"

	myChangeSet editPostscript!
editPreamble
	"Allow the user to edit the receiver's change-set's preamble -- in a separate window at present.  11/27/96 sw"

	myChangeSet editPreamble! !
!ChangeSorter class methodsFor: 'as yet unclassified'!
initialize
	"Initialize the class.  1991-tck
	Modified 1/12/96 sw: added a bunch of new items, not all of them implemented yet.  2/2/96 sw: added browse change set.  Also made it such that if AllChangeSets already exists, this won't clobber the existing order.  2/5/96 sw: changed wording of some items
	5/8/96 sw: added subtractOtherSide
	5/29/96 sw: added SingleCngSetMenu, for single change sorter
	5/30/96 sw: added fileIntoNewChangeSet
	7/23/96 di: removed SingleCngSetMenu, since not used
	11/25/96 sw: added cmds to manipulate preamble and postscript
	11/26/96 sw: added clear"

	AllChangeSets == nil ifTrue:
		[AllChangeSets _ OrderedCollection new].
	self gatherChangeSets.

	CngSetMenu _ PopUpMenu labels: 
'make changes go to me
new...
file into new...
show...
fileOut
browse
rename
copy all to other side
subtract other side
edit preamble...
edit postscript...
clear
remove'    lines: #(1 3 7 9 11).
	CngSetSelectors  _ 
		#(newCurrent newSet fileIntoNewChangeSet chooseCngSet fileOut browseChangeSet rename copyToOther subtractOtherSide editPreamble editPostscript clearChangeSet remove).

	ClassMenu _ PopUpMenu labels: 
'browse class
browse full
inst var refs
class vars
copy to other side
forget' 
			lines: #().
	ClassSelectors _ 
		#(browse browseFull instVarRefs classVariables copyToOther forget).

	MsgListMenu _ PopUpMenu labels: 
'fileOut
senders
implementors
senders of...
implementors of...
implementors of sent msgs
versions
copy to other side
forget' 
			lines: #(1 6 7).
	MsgListSelectors _ 
		#(fileOut senders implementors browseSendersOfMessages messages
		allImplementorsOf versions copyToOther forget).
	false ifTrue: [
		"Just so senders will find it here!!!!!!  Never executed."
		(CngsMsgList new) fileOut; senders; implementors; messages;  
			versions; copyToOther; forget.
		(MessageListController new) browseSendersOfMessages; 
			allImplementorsOf].

	"
	ChangeSorter initialize.
	GeneralListController allInstancesDo:
		[:each  | each model parent class == ChangeSorter ifTrue: [
			each yellowButtonMenu: ClassMenu 
				yellowButtonMessages: ClassSelectors.
			each yellowButtonMenu: MsgListMenu 
				yellowButtonMessages: MsgListSelectors]].
	"!
secondaryChangeSet
	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  11/26/96 sw"
	| last |
	self gatherChangeSets.
	AllChangeSets size == 1 ifTrue: [^ AllChangeSets first].
	^ (last _ AllChangeSets last) == Smalltalk changes
		ifTrue: 	[AllChangeSets at: (AllChangeSets size - 1)]
		ifFalse:	[last]! !
!Character methodsFor: 'converting'!
asLowercase
	"If the receiver is uppercase, answer its matching lowercase Character."
	
	(8r101 <= value and: [value <= 8r132])  "self isUppercase"
		ifTrue: [^ Character value: value + 8r40]
		ifFalse: [^ self]! !
!Character class methodsFor: 'accessing untypeable characters'!
linefeed
	"Answer the Character representing a linefeed."

	^self value: 10! !
!CharacterBlockScanner methodsFor: 'scanning'!
characterNotInFont 
	"This does not handle character selection nicely, i.e., illegal characters are a 
	little tricky to select.  Since the end of a run or line is subverted here by actually
	having the scanner scan a different string in order to manage the illegal 
	character, things are not in an absolutely correct state for the character 
	location code.  If this becomes too odious in use, logic will be added to accurately 
	manage the situation."

	lastCharacterExtent _ 
		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.
	^super characterNotInFont! !
!CharacterBlockScanner methodsFor: 'stop conditions'!
cr 
	"Answer a CharacterBlock that specifies the current location of the mouse 
	relative to a carriage return stop condition that has just been 
	encountered. The ParagraphEditor convention is to denote selections by 
	CharacterBlocks, sometimes including the carriage return (cursor is at 
	the end) and sometimes not (cursor is in the middle of the text)."

	((characterIndex ~= nil
		and: [characterIndex > text size])
			or: [(line last = text size)
				and: [(destY + line lineHeight) < characterPoint y]])
		ifTrue:	["When off end of string, give data for next character"
				destY _ destY +  line lineHeight.
				lastCharacter _ nil.
				characterPoint _ 
					Point
						x: ((text at: lastIndex) = CR
								ifTrue: [leftMargin]
								ifFalse: [nextLeftMargin])
						y: destY.
				lastIndex _ lastIndex + 1.
				lastCharacterExtent x: 0.
				^ true].
		lastCharacter _ CR.
		characterPoint _ destX @ destY.
		lastCharacterExtent x: rightMargin - destX.
		^true! !
!CharacterBlockScanner methodsFor: 'private'!
buildCharacterBlockIn: aText

	| lineIndex runLength lineStop done stopCondition |
	"handle nullText"
	(aText numberOfLines = 0 or: [text size = 0])
		ifTrue:	[^CharacterBlock
					stringIndex: 1	"like being off end of string"
					character: nil
					topLeft: ((aText leftMarginForDisplayForLine: 1) @
								(aText compositionRectangle) top)
					extent: (0 @ textStyle lineGrid)].

	"find the line"
	lineIndex _ aText lineIndexOfTop: characterPoint y.
	destY _ (aText topAtLineIndex: lineIndex).
	line _ aText lines at: lineIndex.
	rightMargin _ aText rightMarginForDisplay.

	(lineIndex = aText numberOfLines and:
		[(destY + line lineHeight) < characterPoint y])
			ifTrue:	["if beyond lastLine, force search to last character"
					characterPoint x: rightMargin]
			ifFalse:	[characterPoint y < (aText compositionRectangle) top
						ifTrue: ["force search to first line"
								characterPoint _
								(aText compositionRectangle) topLeft].
					characterPoint x > rightMargin
						ifTrue:	[characterPoint x: rightMargin]].
	destX _ leftMargin _ aText leftMarginForDisplayForLine: lineIndex.
	nextLeftMargin_ aText leftMarginForDisplayForLine: lineIndex+1.
	lastIndex _ line first.

	self setStopConditions.		"also sets font"
	runLength _ (text runLengthFor: line first).
	characterIndex ~~ nil
		ifTrue:	[lineStop _ characterIndex	"scanning for index"]
		ifFalse:	[lineStop _ line last].
	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop
		ifTrue:	[runStopIndex _ lineStop].
	lastCharacterExtent _ 0 @ line lineHeight.
	spaceCount _ 0. done  _ false.

	[done]
	whileFalse:
	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex
			in: text string rightX: characterPoint x
			stopConditions: stopConditions displaying: false.

	"see setStopConditions for stopping conditions for character block 	operations."
	lastCharacterExtent x: (font widthOf: (text at: lastIndex)).
	(self perform: stopCondition)
		ifTrue:	[^CharacterBlock
					stringIndex: lastIndex
					character: lastCharacter
					topLeft: characterPoint
					extent: lastCharacterExtent]]! !
!CharacterScanner methodsFor: 'scanning'!
scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display 
	"Primitive. This is the inner loop of text display--but see 
	scanCharactersFrom: to:rightX: which would get the string, 
	stopConditions and displaying from the instance. March through source 
	String from startIndex to stopIndex. If any character is flagged with a 
	non-nil entry in stops, then return the corresponding value. Determine 
	width of each character from xTable. If dextX would exceed rightX, then 
	return stops at: 258. If displaying is true, then display the character. 
	Advance destX by the width of the character. If stopIndex has been 
	reached, then return stops at: 257. Fail under the same conditions that 
	the Smalltalk code below would cause an error. Optional. See Object 
	documentation whatIsAPrimitive."
	| ascii nextDestX maxAscii |
	<primitive: 103>
	maxAscii _ xTable size-2.
	lastIndex _ startIndex.
	[lastIndex <= stopIndex]
		whileTrue: 
			[ascii _ (sourceString at: lastIndex) asciiValue.
			"ascii > maxAscii ifTrue: [ascii _ maxAscii]."
			(stopConditions at: ascii + 1) == nil
				ifFalse: [^stops at: ascii + 1].
			sourceX _ xTable at: ascii + 1.
			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).
			nextDestX > rightX ifTrue: [^stops at: CrossedX].
			display ifTrue: [self copyBits].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1].
	lastIndex _ stopIndex.
	^stops at: EndOfRun! !
!CharacterScanner methodsFor: 'private'!
addEmphasis: code
	"Set the bold-ital-under-strike emphasis."
	emphasisCode _ emphasisCode bitOr: code!
setActualFont: aFont
	"Set the basal font to an isolated font reference."

	font _ aFont!
setFont
	"Set the font and other emphasis."
	self setFont: 1.
	emphasisCode _ 0.
	(text attributesAt: lastIndex) do: 
		[:att | att emphasizeScanner: self].
	font _ font emphasized: emphasisCode.

	"Install various parameters from the font."
	spaceWidth _ font widthOf: Space. 
	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"
	height _ font height.			" ditto "
	xTable _ font xTable.
	stopConditions _ font stopConditions.
	stopConditions at: Space asciiValue + 1 put: #space.
	stopConditions at: Tab asciiValue + 1 put: #tab.
	stopConditions at: CR asciiValue + 1 put: #cr.
	stopConditions at: EndOfRun put: #endOfRun.
	stopConditions at: CrossedX put: #crossedX!
setFont: fontNumber
	"Set the basal font from the textStyle."

	font _ textStyle fontAt: fontNumber!
textColor: ignored
	"Overridden in DisplayScanner"! !
!Class methodsFor: 'initialize-release'!
sharing: poolString 
	"Set up sharedPools. Answer whether recompilation is advisable."
	| oldPools found |
	oldPools _ self sharedPools.
	sharedPools _ OrderedCollection new.
	(Scanner new scanFieldNames: poolString) do: 
		[:poolName | 
		sharedPools add: (Smalltalk at: poolName asSymbol)].
	sharedPools isEmpty ifTrue: [sharedPools _ nil].
	oldPools do: [:pool | found _ false.
				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].
				found ifFalse: [^ true "A pool got deleted"]].
	^ false! !
!Class methodsFor: 'class name'!
rename: aString 
	"The new name of the receiver is the argument, aString."

	| newName |
	newName _ aString asSymbol.
	(Smalltalk includesKey: newName)
		ifTrue: [^self error: newName , ' already exists'].
	(Undeclared includesKey: newName)
		ifTrue: [^ SelectionMenu notify: 'There are references to, ' , aString printString , '
from Undeclared. Check them after this change.'].
	Smalltalk renameClass: self as: newName.
	name _ newName.
	self comment: self comment.
	self class comment: self class comment! !
!Class methodsFor: 'pool variables'!
removeSharedPool: aDictionary 
	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 
	dictionaries. Create an error notification if the dictionary is not one of 
	the pools.
	9/12/96 tk: Note that it removes the wrong one if there are two empty Dictionaries in the list."

	| satisfiedSet workingSet aSubclass |
	(self sharedPools includes: aDictionary)
		ifFalse: [^self error: 'the dictionary is not in my pool'].

	"first see if it is declared in a superclass in which case we can remove it."
	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty
		ifFalse: [sharedPools remove: aDictionary.
				sharedPools isEmpty ifTrue: [sharedPools _ nil].
				^self]. 

	"second get all the subclasses that reference aDictionary through me rather than a 
	superclass that is one of my subclasses."

	workingSet _ self subclasses asOrderedCollection.
	satisfiedSet _ Set new.
	[workingSet isEmpty] whileFalse:
		[aSubclass _ workingSet removeFirst.
		(aSubclass sharedPools includes: aDictionary)
			ifFalse: 
				[satisfiedSet add: aSubclass.
				workingSet addAll: aSubclass subclasses]].

	"for each of these, see if they refer to any of the variables in aDictionary because 
	if they do, we can not remove the dictionary."
	satisfiedSet add: self.
	satisfiedSet do: 
		[:sub | 
		aDictionary associationsDo: 
			[:aGlobal | 
			(sub whichSelectorsReferTo: aGlobal) isEmpty 
				ifFalse: [^self error: aGlobal key 
								, ' is still used in code of class '
								, sub name]]].
	sharedPools remove: aDictionary.
	sharedPools isEmpty ifTrue: [sharedPools _ nil]! !
!Class methodsFor: 'compiling'!
scopeHas: varName ifTrue: assocBlock 
	"Look up the first argument, varName, in the context of the receiver. If it is there,
	pass the association to the second argument, assocBlock, and answer true.
	Else answer false.
	9/11/96 tk: Allow key in shared pools to be a string for HyperSqueak"

	| assoc |
	assoc _ self classPool associationAt: varName ifAbsent: [].
	assoc == nil
		ifFalse: 
			[assocBlock value: assoc.
			^true].
	self sharedPools do: 
		[:pool | 
		varName = #Textual ifTrue: [self halt].
		assoc _ pool associationAt: varName ifAbsent: [
			pool associationAt: varName asString ifAbsent: []].
		assoc == nil
			ifFalse: 
				[assocBlock value: assoc.
				^true]].
	superclass == nil
		ifTrue: 
			[assoc _ Smalltalk associationAt: varName ifAbsent: [].
			assoc == nil
				ifFalse: 
					[assocBlock value: assoc.
					^true].
			^false].
	^superclass scopeHas: varName ifTrue: assocBlock! !
!ClassDescription methodsFor: 'initialize-release'!
subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 
	"Basic initialization message for creating classes using the information 
	provided as arguments. Answer whether old instances will be 
	invalidated."
	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |
	oldNames _ self allInstVarNames.
	usedNames _ #(self super thisContext true false nil ) asSet.
	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.
	newNames _ newSuper allInstVarNames , newInstVarArray.
	newNames size > 254 ifTrue:
		[self error: 'A class cannot have more than 254 instance variables'.
		^ badBlock value].
	newNames do: 
		[:fieldName | 
		(usedNames includes: fieldName)
			ifTrue: 
				[self error: fieldName , ' is reserved (maybe in a superclass)'.
				^ badBlock value].
		usedNames add: fieldName].
	(invalid _ superclass ~~ newSuper)
		ifTrue: 
			["superclass changed"
			oldSuperMeta _ superclass class.
			superclass removeSubclass: self.
			superclass _ newSuper.
			superclass addSubclass: self.
			self class superclass == oldSuperMeta 
				ifTrue: ["Only false when self is a metaclass"
						self class superclass: newSuper class]].
	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].
	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"
	oldSpec _ self instSpec.
	self format: newNames size
		variable: v
		words: w
		pointers: p.
	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"
	^invalid!
updateInstancesFrom: oldClass 
	"Recreate any existing instances of the argument, oldClass, as instances of 
	the receiver, which is a newly changed class. Permute variables as 
	necessary."

	| oldInstVarNames map variable new instSize oldInstances |
	oldClass someInstance == nil ifTrue: [^self].
	"no instances to convert"
	oldInstVarNames _ oldClass allInstVarNames.
	map _ 
		self allInstVarNames 
			collect: [:instVarName | oldInstVarNames indexOf: instVarName].
	variable _ self isVariable.
	instSize _ self instSize.

	"Now perform a bulk mutation of old instances into new ones"
	oldInstances _ oldClass allInstances asArray.
	oldInstances elementsExchangeIdentityWith:
		(oldInstances collect: 
		[:old | 
		variable
			ifTrue: [new _ self basicNew: old basicSize]
			ifFalse: [new _ self basicNew].
		1 to: instSize do: 
			[:offset |  (map at: offset) > 0 ifTrue:
				[new instVarAt: offset
						put: (old instVarAt: (map at: offset))]].
		variable 
			ifTrue: [1 to: old basicSize do: 
						[:offset |
						new basicAt: offset put: (old basicAt: offset)]].
		new])!
validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods 
	"Recompile the receiver, a class, and redefine its subclasses if necessary.
	The parameter invalidFields is no longer really used"

	| newSub invalidSubMethods |
	oldClass becomeUncompact.  "Its about to be abandoned"
	invalidMethods & self hasMethods
		ifTrue: 
			[Transcript show: 'recompiling ' , self name , '...'.
			self compileAllFrom: oldClass.
			Transcript show: ' done'; cr].
	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).
	self == oldClass
		ifTrue: [invalidSubMethods ifFalse: [^self]]
		ifFalse: [self updateInstancesFrom: oldClass].
	oldClass subclasses do: 
		[:sub | 
		newSub _ sub copyForValidation.
		newSub
			subclassOf: self
			oldClass: sub
			instanceVariableNames: sub instVarNames
			variable: sub isVariable
			words: sub isBytes not
			pointers: sub isBits not
			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].
		newSub
			validateFrom: sub
			in: environ
			instanceVariableNames: invalidFields
			methods: invalidSubMethods]! !
!ClassDescription methodsFor: 'accessing'!
comment
	"Answer the receiver's comment."

	| aString |
	aString _ self theNonMetaClass organization classComment.
	aString size = 0 ifTrue: [^''].
	"get string only of classComment, undoubling quotes"
	^ String readFromString: aString!
comment: aString 
	"Set the receiver's comment to be the argument, aString."

	| aStream |
	aString size = 0
		ifTrue: 
			[self theNonMetaClass organization classComment: aString]
		ifFalse: 
			["double internal quotes of the comment string"
			aStream _ WriteStream on: (String new: aString size).
			aStream nextPutAll: self name , ' comment:'; cr.
			aString storeOn: aStream.
			self theNonMetaClass organization classComment: aStream contents.
	Smalltalk changes commentClass: self]!
commentTemplate
	"Answer an expression to edit and evaluate in order to produce the 
	receiver's comment."

	| aString |
	aString _ self theNonMetaClass organization classComment.
	aString size = 0
		ifTrue: [ ^ self name , ' comment:
''This class has not yet been commented''']
		ifFalse: [ ^ aString]! !
!ClassDescription methodsFor: 'compiling'!
compile: text classified: category notifying: requestor 
	| selector priorMethod method methodNode |
	method _ self
		compile: text asString
		notifying: requestor
		trailer: #(0 0 0 )
		ifFail: [^nil]
		elseSetSelectorAndNode: 
			[:sel :node | selector _ sel.
			priorMethod _ methodDict at: selector ifAbsent: [nil].
			methodNode _ node].
	self acceptsLoggingOfCompilation ifTrue:
		[method putSource: text asString
				fromParseNode: methodNode
				class: self category: category
				inFile: 2 priorMethod: priorMethod].
	self organization classify: selector under: category.
	^selector! !
!ClassDescription methodsFor: 'fileIn/Out'!
reformatMethodAt: selector 
	| newCodeString method | 
	newCodeString _ (self compilerClass new)
		format: (self sourceCodeAt: selector)
		in: self
		notifying: nil.
	method _ self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		inFile: 2 priorMethod: method! !
!ClassListController methodsFor: 'menu messages'!
spawnHierarchy
        "Request that the receiver's view display the class hierarchy (super- and 
        subclasses) of the selected class so that it can be edited."

        self controlTerminate.
        model spawnHierarchy.
        self controlInitialize!
spawnProtocol
        "Request that the receiver's model open a protocol browser."

        self controlTerminate.
        model spawnProtocol.
        self controlInitialize! !
!ClassListController class methodsFor: 'class initialization'!
initialize
        "Initialize the yellow button menu information.
         2/1/96 sw: added class vars
         7/29/96 sw: added 'find method' feature
        11/11/96 stp: added spawn protocol and separated show/spawn hierarchy
        11/12/96 stp: added recent classes feature
	   11/25/96 sw: recent classes feature moved to system category-list pane"
        
        ClassListYellowButtonMenu :=
                PopUpMenu 
                                labels: 
'browse class
printOut
fileOut
hierarchy
definition
comment
spawn hierarchy
spawn protocol
inst var refs..
inst var defs..
class var refs...
class vars
class refs
rename...
remove
find method...' 
                                lines: #(3 6 8 10 13 16).
        ClassListYellowButtonMessages := 
                #(browse  printOut fileOut
                hierarchy definition comment
                spawnHierarchy spawnProtocol
                browseInstVarRefs browseInstVarDefs browseClassVarRefs classVariables browseClassRefs
                rename remove findMethod)
        "
        ClassListController initialize.
        ClassListController allInstancesDo:
                [:x | x initializeYellowButtonMenu].
        "! !
!ClassOrganizer methodsFor: 'method dictionary'!
addCategory: catString before: nextCategory
	"Add a new category named heading.
	If default category exists and is empty, remove it.
	If nextCategory is nil, then add the new one at the end,
	otherwise, insert it before nextCategory."
	| index newCategory |
	newCategory _ catString asSymbol.
	(categoryArray indexOf: newCategory) > 0
		ifTrue: [^self].	"heading already exists, so done"
	index _ categoryArray indexOf: nextCategory
		ifAbsent: [categoryArray size + 1].
	categoryArray _ categoryArray
		copyReplaceFrom: index
		to: index-1
		with: (Array with: newCategory).
	categoryStops _ categoryStops
		copyReplaceFrom: index
		to: index-1
		with: (Array with: (index = 1
				ifTrue: [0]
				ifFalse: [categoryStops at: index-1])).
	"remove empty default category"
	(newCategory ~= Default
			and: [(self listAtCategoryNamed: Default) isEmpty])
		ifTrue: [self removeCategory: Default]! !
!Color methodsFor: 'examples'!
hsvExample
	"Shows a palette of hues, varying the saturation and brightness for each one."
	"Color new hsvExample.  Modified 6/14/96 tk"
	| d c rect |
	d _ Display depth.
	c _ Color new.		"modified in loop below"
	rect _ 0@0 extent: 5@5.	"modified in loop below"
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			0 to: 10 do: [:v |
				c setHue: h saturation: s asFloat / 10.0 brightness: v asFloat / 10.0.
				rect left: (h*4) + (s*5); width: 5.
				rect top: (v*5); height: 5.
				Display fill: rect fillColor: (c bitPatternForDepth: d).

				c setHue: h + 180 saturation: s asFloat / 10.0 brightness: v asFloat / 10.0.
				rect top: (v*5) + 80; height: 5.
				Display fill: rect fillColor: (c bitPatternForDepth: d).
			].
		].
	].
!
test: depth
	"Color new test: 8"
	| c |
	1 to: (1 << depth) do: [ :i |
		c _ IndexedColors at: i.
		(Color colorFromPixelValue: (c pixelValueForDepth: depth) value depth: depth) = c
			ifFalse: [ self error: 'bad conversion' ].
	].! !
!Color class methodsFor: 'colors'!
defaultColorMapFrom: sourceDepth to: destDepth
	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap).  Cache the maps.  Erase the cache at shutDown.  User should copy the colorMap before changing it.  12/9/96 tk"
	| bitsPerColor colorMap mask |

ColorMapCache == nil 
	ifTrue: [ColorMapCache _ Dictionary new: 16]
	ifFalse: [colorMap _ ColorMapCache at: (sourceDepth*37 + destDepth) ifAbsent: [nil].
		colorMap == nil ifFalse: [^ colorMap]].

sourceDepth < 16 
	ifTrue: [
		colorMap _ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap]

	ifFalse: [
		"For RGB, generate the simplest (3 bits per color) version"
		bitsPerColor _ 3.
		colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).
		mask _ (1 bitShift: bitsPerColor) - 1.
		0 to: colorMap size - 1 do:
			[:i | colorMap at: i+1 put:
				((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)
					green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
					blue: ((i bitShift: 0) bitAnd: mask)
					range: mask)
				pixelValueForDepth: destDepth)]].

ColorMapCache at: (sourceDepth*37 + destDepth) put: colorMap.
^ colorMap
!
named: newName put: aColor
	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color names) gives a list of the colors.  6/13/96 tk"
	| str cap sym accessor csym |
	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].
	str _ newName asString.
	sym _ str asSymbol.
	cap _ str capitalized.
	csym _ cap asSymbol.
	(self class canUnderstand: sym) ifFalse: [
		"define access message"
		accessor _ str, (String with: Character cr with: Character tab), 			'^', cap.
		self class compile: accessor
			classified: 'colors'].
	(self classPool includesKey: csym) ifFalse: [
		self addClassVarName: cap].
	(ColorNames includes: sym) ifFalse: [
		ColorNames add: sym].
	^ self classPool at: csym put: aColor!
noColor
	"Transparent"
	^ NullColor red: 0 green: 0 blue: 0.!
none
	"Transparent"
	^ NullColor red: 0 green: 0 blue: 0.!
nullColor
	"Transparent"
	^ NullColor red: 0 green: 0 blue: 0.!
transparent
	"Transparent"
	^ NullColor red: 0 green: 0 blue: 0.! !
!Color class methodsFor: 'class initialization'!
shutDown
	ColorChart _ nil.	"Samples of colors for user to pick from"
	ColorMapCache _ nil.	"Maps between color depths"! !
!CompiledMethod methodsFor: 'initialize-release'!
copyWithTrailerBytes: bytes
"Testing:
	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)
		tempNamesPut: 'copy end '
"
	| copy end start |
	start _ self initialPC.
	end _ self endPC.
	copy _ CompiledMethod newMethod: end - start + 1 + bytes size
				header: self header.
	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].
	start to: end do: [:i | copy at: i put: (self at: i)].
	1 to: bytes size do: [:i | copy at: end + i put: (bytes at: i)].
	^ copy! !
!CompiledMethod methodsFor: 'accessing'!
endPC
	"Answer the index of the last bytecode."
	MagicSources ifTrue:
		[self last = 0 ifFalse: [^ self size - self last - 1].
		"If last byte = 0, may be either 0, 0, 0 or just 0"
		1 to: 3 do: [:i | (self at: self size - i) = 0 ifFalse: [^ self size - i]]].
	(self last between: 120 and: 124) ifTrue: [^ self size].
	^ self size - 3! !
!CompiledMethod methodsFor: 'printing'!
storeOn: aStream
	| noneYet |
	aStream nextPutAll: '(('.
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' newMethod: '.
	aStream store: self size - self initialPC + 1.
	aStream nextPutAll: ' header: '.
	aStream store: self header.
	aStream nextPut: $).
	noneYet _ self storeElementsFrom: self initialPC to: self endPC on: aStream.
	1 to: self numLiterals do:
		[:index |
		noneYet
			ifTrue: [noneYet _ false]
			ifFalse: [aStream nextPut: $;].
		aStream nextPutAll: ' literalAt: '.
		aStream store: index.
		aStream nextPutAll: ' put: '.
		aStream store: (self literalAt: index)].
	noneYet ifFalse: [aStream nextPutAll: '; yourself'].
	aStream nextPut: $)! !
!CompiledMethod methodsFor: 'scanning'!
readsField: varIndex 
	"Answer whether the receiver loads the instance variable indexed by the 
	argument."

	self isReturnField ifTrue: [^self returnField + 1 = varIndex].
	varIndex <= 16 ifTrue: [^ self scanFor: varIndex - 1].
	varIndex <= 64 ifTrue: [^ self scanLongLoad: varIndex - 1].
	^ self scanVeryLongLoad: 64 offset: varIndex - 1!
readsRef: literalAssociation 
	"Answer whether the receiver loads the argument."
	| lit |
	lit _ self literals indexOf: literalAssociation ifAbsent: [^false].
	lit <= 32 ifTrue: [^self scanFor: 64 + lit - 1].
	lit <= 64 ifTrue: [^self scanLongLoad: 192 + lit - 1].
	^ self scanVeryLongLoad: 128 offset: lit - 1!
scanFor: byte 
	"Answer whether the receiver contains the argument as a bytecode."

	^ (InstructionStream on: self) scanFor: [:instr | instr = byte]
"
Smalltalk browseAllSelect: [:m | m scanFor: 134]
"!
scanLongStore: extension 
	"Answer whether the receiver contains a long store whose extension is 
	the argument."
	| scanner |
	scanner _ InstructionStream on: self.
	^scanner scanFor: 
		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]!
scanVeryLongLoad: extension offset: offset
	"Answer whether the receiver contains a long load whose extension is the 
	argument."
	| scanner |
	scanner _ InstructionStream on: self.
	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])
											and: [scanner thirdByte = offset]]!
scanVeryLongStore: extension offset: offset
	"Answer whether the receiver contains a long load with the given offset.
	Note that the constant +32 is the known difference between a
	store and a storePop for instVars, and it will always fail on literal variables,
	but these only use store (followed by pop) anyway."
	| scanner ext |
	scanner _ InstructionStream on: self.
	^ scanner scanFor:
		[:instr | (instr = 132 and: [(ext _ scanner followingByte) = extension
											or: [(ext +32) = extension]])
							and: [scanner thirdByte = offset]]!
writesField: field 
	"Answer whether the receiver stores into the instance variable indexed 
	by the argument."

	self isQuick ifTrue: [^false].
	field <= 8 ifTrue: [^ (self scanFor: 96 + field - 1)
						or: [self scanLongStore: field - 1]].
	field <= 64 ifTrue: [^ self scanLongStore: field - 1].
	^ self scanVeryLongStore: 160 offset: field - 1!
writesRef: ref 
	"Answer whether the receiver stores the argument."
	| lit |
	lit _ self literals indexOf: ref ifAbsent: [^false].
	lit <= 64 ifTrue: [^ self scanLongStore: 192 + lit - 1].
	^ self scanVeryLongStore: 224 offset: lit - 1! !
!CompiledMethod methodsFor: 'source code management'!
getSourceFor: selector in: class
	"Reconstruct the source code for the receiver."
	| source position tempNames |
	MagicSources ifTrue:
		["Decompile with temp names"
		^ ((class decompilerClass new withTempNames: self tempNames)
				decompile: selector in: class method: self)
			decompileString].
	(SourceFiles at: self fileIndex) == nil ifTrue:
		["There are no source files -- decompile without temp names"
		^ (class decompilerClass new
				decompile: selector in: class method: self)
			decompileString].
	Sensor leftShiftDown | Sensor controlKeyPressed ifTrue:
		["Special request to decompile..."
		tempNames _ Sensor controlKeyPressed
			ifTrue: [Array new  "emergency - don't touch source file for temps"]
			ifFalse: ["Just a decompiler demo - get temps from source file"
					(class compilerClass new
						parse: self getSourceFromFile in: class notifying: nil)
						tempNames].
		^ ((class decompilerClass new withTempNames: tempNames)
				decompile: selector
				in: class
				method: self) decompileString].

	"Situation normal;  read the sourceCode from the file"
	(source _ self getSourceFromFile) == nil ifFalse: [^ source].

	"Something really wrong -- decompile blind (no temps)"
	^ (class decompilerClass new decompile: selector in: class method: self)
			decompileString!
getSourceFromFile
	"Read the source code from file, determining source file index and
	file position from the last 3 bytes of this method."
	| position |
	(position _ self filePosition) = 0 ifTrue: [^ nil].
	^ (RemoteString newFileNumber: self fileIndex position: position)
			string!
putSource: sourceStr fromParseNode: methodNode class: class category: catName
	inFile: fileIndex priorMethod: priorMethod 
	"Print an expression that is a message to the argument, class, asking the 
	class to accept the source code, sourceStr, as a method in category, 
	catName. This is part of the format for writing descriptions of methods 
	on files. If no sources are specified, i.e., SourceFile iEs nil, then do 
	nothing. If the fileIndex is 1, print on *.sources; if it is 2, print on 
	*.canges.  If priorMethod is not nil, then link this source to the prior
	method and supply the time and date for this definition."
	| file remoteString |
	MagicSources ifTrue:
		[^ self tempNamesPut: methodNode tempNames].
	SourceFiles == nil ifTrue: [^ self].
	file _ SourceFiles at: fileIndex.
	file == nil ifTrue: [^ self].
	file setToEnd.
	class printCategoryChunk: catName on: file priorMethod: priorMethod.
	file cr.
	remoteString _ 
		RemoteString
			newString: sourceStr
			onFileNumber: fileIndex
			toFile: file.
	file nextChunkPut: ' '; flush.
	self setSourcePosition: remoteString position inFile: fileIndex!
putSource: sourceStr fromParseNode: methodNode inFile: fileIndex
	"Store the source code for the receiver on an external file.
	If no sources are specified, i.e., SourceFile is nil, then do nothing.
	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes."
	| file remoteString |
	MagicSources ifTrue:
		[^ self tempNamesPut: methodNode tempNames].
	file _ SourceFiles at: fileIndex.
	file == nil ifTrue: [^self].
	file setToEnd; readWriteShorten.
	file cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr.
	remoteString _ 
		RemoteString
			newString: sourceStr
			onFileNumber: fileIndex
			toFile: file.
	file nextChunkPut: ' '; readOnly.
	self setSourcePosition: remoteString position inFile: fileIndex!
qCompress: str
	"A very simple text compression routine designed for method temp names.
	Most common 12 chars get values 0-11 packed in one 4-bit nibble;
	others get values 12-15 (2 bits) * 16 plus next nibble.
	Last char of str must be a space so it may be dropped without
	consequence if output ends on odd nibble."
	| charTable odd ix oddNibble |
	charTable _  "Character encoding table must match qDecompress:"
	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.
	^ ByteArray streamContents:
		[:strm | odd _ true.  "Flag for odd or even nibble out"
		str do:
			[:char | ix _ (charTable indexOf: char) - 1.
			(ix <= 12 ifTrue: [ix]
				ifFalse: [Array with: ix//16+12 with: ix\\16])
				do:
				[:nibble | (odd _ odd not)
					ifTrue: [strm nextPut: oddNibble*16 + nibble]
					ifFalse: [oddNibble _ nibble]]].
		strm nextPut: strm position]
"
  | m s |  m _ CompiledMethod new.
s _ 'charTable odd ix oddNibble '.
^ Array with: s size with: (m qCompress: s) size
	with: (m qDecompress: (m qCompress: s))
"
!
qDecompress: byteArray
	"Decompress strings compressed by qCompress:.
	Most common 12 chars get values 0-11 packed in one 4-bit nibble;
	others get values 12-15 (2 bits) * 16 plus next nibble"
	|  charTable extended ext |
	charTable _  "Character encoding table must match qCompress:"
	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.
	^ String streamContents:
		[:strm | extended _ false.  "Flag for 2-nibble characters"
		byteArray do:
			[:byte | 
			(Array with: byte//16 with: byte\\16)
				do:
				[:nibble | extended
					ifTrue: [strm nextPut: (charTable at: ext*16+nibble + 1). extended _ false]
					ifFalse: [nibble < 12 ifTrue: [strm nextPut: (charTable at: nibble + 1)]
									ifFalse: [ext _ nibble-12.  extended _ true]]]]]!
setTempNamesIfCached: aBlock
	"This is a cache used by the debugger, independent of the storage of
	temp names when the system is converted to decompilation with temps."
	TempNameCache == nil ifTrue: [^self].
	TempNameCache key == self
		ifTrue: [aBlock value: TempNameCache value]!
tempNames
	| byteCount bytes |
	byteCount _ self at: self size.
	byteCount = 0 ifTrue: [^ Array new].
	bytes _ (ByteArray new: byteCount)
		replaceFrom: 1 to: byteCount with: self 
		startingAt: self size - byteCount.
	^ (self qDecompress: bytes) findTokens: ' '!
tempNamesPut: tempNames
	| tempStr copy |
	tempStr _ String streamContents:
		[:strm | tempNames do: [:n | strm nextPutAll: n; space]].
	copy _ self copyWithTrailerBytes: (self qCompress: tempStr).
	self become: copy! !
!CompiledMethod class methodsFor: 'class initialization'!
initialize    "CompiledMethod initialize"
	"Initialize class variables specifying the size of the temporary frame
	needed to run instances of me."

	SmallFrame _ 12.	"Context range for temps+stack"
	LargeFrame _ 32.
	MagicSources _ false!
magicSources: trueOrFalse
	"Set flag here when casting away source code, but keeping temp names"
	MagicSources _ trueOrFalse! !
!CompiledMethod class methodsFor: 'instance creation'!
new
	"This will not make a meaningful method, but it could be used
	to invoke some otherwise useful method in this class."
	^ self newMethod: 0 header: 0! !
!Compiler methodsFor: 'public access'!
format: textOrStream in: aClass notifying: aRequestor
	"Compile a parse tree from the argument, textOrStream. Answer a string 
	containing the original code, formatted nicely.
	If the leftShift key is pressed, then decorate the resulting text with
	color and hypertext actions"
	| aNode |
	self from: textOrStream
		class: aClass
		context: nil
		notifying: aRequestor.
	aNode _ self format: sourceStream noPattern: false ifFail: [^nil].
	Sensor leftShiftDown
		ifTrue: [^ aNode decompileText]
		ifFalse: [^ aNode decompileString]! !
!CompositionScanner methodsFor: 'scanning'!
composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 
	"Answer an instance of TextLineInterval that represents the next line in the paragraph."
	| runLength done stopCondition |
	spaceX _ destX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.
	destY _ 0.
	rightMargin _ aParagraph rightMarginForComposition.
	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].
	lastIndex _ startIndex.	"scanning sets last index"
	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."
	baseline _ textStyle baseline.
	self setStopConditions.	"also sets font"
	runLength _ text runLengthFor: startIndex.
	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).
	line _ TextLineInterval
		start: lastIndex
		stop: 0
		internalSpaces: 0
		paddingWidth: 0.
	spaceCount _ 0.
	done _ false.
	[done]
		whileFalse: 
			[stopCondition _ super
				scanCharactersFrom: lastIndex
				to: runStopIndex
				in: text string
				rightX: rightMargin
				stopConditions: stopConditions
				displaying: false.
			"See setStopConditions for stopping conditions for composing."
			(self perform: stopCondition)
				ifTrue: [^line lineHeight: lineHeight + textStyle leading
							baseline: baseline + textStyle leading]]!
setActualFont: aFont
        "Keep track of max height and ascent for auto lineheight"

        | descent |
        super setActualFont: aFont.
        descent _ lineHeight - baseline max: font descent.
        baseline _ baseline max: font ascent.
        lineHeight _ lineHeight max: baseline + descent!
setFont: fontNumber
        "Keep track of max height and ascent for auto lineheight"

        | descent |
        super setFont: fontNumber.
        descent _ lineHeight - baseline max: font descent.
        baseline _ baseline max: font ascent.
        lineHeight _ lineHeight max: baseline + descent! !
!CompositionScanner methodsFor: 'stop conditions'!
crossedX
	"There is a word that has fallen across the right edge of the composition 
	rectangle. This signals the need for wrapping which is done to the last 
	space that was encountered, as recorded by the space stop condition."

	line stop: spaceIndex.
	spaceCount > 1	
		ifTrue:	["The common case. First back off the space at which we wrap."
				spaceCount _ spaceCount - 1.
				spaceIndex _ spaceIndex - 1.
				["Check to see if any spaces preceding the one at which we wrap.
					Double space after a period, most likely."
				(spaceCount > 1 and: [(text at: spaceIndex) = Space])]
					whileTrue:
						[spaceCount _ spaceCount - 1.
						"Account for backing over a run which might
							change width of space."
						font _ textStyle fontAt:
								(text fontNumberAt: spaceIndex).
						spaceIndex _ spaceIndex - 1.
						spaceX _ spaceX - (font widthOf: Space)].
						line paddingWidth: rightMargin - spaceX.
						line internalSpaces: spaceCount]
		ifFalse:	[spaceCount = 1
					ifTrue:	["wrap at space, but no internal spaces"
							line internalSpaces: 0.
							line paddingWidth: rightMargin - spaceX]
					ifFalse:	["Neither internal nor trailing spaces, almost never happen,
								she says confidently."
							lastIndex _ lastIndex - 1.
							[destX <= rightMargin]
							whileFalse:
								[destX _ destX - (font widthOf:
													(text at: lastIndex)).
										"bug --doesn't account for backing over
										 run and changing actual width of
										characters. Also doesn't account for
										backing over a tab.  Happens only
										when no spaces in line, presumably rare."
								lastIndex _ lastIndex - 1].
							spaceX _ destX.
							line paddingWidth: rightMargin - destX.
							lastIndex < line first
								ifTrue:	[line stop: line first]
								ifFalse:	[line stop: lastIndex]]].
	^true! !
!ContextPart methodsFor: 'debugger access'!
mclass 
	"Answer the class in which the receiver's method was found."

	self receiver class selectorAtMethod: self method setClass: [:mclass].
	^mclass!
sourceCode
	| selector methodClass |
	selector _ self receiver class selectorAtMethod: self method
		setClass: [:mclass | methodClass _ mclass].
	^ methodClass sourceCodeAt: selector!
tempNames
	"Answer an OrderedCollection of the names of the receiver's temporary 
	variables, which are strings."

	self method setTempNamesIfCached: [:names | ^names].
	names _ (self mclass compilerClass new
			parse: self sourceCode
			in: self mclass
			notifying: nil) tempNames.
	self method cacheTempNames: names.
	^names! !
!ContextPart methodsFor: 'printing'!
printOn: aStream 
	| selector class |
	selector _ 
		(class _ self receiver class) 
			selectorAtMethod: self method 
			setClass: [:mclass].
	selector == #?
		ifTrue: 
			[aStream nextPut: $?; print: self method who.
			^self].
	aStream nextPutAll: class name.
	mclass == class 
		ifFalse: 
			[aStream nextPut: $(.
			aStream nextPutAll: mclass name.
			aStream nextPut: $)].
	aStream nextPutAll: '>>'.
	aStream nextPutAll: selector! !
!ContextPart methodsFor: 'private'!
doPrimitive: primitiveIndex receiver: receiver args: arguments 
	"Simulate a primitive method whose index is primitiveIndex.  The
	simulated receiver and arguments are given as arguments to this message."
"
	NOTE: In order for perform:WithArguments: to work reliably here,
	this method must be forced to invoke a large context.  This is done
	by adding extra temps until the following expression evaluates as true:
		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20
"
	| primitiveMethod value t1 t2 t3 |
	"If successful, push result and return resuming context,
		else ^ #simulatorFail"
	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])
		ifTrue: [^self push: 
					((BlockContext new: receiver size)
						home: receiver home
						startpc: pc + 2
						nargs: (arguments at: 1))].
	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])
		ifTrue: [^receiver pushArgs: arguments from: self].
	primitiveIndex = 83 
		ifTrue: [^self send: (arguments at: 1) to: receiver
					with: (arguments copyFrom: 2 to: arguments size)
					super: false].
	arguments size > 6 ifTrue: [^#simulatorFail].
	primitiveMethod _ TryPrimitiveMethods at: arguments size + 1.
	"slam num into primitive instead of 100 such messages in Object"
	primitiveMethod bePrimitive: primitiveIndex.
	"Class flushCache."  "in case interp caches primitive #"
	value _ receiver perform: (TryPrimitiveSelectors at: arguments size+1)
				withArguments: arguments.
	value == #simulatorFail
		ifTrue: [^ #simulatorFail]
		ifFalse: [^ self push: value]! !
!ContextPart class methodsFor: 'examples'!
tallyInstructions: aBlock
	"This method uses the simulator to count the number of occurrences of
	each of the Smalltalk instructions executed during evaluation of aBlock.
	Results appear in order of the byteCode set."
	| tallies |
	tallies _ Bag new.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current | tallies add: current nextByte].
	^tallies sortedElements

	"ContextPart tallyInstructions: [3.14159 printString]"!
tallyMethods: aBlock
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. Results are given in order of decreasing counts."
	| prev tallies |
	tallies _ Bag new.
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: "call or return"
				[prev sender == nil ifFalse: "call only"
					[tallies add: current printString].
				prev _ current]].
	^tallies sortedCounts

	"ContextPart tallyMethods: [3.14159 printString]"!
trace: aBlock		"ContextPart trace: [3 factorial]"
	"This method uses the simulator to print calls and returned values in the Transcript."
	| prev |
	Transcript clear.
	prev _ aBlock.
	^ thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current |
			Sensor anyButtonPressed ifTrue: [^ nil].
			current == prev
				ifFalse:
					[prev sender == nil ifTrue:  "returning"
						[Transcript space; nextPut: $^; print: current top].
					Transcript cr;
						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );
						print: current receiver; space; nextPutAll: current selector; endEntry.
					prev _ current]]!
trace: aBlock onFileNamed: fileName		"ContextPart trace: [3 factorial]"
	"This method uses the simulator to print calls to a file."
	| prev f sel |
	f _ FileStream fileNamed: fileName.
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current |
			Sensor anyButtonPressed ifTrue: [^ nil].
			current == prev
				ifFalse:
					[f cr;
						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );
						print: current receiver class; space; nextPutAll: (sel _ current selector); flush.
					prev _ current.
					sel == #error: ifTrue: [self halt]]].
	f close! !
!ContextStackListController methodsFor: 'menu messages'!
fullStack
	"Change from displaying the minimal stack to a full one."

	model contextStackList size > 15 "Already expanded"
		ifTrue:
			[view flash]
		ifFalse:
			[model contextStackIndex = 0
				ifFalse: [model toggleContextStackIndex: model contextStackIndex].
			self controlTerminate.
			model fullyExpandStack.
			self controlInitialize]!
proceed
	"Proceed execution of the receiver's model, starting after the expression at 
	which an interruption occurred."

	self controlTerminate.
	Smalltalk okayToProceedEvenIfSpaceIsLow ifTrue: [
		model proceed: view topView controller.
	].
	self controlInitialize! !
!ControlManager methodsFor: 'accessing'!
controllersSatisfying: aBlock
	"Return a list of scheduled controllers satisfying aBlock.  9/27/96 sw"

	^ scheduledControllers select:
		[:aController | (aBlock value: aController) == true]!
removeAllControllersSatisfying: aBlock
	"Unschedule and delete all controllers satisfying aBlock.  May not leave the screen exactly right sometimes. 10/9/96 sw"

	(self controllersSatisfying:  aBlock) do:
		[:aController | aController closeAndUnschedule]! !
!ControlManager methodsFor: 'displaying'!
updateGray
	"From Georg Gollmann - 11/96.  tell the Screen Controller's model to use the currently-preferred desktop color."

	"ScheduledControllers updateGray"
	(screenController view model isMemberOf: InfiniteForm)
		ifTrue: [screenController view model: (InfiniteForm with:
Preferences desktopColor)]! !
!CRFillInTheBlankController methodsFor: 'sensor access'!
dispatchOnCharacter: char with: typeAheadStream
	"Accept and terminate the interation if the user hits a CR or the enter key."

	(char = Character cr) | (char = Character enter)
		ifTrue:
			[sensor keyboard.  "gobble the character"
			self accept.
			^ true]
		ifFalse:
			[^ super dispatchOnCharacter: char with: typeAheadStream].
! !
!DataStream methodsFor: 'as yet unclassified'!
checkForPaths: anObject
	"After an object is fully internalized, it should have no PathFromHome in it.	The only exception is Array, as pointed to by an IncomingObjects.  8/16/96 tk"
	| pfh |
	pfh _ Smalltalk at: #PathFromHome ifAbsent: [^ self].
	1 to: anObject class instSize do:
		[:i | (anObject instVarAt: i) class == pfh ifTrue: [
			self error: 'Unresolved Path']].
!
readInstance
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next."
	| instSize aSymbol refPosn anObject |

	instSize _ (byteStream nextNumber: 4) - 1.
	refPosn _ self getCurrentReference.
	aSymbol _ self next.
	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	aSymbol endsWithDigit ifTrue:
		[self flag: #noteToTed.
		"Remove this once we know no Alias123 are written"
		aSymbol _ aSymbol stemAndNumericSuffix at: 1].
	anObject _ (Smalltalk at: aSymbol asSymbol)
		readDataFrom: self size: instSize.
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject!
writeClass: aClass
	"PRIVATE -- For now, no classes may be written.  HyperSqueak user unique classes have not state other than methods and should be reconstructed.  Could put standard fileOut code here if necessary.  7/29/96 tk."
	"Just halt for now -- 9/20/96 di."
	self error: 'Should not be trying to write a class'
"
	Obj classPool at: #ErrorHolder put: aClass.
	Transcript cr; show: 'The class ', aClass printString,' is trying to be written out.  See Obj class variable ErrorHolder.'.
"! !
!Debugger methodsFor: 'initialize-release'!
expandStack
	"This initialization occurs when the interrupted context is to modelled by 
	a DebuggerView, rather than a NotifierView (which can not display 
	more than five message-sends.
	10/30/96 sw: expand the default number of frames from 7 to 15"

	self newStack: (contextStackTop stackOfSize: 15).
	contextStackIndex _ 0.
	receiverInspector _ Inspector inspect: nil.
	contextVariablesInspector _ ContextVariablesInspector inspect: nil.
	proceedValue _ nil! !
!Debugger methodsFor: 'accessing'!
contents: aString notifying: aController 
	"The retrieved information has changed and its source must now be 
	updated. In this case, the retrieved information is the method of the 
	selected context."
	| selector classOfMethod category method priorMethod parseNode |
	contextStackIndex = 0 ifTrue: [^self].
	(self selectedContext isKindOf: MethodContext)
		ifFalse:
			[(self confirm:
'I will have to revert to the method from
which this block originated.  Is that OK?')
				ifTrue: [self resetContext: self selectedContext home]
				ifFalse: [^self]].
	classOfMethod _ self selectedClass.
	category _ self selectedMessageCategoryName.
	Cursor execute showWhile:
		[method _ classOfMethod
		compile: aString
		notifying: aController
		trailer: #(0 0 0 )
		ifFail: [^ false]
		elseSetSelectorAndNode: 
			[:sel :methodNode | selector _ sel.
			selector == self selectedMessageName
				ifFalse: [self notify: 'can''t change selector'. ^ false].
			priorMethod _ (classOfMethod includesSelector: selector)
				ifTrue: [classOfMethod compiledMethodAt: selector]
				ifFalse: [nil].
			sourceMap _ methodNode sourceMap.
			tempNames _ methodNode tempNames.
			parseNode _ methodNode].
		method cacheTempNames: tempNames].
	category isNil ifFalse: "Skip this for DoIts"
		[method putSource: aString asString
				fromParseNode: parseNode
				class: classOfMethod
				category: category
				inFile: 2 priorMethod: priorMethod.
		classOfMethod organization classify: selector under: category].
	contents _ aString copy.
	self selectedContext restartWith: method.
	contextVariablesInspector object: nil.
	self resetContext: self selectedContext.
	^true! !
!Debugger methodsFor: 'private'!
resumeProcess: aScheduledController
	aScheduledController view erase.
	Smalltalk installLowSpaceWatcher.  "restart low space handler"
	interruptedProcess suspendedContext method
			== (Process compiledMethodAt: #terminate) ifFalse:
		[contextStackIndex > 1
			ifTrue: [interruptedProcess popTo: self selectedContext]
			ifFalse: [interruptedProcess install: self selectedContext].
		ScheduledControllers
						activeControllerNoTerminate: interruptedController
						andProcess: interruptedProcess].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil. 
	aScheduledController closeAndUnscheduleNoErase.
	Processor terminateActive
! !
!DebuggerView class methodsFor: 'instance creation'!
debugger: aDebugger 
	"Answer a DebuggerView whose model is aDebugger. It consists of three 
	subviews, a ContextStackView (the ContextStackListView and 
	ContextStackCodeView), an InspectView of aDebugger's variables, and an 
	InspectView of the variables of the currently selected method context."
	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |
	aDebugger expandStack.
	topView _ self new model: aDebugger.
	stackListView _ ContextStackListView new model: aDebugger.
		stackListView window: (0 @ 0 extent: 150 @ 50).
		stackListView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.
		topView addSubView: stackListView.
	stackCodeView _ ContextStackCodeView new model: aDebugger.
		stackCodeView controller: ContextStackCodeController new.
		stackCodeView window: (0 @ 0 extent: 150 @ 75).
		stackCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.
		topView addSubView: stackCodeView below: stackListView.
	rcvrVarView _ InspectListView new model: aDebugger receiverInspector.
		rcvrVarView window: (0 @ 0 extent: 25 @ 50).
		rcvrVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
		topView addSubView: rcvrVarView below: stackCodeView.
	rcvrValView _ InspectCodeView new model: aDebugger receiverInspector.
		rcvrValView window: (0 @ 0 extent: 50 @ 50).
		rcvrValView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
		topView addSubView: rcvrValView toRightOf: rcvrVarView.
	ctxtVarView _ InspectListView new model: aDebugger contextVariablesInspector.
		ctxtVarView window: (0 @ 0 extent: 25 @ 50).
		ctxtVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
		topView addSubView: ctxtVarView toRightOf: rcvrValView.
	ctxtValView _ InspectCodeView new model: aDebugger contextVariablesInspector.
		ctxtValView window: (0 @ 0 extent: 50 @ 50).
		ctxtValView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
		topView addSubView: ctxtValView toRightOf: ctxtVarView.
	^ topView!
lowSpaceChoices
	"The message at the end of the Debugger window when there is a low space signal. 12/10/96 tk"
	^ ' Squeak is almost out of memory.
 If you detect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.  
 If you need this computation to finish, then make more space available (read on) and choose "proceed" in this debugger.  
 There are several ways to make more space available...
	> Close any other windows that are not needed.
	> Get rid of some large objects (esp images).
	> Leave this window on the screen, choose "save as..." from the screen menu, quit, select the Squeak VM in the Finder and choose "Get Info..." to give it more memory space, and then restart your saved image and choose "proceed" in this window.
 If you need to investigate further, choose "debug" in this widow.  Do not use "fullStack" unless you are certain that the stack is not very deep.
 Low space detection is now disabled.  It will be restored when you close or proceed.'!
openNotifier: aDebugger contents: msgString label: label
	"Create and schedule a simple view with a debugger which can be opened later."
	| aStringHolderView topView displayPoint nLines msg |
	self flag: #developmentNote.
	Cursor normal show.
	Sensor flushKeyboard.
	msg _ msgString.
	(label beginsWith: 'Space is low') ifTrue: [
		msg _ msg, self lowSpaceChoices].
	aStringHolderView _ StringHolderView container:
		(StringHolder new contents: msg).
	aStringHolderView controller: (NotifyStringHolderController debugger: aDebugger).
	topView _ StandardSystemView new.
	topView model: aStringHolderView model.
	topView addSubView: aStringHolderView.
	topView label: label.
	nLines _ 1 + (msgString occurrencesOf: Character cr).
	topView minimumSize: 350 @ (14*nLines + 6).
	displayPoint _ 
		ScheduledControllers activeController == nil
			ifTrue: [Display boundingBox center]
			ifFalse: [ScheduledControllers activeController view displayBox center].
	topView controller openNoTerminateDisplayAt: displayPoint.
	^ topView! !
!Decompiler methodsFor: 'initialize-release'!
initSymbols: aClass
	| nTemps namedTemps |
	constructor method: method class: aClass literals: method literals.
	constTable _ constructor codeConstants.
	instVars _ Array new: aClass instSize.
	nTemps _ method numTemps.
	namedTemps _ tempVars == nil ifTrue: [Array new] ifFalse: [tempVars].
	tempVars _ (1 to: nTemps) collect:
				[:i | i <= namedTemps size
					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]
					ifFalse: [constructor codeTemp: i - 1]]!
withTempNames: tempNameArray
	tempVars _ tempNameArray! !
!Decompiler methodsFor: 'control'!
checkForBlock: receiver
	"We just saw a blockCopy: message. Check for a following block."

	| savePc jump args argPos block |
	receiver == constructor codeThisContext ifFalse: [^false].
	savePc _ pc.
	(jump _ self interpretJump) notNil
		ifFalse:
			[pc _ savePc.  ^nil].
	"Definitely a block"
	jump _ jump + pc.
	argPos _ statements size.
	[self willStorePop]
		whileTrue:
			[stack addLast: ArgumentFlag.  "Flag for doStore:"
			self interpretNextInstructionFor: self].
	args _ Array new: statements size - argPos.
	1 to: args size do:  "Retrieve args"
		[:i | args at: i put: statements removeLast.
		(args at: i) scope: -1  "flag args as block temps"].
	block _ self blockTo: jump.
	stack addLast: (constructor codeArguments: args block: block).
	^true! !
!Decompiler methodsFor: 'instruction decoding'!
jump: dist if: condition

	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump
		elseJump condHasValue b |
	stack last == CascadeFlag ifTrue: [^self case: dist].
	elsePc _ lastPc.
	elseStart _ pc + dist.
	end _ limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign _ condition.
	savePc _ pc.
	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])
		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist]
		ifFalse: [pc _ savePc].
	ifExpr _ stack removeLast.
	thenBlock _ self blockTo: elseStart.
	condHasValue _ hasValue.
	"ensure jump is within block (in case thenExpr returns)"
	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			["thenJump will jump to the beginning of the while expr.  In the case of
			while's with a block in the condition, the while expr
			should include more than just the last expression: find all the
			statements needed by re-decompiling."
			pc _ thenJump.
			b _ self statementsTo: elsePc.
			"discard unwanted statements from block"
			b size - 1 timesRepeat: [statements removeLast].
			statements addLast: (constructor
					codeMessage: (constructor codeBlock: b returns: false)
					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)
					arguments: (Array with: thenBlock)).
			pc _ elseStart.
			self convertToDoLoop]
		ifFalse:
			[elseBlock _ self blockTo: thenJump.
			elseJump _ exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc
				ifTrue: [pc _ lastPc].
			cond _ constructor
						codeMessage: ifExpr
						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
						arguments:
							(sign
								ifTrue: [Array with: elseBlock with: thenBlock]
								ifFalse: [Array with: thenBlock with: elseBlock]).
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]]! !
!Decompiler methodsFor: 'private'!
convertToDoLoop
	"If statements contains the pattern
		var _ startConst.
		[var <= limit] whileTrue: [...statements... var _ var + incConst]
	then replace this by
		startConst to: limit by: incConst do: [:var | ...statements...]"
	| initStmt toDoStmt limitStmt |
	statements size < 2 ifTrue: [^ self].
	initStmt _ statements at: statements size-1.
	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)
		== nil ifTrue: [^ self].
	statements removeLast; removeLast; addLast: toDoStmt.
	initStmt variable scope: -1.  "Flag arg as block temp"
	statements size < 2 ifTrue: [^ self].
	limitStmt _ statements at: statements size-1.
	(toDoStmt _ statements last toDoWithLimit: limitStmt)
		== nil ifTrue: [^ self].
	statements removeLast; removeLast; addLast: toDoStmt.
	limitStmt variable scope: -2.  "Flag limit var as block temp"
!
decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block |
	constructor _ aConstructor.
	method _ aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block _ self quickMethod]
		ifFalse: 
			[stack _ OrderedCollection new: method frameSize.
			statements _ OrderedCollection new: 20.
			super method: method pc: method initialPC.
			block _ self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	^constructor
		codeMethod: aSelector
		block: block
		tempVars: (tempVars select: [:t | t scope >=0])
		primitive: method primitive
		class: aClass! !
!DecompilerConstructor methodsFor: 'constructor'!
codeConstants
	"Answer with an array of the objects representing self, true, false, nil,
	-1, 0, 1, 2."

	^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)
		, ((-1 to: 2) collect: [:i | LiteralNode new key: i code: LdMinus1 + i + 1])!
codeTemp: index

	^ TempVariableNode new
		name: 't' , (index + 1) printString
		index: index
		type: LdTempType
		scope: 0!
codeTemp: index named: tempName

	^ TempVariableNode new
		name: tempName
		index: index
		type: LdTempType
		scope: 0! !
!Dictionary methodsFor: 'accessing'!
keys
	"Answer a Set containing the receiver's keys."
	| aSet |
	aSet _ Set new: self size.
	self keysDo: [:key | aSet add: key].
	^ aSet! !
!Dictionary methodsFor: 'user interface'!
inspect
	"Open a DictionaryInspector on the receiver.  N.B.: this is
	an inspector without trash, since InspectorTrash doesn't do the
	obvious thing right now.  Use basicInspect to get a normal
	(less useful) type of inspector."

	DictionaryInspector openOn: self withEvalPane: false!
inspectFormsWithLabel: aLabel
	"Open a Form Dictionary inspector on the receiver, with the given label.  6/28/96 sw"

	^ DictionaryInspector openOn: self withEvalPane: false
		withLabel: aLabel
		valueViewClass: FormInspectView!
inspectWithLabel: aLabel
	"Open a DictionaryInspector on the receiver.  N.B.: this is
	an inspector without trash, since InspectorTrash doesn't do the
	obvious thing right now.  Use basicInspect to get a normal
	(less useful) type of inspector."

	DictionaryInspector openOn: self withEvalPane: false withLabel: aLabel! !
!DictionaryListController class methodsFor: 'class initialization'!
initialize
	DictionaryListYellowButtonMenu _
		PopUpMenu labels:
'inspect
references
objects pointing to this value
add key
remove'
		lines: #( 3 ).
	DictionaryListYellowButtonMessages _
		#(inspectSelection selectionReferences objectReferencesToSelection addEntry removeSelection )

	"DictionaryListController initialize"! !
!DiskProxyQ methodsFor: 'as yet unclassified'!
xxxQMessage: aMessage
    "Enqueue aMessage on the queue of messages that I will send the newly-created
     object at internalization time.
     IMPLEMENTATION: My instance variable messageQueue holds either nil or an Array
        of objects to sendTo: the object I'm internalizing to (generally of class
        Message or Symbol). -- 11/9/92 jhm
     12/1/92 jhm: Remove the 1-element-array optimization."

    messageQueue _ messageQueue == nil
        ifTrue:  [Array with: aMessage]
        ifFalse: [messageQueue, aMessage]! !
!DiskProxyQ class methodsFor: 'imported from V'!
readDataFrom: aDataStream size: anInteger
    "Create an object based on the contents of aDataStream, which was
       generated by the objects storeDataOn: method. Answer it.
     NOTE: This implementation for DiskProxyQ deals with a subtle issue in reading a
        network of objects. Recursively reading the a DiskProxyQs parts will
        internalize them (comeFullyUpOnReload), possibly sending messages to the
        nascent DiskProxyQ. I.e. the incomplete object receives (and enqueues)
        messages!! When we read the DiskProxyQs message queue, we must combine
        it with the accumulated queue.
     ASSUMES: Rather than hard-wire the index of the inst var messageQueue, we
        assume that any non-nil inst var has an Array to be concatenated with the
        filed value.
     NOTE: This method must match its corresponding storeDataOn:
       method. Also, it must send beginReference: after instantiating
       the new object but before reading any objects from aDataStream
       that might reference it. -- 12/1/92 jhm"
    | anObject cntInstVars cntIndexedVars nextValue var |

    cntInstVars _ self instSize.
    anObject _ self isVariable
        ifTrue:  [cntIndexedVars _ anInteger - cntInstVars.
                 self basicNew: cntIndexedVars]
        ifFalse: [cntIndexedVars _ 0.
                 self basicNew].

    aDataStream beginReference: anObject.

    "Read in the instance vars, but dont just overwrite vars that get contents
     before we get there due to recursive work in aDataStream next."
    1 to: cntInstVars do: [:i |
        nextValue _ aDataStream next.
        (var _ anObject instVarAt: i) == nil
            ifTrue:     "the normal case"
                [anObject instVarAt: i put: nextValue]
            ifFalse:    "Oops!! Recover: Concatenate nextValue and var Arrays."
                [nextValue == nil
                    ifFalse: [anObject instVarAt: i put: (nextValue, var)]]].

    "Read in the indexed vars."
    1 to: cntIndexedVars do:
        [:i | anObject basicAt: i put: aDataStream next].

    ^ anObject! !
!DisplayObject methodsFor: 'display box access'!
initialExtent
	"Included here for when a FormView is being opened
	as a window.  (4@4) covers border widths."

	^ self extent + (4@4) ! !
!DisplayScanner methodsFor: 'scanning'!
displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle
	"The central display routine. The call on the primitive 
	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 
	array of stop conditions passed to the scanner at which time the code to 
	handle the stop condition is run and the call on the primitive continued 
	until a stop condition returns true (which means the line has 
	terminated)."
	| runLength done stopCondition leftInRun |
	"leftInRun is the # of characters left to scan in the current run; when 0,
		it is time to call 'self setStopConditions'"
	leftInRun _ 0.
	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.
	paragraph _ aParagraph.
	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"
	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.
	rightMargin _ aParagraph rightMarginForDisplay.
	lineY _ aParagraph topAtLineIndex: linesInterval first.
	linesInterval do: 
		[:lineIndex | 
		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.
		runX _ destX _ leftMargin.
		line _ aParagraph lines at: lineIndex.
		lineHeight _ line lineHeight.
		fillBlt destX: visibleRectangle left destY: lineY
			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.
		lastIndex _ line first.
		leftInRun <= 0
			ifTrue: [self setStopConditions.  "also sets the font"
					leftInRun _ text runLengthFor: line first].
		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"
		runLength _ leftInRun.
		(runStopIndex _ lastIndex + (runLength - 1)) > line last 
			ifTrue: [runStopIndex _ line last].
		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).
		spaceCount _ 0.
		done _ false.
		[done]
			whileFalse: 
				[stopCondition _ self scanCharactersFrom: lastIndex
						to: runStopIndex
						in: text string
						rightX: rightMargin
						stopConditions: stopConditions
						displaying: true.
				"see setStopConditions for stopping conditions for displaying."
				done _ self perform: stopCondition].
		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.
		lineY _ lineY + lineHeight]! !
!DisplayScanner methodsFor: 'stop conditions'!
crossedX
	"This condition will sometimes be reached 'legally' during display, when, 
	for instance the space that caused the line to wrap actually extends over 
	the right boundary. This character is allowed to display, even though it 
	is technically outside or straddling the clipping ectangle since it is in 
	the normal case not visible and is in any case appropriately clipped by 
	the scanner."

	self fillLeading.
	^ true !
endOfRun
	"The end of a run in the display case either means that there is actually 
	a change in the style (run code) to be associated with the string or the 
	end of this line has been reached."
	| runLength |
	self fillLeading.  "Fill any leading above or below the font"
	lastIndex = line last ifTrue: [^true].
	runX _ destX.
	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).
	(runStopIndex _ lastIndex + (runLength - 1)) > line last 
		ifTrue: [runStopIndex _ line last].
	self setStopConditions.
	^ false!
paddedSpace
	"Each space is a stop condition when the alignment is right justified. 
	Padding must be added to the base width of the space according to 
	which space in the line this space is and according to the amount of 
	space that remained at the end of the line when it was composed."
	| oldX |
	spaceCount _ spaceCount + 1.
	oldX _ destX.
	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).
	fillBlt destX: oldX destY: destY width: destX - oldX height: height; copyBits.
	lastIndex _ lastIndex + 1.
	^ false!
tab
	| oldX |
	oldX _ destX.
	destX _ (textStyle alignment == Justified and: [self leadingTab not])
		ifTrue:		"imbedded tabs in justified text are weird"
			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]
		ifFalse: 
			[textStyle
				nextTabXFrom: destX
				leftMargin: leftMargin
				rightMargin: rightMargin].
	fillBlt destX: oldX destY: destY width: destX - oldX height: height;
		copyBits.
	lastIndex _ lastIndex + 1.
	^ false! !
!DisplayScanner methodsFor: 'private'!
fillLeading
	"At the end of every run (really only needed when font size changes),
	fill any extra leading above and below the font in the larger line height"

	"Fill space above the font"
	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;
		copyBits.

	"Fill space below the font"
	fillBlt destY: (destY + height); height: (lineY + lineHeight) - (destY + height);
		copyBits.
!
setFont 
	| map |
	foregroundColor _ paragraph foregroundColor.
	super setFont.  "Sets font and emphasis bits"
	lastSourceDepth = sourceForm depth ifFalse:
		["Set up color map for a different source depth (color font)"
		"Note this may need some caching for reasonable efficiency"
		map _ (Color defaultColorMapFrom: sourceForm depth to: destForm depth) copy.
		map at: 1 put: ((paragraph backgroundColor bitPatternForDepth: destForm depth) at: 1).
		self colorMap: map.
		lastSourceDepth _ sourceForm depth].
	sourceForm depth = 1 ifTrue:
		[(colorMap == nil or: [destForm depth = 1]) ifFalse:
			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].
	destY _ lineY + line baseline - font ascent!
textColor: textColor
	foregroundColor _ textColor! !
!DisplayScreen methodsFor: 'displaying'!
copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map
	((BitBlt
		destForm: self
		sourceForm: sf
		fillColor: hf
		combinationRule: cr
		destOrigin: destOrigin
		sourceOrigin: rect origin
		extent: rect extent
		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !
!DisplayScreen methodsFor: 'private'!
newDepthNoRestore: pixelSize
	"Change depths.  Check if there is enough space!!  12/10/96 tk, di"
	| area need |
	pixelSize = depth ifTrue: [^ self  "no change"].
	pixelSize < depth ifFalse:
		["Make sure there is enough space"
		area _ Display boundingBox area. "pixels"
		ScheduledControllers scheduledControllers do:
			[:aController | 
			(aController view isKindOf: StandardSystemView) ifTrue: [
				(aController view windowBits isKindOf: TwoToneForm) ifFalse: [
					area _ area + aController view windowBits boundingBox area]]].
		need _ (area * pixelSize // 8) - (area * depth // 8)  "new bytes needed"
				+ 80000.  "lowSpaceThreshold (should be shared)"
		(Smalltalk garbageCollectMost <= need
			and: [Smalltalk garbageCollect <= need])
			ifTrue: [self halt: 'Insufficient free space']].
	self depth: pixelSize.  
	self setExtent: self extent.
	ScheduledControllers updateGray.
	DisplayScreen startUp! !
!DisplayText methodsFor: 'converting'!
asParagraph
	"Answer a Paragraph whose text and style are identical to that of the 
	receiver."
	| para |
	para _ Paragraph withText: text style: textStyle.
	para foregroundColor: foreColor backgroundColor: backColor.
	backColor = Color none ifTrue: [para rule: Form paint].
	^ para! !
!DisplayText methodsFor: 'color'!
backgroundColor
	backColor == nil ifTrue: [^ Color none].
	^ backColor! !
!DisplayText class methodsFor: 'examples'!
example
	"Continually prints two lines of text wherever you point with the cursor 
	and press any mouse button.  Terminate by pressing any key on the 
	keyboard."
	| tx |
	tx _ 'this is a line of characters and
this is the second line.' asDisplayText.
	tx foregroundColor: Color black backgroundColor: Color none.
	tx _ tx alignedTo: #center.
	[Sensor anyButtonPressed]
		whileFalse:
			[tx displayOn: Display at: Sensor cursorPoint]

	"DisplayText example."! !
!DosFileDirectory methodsFor: 'file creation'!
fileClass
	^ StandardFileStream! !
!DosFileDirectory class methodsFor: 'initialization'!
pathNameDelimiter
	^ $\! !
!DualChangeSorter methodsFor: 'everything'!
open
	"1991, tk.  Modified 5/16/96 sw: decrease minimum size drastically
	 6/18/96 sw: more modest minimum size, and other minor adjustments
	 11/26/96 sw: more useful choice for initial cs in second sorter"

	| topView |
	leftCngSorter _ ChangeSorter new initializeFor: Smalltalk changes.
	leftCngSorter parent: self.
	rightCngSorter _ ChangeSorter new initializeFor: ChangeSorter secondaryChangeSet.
	rightCngSorter parent: self.

	topView _ StandardSystemView new.
	topView model: self.
	topView label: leftCngSorter label.
	topView minimumSize: 300 @ 200.
	self openView: topView.
	topView controller open!
openView: topView
	"Create views of dual side-by-side change sorter views"
"	| leftView rightView |
	leftView _ View new.
	leftView model: leftCngSorter.
	leftView window: (0 @ 0 extent: 360 @ 360).
	leftView borderWidthLeft: 0 right: 0 top: 0 bottom: 0.
"
	leftCngSorter openView: topView offsetBy: 0@0.
"
	rightView _ View new.
	rightView model: rightCngSorter.
	rightView window: (0 @ 0 extent: 360 @ 360).
	rightView borderWidthLeft: 0 right: 0 top: 0 bottom: 0.
"
	rightCngSorter openView: topView offsetBy: 360@0.
"
	topView addSubView: leftView.
	topView addSubView: rightView toRightOf: leftView.
"! !
!Encoder methodsFor: 'initialize-release'!
fillDict: dict with: nodeClass mapping: keys to: codeArray
	| codeStream |
	codeStream _ ReadStream on: codeArray.
	keys do: 
		[:key | dict 
				at: key
				put:  (nodeClass new name: key key: key code: codeStream next)]!
init: aClass context: aContext notifying: req
	| node n homeNode indexNode |
	requestor _ req.
	class _ aClass.
	nTemps _ 0.
	supered _ false.
	self initScopeAndLiteralTables.
	n _ -1.
	class allInstVarNames do: 
		[:variable | 
		node _ VariableNode new
					name: variable
					index: (n _ n + 1)
					type: LdInstType.
		scopeTable at: variable put: node].
	aContext == nil
		ifFalse: 
			[homeNode _ self bindTemp: 'homeContext'.
			"first temp = aContext passed as arg"
			n _ 0.
			aContext tempNames do: 
				[:variable | 
				indexNode _ self encodeLiteral: (n _ n + 1).
				node _ MessageNode new
							receiver: homeNode
							selector: #tempAt:
							arguments: (Array with: indexNode)
							precedence: 3
							from: self.
				scopeTable at: variable put: node]].
	sourceRanges _ Dictionary new: 32! !
!Encoder methodsFor: 'encoding'!
encodeVariable: name ifUnknown: action
	| varNode |
	varNode _ 
		scopeTable 
			at: name
			ifAbsent: 
				[self lookupInPools: name 
					ifFound: [:assoc | ^self global: assoc name: name].
				^action value].
	^varNode!
litIndex: literal
	| p |
	p _ literalStream position.
	p = 256 ifTrue:
		[self notify: 'More than 256 literals referenced. 
You must split or otherwise simplify this method.
The 257th literal is: ', literal printString. ^nil].
		"Would like to show where it is in the source code, 
		 but that info is hard to get."
	literalStream nextPut: literal.
	^ p! !
!Encoder methodsFor: 'temps'!
autoBind: name 
	"Declare a block argument as a temp if not already declared."
	| node |
	node _ scopeTable 
			at: name
			ifAbsent: 
				[(self lookupInPools: name ifFound: [:assoc | assoc])
					ifTrue: [self notify: 'Name already used in a Pool or Global'].
				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].
	node isTemp
		ifTrue: [node scope >= 0 ifTrue:
					[^ self notify: 'Name already used in this method'].
				node nowHasDef nowHasRef scope: 1]
		ifFalse: [^ self notify: 'Name already used in this class'].
	^node!
bindArg: name 
	"Declare an argument."
	| node |
	node _ self bindTemp: name.
	^ node nowHasDef nowHasRef!
newTemp: name

	nTemps _ nTemps + 1.
	^ TempVariableNode new
		name: name
		index: nTemps - 1
		type: LdTempType
		scope: 0! !
!Encoder methodsFor: 'results'!
tempNames 
	| tempNodes |
	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].
	scopeTable associationsDo:
		[:assn | (assn value isMemberOf: TempVariableNode)
			ifTrue: [tempNodes add: assn value]].
	^ tempNodes collect: [:node | node key]!
tempsAndBlockArgs
	| tempNodes var |
	tempNodes _ OrderedCollection new.
	scopeTable associationsDo:
		[:assn | var _ assn value.
		((var isTemp and: [var isArg not])
					and: [var scope = 0 or: [var scope = -1]])
			ifTrue: [tempNodes add: var]].
	^ tempNodes!
unusedTempNames 
	| unused |
	unused _ OrderedCollection new.
	scopeTable associationsDo:
		[:assn | (assn value isUnusedTemp)
			ifTrue: [unused add: assn value key]].
	^ unused! !
!Encoder methodsFor: 'source mapping'!
sourceMap
	"Answer with a sorted set of associations (pc range)."

	^ (sourceRanges keys collect: 
		[:key |  Association key: key pc value: (sourceRanges at: key)])
			asSortedCollection! !
!Encoder methodsFor: 'private'!
lookupInPools: name ifFound: assocBlock
	| |
	Symbol 
		hasInterned: name 
		ifTrue: [:sym | ^class scopeHas: sym ifTrue: assocBlock].
	^ class scopeHas: name ifTrue: assocBlock.  "Its a string in the pool"! !
!ExternalStream methodsFor: 'accessing'!
nextInto: buffer 
	"fill buffer from my collection"
	(buffer isMemberOf: Bitmap) ifTrue:
		[1 to: buffer size do:
			[:index | buffer at: index put: (self nextNumber: 4)].
		^ buffer].
	1 to: buffer size do:
		[:index | buffer at: index put: self next].
	^ buffer! !
!ExternalStream methodsFor: 'nonhomogeneous accessing'!
nextNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger."
	| s |
	s _ 0.
	1 to: n do: 
		[:i | s _ (s bitShift: 8) bitOr: self next].
	^ s normalize! !

FileDirectory comment:
'I represent a collection of Files. My instances are uniquely identified by the device or server to which they refer. They may also be found in some other dictionary or FileDirectory, though often this is implicit.  FileDirectories carry a path name, and are capable of a number of file creation and access functions, relating to the directory, or volume indicated by their path name.  A FileDirectory can be thought of as a Dictionary whose keys are the local names of files in that directory, and whose values are directory "entries".

A directory "entry" is an array of five items:
	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>
See the comment in lookupEntry:... which provides primitive access to this information.'!
!FileDirectory methodsFor: 'file names'!
fullNameFor: fileName
	pathName isEmpty ifTrue:
		[^ self checkName: fileName fixErrors: true].

	"Return <explicit or implicit path>,<corrected local name>"
	FileDirectory splitName: fileName to:
		[:path :localName |
		^ (path isEmpty ifTrue: [pathName] ifFalse: [path]) ,
			self pathNameDelimiter asString , 
			(self checkName: localName fixErrors: true)]! !
!FileDirectory class methodsFor: 'class initialization'!
openSources: sourcesName andChanges: changesName forImage: imageName
	"Look for the changes file on the image volume, and make the image volume the default directory.  Then look for the sources in the image volume.   Install results in SourceFiles.  2/13/96 sw.  Look for alias to sources 12/9/96 tk"
	| sources changes sourceAlias |
	self setDefaultDirectoryFrom: imageName.
	sources _ (DefaultDirectory includesKey: sourcesName)
		ifTrue: [DefaultDirectory readOnlyFileNamed: sourcesName]
		ifFalse: [nil].
	sources == nil ifTrue:
		["Allow an un-renamed alias of the sources file"
		sourceAlias _ sourcesName, ' alias'.
		sources _ (DefaultDirectory includesKey: sourceAlias)
			ifTrue: [DefaultDirectory readOnlyFileNamed: sourceAlias]
			ifFalse: [nil]].
	changes _ (DefaultDirectory includesKey: changesName)
		ifTrue: [DefaultDirectory oldFileNamed: changesName]
		ifFalse: [nil].
	SourceFiles _ Array with: sources with: changes! !
!FileDirectory class methodsFor: 'name service'!
convertName: fileName to: volAndNameBlock
	"Convert the fileName to a directory object and a local fileName.  FileName must be of the form: <path><name> where the optional <path> specifies a known directory and <name> is the file name within that directory."
	self splitName: fileName to:
		[:path :localName |
		path isEmpty
		ifTrue:
			[^ volAndNameBlock value: DefaultDirectory
								value: localName]
		ifFalse:
			[^ volAndNameBlock value: (self newOnPath: path)
								value: localName]]! !
!FileDirectory class methodsFor: 'primitives'!
lookupEntryIn: pathName index: index
	"Look up the index-th entry of the directory with the given path (starting from the root of the file hierarchy) and return an array containing:

	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>

	The empty path enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)

	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given pathName is bad."

 	<primitive: 162>
	self primitiveFailed.!
pathNameDelimiter
	^ self actualPathNameDelimiter!
setMacFileNamed: fileName type: typeString creator: creatorString
	"Mac specific; noop on other platforms."! !
!FileList methodsFor: 'initialization'!
directory: dir
	"Set the path of the volume to be displayed."
	sortMode == nil ifTrue: [sortMode _ #name].
	self okToChange ifFalse: [^ self].
	directory _ dir.
	volList _ (Array with: '[]'), directory pathParts.
	self changed: #relabel.
	self changed: #list.
	self newListAndPattern: (pattern == nil ifTrue: ['*']
										ifFalse: [pattern]).
! !
!FileList methodsFor: 'list access'!
toggleFileListIndex: anInteger
	"Select the file name in the receiver's list whose index is the argument, 
	anInteger. If the current selection index is already anInteger, deselect it."
	| item name |
	listIndex = anInteger
	ifTrue:
		[listIndex _ 0.
		contents _ ''.
		fileName _ nil]
	ifFalse: 
		[listIndex _ anInteger.
		item _ list at: anInteger.
		item first = $( ifTrue:  "remove size or date"
			[item _ item copyFrom: (item indexOf: $)) + 2 to: item size].
		(item endsWith: self folderString)
			ifTrue:
			["remove [...] folder string and open the folder"
			name _ item copyFrom: 1 to: item size - self folderString size.
			listIndex _ 0.
			^ self directory: (FileDirectory newOnPath:
				(directory fullNameFor: name))]
			ifFalse:
			["open the file selected"
			self setFileName: item]].
	self changed: #fileListIndex! !
!FileList methodsFor: 'menu messages'!
copyName
	| localName |
	listIndex = 0 ifTrue: [^ self].
	localName _ FileDirectory default localNameFor: self fullName.
	localName size = 0 ifTrue: [localName _ self fullName].
	ParagraphEditor new clipboardTextPut: localName asText! !
!FileListController methodsFor: 'menu messages'!
importHyperSqueakGIF
	"Import the selected file as a GIF file, into the HyperSqueak picture library.  8/17/96 sw"

	model isLocked ifTrue: [^ view flash].

	self controlTerminate.
	model importHyperSqueakGIF.
	self controlInitialize!
openImageInWindow
	self controlTerminate.
	model openImageInWindow.
	self controlInitialize	! !
!FileListController class methodsFor: 'class initialization'!
initialize   "FileListController initialize"
	"Initialize the file list menu.  6/96 di; modified 7/12/96 sw to add the file-into-new-change-set feature"

	FileListYellowButtonMenu _ PopUpMenu labels:
'fileIn
file into new change set
browse changes
spawn this file
copy name to clipboard
open image in a window
import GIF to GIFImports
import GIF to HyperSqueak
load HyperSqueak stack
sort by name
sort by size
sort by date
rename
delete
add new file' lines: # (5 9 12).
	FileListYellowButtonMessages _
#(fileInSelection fileIntoNewChangeSet browseChanges editFile copyName
 openImageInWindow importGIF importHyperSqueakGIF loadIntoHyperSqueak
 sortByName sortBySize sortByDate
 renameFile deleteFile addNewFile)! !
!FileModel methodsFor: 'accessing'!
importGIF
	"Import the file into a GIF file.  Places the resulting form into the global dictionary GIFImports, at a key which the short filename up to the first period.  7/18/96 sw
	 9/18/96 sw: fail gracefully if GIF is missing."

	| aKey anImage gifReader |
	(gifReader _ Smalltalk gifReaderClass) == nil ifTrue: [^ self inform: 'Sorry, there is no GIF reader available in the current system.'].
	aKey _ self fileName sansPeriodSuffix.
	anImage _ gifReader imageFrom: (FileStream oldFileNamed: self fullName) depth: 8.
		"Could allow 16 and not lose data"
	Smalltalk gifImports at: aKey put: anImage!
importHyperSqueakGIF
	"Import the file into a GIF file, into HyperSqueak. It had better be in the appropriate format, or you'll regret it!!  Places the resulting form into the HyperSqueak picture library, at a key which the short filename up to the first period. 8/17/96 sw
	 9/18/96 sw: handle no-gif-reader and no-HyperSqueak cases with Informers
	12/6/96 tk: Do force it to be 8-bit image"

	| aKey anImage hsq gifReader |
	Smalltalk hyperSqueakPresent ifFalse:
		[^ self inform: 'Sorry, HyperSqueak is not present in the current system.'].
	(gifReader _ Smalltalk gifReaderClass) == nil ifTrue: [^ self inform: 'Sorry, there is no GIF reader available in the current system.'].
	aKey _ self fileName sansPeriodSuffix.
	anImage _ gifReader imageFrom: (FileStream oldFileNamed: self fullName) depth: 8.
	(hsq _ Smalltalk at: #SqueakSupport ifAbsent: [nil]) == nil
		ifFalse:
			[hsq importPicture: anImage withKey: aKey]!
openImageInWindow
	| file fileCode form |
	file _ FileStream readOnlyFileNamed: self fullName.
	fileCode _ file next asciiValue.
	file close.
	fileCode = 2
		ifTrue: [form _ Form newFromFileNamed: self fullName]
		ifFalse: [form _ Smalltalk gifReaderClass imageFrom:
					(FileStream oldFileNamed: self
fullName) depth: Display depth].
	FormView open: form named: fileName!
put: aString 
	| f |
	(aString size >= 5 and:
		[#('File ' '16r0 ') includes: (aString copyFrom: 1 to: 5)])
		ifTrue: [(self confirm:
'Abbreviated and hexadecimal file views
cannot be meaningfully saved at present.
Is this REALLY what you want to do?')
				ifFalse: [^ self]].
	f _ FileStream newFileNamed: self fullName.
	Cursor write showWhile: [f nextPutAll: aString; close].!
readContentsBrief: brevityFlag
	"retrieve the contents from the external file unless it is too long.
	9/21/96 tk  Don't create a file here.  Check if exists."
	| f size newContents first1000 last1000 |

	f _ FileStream oldFileOrNoneNamed: self fullName. 
	f == nil ifTrue:
		[^ 'For some reason, this file cannot be read'].
	(brevityFlag and: [(size _ f size) > 30000]) ifFalse: 
		[^ f contentsOfEntireFile].

	"Don't display long files at first.
	Composing the paragraph may take a long time."
	first1000 _ f next: 1000.
	f position: size - 1000.
	last1000 _ f next: 1000.
	f close.
	^ 'File ''' , fileName , ''' is ', size printString, ' bytes long.
You may use the ''get'' command to read the entire file.

Here are the first 1000 characters:
--------------------------------
' , first1000 , '

... and here are the last 1000 characters:
--------------------------------------
' , last1000!
readContentsHex
	"retrieve the contents from the external file unless it is too long.
	9/21/96 tk  Don't create a file here.  Check if exists."
	| f size data hexData s |

	f _ FileStream oldFileOrNoneNamed: self fullName. 
	f == nil ifTrue:
		[^ 'For some reason, this file cannot be read'].
	(size _ f size) > 10000
		ifTrue: [data _ f next: 10000. f close]
		ifFalse: [data _ f contentsOfEntireFile].

	s _ WriteStream on: (String new: data size*4).
	0 to: data size-1 by: 16 do:
		[:loc | s nextPutAll: loc hex; space;
			nextPut: $(; print: loc; nextPut: $); space; tab.
		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].
		s cr].
	hexData _ s contents.

	size > 10000
		ifTrue: [^ 'First 10k bytes:
------------------
' , hexData]
		ifFalse: [^ hexData].! !
!FileStream methodsFor: 'file status'!
close
	"Set the receiver's file status to closed."

	closed
		ifFalse: 
			[self writing 
				ifTrue: [(rwmode bitAnd: Shorten) = Shorten
							ifTrue: [self shorten]
							ifFalse: [self flush]].
			closed _ true.
			readLimit _ writeLimit _ 0.
			self file close].! !
!FileStream class methodsFor: 'instance creation'!
fileNamed: fileName 
	^ self concreteStream fileNamed: (self fullName: fileName)!
newFileNamed: fileName 
	^ self concreteStream newFileNamed: (self fullName: fileName)!
oldFileNamed: fileName 
	^ self concreteStream oldFileNamed: (self fullName: fileName)!
oldFileOrNoneNamed: fileName
	"Only open the file if it exists already.  Don't get an error if not there.  9/21/96 tk"

| myName |
myName _ self fullName: fileName.
^ (self concreteStream isAFileNamed: myName) 
	ifTrue: [self concreteStream oldFileNamed: myName]
	ifFalse: [nil].!
readOnlyFileNamed: fileName 
	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !
!FileStream class methodsFor: 'concrete classes'!
concreteStream
	"Who should we really direct class queries to?  9/21/96 tk"
	^ StandardFileStream! !
!Float methodsFor: 'arithmetic'!
abs
	"This is faster than using Number abs."
	self < 0.0
		ifTrue: [^ 0.0 - self]
		ifFalse: [^ self]! !
!Float methodsFor: 'mathematical functions'!
arcCos
	"Answer the angle in radians."

	^ Halfpi - self arcSin!
arcSin
	"Answer the angle in radians."

	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].
	((self = -1.0) or: [self = 1.0])
		ifTrue: [^ Halfpi]
		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]!
arcTan
	"Answer the angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	| theta eps step sinTheta cosTheta |
	<primitive: 57>

	"Newton-Raphson"
	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].

	"first guess"
	theta _ (self * Halfpi) / (self + 1.0).

	"iterate"
	eps _ Halfpi * Epsilon.
	step _ theta.
	[(step * step) > eps] whileTrue: [
		sinTheta _ theta sin.
		cosTheta _ theta cos.
		step _ (sinTheta * cosTheta) - (self * cosTheta * cosTheta).
		theta _ theta - step].
	^ theta!
cos
	"Answer the cosine of the receiver taken as an angle in radians."

	^ (self + Halfpi) sin!
degreeCos
	"Answer the cosine of the receiver taken as an angle in degrees."

	^ self degreesToRadians cos!
degreeSin
	"Answer the sine of the receiver taken as an angle in degrees."

	^ self degreesToRadians sin!
exp
	"Answer E raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive." 

	| base fract correction delta div |
	<primitive: 59>

	"Taylor series"
	"check the special cases"
	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].
	self = 0.0 ifTrue: [^ 1].
	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].

	"get first approximation by raising e to integer power"
	base _ E raisedToInteger: (self truncated).

	"now compute the correction with a short Taylor series"
	"fract will be 0..1, so correction will be 1..E"
	"in the worst case, convergance time is logarithmic with 1/Epsilon"
	fract _ self fractionPart.
	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"

	correction _ 1.0 + fract.
	delta _ fract * fract / 2.0.
	div _ 2.0.
	[delta > Epsilon] whileTrue: [
		correction _ correction + delta.
		div _ div + 1.0.
		delta _ delta * fract / div].
	correction _ correction + delta.
	^ base * correction!
ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	| expt n mant x div pow delta sum eps |
	<primitive: 58>

	"Taylor series"
	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].

	"get a rough estimate from binary exponent"
	expt _ self exponent.
	n _ Ln2 * expt.
	mant _ self timesTwoPower: 0 - expt.

	"compute fine correction from mantinssa in Taylor series"
	"mant is in the range [0..2]"
	"we unroll the loop to avoid use of abs"
	x _ mant - 1.0.
	div _ 1.0.
	pow _ delta _ sum _ x.
	x _ x negated.  "x <= 0"
	eps _ Epsilon * (n abs + 1.0).
	[delta > eps] whileTrue: [
		"pass one: delta is positive"
		div _ div + 1.0.
		pow _ pow * x.
		delta _ pow / div.
		sum _ sum + delta.
		"pass two: delta is negative"
		div _ div + 1.0.
		pow _ pow * x.
		delta _ pow / div.
		sum _ sum + delta].

	^ n + sum

	"2.718284 ln 1.0"!
log
	"Answer the base 10 logarithm of the receiver."

	^ self ln / Ln10!
sin
	"Answer the sine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	| sum delta self2 i |
	<primitive: 56>

	"Taylor series"
	"normalize to the range [0..Pi/2]"
	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].
	self > Twopi ifTrue: [^ (self \\ Twopi) sin].
	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].
	self > Halfpi ifTrue: [^ (Pi - self) sin].

	"unroll loop to avoid use of abs"
	sum _ delta _ self.
	self2 _ 0.0 - (self * self).
	i _ 2.0.
	[delta > Epsilon] whileTrue: [
		"once"
		delta _ (delta * self2) / (i * (i + 1.0)).
		i _ i + 2.0.
		sum _ sum + delta.
		"twice"
		delta _ (delta * self2) / (i * (i + 1.0)).
		i _ i + 2.0.
		sum _ sum + delta].
	^ sum!
sqrt
	"Answer the square root of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	| exp guess eps delta |
	<primitive: 55>

	"Newton-Raphson"
	self <= 0.0 ifTrue: [
		self = 0.0
			ifTrue: [^ 0.0]
			ifFalse: [^ self error: 'sqrt is invalid for x < 0']].

	"first guess is half the exponent"
	exp _ self exponent // 2.
	guess _ self timesTwoPower: (0 - exp).

	"get eps value"
	eps _ guess * Epsilon.
	eps _ eps * eps.
	delta _ (self - (guess * guess)) / (guess * 2.0).
	[(delta * delta) > eps] whileTrue: [
		guess _ guess + delta.
		delta _ (self - (guess * guess)) / (guess * 2.0)].
	^ guess!
tan
	"Answer the tangent of the receiver taken as an angle in radians."

	^ self sin / self cos! !
!Float methodsFor: 'truncation and round off'!
truncated
	"Answer with a SmallInteger equal to the value of the receiver without 
	its fractional part. The primitive fails if the truncated value cannot be 
	represented as a SmallInteger. In that case, the code below will compute 
	a LargeInteger truncated value. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 51>
	^ (self quo: 16383.0) * 16383 + (self rem: 16383.0) truncated! !
!Float methodsFor: 'printing'!
hex  "If ya really want to know..."
	| word nibble |
	^ String streamContents:
		[:strm |
		1 to: 2 do:
			[:i | word _ self at: i.
			1 to: 8 do: 
				[:s | nibble _ (word bitShift: -8+s*4) bitAnd: 16rF.
				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]
"
(-2.0 to: 2.0) collect: [:f | f hex]
"!
printOn: aStream base: base
	"Estimate significant figures and handle sign." 
	| digitCount |
	digitCount _ 2r1.0e52 floorLog: base asFloat.  "IEEE double -- 52 bits"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base digitCount: digitCount]
		ifFalse: [self = 0.0 ifTrue: [^ aStream nextPutAll: '0.0'].
				aStream nextPutAll: '-'.
				self negated absPrintOn: aStream base: base digitCount: digitCount]! !
!Float methodsFor: 'private'!
absPrintOn: aStream base: base digitCount: digitCount 
	"Print me in the given base, using digitCount significant figures."
	| fuzz x exp q fBase |
	fBase _ base asFloat.
	"x is myself normalized to [1.0, fBase), exp is my exponent"
	exp _ 
		self < 1.0
			ifTrue: [(fBase / self floorLog: fBase) negated]
			ifFalse: [self floorLog: fBase].
	x _ self / (fBase raisedTo: exp).
	fuzz _ fBase raisedTo: 1 - digitCount.
	"round the last digit to be printed"
	x _ 0.5 * fuzz + x.
	x >= fBase
		ifTrue: 
			["check if rounding has unnormalized x"
			x _ x / fBase.
			exp _ exp + 1].
	(exp < 6 and: [exp > -4])
		ifTrue: 
			["decimal notation"
			q _ 0.
			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000' at: i)]]]
		ifFalse: 
			["scientific notation"
			q _ exp.
			exp _ 0].
	[x >= fuzz]
		whileTrue: 
			["use fuzz to track significance"
			i _ x asInteger.
			aStream nextPut: (Character digitValue: i).
			x _ x - i * fBase.
			fuzz _ fuzz * fBase.
			exp _ exp - 1.
			exp = -1 ifTrue: [aStream nextPut: $.]].
	[exp >= -1]
		whileTrue: 
			[aStream nextPut: $0.
			exp _ exp - 1.
			exp = -1 ifTrue: [aStream nextPut: $.]].
	q ~= 0
		ifTrue: 
			[aStream nextPut: $e.
			q printOn: aStream]!
timesTwoPower: anInteger 
	"Primitive. Answer with the receiver multiplied by 2.0 raised
	to the power of the argument.
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 54>

	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].
	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].
	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].
	^ self * (2.0 raisedToInteger: anInteger)! !
!Float class methodsFor: 'class initialization'!
initialize		"Float initialize. Float pi" 
	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288 
		Pi/2 = 1.57079632679489661923132169163975144 
		Pi/4 = 0.78539816339744830961566084581987572 
		Pi*2 = 6.28318530717958647692528676655900576 
		Pi/180 = 0.01745329251994329576923690768488612 
		2.0 ln = 0.69314718055994530941723212145817657 
		2.0 sqrt = 1.41421356237309504880168872420969808"

	Pi _ 3.14159265358979323846264338327950288.
	Halfpi _ Pi / 2.0.
	Fourthpi _ Pi / 4.0.
	Twopi _ Pi * 2.0.
	RadiansPerDegree _ Pi / 180.0.

	Ln2 _ 0.69314718055994530941723212145817657.
	Ln10 _ 10.0 ln.
	Sqrt2 _ 1.41421356237309504880168872420969808.
	E _ 2.718281828459045235360287471353.

	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"

	MaxVal _ 1e306.
	MinVal _ 1e-306.
	MaxValLn _ 704.
! !
!Float class methodsFor: 'constants'!
e
	"Answer the constant, E."

	^E! !
!FMSound methodsFor: 'sound generation'!
doControl

	super doControl.
	modulationDecay ~= 1.0 ifTrue: [
		modulation _ (modulationDecay * modulation asFloat) truncated.
	].
!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan
	"A simple implementation of Chowning's frequency-modulation synthesis technique. The center frequency is varied as the sound plays by changing the increment by which to step through the wave table."
	"FMSound majorScale play"
	"(FMSound pitch: 440.0 dur: 1.0 loudness: 200) play"

	| lastIndex mySample sample channelIndex |
	<primitive: 177>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #waveTable declareC: 'short int *waveTable'.

	lastIndex _ (startIndex + n) - 1.
	startIndex to: lastIndex do: [ :i |
		mySample _ (amplitude * (waveTable at: index)) // 1000.
		pan > 0 ifTrue: [
			channelIndex _ 2 * i.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].
		pan < 1000 ifTrue: [
			channelIndex _ (2 * i) - 1.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].

		index _ index + increment + ((modulation * (waveTable at: offsetIndex)) // 1000000).
		index > waveTableSize ifTrue: [
			index _ index - waveTableSize.
		].
		index < 1 ifTrue: [
			index _ index + waveTableSize.
		].
		offsetIndex _ offsetIndex + offsetIncrement.
		offsetIndex > waveTableSize ifTrue: [
			offsetIndex _ offsetIndex - waveTableSize.
		].
	].
	count _ count - n.
! !
!FontSet class methodsFor: 'as yet unclassified'!
acceptsLoggingOfCompilation
	"Dont log sources for my subclasses, so as not to waste time and space
	storing printstring versions of the string literals."
	^ self == FontSet!
convertFontsNamed: familyName  "FontSet convertFontsNamed: 'Palatino' "
	"This utility is for use after you have used BitFont to produce data files 
	for the fonts you wish to use.  It will read the BitFont files and build
	a fontset class from them.  If one already exists, the sizes that can be
	found will be overwritten."
	"For this utility to work as is, the BitFont data files must be named
	'familyNN.BF', and must reside in the same directory as this image."

	| f allFontNames className fontSet bytes sizeChars header strm fontString tempName |
	"Check first for matching file names and usable FontSet class name."
	allFontNames _ FileDirectory default fileNamesMatching: familyName , '*.BF'.
	allFontNames isEmpty ifTrue: [^ self halt: 'No files found like ' , familyName , 'NN.BF'].
	className _ (familyName select: [:c | c isAlphaNumeric]) capitalized asSymbol.
	(Smalltalk includesKey: className)
		ifTrue: ["Check that this is already a FontSet"
				((fontSet _ Smalltalk at: className) inheritsFrom: self)
					ifFalse: [self halt: 'The name ' , familyName , ' is already in use']]
		ifFalse: [fontSet _ self subclass: className
					instanceVariableNames: '' classVariableNames: ''
					poolDictionaries: '' category: self category].
	tempName _ 'FontTemp.sf2'.
	allFontNames do:
		[:fname | Transcript cr; show: fname.
		f _ StrikeFont new readFromBitFont: fname.
		f writeAsStrike2named: tempName.
		fontString _ (FileStream oldFileNamed: tempName) contentsOfEntireFile.
		sizeChars _ (fname copyFrom: familyName size + 1 to: fname size) copyUpTo: $. .
		header _ 'sizeNN
	^ self size: NN fromLiteral:
' copyReplaceAll: 'NN' with: sizeChars.
		fontSet class compile: header , fontString printString
			classified: 'font creation' notifying: nil].
	FileDirectory default deleteFileNamed: tempName.
! !
!Form methodsFor: 'accessing'!
theForm
	"For compatibility with MaskedForm"

	^ self! !
!Form methodsFor: 'copying'!
copy: sourceRectangle from: sourceForm to: destPt rule: rule
	^ self copy: (destPt extent: sourceRectangle extent)
		from: sourceRectangle topLeft in: sourceForm rule: rule! !
!Form methodsFor: 'displaying'!
copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map
	"Make up a BitBlt table and copy the bits.  Use a colorMap."

	((BitBlt 
		destForm: self
		sourceForm: sourceForm
		fillColor: aForm
		combinationRule: rule
		destOrigin: destOrigin
		sourceOrigin: sourceRect origin
		extent: sourceRect extent
		clipRect: clipRect) colorMap: map) copyBits!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm
	"Supply a color map from source to destination.  12/8/96 tk"
	| map rule |
	rule _ ruleInteger.
	aDisplayMedium depth ~= depth ifTrue: ["need a map"
		map _ Color defaultColorMapFrom: depth to: aDisplayMedium depth.
		depth = 1 & (aDisplayMedium depth > 8) & (rule = 26 "erase1bitShape") 
			ifTrue: [rule _ 1 "and"]].	"Bug workaround"
	aDisplayMedium copyBits: self boundingBox
		from: self
		at: aDisplayPoint + self offset
		clippingBox: clipRectangle
		rule: rule
		fillColor: aForm
		map: map!
displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 
	"Graphically, it means nothing to scale a Form by floating point values.  
	Because scales and other display parameters are kept in floating point to 
	minimize round off errors, we are forced in this routine to round off to the 
	nearest integer."

	| absolutePoint scale magnifiedForm |
	absolutePoint _ displayTransformation applyTo: relativePoint.
	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.
	displayTransformation noScale
		ifTrue: [magnifiedForm _ self]
		ifFalse: 
			[scale _ displayTransformation scale.
			scale _ scale x @ scale y.
			(1@1 = scale)
					ifTrue: [scale _ nil. magnifiedForm _ self]
					ifFalse: [magnifiedForm _ self magnify: self boundingBox by: scale]].
	magnifiedForm
		displayOn: aDisplayMedium
		at: absolutePoint - alignmentPoint
		clippingBox: clipRectangle
		rule: ruleInteger
		fillColor: aForm! !
!Form methodsFor: 'filling'!
colorAt: aPoint
	"Return the Color in the pixel at coordinate aPoint.  6/20/96 tk"

	^ Color 
		colorFromPixelValue: 
			((BitBlt bitPeekerFromForm: self) pixelAt: aPoint)
		depth: depth! !
!Form methodsFor: 'bordering'!
border: rect width: borderWidth rule: rule fillColor: fillColor 
	"Paint a border whose rectangular area is defined by rect. The 
	width of the border of each side is borderWidth. Uses fillColor for 
	drawing the border."
	| blt |
	blt _ (BitBlt toForm: self) combinationRule: rule; fillColor: fillColor.
	blt sourceOrigin: 0@0.
	blt destOrigin: rect origin.
	blt width: rect width; height: borderWidth; copyBits.
	blt destY: rect bottom-borderWidth; copyBits.
	blt destOrigin: rect origin.
	blt height: rect height; width: borderWidth; copyBits.
	blt destX: rect right-borderWidth; copyBits.!
borderFormOfWidth: borderWidth sharpCorners: sharpen
	"Smear this form around and then subtract the original to produce
	an outline.  If sharpen is true, then cause right angles to be outlined
	by right angles (takes an additional diagonal smears ANDed with both
	horizontal and vertical smears)."
	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |
	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."
	bigForm _ self deepCopy.
	all _ bigForm boundingBox.
	smearForm _ Form extent: self extent.
	smearPort _ BitBlt toForm: smearForm.
	sharpen ifTrue:
		[cornerForm _ Form extent: self extent.
		cornerPort _ BitBlt toForm: cornerForm].
	nbrs _ (0@0) fourNeighbors.
	1 to: borderWidth do:
		[:i |  "Iterate to get several layers of 'skin'"
		nbrs do:
			[:d |  "Smear the self in 4 directions to grow each layer of skin"
			smearPort copyForm: bigForm to: d rule: Form under].
		sharpen ifTrue:
			["Special treatment to smear sharp corners"
			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:
				[:d1 :d2 |
				"Copy corner points diagonally"
				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.
				"But only preserve if there were dots on either side"
				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.
				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.
				smearPort copyForm: cornerForm to: 0@0 rule: Form under].
			].
		bigForm copy: all from: 0@0 in: smearForm rule: Form over.
		].
	"Now erase the original shape to obtain the outline"
	bigForm copy: all from: 0@0 in: self rule: Form erase.
	^ bigForm! !
!Form methodsFor: 'scaling, rotation'!
flipBy: direction centerAt: aPoint
	"Return a copy of the receiver flipped either #vertical or #horizontal."
	| newForm quad |
	newForm _ Form extent: self extent depth: depth.
	quad _ self boundingBox corners.
	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
	newForm offset: (self offset flipBy: direction centerAt: aPoint).
	^ newForm
"
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))
			flipBy: #vertical centerAt: 0@0) display]
"!
magnify: aRectangle by: scale 
	"Answer a Form created as a scaling of the receiver.
	Scale may be a Float, and may be greater or less than 1.0."
	^ self magnify: aRectangle by: scale smoothing: 1

"Dynamic test...
[Sensor anyButtonPressed] whileFalse:
	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]
"
"Scaling test...
| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).
Display restoreAfter: [Sensor waitNoButton.
[Sensor anyButtonPressed] whileFalse:
	[cp _ Sensor cursorPoint.
	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]
"!
magnify: aRectangle by: scale smoothing: cellSize
	"Answer a Form created as a scaling of the receiver.
	Scale may be a Float, and may be greater or less than 1.0."
	| newForm |
	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.
	(WarpBlt toForm: newForm)
		sourceForm: self;
		cellSize: cellSize;
		combinationRule: 3;
		copyQuad: aRectangle corners toRect: newForm boundingBox.
	^ newForm

"Dynamic test...
[Sensor anyButtonPressed] whileFalse:
	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]
"
"Scaling test...
| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).
Display restoreAfter: [Sensor waitNoButton.
[Sensor anyButtonPressed] whileFalse:
	[cp _ Sensor cursorPoint.
	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]
"!
rotateBy: deg
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, bit enough for any angle."

	^ self rotateBy: deg smoothing: 1
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))
		rotateBy: (a _ a+5)) display].
f display
"!
rotateBy: direction centerAt: aPoint
	"Return a copy of the receiver rotated either #right or #left"
	| newForm warp quad |
	newForm _ Form extent: height@width depth: depth.
	quad _ self boundingBox corners.
	quad _ (direction = #left ifTrue: [0 to: 3] ifFalse: [2 to: 5])
		collect: [:i | quad atWrap: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
	newForm offset: (self offset rotateBy: direction centerAt: aPoint).
	^ newForm
"
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))
		rotateBy: #left centerAt: 0@0) display]
"!
rotateBy: deg rotationCenter: aPoint
	"Rotate the receiver by the indicated number of degrees.  This variant gets a rotation center, but in fact ignores the thing -- awaiting someone's doing the right thing.   8/9/96 sw
	Note that rotationCenter should now be easy to include in the offset of the resulting form -- see <Point> rotateBy: angle about: center.  Could be even faster by sharing the sin, cos inside rotateBy:.  This should really be reversed so that this becomes the workhorse, and rotateBy: calls this with rotationCenter: self boundingBox center.  And while we're at it, why not include scaling?  9/19/96 di "

	^ self rotateBy: deg smoothing: 1!
rotateBy: deg smoothing: cellSize
	"Rotate the receiver by the indicated number of degrees."
	"rot is the destination form, bit enough for any angle."
	| side rot warp r1 pts p p0 center |
	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.
	rot _ Form extent: side@side depth: self depth.
	center _ rot extent // 2.

	"Now compute the sin and cos constants for the rotation angle." 
	warp _ (WarpBlt toForm: rot)
		sourceForm: self;
		cellSize: cellSize;
		combinationRule: Form over.
	r1 _ rot boundingBox align: center with: self boundingBox center.

	pts _ r1 corners collect:
		[:pt | p _ pt - r1 center.
		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @
		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].
	warp copyQuad: pts toRect: rot boundingBox.
	^ rot
"
 | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.
[Sensor anyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))
		rotateBy: (a _ a+5) smoothing: 2) display].
f display
"! !
!Form methodsFor: 'transitions'!
pageImage: otherImage at: topLeft corner: corner
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.  Corner specifies which corner, as
		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."
	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |
	stepSize _ 10.
	bb _ otherImage boundingBox.
	resultForm _ self copy: (topLeft extent: bb extent).
	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.

	"maskLoc _ starting loc rel to topLeft"
	otherImage width > otherImage height
		ifTrue: ["wide image; motion is horizontal."
				(corner between: 2 and: 3) not ifTrue:
					["motion is to the right"
					delta _ 1@0.
					maskLoc _ bb topLeft - (corner = 1
						ifTrue: [maskForm width@0]
						ifFalse: [maskForm width@stepSize])]
					ifFalse:
					["motion is to the left"
					delta _ -1@0.
					maskLoc _ bb topRight - (corner = 2
						ifTrue: [0@0]
						ifFalse: [0@stepSize])]]
		ifFalse: ["tall image; motion is vertical."
				corner <= 2 ifTrue:
					["motion is downward"
					delta _ 0@1.
					maskLoc _ bb topLeft - (corner = 1
						ifTrue: [0@maskForm height]
						ifFalse: [stepSize@maskForm height])]
					ifFalse:
					["motion is upward"
					delta _ 0@-1.
					maskLoc _ bb bottomLeft - (corner = 3
						ifTrue: [stepSize@0]
						ifFalse: [0@0])]].

	"Build a solid triangle in the mask form"
	(Pen newOnForm: maskForm) do: [:p |
		corner even  "Draw 45-degree line"
			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]
			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].
	maskForm smear: delta negated distance: maskForm width.
	"Copy the mask to full resolution for speed.  Make it be the reversed
	so that it can be used for ORing in the page-corner color"
	maskForm _ (Form extent: maskForm extent depth: otherImage depth)
		copyBits: maskForm boundingBox from: maskForm at: 0@0
		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).

	"Now move the triangle maskForm across the resultForm selecting the
	triangular part of otherImage to display, and across the resultForm,
	selecting the part of the original image to erase."
	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.
	1 to: (otherImage width + otherImage height // stepSize)+1 do:
		[:i |		"Determine the affected square"
		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.
		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:
			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.
			maskRect _ smallRect align: (smallRect perform: cornerSel)
								with: (maskRect perform: cornerSel)].

		"AND otherForm with triangle mask, and OR into result"
		resultForm copyBits: bb from: otherImage at: 0@0
				clippingBox: maskRect rule: Form over fillColor: nil.
		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc
				clippingBox: maskRect rule: Form erase fillColor: nil.
		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc
				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.

		"Now update Display in a single BLT."
		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft
				clippingBox: self boundingBox rule: Form over fillColor: nil.
		maskLoc _ maskLoc + (delta*stepSize)]
"
1 to: 4 do: [:corner | Display pageImage:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 corner: corner]
"
! !
!Form class methodsFor: 'mode constants'!
erase1bitShape
	"Answer the integer denoting mode erase."

	^ 26!
oldErase1bitShape
	"Answer the integer denoting mode erase."

	^ 17!
oldPaint
	"Answer the integer denoting the 'paint' combination rule."

	^16!
paint
	"Answer the integer denoting the 'paint' combination rule."

	^25! !
!FormEditor methodsFor: 'editing tools'!
fileOutForm
	"Ask the user for a file name and then save the current source form 
	(form) under that name. Does not change the tool."

	| outName |
	outName _ self promptRequest: 'type a name for saving the source Form . . . '.
	FileDirectory convertName: outName to: [ :vol :name |
		(vol isLegalFileName: name)
			ifTrue: [(vol includesKey: name) 
					ifTrue: [(self confirm: 
									'Okay to write over old file?')
								ifTrue: [form writeOn: outName]]
					ifFalse: [form writeOn: outName]]].
	tool _ previousTool!
repeatCopy
	"As long as the red button is pressed, copy the source form onto the 
	display screen."

	[sensor redButtonPressed]
		whileTrue: 
		[(BitBlt destForm: Display sourceForm: form halftoneForm: color
			combinationRule: (Display depth > 1 ifTrue: [Form paint]
										ifFalse: [mode])
			destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent
			clipRect: view insetDisplayBox)
			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);
			copyBits]! !
!FormEditor methodsFor: 'menu messages'!
edit
	model edit! !
!FormEditor methodsFor: 'private'!
promptRequest: outputMessage 
	"Answers with a string typed by the user on the keyboard. keyboard
	input is terminated by a line feed character. Typing feedback happens
	in a window that is at least 100 bits wide and 50 bits high."

	FillInTheBlank
		request: outputMessage
		displayAt: view insetDisplayBox topCenter + (0@80)
		centered: true
		action: [:answer] 
		initialAnswer: ''.
	^answer! !
!FormEditor class methodsFor: 'class initialization'!
initialize

	FlashCursor _ false.
	self setKeyboardMap.
	YellowButtonMenu _ PopUpMenu labels: 'accept
cancel
edit
file out' lines: #(2).
	YellowButtonMessages _ #(accept cancel edit fileOut)

	"FormEditor initialize"! !
!FormEditor class methodsFor: 'private'!
createFullScreenForm
	"Create a StandardSystemView for a FormEditor on the form whole screen."
	| formView formEditor menuView topView extent aForm |
	aForm _ Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.
	formView _ FormHolderView new model: aForm.
	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.
	formEditor _ formView controller.
	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.
	formEditor model: menuView controller.
	topView _ ColorSystemView new.
	topView backgroundColor: #veryLightGray.
	topView model: aForm.
	topView addSubView: formView.
	topView 
		addSubView: menuView
		align: menuView viewport topCenter
		with: formView viewport bottomCenter + (0@16).
	topView window: 
		(formView viewport 
			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).
	topView label: 'Form Editor'.
	extent _ topView viewport extent.
	topView minimumSize: extent.
	topView maximumSize: extent.
	^topView

!
createOnForm: aForm
	"Create a StandardSystemView for a FormEditor on the form aForm."

	| formView formEditor menuView aView topView extent topViewBorder |
	topViewBorder _ 2.
	formView _ FormHolderView new model: aForm.
	formEditor _ formView controller.
	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.
	formEditor model: aForm.
	aView _ View new.
	aView model: aForm.
	aView addSubView: formView.
	aView 
		addSubView: menuView
		align: menuView viewport topCenter
		with: formView viewport bottomCenter + (0@16).
	aView window: 
		((formView viewport 
			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 
		  expandBy: (0@topViewBorder corner: 0@0)).
	aView window extent > formView viewport extent
		ifTrue: [formView borderWidthLeft: 1 right: 1 top: 0 bottom: 1]
		ifFalse: [formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1].
	topView _ ColorSystemView new.
	topView backgroundColor: #veryLightGray.
	topView addSubView: aView.
	topView label: 'Form Editor'.
	topView borderWidth: topViewBorder.
	extent _ topView viewport extent.
	topView minimumSize: extent.
	topView maximumSize: extent.
	^topView! !

FormSetFont comment:
'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font.  The TextAttribute subclass TextFontReference is specifically designed for such in-line insertion of exceptional fonts in normal text.'!
!FormSetFont methodsFor: 'as yet unclassified'!
fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal
	| height width x badChar |
	type _ 2.
	name _ 'aFormFont'.
	minAscii _ asciiStart.
	maxAscii _ minAscii + formArray size - 1.
	ascent _ ascentVal.
	subscript _ superscript _ emphasis _ 0.
	height _ width _ 0.
	maxWidth _ 0.
	formArray do:
		[:f | width _ width + f width.
		maxWidth _ maxWidth max: f width.
		height _ height max: f height + f offset y].
	badChar _ (Form extent: 7@height) borderWidth: 1.
	width _ width + badChar width.
	descent _ height - ascent.
	pointSize _ height.
	glyphs _ Form extent: width @ height depth: formArray first depth.
	xTable _ Array new: maxAscii + 3 withAll: 0.
	x _ 0.
	formArray doWithIndex:
		[:f :i | f displayOn: glyphs at: x@0.
		xTable at: minAscii + i+1 put: (x _ x + f width)].
	badChar displayOn: glyphs at: x@0.
	xTable at: maxAscii + 3 put: x + badChar width.
	self setStopConditions!
reset  "Ignored by FormSetFonts"! !
!FormSetFont class methodsFor: 'examples'!
copy: charForm toClipBoardAs: char ascent: ascent
	ParagraphEditor new clipboardTextPut:
		(Text string: char asString
			attribute: (TextFontReference toFont: 
				(FormSetFont new
					fromFormArray: (Array with: charForm)
					asciiStart: char asciiValue
					ascent: ascent)))
"
	The S in the Squeak welcome window was installed by doing the following
	in a workspace (where the value of, eg, charForm will persist through BitEdit...
	f _ TextStyle default fontAt: 4.
	oldS _ f characterFormAt: $S.
	charForm _ Form extent: oldS extent depth: 8.
	oldS displayOn: charForm.
	charForm bitEdit.
	...Play around with the BitEditor, then accept and close...
	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.
	...Then do a paste into the Welcome window
"!
example    "FormSetFont example"
	"Lets the user select a (small) area of the screen to represent the
	character A, then copies 'A' to the clipboard with that as the letter form.
	Thereafter, a paste operation will imbed that character in any text."
	| charForm |
	charForm _ Form fromUser.
	self copy: charForm toClipBoardAs: $A ascent: charForm height! !
!FormView methodsFor: 'displaying'!
displayOn: aPort
	model displayOnPort: aPort at: self displayBox origin!
displayView 
	"Refer to the comment in View|displayView."

	| oldOffset |
	super displayView.
	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].
	oldOffset _ model offset.
	model offset: borderWidth origin "0@0".
	model
		displayOn: Display
		transformation: self displayTransformation
		clippingBox: self insetDisplayBox
		rule: self rule
		fillColor: self fillColor.
	model offset: oldOffset!
updateDisplay
	"overridden by subclass"! !
!FormView class methodsFor: 'examples'!
open: aForm named: aString
	"FormView open: (GIFReadWriter imageFromFileNamed: 'TylerCrop.GIF')
named: 'Squeak' "
	"Answer a scheduled view whose model is aForm and whose label is
aString. 12/11/96 tk"
	| topView aView |
	topView _ ColorSystemView new.
	topView model: aForm.
	topView label: aString.
	topView minimumSize: 80@80.
	aView _ FormView new.
	aView model: aForm.
	aView window: (0 @ 0 extent: aForm extent + (4@4)).
		"compensate for borders.  Should be window:viewport:"
	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
	topView addSubView: aView.
	topView controller open! !
!Fraction methodsFor: 'arithmetic'!
* aFraction
	"Answer the result of multiplying the receiver by aFraction."

	(aFraction isMemberOf: Fraction)
		ifTrue: [^ (Fraction 
					numerator: numerator * aFraction numerator
					denominator: denominator * aFraction denominator)
					reduced]
		ifFalse: [^ self retry: #* coercing: aFraction]!
+ aFraction
	"Answer the sum of the receiver and aFraction."

	| commonDenominator newNumerator |
	(aFraction isMemberOf: Fraction)
		ifTrue: 
			[denominator = aFraction denominator ifTrue: [
				^ (Fraction 
					numerator: numerator + aFraction numerator
					denominator: denominator) reduced].
			commonDenominator _ denominator lcm: aFraction denominator.
			newNumerator _
				(numerator * (commonDenominator / denominator)) +
				(aFraction numerator * (commonDenominator / aFraction denominator)).
			^ (Fraction 
				numerator: newNumerator 
				denominator: commonDenominator) reduced]
		ifFalse: [^ self retry: #+ coercing: aFraction]!
- aFraction
	"Answer the difference between the receiver and aFraction."

	(aFraction isMemberOf: Fraction)
		ifTrue: [^ self + aFraction negated]
		ifFalse: [^ self retry: #- coercing: aFraction]!
/ aFraction
	"Answer the result of dividing the receiver by aFraction."

	(aFraction isMemberOf: Fraction)
		ifTrue: [^self * aFraction reciprocal]
		ifFalse: [^self retry: #/ coercing: aFraction]!
negated 
	"Refer to the comment in Number|negated."

	^ Fraction
		numerator: numerator negated
		denominator: denominator! !

HierarchicalMenu comment:
'Created by Dan Ingalls back in 1985-6, but not currently maintained or used.'!
!HierarchyBrowser methodsFor: 'initialization'!
classList
	^ classList!
classListIndex: newIndex
	"Cause system organization to reflect appropriate category"
	| newClassName |
	newIndex ~= 0 ifTrue:
		[newClassName _ (classList at: newIndex) copyWithout: $ .
		systemCategoryListIndex _
			systemOrganizer numberOfCategoryOfElement: newClassName.
		self changed: #systemCategorySelectionChanged].
	^ super classListIndex: newIndex!
initAlphabeticListing
	| tab stab index |
	self systemOrganizer: SystemOrganization.
	metaClassIndicated _ false.
	classList _ Smalltalk classNames.!
initForClassList: classNames
	"Initialize the receiver for use with the provided list of class names.   11/27/96 sw"

	self systemOrganizer: SystemOrganization.
	metaClassIndicated _ false.
	classList _ classNames!
initHierarchyForClass: theClass meta: meta
	| tab stab index |
	self systemOrganizer: SystemOrganization.
	metaClassIndicated _ meta.
	classList _ OrderedCollection new.
	tab _ ''.
	theClass allSuperclasses reverseDo: 
		[:aClass | 
		classList add: tab , aClass name.
		tab _ tab , '  '].
	index _ classList size + 1.
	theClass allSubclassesWithLevelDo:
		[:aClass :level |
		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].
		classList add: tab , stab , aClass name]
	 	startingLevel: 0.
	self classListIndex: index!
selectClass: classNotMeta
	| name |
	name _ classNotMeta name.
	self classListIndex: (self classList findFirst:
			[:each | (each endsWith: name)
					and: [each size = name size
							or: [(each at: each size - name size) isSeparator]]])!
selectedClassName
	"Answer the name of the class currently selected.   di
	 12/4/96 sw bug fix for the case where name cannot be found -- return nil rather than halt"

	| aName |
	aName _ super selectedClassName.
	^ aName == nil
		ifTrue:
			[aName]
		ifFalse:
			[(aName copyWithout: $ ) asSymbol]! !
!InfiniteForm methodsFor: 'displaying'!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm
	"This is the real display message, but it doesn't get used until the new
	display protocol is installed."
	| targetBox patternBox bb |
	(patternForm class == Pattern) ifTrue:
			["Use patternForm as a mask for BitBlt"
			aDisplayMedium fill: clipRectangle 
				rule: ruleInteger fillColor: patternForm.
			^ self].
	(patternForm isKindOf: Form) ifFalse:
			["A Color-like thing.  Use patternForm as a mask for BitBlt"
			aDisplayMedium fill: clipRectangle 
				rule: ruleInteger fillColor: patternForm.
			^ self].
	"Do it iteratively"
	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.
	patternBox _ patternForm boundingBox.
	bb _ BitBlt destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm
		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0
		extent: patternBox extent clipRect: clipRectangle.
	(targetBox left truncateTo: patternBox width)
		to: targetBox right - 1 by: patternBox width do:
		[:x |
		(targetBox top truncateTo: patternBox height)
			to: targetBox bottom - 1 by: patternBox height do:
			[:y |
			bb destOrigin: x@y; copyBits]]!
displayOnPort: aPort at: aDisplayPoint
	| targetBox patternBox |
	(patternForm class == Pattern) ifTrue:
			["Use patternForm as a mask for BitBlt"
			aPort fill: aPort clipRect fillColor: patternForm rule: Form over.
			^ self].
	(patternForm isKindOf: Form) ifFalse:
			["A Color-like thing.  Use patternForm as a mask for BitBlt"
			aPort fill: aPort clipRect fillColor: patternForm rule: Form over.
			^ self].
	"Do it iteratively"
	targetBox _ aPort clipRect.
	patternBox _ patternForm boundingBox.
	aPort sourceForm: patternForm;
		combinationRule: Form over;
		sourceRect: (0@0 extent: patternBox extent).
	(targetBox left truncateTo: patternBox width)
		to: targetBox right - 1 by: patternBox width do:
		[:x |
		(targetBox top truncateTo: patternBox height)
			to: targetBox bottom - 1 by: patternBox height do:
			[:y |
			aPort destOrigin: x@y; copyBits]]! !
!InputSensor methodsFor: 'joystick'!
joystickOn: index

	^ (((self primReadJoystick: index) bitShift: -27) bitAnd: 1) ~= 0
	! !
!InspectListController methodsFor: 'menu messages'!
objectReferencesToSelection
	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  9/27/96 sw"

	model selectionIndex == 0 ifTrue: [^ view flash].
	self controlTerminate.
	Smalltalk
		browseAllObjectReferencesTo: model selection
		except: (Array with: model object)
		ifNone: [:obj | view topView flash].
! !
!InspectListController class methodsFor: 'class initialization'!
initialize
	"Initialize the menu associated with the upper-left pane of an Inspector.  1/25/96 sw: added references and browse items
	 9/27/96 sw: added object refs"

	InspectListYellowButtonMenu _ PopUpMenu labels: 'inspect
method refs to this inst var
objects pointing to this value
browse full
browse class'
	lines: #(1 3).
	InspectListYellowButtonMessages _ 
		#(inspectSelection referencesToSelection objectReferencesToSelection browseFull browseClass )

	"InspectListController initialize"! !
!Inspector methodsFor: 'accessing'!
initialExtent
	"Answer the desired extent for the receiver when it is first opened on the screen.  5/22/96 sw"

	^ 250 @ 200! !
!Inspector class methodsFor: 'instance creation'!
openOn: anObject withEvalPane: withEval 
	"Create and schedule an instance of me on the model, anInspector. "

	^ self openOn: anObject withEvalPane: withEval withLabel: anObject class name!
openOn: anObject withEvalPane: withEval withLabel: label
	^ self openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: InspectCodeView
!
openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass
	| topView inspector listView valueView evalView |
	inspector _ self inspect: anObject.
	topView _ StandardSystemView new model: inspector.

	listView _ InspectListView new model: inspector.
		(inspector isMemberOf: DictionaryInspector)
			ifTrue: [listView controller: DictionaryListController new].
		listView window: (0 @ 0 extent: 40 @ 40).
		listView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.
		topView addSubView: listView.
	valueView _ valueViewClass new model: inspector.
		valueView window: (0 @ 0 extent: 75 @ 40).
		valueView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
		topView addSubView: valueView toRightOf: listView.
withEval ifTrue:
	[evalView _ StringHolderView new
					model: (InspectorTrash for: inspector object).
		evalView window: (0 @ 0 extent: 115 @ 20).
		evalView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.
		topView addSubView: evalView below: listView].
	topView label: label.
	topView minimumSize: 180 @ 120.
	topView controller open! !
!InstructionStream methodsFor: 'scanning'!
addSelectorTo: set 
	"If this instruction is a send, add its selector to set."

	| byte literalNumber byte2 |
	byte _ self method at: pc.
	byte < 128 ifTrue: [^self].
	byte >= 176
		ifTrue: 
			["special byte or short send"
			byte >= 208
				ifTrue: [set add: (self method literalAt: (byte bitAnd: 15) + 1)]
				ifFalse: [set add: (Smalltalk specialSelectorAt: byte - 176 + 1)]]
		ifFalse: 
			[(byte between: 131 and: 134)
				ifTrue: 
					[byte2 _ self method at: pc + 1.
					byte = 131 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].
					byte = 132 ifTrue: [byte2 < 64 ifTrue: [set add: (self method literalAt: (self method at: pc + 2) + 1)]].
					byte = 133 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].
					byte = 134 ifTrue: [set add: (self method literalAt: byte2 \\ 64 + 1)]]]!
scanFor: scanBlock 
	"Answer the index of the first bytecode for which scanBlock answer true 
	when supplied with that bytecode."

	| method end byte type |
	method _ self method.
	end _ method endPC.
	[pc <= end]
		whileTrue: 
			[(scanBlock value: (byte _ method at: pc)) ifTrue: [^true].
			type _ byte // 16.
			pc _ 
				type = 8
					ifTrue: ["extensions"
							pc + (#(2 2 2 2 3 2 2 1 1 1 ) at: byte \\ 16 + 1)]
					ifFalse: [type = 10
								ifTrue: [pc + 2"long jumps"]
								ifFalse: [pc + 1]]].
	^false!
thirdByte
	"Answer the next bytecode."

	^self method at: pc + 2! !
!InstructionStream methodsFor: 'private'!
interpretExtension: offset in: method for: client
	| type offset2 byte2 byte3 |
	offset <=6 ifTrue: 
		["Extended op codes 128-134"
		byte2 _ method at: pc.
		pc _ pc + 1.
		offset <= 2 ifTrue:
			["128-130:  extended pushes and pops"
			type _ byte2 // 64.
			offset2 _ byte2 \\ 64.
			offset = 0 ifTrue: 
				[type = 0 ifTrue: [^ client pushReceiverVariable: offset2].
				type = 1 ifTrue: [^ client pushTemporaryVariable: offset2].
				type = 2  ifTrue: [^ client pushConstant: (method literalAt: offset2 + 1)].
				type = 3 ifTrue: [^ client pushLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 1 ifTrue: 
				[type = 0 ifTrue: [^ client storeIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^ client storeIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 2 ifTrue: 
				[type = 0 ifTrue: [^ client popIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^ client popIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3  ifTrue: [^ client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].
		"131-134: extended sends"
		offset = 3 ifTrue:  "Single extended send"
			[^ client send: (method literalAt: byte2 \\ 32 + 1)
					super: false numArgs: byte2 // 32].
		offset = 4 ifTrue:    "Double extended do-anything"
			[byte3 _ method at: pc.  pc _ pc + 1.
			type _ byte2 // 32.
			type = 0 ifTrue: [^ client send: (method literalAt: byte3 + 1)
									super: false numArgs: byte2 \\ 32].
			type = 1 ifTrue: [^ client send: (method literalAt: byte3 + 1)
									super: true numArgs: byte2 \\ 32].
			type = 2 ifTrue: [^ client pushReceiverVariable: byte3].
			type = 3 ifTrue: [^ client pushConstant: (method literalAt: byte3 + 1)].
			type = 4 ifTrue: [^ client pushLiteralVariable: (method literalAt: byte3 + 1)].
			type = 5 ifTrue: [^ client storeIntoReceiverVariable: byte3].
			type = 6 ifTrue: [^ client popIntoReceiverVariable: byte3].
			type = 7 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].
		offset = 5 ifTrue:  "Single extended send to super"
			[^ client send: (method literalAt: byte2 \\ 32 + 1)
					super: true numArgs: byte2 // 32].
		offset = 6 ifTrue:   "Second extended send"
			[^ client send: (method literalAt: byte2 \\ 64 + 1)
					super: false numArgs: byte2 // 64]].
	offset = 7 ifTrue: [^ client doPop].
	offset = 8 ifTrue: [^ client doDup].
	offset = 9 ifTrue: [^ client pushActiveContext].
	self error: 'unusedBytecode'! !
!Integer methodsFor: 'testing'!
benchFib  "Handy send-heavy benchmark"
	"(result // seconds to run) = approx calls per second"
	" | r t | t _ Time millisecondsToRun: [r _ 26 benchFib].
			r//t*1000 "
	"138000 on a Mac 8100/100"
	^ self < 2
		ifTrue: [1] 
		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]!
benchmark  "Handy bytecode-heavy benchmark"
	"(500000 // time to run) = approx bytecodes per second"
	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"
	"3059000 on a Mac 8100/100"
    | size flags prime k count |
    size _ 8190.
    1 to: self do:
        [:iter |
        count _ 0.
        flags _ (Array new: size) atAllPut: true.
        1 to: size do:
            [:i | (flags at: i) ifTrue:
                [prime _ i+1.
                k _ i + prime.
                [k <= size] whileTrue:
                    [flags at: k put: false.
                    k _ k + prime].
                count _ count + 1]]].
    ^ count! !
!Integer methodsFor: 'mathematical functions'!
degreeCos
	"Answer the cosine of the receiver taken as an angle in degrees."

	^ (90 + self) degreeSin!
degreeSin
	"Answer the sine of the receiver taken as an angle in degrees."

	^ self asFloat degreesToRadians sin! !
!Integer methodsFor: 'private'!
digitDiv: arg neg: ng 
	"Answer with an array of (quotient, remainder)."
	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |
	l _ self digitLength - arg digitLength + 1.
	l <= 0 ifTrue: [^Array with: 0 with: self].
	d _ 8 - arg lastDigit highBit.
	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.
	"shifts so high order word is >=128"
	rem _ self digitLshift: d.
	rem digitLength = self digitLength ifTrue:
		[rem _ rem growto: self digitLength + 1].
	"makes a copy and shifts"
	quo _ Integer new: l neg: ng.
	dl _ div digitLength - 1.
	"Last actual byte of data"
	ql _ l.
	dh _ div digitAt: dl.
	dnh _
		 dl = 1
			ifTrue: [0]
			ifFalse: [div digitAt: dl - 1].
	1 to: ql do: 
		[:k | 
		"maintain quo*arg+rem=self"
		"Estimate rem/div by dividing the leading to bytes of rem by dh."
		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."
		j _ rem digitLength + 1 - k.
		"r1 _ rem digitAt: j."
		(rem digitAt: j) = dh
			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]
			ifFalse: 
				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  
				Note that r1,r2 are bytes, not nibbles.  
				Be careful not to generate intermediate results exceeding 13 bits."
				"r2 _ (rem digitAt: j - 1)."
				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).
				qhi _ t // dh.
				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).
				qlo _ t // dh.
				t _ t \\ dh.
				"Next compute (hi,lo) _ q*dnh"
				hi _ qhi * dnh.
				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).
				hi _ (hi bitShift: -4) + (lo bitShift: -8).
				lo _ lo bitAnd: 255.
				"Correct overestimate of q.  
				Max of 2 iterations through loop -- see Knuth vol. 2"
				r3 _ 
					j < 3 ifTrue: [0]
						 ifFalse: [rem digitAt: j - 2].
				[(t < hi or: [t = hi and: [r3 < lo]]) and: 
						["i.e. (t,r3) < (hi,lo)"
						qlo _ qlo - 1.
						lo _ lo - dnh.
						lo < 0
							ifTrue: 
								[hi _ hi - 1.
								lo _ lo + 256].
						hi >= dh]]
					whileTrue: [hi _ hi - dh].
				qlo < 0
					ifTrue: 
						[qhi _ qhi - 1.
						qlo _ qlo + 16]].
		"Subtract q*div from rem"
		l _ j - dl.
		a _ 0.
		1 to: div digitLength do: 
			[:i | 
			hi _ (div digitAt: i) * qhi.
			lo _ 
				a + (rem digitAt: l) 
					- ((hi bitAnd: 15) bitShift: 4) 
					- ((div digitAt: i) * qlo).
			rem digitAt: l put: (lo bitAnd: 255).
			a _ (lo bitShift: -8) - (hi bitShift: -4).
			l _ l + 1].
		a < 0
			ifTrue: 
				["Add div back into rem, decrease q by 1"
				qlo _ qlo - 1.
				l _ j - dl.
				a _ 0.
				1 to: div digitLength do: 
					[:i | 
					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).
					rem digitAt: l put: (a bitAnd: 255).
					l _ l + 1]].
		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].
	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.
	^Array with: quo with: rem!
digitLogic: arg op: op length: len
	| result neg1 neg2 rneg z1 z2 rz b1 b2 b |
	neg1 _ self negative.
	neg2 _ arg negative.
	rneg _ 
		((neg1 ifTrue: [-1] ifFalse: [0])
			perform: op 
			with: (neg2
					ifTrue: [-1]
					ifFalse: [0])) < 0.
	result _ Integer new: len neg: rneg.
	rz _ z1 _ z2 _ true.
	1 to: result digitLength do: 
		[:i | 
		b1 _ self digitAt: i.
		neg1 
			ifTrue: [b1 _ z1
						ifTrue: [b1 = 0
									ifTrue: [0]
									ifFalse: 
										[z1 _ false.
										256 - b1]]
						ifFalse: [255 - b1]].
		b2 _ arg digitAt: i.
		neg2 
			ifTrue: [b2 _ z2
						ifTrue: [b2 = 0
									ifTrue: [0]
									ifFalse: 
										[z2 _ false.
										256 - b2]]
						ifFalse: [255 - b2]].
		b _ b1 perform: op with: b2.
		b = 0
			ifTrue: 
				[result digitAt: i put: 0]
			ifFalse: 
				[result 
					digitAt: i 
					put: (rneg
							ifTrue: [rz ifTrue: 
											[rz _ false.
											256 - b]
										ifFalse: [255 - b]]
						ifFalse: [b])]].
	^ result normalize!
digitMultiply: arg neg: ng
	| prod prodLen carry digit k ab |
	(arg digitLength = 1 and: [(arg digitAt: 1) = 0]) ifTrue: [^ 0].
	prodLen _ self digitLength + arg digitLength.
	prod _ Integer new: prodLen neg: ng.
	"prod starts out all zero"
	1 to: self digitLength do: 
		[:i | 
		(digit _ self digitAt: i) ~= 0
			ifTrue: 
				[k _ i.
				carry _ 0.
				"Loop invariant: 0<=carry<=0377, k=i+j-1"
				1 to: arg digitLength do: 
					[:j | 
					ab _ ((arg digitAt: j) * digit) + carry
							+ (prod digitAt: k).
					carry _ ab bitShift: -8.
					prod digitAt: k put: (ab bitAnd: 255).
					k _ k + 1].
				prod digitAt: k put: carry]].
	^ prod normalize!
digitRshift: anInteger bytes: b lookfirst: a 
	 "Shift right 8*b+anInteger bits, 0<=n<8.
	Discard all digits beyond a, and all zeroes at or below a."
	| n x r f m digit count i |
	n _ 0 - anInteger.
	x _ 0.
	f _ n + 8.
	i _ a.
	m _ 255 bitShift: 0 - f.
	digit _ self digitAt: i.
	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:
		[x _ digit bitShift: f "Can't exceed 8 bits".
		i _ i - 1.
		digit _ self digitAt: i].
	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"
	r _ Integer new: i - b neg: self negative.
	count _ i.
	x _ (self digitAt: b + 1) bitShift: n.
	b + 1 to: count do:
		[:j | digit _ self digitAt: j + 1.
		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 
			"Avoid values > 8 bits".
		x _ digit bitShift: n].
	^r! !

Interpreter comment:
'This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.

It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.

In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.'!
!Interpreter methodsFor: 'initialization'!
initializeInterpreter: bytesToShift
	"Initialize Interpreter state before starting execution of a new image."

	self initializeObjectMemory: bytesToShift.

	activeContext	_ nilObj.
	theHomeContext	_ nilObj.
	method			_ nilObj.
	receiver			_ nilObj.
	messageSelector	_ nilObj.
	newMethod		_ nilObj.

	self flushMethodCache.
	self loadInitialContext.
	interruptCheckCounter _ 0.
	nextPollTick _ 0.
	nextWakeupTick _ 0.
	interruptKeycode _ 2094.  "cmd-."
	interruptPending _ false.
!
loadInitialContext

	| sched proc |
	sched _ self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).
	proc _ self fetchPointer: ActiveProcessIndex ofObject: sched.
	activeContext _ self fetchPointer: SuspendedContextIndex ofObject: proc.
	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].
	self fetchContextRegisters: activeContext.
	reclaimableContextCount _ 0.! !
!Interpreter methodsFor: 'utilities'!
areIntegers: oop1 and: oop2

	^ ((oop1 bitAnd: oop2) bitAnd: 1) ~= 0!
arrayValueOf: arrayOop
	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."
	"Note: May be called by translated primitive code."

	self returnTypeC: 'void *'.
	((self isIntegerObject: arrayOop) not and:
	 [self isWordsOrBytes: arrayOop]) ifTrue: [
		^ self cCode: '(void *) (arrayOop + 4)'
	].
	self primitiveFail.!
assertClassOf: oop is: classOop
	"Succeed if the given (non-integer) object is an instance of the given class. Fail if the object is an integer."

	| ccIndex cl |
	(self isIntegerObject: oop)
		ifTrue: [ successFlag _ false. ^ nil ].

	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.
	ccIndex = 0
		ifTrue: [ cl _ ((self classHeader: oop) bitAnd: AllButTypeMask) ]
		ifFalse: [
			"look up compact class"
			cl _ (self fetchPointer: (ccIndex - 1)
					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop))].

	self success: cl = classOop.
!
assertFloat: oop1 and: oop2
	"Fail unless both arguments are floats."

	| floatClass |
	((oop1 bitOr: oop2) bitAnd: 1) ~= 0 ifTrue: [
		successFlag _ false.
	] ifFalse: [
		floatClass _ self splObj: ClassFloat.
		self assertClassOf: oop1 is: floatClass.
		self assertClassOf: oop2 is: floatClass.
	].!
booleanCheat: cond

	| peek |
	peek _ self fetchByte.  "peek ahead for jumpIfFalse (99%)"
	(peek >= 152 and: [peek <= 159]) ifTrue: [  "short jumpIfFalse"
		self internalPop: 2.
		cond ifFalse: [ ^ self jump: peek - 151 ].
		^ nil
	].
	peek = 172 ifTrue: [  "long jumpIfFalse"
		self internalPop: 2.
		cond ifFalse: [ ^ self jump: self fetchByte ].
		^ self jump: 1
	].

	"was not followed by a jumpIfFalse; just leave boolean result on the stack"
	localIP _ localIP - 1.
	cond
		ifTrue: [ self longAt: (localSP _ localSP - 4) put: trueObj ]
		ifFalse: [ self longAt: (localSP _ localSP - 4) put: falseObj ].
!
booleanValueOf: obj

	obj = trueObj ifTrue: [ ^ true ].
	obj = falseObj ifTrue: [ ^ false ].
	successFlag _ false.
	^ nil!
checkedIntegerValueOf: intOop
	"Note: May be called by translated primitive code."

	(self isIntegerObject: intOop)
		ifTrue: [ ^ self integerValueOf: intOop ]
		ifFalse: [ self primitiveFail. ^ 0 ]!
externalizeIPandSP
	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."

	instructionPointer _ localIP.
	stackPointer _ localSP.!
fetchArray: fieldIndex ofObject: objectPointer
	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."
	"Note: May be called by translated primitive code."

	| arrayOop |
	self returnTypeC: 'void *'.
	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.
	^ self arrayValueOf: arrayOop!
fetchFloat: fieldIndex ofObject: objectPointer
	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."
	"Note: May be called by translated primitive code."

	| floatOop |
	self returnTypeC: 'double'.
	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.
	^ self floatValueOf: floatOop!
fetchInteger: fieldIndex ofObject: objectPointer
	"Note: May be called by translated primitive code."

	| intOop |
	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.
	(self isIntegerObject: intOop)
		ifTrue: [ ^ self integerValueOf: intOop ]
		ifFalse: [ self primitiveFail. ^ 0 ]!
floatValueOf: oop
	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."
	"Note: May be called by translated primitive code."

	| result |
	self returnTypeC: 'double'.
	self var: #result declareC: 'double result'.
	self assertClassOf: oop is: (self splObj: ClassFloat).
	successFlag
		ifTrue: [self fetchFloatAt: oop + BaseHeaderSize into: result]
		ifFalse: [result _ 0.0].
	^ result!
internalizeIPandSP
	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."

	localIP _ instructionPointer.
	localSP _ stackPointer.!
makePointwithxValue: xValue yValue: yValue

	| pointResult |
	pointResult _ self instantiateSmallClass: (self splObj: ClassPoint)
							   sizeInBytes: 12
									   fill: nilObj.
	self storePointer: XIndex ofObject: pointResult withValue: (self integerObjectOf: xValue).
	self storePointer: YIndex ofObject: pointResult withValue: (self integerObjectOf: yValue).
	^ pointResult!
quickFetchInteger: fieldIndex ofObject: objectPointer
	"Return the integer value of the field without verifying that it is an integer value!! For use in time-critical places where the integer-ness of the field can be guaranteed."

	^ self integerValueOf:
		(self fetchPointer: fieldIndex ofObject: objectPointer).!
signExtend16: int16
	"Convert a signed 16-bit integer into a signed 32-bit integer value. The integer bit is not added here."

	(int16 bitAnd: 16r8000) = 0
		ifTrue: [ ^ int16 ]
		ifFalse: [ ^ int16 - 16r10000 ].!
storeInteger: fieldIndex ofObject: objectPointer withValue: integerValue
	"Note: May be called by translated primitive code."

	(self isIntegerValue: integerValue) ifTrue: [
		self storeWord: fieldIndex
			ofObject: objectPointer
			withValue: (self integerObjectOf: integerValue).
	] ifFalse: [
		self primitiveFail
	].!
transfer: count
	fromIndex: firstFrom ofObject: fromOop
	toIndex: firstTo ofObject: toOop
	"Assume: beRootIfOld: will be called on toOop."

	| fromIndex toIndex lastFrom |
	fromIndex _ fromOop + (firstFrom * 4).
	toIndex _ toOop + (firstTo * 4).
	lastFrom _ fromIndex + (count * 4).
	[fromIndex < lastFrom] whileTrue: [
		fromIndex _ fromIndex + 4.
		toIndex _ toIndex + 4.
		self longAt: toIndex put: (self longAt: fromIndex).
	].! !
!Interpreter methodsFor: 'object memory support'!
mapInterpreterOops
	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."
	"Assume: All traced variables contain valid oops."

	| oop |
	nilObj				_ self remap: nilObj.
	falseObj				_ self remap: falseObj.
	trueObj				_ self remap: trueObj.
	specialObjectsOop	_ self remap: specialObjectsOop.

	stackPointer 		_ stackPointer - activeContext.	"*rel to active"
	activeContext		_ self remap: activeContext.
	stackPointer 		_ stackPointer + activeContext.	"*rel to active"
	theHomeContext		_ self remap: theHomeContext.
	instructionPointer 	_ instructionPointer - method.	"*rel to method"
	method				_ self remap: method.
	instructionPointer 	_ instructionPointer + method.	"*rel to method"
	receiver				_ self remap: receiver.
	messageSelector		_ self remap: messageSelector.
	newMethod			_ self remap: newMethod.

	1 to: remapBufferCount do: [ :i |
		oop _ remapBuffer at: i.
		(self isIntegerObject: oop) ifFalse: [
			remapBuffer at: i put: (self remap: oop).
		].
	].

	"The method cache uses oops as hashes -- toss the whole thing."
	self flushMethodCache.!
markAndTraceInterpreterOops
	"Mark and trace all oops in the interpreter's state."
	"Assume: All traced variables contain valid oops."
	| oop |
	self markAndTrace: specialObjectsOop.
		"also covers nilObj, trueObj, falseObj, and compact classes"

	self markAndTrace: activeContext.  "traces entire stack"
		"also covers theHomeContext, receiver, method"

	self markAndTrace: messageSelector.
	self markAndTrace: newMethod.

	1 to: remapBufferCount do: [ :i |
		oop _ remapBuffer at: i.
		(self isIntegerObject: oop) ifFalse: [
			self markAndTrace: oop.
		].
	].!
postGCAction
	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."

	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].
	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].
! !
!Interpreter methodsFor: 'compiled methods'!
argumentCountOf: methodPointer
	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r1F!
headerOf: methodPointer
	^self fetchPointer: HeaderIndex
		ofObject: methodPointer!
literal: offset
	^self literal: offset
		ofMethod: method!
literal: offset ofMethod: methodPointer
	^self fetchPointer: offset + LiteralStart
		ofObject: methodPointer!
literalCountOf: methodPointer
	^self literalCountOfHeader: (self headerOf: methodPointer)!
literalCountOfHeader: headerPointer
	^ (headerPointer >> 10) bitAnd: 16rFF!
methodClassOf: methodPointer
	| literalCount association |
	literalCount _ self literalCountOf: methodPointer.
	association _ self literal: literalCount - 1
				ofMethod: methodPointer.
	^self fetchPointer: ValueIndex
		ofObject: association!
primitiveIndexOf: methodPointer
	^ ((self headerOf: methodPointer) >> 1) bitAnd: 16r1FF!
primitiveNewMethod
	| header bytecodeCount class size theMethod literalCount |
	header _ self popStack.
	bytecodeCount _ self popInteger.
	self success: (self isIntegerObject: header).
	successFlag ifFalse: [self unPop: 2].
	class _ self popStack.
	size _ (self literalCountOfHeader: header) + 1 * 4 + bytecodeCount.
	theMethod _ self instantiateClass: class indexableSize: size.
	self storePointer: HeaderIndex ofObject: theMethod withValue: header.
	literalCount _ self literalCountOfHeader: header.
	1 to: literalCount do:
		[:i | self storePointer: i ofObject: theMethod withValue: nilObj].
	self push: theMethod! !
!Interpreter methodsFor: 'contexts'!
argumentCountOfBlock: blockPointer

	| argCount |
	argCount _ self fetchPointer: BlockArgumentCountIndex
							ofObject: blockPointer.
	(self isIntegerObject: argCount)
		ifTrue: [ ^ self integerValueOf: argCount ]
		ifFalse: [ self primitiveFail. ^0 ].!
caller
	^self fetchPointer: SenderIndex
		ofObject: activeContext!
fetchContextRegisters: activeCntx
	"Note: internalFetchContextRegisters: should track changes to this method."

	| tmp |
	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.
	(self isIntegerObject: tmp) ifTrue: [
		"if the MethodIndex field is an integer, activeCntx is a block context"
		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.
		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].
	] ifFalse: [
		"otherwise, it is a method context and is its own home context"
		tmp _ activeCntx.
	].
	theHomeContext _ tmp.
	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.
	method _ self fetchPointer: MethodIndex ofObject: tmp.

	"the instruction pointer is a pointer variable equal to
		method oop + ip + BaseHeaderSize
		  -1 for 0-based addressing of fetchByte
		  -1 because it gets incremented BEFORE fetching currentByte"
	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.
	instructionPointer _ method + tmp + BaseHeaderSize - 2.

	"the stack pointer is a pointer variable also..."
	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.
	stackPointer _ activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4).!
internalFetchContextRegisters: activeCntx
	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."

	| tmp |
	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.
	(self isIntegerObject: tmp) ifTrue: [
		"if the MethodIndex field is an integer, activeCntx is a block context"
		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.
		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].
	] ifFalse: [
		"otherwise, it is a method context and is its own home context"
		tmp _ activeCntx.
	].
	theHomeContext _ tmp.
	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.
	method _ self fetchPointer: MethodIndex ofObject: tmp.

	"the instruction pointer is a pointer variable equal to
		method oop + ip + BaseHeaderSize
		  -1 for 0-based addressing of fetchByte
		  -1 because it gets incremented BEFORE fetching currentByte"
	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.
	localIP _ method + tmp + BaseHeaderSize - 2.

	"the stack pointer is a pointer variable also..."
	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.
	localSP _ activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4).!
internalPop: nItems

	localSP _ localSP - (nItems * 4).!
internalPush: object

	self longAt: (localSP _ localSP + 4) put: object.!
internalStackTop

	^ self longAt: localSP!
internalStackValue: offset

	^ self longAt: localSP - (offset * 4)!
localPop: nItems thenPush: oop

	self longAt: (localSP _ localSP - ((nItems - 1) * 4)) put: oop.
!
newActiveContext: aContext

	self storeContextRegisters: activeContext.
	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].
	activeContext _ aContext.
	self fetchContextRegisters: aContext.!
pop: nItems
	"Note: May be called by translated primitive code."

	stackPointer _ stackPointer - (nItems*4).!
pop: nItems thenPush: oop

	| sp |
	self longAt: (sp _ stackPointer - ((nItems - 1) * 4)) put: oop.
	stackPointer _ sp.
!
popInteger
	| integerPointer |
	integerPointer _ self popStack.
	(self isIntegerObject: integerPointer)
		ifTrue: [^ self integerValueOf: integerPointer]
		ifFalse: [successFlag _ false.
				^ 1  "in case need SOME integer prior to fail"]!
popPos32BitInteger
	"May set successFlag, and return false if not valid"

	| top |
	top _ self popStack.
	^ self positive32BitValueOf: top!
popStack

	| top |
	top _ self longAt: stackPointer.
	stackPointer _ stackPointer - 4.
	^ top!
push: object

	| sp |
	self longAt: (sp _ stackPointer + 4) put: object.
	stackPointer _ sp.!
pushBool: trueOrFalse

	trueOrFalse
		ifTrue: [ self push: trueObj ]
		ifFalse: [ self push: falseObj ].!
pushInteger: integerValue
	self push: (self integerObjectOf: integerValue).!
sender
	^self fetchPointer: SenderIndex
		ofObject: theHomeContext!
stackIntegerValue: offset
	| integerPointer |
	integerPointer _ self longAt: stackPointer - (offset*4).
	(self isIntegerObject: integerPointer)
		ifTrue: [ ^self integerValueOf: integerPointer ]
		ifFalse: [ self primitiveFail. ^0 ]!
stackPointerIndex
	"Return the 0-based index rel to the current context.
	(This is what stackPointer used to be before conversion to pointer"
	^ (stackPointer - activeContext - BaseHeaderSize) // 4!
stackTop
	^self longAt: stackPointer!
stackValue: offset
	^ self longAt: stackPointer - (offset*4)!
storeContextRegisters: activeCntx

	"InstructionPointer is a pointer variable equal to
	method oop + ip + BaseHeaderSize
		-1 for 0-based addressing of fetchByte
		-1 because it gets incremented BEFORE fetching currentByte"

	self storeWord: InstructionPointerIndex ofObject: activeCntx
		withValue: (self integerObjectOf: 
			(instructionPointer - method - (BaseHeaderSize - 2))).
	self storeWord: StackPointerIndex		  ofObject: activeCntx
		withValue: (self integerObjectOf:
			(self stackPointerIndex - TempFrameStart + 1)).
!
storeInstructionPointerValue: value inContext: contextPointer
	"Assume: value is an integerValue"

	self storeWord: InstructionPointerIndex
		ofObject: contextPointer
		withValue: (self integerObjectOf: value).!
storeStackPointerValue: value inContext: contextPointer
	"Assume: value is an integerValue"

	self storeWord: StackPointerIndex
		ofObject: contextPointer
		withValue: (self integerObjectOf: value).!
temporary: offset
	^self fetchPointer: offset + TempFrameStart
		ofObject: theHomeContext!
unPop: nItems
	stackPointer _ stackPointer + (nItems*4)! !
!Interpreter methodsFor: 'object format'!
fixedFieldsOf: instPointer
	| classPointer fmt |
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	When we revise the image format, it should become...
	^ (fmt >> 2 bitAnd: 16rFF) - 1
"
	classPointer _ self fetchClassOf: instPointer.
	fmt _ self formatOfClass: classPointer.
	^ (fmt >> 11 bitAnd: 16rC0) + (fmt >> 2 bitAnd: 16r3F) - 1!
formatOfClass: classPointer
	"**should be in-lined**"
	"Note that, in Smalltalk, the instSpec will be equal to the inst spec
	part of the base header of an instance (without hdr type) shifted left 1.
	In this way, apart from the smallInt bit, the bits
	are just where you want them for the first header word."
	"Callers expect low 2 bits (header type) to be zero!!"

	^ (self fetchPointer: InstanceSpecificationIndex ofObject: classPointer) - 1! !
!Interpreter methodsFor: 'message sending'!
activateNewMethod

	| methodHeader smallContext newContext initialIP tempCount i contextEnd nilOop |
	methodHeader _ self headerOf: newMethod.

	smallContext _ ((methodHeader >> 18) bitAnd: 1) = 0.
	newContext _ self allocateOrRecycleContext: smallContext.

	initialIP _
		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.
	tempCount _
		(methodHeader >> 19) bitAnd: 16r3F.

	"Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores."

	self storePointerUnchecked: SenderIndex	ofObject: newContext
		withValue: activeContext.
	self storeWord: InstructionPointerIndex	ofObject: newContext
		withValue: (self integerObjectOf: initialIP).
	self storeWord: StackPointerIndex			ofObject: newContext
		withValue: (self integerObjectOf: tempCount).
	self storePointerUnchecked: MethodIndex ofObject: newContext
		withValue: newMethod.

	self transfer: argumentCount + 1
		fromIndex: self stackPointerIndex - argumentCount
		ofObject: activeContext
		toIndex: ReceiverIndex
		ofObject: newContext.

	"clear extra context fields to nil in case it is recycled"
	nilOop _ nilObj.
	i _ newContext + ((ReceiverIndex + argumentCount + 1) * 4).
	smallContext
		ifTrue: [ contextEnd _ newContext + SmallContextSize - BaseHeaderSize ]
		ifFalse: [ contextEnd _ newContext + LargeContextSize - BaseHeaderSize ].
	[i < contextEnd] whileTrue: [
		i _ i + 4.
		self longAt: i put: nilOop.
	].

	self pop: argumentCount + 1.
	reclaimableContextCount _ reclaimableContextCount + 1.
	self newActiveContext: newContext.!
argCount
	^ argumentCount!
createActualMessage

	| argumentArray message |
	argumentArray _
		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.

	"remap argumentArray in case GC happens during allocation"
	self pushRemappableOop: argumentArray.
	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.
	argumentArray _ self popRemappableOop.

	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].
	self storePointer: MessageSelectorIndex
		ofObject: message
		withValue: messageSelector.
	self storePointer: MessageArgumentsIndex
		ofObject: message
		withValue: argumentArray.
	self transfer: argumentCount
		fromIndex: self stackPointerIndex - (argumentCount - 1)
		ofObject: activeContext
		toIndex: 0
		ofObject: argumentArray.

	self pop: argumentCount.
	self push: message.
	argumentCount _ 1.!
executeNewMethod

	(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [
		"if not primitive, or primitive failed, activate the method"
		self activateNewMethod.

		"check for possible interrupts at each real send"
		self quickCheckForInterrupts.
	].
!
findNewMethodInClass: class
	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."

	| ok |
	ok _ self lookupInMethodCacheSel: messageSelector class: class.
	ok ifFalse: [
		"entry was not found in the cache; look it up the hard way"
		self lookupMethodInClass: class.
		primitiveIndex _ self primitiveIndexOf: newMethod.
		self addToMethodCacheSel: messageSelector
			class: class
			method: newMethod
			primIndex: primitiveIndex.
	].
!
lookupMethodInClass: class
	| currentClass dictionary |
	currentClass _ class.
	[currentClass~=nilObj] whileTrue:
		[dictionary _ self fetchPointer: MessageDictionaryIndex
					ofObject: currentClass.
		(self lookupMethodInDictionary: dictionary)
			ifTrue: [^ currentClass].
		currentClass _ self superclassOf: currentClass].
	messageSelector = (self splObj: SelectorDoesNotUnderstand)
		ifTrue: [self error: 'Recursive not understood error encountered'].
	self createActualMessage.
	messageSelector _ (self splObj: SelectorDoesNotUnderstand).
	^ self lookupMethodInClass: class!
lookupMethodInDictionary: dictionary
	"NOTE: This method has been converted to do an exhaustive search,
	since hashes will not be the same when we start up the new system.
	Unless the method cache is VERY effective, proper hashing will need
	to be reinstated here."
 	| length index mask wrapAround nextSelector methodArray |
	length _ self fetchWordLengthOf: dictionary.
	mask _ length - SelectorStart - 1.
	index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart.
	wrapAround _ false.
	[true] whileTrue:
		[nextSelector _ self fetchPointer: index
					ofObject: dictionary.
		nextSelector=nilObj ifTrue: [^false].
		nextSelector=messageSelector
			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex
							ofObject: dictionary.
				newMethod _ self fetchPointer:  index - SelectorStart
							ofObject: methodArray.
				primitiveIndex _ self primitiveIndexOf: newMethod.
				^true].
		index _ index + 1.
		index = length
			ifTrue: [wrapAround ifTrue: [^false].
				wrapAround _ true.
				index _ SelectorStart]]!
superclassOf: classPointer
	^self fetchPointer: SuperclassIndex
		ofObject: classPointer! !
!Interpreter methodsFor: 'method lookup cache'!
addToMethodCacheSel: selector class: class method: meth primIndex: primIndex
	"Add the given entry to the method cache."

	| probe |
	"select one of the CacheProbeMax possible entries for replacement..."
	mcProbe _ (mcProbe + 1) \\ CacheProbeMax.  "in range 0..CacheProbeMax-1"
	probe _ (((selector bitXor: class) >> (mcProbe + 2)) bitAnd: MethodCacheMask) + 1.

	"...and replace the entry at that probe addresses"
	methodCache at: probe put: selector.
	methodCache at: probe + MethodCacheEntries put: class.
	methodCache at: probe + (MethodCacheEntries * 2) put: meth.
	methodCache at: probe + (MethodCacheEntries * 3) put: primIndex.
!
flushMethodCache
	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."

	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].
	mcProbe _ 0.!
lookupInMethodCacheSel: selector class: class
	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."
	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."
	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."

	| hash probe |
	hash _ (selector bitXor: class) >> 2.  "shift drops two low-order zeros from addresses"
	probe _ (hash bitAnd: MethodCacheMask) + 1.  "initial probe"

	1 to: CacheProbeMax do: [ :p |
		(((methodCache at: probe) = selector) and:
		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue: [
			newMethod _ methodCache at: probe + (MethodCacheEntries * 2).
			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).
			^ true	"found entry in cache; done"
		].
		probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1
	].
	^ false
! !
!Interpreter methodsFor: 'interpreter shell'!
fetchByte
	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."

	^ self byteAt: localIP preIncrement!
getCurrentBytecode
	"currentBytecode will be private to the main dispatch loop in the generated code. This method allows the currentBytecode to be retrieved from global variables."

	^ self byteAt: instructionPointer!
interpret

	self internalizeIPandSP.
	[true] whileTrue: [
		currentBytecode _ self fetchByte.
		self dispatchOn: currentBytecode in: BytecodeTable.
	].
	self externalizeIPandSP.
!
unknownBytecode
	"This should never get called; it means that an unimplemented bytecode appears in a CompiledMethod."

	self error: 'Unknown bytecode'.! !
!Interpreter methodsFor: 'stack bytecodes'!
duplicateTopBytecode

	self internalPush: self internalStackTop.!
extendedPushBytecode

	| descriptor variableType variableIndex |
	descriptor _ self fetchByte.
	variableType _ (descriptor >> 6) bitAnd: 16r3.
	variableIndex _ descriptor bitAnd: 16r3F.
	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].
	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].
	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].
	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].!
extendedStoreAndPopBytecode

	self extendedStoreBytecode.
	self popStackBytecode.!
extendedStoreBytecode

	| descriptor variableType variableIndex association |
	descriptor _ self fetchByte.
	variableType _ (descriptor >> 6) bitAnd: 16r3.
	variableIndex _ descriptor bitAnd: 16r3F.
	variableType = 0 ifTrue:
		[^self storePointer: variableIndex
			ofObject: receiver
			withValue: self internalStackTop].
	variableType = 1 ifTrue:
		[^self storePointerUnchecked: variableIndex + TempFrameStart
			ofObject: theHomeContext
			withValue: self internalStackTop].
	variableType = 2 ifTrue:
		[self error: 'illegal store'].
	variableType = 3 ifTrue:
		[association _ self literal: variableIndex.
		^self storePointer: ValueIndex
			ofObject: association
			withValue: self internalStackTop].!
popStackBytecode

	self internalPop: 1.!
pushActiveContextBytecode
	"Puts reclaimability of this context in question."

	reclaimableContextCount _ 0.
	self internalPush: activeContext.!
pushConstantFalseBytecode

	self internalPush: falseObj.!
pushConstantMinusOneBytecode

	self internalPush: ConstMinusOne.!
pushConstantNilBytecode

	self internalPush: nilObj.!
pushConstantOneBytecode

	self internalPush: ConstOne.!
pushConstantTrueBytecode

	self internalPush: trueObj.!
pushConstantTwoBytecode

	self internalPush: ConstTwo.!
pushConstantZeroBytecode

	self internalPush: ConstZero.!
pushLiteralConstant: literalIndex

	self internalPush: (self literal: literalIndex).!
pushLiteralConstantBytecode

	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).!
pushLiteralVariable: literalIndex

	self internalPush:
		(self fetchPointer: ValueIndex ofObject: (self literal: literalIndex)).!
pushLiteralVariableBytecode

	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).!
pushReceiverBytecode

	self internalPush: receiver.!
pushReceiverVariable: fieldIndex

	self internalPush:
		(self fetchPointer: fieldIndex ofObject: receiver).!
pushReceiverVariableBytecode

	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).!
pushTemporaryVariable: temporaryIndex

	self internalPush: (self temporary: temporaryIndex).!
pushTemporaryVariableBytecode

	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).!
storeAndPopReceiverVariableBytecode

	self storePointer: (currentBytecode bitAnd: 7)
		ofObject: receiver
		withValue: self internalStackTop.
	self internalPop: 1.
!
storeAndPopTemporaryVariableBytecode

	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart
		ofObject: theHomeContext
		withValue: self internalStackTop.
	self internalPop: 1.
! !
!Interpreter methodsFor: 'jump bytecodes'!
jump: offset

	localIP _ localIP + offset.!
jumplfFalseBy: offset

	| boolean |
	boolean _ self internalStackTop.
	self internalPop: 1.
	boolean = falseObj ifTrue: [
		self jump: offset.
	] ifFalse: [
		boolean = trueObj ifFalse: [
			self externalizeIPandSP.
			self unPop: 1.
			self externalSendSelector: (self splObj: SelectorMustBeBoolean)
					 argumentCount: 0.
			self internalizeIPandSP.
		].
	].!
jumplfTrueBy: offset

	| boolean |
	boolean _ self internalStackTop.
	self internalPop: 1.
	boolean = trueObj ifTrue: [
		self jump: offset.
	] ifFalse: [
		boolean = falseObj ifFalse: [
			self externalizeIPandSP.
			self unPop: 1.
			self externalSendSelector: (self splObj: SelectorMustBeBoolean)
					 argumentCount: 0.
			self internalizeIPandSP.
		].
	].!
longJumpIfFalse

	self jumplfFalseBy:
		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!
longJumpIfTrue

	self jumplfTrueBy:
		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!
longUnconditionalJump

	| offset |
	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.
	localIP _ localIP + offset.
	offset < 0 ifTrue: [
		"backward jump means we're in a loop; check for possible interrupts"
		self internalQuickCheckForInterrupts.
	].!
shortConditionalJump

	self jumplfFalseBy: (currentBytecode bitAnd: 7) + 1.!
shortUnconditionalJump

	self jump: (currentBytecode bitAnd: 7) + 1.! !
!Interpreter methodsFor: 'send bytecodes'!
doubleExtendedDoAnythingBytecode
	"Replaces the Blue Book double-extended send [132], in which
	the first byte was wasted on 8 bits of argument count.
	Here we use 3 bits for the operation sub-type (opType),
	and the remaining 5 bits for argument count where needed.
	The last byte give access to 256 instVars or literals.
	See also secondExtendedSendBytecode"

	| byte2 byte3 opType top |
	byte2 _ self fetchByte.
	byte3 _ self fetchByte.
	opType _ byte2 >> 5.
	opType = 0 ifTrue: [
		"Note: Use non-inlined version of sendSelector:argumentCount:"
		self externalizeIPandSP.
		self externalSendSelector: (self literal: byte3) argumentCount: (byte2 bitAnd: 16r1F).
		self internalizeIPandSP.
		^ nil
	].
	opType = 1 ifTrue: [
		messageSelector _ self literal: byte3.
		argumentCount _ byte2 bitAnd: 16r1F.
		self externalizeIPandSP.
		self sendSelectorToClass: (self superclassOf: (self methodClassOf: method)).
		self internalizeIPandSP.
		^ nil
	].
	opType = 2 ifTrue: [ ^ self pushReceiverVariable: byte3 ].
	opType = 3 ifTrue: [ ^ self pushLiteralConstant: byte3 ].
	opType = 4 ifTrue: [ ^ self pushLiteralVariable: byte3 ].
	opType = 5 ifTrue: [
		^ self storePointer: byte3 ofObject: receiver withValue: self internalStackTop
	].
	opType = 6 ifTrue: [
		top _ self internalStackTop.
		self internalPop: 1.
		self storePointer: byte3 ofObject: receiver withValue: top.
		^ nil
	].
	opType = 7 ifTrue: [
		self storePointer: ValueIndex
			    ofObject: (self literal: byte3)
			 withValue: (self internalStackTop).
		^ nil
	].!
externalSendSelector: selector argumentCount: count
	"Note: Requires that instructionPointer and stackPointer be externalized."
	"Note: This version is NOT inlined, for use in uncommon cases (errors, etc.)."

	| rcvrClass |
	messageSelector _ selector.
	argumentCount _ count.
	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).
	self sendSelectorToClass: rcvrClass.!
internalSendSelector: selector argumentCount: count
	"Note: This method is inlined into the interpreter dispatch loop."

	| rcvrClass |
	messageSelector _ selector.
	argumentCount _ count.
	rcvrClass _ self fetchClassOf: (self internalStackValue: argumentCount).

	self externalizeIPandSP.
	self sendSelectorToClass: rcvrClass.
	self internalizeIPandSP.
!
secondExtendedSendBytecode
	"This replaces the Blue Book double-extended super-send [134],
	which is subsumed by the new double-extended do-anything [132].
	It offers a 2-byte send of 0-3 args for up to 63 literals, for which 
	the Blue Book opcode set requires a 3-byte instruction."
	| descriptor selectorIndex |
	descriptor _ self fetchByte.
	selectorIndex _ descriptor bitAnd: 16r3F.
	self internalSendSelector: (self literal: selectorIndex)
		argumentCount: (descriptor >> 6)!
sendLiteralSelectorBytecode

	| selector |
	selector _ self literal: (currentBytecode bitAnd: 16rF).
	self internalSendSelector: selector
		argumentCount: ((currentBytecode >> 4) bitAnd: 3) - 1.!
sendSelectorToClass: classPointer
	"Note: Requires that instructionPointer and stackPointer be externalized."

	self findNewMethodInClass: classPointer.
	self executeNewMethod.
!
singleExtendedSendBytecode
	| descriptor selectorIndex |
	descriptor _ self fetchByte.
	selectorIndex _ descriptor bitAnd: 16r1F.
	self internalSendSelector: (self literal: selectorIndex)
		argumentCount: (descriptor >> 5)!
singleExtendedSuperBytecode

	| descriptor selectorIndex |
	descriptor _ self fetchByte.
	argumentCount _ descriptor >> 5.
	selectorIndex _ descriptor bitAnd: 16r1F.
	messageSelector _ self literal: selectorIndex.

	self externalizeIPandSP.
	self sendSelectorToClass: (self superclassOf: (self methodClassOf: method)).
	self internalizeIPandSP.
! !
!Interpreter methodsFor: 'return bytecodes'!
returnFalse

	self returnValue: falseObj to: self sender.
!
returnNil

	self returnValue: nilObj to: self sender.
!
returnReceiver

	self returnValue: receiver to: self sender.
!
returnTopFromBlock
	"Return to the caller of the method containing the block."

	self returnValue: (self internalStackTop) to: (self caller).
!
returnTopFromMethod

	self returnValue: (self internalStackTop) to: (self sender).
!
returnTrue

	self returnValue: trueObj to: self sender.
!
returnValue: resultObj to: returnContext
	"Note: Assumed to be inlined into the dispatch loop."

	| nilOop thisCntx methodContextClass contextOfCaller |
	nilOop _ nilObj. "keep in a register"
	thisCntx _ activeContext.
	methodContextClass _ self splObj: ClassMethodContext.

	"make sure we can return to the given context"
	((returnContext = nilOop) or:
	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [
		"error: sender's instruction pointer or context is nil; cannot return"
		self internalPush: activeContext.
		self internalPush: resultObj.
		self externalizeIPandSP.
		self externalSendSelector: (self splObj: SelectorCannotReturn) argumentCount: 1.
		self internalizeIPandSP.
		^ nil
	].

	[thisCntx = returnContext] whileFalse: [
		"climb up stack to returnContext"
		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.

		"zap exited contexts so any future attempted use will be caught"
		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.
		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.

		reclaimableContextCount > 0 ifTrue: [
			"try to recycle this context"
			reclaimableContextCount _ reclaimableContextCount - 1.
			self recycleContextIfPossible: thisCntx methodContextClass: methodContextClass.
		].
		thisCntx _ contextOfCaller.
	].
	activeContext _ thisCntx.
	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].

	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"
	self internalPush: resultObj.
	self internalQuickCheckForInterrupts.
! !
!Interpreter methodsFor: 'common selector sends'!
bytecodePrimAdd

	| rcvr arg result |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).
		(self isIntegerValue: result) ifTrue: [
			self longAt: (localSP _ localSP - 4)
					put: (self integerObjectOf: result).
			^ nil
		].
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatAdd.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveAdd.
	].
	self internalizeIPandSP.
!
bytecodePrimAt
	"This version of at: is run directly from the special byteCode.
	It requires that its array be one of the 'ok' classes that will not
	attempt to redefine at:.  Otherwise it will fail and do a lookup"

	| arrayClass stringy |
	self externalizeIPandSP.
	successFlag _ true.
	arrayClass _ self fetchClassOf: (self stackValue: 1).
	stringy _ arrayClass = (self splObj: ClassString).
	(stringy or: [self okStreamArrayClass: arrayClass])
		ifTrue: [ self commonAt: stringy ]
		ifFalse: [ self failSpecialPrim: 0 ].
	self internalizeIPandSP.
!
bytecodePrimAtEnd

	self externalizeIPandSP.
	self primitiveAtEnd.
	self internalizeIPandSP.
!
bytecodePrimAtPut
	"See the comment in bytePrimitiveAt."

	| arrayClass stringy |
	self externalizeIPandSP.
	successFlag _ true.
	arrayClass _ self fetchClassOf: (self stackValue: 2).
	stringy _ arrayClass = (self splObj: ClassString).
	(stringy or: [self okStreamArrayClass: arrayClass])
		ifTrue: [ self commonAtPut: stringy ]
		ifFalse: [ self failSpecialPrim: 0 ].
	self internalizeIPandSP.
!
bytecodePrimBitAnd

	self externalizeIPandSP.
	self primitiveBitAnd.
	self internalizeIPandSP.
!
bytecodePrimBitOr

	self externalizeIPandSP.
	self primitiveBitOr.
	self internalizeIPandSP.
!
bytecodePrimBitShift

	self externalizeIPandSP.
	self primitiveBitShift.
	self internalizeIPandSP.
!
bytecodePrimBlockCopy

	| sel rcvrClass |
	self externalizeIPandSP.
	successFlag _ true.
	argumentCount _ 1.
	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).
	self success:
		((rcvrClass = (self splObj: ClassBlockContext)) or:
		 [rcvrClass = (self splObj: ClassMethodContext)]).
	successFlag ifTrue: [ self primitiveBlockCopy ].
	successFlag ifFalse: [
		sel _ self fetchPointer: (24 * 2) ofObject: (self splObj: SpecialSelectors).
		self externalSendSelector: sel argumentCount: argumentCount.
	].
	self internalizeIPandSP.
!
bytecodePrimClass

	self externalizeIPandSP.
	self primitiveClass.
	self internalizeIPandSP.
!
bytecodePrimDiv

	self externalizeIPandSP.
	self primitiveDiv.
	self internalizeIPandSP.
!
bytecodePrimDivide

	| rcvr arg result |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		rcvr _ self integerValueOf: rcvr.
		arg _ self integerValueOf: arg.
		((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue: [
			result _ rcvr // arg.  "generates C / operation"
			(self isIntegerValue: result) ifTrue: [
				self longAt: (localSP _ localSP - 4)
						put: (self integerObjectOf: result).
				^ nil
			].
		].
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatDivide.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveDivide.
	].
	self internalizeIPandSP.
!
bytecodePrimDo

	| sel |
	sel _ self fetchPointer: (27 * 2) ofObject: (self splObj: SpecialSelectors).

	"Note: Use non-inlined version of sendSelector:argumentCount:"
	self externalizeIPandSP.
	self externalSendSelector: sel argumentCount: 1.
	self internalizeIPandSP.
!
bytecodePrimEqual

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr = arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatEqual.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveEqual.
	].
	self internalizeIPandSP.
!
bytecodePrimEquivalent

	self booleanCheat: (self internalStackValue: 1) = (self internalStackValue: 0).!
bytecodePrimGreaterOrEqual

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr >= arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatGreaterOrEqual.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveGreaterOrEqual.
	].
	self internalizeIPandSP.
!
bytecodePrimGreaterThan

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr > arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatGreaterThan.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveGreaterThan.
	].
	self internalizeIPandSP.
!
bytecodePrimLessOrEqual

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr <= arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatLessOrEqual.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveLessOrEqual.
	].
	self internalizeIPandSP.
!
bytecodePrimLessThan

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr < arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatLessThan.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveLessThan.
	].
	self internalizeIPandSP.
!
bytecodePrimMakePoint

	self externalizeIPandSP.
	self primitiveMakePoint.
	self internalizeIPandSP.
!
bytecodePrimMod

	self externalizeIPandSP.
	self primitiveMod.
	self internalizeIPandSP.
!
bytecodePrimMultiply

	| rcvr arg result |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		rcvr _ self integerValueOf: rcvr.
		arg _ self integerValueOf: arg.
		result _ rcvr * arg.
		((arg = 0 or: [(result // arg) = rcvr]) and:
		 [self isIntegerValue: result]) ifTrue: [
			self longAt: (localSP _ localSP - 4)
					put: (self integerObjectOf: result).
			^ nil
		].
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatMultiply.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveMultiply.
	].
	self internalizeIPandSP.
!
bytecodePrimNew

	| sel |
	sel _ self fetchPointer: (28 * 2) ofObject: (self splObj: SpecialSelectors).

	"Note: Use non-inlined version of sendSelector:argumentCount:"
	self externalizeIPandSP.
	self externalSendSelector: sel argumentCount: 0.
	self internalizeIPandSP.
!
bytecodePrimNewWithArg

	| sel |
	sel _ self fetchPointer: (29 * 2) ofObject: (self splObj: SpecialSelectors).

	"Note: Use non-inlined version of sendSelector:argumentCount:"
	self externalizeIPandSP.
	self externalSendSelector: sel argumentCount: 1.
	self internalizeIPandSP.
!
bytecodePrimNext

	| rcvrClass sel |
	self externalizeIPandSP.
	successFlag _ true.
	rcvrClass _ self fetchClassOf: (self stackValue: 0).
	self success: (self okStreamArrayClass: rcvrClass).
	successFlag ifTrue: [ self primitiveNext ].
	successFlag ifFalse: [
		sel _ self fetchPointer: (19 * 2) ofObject: (self splObj: SpecialSelectors).
		self externalSendSelector: sel argumentCount: 0.
	].
	self internalizeIPandSP.
!
bytecodePrimNextPut

	self externalizeIPandSP.
	self primitiveNextPut.
	self internalizeIPandSP.
!
bytecodePrimNotEqual

	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		^ self booleanCheat: rcvr ~= arg
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatNotEqual.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveNotEqual.
	].
	self internalizeIPandSP.
!
bytecodePrimPointX

	self externalizeIPandSP.
	self primitivePointX.
	self internalizeIPandSP.
!
bytecodePrimPointY

	self externalizeIPandSP.
	self primitivePointY.
	self internalizeIPandSP.
!
bytecodePrimSize
	"See the comment in bytePrimitiveAt"

	| arrayClass |
	self externalizeIPandSP.
	successFlag _ true.
	arrayClass _ self fetchClassOf: (self stackValue: 0).
	(self okStreamArrayClass: arrayClass)
		ifTrue: [self primitiveSize]
		ifFalse: [self failSpecialPrim: 0].
	self internalizeIPandSP.
!
bytecodePrimSubtract

	| rcvr arg result |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg) ifTrue: [
		result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).
		(self isIntegerValue: result) ifTrue: [
			self longAt: (localSP _ localSP - 4)
					put: (self integerObjectOf: result).
			^ nil
		].
	].

	self externalizeIPandSP.
	successFlag _ true.
	self primitiveFloatSubtract.
	successFlag ifFalse: [
		successFlag _ true.
		self primitiveSubtract.
	].
	self internalizeIPandSP.
!
bytecodePrimValue

	| sel rcvrClass |
	self externalizeIPandSP.
	successFlag _ true.
	argumentCount _ 0.
	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).
	self success: rcvrClass = (self splObj: ClassBlockContext).
	successFlag ifTrue: [ self primitiveValue ].
	successFlag ifFalse: [
		sel _ self fetchPointer: (25 * 2) ofObject: (self splObj: SpecialSelectors).
		self externalSendSelector: sel argumentCount: argumentCount.
	].
	self internalizeIPandSP.
!
bytecodePrimValueWithArg

	| sel rcvrClass |
	self externalizeIPandSP.
	successFlag _ true.
	argumentCount _ 1.
	rcvrClass _ self fetchClassOf: (self stackValue: argumentCount).
	self success: rcvrClass = (self splObj: ClassBlockContext).
	successFlag ifTrue: [ self primitiveValue ].
	successFlag ifFalse: [
		sel _ self fetchPointer: (26 * 2) ofObject: (self splObj: SpecialSelectors).
		self externalSendSelector: sel argumentCount: argumentCount.
	].
	self internalizeIPandSP.
! !
!Interpreter methodsFor: 'primitive support'!
failed

	^successFlag not!
failSpecialPrim: primIndex
	"Used only for failing from a primitive that was entered as a special
	bytecode.  This routine will look up the real method and, only if its
	primitiveIndex is different, then it will run that primitive, otherwise
	it will simply activate to run the fail code"
	| bytecode selectorIndex newReceiver rcvrClass |
	bytecode _ self getCurrentBytecode.
	(bytecode < 176 or: [bytecode > 207])
		ifTrue: ["Primitive was not running as a special bytecode"
				^ self primitiveFail].
	selectorIndex _ (bytecode - 176) * 2.
	messageSelector _ self fetchPointer: selectorIndex
				ofObject: (self splObj: SpecialSelectors).
	argumentCount _ self quickFetchInteger: selectorIndex + 1
				ofObject: (self splObj: SpecialSelectors).
"
	self sendSelector: messageSelector argumentCount: count
"
	"The above line of code must be expanded and altered, because we only
	want to run the ST code, not re-run the primitive and get into a loop"
	newReceiver _ self stackValue: argumentCount.
	rcvrClass _ self fetchClassOf: newReceiver.
	self findNewMethodInClass: rcvrClass.
	(primitiveIndex > 37 and: [primitiveIndex ~= primIndex])
		ifTrue: [self executeNewMethod]
		ifFalse: [self activateNewMethod]!
positive32BitIntegerFor: integerValue
	| newLargeInteger |
	"Note - integerValue is interpreted as POSITIVE, eg, as the result of
		Bitmap>at:, or integer>bitAnd:."
	(integerValue >= 0 and: [self isIntegerValue: integerValue])
		ifTrue: [^ self integerObjectOf: integerValue].
	newLargeInteger _
		self instantiateSmallClass: (self splObj: ClassLargePositiveInteger)
				sizeInBytes: 8
						 fill: 0.
	self storeByte: 3 ofObject: newLargeInteger
		withValue: ((integerValue >> 24) bitAnd: 16rFF).
	self storeByte: 2 ofObject: newLargeInteger
		withValue: ((integerValue >> 16) bitAnd: 16rFF).
	self storeByte: 1 ofObject: newLargeInteger
		withValue: ((integerValue >> 8) bitAnd: 16rFF).
	self storeByte: 0 ofObject: newLargeInteger
		withValue: (integerValue bitAnd: 16rFF).
	^ newLargeInteger!
positive32BitValueOf: integerPointer
	"Convert the given object into an integer value.
	The object may be either a positive ST integer or a four-byte LargePositiveInteger."
	| sz value |
	(self isIntegerObject: integerPointer)
		ifTrue: [value _ self integerValueOf: integerPointer.
				value < 0 ifTrue: [^ self primitiveFail].
				^ value].
	sz _ self lengthOf: integerPointer.
	(((self fetchClassOf: integerPointer) = (self splObj: ClassLargePositiveInteger)) and: [sz = 4])
		ifFalse: [^ self primitiveFail].
	value _
		(self fetchByte: 0 ofObject: integerPointer) +
		((self fetchByte: 1 ofObject: integerPointer) <<  8) +
		((self fetchByte: 2 ofObject: integerPointer) << 16) +
		((self fetchByte: 3 ofObject: integerPointer) << 24).
	^ value!
primIndex
	^ primitiveIndex!
primitiveFail

	successFlag _ false.!
primitiveResponse

	| thisReceiver |
	primitiveIndex >= 256
		ifTrue:
			[thisReceiver _ self popStack.
			primitiveIndex < 264
				ifTrue: ["Quick return of self or a constant"
						primitiveIndex = 256 ifTrue: [self push: thisReceiver].
						primitiveIndex = 257 ifTrue: [self push: trueObj].
						primitiveIndex = 258 ifTrue: [self push: falseObj].
						primitiveIndex = 259 ifTrue: [self push: nilObj].
						primitiveIndex = 260 ifTrue: [self push: ConstMinusOne].
						primitiveIndex = 261 ifTrue: [self push: ConstZero].
						primitiveIndex = 262 ifTrue: [self push: ConstOne].
						primitiveIndex = 263 ifTrue: [self push: ConstTwo].
						^ true]
				ifFalse: ["Quick return of an instance field"	
						self push: (self fetchPointer: primitiveIndex-264 ofObject: thisReceiver).
						^ true]]
		ifFalse:
			[successFlag _ true.
			self dispatchOn: primitiveIndex in: PrimitiveTable.
			^ successFlag]!
success: successValue

	successFlag _ successValue & successFlag.! !
!Interpreter methodsFor: 'arithmetic primitives'!
checkBooleanResult: result from: primIndex
	successFlag
		ifTrue: [self pushBool: result]
		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!
checkIntegerResult: integerResult from: primIndex
	(successFlag and: [self isIntegerValue: integerResult])
		ifTrue: [self pushInteger: integerResult]
		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!
compare31or32Bits: obj1 equal: obj2
	"May set success to false"

	"First compare two ST integers..."
	((self isIntegerObject: obj1)
		and: [self isIntegerObject: obj2])
		ifTrue: [^ obj1 = obj2].

	"Now compare, assuming positive integers, but setting fail if not"
	^ (self positive32BitValueOf: obj1) = (self positive32BitValueOf: obj2)!
primitiveAdd

	| rcvr arg result |
	rcvr _ self stackValue: 1.
	arg _ self stackValue: 0.
	self pop: 2.
	self success: (self areIntegers: rcvr and: arg).
	successFlag ifTrue: [
		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).
	].
	self checkIntegerResult: result from: 1.
!
primitiveBitAnd
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popPos32BitInteger.
	integerReceiver _ self popPos32BitInteger.
	successFlag
		ifTrue: [self push: (self positive32BitIntegerFor:
					(integerReceiver bitAnd: integerArgument))]
		ifFalse: [self unPop: 2.  self failSpecialPrim: 14]!
primitiveBitOr
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popPos32BitInteger.
	integerReceiver _ self popPos32BitInteger.
	successFlag
		ifTrue: [self push: (self positive32BitIntegerFor:
					(integerReceiver bitOr: integerArgument))]
		ifFalse: [self unPop: 2.  self failSpecialPrim: 15]!
primitiveBitShift 
	| integerReceiver integerArgument shifted |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popPos32BitInteger.
	integerArgument >= 0
		ifTrue:
		["Left shift -- must fail if we lose bits beyond 32"
		self success: integerArgument <= 31.
		shifted _ integerReceiver << integerArgument.
		self success: (shifted >> integerArgument) = integerReceiver.
		]
		ifFalse:
		["Right shift -- OK to lose bits"
		self success: integerArgument >= -31.
		shifted _ integerReceiver bitShift: integerArgument.
		].
	successFlag
		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]
		ifFalse: [self unPop: 2.  self failSpecialPrim: 17]!
primitiveBitXor
	"Note: unlike all the other arithmetic primitives, this is called as
	a real send, not as a special byte.  Thus successFlag has already
	been set, and failure is normal, not through failSpecialPrim."
	| integerReceiver integerArgument |
	integerArgument _ self popPos32BitInteger.
	integerReceiver _ self popPos32BitInteger.
	successFlag
		ifTrue: [self push: (self positive32BitIntegerFor:
					(integerReceiver bitXor: integerArgument))]
		ifFalse: [self unPop: 2]!
primitiveDiv
	"Rounds negative results towards negative infinity, rather than zero."
	| rcvr arg result posArg posRcvr |
	successFlag _ true.
	arg _ self popInteger.
	rcvr _ self popInteger.
	self success: arg ~= 0.
	successFlag ifTrue: [
		rcvr > 0 ifTrue: [
			arg > 0 ifTrue: [
				result _ rcvr // arg.
			] ifFalse: [
				"round negative result toward negative infinity"
				posArg _ 0 - arg.
				result _ 0 - ((rcvr + (posArg - 1)) // posArg).
			].
		] ifFalse: [
			posRcvr _ 0 - rcvr.
			arg > 0 ifTrue: [
				"round negative result toward negative infinity"
				result _ 0 - ((posRcvr + (arg - 1)) // arg).
			] ifFalse: [
				posArg _ 0 - arg.
				result _ posRcvr // posArg.
			].
		].
		self checkIntegerResult: result from: 12]
	ifFalse:
		[self checkIntegerResult: 0 from: 12 "will fail"]!
primitiveDivide
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self success: integerArgument ~= 0.
	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"
	self success: integerReceiver \\ integerArgument = 0.
	self checkIntegerResult: integerReceiver // integerArgument from: 10!
primitiveEqual
	| integerReceiver integerArgument result |
	successFlag _ true.
	integerArgument _ self popStack.
	integerReceiver _ self popStack.
	result _ self compare31or32Bits: integerReceiver equal: integerArgument.
	self checkBooleanResult: result from: 7!
primitiveGreaterOrEqual
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self checkBooleanResult: integerReceiver >= integerArgument from: 6!
primitiveGreaterThan
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self checkBooleanResult: integerReceiver > integerArgument from: 4!
primitiveLessOrEqual
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self checkBooleanResult: integerReceiver <= integerArgument from: 5!
primitiveLessThan
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self checkBooleanResult: integerReceiver < integerArgument from: 3!
primitiveMakePoint
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	successFlag
		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]
		ifFalse: [self checkIntegerResult: 0 from: 18  "will fail"]!
primitiveMod
	| integerReceiver integerArgument integerResult |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self success: integerArgument ~= 0.
	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"
	integerResult _ integerReceiver \\ integerArgument.
	integerResult < 0 ifTrue: [integerResult _ integerResult + integerArgument].
	self checkIntegerResult: integerResult from: 11!
primitiveMultiply

	| rcvr arg result |
	rcvr _ self stackValue: 1.
	arg _ self stackValue: 0.
	self pop: 2.
	self success: (self areIntegers: rcvr and: arg).
	successFlag ifTrue: [
		rcvr _ self integerValueOf: rcvr.
		arg _ self integerValueOf: arg.
		result _ rcvr * arg.
		"check for C overflow by seeing if computation is reversible"
		self success: ((arg = 0) or: [(result // arg) = rcvr]).
	].
	self checkIntegerResult: result from: 9.!
primitiveNotEqual
	| integerReceiver integerArgument result |
	successFlag _ true.
	integerArgument _ self popStack.
	integerReceiver _ self popStack.
	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.
	self checkBooleanResult: result from: 8!
primitiveQuo
	"Rounds negative results towards zero."
	"Note: unlike the other arithmetic primitives, this is called as
	a real send, not as a special byte.  Thus successFlag has already
	been set, and failure is normal, not through failSpecialPrim."
	| rcvr arg result |
	arg _ self popInteger.
	rcvr _ self popInteger.
	self success: arg ~= 0.
	successFlag ifTrue: [
		rcvr > 0 ifTrue: [
			arg > 0 ifTrue: [
				result _ rcvr // arg.
			] ifFalse: [
				result _ 0 - (rcvr // (0 - arg)).
			].
		] ifFalse: [
			arg > 0 ifTrue: [
				result _ 0 - ((0 - rcvr) // arg).
			] ifFalse: [
				result _ (0 - rcvr) // (0 - arg).
			].
		].
		self success: (self isIntegerValue: result)].
	successFlag
		ifTrue: [self pushInteger: result]
		ifFalse: [self unPop: 2]!
primitiveSubtract
	| integerReceiver integerArgument |
	successFlag _ true.
	integerArgument _ self popInteger.
	integerReceiver _ self popInteger.
	self checkIntegerResult: integerReceiver - integerArgument from: 2! !
!Interpreter methodsFor: 'float primitives'!
popFloat
	"Note: May be called by translated primitive code."

	| top result |
	self returnTypeC: 'double'.
	self var: #result declareC: 'double result'.
	top _ self popStack.
	self assertClassOf: top is: (self splObj: ClassFloat).
	successFlag
		ifTrue: [self fetchFloatAt: top + BaseHeaderSize into: result].
	^ result!
primitiveArctan

	| rcvr |
	self var: #rcvr declareC: 'double rcvr'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: (self cCode: 'atan(rcvr)')]
		ifFalse: [self unPop: 1]!
primitiveAsFloat
	| arg |
	arg _ self popInteger.
	successFlag
		ifTrue: [ self pushFloat: (self cCode: '((double) arg)') ]
		ifFalse: [ self unPop: 1 ].!
primitiveExp
	"Computes E raised to the receiver power."

	| rcvr |
	self var: #rcvr declareC: 'double rcvr'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: (self cCode: 'exp(rcvr)')]
		ifFalse: [self unPop: 1]!
primitiveExponent
	"Exponent part of this float."

	| rcvr frac pwr |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #frac declareC: 'double frac'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [
			self cCode: 'frac = frexp(rcvr, &pwr)'.  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"
			(pwr = 0)
				ifTrue: [self pushInteger: 0]
				ifFalse: [self pushInteger: pwr - 1]]
		ifFalse: [self unPop: 1].!
primitiveFloatAdd

	| rcvr rcvrOop arg argOop result resultOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.
	self var: #result declareC: 'double result'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		result _ rcvr + arg.
		resultOop _ self clone: rcvrOop.
		self storeFloatAt: resultOop + BaseHeaderSize from: result.
		self pop: 2 thenPush: resultOop].!
primitiveFloatDivide

	| rcvr rcvrOop arg argOop result resultOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.
	self var: #result declareC: 'double result'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self success: arg ~= 0.0.
		successFlag ifTrue: [
			result _ rcvr // arg.  "generates C / operation"
			resultOop _ self clone: rcvrOop.
			self storeFloatAt: resultOop + BaseHeaderSize from: result.
			self pop: 2 thenPush: resultOop]].!
primitiveFloatEqual

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr = arg].
!
primitiveFloatGreaterOrEqual

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr >= arg].
!
primitiveFloatGreaterThan

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr > arg].
!
primitiveFloatLessOrEqual

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr <= arg].
!
primitiveFloatLessThan

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr < arg].
!
primitiveFloatMultiply

	| rcvr rcvrOop arg argOop result resultOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.
	self var: #result declareC: 'double result'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		result _ rcvr * arg.
		resultOop _ self clone: rcvrOop.
		self storeFloatAt: resultOop + BaseHeaderSize from: result.
		self pop: 2 thenPush: resultOop].!
primitiveFloatNotEqual

	| rcvr rcvrOop arg argOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		self pop: 2.
		self pushBool: rcvr ~= arg].
!
primitiveFloatSubtract

	| rcvr rcvrOop arg argOop result resultOop |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #arg declareC: 'double arg'.
	self var: #result declareC: 'double result'.

	rcvrOop _ self stackValue: 1.
	argOop _ self stackTop.
	self assertFloat: rcvrOop and: argOop.
	successFlag ifTrue: [
		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.
		self fetchFloatAt: argOop + BaseHeaderSize into: arg.
		result _ rcvr - arg.
		resultOop _ self clone: rcvrOop.
		self storeFloatAt: resultOop + BaseHeaderSize from: result.
		self pop: 2 thenPush: resultOop].!
primitiveFractionalPart
	| rcvr frac trunc |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #frac declareC: 'double frac'.
	self var: #trunc declareC: 'double trunc'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [
			self cCode: 'frac = modf(rcvr, &trunc)'.
			self pushFloat: frac]
		ifFalse: [self unPop: 1]!
primitiveLogN
	"Natural log."

	| rcvr |
	self var: #rcvr declareC: 'double rcvr'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: (self cCode: 'log(rcvr)')]
		ifFalse: [self unPop: 1]!
primitiveSine

	| rcvr |
	self var: #rcvr declareC: 'double rcvr'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: (self cCode: 'sin(rcvr)')]
		ifFalse: [self unPop: 1]!
primitiveSquareRoot

	| rcvr |
	self var: #rcvr declareC: 'double rcvr'.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: (self cCode: 'sqrt(rcvr)')]
		ifFalse: [self unPop: 1]!
primitiveTimesTwoPower
	| rcvr arg |
	self var: #rcvr declareC: 'double rcvr'.
	arg _ self popInteger.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]
		ifFalse: [ self unPop: 2 ].!
primitiveTruncated
	| rcvr frac trunc |
	self var: #rcvr declareC: 'double rcvr'.
	self var: #frac declareC: 'double frac'.
	self var: #trunc declareC: 'double trunc'.
	rcvr _ self popFloat.
	successFlag ifTrue: [
		self cCode: 'frac = modf(rcvr, &trunc)'.
		self cCode: 'success((-4294967296.0 <= trunc) && (trunc <= 4294967295.0))'.
	].
	successFlag
		ifTrue: [self cCode: 'pushInteger((int) trunc)']
		ifFalse: [self unPop: 1]!
pushFloat: f

	| newFloatObj |
	self var: #f declareC: 'double f'.
	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.
	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.
	self push: newFloatObj.! !
!Interpreter methodsFor: 'array and stream primitives'!
asciiOfCharacter: characterObj  "Returns an integer object"
	self success: (self fetchClassOf: characterObj) = (self splObj: ClassCharacter).
	successFlag
		ifTrue: [^ self fetchPointer: CharacterValueIndex ofObject: characterObj]
		ifFalse: [^ ConstZero]  "in case some code needs an int"!
byteLengthOf: oop
	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."
	| header sz fmt |
	header _ self baseHeader: oop.
	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass
		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
		ifFalse: [ sz _ header bitAnd: 16rFC ].
	fmt _ (header >> 8) bitAnd: 16rF.
	fmt < 8
		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"
		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"!
characterForAscii: integerObj  "Arg must lie in range 0-255!!"
	^ self fetchPointer: (self integerValueOf: integerObj)
			ofObject: (self splObj: CharacterTable)!
commonAt: stringy
	"This version of at: is called from the special byteCode, from
	primitiveAt, and from primStringAt.  The boolean 'stringy'
	indicates that the result should be converted to a Character."

	| index array result |
	index _ self popInteger.
	array _ self popStack.
	self success: (self isIntegerObject: array) not.
	successFlag ifTrue: [
		result _ self stObject: array at: index.
	].
	successFlag ifTrue: [
		stringy
			ifTrue: [ self push: (self characterForAscii: result) ]
			ifFalse: [ self push: result ].
	] ifFalse: [
		self unPop: 2.
		stringy
			ifTrue: [ self failSpecialPrim: 63 ]
			ifFalse: [ self failSpecialPrim: 60 ].
	].!
commonAtPut: stringy
	"See the comment in commonAt"
	| index array value storeVal |
	value _ self popStack.
	index _ self popInteger.
	array _ self popStack.
	stringy ifTrue: [storeVal _ self asciiOfCharacter: value]
			ifFalse: [storeVal _ value].
	self stObject: array at: index put: storeVal.
	successFlag
		ifTrue: [self push: value]
		ifFalse: [self unPop: 3.
				stringy ifTrue: [self failSpecialPrim: 64]
						ifFalse: [self failSpecialPrim: 61]]!
lengthOf: oop
	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."

	| header sz fmt |
	"from ObjectMemory>sizeBitsOf:..."
	header _ self baseHeader: oop.
	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass
		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
		ifFalse: [ sz _ header bitAnd: 16rFC ].

	"from ObjectMemory>formatOf:..."
	fmt _ (header >> 8) bitAnd: 16rF.

	fmt < 8
		ifTrue: [ ^ (sz - BaseHeaderSize) // 4 ]  "words"
		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"!
okStreamArrayClass: cl

	^(cl = (self splObj: ClassString) or:
	  [cl = (self splObj: ClassArray) or:
	  [cl = (self splObj: ClassByteArray) or:
	  [cl = (self splObj: ClassBitmap)]]])!
primitiveAt
	^ self commonAt: false!
primitiveAtEnd

	| stream array index limit arrayClass size |
	successFlag _ true.
	stream _ self popStack.
	self success: ((self isPointers: stream) and: [(self lengthOf: stream) >= 3]).
 	successFlag ifTrue: [
		array _ self fetchPointer: StreamArrayIndex ofObject: stream.
		index _ self fetchInteger: StreamIndexIndex ofObject: stream.
		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.
		arrayClass _ self fetchClassOf: array.
		self success: (self okStreamArrayClass: arrayClass).
		size _ self stSizeOf: array.
	].
 	successFlag
		ifTrue: [self pushBool: (index >= limit) | (index >= size)]
		ifFalse: [self unPop: 1.  self failSpecialPrim: 67].!
primitiveAtPut
	^ self commonAtPut: false!
primitiveNext
	| stream array index limit arrayClass result |
	successFlag _ true.
	stream _ self popStack.
	array _ self fetchPointer: StreamArrayIndex ofObject: stream.
	index _ self fetchInteger: StreamIndexIndex ofObject: stream.
	limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.
	arrayClass _ self fetchClassOf: array.
	self success: (self okStreamArrayClass: arrayClass).
	self success: index < limit.
	successFlag ifTrue:
		[index _ index + 1.
		result _ self stObject: array at: index].
	successFlag ifTrue:
		[self storeInteger: StreamIndexIndex ofObject: stream
				withValue: index].
	successFlag ifTrue:
		[arrayClass = (self splObj: ClassString)
			ifTrue: [self push: (self characterForAscii: result)]
			ifFalse: [self push: result]]
		ifFalse:
		[self unPop: 1. "self failSpecialPrim: 65" ]  "experimental: new way to handle bytecode sends"!
primitiveNextPut
	| value stream index limit array arrayClass storeVal |
	successFlag _ true.
	value _ self popStack.
	stream _ self popStack.
	array _ self fetchPointer: StreamArrayIndex ofObject: stream.
	index _ self fetchInteger: StreamIndexIndex ofObject: stream.
	limit _ self fetchInteger: StreamWriteLimitIndex ofObject: stream.
	arrayClass _ self fetchClassOf: array.
	self success: (self okStreamArrayClass: arrayClass).
	self success: index < limit.
	successFlag ifTrue:
		[index _ index + 1.
		arrayClass = (self splObj: ClassString)
			ifTrue: [storeVal _ self asciiOfCharacter: value]
			ifFalse: [storeVal _ value].
		self stObject: array at: index put: storeVal].
	successFlag ifTrue:
		[self storeInteger: StreamIndexIndex ofObject: stream
			withValue: index].
	successFlag
		ifTrue: [self push: value]
		ifFalse: [self unPop: 2. self failSpecialPrim: 66]!
primitiveSize
	| array sz |
	array _ self popStack.
	sz _ self stSizeOf: array.
	successFlag
		ifTrue: [self pushInteger: sz]
		ifFalse: [self unPop: 1. self failSpecialPrim: 62]!
primitiveStringAt
	^ self commonAt: true!
primitiveStringAtPut
	^ self commonAtPut: true!
primitiveStringReplace
"
<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 
	<primitive: 105>
"
	| array start stop replacement repStart arrayInstSize repInstSize fmt repi | 
	array _ self stackValue: 4.
	start _ self stackIntegerValue: 3.
	stop _ self stackIntegerValue: 2.
	replacement _ self stackValue: 1.
	repStart _ self stackIntegerValue: 0.
	(self isIntegerObject: replacement) "can happen in LgInt copy"
		ifTrue: [^ self primitiveFail].
	arrayInstSize _ self fixedFieldsOf: array.
	repInstSize _ self fixedFieldsOf: replacement.
	self success: start >= 1.
	self success: start <= stop.
	self success: (stop + arrayInstSize <= (self lengthOf: array)).
	self success: repStart >= 1.
	self success: (stop - start + repStart + repInstSize <= (self lengthOf: replacement)).
	fmt _ self formatOf: array.
	fmt < 8  "Array formats (without byteSize bits) must be same"
		ifTrue: [self success: fmt = (self formatOf: replacement)]
		ifFalse: [self success: (fmt bitAnd: 16rC) = ((self formatOf: replacement) bitAnd: 16rC)].
	successFlag ifFalse: [^ self primitiveFail].

	repi _ repStart + repInstSize - 1.   " - 1 for 0-based access"
	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do:
		[:i | 
		fmt < 4 ifTrue:
			["pointer type objects"
			self storePointer: i ofObject: array withValue:
				(self fetchPointer: repi ofObject: replacement)]
		ifFalse:
			[fmt < 8 ifTrue:
				["long-word type objects"
				self storeWord: i ofObject: array withValue:
				(self fetchWord: repi ofObject: replacement)]
			ifFalse: 
				["byte-type objects"
				self storeByte: i ofObject: array withValue:
				(self fetchByte: repi ofObject: replacement)]].
		repi _ repi + 1].
	self pop: 4.!
stObject: array at: index
	"Return what ST would return for <obj> at: index."

	| fixedFields totalLength i |
	fixedFields _ self fixedFieldsOf: array.
	totalLength _ self lengthOf: array.
	i _ index + fixedFields.
	self success: ((index >= 1) and: [i <= totalLength]).
	successFlag
		ifTrue: [ ^ self subscript: array with: i ]
		ifFalse: [ ^ nilObj ].!
stObject: array at: index put: value
	"Do what ST would return for <obj> at: index put: value."

	| fixedFields totalLength i |
	fixedFields _ self fixedFieldsOf: array.
	totalLength _ self lengthOf: array.
	i _ index + fixedFields.
	self success: ((index >= 1) and: [i <= totalLength]).
	successFlag ifTrue: [
		self subscript: array with: i storing: value.
	].!
stSizeOf: oop
	"Return the number of indexable fields in the given object. (i.e. what ST would return for <obj> size)."
	"Note: oop may be a SmallInteger!!"

	| totalLength fixedFields |
	(self isIntegerObject: oop) ifTrue: [ ^ 0 ].  "integers have no indexable fields"
	totalLength _ self lengthOf: oop.
	fixedFields _ self fixedFieldsOf: oop.
	^ totalLength - fixedFields!
subscript: array with: index
	"Note: This method assumes that the index is within bounds!!"
	| fmt byteVal |
	fmt _ self formatOf: array.
	fmt < 4 ifTrue:
		["pointer type objects"
		^ self fetchPointer: index - 1 ofObject: array].
	fmt < 8 ifTrue:
		["long-word type objects"
		^ self positive32BitIntegerFor:
			(self fetchWord: index - 1 ofObject: array)].
	"byte-type objects"
	byteVal _ self fetchByte: index - 1 ofObject: array.
	^ self integerObjectOf: byteVal!
subscript: array with: index storing: value
	"Note: This method assumes that the index is within bounds!!"
	| fmt byte bitValue |
	fmt _ self formatOf: array.
	fmt < 4 ifTrue:
		["pointer type objects"
		self storePointer: index - 1 ofObject: array withValue: value.
		^ nil].
	fmt < 8 ifTrue:
		["long-word type objects"
		bitValue _ self positive32BitValueOf: value.
		successFlag ifTrue:
			[self storeWord: index-1 ofObject: array withValue: bitValue].
		^ nil].
	"byte-type objects"
	self success: (self isIntegerObject: value).
	byte _ self integerValueOf: value.
	self success: ((byte >= 0) and: [byte <= 255]).
	successFlag ifTrue:
		[self storeByte: index - 1 ofObject: array withValue: byte].! !
!Interpreter methodsFor: 'object access primitives'!
checkInstanceVariableBoundsOf: index in: object
	"NOTE: this should really only work for index <= fixed instSize"
	self success: index >= 1.
	self success: index <= (self lengthOf: object)!
primitiveArrayBecome
	| arg rcvr |
	arg _ self popStack.
	rcvr _ self stackTop.
	self success: (self become: rcvr with: arg).
	successFlag ifFalse: [ self unPop: 1 ].!
primitiveAsOop
	| thisReceiver |
	thisReceiver _ self popStack.
	self success: (self isIntegerObject: thisReceiver) not.
	successFlag
		ifTrue: [self pushInteger: (self hashBitsOf: thisReceiver)]
		ifFalse: [self unPop: 1]!
primitiveClass
	| instance |
	instance _ self popStack.
	self push: (self fetchClassOf: instance)!
primitiveClone
	"Return a shallow copy of the receiver."

	| newCopy |
	newCopy _ self clone: (self stackTop).
	self pop: 1 thenPush: newCopy.!
primitiveEquivalent
	| thisObject otherObject |
	otherObject _ self popStack.
	thisObject _ self popStack.
	self pushBool: thisObject = otherObject!
primitiveInstVarAt
	| index thisReceiver value |
	index _ self popInteger.
	thisReceiver _ self popStack.
	self checkInstanceVariableBoundsOf: index in: thisReceiver.
	successFlag
		ifTrue: [value _ self subscript: thisReceiver with: index].
	successFlag
		ifTrue: [self push: value]
		ifFalse: [self unPop: 2]!
primitiveInstVarAtPut
	| newValue index thisReceiver |
	newValue _ self popStack.
	index _ self popInteger.
	thisReceiver _ self popStack.
	self checkInstanceVariableBoundsOf: index in: thisReceiver.
	successFlag
		ifTrue: [self subscript: thisReceiver with: index storing: newValue].
	successFlag
		ifTrue: [self push: newValue]
		ifFalse: [self unPop: 3]!
primitiveNew
	"Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."

	| class spaceOkay |
	class _ self popStack.
	spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: 0.
	self success: spaceOkay.
	successFlag
		ifTrue: [ self push: (self instantiateClass: class indexableSize: 0) ]
		ifFalse: [ self unPop: 1 ].!
primitiveNewWithArg
	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."

	| size class spaceOkay |
	size _ self popInteger.
	class _ self popStack.
	self success: size >= 0.
	successFlag ifTrue: [
		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.
		self success: spaceOkay.
	].
	successFlag
		ifTrue: [ self push: (self instantiateClass: class indexableSize: size) ]
		ifFalse: [ self unPop: 2 ].!
primitiveNextInstance
	| object instance |
	object _ self popStack.
	instance _ self instanceAfter: object.
	instance = nilObj
		ifTrue: [self unPop: 1. self primitiveFail]
		ifFalse: [self push: instance]!
primitiveNextObject
	"Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects."

	| object instance |
	object _ self popStack.
	instance _ self accessibleObjectAfter: object.
	instance = nil
		ifTrue: [ self pushInteger: 0 ]
		ifFalse: [ self push: instance ].!
primitiveObjectAt  "Defined for CompiledMethods only"
	| thisReceiver index |
	index  _ self popInteger.
	thisReceiver _ self popStack.
	self success: index > 0.
	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).
	successFlag
		ifTrue: [self push: (self fetchPointer: index - 1
					ofObject: thisReceiver)]
		ifFalse: [self unPop: 2]!
primitiveObjectAtPut  "Defined for CompiledMethods only"
	| thisReceiver index newValue |
	newValue _ self popStack.
	index _ self popInteger.
	thisReceiver _ self popStack.
	self success: index > 0.
	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).
	successFlag
		ifTrue: [self storePointer: index - 1
				ofObject: thisReceiver
				withValue: newValue.
			self push: newValue]
		ifFalse: [self unPop: 3]!
primitiveObjectPointsTo
	| rcvr thang lastField |
	thang _ self popStack.
	rcvr _ self popStack.
	(self isIntegerObject: rcvr) ifTrue: [^ self pushBool: false].
	lastField _ self lastPointerOf: rcvr.
	BaseHeaderSize to: lastField by: 4 do:
		[:i | (self longAt: rcvr + i) = thang
			ifTrue: [^ self pushBool: true]].
	self pushBool: false.!
primitivePointX
	| rcvr | 
	successFlag _ true.
	rcvr _ self popStack.
	self success: (self fetchClassOf: rcvr) = (self splObj: ClassPoint).
	successFlag
		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]
		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!
primitivePointY
	| rcvr | 
	successFlag _ true.
	rcvr _ self popStack.
	self success: (self fetchClassOf: rcvr) = (self splObj: ClassPoint).
	successFlag
		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]
		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!
primitiveSomeInstance
	| class instance |
	class _ self popStack.
	instance _ self initialInstanceOf: class.
	instance = nilObj
		ifTrue: [self primitiveFail]
		ifFalse: [self push: instance]!
primitiveSomeObject
	"Return the first object in the heap."

	self pop: 1.
	self push: self firstAccessibleObject.!
sufficientSpaceToInstantiate: classOop indexableSize: size
	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."
	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."

	| format okay |
	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.

	"fail if attempting to call new: on non-indexable class"
	(size > 0 and: [format < 2]) ifTrue: [ ^ false ].

	format < 8 ifTrue: [
		"indexable fields are words or pointers"
		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).
	] ifFalse: [
		"indexable fields are bytes"
		okay _ self sufficientSpaceToAllocate: (2500 + size).
	].

	^ okay! !
!Interpreter methodsFor: 'control primitives'!
primitiveBlockCopy

	| context methodContext contextSize newContext initialIP |
	context _ self stackValue: 1.
	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context)) ifTrue: [
		"context is a block; get the context of its enclosing method"
		methodContext _ self fetchPointer: HomeIndex ofObject: context.
	] ifFalse: [
		methodContext _ context.
	].
	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"
	context _ nil.  "context is no longer needed and is not preserved across allocation"

	"remap methodContext in case GC happens during allocation"
	self pushRemappableOop: methodContext.
	newContext _ self instantiateSmallClass: (self splObj: ClassBlockContext)
							   sizeInBytes: contextSize
									   fill: nilObj.
	methodContext _ self popRemappableOop.

	initialIP _ self integerObjectOf: instructionPointer - method.
	"Was instructionPointer + 3, but now it's greater by 
		methodOop + 4 (headerSize) and less by 1 due to preIncrement"

	"Assume: have just allocated a new context; it must be young.
	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."

	self storeWord: InitialIPIndex					ofObject: newContext
		withValue: initialIP.
	self storeWord: InstructionPointerIndex		ofObject: newContext
		withValue: initialIP.
	self storeStackPointerValue: 0				inContext: newContext.
	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext
		withValue: (self stackValue: 0).
	self storePointerUnchecked: HomeIndex		ofObject: newContext
		withValue: methodContext.

	self pop: 2.  "block argument count, rcvr"
	self push: newContext.!
primitivePerform
	| performSelector newReceiver selectorIndex |
	performSelector _ messageSelector.
	messageSelector _ self stackValue: argumentCount - 1.
	newReceiver _ self stackValue: argumentCount.
	self lookupMethodInClass: (self fetchClassOf: newReceiver).
	self success: (self argumentCountOf: newMethod) = (argumentCount - 1).
	successFlag
		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount + 1.
			self transfer: argumentCount - 1
				fromIndex: selectorIndex + 1
				ofObject: activeContext
				toIndex: selectorIndex
				ofObject: activeContext.
			self pop: 1.
			argumentCount _ argumentCount - 1.
			self executeNewMethod.  "Recursive xeq affects successFlag"
			successFlag _ true]
		ifFalse: [messageSelector _ performSelector]!
primitivePerformWithArgs
	| thisReceiver performSelector argumentArray arrayClass arraySize index cntxSize |
	argumentArray _ self popStack.
	arraySize _ self fetchWordLengthOf: argumentArray.
	arrayClass _ self fetchClassOf: argumentArray.
	cntxSize _ self fetchWordLengthOf: activeContext.
	self success: (self stackPointerIndex + arraySize) < cntxSize.
	self success: (arrayClass = (self splObj: ClassArray)).
	successFlag
		ifTrue: [performSelector _ messageSelector.
			messageSelector _ self popStack.
			thisReceiver _ self stackTop.
			argumentCount _ arraySize.
			index _ 1.
			[index <= argumentCount]
				whileTrue: [self push: (self fetchPointer: index - 1
								ofObject: argumentArray).
					index _ index + 1].
			self lookupMethodInClass:
				(self fetchClassOf: thisReceiver).
			self success: (self argumentCountOf: newMethod)
						= argumentCount.
			successFlag
				ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"
						successFlag _ true]
				ifFalse: [self unPop: argumentCount.
						self push: messageSelector.
						self push: argumentArray.
						argumentCount _ 2.
						messageSelector _ performSelector]]
	ifFalse: [self unPop: 1]!
primitiveValue
	| blockContext blockArgumentCount initialIP |
	blockContext _ self stackValue: argumentCount.
	blockArgumentCount _ self argumentCountOfBlock: blockContext.
	self success: argumentCount = blockArgumentCount.
	successFlag
		ifTrue: [self transfer: argumentCount
				fromIndex: self stackPointerIndex - argumentCount + 1
				ofObject: activeContext
				toIndex: TempFrameStart
				ofObject: blockContext.

			"Assume: The call to transfer:... makes blockContext a root if necessary,
			 allowing use to use unchecked stored in the following code."
			self pop: argumentCount + 1.
			initialIP _ self fetchPointer: InitialIPIndex	ofObject: blockContext.
			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext
				withValue: initialIP.
			self storeStackPointerValue: argumentCount	inContext: blockContext.
			self storePointerUnchecked: CallerIndex		ofObject: blockContext
				withValue: activeContext.
			self newActiveContext: blockContext]!
primitiveValueWithArgs
	| argumentArray blockContext blockArgumentCount
	arrayClass arrayArgumentCount initialIP |
	argumentArray _ self popStack.
	blockContext _ self popStack.
	blockArgumentCount _ self argumentCountOfBlock: blockContext.
	arrayClass _ self fetchClassOf: argumentArray.
	self success: (arrayClass = (self splObj: ClassArray)).
	successFlag
		ifTrue: [arrayArgumentCount _ self fetchWordLengthOf: argumentArray.
			self success: arrayArgumentCount = blockArgumentCount].
	successFlag
		ifTrue: [self transfer: arrayArgumentCount
				fromIndex: 0
				ofObject: argumentArray
				toIndex: TempFrameStart
				ofObject: blockContext.

			"Assume: The call to transfer:... makes blockContext a root if necessary,
			 allowing use to use unchecked stored in the following code."
			initialIP _ self fetchPointer: InitialIPIndex		ofObject: blockContext.
			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext
				withValue: initialIP.
			self storeStackPointerValue: arrayArgumentCount inContext: blockContext.
			self storePointerUnchecked: CallerIndex			ofObject: blockContext
				withValue: activeContext.
			self newActiveContext: blockContext]
		ifFalse: [self unPop: 2]! !
!Interpreter methodsFor: 'processes'!
addLastLink: proc toList: aList
	"Add the given process to the given linked list and set the backpointer
	of process to its new list."

	| lastLink |
	(self isEmptyList: aList) ifTrue: [
		self storePointer: FirstLinkIndex ofObject: aList withValue: proc.
	] ifFalse: [
		lastLink _ self fetchPointer: LastLinkIndex ofObject: aList.
		self storePointer: NextLinkIndex ofObject: lastLink withValue: proc.
	].
	self storePointer: LastLinkIndex ofObject: aList withValue: proc.
	self storePointer: MyListIndex   ofObject:  proc withValue: aList.!
checkForInterrupts
	"Check for possible interrupts and handle one if necessary."

	| sema now |
	signalLowSpace ifTrue: [
		signalLowSpace _ false.  "reset flag"
		lowSpaceThreshold _ 0.  "disable additional interrupts until this is reset by image"
		sema _ (self splObj: TheLowSpaceSemaphore).
		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].
	].

	now _ self ioMSecs.
	now >= nextPollTick ifTrue: [
		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"
		nextPollTick _ now + 500.  "msecs to wait before next call to ioProcessEvents"
	].

	interruptPending ifTrue: [
		interruptPending _ false.  "reset interrupt flag"
		sema _ (self splObj: TheInterruptSemaphore).
		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].
	].

	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [
		nextWakeupTick _ 0.  "reset timer interrupt"
		sema _ (self splObj: TheTimerSemaphore).
		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].
	].!
internalQuickCheckForInterrupts
	"Internal version of quickCheckForInterrupts for use within jumps."

	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [
		interruptCheckCounter _ 1000.
		self externalizeIPandSP.
		self checkForInterrupts.
		self internalizeIPandSP.
	].
!
isEmptyList: aLinkedList

	^ (self fetchPointer: FirstLinkIndex ofObject: aLinkedList) = nilObj!
primitiveResume

	| proc |
	proc _ self stackTop.  "rcvr"
	"self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess))."
	successFlag ifTrue: [ self resume: proc ].!
primitiveSignal

	| sema |
	sema _ self stackTop.  "rcvr"
	self success: ((self fetchClassOf: sema) = (self splObj: ClassSemaphore)).
	successFlag ifTrue: [ self synchronousSignal: sema ].!
primitiveSuspend

	| activeProc |
	activeProc _ self fetchPointer: ActiveProcessIndex
						 ofObject: self schedulerPointer.
	self success: self stackTop = activeProc.
	successFlag ifTrue: [
		self pop: 1.
		self push: nilObj.
		self transferTo: self wakeHighestPriority.
	].!
primitiveWait

	| sema excessSignals activeProc |
	sema _ self stackTop.  "rcvr"
	self success: ((self fetchClassOf: sema) = (self splObj: ClassSemaphore)).
	successFlag ifTrue: [
		excessSignals _
			self fetchInteger: ExcessSignalsIndex ofObject: sema.
		excessSignals > 0 ifTrue: [
			self storeInteger: ExcessSignalsIndex
				ofObject: sema withValue: excessSignals - 1.
		] ifFalse: [
			activeProc _ self fetchPointer: ActiveProcessIndex
								 ofObject: self schedulerPointer.
			self addLastLink: activeProc toList: sema.
			self transferTo: self wakeHighestPriority.
		].
	].!
putToSleep: aProcess
	"Save the given process on the scheduler process list for its priority."

	| priority processLists processList |
	priority _ self quickFetchInteger: PriorityIndex ofObject: aProcess.
	processLists _ self fetchPointer: ProcessListsIndex ofObject: self schedulerPointer.
	processList _ self fetchPointer: priority - 1 ofObject: processLists.
	self addLastLink: aProcess toList: processList.!
quickCheckForInterrupts
	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."
	"Note: Clients who set signalLowSpace or interruptPending should also set interruptCheckCounter to zero to get immediate results."
	"Note: Requires that instructionPointer and stackPointer be external."

	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [
		interruptCheckCounter _ 1000.
		self checkForInterrupts.
	].
!
removeFirstLinkOfList: aList
	"Remove the first process from the given linked list."

	| first last next |
	first _ self fetchPointer: FirstLinkIndex ofObject: aList.
	last  _ self fetchPointer: LastLinkIndex ofObject: aList.
	first = last ifTrue: [
		self storePointer: FirstLinkIndex ofObject: aList withValue: nilObj.
		self storePointer:  LastLinkIndex ofObject: aList withValue: nilObj.
	] ifFalse: [
		next _ self fetchPointer: NextLinkIndex ofObject: first.
		self storePointer: FirstLinkIndex ofObject: aList withValue: next.
	].
	self storePointer: NextLinkIndex ofObject: first withValue: nilObj.
	^ first!
resume: aProcess

	| activeProc activePriority newPriority |
	activeProc _ self fetchPointer: ActiveProcessIndex
						 ofObject: self schedulerPointer.
	activePriority _ self quickFetchInteger: PriorityIndex ofObject: activeProc.
	newPriority   _ self quickFetchInteger: PriorityIndex ofObject: aProcess.
	newPriority > activePriority ifTrue: [
		self putToSleep: activeProc.
		self transferTo: aProcess.
	] ifFalse: [
		self putToSleep: aProcess.
	].!
schedulerPointer

	^ self fetchPointer: ValueIndex
		ofObject: (self splObj: SchedulerAssociation)!
synchronousSignal: aSemaphore
	"Signal the given semaphore from within the interpreter."

	| excessSignals |
	(self isEmptyList: aSemaphore) ifTrue: [
		"no process is waiting on this semaphore"
		excessSignals _
			self fetchInteger: ExcessSignalsIndex ofObject: aSemaphore.
		self storeInteger: ExcessSignalsIndex
			ofObject: aSemaphore withValue: excessSignals + 1.
	] ifFalse: [
		self resume: (self removeFirstLinkOfList: aSemaphore).
	].!
transferTo: newProc
	"Record a process to be awoken on the next interpreter cycle."

	| sched oldProc |
	sched _ self schedulerPointer.
	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.
	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.
	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.
	self newActiveContext:
		(self fetchPointer: SuspendedContextIndex ofObject: newProc).
	reclaimableContextCount _ 0.!
wakeHighestPriority
	"Return the highest priority process that is ready to run."
	"Note: It is a fatal VM error if there is no runnable process."

	| schedLists p processList |
	schedLists _ self fetchPointer: ProcessListsIndex
				ofObject: self schedulerPointer.
	p _ self fetchWordLengthOf: schedLists.
	p _ p - 1.  "index of last indexable field"
	processList _ self fetchPointer: p ofObject: schedLists.
	[self isEmptyList: processList] whileTrue: [
		p _ p - 1.
		p < 0 ifTrue: [ self error: 'scheduler could not find a runnable process' ].
		processList _ self fetchPointer: p ofObject: schedLists.
	].
	^ self removeFirstLinkOfList: processList! !
!Interpreter methodsFor: 'I/O primitives'!
fullDisplayUpdate
	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."

	| displayObj dispBits w h dispBitsIndex d |
	displayObj _ self splObj: TheDisplay.
	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [
		dispBits _ self fetchPointer: 0 ofObject: displayObj.
		w _ self fetchInteger: 1 ofObject: displayObj.
		h _ self fetchInteger: 2 ofObject: displayObj.
		d _ self fetchInteger: 3 ofObject: displayObj.
		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"
		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.
	].!
primitiveBeCursor
	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."

	| cursorObj bitsObj extentX extentY offsetObj offsetX offsetY cursorBitsIndex |
	cursorObj _ self stackTop.
	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).
	successFlag ifTrue: [
		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.
		extentX _ self fetchInteger: 1 ofObject: cursorObj.
		extentY _ self fetchInteger: 2 ofObject: cursorObj.
		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.
		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).
	].
	successFlag ifTrue: [
		offsetX _ self fetchInteger: 0 ofObject: offsetObj.
		offsetY _ self fetchInteger: 1 ofObject: offsetObj.
		self success: ((extentX = 16) and: [extentY = 16]).
		self success: ((offsetX >= -16) and: [offsetX <= 0]).
		self success: ((offsetY >= -16) and: [offsetY <= 0]).
		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).
		cursorBitsIndex _ bitsObj + BaseHeaderSize.
	].
	successFlag ifTrue: [
		self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'.
		self pop: 1.
	].!
primitiveBeDisplay
	"Record the system Display object."

	| rcvr |
	rcvr _ self stackTop.
	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).
	successFlag ifTrue: [
		"record the display object both in a variable and in the specialObjectsOop"
		self storePointer: TheDisplay ofObject: specialObjectsOop withValue: rcvr.
		self pop: 1.
	].!
primitiveBeep

	self ioBeep.!
primitiveCopyBits
	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."

	| rcvr |
	rcvr _ self stackTop.
	self success: (self loadBitBltFrom: rcvr).
	successFlag ifTrue: [
		self copyBits.
		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].
	].!
primitiveDrawLoop
	"Invoke the line drawing primitive."
	| rcvr xDelta yDelta |
	rcvr _ self stackValue: 2.
	xDelta _ self stackIntegerValue: 1.
	yDelta _ self stackIntegerValue: 0.
	self success: (self loadBitBltFrom: rcvr).
	successFlag ifTrue: [
		self drawLoopX: xDelta Y: yDelta.
		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].
		self pop: 2].!
primitiveInputSemaphore
	"Register the input semaphore. If the argument is not a Semaphore, unregister the current input semaphore."

	| arg |
	arg _ self popStack.
	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [
		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: arg.
	] ifFalse: [
		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: nilObj.
	].!
primitiveInputWord
	"Return an integer indicating the reason for the most recent input interrupt."

	self pop: 1.
	self pushInteger: 0.	"noop for now"!
primitiveInterruptSemaphore
	"Register the user interrupt semaphore. If the argument is not a Semaphore, unregister the current interrupt semaphore."

	| arg |
	arg _ self popStack.
	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [
		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: arg.
	] ifFalse: [
		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: nilObj.
	].!
primitiveKbdNext
	"Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."

	| keystrokeWord |
	self pop: 1.
	keystrokeWord _ self ioGetKeystroke.
	keystrokeWord >= 0
		ifTrue: [self pushInteger: keystrokeWord]
		ifFalse: [self push: nilObj].!
primitiveKbdPeek
	"Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."

	| keystrokeWord |
	self pop: 1.
	keystrokeWord _ self ioPeekKeystroke.
	keystrokeWord >= 0
		ifTrue: [self pushInteger: keystrokeWord]
		ifFalse: [self push: nilObj].!
primitiveMouseButtons
	"Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>."

	| buttonWord |
	self pop: 1.
	buttonWord _ self ioGetButtonState.
	self pushInteger: buttonWord.!
primitiveMousePoint
	"Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window."

	| pointWord x y |
	self pop: 1.
	pointWord _ self ioMousePoint.
	x _ self signExtend16: ((pointWord >> 16) bitAnd: 16rFFFF).
	y _ self signExtend16: (pointWord bitAnd: 16rFFFF).
	self push: (self makePointwithxValue: x  yValue: y).!
primitiveScanCharacters
	"Invoke the scanCharacters primitive."

	| rcvr start stop string rightX stopArray displayFlag |
	rcvr _ self stackValue: 6.
	start _ self stackIntegerValue: 5.
	stop _ self stackIntegerValue: 4.
	string _ self stackValue: 3.
	rightX _ self stackIntegerValue: 2.
	stopArray _ self stackValue: 1.
	displayFlag _ self booleanValueOf: (self stackValue: 0).
	successFlag ifFalse: [^ nil].
	self success: (self loadScannerFrom: rcvr
					start: start stop: stop string: string rightX: rightX
					stopArray: stopArray displayFlag: displayFlag).
	successFlag
		ifTrue: [self scanCharacters].
	successFlag
		ifTrue: [
			(displayFlag and: [self targetForm = (self splObj: TheDisplay)])
				ifTrue: [self showDisplayBits].
			self pop: 7.
			self push: self stopReason].!
primitiveScreenSize
	"Return a point indicating the current size of the Smalltalk window."

	| pointWord |
	self pop: 1.
	pointWord _ self ioScreenSize.
	self push:
		(self makePointwithxValue: ((pointWord >>16) bitAnd: 16rFFFF)
						   yValue: (pointWord bitAnd: 16rFFFF)).!
primitiveSetInterruptKey
	"Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext."

	| keycode |
	keycode _ self popInteger.
	successFlag
		ifTrue: [ interruptKeycode _ keycode ]
		ifFalse: [ self unPop: 1 ].!
primitiveWarpBits
	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."
	| rcvr |
	rcvr _ self stackValue: self argCount.
	self success: (self loadBitBltFrom: rcvr).
	successFlag ifTrue: [
		self warpBits.
		self targetForm = (self splObj: TheDisplay) ifTrue: [self showDisplayBits].
	].!
showDisplayBits
	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."

	| displayObj dispBits w h affectedRectL affectedRectR affectedRectT affectedRectB dispBitsIndex d |
	displayObj _ self splObj: TheDisplay.
	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).
	successFlag ifTrue: [
		dispBits _ self fetchPointer: 0 ofObject: displayObj.
		w _ self fetchInteger: 1 ofObject: displayObj.
		h _ self fetchInteger: 2 ofObject: displayObj.
		d _ self fetchInteger: 3 ofObject: displayObj.
	].
	successFlag ifTrue: [
		affectedRectL _ self affectedLeft.
		affectedRectR _ self affectedRight.
		affectedRectT _ self affectedTop.
		affectedRectB _ self affectedBottom.
		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"
		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.
	].! !
!Interpreter methodsFor: 'file primitives'!
asciiDirectoryDelimiter
	^ self cCode: 'dir_Delimitor()'!
fileRecordSize
	"Return the size of a Smalltalk file record in bytes."

	^ self cCode: 'sizeof(SQFile)'.!
fileValueOf: objectPointer
	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."

	| fileIndex |
	self returnTypeC: 'SQFile *'.
	self success:
		((self isBytes: objectPointer) and:
		 [(self lengthOf: objectPointer) = self fileRecordSize]).

	successFlag ifTrue: [
		fileIndex _ objectPointer + BaseHeaderSize.
		^ self cCode: '(SQFile *) fileIndex'
	] ifFalse:  [
		^ nil
	].!
makeDirEntryName: entryName size: entryNameSize
	createDate: createDate modDate: modifiedDate
	isDir: dirFlag fileSize: fileSize

	| modDateOop createDateOop nameString results |
	self var: 'entryName' declareC: 'char *entryName'.

	"allocate storage for results, remapping newly allocated
	 oops in case GC happens during allocation"
	self pushRemappableOop:
		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).
	self pushRemappableOop:
		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..
	self pushRemappableOop: (self positive32BitIntegerFor: createDate).
	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).

	modDateOop   _ self popRemappableOop.
	createDateOop _ self popRemappableOop.
	nameString    _ self popRemappableOop.
	results         _ self popRemappableOop.

	"copy name into Smalltalk string"
	0 to: entryNameSize - 1 do: [ :i |
		self storeByte: i ofObject: nameString withValue: (entryName at: i).
	].

	self storePointer: 0 ofObject: results withValue: nameString.
	self storePointer: 1 ofObject: results withValue: createDateOop.
	self storePointer: 2 ofObject: results withValue: modDateOop.
	dirFlag
		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]
		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].
	self storePointer: 4 ofObject: results
		withValue: (self integerObjectOf: fileSize).
	^ results
!
primitiveDirectoryCreate

	| dirName dirNameIndex dirNameSize |
	dirName _ self stackTop.
	self success: (self isBytes: dirName).
	successFlag ifTrue: [
		dirNameIndex _ dirName + BaseHeaderSize.
		dirNameSize _ self lengthOf: dirName.
	].
	successFlag ifTrue: [
		self success:
			(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)').
	].
	successFlag ifTrue: [
		self pop: 1.  "pop dirName; leave rcvr on stack"
	].!
primitiveDirectoryDelimitor

	| ascii |
	ascii _ self asciiDirectoryDelimiter.
	self success: ((ascii >= 0) and: [ascii <= 255]).
	successFlag ifTrue: [
		self pop: 1.  "pop rcvr"
		self push: (self fetchPointer: ascii ofObject: (self splObj: CharacterTable)).
	].!
primitiveDirectoryLookup

	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |
	self var: 'entryName' declareC: 'char entryName[256]'.
	index _ self stackIntegerValue: 0.
	pathName _ self stackValue: 1.
	self success: (self isBytes: pathName).
	successFlag ifTrue: [
		pathNameIndex _ pathName + BaseHeaderSize.
		pathNameSize _ self lengthOf: pathName.
	].
	successFlag ifTrue: [
		status _ self cCode:
			'dir_Lookup(
				(char *) pathNameIndex, pathNameSize, index,
				entryName, &entryNameSize, &createDate, &modifiedDate,
				&dirFlag, &fileSize)'.
		status = DirNoMoreEntries ifTrue: [
			"no more entries; return nil"
			self pop: 3.  "pop pathName, index, rcvr"
			self push: nilObj.
			^ nil
		].
		status = DirBadPath ifTrue: [ ^ self primitiveFail ].  "bad path"
	].
	successFlag ifTrue: [
		self pop: 3.  "pop pathName, index, rcvr"
		self push:
			(self makeDirEntryName: entryName size: entryNameSize
				createDate: createDate modDate: modifiedDate
				isDir: dirFlag fileSize: fileSize).
	].!
primitiveDirectorySetMacTypeAndCreator

	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |
	creatorString _ self stackTop.
	typeString _ self stackValue: 1.
	fileName _ self stackValue: 2.
	self success: ((self isBytes: creatorString) and: [(self lengthOf: creatorString) = 4]).
	self success: ((self isBytes: typeString) and: [(self lengthOf: typeString) = 4]).
	self success: (self isBytes: fileName).
	successFlag ifTrue: [
		creatorStringIndex _ creatorString + BaseHeaderSize.
		typeStringIndex _ typeString + BaseHeaderSize.
		fileNameIndex _ fileName + BaseHeaderSize.
		fileNameSize _ self lengthOf: fileName.
	].
	successFlag ifTrue: [
		self success:
			(self cCode: 'dir_SetMacFileTypeAndCreator(
				(char *) fileNameIndex, fileNameSize,
				(char *) typeStringIndex, (char *) creatorStringIndex)').
	].
	successFlag ifTrue: [
		self pop: 3.  "pop filename, type, creator; leave rcvr on stack"
	].!
primitiveFileAtEnd

	| file atEnd |
	self var: 'file' declareC: 'SQFile *file'.
	file _ self fileValueOf: self stackTop.
	successFlag ifTrue: [ atEnd _ self sqFileAtEnd: file ].
	successFlag ifTrue: [
		self pop: 2.  "rcvr, file"
		self pushBool: atEnd.
	].!
primitiveFileClose

	| file |
	self var: 'file' declareC: 'SQFile *file'.
	file _ self fileValueOf: self stackTop.
	successFlag ifTrue: [ self sqFileClose: file ].
	successFlag ifTrue: [ self pop: 1  "pop file; leave rcvr on stack" ].!
primitiveFileDelete

	| namePointer nameIndex nameSize |
	namePointer _ self stackTop.
	self success: (self isBytes: namePointer).
	successFlag ifTrue: [
		nameIndex _ namePointer + BaseHeaderSize.
		nameSize _ self lengthOf: namePointer.
	].
	successFlag ifTrue: [
		self sqFileDeleteName: nameIndex Size: nameSize.
	].
	successFlag ifTrue: [ self pop: 1. "pop name, leave rcvr on stack" ].
!
primitiveFileGetPosition

	| file position |
	self var: 'file' declareC: 'SQFile *file'.
	file _ self fileValueOf: (self stackTop).
	successFlag ifTrue: [ position _ self sqFileGetPosition: file ].
	successFlag ifTrue: [
		self pop: 2.  "rcvr, file"
		self pushInteger: position.
	].!
primitiveFileOpen

	| writeFlag namePointer filePointer file nameIndex nameSize |
	self var: 'file' declareC: 'SQFile *file'.
	writeFlag _ self booleanValueOf: (self stackTop).
	namePointer _ self stackValue: 1.
	self success: (self isBytes: namePointer).
	successFlag ifTrue: [
		filePointer _ self instantiateClass: (self splObj: ClassByteArray)
						   indexableSize: self fileRecordSize.
		file _ self fileValueOf: filePointer.
		nameIndex _ namePointer + BaseHeaderSize.
		nameSize _ self lengthOf: namePointer.
	].
	successFlag ifTrue: [
		self cCode: 'sqFileOpen(file, nameIndex, nameSize, writeFlag)'.
	].
	successFlag ifTrue: [
		self pop: 3.  "rcvr, name, writeFlag"
		self push: filePointer.
	].!
primitiveFileRead

	| count startIndex array file byteSize arrayIndex bytesRead |
	self var: 'file' declareC: 'SQFile *file'.

	count		_ self stackIntegerValue: 0.
	startIndex	_ self stackIntegerValue: 1.
	array		_ self stackValue: 2.
	file			_ self fileValueOf: (self stackValue: 3).

	"buffer can be any indexable words or bytes object except CompiledMethod"
	self success: (self isWordsOrBytes: array).

	(self isWords: array)
		ifTrue: [ byteSize _ 4 ]
		ifFalse: [ byteSize _ 1 ].
	self success: (
		(startIndex >= 1) and:
		[(startIndex + count - 1) <= (self lengthOf: array)]).
	successFlag ifTrue: [
		arrayIndex _ array + BaseHeaderSize.
		"Note: adjust startIndex for zero-origin indexing"
		bytesRead _ self sqFile: file Read: (count * byteSize)
						 Into: arrayIndex
						   At: ((startIndex - 1) * byteSize).
	].
	successFlag ifTrue: [
		self pop: 5.  "pop rcvr, file, array, startIndex, count"
		self pushInteger: bytesRead // byteSize.  "push # of elements read"
	].!
primitiveFileRename

	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |
	newNamePointer _ self stackTop.
	oldNamePointer _ self stackValue: 1.
	self success: (self isBytes: newNamePointer).
	self success: (self isBytes: oldNamePointer).
	successFlag ifTrue: [
		newNameIndex _ newNamePointer + BaseHeaderSize.
		newNameSize _ self lengthOf: newNamePointer.
		oldNameIndex _ oldNamePointer + BaseHeaderSize.
		oldNameSize _ self lengthOf: oldNamePointer.
	].
	successFlag ifTrue: [
		self sqFileRenameOld: oldNameIndex Size: oldNameSize New: newNameIndex Size: newNameSize.
	].
	successFlag ifTrue: [
		self pop: 2.  "pop new and old names, leave rcvr on stack"
	].!
primitiveFileSetPosition

	| newPosition file |
	self var: 'file' declareC: 'SQFile *file'.
	newPosition _ self stackIntegerValue: 0.
	file _ self fileValueOf: (self stackValue: 1).
	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].
	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].!
primitiveFileSize

	| file size |
	self var: 'file' declareC: 'SQFile *file'.
	file _ self fileValueOf: (self stackTop).
	successFlag ifTrue: [ size _ self sqFileSize: file ].
	successFlag ifTrue: [
		self pop: 2.  "rcvr, file"
		self pushInteger: size.
	].!
primitiveFileWrite

	| count startIndex array file byteSize arrayIndex bytesWritten |
	self var: 'file' declareC: 'SQFile *file'.

	count		_ self stackIntegerValue: 0.
	startIndex	_ self stackIntegerValue: 1.
	array		_ self stackValue: 2.
	file			_ self fileValueOf: (self stackValue: 3).

	"buffer can be any indexable words or bytes object except CompiledMethod"
	self success: (self isWordsOrBytes: array).

	(self isWords: array)
		ifTrue: [ byteSize _ 4 ]
		ifFalse: [ byteSize _ 1 ].
	self success: (
		(startIndex >= 1) and:
		[(startIndex + count - 1) <= (self lengthOf: array)]).
	successFlag ifTrue: [
		arrayIndex _ array + BaseHeaderSize.
		"Note: adjust startIndex for zero-origin indexing"
		bytesWritten _
			self sqFile: file
				Write: (count * byteSize)
				From: arrayIndex At: ((startIndex - 1) * byteSize).
	].
	successFlag ifTrue: [
		self pop: 5.  "pop rcvr, file, array, startIndex, count"
		self pushInteger: bytesWritten // byteSize.  "push # of elements written"
	].! !
!Interpreter methodsFor: 'memory space primitives'!
primitiveBytesLeft
	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."

	self pop: 1.
	self pushInteger: (self sizeOfFree: freeBlock).!
primitiveFullGC
	"Do a quick, incremental garbage collection and return the number of bytes available."

	self pop: 1.
	self incrementalGC.  "maximimize space for forwarding table"
	self fullGC.
	self pushInteger: (self sizeOfFree: freeBlock).!
primitiveIncrementalGC
	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."

	self pop: 1.
	self incrementalGC.
	self pushInteger: (self sizeOfFree: freeBlock).!
primitiveLowSpaceSemaphore
	"Register the low-space semaphore. If the argument is not a Semaphore, unregister the current low-space Semaphore."

	| arg |
	arg _ self popStack.
	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [
		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: arg.
	] ifFalse: [
		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: nilObj.
	].!
primitiveSignalAtBytesLeft
	"Set the low-water mark for free space. When the free space falls below this level, the new and new: primitives fail and system attempts to allocate space (e.g., to create a method context) cause the low-space semaphore (if one is registered) to be signalled."

	| bytes |
	bytes _ self popInteger.
	successFlag
		ifTrue: [ lowSpaceThreshold _ bytes ]
		ifFalse: [
			lowSpaceThreshold _ 0.
			self unPop: 1.
		].! !
!Interpreter methodsFor: 'sound primitives'!
primitiveConstantFill
	"Fill the receiver, which must be an indexable bytes or words objects, with the given integer value."

	| fillValue rcvr rcvrIsBytes end i |
	fillValue _ self stackIntegerValue: 0.
	rcvr _ self stackValue: 1.
	self success: (self isWordsOrBytes: rcvr).
	rcvrIsBytes _ self isBytes: rcvr.
	rcvrIsBytes ifTrue: [
		self success: ((fillValue >= 0) and: [fillValue <= 255]).
	].
	successFlag ifTrue: [
		end _ rcvr + (self sizeBitsOf: rcvr).
		i _ rcvr + BaseHeaderSize.
		rcvrIsBytes ifTrue: [
			[i < end] whileTrue: [
				self byteAt: i put: fillValue.
				i _ i + 1.
			].
		] ifFalse: [
			[i < end] whileTrue: [
				self longAt: i put: fillValue.
				i _ i + 4.
			].
		].
		self pop: 1.  "pop fillValue; leave rcvr on stack"
	].
!
primitiveShortAt
	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."

	| index rcvr sz addr value |
	index _ self stackIntegerValue: 0.
	rcvr _ self stackValue: 1.
	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).
	successFlag ifFalse: [ ^ nil ].
	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"
	self success: ((index >= 1) and: [index <= sz]).
	successFlag ifTrue: [
		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).
		value _ self cCode: '*((short int *) addr)'.
		self pop: 2.  "pop rcvr, index"
		self pushInteger: value.  "push element value"
	].!
primitiveShortAtPut
	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."

	| index rcvr sz addr value |
	value _ self stackIntegerValue: 0.
	index _ self stackIntegerValue: 1.
	rcvr _ self stackValue: 2.
	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).
	successFlag ifFalse: [ ^ nil ].
	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"
	self success: ((index >= 1) and: [index <= sz]).
	self success: ((value >= -32768) and: [value <= 32767]).
	successFlag ifTrue: [
		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).
		self cCode: '*((short int *) addr) = value'.
		self pop: 2.  "pop index and value; leave rcvr on stack"
	].!
primitiveSoundAvailableSpace
	"Returns the number of sample frames of available sound output buffer space."

	| frames |
	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"
	self success: frames >= 0.
	successFlag ifTrue: [
		self pop: 1.  "rcvr"
		self push: (self positive32BitIntegerFor: frames).
	].!
primitiveSoundPlaySamples
	"Output a buffer's worth of sound samples."

	| startIndex buf frameCount framesPlayed |
	startIndex _ self stackIntegerValue: 0.
	buf _ self stackValue: 1.
	frameCount _ self stackIntegerValue: 2.
	self success: (self isWords: buf).
	self success: (
		(startIndex >= 1) and:
		[(startIndex + frameCount - 1) <= (self lengthOf: buf)]).

	successFlag ifTrue: [
		framesPlayed _
			self cCode: 'snd_PlaySamplesFromAtLength(frameCount, buf + 4, startIndex - 1)'.
		self success: framesPlayed >= 0.
	].
	successFlag ifTrue: [
		self pop: 4.  "pop frameCount, buf, startIndex, rcvr"
		self push: (self positive32BitIntegerFor: framesPlayed).
	].!
primitiveSoundPlaySilence
	"Output a buffer's worth of silence. Returns the number of sample frames played."

	| framesPlayed |
	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"
	self success: framesPlayed >= 0.
	successFlag ifTrue: [
		self pop: 1.  "rcvr"
		self push: (self positive32BitIntegerFor: framesPlayed).
	].!
primitiveSoundStart
	"Start the double-buffered sound output with the given buffer size and sample rate."

	| stereoFlag samplesPerSec bufFrames |
	stereoFlag		_ self booleanValueOf: (self stackValue: 0).
	samplesPerSec	_ self stackIntegerValue: 1.
	bufFrames		_ self stackIntegerValue: 2.
	successFlag ifTrue: [
		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag)').
	].
	successFlag ifTrue: [
		self pop: 3.  "pop bufFrames, samplesPerSec, stereoFlag; leave rcvr on stack"
	].!
primitiveSoundStop
	"Stop double-buffered sound output."

	self cCode: 'snd_Stop()'.  "leave rcvr on stack"
	! !
!Interpreter methodsFor: 'other primitives'!
primitiveClipboardText
	"When called with a single string argument, post the string to the clipboard. When called with zero arguments, return a string containing the current clipboard contents."

	| s sz |
	argumentCount = 1 ifTrue: [
		s _ self stackTop.
		self success: (self fetchClassOf: s) = (self splObj: ClassString).
		successFlag ifTrue: [
			sz _ self stSizeOf:  s.
			self clipboardWrite: sz From: (s + BaseHeaderSize) At: 0.
			self pop: 1.  "pop s, leave rcvr on stack"
		].
	] ifFalse: [
		sz _ self clipboardSize.
		s _ self instantiateClass: (self splObj: ClassString)
					  indexableSize: sz.
		self clipboardRead: sz Into: (s + BaseHeaderSize) At: 0.
		self pop: 1.  "rcvr"
		self push: s.
	].
!
primitiveExitToDebugger

	self error: 'Exit to debugger at user request'.!
primitiveFlushCache
	"Clear the method lookup cache. This must be done after every programming change."

	self flushMethodCache.!
primitiveImageName
	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."

	| s sz |
	argumentCount = 1 ifTrue: [
		s _ self stackTop.
		self success: (self fetchClassOf: s) = (self splObj: ClassString).
		successFlag ifTrue: [
			sz _ self stSizeOf:  s.
			self imageNamePut: (s + BaseHeaderSize) Length: sz.
			self pop: 1.  "pop s, leave rcvr on stack"
		].
	] ifFalse: [
		sz _ self imageNameSize.
		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.
		self imageNameGet: (s + BaseHeaderSize) Length: sz.
		self pop: 1.  "rcvr"
		self push: s.
	].
!
primitiveMillisecondClock
	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around every so many days."

	self pop: 1.  "pop rcvr"
	self push: (self positive32BitIntegerFor: self ioMSecs).!
primitiveNoop
	"A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver."

	self pop: argumentCount.  "pop args, leave rcvr on stack"!
primitiveQuit

	self exit: 0.
	self error: 'Execution should not continue after quit'.!
primitiveReadJoystick
	"Read an input word from the joystick with the given index."

	| index |
	index _ self stackIntegerValue: 0.
	successFlag ifTrue: [
		self pop: 2.  "index, rcvr"
		self push: (self positive32BitIntegerFor: (self joystickRead: index)).
	].!
primitiveSecondsClock
	"Return the number of seconds since January 1, 1901 as an integer."

	self pop: 1.  "pop rcvr"
	self push: (self positive32BitIntegerFor: self ioSeconds).!
primitiveSignalAtMilliseconds
	"Cause the time semaphore, if one has been registered, to be signalled when the millisecond clock is greater than or equal to the given tick value. A tick value of zero turns off timer interrupts."

	| tick sema |
	tick _ self popInteger.
	sema _ self popStack.
	successFlag ifTrue: [
		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) ifTrue: [
			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: sema.
			nextWakeupTick _ tick.
		] ifFalse: [
			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: nilObj.
			nextWakeupTick _ 0.
		].
	] ifFalse: [
		self unPop: 2.  "sema, tick"
	].!
primitiveSnapshot

	| activeProc dataSize rcvr |
	"save the state of the current process and save it on the scheduler queue"
	self storeContextRegisters: activeContext.
	activeProc _
		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.
	self storePointer: SuspendedContextIndex
		    ofObject: activeProc
		  withValue: activeContext.

	"compact memory and compute the size of the memory actually in use"
	self incrementalGC.  "maximimize space for forwarding table"
	self fullGC.

	dataSize _ freeBlock - (self startOfMemory).
	"Assume: all objects are below the start of the free block"

	successFlag ifTrue: [
		rcvr _ self popStack.  "pop rcvr"
		self push: trueObj.
		self writeImageFile: dataSize.
		self pop: 1.  "pop true"
	].
	successFlag
		ifTrue: [ self push: falseObj ]
		ifFalse: [ self push: rcvr ].!
primitiveSpecialObjectsOop
	"Return the oop of the SpecialObjectsArray."

	self pop: 1.
	self push: specialObjectsOop.!
primitiveVMPath
	"Return a string containing the path name of VM's directory."

	| s sz |
	sz _ self vmPathSize.
	s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.
	self vmPathGet: (s + BaseHeaderSize) Length: sz.
	self pop: 1.  "rcvr"
	self push: s.
! !
!Interpreter methodsFor: 'debug printing'!
cr
	"For testing in Smalltalk, this method should be overridden in a subclass."

	self printf: '\n'.!
print: s
	"For testing in Smalltalk, this method should be overridden in a subclass."

	self var: #s declareC: 'char *s'.
	self cCode: 'printf("%s", s)'.!
printChar: aByte
	"For testing in Smalltalk, this method should be overridden in a subclass."

	self putchar: aByte.!
printNum: n
	"For testing in Smalltalk, this method should be overridden in a subclass."

	self cCode: 'printf("%ld", (long) n)'.! !
!Interpreter methodsFor: 'debug support'!
allAccessibleObjectsOkay
	"Ensure that all accessible objects in the heap are okay."

	| oop |
	oop _ self firstAccessibleObject.
	[oop = nil] whileFalse: [
		self okayFields: oop.
		oop _ self accessibleObjectAfter: oop.
	].!
findClassOfMethod: meth forReceiver: rcvr

	| currClass classDict classDictSize methodArray i done |
	currClass _ self fetchClassOf: rcvr.
	done _ false.
	[done] whileFalse: [
		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.
		classDictSize _ self fetchWordLengthOf: classDict.
		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.
		i _ 0.
		[i < (classDictSize - SelectorStart)] whileTrue: [
			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [ ^currClass ].
			i _ i + 1.
		].
		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.
		done _ currClass = nilObj.
	].
	^self fetchClassOf: rcvr    "method not found in superclass chain"!
findSelectorOfMethod: meth forReceiver: rcvr

	| currClass done classDict classDictSize methodArray i |
	currClass _ self fetchClassOf: rcvr.
	done _ false.
	[done] whileFalse: [
		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.
		classDictSize _ self fetchWordLengthOf: classDict.
		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.
		i _ 0.
		[i <= (classDictSize - SelectorStart)] whileTrue: [
			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [
				^(self fetchPointer: i + SelectorStart ofObject: classDict)
			].
			i _ i + 1.
		].
		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.
		done _ currClass = nilObj.
	].
	^self splObj: SelectorDoesNotUnderstand    "method not found in superclass chain"!
okayActiveProcessStack

	| cntxt |
	cntxt _ activeContext.	
	[cntxt = nilObj] whileFalse: [
		self okayFields: cntxt.
		cntxt _ (self fetchPointer: SenderIndex ofObject: cntxt).
	].!
okayFields: oop
	"If this is a pointers object, check that its fields are all okay oops."

	| i fieldOop |
	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].
	(self isIntegerObject: oop) ifTrue: [ ^true ].
	self okayOop: oop.
	self oopHasOkayClass: oop.
	(self isPointers: oop) ifFalse: [ ^true ].
	i _ (self lengthOf: oop) - 1.
	[i >= 0] whileTrue: [
		fieldOop _ self fetchPointer: i ofObject: oop.
		(self isIntegerObject: fieldOop) ifFalse: [
			self okayOop: fieldOop.
			self oopHasOkayClass: fieldOop.
		].
		i _ i - 1.
	].!
okayInterpreterObjects

	| oopOrZero oop |
	self okayFields: nilObj.
	self okayFields: falseObj.
	self okayFields: trueObj.
	self okayFields: specialObjectsOop.
	self okayFields: activeContext.
	self okayFields: method.
	self okayFields: receiver.
	self okayFields: theHomeContext.
	self okayFields: messageSelector.
	self okayFields: newMethod.
	1 to: MethodCacheEntries do: [ :i |
		oopOrZero _ methodCache at: i.
		oopOrZero = 0 ifFalse: [
			self okayFields: (methodCache at: i).							"selector"
			self okayFields: (methodCache at: i + MethodCacheEntries).		"class"
			self okayFields: (methodCache at: i + (2 * MethodCacheEntries)).	"method"
		].
	].
	1 to: remapBufferCount do: [ :i |
		oop _ remapBuffer at: i.
		(self isIntegerObject: oop) ifFalse: [
			self okayFields: oop.
		].
	].
	self okayActiveProcessStack.!
okayOop: oop
	"Verify that the given oop is legitimate. Check address, header, and size but not class."

	| sz type fmt |
	"address and size checks"
	(self isIntegerObject: oop) ifTrue: [ ^true ].
	((0 < oop) & (oop < endOfMemory))
		ifFalse: [ self error: 'oop is not a valid address' ].
	((oop \\ 4) = 0)
		ifFalse: [ self error: 'oop is not a word-aligned address' ].
	sz _ self sizeBitsOf: oop.
	(oop + sz) < endOfMemory
		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].

	"header type checks"
	type _ self headerType: oop.
	type = HeaderTypeFree
		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].
	type = HeaderTypeShort ifTrue: [
		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0
			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].
	].
	type = HeaderTypeClass ifTrue: [
		((oop >= 4) and: [(self headerType: oop - 4) = type])
			ifFalse: [ self error: 'class header word has wrong type' ].
	].
	type = HeaderTypeSizeAndClass ifTrue: [
		((oop >= 8) and:
		 [(self headerType: oop - 8) = type and:
		 [(self headerType: oop - 4) = type]])
			ifFalse: [ self error: 'class header word has wrong type' ].
	].

	"format check"
	fmt _ self formatOf: oop.
	((fmt = 4) | (fmt = 5) | (fmt = 7))
		ifTrue:  [ self error: 'oop has an unknown format type' ].

	"mark and root bit checks"
	((self longAt: oop) bitAnd: 16r20000000) = 0
		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ].
"xxx
	((self longAt: oop) bitAnd: MarkBit) = 0
		ifFalse: [ self error: 'mark bit should not be set except during GC' ].
xxx"
	(((self longAt: oop) bitAnd: RootBit) = 1 and:
	 [oop >= youngStart])
		ifTrue: [ self error: 'root bit is set in a young object' ].
	^true!
oopHasOkayClass: oop
	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."

	| oopClass formatMask behaviorFormatBits oopFormatBits |
	self okayOop: oop.
	oopClass _ self fetchClassOf: oop.

	(self isIntegerObject: oopClass)
		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].
	self okayOop: oopClass.
	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])
		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].
	(self isBytes: oop)
		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"
		ifFalse: [ formatMask _ 16rF00 ].

	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.
	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.
	behaviorFormatBits = oopFormatBits
		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].
	^true!
printCallStack

	| ctxt home methodClass methodSel |
	ctxt _ activeContext.
	[ctxt = nilObj] whileFalse: [
		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)
			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]
			ifFalse: [ home _ ctxt ].
		methodClass _
			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)
					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).
		methodSel _
			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)
						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).
		self printNum: ctxt.
		self print: ' '.
		ctxt = home ifFalse: [ self print: '[] in ' ].
		self printNameOfClass: methodClass count: 5.
		self print: '>'.
		self printStringOf: methodSel.
		self cr.

		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).
	].!
printNameOfClass: classOop count: cnt
	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."

	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].
	(self sizeBitsOf: classOop) = 16r20 ifTrue: [
		self printNameOfClass: (self fetchPointer: 6 "thisClass" ofObject: classOop) count: cnt - 1.
		self print: ' class'.
	] ifFalse: [
		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).
	].!
printStringOf: oop

	| fmt cnt i |
	fmt _ self formatOf: oop.
	fmt < 8 ifTrue: [ ^nil ].

	cnt _ 100 min: (self lengthOf: oop).
	i _ 0.
	[i < cnt] whileTrue: [
		self printChar: (self fetchByte: i ofObject: oop).
		i _ i + 1.
	].!
reportContexts

	| cntxt big small |
	big _ 0.
	cntxt _ freeLargeContexts.
	[cntxt = NilContext] whileFalse: [
		big _ big + 1.
		cntxt _ self fetchWord: 0 ofObject: cntxt.
	].
	small _ 0.
	cntxt _ freeSmallContexts.
	[cntxt = NilContext] whileFalse: [
		small _ small + 1.
		cntxt _ self fetchWord: 0 ofObject: cntxt.
	].
	self print: 'Recycled contexts: '.
	self printNum: small; print: ' small, '.
	self printNum: big; print: ' large ('.
	self printNum: (big * LargeContextSize) + (small * SmallContextSize).
	self print: ' bytes)'.
	self cr.! !
!Interpreter methodsFor: 'image save/restore'!
byteSwapped: w
	"Return the given integer with its bytes in the reverse order."

	^ ((w bitShift: -24) bitAnd: 16rFF) +
	  ((w bitShift: -8) bitAnd: 16rFF00) +
	  ((w bitShift: 8) bitAnd: 16rFF0000) +
	  ((w bitShift: 24) bitAnd: 16rFF000000)
!
checkImageVersionFrom: f
	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."
	"This code is based on C code by Ian Piumarta."

	| expectedVersion version firstVersion |
	self var: #f declareC: 'FILE *f'.
	expectedVersion _ self imageFormatVersion.

	"check the version number"
	self fileSeek: f position: 0.
	version _ firstVersion _ self getLongFromFile: f swap: false.
	(version = expectedVersion) ifTrue: [^ false].

	"try with byte reversal"
	self fileSeek: f position: 0.
	version _ self getLongFromFile: f swap: true.
	(version = expectedVersion) ifTrue: [^ true].

	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"
	self fileSeek: f position: 512.
	version _ self getLongFromFile: f swap: false.
	(version = expectedVersion) ifTrue: [^ false].

	"try skipping the first 512 bytes with byte reversal"
	self fileSeek: f position: 512.
	version _ self getLongFromFile: f swap: true.
	(version = expectedVersion) ifTrue: [^ true].

	"hard failure; abort"
	self print: 'This interpreter (vers. '.
	self printNum: expectedVersion.
	self print: ' cannot read image file (vers. '.
	self printNum: firstVersion.
	self cr.
	self exit: -1.
!
fileSeek: f position: pos
	"Position the given file stream to the given offset from the start of the file."

	self var: #f declareC: 'FILE *f'.
	self cCode: 'fseek(f, pos, SEEK_SET)'.!
getLongFromFile: f swap: swapFlag
	"Return the next 4-byte word of the given file, byte-swapped according to the given flag."

	self var: #f declareC: 'FILE *f'.
	swapFlag ifTrue: [
		^ ((self cCode: 'fgetc(f)') bitShift: 24) +
		  ((self cCode: 'fgetc(f)') bitShift: 16) +
		  ((self cCode: 'fgetc(f)') bitShift: 8) +
		  ((self cCode: 'fgetc(f)') bitShift: 0)
	] ifFalse: [
		^ ((self cCode: 'fgetc(f)') bitShift: 0) +
		  ((self cCode: 'fgetc(f)') bitShift: 8) +
		  ((self cCode: 'fgetc(f)') bitShift: 16) +
		  ((self cCode: 'fgetc(f)') bitShift: 24)
	].
!
imageFormatVersion
	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."

	^ 6502!
positionOfFile: f
	"Return the current position of the given file stream."

	self var: #f declareC: 'FILE *f'.
	^ self cCode: 'ftell(f)'!
putLong: n toFile: f
	"Append the given 4-byte long word to the given file in this platforms 'natural' byte order. (Bytes will be swapped, if necessary, when the image is read on a different platform.) Set successFlag to false if the write fails."

	| wordsWritten |
	self var: #f declareC: 'FILE *f'.

	wordsWritten _ self cCode: 'fwrite(&n, sizeof(int), 1, f)'.
	self success: wordsWritten = 1.!
readImageFromFile: f HeapSize: desiredHeapSize
	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."
	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."
	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"

	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift |
	self var: #f declareC: 'FILE *f'.

	swapBytes _ self checkImageVersionFrom: f.
	headerStart _ (self positionOfFile: f) - 4.  "record header start position"

	headerSize			_ self getLongFromFile: f swap: swapBytes.
	dataSize				_ self getLongFromFile: f swap: swapBytes.
	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.
	specialObjectsOop		_ self getLongFromFile: f swap: swapBytes.
	lastHash			_ self getLongFromFile: f swap: swapBytes.
	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.

	lastHash = 0 ifTrue: [
		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"
		lastHash _ 999].

	"compare memory requirements with availability".
	minimumMemory _ dataSize + 80000.  "need at least 80K of breathing room"
	desiredHeapSize < minimumMemory
		ifTrue: [ self error: 'Insufficient memory for this image' ].

	"allocate a contiguous block of memory for the Squeak heap"
	memory _ self cCode: '(unsigned char *) malloc(desiredHeapSize)'.
	memory = nil
		ifTrue: [ self error: 'Failed to allocate memory for the heap' ].

	memStart _ self startOfMemory.
	memoryLimit _ (memStart + desiredHeapSize) - 24.  "decrease memoryLimit a tad for safety"
	endOfMemory _ memStart + dataSize.

	"position file after the header"
	self fileSeek: f position: headerStart + headerSize.

	"read in the image in bulk, then swap the bytes if necessary"
	bytesRead _ self cCode: 'fread(memory, sizeof(unsigned char), dataSize, f)'.
	bytesRead ~= dataSize
		ifTrue: [ self error: 'Read failed or premature end of image file' ].
	swapBytes ifTrue: [self reverseBytesInImage].

	"compute difference between old and new memory base addresses"
	bytesToShift _ memStart - oldBaseAddr.
	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"

	^ dataSize
!
reverseBytesInImage
	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."

	| addr lastAddr |
	addr _ self startOfMemory.
	lastAddr _ endOfMemory.
	[addr < lastAddr] whileTrue: [
		self longAt: addr put: (self byteSwapped: (self longAt: addr)).
		addr _ addr + 4.
	].
!
writeImageFile: imageBytes

	| headerStart headerSize f bytesWritten |
	self var: #f declareC: 'FILE *f'.

	"local constants"
	headerStart _ 0.  "change to 512 to leave room for a Unix exec string"
	headerSize _ 64.  "header size in bytes; do not change!!"

	f _ self cCode: 'fopen(imageName, "wb")'.
	f = nil ifTrue: [
		"could not open the image file for writing"
		self success: false.
		^ nil ].

	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.
	"position file to start of header"
	self fileSeek: f position: headerStart.

	self putLong: (self imageFormatVersion) toFile: f.
	self putLong: headerSize toFile: f.
	self putLong: imageBytes toFile: f.
	self putLong: (self startOfMemory) toFile: f.
	self putLong: specialObjectsOop toFile: f.
	self putLong: lastHash toFile: f.
	self putLong: (self ioScreenSize) toFile: f.
	successFlag ifFalse: [
		"write or seek failure"
		self cCode: 'fclose(f)'.
		^ nil ].

	"position file after the header"
	self fileSeek: f position: headerStart + headerSize.

	"write the image data"
	bytesWritten _ self cCode: 'fwrite(memory, sizeof(unsigned char), imageBytes, f)'.
	self success: bytesWritten = imageBytes.
	self cCode: 'fclose(f)'.

	"set Mac file type and creator; this is a noop on other platforms"
	self cCode: 'dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST")'.
! !
!Interpreter class methodsFor: 'initialization'!
initialize
	"Interpreter initialize"

	super initialize.  "initialize ObjectMemory constants"
	self initializeAssociationIndex.
	self initializeBytecodeTable.
	self initializeCharacterIndex.
	self initializeClassIndices.
	self initializeContextIndices.
	self initializeDirectoryLookupResultCodes.
	self initializeMessageIndices.
	self initializeMethodIndices.
	self initializePointIndices.
	self initializePrimitiveTable.
	self initializeSchedulerIndices.
	self initializeSmallIntegers.
	self initializeStreamIndices.

	MethodCacheEntries _ 512. 
	MethodCacheMask _ MethodCacheEntries - 1.
	(MethodCacheEntries bitAnd: MethodCacheMask) = 0
		ifFalse: [ self error: 'MethodCacheEntries must be a power of two' ].
	MethodCacheSize _ MethodCacheEntries * 4.
	CacheProbeMax _ 3.!
initializeAssociationIndex
	ValueIndex _ 1!
initializeBytecodeTable
	"Interpreter initializeBytecodeTable"
	"Note: This table will be used to generate a C switch statement."

	BytecodeTable _ Array new: 256.
	self table: BytecodeTable from:
	#(
		(  0  15 pushReceiverVariableBytecode)
		( 16  31 pushTemporaryVariableBytecode)
		( 32  63 pushLiteralConstantBytecode)
		( 64  95 pushLiteralVariableBytecode)
		( 96 103 storeAndPopReceiverVariableBytecode)
		(104 111 storeAndPopTemporaryVariableBytecode)
		(112 pushReceiverBytecode)
		(113 pushConstantTrueBytecode)
		(114 pushConstantFalseBytecode)
		(115 pushConstantNilBytecode)
		(116 pushConstantMinusOneBytecode)
		(117 pushConstantZeroBytecode)
		(118 pushConstantOneBytecode)
		(119 pushConstantTwoBytecode)
		(120 returnReceiver)
		(121 returnTrue)
		(122 returnFalse)
		(123 returnNil)
		(124 returnTopFromMethod)
		(125 returnTopFromBlock)
		(126 unknownBytecode)
		(127 unknownBytecode)
		(128 extendedPushBytecode)
		(129 extendedStoreBytecode)
		(130 extendedStoreAndPopBytecode)
		(131 singleExtendedSendBytecode)
		(132 doubleExtendedDoAnythingBytecode)
		(133 singleExtendedSuperBytecode)
		(134 secondExtendedSendBytecode)
		(135 popStackBytecode)
		(136 duplicateTopBytecode)
		(137 pushActiveContextBytecode)
		(138 143 unknownBytecode)
		(144 151 shortUnconditionalJump)
		(152 159 shortConditionalJump)
		(160 167 longUnconditionalJump)
		(168 171 longJumpIfTrue)
		(172 175 longJumpIfFalse)

		"176-191 were sendArithmeticSelectorBytecode"
		(176 bytecodePrimAdd)
		(177 bytecodePrimSubtract)
		(178 bytecodePrimLessThan)
		(179 bytecodePrimGreaterThan)
		(180 bytecodePrimLessOrEqual)
		(181 bytecodePrimGreaterOrEqual)
		(182 bytecodePrimEqual)
		(183 bytecodePrimNotEqual)
		(184 bytecodePrimMultiply)
		(185 bytecodePrimDivide)
		(186 bytecodePrimMod)
		(187 bytecodePrimMakePoint)
		(188 bytecodePrimBitShift)
		(189 bytecodePrimDiv)
		(190 bytecodePrimBitAnd)
		(191 bytecodePrimBitOr)	

		"192-207 were sendCommonSelectorBytecode"
		(192 bytecodePrimAt)
		(193 bytecodePrimAtPut)
		(194 bytecodePrimSize)
		(195 bytecodePrimNext)
		(196 bytecodePrimNextPut)
		(197 bytecodePrimAtEnd)
		(198 bytecodePrimEquivalent)
		(199 bytecodePrimClass)
		(200 bytecodePrimBlockCopy)
		(201 bytecodePrimValue)
		(202 bytecodePrimValueWithArg)
		(203 bytecodePrimDo)
		(204 bytecodePrimNew)
		(205 bytecodePrimNewWithArg)
		(206 bytecodePrimPointX)
		(207 bytecodePrimPointY)

		(208 255 sendLiteralSelectorBytecode)
	).!
initializeCharacterIndex
	CharacterValueIndex _ 0!
initializeClassIndices
	"Class Class"
	SuperclassIndex _ 0.
	MessageDictionaryIndex _ 1.
	InstanceSpecificationIndex _ 2.
	"Fields of a message dictionary"
	MethodArrayIndex _ 1.
	SelectorStart _ 2!
initializeContextIndices
	"Class MethodContext"
	SenderIndex _ 0.
	InstructionPointerIndex _ 1.
	StackPointerIndex _ 2.
	MethodIndex _ 3.
	ReceiverIndex _ 5.
	TempFrameStart _ 6.
	"Class BlockContext"
	CallerIndex _ 0.
	BlockArgumentCountIndex _ 3.
	InitialIPIndex _ 4.
	HomeIndex _ 5!
initializeDirectoryLookupResultCodes

	DirEntryFound _ 0.
	DirNoMoreEntries _ 1.
	DirBadPath _ 2.!
initializeMessageIndices
	MessageSelectorIndex _ 0.
	MessageArgumentsIndex _ 1.
	MessageSize _ 2!
initializeMethodIndices
	"Class CompiledMethod"
	HeaderIndex _ 0.
	LiteralStart _ 1!
initializePointIndices
	XIndex _ 0.
	YIndex _ 1!
initializePrimitiveTable
	"Interpreter initializePrimitiveTable"
	"Note: This table will be used to generate a C switch statement."

	PrimitiveTable _ Array new: 256.
	self table: PrimitiveTable from: 
	#(
		"Integer Primitives (0-19)"
		(0 primitiveFail)
		(1 primitiveAdd)
		(2 primitiveSubtract)
		(3 primitiveLessThan)
		(4 primitiveGreaterThan)
		(5 primitiveLessOrEqual)
		(6 primitiveGreaterOrEqual)
		(7 primitiveEqual)
		(8 primitiveNotEqual)
		(9 primitiveMultiply)
		(10 primitiveDivide)
		(11 primitiveMod)
		(12 primitiveDiv)
		(13 primitiveQuo)
		(14 primitiveBitAnd)
		(15 primitiveBitOr)
		(16 primitiveBitXor)
		(17 primitiveBitShift)
		(18 primitiveMakePoint)
		(19 primitiveFail)

		"LargeInteger Primitives (20-39)"
		"32-bit logic is aliased to Integer prims above"
		(20 39 primitiveFail)

		"Float Primitives (40-59)"
		(40 primitiveAsFloat)
		(41 primitiveFloatAdd)
		(42 primitiveFloatSubtract)
		(43 primitiveFloatLessThan)
		(44 primitiveFloatGreaterThan)
		(45 primitiveFloatLessOrEqual)
		(46 primitiveFloatGreaterOrEqual)
		(47 primitiveFloatEqual)
		(48 primitiveFloatNotEqual)
		(49 primitiveFloatMultiply)
		(50 primitiveFloatDivide)
		(51 primitiveTruncated)
		(52 primitiveFractionalPart)
		(53 primitiveExponent)
		(54 primitiveTimesTwoPower)
		(55 primitiveSquareRoot)
		(56 primitiveSine)
		(57 primitiveArctan)
		(58 primitiveLogN)
		(59 primitiveExp)

		"Subscript and Stream Primitives (60-67)"
		(60 primitiveAt)
		(61 primitiveAtPut)
		(62 primitiveSize)
		(63 primitiveStringAt)
		(64 primitiveStringAtPut)
		(65 primitiveNext)
		(66 primitiveNextPut)
		(67 primitiveAtEnd)

		"StorageManagement Primitives (68-79)"
		(68 primitiveObjectAt)
		(69 primitiveObjectAtPut)
		(70 primitiveNew)
		(71 primitiveNewWithArg)
		(72 primitiveFail)					"Blue Book: primitiveBecome"
		(73 primitiveInstVarAt)
		(74 primitiveInstVarAtPut)
		(75 primitiveAsOop)
		(76 primitiveFail)					"Blue Book: primitiveAsObject"
		(77 primitiveSomeInstance)
		(78 primitiveNextInstance)
		(79 primitiveNewMethod)

		"Control Primitives (80-89)"
		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"
		(81 primitiveValue)
		(82 primitiveValueWithArgs)
		(83 primitivePerform)
		(84 primitivePerformWithArgs)
		(85 primitiveSignal)
		(86 primitiveWait)
		(87 primitiveResume)
		(88 primitiveSuspend)
		(89 primitiveFlushCache)

		"Input/Output Primitives (90-109)"
		(90 primitiveMousePoint)
		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"
		(92 primitiveFail)					"Blue Book: primitiveCursorLink"
		(93 primitiveInputSemaphore)
		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"
		(95 primitiveInputWord)
		(96 primitiveCopyBits)
		(97 primitiveSnapshot)
		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"
		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"
		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"
		(101 primitiveBeCursor)
		(102 primitiveBeDisplay)
		(103 primitiveScanCharacters)
		(104 primitiveDrawLoop)
		(105 primitiveStringReplace)
		(106 primitiveScreenSize)
		(107 primitiveMouseButtons)
		(108 primitiveKbdNext)
		(109 primitiveKbdPeek)

		"System Primitives (110-119)"
		(110 primitiveEquivalent)
		(111 primitiveClass)
		(112 primitiveBytesLeft)
		(113 primitiveQuit)
		(114 primitiveExitToDebugger)
		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"
		(116 primitiveFail)
		(117 primitiveFail)
		(118 primitiveFail)
		(119 primitiveFail)

		"Miscellaneous Primitives (120-127)"
		(120 primitiveFail)
		(121 primitiveImageName)
		(122 primitiveNoop)				"Blue Book: primitiveImageVolume"
		(123 primitiveFail)
		(124 primitiveLowSpaceSemaphore)
		(125 primitiveSignalAtBytesLeft)
		(126 primitiveFail)
		(127 primitiveFail)

		"AppleSmalltalk Primitives Start Here"

		"Apple Miscellaneous Primitives (128-149)"
		(128 primitiveArrayBecome)
		(129 primitiveSpecialObjectsOop)
		(130 primitiveFullGC)
		(131 primitiveIncrementalGC)
		(132 primitiveObjectPointsTo)
		(133 primitiveSetInterruptKey)
		(134 primitiveInterruptSemaphore)
		(135 primitiveMillisecondClock)
		(136 primitiveSignalAtMilliseconds)
		(137 primitiveSecondsClock)
		(138 primitiveSomeObject)
		(139 primitiveNextObject)
		(140 primitiveBeep)
		(141 primitiveClipboardText)
		(142 primitiveVMPath)
		(143 primitiveShortAt)
		(144 primitiveShortAtPut)
		(145 primitiveConstantFill)
		(146 primitiveReadJoystick)
		(147 primitiveWarpBits)
		(148 primitiveClone)
		(149 primitiveFail)

		"File Primitives (150-169)"
		(150 primitiveFileAtEnd)
		(151 primitiveFileClose)
		(152 primitiveFileGetPosition)
		(153 primitiveFileOpen)
		(154 primitiveFileRead)
		(155 primitiveFileSetPosition)
		(156 primitiveFileDelete)
		(157 primitiveFileSize)
		(158 primitiveFileWrite)
		(159 primitiveFileRename)
		(160 primitiveDirectoryCreate)
		(161 primitiveDirectoryDelimitor)
		(162 primitiveDirectoryLookup)
		(163 168 primitiveFail)
		(169 primitiveDirectorySetMacTypeAndCreator)

		"Sound Primitives (170-199)"
		(170 primitiveSoundStart)
		(171 primitiveFail)
		(172 primitiveSoundStop)
		(173 primitiveSoundAvailableSpace)
		(174 primitiveSoundPlaySamples)
		(175 primitiveSoundPlaySilence)
		(176 primWaveTableSoundmixSampleCountintostartingAtpan)
		(177 primFMSoundmixSampleCountintostartingAtpan)
		(178 primPluckedSoundmixSampleCountintostartingAtpan)
		(179 199 primitiveFail)

		"Unimplemented Primitives (200-249)"
		(200 249 primitiveFail)

		"VM Implementor Primitives (250-255)"
		(250 clearProfile)
		(251 dumpProfile)
		(252 startProfiling)
		(253 stopProfiling)
		(254 primitiveFail)
		(255 primitiveFail)
	).!
initializeSchedulerIndices
	"Class ProcessorScheduler"
	ProcessListsIndex _ 0.
	ActiveProcessIndex _ 1.
	"Class LinkedList"
	FirstLinkIndex _ 0.
	LastLinkIndex _ 1.
	"Class Semaphore"
	ExcessSignalsIndex _ 2.
	"Class Link"
	NextLinkIndex _ 0.
	"Class Process"
	SuspendedContextIndex _ 1.
	PriorityIndex _ 2.
	MyListIndex _ 3!
initializeSmallIntegers
	"SmallIntegers"
	ConstMinusOne _ Interpreter new integerObjectOf: -1.
	ConstZero _ Interpreter new integerObjectOf: 0.
	ConstOne _ Interpreter new integerObjectOf: 1.
	ConstTwo _ Interpreter new integerObjectOf: 2!
initializeStreamIndices
	StreamArrayIndex _ 0.
	StreamIndexIndex _ 1.
	StreamReadLimitIndex _ 2.
	StreamWriteLimitIndex _ 3.!
table: anArray from: specArray
	"SpecArray is an array of either (index selector) or (index1 index2 selector)."

	| contiguous |
	contiguous _ 0.
	specArray do: [ :spec |
		(spec at: 1) = contiguous ifFalse: [ self error: 'Non-contiguous table entry' ].
		spec size = 2 ifTrue: [
			anArray at: ((spec at: 1) + 1) put: (spec at: 2).
			contiguous _ contiguous + 1.
		] ifFalse: [
			(spec at: 1) to: (spec at: 2) do: [ :i | anArray at: (i + 1) put: (spec at: 3) ].
			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.
		].
	].! !
!Interpreter class methodsFor: 'constants'!
bytecodeTable

	^ BytecodeTable!
primitiveTable

	^ PrimitiveTable! !
!Interpreter class methodsFor: 'translation'!
declareCVarsIn: aCCodeGenerator

	aCCodeGenerator var: 'methodCache'
		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.
	aCCodeGenerator var: 'currentBytecode'
		declareC: 'unsigned char currentBytecode'.
!
patchInterp: fileName
	"Interpreter patchInterp: 'Squeak VM PPC'"
	"This will patch out the unneccesary range check (a compare
	 and branch) in the inner interpreter dispatch loop."
	"NOTE: You must edit in the Interpeter file name, and the
	 number of instructions (delta) to count back to find the compare
	 and branch that we want to get rid of."

	| delta f code len remnant i |
	delta _ 6.
	f _ FileStream fileNamed: fileName.
	f binary.
	code _ Bitmap new: (len _ f size) // 4.
	f nextInto: code.
	remnant _ f next: len - (code size * 4).
	i _ 0.
	["Look for a BCTR instruction"
	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [
		"Look for a CMPLWI FF, 6 instrs back"
	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [
	       	"Copy dispatch instrs back over the compare"
			SelectionMenu notify: 'Patching at ', i hex.
			0 to: delta - 2 do: [ :j |
				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).
			].
		].
	].
	f position: 0; nextPutAll: code; nextPutAll: remnant.
	f close.
!
translate: fileName doInlining: inlineFlag
	"Time millisecondsToRun: [
		Interpreter translate: 'InterpTest.c' doInlining: true.
		Smalltalk beep]"
	| cg |
	BitBltSimulation initialize.
	Interpreter initialize.
	ObjectMemory initialize.
	cg _ CCodeGenerator new initialize.
	cg addClass: BitBltSimulation.
	cg addClass: Interpreter.
	cg addClass: ObjectMemory.
	BitBltSimulation declareCVarsIn: cg.
	Interpreter declareCVarsIn: cg.
	ObjectMemory declareCVarsIn: cg.
	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !

InterpreterSimulator comment:
'This class defines basic memory access and primitive simulation so that the Interpreter can run simulated in the Squeak environment.  It also defines a number of handy object viewing methods to facilitate pawing around in the object memory.

To see the thing actually run, you could (after backing up this image and changes), execute

	(InterpreterSimulator new openOn: Smalltalk imageName) test

and be patient both to wait for things to happen, and to accept various things that may go wrong depending on how large or unusual your image may be.  We usually do this with a small and simple benchmark image.'!
!InterpreterSimulator methodsFor: 'initialization'!
close  "close any files that ST may have opened"
	filesOpen do: [:f | f setToEnd; close]!
initialize
	"Initialize the InterpreterSimulator when running the interpreter inside Smalltalk. The primary responsibility of this method is to allocate Smalltalk Arrays for variables that will be declared as statically-allocated global arrays in the translated code."

	"initialize class variables"
	ObjectMemory initialize.
	Interpreter initialize.

	methodCache _ Array new: MethodCacheSize.
	rootTable _ Array new: RootTableSize.
	remapBuffer _ Array new: RemapBufferSize.

	"initialize InterpreterSimulator variables used for debugging"
	byteCount _ 0.
	sendCount _ 0.
	traceOn _ true.
	myBitBlt _ BitBltSimulation new setInterpreter: self.
	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"
	filesOpen _ OrderedCollection new.
!
nextLongFrom: aStream
	"Read a 32-bit quantity from the given (binary) stream."
	| bytes |
	bytes _ aStream nextInto: (ByteArray new: 4).
	^ Integer
		byte1: (bytes at: 4)
		byte2: (bytes at: 3)
		byte3: (bytes at: 2)
		byte4: (bytes at: 1)!
openOn: fileName
	"(InterpreterSimulator new openOn: 'clonex.image') test"

	self openOn: fileName extraMemory: 500000.!
openOn: fileName extraMemory: extraBytes
	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"

	| f version headerSize count oldBaseAddr bytesToShift |
	"open image file and read the header"
	f _ FileStream oldFileNamed: fileName.
	imageName _ f fullName.
	f binary; readOnly.
	version _ self nextLongFrom: f.  "current version: 6501"
	headerSize _ self nextLongFrom: f.
	endOfMemory _ self nextLongFrom: f.  "first unused location in heap"
	oldBaseAddr _ self nextLongFrom: f.  "object memory base address of image"
	specialObjectsOop _ self nextLongFrom: f.
	lastHash _ 999.  "Should be loaded from, and saved to the image header"

	"allocate interpreter memory"
	memoryLimit _ endOfMemory + extraBytes.

	"read in the image"
	f position: headerSize.
	memory _ Bitmap new: memoryLimit // 4.
	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.
	count ~= (endOfMemory // 4) ifTrue: [self halt].
	f close.
	self initialize.
	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"
	endOfMemory _ endOfMemory.
	self initializeInterpreter: bytesToShift.
	checkAssertions _ false.!
startOfMemory
	"Return the start of object memory."

	^ 0! !
!InterpreterSimulator methodsFor: 'testing'!
findNewMethodInClass: class
"
	| cName |
	traceOn ifTrue:
		[cName _ (self sizeBitsOf: class) = 16r20
			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]
			ifFalse: [(self nameOfClass: class)].
		self cr; print: cName , '>>' , (self stringOf: messageSelector)].
"
"
(self stringOf: messageSelector) = 'raisedToInteger:' ifTrue: [self halt].
"
	sendCount _ sendCount + 1.
	super findNewMethodInClass: class.!
profile: nBytecodes
	"(InterpreterSimulator new openOn: 'clonex.image') profile: 60000"
	Transcript clear.
	byteCount _ 0.
	MessageTally spyOn: [
		self internalizeIPandSP.
		[byteCount < nBytecodes] whileTrue: [
			currentBytecode _ self fetchByte.
			self dispatchOn: currentBytecode in: BytecodeTable.
			byteCount _ byteCount + 1.
		].
		self externalizeIPandSP.
	].!
profileSends: nBytecodes
	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"
	Transcript clear.
	byteCount _ 0.
	MessageTally tallySendsTo: self inBlock: [
		self internalizeIPandSP.
		[byteCount < nBytecodes] whileTrue: [
			currentBytecode _ self fetchByte.
			self dispatchOn: currentBytecode in: BytecodeTable.
			byteCount _ byteCount + 1.
		].
		self externalizeIPandSP.
	] showTree: true.!
test

	Transcript clear.
	byteCount _ 0.
	self internalizeIPandSP.
	[true] whileTrue: [
		currentBytecode _ self fetchByte.
		self dispatchOn: currentBytecode in: BytecodeTable.
		byteCount _ byteCount + 1.
	].
	self externalizeIPandSP.
!
testBecome
	"Become some young things.  AA testBecome    "
	| array list1 list2 p1 p2 p3 p4 |
	array _ self splObj: ClassArray.
	list1 _ self instantiateClass: array indexableSize: 2.
	list2 _ self instantiateClass: array indexableSize: 2.
	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.
	self push: p1.
	self storePointer: 0 ofObject: list1 withValue: p1.
	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.
	self push: p2.
	self storePointer: 1 ofObject: list1 withValue: p2.
	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.
	self push: p3.
	self storePointer: 0 ofObject: list2 withValue: p3.
	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.
	self push: p4.
	self storePointer: 1 ofObject: list2 withValue: p4.
	(self become: list1 with: list2) ifFalse: [self error: 'failed'].
	self popStack = p2 ifFalse: [self halt].
	self popStack = p1 ifFalse: [self halt].
	self popStack = p4 ifFalse: [self halt].
	self popStack = p3 ifFalse: [self halt].
	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].
	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].
	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].
	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].!
validate
	| oop prev |
	Transcript show: 'Validating...'.
	oop _ self firstObject.
	[oop < endOfMemory] whileFalse: [
		self validate: oop.
		prev _ oop.  "look here if debugging prev obj overlapping this one"
		oop _ self objectAfter: oop.
	].
	Transcript show: 'done.'; cr!
validate: oop
	| header type cc sz fmt nextChunk | 
	header _ self longAt: oop.
	type _ header bitAnd: 3.
	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].
	sz _ (header >> 2) bitAnd: 16r3F.
	(sz = 1) & (type = 3) ifTrue: [self halt].	"object only 4 bytes long"
	(sz = 1) & (type = 0) ifTrue: [self halt].	"object only 4 bytes long"
	(self isFreeObject: oop)
		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]
		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].
	nextChunk > endOfMemory
		ifTrue: [oop = endOfMemory ifFalse: [self halt]].
	(self headerType: nextChunk) = 0 ifTrue: [
		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].
	(self headerType: nextChunk) = 1 ifTrue: [
		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].
	type = 2 ifTrue:
		["free block" ^ self].
	fmt _ (header >> 8) bitAnd: 16rF.
	cc _ (header >> 12) bitAnd: 31.
	cc > 15 ifTrue: [self halt].
	type = 0 ifTrue:
		["three-word header"
		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].
		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].
		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"
		sz = 0 ifFalse: [self halt]].
	type = 1 ifTrue:
		["two-word header"
		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].
		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].
		sz = 0 ifTrue: [self halt]].
	type = 3 ifTrue:
		["one-word header"
		cc = 0 ifTrue: [self halt].
		sz <= 1 ifTrue: [self halt]].
	fmt = 0 ifTrue: [self halt].
	fmt = 4 ifTrue: [self halt].
	fmt = 5 ifTrue: [self halt].
	fmt = 7 ifTrue: [self halt].
	fmt >= 12 ifTrue:
		["CompiledMethod -- check for integer header"
		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].!
validateActiveContext
	self validateOopsIn: activeContext.	"debug -- test if messed up"!
validateOopsIn: object
	| fieldPtr limit former header | 
	"for each oop in me see if it is legal"
	fieldPtr _ object + BaseHeaderSize.	"first field"
	limit _ object + (self lastPointerOf: object).	"a good field"
	[fieldPtr > limit] whileFalse: [
		former _ self longAt: fieldPtr.
		self validOop: former.
		fieldPtr _ fieldPtr + 4].
	"class"
	header _ self baseHeader: object.
	(header bitAnd: 16r1F000 "compact class bits") = 0 ifTrue: [	
		former _ (self classHeader: object) bitAnd: 16rFFFFFFFC.
		self validOop: former].!
validOop: oop
	"halt if invalid active object"
	(oop bitAnd: 1) = 1 ifTrue: [^ self].
	(oop bitAnd: 3) = 0 ifFalse: [self halt].
	oop >= endOfMemory ifTrue: [self halt].
	"could test if within the first large freeblock"
	(self longAt: oop) = 4 ifTrue: [self halt].
	(self headerType: oop) = 2 ifTrue: [self halt].	"free object"! !
!InterpreterSimulator methodsFor: 'debug printing'!
cr

	traceOn ifTrue: [ Transcript cr; endEntry ].!
print: s

	traceOn ifTrue: [ Transcript show: s ]!
printChar: aByte

	traceOn ifTrue: [ Transcript nextPut: aByte asCharacter ].!
printNum: anInteger

	traceOn ifTrue: [ Transcript show: anInteger printString ].! !
!InterpreterSimulator methodsFor: 'debug support'!
charsOfLong: long
	^ (4 to: 1 by: -1) collect:
		[:i | ((long digitAt: i) between: 14 and: 126)
					ifTrue: [(long digitAt: i) asCharacter]
					ifFalse: [$?]]!
classAndSelectorOfMethod: meth forReceiver: rcvr
	| mClass dict length methodArray |
	mClass _ self fetchClassOf: rcvr.
	[dict _ self fetchPointer: MessageDictionaryIndex ofObject: mClass.
	length _ self fetchWordLengthOf: dict.
	methodArray _ self fetchPointer: MethodArrayIndex ofObject: dict.
	0 to: length-SelectorStart-1 do: 
		[:index | 
		meth = (self fetchPointer: index ofObject: methodArray) 
			ifTrue: [^ Array
				with: mClass
				with: (self fetchPointer: index + SelectorStart ofObject: dict)]].
	mClass _ self fetchPointer: SuperclassIndex ofObject: mClass.
	mClass = nilObj]
		whileFalse: [].
	^ Array
		with: (self fetchClassOf: rcvr)
		with: (self splObj: SelectorDoesNotUnderstand)!
compactClassAt: ccIndex
	"Index must be between 1 and compactClassArray size. (A zero compact class index in the base header indicate that the class is in the class header word.)"

	| classArray |
	classArray _ self fetchPointer: CompactClasses ofObject: specialObjectsOop.
	^ self fetchPointer: (ccIndex - 1) ofObject: classArray!
dumpHeader: hdr
	| cc |
	^ String streamContents:
		[:strm |
		strm nextPutAll: '<cc=', (cc_ (hdr >> 12) bitAnd: 16r1F) hex.
			cc > 0 ifTrue:
				[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].
			strm nextPutAll: '>'.
		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.
		strm nextPutAll: '<sz=', (hdr bitAnd: 16rFC) hex , '>'.
		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>'.
		]!
dumpMethodHeader: hdr
	^ String streamContents:
		[:strm |
		strm nextPutAll: '<nArgs=', ((hdr >> 25) bitAnd: 16r1F) printString , '>'.
		strm nextPutAll: '<nTemps=', ((hdr >> 19) bitAnd: 16r3F) printString , '>'.
		strm nextPutAll: '<lgCtxt=', ((hdr >> 18) bitAnd: 16r1) printString , '>'.
		strm nextPutAll: '<nLits=', ((hdr >> 10) bitAnd: 16rFF) printString , '>'.
		strm nextPutAll: '<prim=', ((hdr >> 1) bitAnd: 16r1FF) printString , '>'.
		]!
headerStart: oop

	^ (self extraHeaderBytes: oop) negated!
hexDump100: oop
	| byteSize val |
	^ String streamContents:
		[:strm |
		byteSize _ 256.
		(self headerStart: oop) to: byteSize by: 4 do:
			[:a | val _ self longAt: oop+a.
			strm cr; nextPutAll: (oop+a) hex8; space; space; 
				nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 
				space; space; space; nextPutAll: val hex8;
				space; space.
			strm nextPutAll: (self charsOfLong: val).
			strm space; space; nextPutAll: (oop+a) printString]]!
hexDump: oop
	| byteSize val |
	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].
	^ String streamContents:
		[:strm |
		byteSize _ 256 min: (self sizeBitsOf: oop)-4.
		(self headerStart: oop) to: byteSize by: 4 do:
			[:a | val _ self longAt: oop+a.
			strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 
				space; space; space; nextPutAll: val hex8;
				space; space.
			a=0
				ifTrue: [strm nextPutAll: (self dumpHeader: val)]
				ifFalse: [strm nextPutAll: (self charsOfLong: val)]]]!
longPrint: oop
	| lastPtr val lastLong hdrType prevVal |
	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].
	^ String streamContents:
		[:strm |
		lastPtr _ 256 min: (self lastPointerOf: oop).
		hdrType _ self headerType: oop.
		hdrType = 2 ifTrue: [lastPtr _ 0].
		prevVal _ 0.
		(self headerStart: oop) to: lastPtr by: 4 do:
			[:a | val _ self longAt: oop+a.
			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])
			ifTrue:
			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]
			ifFalse:
			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 
				space; space; space; nextPutAll: val hex8; space; space.
			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].
			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].
			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].
			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].
			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:
							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].
			prevVal _ val].
		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.
		hdrType = 2
			ifTrue: ["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;
				space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]
			ifFalse: [lastPtr+4 to: lastLong by: 4 do:
				[:a | val _ self longAt: oop+a.
				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 
					space; space; space.
				strm nextPutAll: val hex8; space; space;
						nextPutAll: (self charsOfLong: val)]].
	]!
nameOfClass: classOop
	(self sizeBitsOf: classOop) = 16r20 ifTrue:
		[^ (self nameOfClass:
				(self fetchPointer: 6 "thisClass" ofObject: classOop)) , ' class'].
	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)!
printStack
	| ctxt classAndSel home |
	ctxt _ activeContext.
	^ String streamContents:
		[:strm |
			[home _ (self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)
				ifTrue: [self fetchPointer: HomeIndex ofObject: ctxt]
				ifFalse: [ctxt].
			classAndSel _ self
				classAndSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)
				forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).
			strm cr; nextPutAll: ctxt hex8.
			ctxt = home ifFalse: [strm nextPutAll: ' [] in'].
			strm space; nextPutAll: (self nameOfClass: classAndSel first).
			strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).
			(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]
				whileFalse: [].
		]!
shortPrint: oop
	| name classOop |
	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , ' (' , (self integerValueOf: oop) hex , ')'].
	classOop _ self fetchClassOf: oop.
	(self sizeBitsOf: classOop) =16r20 ifTrue: [^ 'class ' , (self nameOfClass: oop)].
	name _ self nameOfClass: classOop.
	name size = 0 ifTrue: [name _ '??'].
	name = 'String' ifTrue: [^ (self stringOf: oop) printString].
	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].
	name = 'Character' ifTrue: [^ '=' ,
			(Character value: (self integerValueOf: (self fetchPointer: 0 ofObject: oop))) printString].
	name = 'UndefinedObject' ifTrue: [^ 'nil'].
	name = 'False' ifTrue: [^ 'false'].
	name = 'True' ifTrue: [^ 'true'].
	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].
	name = 'Association' ifTrue: [^ '(' ,
				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,
				' -> ' ,
				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].
	('AEIOU' includes: name first)
		ifTrue: [^ 'an ' , name]
		ifFalse: [^ 'a ' , name]!
stringOf: oop
	| size long nLongs chars |
	^ String streamContents:
		[:strm |
		size _ 100 min: (self stSizeOf: oop).
		nLongs _ size-1//4+1.
		1 to: nLongs do:
			[:i | long _ self longAt: oop + BaseHeaderSize + (i-1*4).
			chars _ self charsOfLong: long.
			strm nextPutAll: (i=nLongs
							ifTrue: [chars copyFrom: 1 to: size-1\\4+1]
							ifFalse: [chars])]]! !
!InterpreterSimulator methodsFor: 'interpreter shell'!
fetchByte

	^ self byteAt: (localIP _ localIP + 1).!
isIntegerValue: valueWord 
	^ valueWord >= 16r-40000000 and: [valueWord <= 16r3FFFFFFF]! !
!InterpreterSimulator methodsFor: 'translation support'!
cCode: codeString
	"For translation only; noop when running in Smalltalk."!
dispatchOn: anInteger in: selectorArray
	"Simulate a case statement via selector table lookup.
	The given integer must be between 0 and selectorArray size-1, inclusive.
	For speed, no range test is done, since it is done by the at: operation."

	"assert: (anInteger >= 0) | (anInteger < selectorArray size)"
"
Transcript cr; show: anInteger hex , '  ' , (selectorArray at: (anInteger + 1)).
Sensor waitButton.
Sensor yellowButtonPressed ifTrue: [self halt].
"
	self perform: (selectorArray at: (anInteger + 1)).!
returnTypeC: typeString
	"For translation only; noop when running in Smalltalk."!
var: varSymbol declareC: declString
	"For translation only; noop when running in Smalltalk."! !
!InterpreterSimulator methodsFor: 'I/O primitives'!
ioProcessEvents!
primitiveBeCursor
	"Take note of the current cursor"
	| cursorObj bitsObj offsetObj ourCursor |
	cursorObj _ self stackTop.
	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 4]).
	successFlag ifTrue:
		[bitsObj _ self fetchPointer: 0 ofObject: cursorObj.
		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.
		ourCursor _ Cursor
			extent: (self fetchInteger: 1 ofObject: cursorObj)@(self fetchInteger: 2 ofObject: cursorObj)
			fromArray: ((1 to: 16) collect: [:i |
					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])
			offset: (self fetchInteger: 0 ofObject: offsetObj)@(self fetchInteger: 1 ofObject: offsetObj)].
	successFlag
		ifTrue: [ourCursor show]
		ifFalse: [self primitiveFail].!
primitiveBeDisplay
	"Extended to create a scratch Form for use by showDisplayBits."

	| rcvr destWidth destHeight destDepth |
	rcvr _ self stackTop.
	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).
	successFlag ifTrue: [
		destWidth _ self fetchInteger: 1 ofObject: rcvr.
		destHeight _ self fetchInteger: 2 ofObject: rcvr.
		destDepth _ self fetchInteger: 3 ofObject: rcvr.
	].
	successFlag ifTrue: [
		"create a scratch form the same size as Smalltalk displayObj"
		displayForm _ Form extent: destWidth @ destHeight
							depth: destDepth.
	].
	super primitiveBeDisplay.!
primitiveKbdNext

	self pop: 1.
	Sensor keyboardPressed
		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]
		ifFalse: [self push: nilObj]!
primitiveKbdPeek

	self pop: 1.
	Sensor keyboardPressed
		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]
		ifFalse: [self push: nilObj]!
primitiveMouseButtons

	| rcvr relPt buttons |
	self pop: 1.
	buttons _ 0.
	Sensor redButtonPressed ifTrue: [buttons _ buttons + 4].
	Sensor yellowButtonPressed ifTrue: [buttons _ buttons + 2].
	Sensor blueButtonPressed ifTrue: [buttons _ buttons + 1].
	self pushInteger: buttons!
primitiveMousePoint

	| relPt |
	self pop: 1.
	displayForm == nil
		ifTrue: [self push: (self makePointwithxValue: 99 yValue: 66)]
		ifFalse: [relPt _ Sensor cursorPoint - (Display extent - displayForm extent - (10@10)).
				self push: (self makePointwithxValue: relPt x yValue: relPt y)]!
primitiveScreenSize  "Dummied for now"

	self pop: 1.
	self push: (self makePointwithxValue: 640 yValue: 480).!
showDisplayBits
	| displayObj destBits sRaster dRaster destDepth pixPerWord srcWord destWord |
	displayObj _ self splObj: TheDisplay.
	destBits _ self fetchPointer: 0 ofObject: displayObj.
	destDepth _ self fetchInteger: 3 ofObject: displayObj.
	pixPerWord _ 32 // destDepth.
	sRaster _ displayForm width + (pixPerWord-1) // pixPerWord * 4.
	dRaster _ sRaster // 4.
	myBitBlt affectedTop to: myBitBlt affectedBottom - 1 do:
		[:y | 
		srcWord _ destBits + 4 + (y * sRaster).
		destWord _ y*dRaster.
		1 to: dRaster do: 
			[:i | displayForm bits at: destWord + i put: (self longAt: srcWord).
			srcWord _ srcWord + 4]].
	Display border: ((displayForm boundingBox expandBy: 2)
						translateBy: self displayLocation) width: 2.
	displayForm displayAt: self displayLocation! !
!InterpreterSimulator methodsFor: 'I/O primitives support'!
copyBits

	^ myBitBlt copyBits!
displayLocation

	^ Display extent - displayForm extent - (10@10)!
drawLoopX: xDelta Y: yDelta

	^ myBitBlt drawLoopX: xDelta Y: yDelta!
ioMSecs
	"Return the value of the millisecond clock."

	^ Time millisecondClockValue!
ioProcessEventsEveryMSecs: mSecs
	"Noop during simulation."!
loadBitBltFrom: bbObj

	^ myBitBlt loadBitBltFrom: bbObj!
loadScannerFrom: bbObj
	start: start stop: stop string: string rightX: rightX
	stopArray: stopArray displayFlag: displayFlag

	^ myBitBlt loadScannerFrom: bbObj
		start: start stop: stop string: string rightX: rightX
		stopArray: stopArray displayFlag: displayFlag!
scanCharacters

	^ myBitBlt scanCharacters!
stopReason

	^ myBitBlt stopReason!
targetForm

	^ myBitBlt targetForm! !
!InterpreterSimulator methodsFor: 'file primitives'!
asciiDirectoryDelimiter
	^ FileDirectory pathNameDelimiter asciiValue!
fileValueOf: integerPointer
	"Convert the (integer) fileID to the actual fileStream it uses"
	self success: (self isIntegerObject: integerPointer).
	successFlag
		ifTrue: [^ filesOpen at: (self integerValueOf: integerPointer)]
		ifFalse: [^ nil]!
primitiveFileDelete

	| namePointer |
	namePointer _ self stackTop.
	self success: (self isBytes: namePointer).
	self success: (FileDirectory includesKey: (self stringOf: namePointer)).
	successFlag ifTrue: [
		FileDirectory removeKey: (self stringOf: namePointer) ifAbsent: [].
	].
	successFlag ifTrue: [
		self pop: 1.  "fileName; leave rcvr on stack"
	].!
primitiveFileOpen
	| namePointer writeFlag fileName |
	writeFlag _ self booleanValueOf: self stackTop.
	namePointer _ self stackValue: 1.
	self success: (self isBytes: namePointer).
	successFlag ifTrue:
		[fileName _ self stringOf: namePointer.
		filesOpen addLast: (writeFlag
			ifTrue: [(FileStream fileNamed: fileName) binary]
			ifFalse: [(FileDirectory default includesKey: fileName)
				ifTrue: [(FileStream oldFileNamed: fileName) readOnly; binary]
				ifFalse: [^ self primitiveFail]]).
		self pop: 3.  "rcvr, name, write"
		self pushInteger: filesOpen size]!
primitiveFileRename

	| oldNamePointer newNamePointer f |
	oldNamePointer _ self stackTop.
	newNamePointer _ self stackValue: 1.
	self success: (self isBytes: oldNamePointer).
	self success: (self isBytes: newNamePointer).
	self success: (FileDirectory includesKey: (self stringOf: oldNamePointer)).
	self success: (FileDirectory includesKey: (self stringOf: newNamePointer)) not.
	successFlag ifTrue: [
		f _ FileStream oldFileNamed: (self stringOf: oldNamePointer).
		f rename: (self stringOf: newNamePointer).
		f close.
	].
	successFlag ifTrue: [
		self pop: 2.  "oldName, newName; leave rcvr on stack"
	].!
primitiveImageName
	"Note: For now, this only implements getting, not setting, the image file name."
	| result imageNameSize |
	self pop: 1.
	imageNameSize _ imageName size.
	result _ self instantiateClass: (self splObj: ClassString)
				   indexableSize: imageNameSize.
	1 to: imageNameSize do:
		[:i | self storeByte: i-1 ofObject: result
			withValue: (imageName at: i) asciiValue].
	self push: result.!
sqFile: file Read: count Into: byteArrayIndex At: startIndex

	startIndex to: (startIndex + count - 1) do: [ :i |
		file atEnd ifTrue: [ ^ i - startIndex ].
		self byteAt: byteArrayIndex + i put: file next.
	].
	^ count!
sqFile: file SetPosition: newPosition

	file position: newPosition.!
sqFile: file Write: count From: byteArrayIndex At: startIndex

	startIndex to: (startIndex + count - 1) do: [ :i |
		file nextPut: (self byteAt: byteArrayIndex + i).
	].
	^ count!
sqFileAtEnd: file

	^ file atEnd!
sqFileClose: file

	file close.!
sqFileGetPosition: file

	^ file position!
sqFileSize: file

	^ file size!
vmPathGet: stringBase Length: stringSize
	| pathName stringOop |
	pathName _ Smalltalk vmPath.
	stringOop _ stringBase - BaseHeaderSize. "Due to C call in Interp"
	1 to: stringSize do:
		[:i | self storeByte: i-1 ofObject: stringOop
			withValue: (pathName at: i) asciiValue].
!
vmPathSize
	^ Smalltalk vmPath size! !
!InterpreterSimulator methodsFor: 'float primitives'!
floatObjectOf: float
	| result sign exponent mantissa mantSize long0 long1 |
true ifTrue: [
	"No conversion needed in Apple ST"
	long0 _ float at: 1.
	long1 _ float at: 2.

] ifFalse: ["Following code useful when porting to different formats"
	((float at: 1) = 0 and: [(float at: 2) = 0])
		ifTrue: [long0 _ 0. long1 _ 0]
		ifFalse: 
	["Read from the PPS 32-bit format"
	sign _ ((float at: 1) bitAnd: 16r8000) bitShift: -15.				"1-bit sign"
	exponent _ (((float at: 1) bitShift: -7) bitAnd: 16rFF) - 16r80. 		"8-bit expt"
	mantissa _ (((float at: 1) bitAnd: 16r7F) bitShift: 16) + (float at: 2).	"23 bit mantissa"
	mantSize _ 23.

	"Convert to first 32 bits of 64-bit IEEE format"
	long0 _ (sign bitShift: 31)										"1-bit sign"
			+ (exponent + 16r400 bitShift: 20)						"11-bit expt"
			+ ((mantissa bitShift: 20 - mantSize) bitAnd: 16rFFFFF).	"20 bit mantissa"
	].
 ]. "end of porting code"

	result _ self instantiateClass: (self splObj: ClassFloat) indexableSize: 2.
	self storeWord: 0 ofObject: result withValue: long0.
	self storeWord: 1 ofObject: result withValue: long1.
	^ result!
floatValueOf: objectPointer
	| float len long0 long1 sign exponent mantissa mantSize |
	(self isIntegerObject: objectPointer)
		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].
	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)
		ifFalse: [self success: false.  ^0.0].
	len _ self fetchWordLengthOf: objectPointer.
	(len between: 2 and: 3)
		ifFalse: [self success: false.  ^0.0].

	"FIRST convert image formats to sign/exponent/mantissa"
	len = 2 ifTrue:  
		["Normal 64-bit IEEE format"
		long0 _ self fetchWord: 0 ofObject: objectPointer.
		long1 _ self fetchWord: 1 ofObject: objectPointer.
true ifTrue: [float _ Float new: 2.  "No conversion needed for AST"
			float at: 1 put: long0.
			float at: 2 put: long1.
			^ float].
		long0 = 0 ifTrue: [^ 0.0].
		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"
		exponent _ ((long0 bitShift: -20) bitAnd: 16r7FF) - 16r400.		"11-bit exponent"
		mantissa _ ((long0 bitAnd: 16rFFFFF) bitShift: 32) + long1.		"52-bit mantissa"
		mantSize _ 52]
		ifFalse:  
		["Weird 80-bit Apple format -- will go away soon"
		long0 _ self fetchWord: 0 ofObject: objectPointer.
		long1 _ self fetchWord: 1 ofObject: objectPointer.
		long0 = 0 ifTrue: [^ 0.0].
		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"
		exponent _ ((long0 bitShift: -16) bitAnd: 16r7FFF) - 16r4000. 	"15-bit exponent"
		"Note: drop the (redundant) high bit (16r8000) of mantissa"
		mantissa _ ((long0 bitAnd: 16r7FFF) bitShift: 32) + long1.		"47-bit mantissa"
		mantSize _ 47].

	"THEN convert sign/exponent/mantissa to host format"
	float _ Float new: 2.  "PPSST FP uses 2 16-bit words"
	float at: 1 put: (sign bitShift: 15)							"1-bit sign"
				+ (exponent + 16r80 bitShift: 7)				"8-bit expt"
				+ ((mantissa bitShift: 7 - mantSize) bitAnd: 16r7F).	"7 bits of mantissa"
	float at: 2 put: ((mantissa bitShift: 16 - (mantSize - 7)) bitAnd: 16rFFFF).  "16 more bits of mantissa"
	^ float!
popFloat

	^ self floatValueOf: (self popStack)!
primitiveArctan
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr arcTan]
		ifFalse: [self unPop: 1].!
primitiveAsFloat
	"Use host Smalltalk's native function."

	| arg |
	arg _ self popInteger.
	successFlag
		ifTrue: [self pushFloat: arg asFloat]
		ifFalse: [self unPop: 1].!
primitiveExp
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr exp]
		ifFalse: [self unPop: 1].!
primitiveExponent
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushInteger: rcvr exponent]
		ifFalse: [self unPop: 1].!
primitiveFloatAdd
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr + arg]
		ifFalse: [self unPop: 2].!
primitiveFloatDivide
	"Note: This method overridden here because the translator (intentionally) doesn't translate the / operator (since the semantics of C / are the semantics of Smalltalk //). This allows the version of this method to be translated to express division as //, which translates to the float division operator /."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag ifTrue: [self success: arg ~= 0.0].
	successFlag
		ifTrue: [self pushFloat: rcvr / arg]
		ifFalse: [self unPop: 2].!
primitiveFloatEqual
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr = arg]
		ifFalse: [self unPop: 2].!
primitiveFloatGreaterOrEqual
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr >= arg]
		ifFalse: [self unPop: 2].!
primitiveFloatGreaterThan
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr > arg]
		ifFalse: [self unPop: 2].!
primitiveFloatLessOrEqual
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr <= arg]
		ifFalse: [self unPop: 2].!
primitiveFloatLessThan
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr < arg]
		ifFalse: [self unPop: 2].!
primitiveFloatMultiply
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr * arg]
		ifFalse: [self unPop: 2].!
primitiveFloatNotEqual
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushBool: rcvr ~= arg]
		ifFalse: [self unPop: 2].!
primitiveFloatSubtract
	"Use host Smalltalk's native function."

	| rcvr arg |
	arg _ self popFloat.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr - arg]
		ifFalse: [self unPop: 2].!
primitiveFractionalPart
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr fractionPart]
		ifFalse: [self unPop: 1].!
primitiveLogN
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr ln]
		ifFalse: [self unPop: 1].!
primitiveSine
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr sin]
		ifFalse: [self unPop: 1].!
primitiveSquareRoot
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushFloat: rcvr sqrt]
		ifFalse: [self unPop: 1].!
primitiveTimesTwoPower
	"Use Smalltalk's native function (tho could just fail)"

	| rcvr arg |
	arg _ self popInteger.
	rcvr _ self popFloat.
	successFlag
		ifTrue: [ self pushFloat: (rcvr timesTwoPower: arg) ]
		ifFalse: [ self unPop: 2 ].!
primitiveTruncated
	"Use host Smalltalk's native function."

	| rcvr |
	rcvr _ self popFloat.
	successFlag
		ifTrue: [self pushInteger: rcvr truncated]
		ifFalse: [self unPop: 1].!
pushFloat: f

	self push: (self floatObjectOf: f).! !
!InterpreterSimulator methodsFor: 'memory access'!
byteAt: byteAddress
	| lowBits |
	lowBits _ byteAddress bitAnd: 3.
	^((self longAt: byteAddress - lowBits)
		bitShift: (lowBits - 3) * 8)
		bitAnd: 16rFF!
byteAt: byteAddress put: byte
	| longWord shift lowBits |
	lowBits _ byteAddress bitAnd: 3.
	longWord _ self longAt: byteAddress - lowBits.
	shift _ (3 - lowBits) * 8.
	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).
	self longAt: byteAddress put: longWord!
longAt: byteAddress
	"Note: Adjusted for Smalltalk's 1-based array indexing."

	^memory at: (byteAddress // 4) + 1!
longAt: byteAddress put: a32BitValue
	"Note: Adjusted for Smalltalk's 1-based array indexing."

	^memory at: (byteAddress // 4) + 1 put: a32BitValue! !
!InterpreterSimulator methodsFor: 'arithmetic'!
bytecodePrimGreaterOrEqual
	"Must be overridden from Interpreter because simulator doesn't have
		32-bit signed ints to work with"
	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg)
		ifTrue: [ ^ self booleanCheat:
			(self integerValueOf: rcvr) >= (self integerValueOf: arg)].
	^ super bytecodePrimGreaterOrEqual!
bytecodePrimGreaterThan
	"Must be overridden from Interpreter because simulator doesn't have
		32-bit signed ints to work with"
	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg)
		ifTrue: [ ^ self booleanCheat:
			(self integerValueOf: rcvr) > (self integerValueOf: arg)].
	^ super bytecodePrimGreaterThan!
bytecodePrimLessOrEqual
	"Must be overridden from Interpreter because simulator doesn't have
		32-bit signed ints to work with"
	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg)
		ifTrue: [ ^ self booleanCheat:
			(self integerValueOf: rcvr) <= (self integerValueOf: arg)].
	^ super bytecodePrimLessOrEqual!
bytecodePrimLessThan
	"Must be overridden from Interpreter because simulator doesn't have
		32-bit signed ints to work with"
	| rcvr arg |
	rcvr _ self internalStackValue: 1.
	arg _ self internalStackValue: 0.
	(self areIntegers: rcvr and: arg)
		ifTrue: [ ^ self booleanCheat:
			(self integerValueOf: rcvr) < (self integerValueOf: arg)].
	^ super bytecodePrimLessThan! !

InterpreterSupportCode comment:
'This class is a shell that includes all the ancillary C code for supporting Squeak in the Macintosh operating environment.  Executing

	InterpreterSupportCode writeMacSourceFiles

will cause the creation of a number of files in your working directory which, together with the one large interpreter file (see CCodeGenerator) should be adequate to compile a complete running interpreter.'!
!InterpreterSupportCode class methodsFor: 'source file exporting'!
archiveBinaryFileBytes
	"Convert the binary archive date into a ByteArray."

	| data b |
	data _ self archiveBinaryFile.
	b _ ByteArray new: data size.
	1 to: data size do: [ :i | b at: i put: (data at: i)].
	^ b!
compareWithFilesInFolder: folderName
	"InterpreterSupportCode compareWithFilesInFolder: ''"

	(FileStream readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =
	InterpreterSupportCode archiveBinaryFileBytes
		ifFalse: [ self inform: 'File projectArchive.sit differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'readme') contentsOfEntireFile =
	InterpreterSupportCode readmeFile
		ifFalse: [ self inform: 'File readme differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sq.h') contentsOfEntireFile =
	InterpreterSupportCode squeakHeaderFile
		ifFalse: [ self inform: 'File sq.h differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =
	InterpreterSupportCode filePrimsFile
		ifFalse: [ self inform: 'File sqFilePrims.c differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =
	InterpreterSupportCode macDirectoryFile
		ifFalse: [ self inform: 'File sqMacDirectory.c differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =
	InterpreterSupportCode macJoystickFile
		ifFalse: [ self inform: 'File sqMacJoystick.c differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =
	InterpreterSupportCode macSoundFile
		ifFalse: [ self inform: 'File sqMacSound.c differs from the version stored in this image.' ].

	(FileStream readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =
	InterpreterSupportCode macWindowFile
		ifFalse: [ self inform: 'File sqMacWindow.c differs from the version stored in this image.' ].!
storeProjectArchiveOnFileNamed: fileName
	"Store into this image's folder a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be two project files for CodeWarrier, version 8."

	| f |
	f _ (FileStream newFileNamed: fileName) binary.
	self archiveBinaryFile do: [ :byte | f nextPut: byte ].
	f close.
	FileDirectory default class setMacFileNamed: fileName type: 'SITD' creator: 'SIT!!'.!
storeString: s onFileNamed: fileName
	"Store the given string in a file of the given name."

	| f |
	f _ FileStream newFileNamed: fileName.
	f nextPutAll: s.
	f close.!
writeMacSourceFiles
	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."
	"InterpreterSupportCode writeMacSourceFiles"

	self storeString: self readmeFile			onFileNamed: 'readme'.
	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.
	self storeString: self filePrimsFile		onFileNamed: 'sqFilePrims.c'.
	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.
	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.
	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.
	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.
	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.
	self storeString: AbstractSound cCodeForSoundPrimitives
											onFileNamed: 'sqSoundPrims.c'.
! !
!InterpreterSupportCode class methodsFor: 'source files'!
archiveBinaryFile

	^ #(83 73 84 33 0 2 0 0 26 106 114 76 97 117 2 210 0 0 0 22 1 87 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 105 108 101 73 110 115 0 0 0 0 0 0 0 0 0 0 0 129 35 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 96 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 174 214 20 200 0 0 37 198 0 0 12 174 0 0 7 233 0 0 3 241 119 186 224 210 0 0 0 0 0 0 202 68 13 192 248 163 54 177 227 43 51 91 249 209 227 18 54 192 179 243 138 240 167 221 202 142 176 35 199 162 132 18 214 137 167 39 167 199 105 209 147 83 57 61 217 249 156 112 51 124 47 229 212 206 244 56 254 105 209 6 121 107 156 48 249 19 78 142 31 161 92 194 8 127 202 9 123 66 35 199 34 252 200 83 110 3 194 159 60 127 242 140 240 147 112 66 249 75 56 97 132 123 132 159 71 56 161 17 70 142 75 248 41 57 126 18 70 56 225 132 31 229 228 24 225 43 112 87 223 113 202 41 63 114 44 218 32 202 87 190 70 56 225 132 30 97 145 227 71 9 139 204 56 225 132 83 60 225 192 120 3 2 208 235 236 2 96 0 32 135 7 152 139 39 123 63 167 221 35 113 245 162 224 85 185 38 81 8 112 90 189 160 113 170 212 36 74 1 145 19 253 170 165 234 238 102 81 104 92 154 95 102 147 21 169 161 140 197 236 14 135 179 210 94 189 162 24 153 28 24 66 247 226 245 161 232 186 227 182 0 64 250 30 128 121 111 137 156 219 47 120 26 57 169 89 243 251 144 32 161 172 234 156 181 122 159 202 225 161 213 139 156 87 172 19 154 253 26 254 171 141 154 36 115 178 226 11 104 162 98 91 225 162 151 7 47 113 30 33 16 144 52 206 141 108 164 181 162 151 147 234 234 194 36 244 60 110 209 35 52 171 34 231 211 8 61 20 132 133 68 172 2 19 45 4 35 152 200 29 171 131 36 96 49 81 2 34 237 248 103 4 80 59 44 178 48 27 8 168 120 51 81 36 195 33 120 184 138 42 110 105 126 35 103 95 104 207 203 179 189 252 125 22 236 120 0 166 240 79 248 127 37 211 206 164 178 27 6 243 216 32 37 140 140 235 156 62 148 201 10 12 99 101 5 182 49 225 77 2 239 248 28 224 83 157 89 34 3 161 80 36 77 40 196 144 32 208 44 253 151 68 71 7 192 242 16 249 194 202 166 38 57 164 128 224 145 70 20 48 193 213 96 102 222 96 131 209 255 161 32 244 166 45 131 68 82 37 180 72 202 184 114 95 160 81 84 126 100 18 206 224 116 218 207 102 200 46 116 58 203 39 75 246 78 60 11 101 217 111 12 192 195 225 40 47 138 231 177 148 251 220 220 138 38 89 82 52 34 237 79 57 28 206 242 18 131 0 30 213 246 27 141 1 116 173 172 170 28 38 248 23 15 87 113 141 139 181 121 98 45 204 81 173 119 205 243 170 234 60 76 54 79 94 158 33 0 143 4 155 231 23 65 254 224 33 27 6 232 42 143 16 185 200 67 108 249 69 144 223 66 175 215 250 127 235 53 35 202 35 166 198 101 200 195 41 168 30 193 127 65 88 93 87 89 80 141 2 120 120 70 148 141 235 74 140 13 225 145 68 120 252 220 137 198 121 176 182 31 253 205 96 36 84 138 235 227 245 90 99 175 24 245 13 25 36 73 73 204 57 120 37 79 243 127 173 131 246 123 69 85 98 205 126 140 135 90 239 119 199 243 88 156 197 191 170 138 60 180 102 131 0 30 36 76 54 172 146 127 116 117 146 90 140 123 96 3 16 135 139 210 254 148 99 194 225 158 231 97 24 224 112 43 138 110 38 51 185 152 30 14 103 117 92 15 163 6 167 124 78 141 9 167 28 227 113 209 41 143 242 24 115 202 163 186 142 57 229 56 15 227 5 167 60 172 199 223 78 249 188 176 127 57 229 56 143 49 167 60 76 227 146 83 142 241 48 6 112 202 198 31 14 247 92 193 78 56 220 11 157 209 48 192 225 86 251 2 75 22 115 45 249 75 207 58 92 243 159 78 7 137 156 205 241 167 211 137 241 184 232 80 70 245 24 115 40 113 30 227 29 120 152 199 165 14 28 227 145 96 139 117 189 20 228 129 133 63 106 133 39 59 76 63 15 191 111 164 237 125 55 73 184 80 105 132 135 228 110 24 225 81 225 110 136 243 72 117 156 91 87 136 22 135 195 94 106 8 32 250 239 51 130 20 84 131 86 244 175 60 176 83 249 71 188 226 84 194 195 47 168 42 103 151 154 100 159 255 7 117 35 157 1 43 90 172 51 4 208 117 178 51 244 123 233 152 39 31 231 17 239 192 241 58 235 239 156 218 72 153 141 133 41 155 174 13 49 144 192 152 113 195 167 0 106 17 95 253 237 78 168 189 246 132 142 1 89 129 171 229 131 31 125 139 231 73 62 200 7 123 14 207 91 141 27 63 83 224 16 102 190 15 255 97 21 161 80 206 183 238 216 15 181 11 74 97 245 87 119 66 240 232 1 8 182 181 240 193 39 205 244 78 112 11 182 67 194 68 231 199 101 240 173 36 31 223 186 253 40 220 126 228 193 239 185 32 18 124 224 153 1 193 245 255 227 186 100 148 223 64 240 173 207 207 226 91 159 195 219 97 126 144 121 7 28 194 115 144 79 219 113 168 93 126 12 255 95 161 92 186 41 231 47 160 131 42 157 137 89 145 49 110 20 177 211 11 244 81 106 85 179 76 186 51 65 75 113 155 80 84 212 2 171 165 27 166 238 190 58 74 156 153 175 43 130 89 25 239 179 139 192 186 242 24 158 135 234 67 95 243 136 95 131 247 66 96 189 124 62 98 125 120 102 64 102 171 11 243 239 205 5 147 9 113 110 32 63 32 238 212 241 249 26 147 247 110 167 234 81 124 144 133 3 73 204 79 183 170 188 123 176 14 80 31 154 63 5 243 119 29 0 107 118 255 78 84 238 214 23 249 109 47 105 136 208 141 69 204 183 7 172 179 187 152 27 18 51 16 251 0 249 181 211 58 159 186 123 163 158 31 245 32 249 173 115 34 182 50 27 230 144 109 56 82 3 87 14 213 0 154 30 69 80 124 162 90 0 134 22 53 192 92 127 235 151 134 1 53 144 2 108 214 80 13 68 154 0 64 103 14 244 150 237 131 222 202 22 190 237 222 119 42 200 84 61 1 82 241 3 248 152 241 174 35 28 67 228 54 156 120 186 19 78 238 127 2 152 133 91 24 239 122 212 99 93 123 79 56 232 253 94 117 19 50 121 143 223 134 154 210 252 157 57 152 227 84 17 204 45 130 180 131 53 48 45 159 165 61 44 51 77 55 12 39 118 189 30 239 231 200 115 81 4 210 241 13 217 144 217 179 29 207 118 196 220 244 126 102 239 105 176 188 214 29 194 64 156 191 17 107 129 223 149 154 11 125 12 214 235 230 16 48 71 232 36 156 53 227 94 105 90 149 175 73 246 139 92 145 40 78 78 54 13 59 130 1 198 8 166 8 48 172 96 194 133 89 186 212 73 55 60 201 226 52 9 11 36 135 175 69 154 206 62 220 173 133 203 244 61 107 110 149 131 140 6 201 190 245 232 248 96 48 74 10 171 92 250 206 74 150 124 102 11 123 34 150 99 68 193 51 59 178 144 140 187 223 131 177 24 117 188 180 23 108 142 86 6 169 135 15 232 134 241 80 67 49 2 138 53 107 84 77 80 136 213 51 112 8 43 117 138 88 204 67 245 140 221 207 8 160 93 45 55 128 208 151 177 146 87 5 12 105 226 85 50 97 138 111 230 19 183 161 187 23 134 204 44 240 36 187 250 53 134 0 62 38 94 182 3 62 231 140 203 209 189 137 89 127 44 32 156 18 207 254 247 51 160 107 73 95 38 185 54 131 9 0 43 175 162 243 217 233 178 130 195 216 44 184 170 202 85 153 131 25 7 55 238 114 122 232 112 19 61 31 110 177 124 6 51 241 190 133 96 149 111 3 206 109 24 58 220 190 233 97 200 71 140 190 87 80 234 4 28 231 51 100 226 7 242 251 80 129 172 231 18 172 105 51 172 65 204 69 176 228 66 192 199 1 88 47 193 184 195 176 9 177 141 4 187 101 51 180 33 134 111 111 160 241 60 13 15 33 118 154 96 197 91 225 81 128 43 150 17 44 247 113 216 137 146 213 16 236 238 57 240 20 74 73 7 201 230 199 224 5 196 144 11 128 155 5 156 165 204 32 179 26 152 181 17 186 1 102 210 124 216 114 63 68 236 17 130 77 105 128 79 16 219 78 176 235 250 0 95 60 152 189 150 234 221 1 223 32 70 115 20 173 196 119 55 128 163 67 198 5 7 153 116 128 57 248 54 8 6 78 87 176 162 22 19 40 225 20 197 176 22 144 147 19 223 28 17 61 26 135 117 165 250 164 64 58 110 24 69 7 225 22 186 233 16 133 211 200 174 139 93 242 138 55 137 1 115 255 222 11 189 22 166 49 37 188 117 21 73 25 193 171 5 37 224 11 220 165 90 34 116 139 91 52 69 80 147 138 189 62 77 82 76 37 82 64 75 114 9 202 93 162 150 94 232 241 136 56 140 119 10 90 61 222 167 105 210 168 89 15 19 239 95 41 165 215 194 132 44 250 114 71 84 57 29 142 208 78 178 151 56 48 89 26 121 112 33 194 163 255 241 133 100 2 225 230 16 189 30 230 243 63 0 0 0 11 0 171 116 224 229 36 155 216 136 48 66 35 207 200 81 201 49 178 198 143 28 77 66 201 128 17 182 54 202 235 148 41 185 181 94 114 140 28 125 60 91 61 230 225 9 197 119 82 125 122 221 74 24 57 166 132 145 9 35 199 200 49 66 201 132 18 70 38 244 34 3 70 70 235 69 16 192 200 132 70 40 65 1 35 140 80 114 140 160 128 30 57 70 70 140 48 66 35 3 70 142 2 247 61 123 15 79 9 59 201 90 122 108 101 135 167 132 145 103 100 204 200 132 146 17 35 140 48 60 193 3 31 30 171 65 248 152 36 137 8 33 27 188 91 16 114 247 192 123 28 118 17 120 151 194 251 49 42 65 255 33 6 181 217 163 210 156 28 227 21 100 219 120 137 238 162 254 233 157 119 33 100 7 2 126 28 218 12 15 195 80 158 39 204 198 90 135 133 155 50 43 11 64 189 72 120 229 26 68 231 210 135 240 188 221 87 162 67 31 128 11 5 30 136 252 205 51 118 216 63 50 183 63 100 188 168 212 22 171 29 51 105 136 57 207 92 88 216 65 175 193 123 84 54 134 220 40 77 60 198 25 209 52 224 193 53 148 80 121 121 182 227 220 255 193 216 190 130 221 7 114 69 30 95 214 89 51 14 236 106 152 39 96 174 209 230 90 152 39 97 174 211 246 85 48 179 48 187 87 55 170 22 97 190 151 211 239 81 146 3 130 200 71 100 33 174 20 29 208 83 113 162 255 17 90 4 186 115 95 191 79 73 66 198 251 4 153 143 169 146 156 202 91 160 167 209 159 181 61 93 1 118 125 214 213 248 2 230 19 63 150 209 19 80 227 222 247 163 146 248 113 73 74 41 170 16 155 41 36 194 169 205 222 204 233 244 115 96 55 192 188 246 209 143 74 237 59 203 23 79 70 120 251 230 139 63 75 208 154 80 15 251 254 184 137 63 80 163 9 238 123 97 232 109 250 53 47 205 153 107 221 245 127 19 200 13 244 8 248 114 93 72 112 210 237 162 49 21 63 124 105 202 188 223 186 255 211 151 70 45 111 191 122 206 171 36 73 104 142 139 206 245 167 231 6 208 96 201 38 204 204 158 126 127 152 85 167 225 208 232 236 186 220 218 214 33 180 119 113 129 32 172 63 235 199 247 18 126 14 117 84 64 202 70 162 65 241 0 109 94 43 69 29 254 89 89 186 5 197 47 119 118 205 180 69 227 172 40 6 114 162 224 122 217 213 161 239 245 220 71 135 70 174 142 5 193 214 156 157 123 180 188 14 63 185 196 180 100 180 246 230 5 149 125 210 20 2 21 43 103 44 15 178 174 150 7 182 116 56 50 60 128 55 136 33 212 42 43 73 89 87 96 93 167 6 214 81 9 161 186 173 220 64 123 61 163 84 188 65 165 132 234 176 210 15 10 67 134 214 16 42 35 212 18 43 19 89 143 231 149 70 133 13 92 104 144 241 205 227 139 14 247 148 45 61 218 63 54 74 26 203 78 169 214 29 102 82 29 148 106 93 35 38 181 194 112 168 120 43 152 84 39 165 90 151 153 73 117 81 170 213 251 192 90 50 168 75 112 215 16 106 169 146 12 78 23 202 204 212 234 9 65 107 47 143 219 71 83 179 188 146 7 147 75 143 80 201 198 75 169 53 189 82 130 19 84 65 74 176 34 24 44 75 166 2 114 71 82 42 222 84 82 170 43 44 220 225 185 176 196 241 57 189 38 213 71 168 213 229 113 232 161 130 179 228 230 33 84 178 169 162 84 123 106 158 21 11 190 146 11 72 167 178 168 90 163 42 42 39 72 69 234 132 65 157 64 53 148 234 0 42 244 233 17 214 164 214 26 84 89 72 76 125 163 78 26 212 73 84 167 165 65 21 226 135 241 57 208 234 15 65 55 172 4 220 16 210 65 158 229 120 57 23 9 114 215 82 42 222 212 83 42 254 147 165 81 161 198 15 174 13 184 130 211 225 112 239 32 217 52 208 148 87 244 241 202 76 207 220 81 246 200 13 172 167 124 13 53 234 61 4 190 202 133 30 218 163 54 17 234 13 167 126 217 28 130 201 93 78 169 120 211 172 105 165 229 159 215 138 255 50 80 42 222 180 208 126 181 254 122 173 110 248 182 245 126 245 109 107 199 30 254 3 198 68 162 252 212 206 142 1 130 111 108 8 127 67 174 200 76 71 3 236 79 225 255 109 145 97 69 165 6 116 156 133 159 87 243 240 205 86 100 64 84 240 39 255 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 105 108 101 73 110 115 0 0 0 0 0 0 0 0 0 0 0 89 11 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 174 214 20 197 0 0 42 109 0 0 13 170 0 0 9 121 0 0 4 33 68 33 178 45 0 0 0 0 0 0 25 67 13 192 213 101 47 91 187 188 110 229 73 147 176 205 90 227 244 26 164 221 202 110 179 34 108 179 77 201 102 155 225 233 217 111 154 155 218 217 203 206 231 231 71 241 212 240 124 205 206 252 189 90 132 211 54 43 70 214 186 6 70 110 147 77 219 18 70 110 31 187 173 155 80 194 9 35 155 176 223 172 167 91 194 182 31 219 70 54 35 251 36 251 232 62 182 143 28 219 228 216 102 132 95 39 229 132 109 114 140 176 46 194 46 202 37 140 108 47 70 158 118 43 112 215 245 117 94 215 121 110 246 209 86 182 222 62 178 165 17 182 201 109 221 108 147 217 38 155 108 134 39 27 24 239 1 1 232 117 118 120 0 2 0 51 63 13 48 3 79 205 103 61 161 63 45 126 152 64 232 61 31 204 229 67 39 241 28 108 232 158 103 14 29 147 111 149 233 181 95 234 16 133 54 155 205 98 246 249 189 173 22 14 179 91 173 182 26 75 221 210 18 100 178 127 4 229 241 249 72 236 90 229 204 1 72 219 9 48 187 61 119 137 57 116 100 199 150 242 146 7 117 203 186 119 60 87 112 23 34 217 101 158 80 207 60 51 100 224 105 192 51 165 114 207 41 93 213 59 144 209 104 88 214 77 223 250 116 59 107 236 85 243 147 42 6 166 158 12 249 42 87 85 118 204 7 72 98 220 146 216 167 141 146 165 226 14 135 54 9 3 42 151 3 148 189 73 178 102 224 11 142 37 215 226 157 189 7 141 241 69 188 183 42 56 190 79 246 9 142 54 193 41 190 175 165 28 19 148 247 102 105 117 251 133 247 105 181 171 165 128 216 110 113 11 146 36 74 23 41 228 125 160 212 133 208 1 135 137 52 136 108 196 219 71 57 199 130 67 22 122 21 0 22 225 40 167 138 100 88 5 135 169 170 214 132 45 194 100 153 103 201 207 55 127 127 56 11 235 9 172 70 241 162 220 151 145 141 36 149 91 115 54 143 30 8 210 193 147 201 76 209 40 108 102 213 201 69 106 52 17 68 171 10 80 45 234 32 129 13 53 92 18 227 25 13 35 153 140 88 132 207 115 219 184 223 106 190 75 225 173 111 3 188 41 51 75 66 227 16 10 167 9 133 176 96 105 201 2 76 147 175 52 54 111 6 88 18 162 159 210 47 82 117 86 175 71 112 120 199 20 208 194 44 208 147 159 112 193 200 253 92 117 83 89 86 64 18 237 61 74 235 169 112 121 218 68 255 121 38 137 12 217 133 54 91 197 237 34 107 196 179 208 231 115 171 3 240 176 90 43 138 226 121 210 43 92 77 166 165 237 62 175 63 64 165 189 152 195 106 171 40 85 9 224 81 103 41 86 7 208 181 166 182 102 148 224 199 60 236 37 245 118 141 185 169 197 209 223 223 15 228 103 155 216 195 163 79 6 232 149 127 188 245 48 218 165 98 67 145 224 118 123 189 30 83 153 232 246 209 135 147 23 113 112 180 187 23 122 102 46 130 29 5 232 90 101 30 156 217 17 107 133 214 58 217 211 92 174 14 153 135 214 236 200 207 87 5 224 161 49 59 174 10 242 15 30 76 118 85 0 93 125 99 68 110 240 16 59 175 10 242 183 144 235 181 229 191 245 154 17 225 17 83 35 13 121 216 4 201 33 184 175 8 43 235 234 19 70 13 254 191 120 56 198 148 141 235 74 13 18 229 161 163 60 62 236 68 215 121 112 230 243 62 233 108 104 106 196 47 127 84 175 210 213 62 173 67 25 10 165 118 214 167 217 251 15 250 116 189 165 42 225 99 50 104 146 210 152 147 105 246 58 58 254 215 130 152 255 240 75 254 152 105 24 231 33 181 184 155 226 121 210 109 37 215 84 69 30 129 14 149 0 30 52 180 102 172 146 255 232 106 163 181 40 59 238 133 139 190 168 94 226 184 81 218 139 57 110 58 238 203 60 84 3 28 119 85 81 185 41 161 135 213 86 23 215 67 237 195 185 95 82 245 166 115 143 241 184 225 220 19 60 198 157 123 66 215 113 231 30 231 161 190 224 220 71 245 248 183 115 191 44 236 199 206 61 206 99 220 185 143 210 184 229 220 99 60 212 3 156 187 214 44 137 206 15 251 52 64 207 61 167 113 26 63 11 138 242 176 63 239 29 238 211 165 172 79 171 127 56 238 75 133 127 211 113 95 233 176 170 1 142 187 206 229 185 119 129 169 115 209 194 191 56 110 253 63 29 19 18 185 218 25 174 59 166 24 143 27 78 39 161 199 184 211 137 243 184 222 201 71 121 220 234 228 49 30 26 115 172 235 165 32 15 44 252 132 53 191 221 97 162 60 220 174 177 182 119 102 178 113 165 210 40 15 111 83 235 24 143 170 166 214 56 143 84 235 165 117 142 72 113 88 45 101 170 0 162 255 125 214 144 130 106 176 138 190 198 3 59 149 123 204 115 102 82 30 116 105 204 100 241 182 251 92 238 115 234 134 59 3 86 180 248 160 42 128 174 183 59 67 212 147 199 188 253 117 30 241 14 28 175 179 104 231 12 140 149 217 120 232 76 108 89 141 3 45 161 187 104 5 208 128 248 202 211 223 134 134 217 111 201 24 192 94 128 6 62 248 251 211 120 14 240 65 62 216 255 234 244 149 184 17 53 17 14 96 230 117 120 7 220 59 4 82 193 119 109 253 21 52 204 45 131 149 239 53 66 240 141 253 16 124 180 147 15 110 209 179 55 193 71 176 29 82 38 50 63 83 6 223 69 243 241 93 79 189 1 43 94 219 48 204 5 145 224 227 219 135 4 151 239 232 201 49 48 63 242 27 10 190 171 119 26 223 245 28 190 86 248 193 164 85 112 0 207 179 124 30 61 12 13 75 14 225 253 5 198 165 143 113 62 1 155 153 210 147 48 43 50 38 184 125 200 21 20 172 231 215 191 82 175 144 35 160 153 86 76 60 246 199 240 68 166 201 103 76 216 92 150 64 126 251 20 112 239 188 74 113 147 150 199 252 38 35 191 126 167 60 183 77 93 208 75 156 223 146 181 163 249 170 127 208 201 175 223 94 10 250 146 221 48 248 189 131 164 250 231 125 152 107 45 36 183 125 21 158 120 119 144 84 191 184 17 71 18 44 48 199 33 146 244 245 39 225 212 253 219 249 199 78 84 50 245 225 233 70 58 147 0 242 90 49 169 126 9 56 103 214 221 48 248 235 169 50 187 135 126 196 52 27 139 193 83 180 21 177 226 143 104 204 116 249 241 30 128 181 59 201 235 192 229 21 200 227 237 218 14 31 117 40 5 101 162 208 44 250 165 130 194 202 218 165 56 179 148 65 156 146 252 240 52 61 201 226 125 135 72 115 111 0 207 89 100 49 45 175 201 7 25 163 230 103 108 69 144 98 0 67 174 49 194 222 88 248 122 188 39 145 207 173 126 139 1 205 10 15 138 163 226 148 15 249 252 228 191 78 195 143 128 4 39 161 15 115 109 162 245 66 154 159 221 64 53 193 252 189 236 189 225 238 13 144 249 141 237 121 144 162 101 122 60 77 50 217 41 71 22 228 96 65 112 217 35 53 128 104 88 121 99 122 31 100 110 155 21 21 108 78 184 186 57 210 250 246 124 48 46 59 132 231 129 150 208 159 121 196 239 193 119 33 48 222 49 7 177 147 120 102 192 164 46 59 230 223 155 7 90 45 226 166 161 252 128 184 77 198 231 4 72 254 190 30 201 225 119 193 157 56 136 194 252 108 251 176 117 0 251 33 234 195 242 167 96 254 99 251 193 152 21 221 29 204 61 177 142 223 180 155 78 177 176 25 82 62 3 207 130 241 174 93 164 216 96 67 236 32 242 219 200 42 62 115 219 195 114 126 212 131 230 55 230 132 59 27 234 79 119 113 105 13 76 25 169 1 52 191 126 193 239 18 177 248 85 31 106 128 223 116 165 6 72 219 31 94 86 19 168 129 137 35 53 64 119 65 121 228 68 57 171 163 244 1 20 83 175 44 162 171 189 132 178 178 173 2 19 70 156 21 68 74 98 40 210 33 25 75 132 29 202 203 87 168 195 76 108 206 95 139 37 24 242 46 21 9 214 159 223 145 190 21 148 79 4 188 176 161 143 60 71 82 46 64 29 21 169 163 46 48 49 14 210 163 11 136 44 139 147 131 114 47 29 110 40 106 64 241 192 3 82 64 240 179 165 13 245 134 48 130 134 83 126 234 16 253 35 0 6 118 63 102 189 84 63 244 37 70 149 24 247 247 126 236 161 179 165 52 249 207 49 166 229 86 106 112 232 31 100 240 255 49 67 73 74 11 107 237 178 123 185 19 125 117 50 221 24 162 211 55 53 128 198 144 40 219 33 159 115 193 229 200 255 24 209 159 251 173 76 244 159 57 176 235 83 125 147 94 198 39 83 201 11 192 249 150 179 57 125 182 207 143 67 249 79 194 140 90 123 77 46 102 252 218 25 74 169 133 76 91 54 85 188 239 167 64 231 29 233 20 171 94 3 5 120 253 4 197 202 159 0 186 21 251 8 197 58 166 192 253 120 221 69 177 52 59 56 241 74 135 135 144 51 29 144 43 41 167 88 237 28 88 139 216 55 41 182 208 15 221 136 125 135 98 133 207 67 15 98 187 41 182 34 19 158 65 236 8 197 146 143 99 93 2 55 64 177 175 244 195 47 81 73 182 29 170 155 2 191 67 12 255 169 3 224 92 12 127 68 140 109 78 180 88 224 56 98 108 91 204 179 15 222 69 172 143 98 115 67 48 136 35 16 54 219 89 115 140 164 226 239 62 168 110 96 251 5 65 141 77 247 81 108 121 61 193 169 171 137 237 47 216 183 144 153 136 49 93 115 127 67 238 69 21 89 190 14 55 193 173 219 156 117 76 215 151 72 53 222 232 220 5 102 111 37 56 97 206 101 173 34 187 145 52 35 198 114 36 29 37 248 211 144 60 166 253 29 159 33 15 1 76 151 215 81 250 232 220 105 6 253 179 15 104 142 51 140 233 58 209 134 253 70 116 4 76 88 159 146 203 235 201 178 10 78 151 195 100 17 124 35 75 22 104 195 195 15 229 157 146 204 232 3 133 67 58 91 180 137 100 156 64 87 173 44 222 102 241 11 162 71 31 93 187 98 207 148 140 25 116 255 185 216 37 33 81 177 189 137 178 164 46 255 204 3 131 188 251 142 91 134 30 209 109 192 181 188 8 189 137 202 226 225 57 188 78 240 123 92 30 167 148 30 86 182 164 51 224 23 36 93 73 179 43 224 245 107 75 189 158 128 206 46 248 157 98 192 80 232 112 136 40 177 77 8 180 224 123 150 102 2 85 36 44 90 116 59 155 61 11 203 44 239 37 133 121 43 112 152 182 206 82 106 197 100 19 216 184 66 225 17 253 175 74 50 133 112 233 141 61 87 248 252 31 0 0 11 192 248 122 51 39 121 89 103 166 44 66 57 121 78 142 69 142 147 149 31 37 199 58 194 201 128 255 26 95 227 43 161 199 93 229 226 89 107 156 118 61 57 230 225 169 39 59 241 132 154 82 253 248 175 156 60 119 37 156 204 57 97 100 66 249 145 231 132 30 39 3 70 38 124 189 56 65 1 35 207 34 19 78 80 64 201 113 114 156 60 39 35 182 114 194 201 136 19 78 24 225 228 41 225 20 56 235 89 244 56 158 18 254 132 74 152 242 181 195 179 142 60 63 130 2 78 56 25 49 194 9 7 32 0 94 88 93 39 64 65 211 74 0 32 224 157 4 136 60 143 247 27 216 147 240 238 197 251 11 172 158 2 31 190 53 150 199 137 241 217 216 215 88 3 108 254 48 71 181 123 124 64 188 179 127 243 240 252 195 179 143 240 229 20 192 245 29 33 111 158 133 39 225 43 33 111 180 246 104 63 146 41 191 240 46 222 90 34 222 197 91 247 222 178 179 141 184 231 124 47 92 223 129 111 161 7 160 175 5 81 168 227 187 0 205 136 165 129 21 161 153 178 169 232 171 231 158 158 72 21 218 78 241 243 136 85 199 155 193 196 21 100 39 176 158 199 122 216 170 79 96 189 128 245 73 171 63 132 181 140 117 100 115 43 126 3 235 247 14 244 71 140 74 86 45 41 146 174 174 24 93 7 250 31 234 255 0 110 32 61 184 175 63 102 84 68 185 48 165 234 74 193 212 244 218 161 5 1 171 30 105 10 55 55 144 125 170 25 26 109 97 253 175 31 235 240 9 170 9 239 251 49 72 126 188 172 213 12 83 45 44 119 38 34 108 213 131 141 71 235 159 35 251 52 214 183 127 242 35 102 189 243 124 137 54 212 239 191 251 213 159 53 248 136 173 135 125 127 194 228 79 94 171 150 139 71 11 99 224 120 94 70 27 115 147 35 255 37 48 55 184 71 208 151 75 106 185 168 189 221 53 38 120 236 75 178 177 221 122 255 79 95 198 172 121 251 107 207 69 141 10 13 205 131 69 23 122 184 231 178 48 221 115 7 107 140 48 123 250 39 95 201 207 140 103 82 146 148 73 229 212 197 67 253 182 111 109 29 145 252 204 133 215 46 255 33 3 250 92 29 152 66 246 246 8 229 142 171 114 65 57 146 225 232 111 235 24 92 213 181 171 24 32 116 230 72 169 35 197 127 164 163 95 148 205 165 99 43 232 216 220 182 142 168 120 41 243 106 181 108 170 43 202 209 128 176 92 186 171 195 238 59 115 86 169 42 242 242 248 156 56 254 204 179 231 59 126 156 217 157 221 52 170 216 232 241 102 189 25 57 255 174 80 23 165 92 150 117 192 71 212 184 55 145 141 11 55 211 66 221 88 42 45 178 14 244 16 53 224 205 205 167 31 191 206 168 102 117 145 117 160 151 168 195 222 148 52 227 185 33 203 33 236 64 31 81 31 243 118 79 51 148 252 208 162 98 7 252 68 13 123 27 162 177 253 205 19 156 202 58 152 51 113 227 220 121 144 75 217 182 21 234 179 47 93 158 165 189 27 224 84 47 77 186 212 1 78 245 50 149 75 13 58 14 117 19 143 75 13 113 170 151 67 144 181 230 80 215 48 103 17 213 75 165 174 214 8 167 246 26 149 212 82 103 117 185 212 104 26 51 195 250 149 254 217 218 170 98 28 130 41 175 18 149 58 131 156 154 200 104 229 162 106 170 90 89 46 161 85 186 230 42 160 52 204 169 172 19 227 212 144 168 190 163 20 69 173 168 28 232 117 169 241 52 250 186 62 228 95 193 157 215 113 150 146 27 81 169 51 196 169 253 181 183 228 82 199 87 202 113 54 85 134 132 69 53 204 162 170 117 169 243 14 117 30 134 57 53 128 84 92 117 247 177 46 245 132 67 213 213 242 181 223 169 11 14 117 1 78 90 211 64 91 188 59 13 187 90 71 210 152 152 54 30 15 227 144 78 43 114 81 209 15 70 130 210 57 167 178 206 41 78 141 220 163 226 54 255 45 1 96 150 175 139 98 102 154 58 163 214 70 225 171 245 112 163 176 159 8 62 229 172 115 154 83 7 166 20 99 249 197 234 253 137 165 252 111 239 134 219 48 102 111 47 156 6 189 163 245 103 106 146 168 111 6 237 140 210 6 211 159 4 167 178 206 25 43 1 28 103 196 205 173 68 86 168 79 74 82 142 117 240 7 143 168 222 143 223 230 86 236 174 189 149 99 119 249 27 1 127 85 193 39 229 149 107 59 59 14 8 223 8 192 222 80 98 109 76 156 195 62 254 18 246 181 164 156 97 114 219 38 98 152 172 49 121 251 103 165 108 201 96 79 254 7 0)!
filePrimsFile

	^ '#include "sq.h"

/***
	The state of a file is kept in the following structure,
	which is stored directly in a Squeak bytes object.
	NOTE: The Squeak side is responsible for creating an
	object with enough room to store sizeof(SQFile) bytes.

	The session ID is used to detect stale file objects--
	files that were still open when an image was written.
	The file pointer of such files is meaningless.

	Files are always opened in binary mode; the higher
	level does line-end conversion if needed.

	Writeable files are opened read/write. The stdio spec
	requires that an fflush or positioning operation be
	done when switching between reading and writing. The
	lastOp field records whether the last operation was
	a read or write operation allowing the fflush to be
	done automatically if needed.

	typedef struct {
		File	*file;
		int		sessionID;
		int		writable;
		int		fileSize;
		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //
	} SQFile;

***/

/*** Constants ***/
#define UNCOMMITTED	0
#define READ_OP		1
#define WRITE_OP	2

/*** Variables ***/
int thisSession = 0;
extern unsigned char *memory;

int sqFileAtEnd(SQFile *f) {
	/* Return true if the file''s read/write head is at the end of the file. */

	if (!!sqFileValid(f)) return success(false);
	return ftell(f->file) == f->fileSize;
}

int sqFileClose(SQFile *f) {
	/* Close the given file. */

	if (!!sqFileValid(f)) return success(false);
	fclose(f->file);
	f->file = NULL;
	f->sessionID = 0;
	f->writable = false;
	f->fileSize = 0;
	f->lastOp = UNCOMMITTED;
}

int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {
	char cFileName[1000];
	int i, err;

	if (sqFileNameSize >= 1000) {
		return success(false);
	}

	/* copy the file name into a null-terminated C string */
	for (i = 0; i < sqFileNameSize; i++) {
		cFileName[i] = *((char *) (sqFileNameIndex + i));
	}
	cFileName[sqFileNameSize] = 0;

	err = remove(cFileName);
	if (err) {
		return success(false);
	}
}

int sqFileGetPosition(SQFile *f) {
	/* Return the current position of the file''s read/write head. */

	int position;

	if (!!sqFileValid(f)) return success(false);
	position = ftell(f->file);
	if (position < 0) return success(false);
	return position;
}

int sqFileInit(void) {
	/* Create a session ID that is unlikely to be repeated.
	   Zero is never used for a valid session number.
	   Should be called once at startup time.
	*/

	thisSession = clock() + time(NULL);
	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */
}

int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {
	/* Opens the given file using the supplied sqFile structure
	   to record its state. Fails with no side effects if f is
	   already open. Files are always opened in binary mode;
	   Squeak must take care of any line-end character mapping.
	*/

	char cFileName[1001];
	int i;

	/* don''t open an already open file */
	if (sqFileValid(f)) return success(false);

	/* copy the file name into a null-terminated C string */
	if (sqFileNameSize > 1000) {
		return success(false);
	}
	for (i = 0; i < sqFileNameSize; i++) {
		cFileName[i] = *((char *) (sqFileNameIndex + i));
	}
	cFileName[sqFileNameSize] = 0;

	if (writeFlag) {
		/* First try to open an existing file read/write: */
		f->file = fopen(cFileName, "r+b");
		if (f->file == NULL) {
			/* Previous call fails if file does not exist. In that case,
			   try opening it in write mode to create a new, empty file.
			*/
			f->file = fopen(cFileName, "w+b");
			if (f->file !!= NULL) {
				/* set the type and creator of newly created Mac files */
				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");	
			}
		}
		f->writable = true;
	} else {
		f->file = fopen(cFileName, "rb");
		f->writable = false;
	}

	if (f->file == NULL) {
		f->sessionID = 0;
		f->fileSize = 0;
		return success(false);
	} else {
		f->sessionID = thisSession;
		/* compute and cache file size */
		fseek(f->file, 0, SEEK_END);
		f->fileSize = ftell(f->file);
		fseek(f->file, 0, SEEK_SET);
	}
	f->lastOp = UNCOMMITTED;
}

int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {
	/* Read count bytes from the given file into byteArray starting at
	   startIndex. byteArray is the address of the first byte of a
	   Squeak bytes object (e.g. String or ByteArray). startIndex
	   is a zero-based index; that is a startIndex of 0 starts writing
	   at the first byte of byteArray.
	*/

	char *dst;
	int bytesRead;

	if (!!sqFileValid(f)) return success(false);
	if (f->writable && (f->lastOp == WRITE_OP)) fflush(f->file);  /* flush between writing and reading */
	dst = (char *) (byteArrayIndex + startIndex);
	bytesRead = fread(dst, 1, count, f->file);
	f->lastOp = READ_OP;
	return bytesRead;
}

int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {
	char cOldName[1000], cNewName[1000];
	int i, err;

	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {
		return success(false);
	}

	/* copy the file names into null-terminated C strings */
	for (i = 0; i < oldNameSize; i++) {
		cOldName[i] = *((char *) (oldNameIndex + i));
	}
	cOldName[oldNameSize] = 0;

	for (i = 0; i < newNameSize; i++) {
		cNewName[i] = *((char *) (newNameIndex + i));
	}
	cNewName[newNameSize] = 0;

	err = rename(cOldName, cNewName);
	if (err) {
		return success(false);
	}
}

int sqFileSetPosition(SQFile *f, int position) {
	/* Set the file''s read/write head to the given position. */

	if (!!sqFileValid(f)) return success(false);
	fseek(f->file, position, SEEK_SET);
	f->lastOp = UNCOMMITTED;
}

int sqFileSize(SQFile *f) {
	/* Return the length of the given file. */

	if (!!sqFileValid(f)) return success(false);
	return f->fileSize;
}

int sqFileValid(SQFile *f) {
	return (
		(f !!= NULL) &&
		(f->file !!= NULL) &&
		(f->sessionID == thisSession));
}

int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {
	/* Write count bytes to the given writable file starting at startIndex
	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation
	   of byteArray and startIndex).
	*/

	char *src;
	int bytesWritten, position;

	if (!!(sqFileValid(f) && f->writable)) return success(false);
	if (f->lastOp == READ_OP) fflush(f->file);  /* flush between reading and writing */
	src = (char *) (byteArrayIndex + startIndex);
	bytesWritten = fwrite(src, 1, count, f->file);

	position = ftell(f->file);
	if (position > f->fileSize) {
		f->fileSize = position;  /* update file size */
	}

	if (bytesWritten !!= count) {
		success(false);
	}
	f->lastOp = WRITE_OP;
	return bytesWritten;
}
'!
macDirectoryFile

	^ '#include <MacHeaders.h>
#include "sq.h"

/***
	The interface to the directory primitive is path based.
	That is, the client supplies a Squeak string describing
	the path to the directory on every call. To avoid traversing
	this path on every call, a cache is maintained of the last
	path seen, along with the Mac volume and folder reference
	numbers corresponding to that path.
***/

/*** Constants ***/
#define ENTRY_FOUND     0
#define NO_MORE_ENTRIES 1
#define BAD_PATH        2

#define DELIMITOR '':''
#define MAX_PATH 2000

/*** Variables ***/
char lastPath[MAX_PATH + 1];
int  lastPathValid = false;
int  lastRefNum = 0;
int  lastVolNum = 0;

/*** Functions ***/
int convertToSqueakTime(int macTime);
int equalsLastPath(char *pathString, int pathStringLength);
int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);
int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);
int lookupVolume(char *volName, int *refNumPtr);
int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);
int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);

int convertToSqueakTime(int macTime) {
	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */
	return macTime + (3 * 365 * 24 * 60 * 60);
}

int dir_Create(char *pathString, int pathStringLength) {
	/* Create a new directory with the given path. By default, this
	   directory is created in the current directory. Use
	   a full path name such as "MyDisk:Working:New Folder" to
	   create folders elsewhere. */
	Str255 name;
	HParamBlockRec pb;
	int i;

	for (i = 0; i < pathStringLength; i++) {
		name[i] = pathString[i];
	}
	name[i] = 0; /* string terminator */
	c2pstr((char *) name);

	pb.fileParam.ioNamePtr = name;
	pb.fileParam.ioVRefNum = 0;
	pb.fileParam.ioDirID = 0;
	return PBDirCreateSync(&pb) == noErr;
}

int dir_Delimitor(void) {
	return DELIMITOR;
}

int dir_Lookup(char *pathString, int pathStringLength, int index,
  /* outputs: */
  char *name, int *nameLength, int *creationDate, int *modificationDate,
  int *isDirectory, int *sizeIfFile) {
	/* Lookup the index-th entry of the directory with the given path, starting
	   at the root of the file system. Set the name, name length, creation date,
	   creation time, directory flag, and file size (if the entry is a file).
	   Return:	0 	if a entry is found at the given index
	   			1	if the directory has fewer than index entries
	   			2	if the given path has bad syntax or does not reach a directory
	*/

	int okay, newRefNum, newVolNum;
	HVolumeParam volumeParams;
	CInfoPBRec dirParams;

	/* default return values */
	*name             = 0;
	*nameLength       = 0;
	*creationDate     = 0;
	*modificationDate = 0;
	*isDirectory      = false;
	*sizeIfFile       = 0;

	if ((pathStringLength == 0)) {
		/* get volume info */
		volumeParams.ioNamePtr = (unsigned char *) name;
		volumeParams.ioVRefNum = 0;
		volumeParams.ioVolIndex = index;
		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;
		if (okay) {
			p2cstr((unsigned char *) name);
			*nameLength       = strlen(name);
			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);
			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);
			*isDirectory      = true;
			*sizeIfFile       = 0;
			return ENTRY_FOUND;
		} else {
			return NO_MORE_ENTRIES;
		}
	} else {
		/* get file or directory info */
		if (!!equalsLastPath(pathString, pathStringLength)) {
			/* lookup and cache the refNum for this path */
			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);
			if (okay) {
				recordPath(pathString, pathStringLength, newRefNum, newVolNum);
			} else {
				return BAD_PATH;
			}
		}
		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;
		dirParams.hFileInfo.ioFVersNum = 0;
		dirParams.hFileInfo.ioFDirIndex = index;
		if (lastRefNum < 0) {
			dirParams.hFileInfo.ioVRefNum = lastRefNum;
			dirParams.hFileInfo.ioDirID = 0;
		} else {
			dirParams.hFileInfo.ioVRefNum = lastVolNum;
			dirParams.hFileInfo.ioDirID = lastRefNum;
		}
		okay = PBGetCatInfoSync(&dirParams) == noErr;
		if (okay) {
			p2cstr((unsigned char *) name);
			*nameLength       = strlen(name);
			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);
			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);
			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {
				*isDirectory  = true;
				*sizeIfFile   = 0;
			} else {
				*isDirectory  = false;
				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;
			}
			return ENTRY_FOUND;
		} else {
			return NO_MORE_ENTRIES;
		}
	}
}

int dir_PathToWorkingDir(char *pathName, int pathNameMax) {
	/* Fill in the given string with the full path from a root volume to
	   to current working directory. (At startup time, the working directory
	   is set to the application''s directory. Fails if the given string is not
	   long enough to hold the entire path. (Use at least 1000 characters to
	   be safe.)
	*/

	char thisName[256];
	CInfoPBRec pb;
	int nextDirRefNum, pathLen;

	/* initialize string copying state */
	pathName[0] = 0;
	pathLen = 0;

	/* get refNum of working directory */
	strcpy(thisName, ":");
	pb.hFileInfo.ioNamePtr = c2pstr(thisName);
	pb.hFileInfo.ioVRefNum = 0;
	pb.hFileInfo.ioFDirIndex = 0;
	pb.hFileInfo.ioDirID = 0;
	if (PBGetCatInfoSync(&pb) !!= noErr) {
		nextDirRefNum = 0;
	}
	nextDirRefNum = pb.hFileInfo.ioDirID;

	while (true) {
		thisName[0] = 0;
		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */
		pb.hFileInfo.ioVRefNum = 0;
		pb.hFileInfo.ioDirID = nextDirRefNum;
		if (PBGetCatInfoSync(&pb) !!= noErr) {
			break;  /* we''ve reached the root */
		}
		p2cstr((unsigned char *) thisName);
		pathLen = prefixPathWith(pathName, pathLen, pathNameMax, thisName);
		nextDirRefNum = pb.dirInfo.ioDrParID;
	}
	return pathLen;
}

dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {
	/* Set the Macintosh type and creator of the given file. */
	/* Note: On other platforms, this is just a noop. */

	Str255 name;
	FInfo finderInfo;
	int i;

	/* copy file name into a Pascal string */
	if (filenameSize > 255) return false;
	name[0] = filenameSize;
	for (i = 1; i <= filenameSize; i++) {
		name[i] = filename[i - 1];
	}

	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;
	finderInfo.fdType = *((int *) fType);
	finderInfo.fdCreator = *((int *) fCreator);
	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;
	return true;
}

int equalsLastPath(char *pathString, int pathStringLength) {
	/* Return true if the lastPath cache is valid and the
	   given Squeak string equals it. */

	int i, ch;

	if (!!lastPathValid ||
		(pathStringLength > MAX_PATH)) {
			return false;
	}

	for (i = 0; i < pathStringLength; i++) {
		ch = lastPath[i];
		if ((ch == 0) || (ch !!= pathString[i])) return false;
	}
	return lastPath[i] == 0;
}

int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {
	/* Look up the next directory in a path starting from the folder and volume
	   with the given reference numbers and setting *refNumPtr to the reference
	   number of the resulting folder. Return true if this succeeds. */

	CInfoPBRec pb;

	c2pstr((char *) name);
	pb.hFileInfo.ioNamePtr = (unsigned char *) name;
	pb.hFileInfo.ioFVersNum = 0;
	pb.hFileInfo.ioFDirIndex = 0;
	pb.hFileInfo.ioVRefNum = volRefNum;
	pb.hFileInfo.ioDirID = folderRefNum;

	if (PBGetCatInfoSync(&pb) == noErr) {
		p2cstr((unsigned char *) name);
		*refNumPtr = pb.hFileInfo.ioDirID;
		return true;
	}
	p2cstr((unsigned char *) name);
	return false;
}

int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {
	/* Resolve the given path and return the resulting folder or volume
	   reference number in *refNumPtr. Return false if the path is bad. */

	char chunk[100];
	int stIndex, chunkIndex, ch;
	int okay, thisVolNum = 0, thisRefNum = 0;
	int firstChunk = true, hasLeadingDelimitors = false;

	stIndex = 0;
	while (stIndex < pathStringLength) {
		chunkIndex = 0;

		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {
			/* copy any leading delimitors */
			chunk[chunkIndex++] = pathString[stIndex++];
			hasLeadingDelimitors = true;
		}

		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {
			/* copy up to the next delimitor */
			ch = chunk[chunkIndex++] = pathString[stIndex++];
		}

		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {
			/* Add a trailing delimiter to the first chunk of the
			   path to indicate that it is a volume name. If the
			   path starts with an initial delimitor, it will be
			   interpreted as a path relative to the current working
			   directory even with a trailing delimitor, which is
			   exactly the behavior we want. */
			chunk[chunkIndex++] = DELIMITOR;
			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {
				stIndex++;
			}
			firstChunk = false;
		}
		chunk[chunkIndex] = 0;  /* terminate this chunk */

		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {
			okay = lookupVolume(chunk, &thisVolNum);
			thisRefNum = 0;
		} else {
			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);
		}
		if (!!okay) {
			*refNumPtr = 0;
			*volNumPtr = 0;
			return false;
		}
	}
	*refNumPtr = thisRefNum;
	*volNumPtr = thisVolNum;
	return true;
}

int lookupVolume(char *volName, int *refNumPtr) {
	/* Look up the volume with the given name and set *refNumPtr
	   to the reference number of the resulting volume.
	   Return true if this succeeds. */

	int okay;
	HVolumeParam volumeParams;

	volumeParams.ioNamePtr = c2pstr(volName);
	volumeParams.ioVRefNum = 0;
	volumeParams.ioVolIndex = -1;
	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;
	p2cstr((unsigned char *) volName);
	if (okay) {
		*refNumPtr = volumeParams.ioVRefNum;
		return true;
	}
	return false;
}

int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {
	/* Insert the given prefix C string plus a delimitor character at the
	   beginning of the given C string. Return the new pathName size. Fails
	   if pathName is does not have sufficient space for the result.
	   Assume: pathName is null terminated.
	*/

	int offset, i;

	offset = strlen(prefix) + 1;
	if ((pathNameSize + offset) > pathNameMax) {
		error("path name to working directory is too long for available space");
	}

	for (i = pathNameSize; i >= 0; i--) {
		/* make room in pathName for prefix (moving string terminator, too) */
		pathName[i + offset] = pathName[i];
	}
	for (i = 0; i < offset; i++) {
		/* make room in pathName for prefix */
		pathName[i] = prefix[i];
	}
	pathName[offset - 1] = DELIMITOR;  /* insert delimitor */
	return pathNameSize + offset;
}

int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {
	/* Copy the given Squeak string into the lastPath cache. */

	int i;

	if (pathStringLength > MAX_PATH) {
		lastPath[0] = 0; /* set to empty string */
		lastPathValid = false;
		lastRefNum = 0;
		lastVolNum = 0;
		return;
	}
	for (i = 0; i < pathStringLength; i++) {
		lastPath[i] = pathString[i];
	}
	lastPath[i] = 0; /* string terminator */
	lastPathValid = true;
	lastRefNum = refNum;
	lastVolNum = volNum;
}

'!
macJoystickFile

	^ '#include <DeskBus.h>
#include "sq.h"

#define MOUSESTICK_SIGNATURE 0x4A656666
#define MAX_STICKS 4

typedef struct {
	short			rawX;				/* absolute stick position */
	short			rawY;
	unsigned char	buttons;
	char			private1;
	short			cursorX;			/* cursor position */
	short			cursorY;
	char			oldStickType;
	char			private2;
	char			stickOn;			/* true if stick is connected */
	char			private3;
	char			stickControlsCursor;
	char			applicationAware;	/* settings change with application changes */
	char			private4[152];
} MouseStickRec;

typedef struct {
	long			signature;
	char			private1[18];
	short			stickCount;
	char			private2[22];
	MouseStickRec	stick[MAX_STICKS];
} MouseStickSetRec, *MouseStickSetPtr;

/*** Variables ***/
MouseStickSetPtr joySticks = nil;  /* pointer to a joystick set or nil */

int joystickInit(void) {
	/* If a joystick is plugged in and its control panel is installed,
	   initialize the global pointer ''joySticks'' to the joystick set
	   data structure. Otherwise, set it to nil.
	*/

	ADBDataBlock adbGetInfo;
	MouseStickSetPtr sticks;
	int count, i;

	joySticks = nil;  /* set to nil in case we don''t find any joysticks */

	count = CountADBs();
	for (i = 1; i <= count; i++) {
		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));
		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;
		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {
			joySticks = sticks;
			return;
		}
	}
}

int joystickRead(int stickIndex) {
	/* Return input word for the joystick with the given index (in range [1..2]
	   on the Macintosh; other platforms may vary). This word is encoded as follows:

		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>

	   The highest four bits of the input word are zero. If the onFlag bit is zero,
	   there is no joystick at the given index. This may be because no joystick
	   is connected or the joystick control panel is not installed. In such,
	   cases, the entire word will be zero. A maximum of two joysticks are supported
	   by Gravis''s current version of the control panel. The x and y values are
	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)
	   joystick position. The MouseStick II only uses the approximate range [-650..650].
	   The range and center values of poorly adjusted joysticks may vary; the client
	   software should provide a way to adjust the center and scaling to correct.
	*/

	MouseStickRec stickData;
	int buttons, xBits, yBits;

	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||
		(stickIndex > joySticks->stickCount)) {
			return 0;  /* no joystick at the given index */
	}
	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */
	buttons = ~stickData.buttons & 0x1F;
	xBits = (0x400 + stickData.rawX) & 0x7FF;
	yBits = (0x400 + stickData.rawY) & 0x7FF;
	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;
}
'!
macSoundFile

	^ '#include <MacHeaders.h>
#include <Sound.h>
#include "sq.h"

/******
  Mac Sound Notes:

	On Macs that support it (all PPC Macs, I believe), 16-bit sound should
	be used. I measured a slight increase in overhead for background sound
	generation (5% to 7.5% for 16-bit sound version 2.5% to 5% for 8-bit).
	The cost of copying the larger buffer in snd_PlaySamplesFromAtLength
	was too small to easily measure in both 8-bit and 16-bits. On the other
	hand, 16-bits give far, far superiour sound quality.

	My understanding is that SoundManager 3.0 or later supports the 16-bit
	sound interface an all Macs, even if the hardware only supports 8-bits.
	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either
	the Squeak code will need to be changed to use 8-bit sound buffers,
	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion
	from 16 to 8 bits. I plan to cross that bridge if and when we need to.
	The code as currently written was to support Squeak code that generated
	8-bit sound buffers.

	Here are the various sound buffer formats from Squeak:
		1. mono,    8-bits -- packed array of bytes
		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes
		3. mono,   16-bits -- array of 32-bit words, samples in low-order 16 bits (high bits ignored)
		4. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words

	Note:  8-bit samples are encoded with 0x80 as the center (zero) value
	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)

	-- John Maloney, July 28, 1996
******/

#define BYTES_PER_SAMPLE 2

/*** double-buffer state record ***/

typedef struct {
	int open;
	int stereo;
	int frameCount;
	int bufSizeInBytes;
	int bufState0;
	int bufState1;
	int done;
} BufferStateRec;

/*** possible buffer states ***/

#define BUF_EMPTY	0
#define BUF_FULL	1
#define BUF_PLAYING	2

/*** variables ***/

SndChannelPtr chan;
BufferStateRec bufState = {false, false, 0, 0, NULL, NULL, true};
SndDoubleBufferHeader dblBufHeader;

/*** local functions ***/

pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);
int FillBufferWithSilence(SndDoubleBufferPtr buf);

pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {
	BufferStateRec *state;

	chan;  /* reference argument to avoid compiler warnings */

	/* insert a click to help user detect failure to fill buffer in time */
	*(unsigned int *) &buf->dbSoundData[0] = 0;
	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;

	state = (BufferStateRec *) buf->dbUserInfo[0];
	if (buf->dbUserInfo[1] == 0) {
		state->bufState0 = BUF_EMPTY;
		state->bufState1 = BUF_PLAYING;
	} else {
		state->bufState0 = BUF_PLAYING;
		state->bufState1 = BUF_EMPTY;
	}

	buf->dbNumFrames = state->frameCount;
	buf->dbFlags = buf->dbFlags | dbBufferReady;
	if (state->done) {
		FillBufferWithSilence(buf);
		buf->dbFlags = buf->dbFlags | dbLastBuffer;
	}
}

int FillBufferWithSilence(SndDoubleBufferPtr buf) {
	unsigned int *sample, *lastSample;

	sample		= (unsigned int *) &buf->dbSoundData[0];
	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];

	/* word-fill buffer with silence */
	if (BYTES_PER_SAMPLE == 1) {
		while (sample < lastSample) {
			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */
		}
	} else {
		while (sample < lastSample) {
			*sample++ = 0;
		}
	}
}

/*** exported functions ***/

int snd_AvailableSpace(void) {
	if (!!bufState.open) return -1;
	if ((bufState.bufState0 == BUF_EMPTY) ||
		(bufState.bufState1 == BUF_EMPTY)) {
			return bufState.bufSizeInBytes;
	}
	return 0;
}

int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {
	SndDoubleBufferPtr buf;
	int framesWritten;

	if (!!bufState.open) return -1;

	if (bufState.bufState0 == BUF_EMPTY) {
		buf = dblBufHeader.dbhBufferPtr[0];
		bufState.bufState0 = BUF_FULL;
	} else {
		if (bufState.bufState1 == BUF_EMPTY) {
			buf = dblBufHeader.dbhBufferPtr[1];
			bufState.bufState1 = BUF_FULL;
		} else {
			return 0;  /* neither buffer is available */
		}
	}

	if (bufState.frameCount < frameCount) {
		framesWritten = bufState.frameCount;
	} else {
		framesWritten = frameCount;
	}

	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */
		unsigned char *src, *dst, *end;
		src = (unsigned char *) (arrayIndex + startIndex);
		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));
		dst = (unsigned char *) &buf->dbSoundData[0];
		while (src < end) {
			*dst++ = *src++;
		}
	} else {  /* 16-bit samples */
		short int *src, *dst, *end;
		src = (short int *) (arrayIndex + (startIndex * 4));
		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));
		dst = (short int *) &buf->dbSoundData[0];
		if (bufState.stereo) {  /* stereo */
			while (src < end) {
				*dst++ = *src++;
			}
		} else {  /* mono */
			/* if mono, skip every other frame of the source */
			while (src < end) {
				src++;  /* skip high word */
				*dst++ = *src++;
			}
		}
	}
	return framesWritten;
}

int snd_PlaySilence(void) {
	if (!!bufState.open) return -1;

	if (bufState.bufState0 == BUF_EMPTY) {
		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);
		bufState.bufState0 = BUF_FULL;
	} else {
		if (bufState.bufState1 == BUF_EMPTY) {
			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);
			bufState.bufState1 = BUF_FULL;
		} else {
			return 0;  /* neither buffer is available */
		}
	}
	return bufState.bufSizeInBytes;
}

int snd_Start(int frameCount, int samplesPerSec, int stereo) {
	OSErr				err;
	SndDoubleBufferPtr	buffer;
	int					bytesPerFrame, bufferBytes, i;

	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;
	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;
		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */

	if (bufState.open) {
		/* still open from last time; clean up before continuing */
		snd_Stop();
	}

	bufState.open			= false;  /* set to true if successful */
	bufState.stereo			= stereo;
	bufState.frameCount		= bufferBytes / bytesPerFrame;
	bufState.bufSizeInBytes	= bufferBytes;
	bufState.bufState0  	= BUF_EMPTY;
	bufState.bufState1  	= BUF_EMPTY;
	bufState.done			= false;

	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;
	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;
	dblBufHeader.dbhCompressionID	= 0;
	dblBufHeader.dbhPacketSize		= 0;
	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */
	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);

	chan = NULL;
	err = SndNewChannel(&chan, sampledSynth, 0, NULL);
	if (err !!= noErr) return false; /* could not open sound channel */

	for (i = 0; i < 2; i++) {
		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);
		if (buffer == NULL) return false; /* could not allocate memory for a buffer */
		buffer->dbNumFrames		= bufState.frameCount;
		buffer->dbFlags			= dbBufferReady;
		buffer->dbUserInfo[0]	= (long) &bufState;
		buffer->dbUserInfo[1]	= i;
		FillBufferWithSilence(buffer);

		dblBufHeader.dbhBufferPtr[i] = buffer;
	}

	err = SndPlayDoubleBuffer(chan, &dblBufHeader);
	if (err !!= noErr) return false; /* could not play double buffer */

	bufState.open = true;
	return true;
}

int snd_Stop(void) {
	OSErr				err;
	SndDoubleBufferPtr	buffer;
	SCStatus			status;
	long				i, junk;

	if (!!bufState.open) return;
	bufState.done = true;
	while (true) {
		err = SndChannelStatus(chan, sizeof(status), &status);
		if (err !!= noErr) break; /* could not get channel status */
		if (!!status.scChannelBusy) break;
		Delay(1, &junk);
	}
	SndDisposeChannel(chan, true);
	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);

	for (i = 0; i < 2; i++) {
		buffer = dblBufHeader.dbhBufferPtr[i];
		if (buffer !!= NULL) {
			DisposePtr((char *) buffer);
		}
		dblBufHeader.dbhBufferPtr[i] = NULL;
	}
	bufState.open = false;
}
'!
macWindowFile

	^ '#include <MacHeaders.h>
#include <Timer.h>
#include <profiler.h>
#include "sq.h"

/*** Compilation Options:
*
*	define PLUGIN		to compile code for Netscape Plug-in
*	define MAKE_PROFILE	to compile code for profiling
*
***/

//#define PLUGIN
//#define MAKE_PROFILE

/*** Enumerations ***/
enum { appleID = 1, fileID, editID };
enum { quitItem = 1 };

/*** Variables -- Imported from Virtual Machine ***/
extern unsigned char *memory;
extern int interruptKeycode;
extern int interruptPending;
extern int interruptCheckCounter;
extern int savedWindowSize;  /* set from header when image file is loaded */

/*** Variables -- image and path names ***/
#define IMAGE_NAME_SIZE 300
char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */

#define SHORTIMAGE_NAME_SIZE 40
char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the file name, reported on launch */

#define VMPATH_SIZE 300
char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory */

/*** Variables -- Mac Related ***/
MenuHandle		appleMenu = nil;
Handle			clipboardBuffer = nil;
MenuHandle		editMenu = nil;
MenuHandle		fileMenu = nil;
CTabHandle		stColorTable = nil;
PixMapHandle	stPixMap = nil;
WindowPtr		stWindow = nil;

/*** Variables -- Event Recording ***/
#define KEYBUF_SIZE 64
int keyBuf[KEYBUF_SIZE];	/* circular buffer */
int keyBufGet = 0;			/* index of next item of keyBuf to read */
int keyBufPut = 0;			/* index of next item of keyBuf to write */
int keyBufOverflows = 0;	/* number of characters dropped */

int buttonState = 0;		/* mouse button and modifier state when mouse
							   button went down or 0 if not pressed */

Point savedMousePosition;	/* mouse position when window is inactive */
int windowActive = true;	/* true if the Squeak window is the active window */

/* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier
   bits. (The Mac shift and caps lock keys are both mapped to the single
   Squeak shift bit).
		Mac bits: <control><option><caps lock><shift><command>
		ST bits:  <command><option><control><shift>
   
*/ 
char modifierMap[32] = {
	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,
	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15
};

/*** Functions ***/
void AdjustMenus(void);
void FreeClipboard(void);
void FreePixmap(void);
int  HandleEvents(void);
void HandleMenu(int mSelect);
void HandleMouseDown(EventRecord *theEvent);
void InitMacintosh(void);
void InstallAppleEventHandlers(void);
void RecordFullPathForImageName(char *localImageName);
void SetColorEntry(int index, int red, int green, int blue);
void SetUpClipboard(void);
void SetUpMenus(void);
void SetUpPixmap(void);
void SetUpWindow(void);

/* event capture */
int recordKeystroke(EventRecord *theEvent);
int recordModifierButtons(EventRecord *theEvent);
int recordMouseDown(EventRecord *theEvent);

/*** Apple Event Handlers ***/
static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);
static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);
static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);
static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);

/*** Apple Event Handling ***/

void InstallAppleEventHandlers() {
	OSErr	err;
	long	result;

	shortImageName[0] = 0;
	err = Gestalt(gestaltAppleEventsAttr, &result);
	if (err == noErr) {	
		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);
		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);
		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);
		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);
	}
}

pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {
	/* User double-clicked application; look for "clone.image" in same directory */

	aevt; reply; refCon;  /* reference args to avoid compiler warnings */

	/* record path to VM''s home folder */
	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);

	/* use default image name in same directory as the VM */
	strcpy(shortImageName, "clone.image");
	return noErr;
}

pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {
	/* User double-clicked an image file. Record the path to the VM''s directory,
	   then set the default directory to the folder containing the image and
	   record the image name. Fail if mullitple image files were selected. */

	OSErr		err;
	AEDesc		fileList = {''NULL'', NULL};
	long		numFiles, size;
	DescType	type;
	AEKeyword	keyword;
	FSSpec		fileSpec;
	WDPBRec		pb;

	reply; refCon;  /* reference args to avoid compiler warnings */

	/* record path to VM''s home folder */
	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);

	/* copy document list */
	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);
	if (err) goto done;

	/* count list elements */
	err = AECountItems( &fileList, &numFiles);
	if (err) goto done;
	if (numFiles !!= 1) {
		error("You may only open one Squeak image file at a time.");
	}

	/* get image name */
	err = AEGetNthPtr(&fileList, 1, typeFSS,
					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);
	if (err) goto done;
	strcpy(shortImageName, p2cstr(fileSpec.name));

	/* make image directory the default */
	pb.ioNamePtr = NULL;
	pb.ioVRefNum = fileSpec.vRefNum;
	pb.ioWDDirID = fileSpec.parID;
	PBHSetVolSync(&pb);

done:
	AEDisposeDesc(&fileList);
	return err;
}

pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {
	aevt; reply; refCon;  /* reference args to avoid compiler warnings */
	return errAEEventNotHandled;
}

pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {
	aevt; reply; refCon;  /* reference args to avoid compiler warnings */
	return errAEEventNotHandled;
}

/*** VM Home Directory Path ***/

int vmPathSize(void) {
	return strlen(vmPath);
}

int vmPathGetLength(int sqVMPathIndex, int length) {
	char *stVMPath = (char *) sqVMPathIndex;
	int count, i;

	count = strlen(vmPath);
	count = (length < count) ? length : count;

	/* copy the file name into the Squeak string */
	for (i = 0; i < count; i++) {
		stVMPath[i] = vmPath[i];
	}
	return count;
}

/*** Mac-related Functions ***/

void AdjustMenus(void) {
	WindowPeek		wp;
	int				isDeskAccessory;

	wp = (WindowPeek) FrontWindow();
	if (wp !!= NULL) {
		isDeskAccessory = (wp->windowKind < 0);
	} else {
		isDeskAccessory = false;
	}

	if (isDeskAccessory) {
		/* Enable items in the Edit menu */
		EnableItem(editMenu, 1);
		EnableItem(editMenu, 3);
		EnableItem(editMenu, 4);
		EnableItem(editMenu, 5);
		EnableItem(editMenu, 6);
	} else {
		/* Disable items in the Edit menu */
		DisableItem(editMenu, 1);
		DisableItem(editMenu, 3);
		DisableItem(editMenu, 4);
		DisableItem(editMenu, 5);
		DisableItem(editMenu, 6);
	}
}

int HandleEvents(void) {
	EventRecord		theEvent;
	int				ok;

	ok = GetNextEvent(everyEvent, &theEvent);
	if (ok) {
		switch (theEvent.what) {
			case mouseDown:
				HandleMouseDown(&theEvent);
				return false;
			break;

			case mouseUp:
				recordModifierButtons(&theEvent);
				return false;
			break;

			case keyDown:
			case autoKey:
				if ((theEvent.modifiers & cmdKey) !!= 0) {
					AdjustMenus();
					HandleMenu(MenuKey(theEvent.message & charCodeMask));
				}
				recordModifierButtons(&theEvent);
				recordKeystroke(&theEvent);
			break;

			case updateEvt:
				BeginUpdate(stWindow);
				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */
				EndUpdate(stWindow);
			break;

			case activateEvt:
				if (theEvent.modifiers & activeFlag) {
					windowActive = true;
				} else {
					GetMouse(&savedMousePosition);
					windowActive = false;
				}
				InvalRect(&stWindow->portRect);
			break;

			case kHighLevelEvent:
				AEProcessAppleEvent(&theEvent);
			break;
		}
	}
	return ok;
}

void HandleMenu(int mSelect) {
	int			menuID, menuItem;
	Str255		name;
	GrafPtr		savePort;

	menuID = HiWord(mSelect);
	menuItem = LoWord(mSelect);
	switch (menuID) {
		case appleID:
			GetPort(&savePort);
			GetItem(appleMenu, menuItem, name);
			OpenDeskAcc(name);
			SetPort(savePort);
		break;

		case fileID:
			if (menuItem == quitItem) {
				exit(-1);
			}
		break;

		case editID:
			if (!!SystemEdit(menuItem - 1)) {
				SysBeep(5);
			}
		break;
	}
}

void HandleMouseDown(EventRecord *theEvent) {
	WindowPtr	theWindow;
	Rect		growLimits = { 20, 20, 4000, 4000 };
	Rect		dragBounds;
	int			windowCode, newSize;

	windowCode = FindWindow(theEvent->where, &theWindow);
	switch (windowCode) {
		case inSysWindow:
			SystemClick(theEvent, theWindow);
		break;

		case inMenuBar:
			AdjustMenus();
			HandleMenu(MenuSelect(theEvent->where));
		break;

		case inDrag:
			dragBounds = qd.screenBits.bounds;
			if (theWindow == stWindow) {
				DragWindow(stWindow, theEvent->where, &dragBounds);
			}
		break;

		case inGrow:
			if (theWindow == stWindow) {
				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);
				if (newSize !!= 0) {
					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);
				}
			}
		break;

		case inContent:
			if (theWindow == stWindow) {
				if (theWindow !!= FrontWindow()) {
					SelectWindow(stWindow);
				}
				recordMouseDown(theEvent);
			}
		break;

		case inGoAway:
			if ((theWindow == stWindow) &&
				(TrackGoAway(stWindow, theEvent->where))) {
					/* HideWindow(stWindow); noop for now */
			}
		break;
	}
}

void InitMacintosh(void) {
	MaxApplZone();
	InitGraf(&qd.thePort);
	InitFonts();
	FlushEvents(everyEvent, 0);
	InitWindows();
	InitMenus();
	TEInit();
	InitDialogs(NULL);
	InitCursor();
}

void SetUpMenus(void) {
	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);
	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);
	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);
	DrawMenuBar();
	AddResMenu(appleMenu, ''DRVR'');
	AppendMenu(fileMenu, "\pQuit");
	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");
}

void SetColorEntry(int index, int red, int green, int blue) {
	(*stColorTable)->ctTable[index].value = index;
	(*stColorTable)->ctTable[index].rgb.red = red;
	(*stColorTable)->ctTable[index].rgb.green = green;
	(*stColorTable)->ctTable[index].rgb.blue = blue;
}

void FreePixmap(void) {
	if (stPixMap !!= nil) {
		DisposePixMap(stPixMap);
		stPixMap = nil;
	}

	if (stColorTable !!= nil) {
		DisposeHandle((void *) stColorTable);
		stColorTable = nil;
	}
}

void SetUpPixmap(void) {
	int i, r, g, b;

	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));
	(*stColorTable)->ctSeed = GetCTSeed();
	(*stColorTable)->ctFlags = 0;
	(*stColorTable)->ctSize = 255;

	/* 1-bit colors (monochrome) */
	SetColorEntry(0, 65535, 65535, 65535);	/* white */
	SetColorEntry(1,     0,     0,     0);	/* black */

	/* additional colors for 2-bit color */
	SetColorEntry(2, 32768, 32768, 32768);	/* 50% gray */
	SetColorEntry(3, 65535, 65535,     0);	/* yellow */

	/* additional colors for 4-bit color */
	SetColorEntry( 4, 65535,     0,     0);	/* red */
	SetColorEntry( 5,     0, 65535,     0);	/* green */
	SetColorEntry( 6,     0,     0, 65535);	/* blue */
	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */
	SetColorEntry( 8, 65535,     0, 65535);	/* magenta */
	SetColorEntry( 9,  8192,  8192,  8192);	/* 1/8 gray */
	SetColorEntry(10, 16384, 16384, 16384);	/* 2/8 gray */
	SetColorEntry(11, 24576, 24576, 24576);	/* 3/8 gray */
	SetColorEntry(12, 32768, 32768, 32768);	/* 4/8 gray */
	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */
	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */
	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */

	/* additional colors for 8-bit color */
	/* 24 more shades of gray (does not repeat 1/8th increments) */
	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */
	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */
	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */
	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */
	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */
	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */
	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */
	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */
	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */
	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */
	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */
	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */
	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */
	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */
	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */
	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */
	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */
	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */
	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */
	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */
	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */
	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */
	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */
	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */

	/* The remainder of color table defines a color cube with six steps
	   for each primary color. Note that the corners of this cube repeat
	   previous colors, but simplifies the mapping between RGB colors and
	   color map indices. This color cube spans indices 40 through 255.
	*/
	for (r = 0; r < 6; r++) {
		for (g = 0; g < 6; g++) {
			for (b = 0; b < 6; b++) {
				i = 40 + ((36 * r) + (6 * b) + g);
				if (i > 255) error("index out of range in color table compuation");
				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);
			}
		}
	}

	stPixMap = NewPixMap();
	(*stPixMap)->pixelType = 0; /* chunky */
	(*stPixMap)->cmpCount = 1;
	(*stPixMap)->pmTable = stColorTable;
}

void SetUpWindow(void) {
	Rect windowBounds = { 44, 8, 408, 648 };  /* default window bounds */
	Rect screen;
	int right, bottom;

	if (savedWindowSize !!= 0) {
		right  = windowBounds.left + ((unsigned) savedWindowSize >> 16);
		bottom = windowBounds.top  + (savedWindowSize & 0xFFFF);
	} else {
		right  = windowBounds.right;
		bottom = windowBounds.bottom;
	}

	/* minimum size is 64 x 64 */
	right  = ( right > (windowBounds.left + 64)) ?  right : (windowBounds.left + 64);
	bottom = (bottom > (windowBounds.top  + 64)) ? bottom : (windowBounds.top  + 64);

	/* maximum bottom-right is screen bottom-right */
	screen = qd.screenBits.bounds;
	right  = ( right <= screen.right)  ?  right : (screen.right  - 8);
	bottom = (bottom <= screen.bottom) ? bottom : (screen.bottom - 8);

	windowBounds.right = right;
	windowBounds.bottom = bottom;

	stWindow = NewCWindow(0L, &windowBounds, "\pSqueak", true, documentProc, (WindowPtr) -1L, true, 0);
}

void SetWindowSize(void);
void SetWindowSize(void) {
	Rect screen;
	int width, height, maxWidth, maxHeight;

	if (savedWindowSize !!= 0) {
		width  = (unsigned) savedWindowSize >> 16;
		height = savedWindowSize & 0xFFFF;
	} else {
		width  = 640;
		height = 480;
	}

	/* minimum size is 64 x 64 */
	width  = ( width > 64) ?   width : 64;
	height = (height > 64) ?  height : 64;

	/* maximum size is screen size */
	screen = qd.screenBits.bounds;
	maxWidth  = (screen.right  - screen.left) - 16;
	maxHeight = (screen.bottom - screen.top)  - 52;
	width  = ( width <= maxWidth)  ?  width : maxWidth;
	height = (height <= maxHeight) ? height : maxHeight;

	SizeWindow(stWindow, width, height, true);
}

/*** Event Recording Functions ***/

int recordKeystroke(EventRecord *theEvent) {
	int keystate;

	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */
	keystate =
		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |
		(theEvent->message & 0xFF);
	if (keystate == interruptKeycode) {
		/* Note: interrupt key is "meta"; it not reported as a keystroke */
		interruptPending = true;
		interruptCheckCounter = 0;
	} else {
		keyBuf[keyBufPut] = keystate;
		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;
		if (keyBufGet == keyBufPut) {
			/* buffer overflow; drop the last character */
			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;
			keyBufOverflows++;
		}
	}
}

int recordMouseDown(EventRecord *theEvent) {
	int stButtons;

	stButtons = 4;		/* red button by default */
	if ((theEvent->modifiers & optionKey) !!= 0) {
		stButtons = 2;	/* yellow button if option down */
	}
	if ((theEvent->modifiers & cmdKey) !!= 0) {
		stButtons = 1;	/* blue button if command down */
	}
	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */
	buttonState =
		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |
		(stButtons & 0x7);
}

int recordModifierButtons(EventRecord *theEvent) {
	int stButtons = 0;

	if (Button()) {
		stButtons = buttonState & 0x7;
	} else {
		stButtons = 0;
	}
	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */
	buttonState =
		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |
		(stButtons & 0x7);
}

/*** I/O Primitives ***/

int ioBeep(void) {
	SysBeep(1000);
}

int ioGetButtonState(void) {
	ioProcessEvents();  /* process all pending events */
	return buttonState;
}

int ioGetKeystroke(void) {
	int keystate;

	ioProcessEvents();  /* process all pending events */
	if (keyBufGet == keyBufPut) {
		return -1;  /* keystroke buffer is empty */
	} else {
		keystate = keyBuf[keyBufGet];
		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;
		/* set modifer bits in buttonState to reflect the last keystroke fetched */
		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);
	}
	return keystate;
}

int ioMicroMSecs(void) {
	/* millisecond clock based on microsecond timer (about 60 times slower than ioMSecs!!!!) */
	UnsignedWide microTicks;

	Microseconds(&microTicks);
	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);
}

int ioMousePoint(void) {
	Point p;

	ioProcessEvents();  /* process all pending events */
	if (windowActive) {
		GetMouse(&p);
	} else {
		/* don''t report mouse motion if window is not active */
		p = savedMousePosition;
	}
	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */
}

int ioPeekKeystroke(void) {
	int keystate;

	ioProcessEvents();  /* process all pending events */
	if (keyBufGet == keyBufPut) {
		return -1;  /* keystroke buffer is empty */
	} else {
		keystate = keyBuf[keyBufGet];
		/* set modifer bits in buttonState to reflect the last keystroke peeked at */
		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);
	}
	return keystate;
}

int ioProcessEvents(void) {
	/* This is a noop when running as a plugin; the browser handles events. */
	int maxPollsPerSec = 30;
	static clock_t nextPollTick = 0;

#ifndef PLUGIN
	if (clock() > nextPollTick) {
		/* time to process events!! */
		while (HandleEvents()) {
			/* process all pending events */
		}

		/* wait a while before trying again */
		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);
	}
#endif
}

int ioScreenSize(void) {
	int w = 10, h = 10;

	if (stWindow !!= nil) {
		w = stWindow->portRect.right - stWindow->portRect.left;
		h = stWindow->portRect.bottom - stWindow->portRect.top;
	}
	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */
}

int ioSeconds(void) {
	struct tm timeRec;
	time_t time1904, timeNow;

	/* start of ANSI epoch is midnight of Jan 1, 1904 */
	timeRec.tm_sec   = 0;
	timeRec.tm_min   = 0;
	timeRec.tm_hour  = 0;
	timeRec.tm_mday  = 1;
	timeRec.tm_mon   = 0;
	timeRec.tm_year  = 4;
	timeRec.tm_wday  = 0;
	timeRec.tm_yday  = 0;
	timeRec.tm_isdst = 0;
	time1904 = mktime(&timeRec);

	timeNow = time(NULL);

	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */
	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);
}

int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {
	Cursor macCursor;
	int i;

	for (i = 0; i < 16; i++) {
		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;
		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;
	}

	/* Squeak hotspot offsets are negative; Mac''s are positive */
	macCursor.hotSpot.h = -offsetX;
	macCursor.hotSpot.v = -offsetY;
	SetCursor(&macCursor);
}

int ioShowDisplay(
	int dispBitsIndex, int width, int height, int depth,
	int affectedL, int affectedR, int affectedT, int affectedB) {

	Rect		dstRect = { 0, 0, 0, 0 };
	Rect		srcRect = { 0, 0, 0, 0 };
	RgnHandle	maskRect = nil;

	if (stWindow == nil) {
		return;
	}

	dstRect.left	= 0;
	dstRect.top		= 0;
	dstRect.right	= width;
	dstRect.bottom	= height;

	srcRect.left	= 0;
	srcRect.top		= 0;
	srcRect.right	= width;
	srcRect.bottom	= height;

	(*stPixMap)->baseAddr = (void *) dispBitsIndex;
	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */
	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;
	(*stPixMap)->bounds = srcRect;
	(*stPixMap)->pixelSize = depth;
	(*stPixMap)->cmpSize = depth;

	/* create a mask region so that only the affected rectangle is copied */
	maskRect = NewRgn();
	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);

	SetPort(stWindow);
	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);
	DisposeRgn(maskRect);
}

/*** Image File Naming ***/

void RecordFullPathForImageName(char *localImageName) {
	int offset, localNameSize, i;

	offset = dir_PathToWorkingDir(imageName, IMAGE_NAME_SIZE);

	/* copy the file name into a null-terminated C string */
	localNameSize = strlen(localImageName);
	for (i = 0; i <= localNameSize; i++) {
		/* append localName, including terminator */
		imageName[i + offset] = localImageName[i];
	}
}

int imageNameSize(void) {
	return strlen(imageName);
}

int imageNameGetLength(int sqImageNameIndex, int length) {
	char *sqImageName = (char *) sqImageNameIndex;
	int count, i;

	count = strlen(imageName);
	count = (length < count) ? length : count;

	/* copy the file name into the Squeak string */
	for (i = 0; i < count; i++) {
		sqImageName[i] = imageName[i];
	}
	return count;
}

int imageNamePutLength(int sqImageNameIndex, int length) {
	char *sqImageName = (char *) sqImageNameIndex;
	int count, i;

	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;

	/* copy the file name into a null-terminated C string */
	for (i = 0; i < count; i++) {
		imageName[i] = sqImageName[i];
	}
	imageName[count] = 0;
	return count;
}

/*** Clipboard Support (text only for now) ***/

void SetUpClipboard(void) {
	/* allocate clipboard in the system heap to support really big copy/paste */
	THz oldZone;

	oldZone = GetZone();
	SetZone(SystemZone());
	clipboardBuffer = NewHandle(0);
	SetZone(oldZone);
}

void FreeClipboard(void) {
	if (clipboardBuffer !!= nil) {
		DisposeHandle(clipboardBuffer);
		clipboardBuffer = nil;
	}
}

int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {
	long clipSize, charsToMove;
	char *srcPtr, *dstPtr, *end;

	clipSize = clipboardSize();
	charsToMove = (count < clipSize) ? count : clipSize;

	srcPtr = (char *) *clipboardBuffer;
	dstPtr = (char *) byteArrayIndex + startIndex;
	end = srcPtr + charsToMove;
	while (srcPtr < end) {
		*dstPtr++ = *srcPtr++;
	}
	return charsToMove;
}

int clipboardSize(void) {
	long count, offset;

	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);
	if (count < 0) {
		return 0;
	} else {
		return count;
	}
}

int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {
	ZeroScrap();
	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));
}

/*** Profiling ***/

int clearProfile(void) {
#ifdef MAKE_PROFILE
	ProfilerClear();
#endif
}

int dumpProfile(void) {
#ifdef MAKE_PROFILE
	ProfilerDump("\pProfile.out");
#endif
}

int startProfiling(void) {
#ifdef MAKE_PROFILE
	ProfilerSetStatus(true);
#endif
}

int stopProfiling(void) {
#ifdef MAKE_PROFILE
	ProfilerSetStatus(false);
#endif
}

/*** Plugin Support ***/

int plugInInit(char *fullImagePath) {
	if (memory == nil) {
		return;	/* failed to read image */
	}

	/* check the interpreter''s size assumptions for basic data types */
	if (sizeof(int) !!= 4) {
		error("This C compiler''s integers are not 32 bits.");
	}
	if (sizeof(double) !!= 8) {
		error("This C compiler''s floats are not 64 bits.");
	}
	if (sizeof(time_t) !!= 4) {
		error("This C compiler''s time_t''s are not 32 bits.");
	}

	strcpy(imageName, fullImagePath);
	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);

	SetUpClipboard();
	SetUpPixmap();
	sqFileInit();
	joystickInit();
}

int plugInShutdown(void) {
	snd_Stop();
	FreeClipboard();
	FreePixmap();
	if (memory !!= nil) {
		DisposePtr((void *) memory);
		memory = nil;
	}
}

/*** Main ***/

#ifndef PLUGIN
void main(void) {
	EventRecord theEvent;
	FILE *f;
	int availableMemory;

	InitMacintosh();
	SetUpMenus();
	SetUpClipboard();
	SetUpWindow();
	SetUpPixmap();
	sqFileInit();
	joystickInit();

	/* install apple event handlers and wait for open event */
	InstallAppleEventHandlers();
	while (shortImageName[0] == 0) {
		GetNextEvent(everyEvent, &theEvent);
		if (theEvent.what == kHighLevelEvent) {
			AEProcessAppleEvent(&theEvent);
		}
	}
	RecordFullPathForImageName(shortImageName);

	/* check the interpreter''s size assumptions for basic data types */
	if (sizeof(int) !!= 4) {
		error("This C compiler''s integers are not 32 bits.");
	}
	if (sizeof(double) !!= 8) {
		error("This C compiler''s floats are not 64 bits.");
	}
	if (sizeof(time_t) !!= 4) {
		error("This C compiler''s time_t''s are not 32 bits.");
	}

#ifdef MAKE_PROFILE
	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);
	ProfilerSetStatus(false);
	ProfilerClear();
#endif

	/* compute the desired memory allocation */
	availableMemory = MaxBlock() - 80000;  /* reserve a little memory (at least 50000!!) */
	/******
	  Note: This is platform-specific. On the Mac, the user specifies the desired
	    memory partition for each application using the Finder''s Get Info command. On
	    other platforms, it would be specified in other ways (e.g, by a command line
	    argument. The maximum size of the object heap is fixed at at startup. If you
	    run out, you must save the image and restart with more memory.

	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.
	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the
	    console is opened. 50K allows the console to be opened (with and w/o the
	    profiler). I added another 30K to provide for sound buffers and reliability.
	******/

	/* uncomment the following when using the C transcript window for debugging: */
	//printf("Move this window, then hit CR\n"); getchar();

	/* read the image file and allocate memory for Squeak heap */
	f = fopen(imageName, "rb");
	if (f == NULL) {
		/* give a Mac-specific error message if image file is not found */
		printf("Could not open the Squeak image file ''%s''\n\n", imageName);
		printf("There are several ways to open a Squeak image file. You can:\n");
		printf("  1. Double-click on the desired image file.\n");
		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");
		printf("  3. Name your image ''clone.image'' and put it in the same folder as the\n");
		printf("     Squeak application, then double-click on the Squeak application.\n\n");
		printf("Press the return key to exit.\n");
		getchar();
		printf("Aborting...\n");
		exit(-1);
	}	
	readImageFromFileHeapSize(f, availableMemory);
	fclose(f);

	SetWindowSize();

	/* run Squeak */
	interpret();
}
#endif
'!
readmeFile

	^ 'Building the Squeak Virtual Machine

The virtual machine is build from one header and seven source files:

	sq.h				-- shared definitions included in all .c files
	sqFilePrims.c		-- file primitives
	sqMacDirectory.c	-- Mac directory enumerations
	sqMacJoystick.c		-- primitives to support Gravis MouseStickII joystick
	sqMacSound.c		-- Mac audio output primitives
	sqMacWindow.c		-- Mac window and event handling; main program
	sqSoundPrims.c		-- automatically generated sound synthesis primitives
	interp.c				-- automatically generated code for the virtual machine

The only files that are Mac-specific are stMacWindow.c, stMacDirectory.c, stMacJoystick.c, and stMacSound.c, totaling about 1800 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.

The code assumes that C ints are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time.

The files interp.c and sqSoundPrims.c are generated automatically, so changes to these files will be lost when the next interpreter is generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.

The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs could probably be worked around if one really wanted to use that environment.

The virtual machine uses the following libraries:

	Libraries for 68K Project:
		MathLib68K (4i/8d).Lib
		MacOS.lib
		profiler68k(Small).lib
		SIOUX.68K.Lib
		ANSI (4i/8d) C.68K.lib

	Libraries for PowerPC Project:
		ANSI C.PPC.Lib
		SIOUX.PPC.Lib
		InterfaceLib
		profilerPPC.lib
		MathLib
		MWCRuntime.Lib

To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop can be patched using the method "patchInterp:" in Interpreter class.

	-- John Maloney, December 12, 1996
'.!
squeakHeaderFile

	^ '#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define true 1
#define false 0
#define null 0  /* using ''null'' because nil is predefined in Think C */

/* platform-dependent float conversion macros */
/* Note: Second argument must be a variable name, not an expression!! */
/* Note: Floats in image are always in PowerPC word order; change
   these macros to swap words if necessary. This costs no extra and
   obviates sometimes having to word-swap floats when reading an image.
*/
#ifdef DOUBLE_WORD_ALIGNMENT
/* word-based copy for machines that require doubles to be double-word aligned */
#define storeFloatAtfrom(i, floatVarName) \
	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \
	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);
#define fetchFloatAtinto(i, floatVarName) \
	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \
	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);
#else
/* for machines that allow doubles to be on any word boundary */
#define storeFloatAtfrom(i, floatVarName) \
	*((double *) (i)) = (floatVarName);
#define fetchFloatAtinto(i, floatVarName) \
	(floatVarName) = *((double *) (i));
#endif

/*** increment this version number when the image file format changes ***/
#define CURRENT_VERSION 6502

/* squeak file record; see sqFilePrims.c for details */
typedef struct {
	FILE	*file;
	int		sessionID;
	int		writable;
	int		fileSize;
	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */
} SQFile;

/* file i/o */
int sqFileAtEnd(SQFile *f);
int sqFileClose(SQFile *f);
int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);
int sqFileGetPosition(SQFile *f);
int sqFileInit(void);
int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);
int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);
int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);
int sqFileSetPosition(SQFile *f, int position);
int sqFileSize(SQFile *f);
int sqFileValid(SQFile *f);
int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);

/* directories */
int dir_Create(char *pathString, int pathStringLength);
int dir_Delimitor(void);
int dir_Lookup(char *pathString, int pathStringLength, int index,
	/* outputs: */
	char *name, int *nameLength, int *creationDate, int *modificationDate,
	int *isDirectory, int *sizeIfFile);
int dir_PathToWorkingDir(char *pathName, int pathNameMax);
int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);

/* interpreter entry points */
void error(char *s);
int checkedByteAt(int byteAddress);
int checkedByteAtput(int byteAddress, int byte);
int checkedLongAt(int byteAddress);
int checkedLongAtput(int byteAddress, int a32BitInteger);
int fullDisplayUpdate(void);
int initializeInterpreter(int bytesToShift);
int interpret(void);
int success(int);

/* display, mouse, keyboard, time i/o */
int ioBeep(void);
int ioGetButtonState(void);
int ioGetKeystroke(void);
int ioMicroMSecs(void);
int ioMousePoint(void);
int ioPeekKeystroke(void);
int ioProcessEvents(void);
int ioScreenSize(void);
int ioSeconds(void);
int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);
int ioShowDisplay(
	int dispBitsIndex, int width, int height, int depth,
	int affectedL, int affectedR, int affectedT, int affectedB);

/* millisecond clock based on vertical retrace timer (1/60th second) */
#define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)

/* image file and VM path names */
extern char imageName[];
int imageNameGetLength(int sqImageNameIndex, int length);
int imageNamePutLength(int sqImageNameIndex, int length);
int imageNameSize(void);
int vmPathSize(void);
int vmPathGetLength(int sqVMPathIndex, int length);

/* save/restore */
int readImageFromFileHeapSize(FILE *f, int desiredHeapSize);

/* clipboard (cut/copy/paste) */
int clipboardSize(void);
int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);
int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);

/* sound output */
int snd_AvailableSpace(void);
int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);
int snd_PlaySilence(void);
int snd_Start(int frameCount, int samplesPerSec, int stereo);
int snd_Stop(void);

/* joystick support */
int joystickInit(void);
int joystickRead(int stickIndex);

/* netscape plug-in support */
int plugInInit(char *imageName);
int plugInShutdown(void);
int plugInInterpretCycles(int cycleCount);

/* interpreter entry points needed by compiled primitives */
void * arrayValueOf(int arrayOop);
int checkedIntegerValueOf(int intOop);
void * fetchArrayofObject(int fieldIndex, int objectPointer);
double fetchFloatofObject(int fieldIndex, int objectPointer);
int fetchIntegerofObject(int fieldIndex, int objectPointer);
double floatValueOf(int floatOop);
int pop(int nItems);
int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);

/* sound generation primitives */
int primWaveTableSoundmixSampleCountintostartingAtpan(void);
int primFMSoundmixSampleCountintostartingAtpan(void);
int primPluckedSoundmixSampleCountintostartingAtpan(void);

/* profiling */
int clearProfile(void);
int dumpProfile(void);
int startProfiling(void);
int stopProfiling(void);
'.! !

LargeNegativeInteger comment:
'Just like LargePositiveInteger, but represents a negative number.'!

LargePositiveInteger comment:
'I represent a positive large integer, integers greater than 2-to-the-30th (1073741824).  These are beyond the range of SmallInteger, encoded as an array of 8-bit digits.  Care must be taken, when new results are computed, that any value that COULD BE a SmallInteger IS a SmallInteger (see normalize).'!
!LargePositiveInteger methodsFor: 'arithmetic'!
* anInteger 
	"Primitive. Multiply the receiver by the argument and answer with an
	Integer result. Fail if either the argument or the result is not a
	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See
	Object documentation whatIsAPrimitive. "

	<primitive: 29>
	^super * anInteger!
+ anInteger 
	"Primitive. Add the receiver to the argument and answer with an
	Integer result. Fail if either the argument or the result is not a
	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See
	Object documentation whatIsAPrimitive."

	<primitive: 21>
	^super + anInteger!
- anInteger 
	"Primitive. Subtract the argument from the receiver and answer with an
	Integer result. Fail if either the argument or the result is not a
	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See
	Object documentation whatIsAPrimitive."

	<primitive: 22>
	^super - anInteger!
/ anInteger 
	"Primitive. Divide the receiver by the argument and answer with the
	result if the division is exact. Fail if the result is not a whole integer.
	Fail if the argument is 0. Fail if either the argument or the result is not
	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See
	Object documentation whatIsAPrimitive. "

	<primitive: 30>
	^super / anInteger!
// anInteger 
	"Primitive. Divide the receiver by the argument and return the result.
	Round the result down towards negative infinity to make it a whole
	integer. Fail if the argument is 0. Fail if either the argument or the
	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).
	Optional. See Object documentation whatIsAPrimitive. "

	<primitive: 32>
	^super // anInteger!
quo: anInteger 
	"Primitive. Divide the receiver by the argument and return the result.
	Round the result down towards zero to make it a whole integer. Fail if
	the argument is 0. Fail if either the argument or the result is not a
	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See
	Object documentation whatIsAPrimitive."

	<primitive: 33>
	^super quo: anInteger!
\\ anInteger 
	"Primitive. Take the receiver modulo the argument. The result is the
	remainder rounded towards negative infinity, of the receiver divided
	by the argument. Fail if the argument is 0. Fail if either the argument
	or the result is not a SmallInteger or a LargePositiveInteger less than
	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."

	<primitive: 31>
	^super \\ anInteger! !
!LargePositiveInteger methodsFor: 'comparing'!
< anInteger 
	"Primitive. Compare the receiver with the argument and answer true if
	the receiver is less than the argument. Otherwise answer false. Fail if the
	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 23>
	^super < anInteger!
<= anInteger 
	"Primitive. Compare the receiver with the argument and answer true if
	the receiver is less than or equal to the argument. Otherwise answer false.
	Fail if the argument is not a SmallInteger or a LargePositiveInteger less
	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."

	<primitive: 25>
	^super <= anInteger!
= anInteger 
	"Primitive. Compare the receiver with the argument and answer true if
	the receiver is equal to the argument. Otherwise answer false. Fail if the
	receiver or argument is negative or greater than 32 bits.
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 7>
	^ super = anInteger!
> anInteger 
	"Primitive. Compare the receiver with the argument and answer true if
	the receiver is greater than the argument. Otherwise answer false. Fail if
	the argument is not a SmallInteger or a LargePositiveInteger less than
	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."

	<primitive: 24>
	^super > anInteger!
>= anInteger 
	"Primitive. Compare the receiver with the argument and answer true if
	the receiver is greater than or equal to the argument. Otherwise answer
	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger
	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."

	<primitive: 26>
	^super >= anInteger! !

LeafNode comment:
'I represent a leaf node of the compiler parse tree. I am abstract.
	
Types (defined in class ParseNode):
	1 LdInstType (which uses class VariableNode)
	2 LdTempType (which uses class VariableNode)
	3 LdLitType (which uses class LiteralNode)
	4 LdLitIndType (which uses class VariableNode)
	5 SendType (which uses class SelectorNode).

Note that Squeak departs slightly from the Blue Book bytecode spec.

In order to allow access to more than 63 literals and instance variables,
bytecode 132 has been redefined as DoubleExtendedDoAnything:
		byte2				byte3			Operation
(hi 3 bits)  (lo 5 bits)
	0		nargs			lit index			Send Literal Message 0-255
	1		nargs			lit index			Super-Send Lit Msg 0-255
	2		ignored			rcvr index		Push Receiver Variable 0-255
	3		ignored			lit index			Push Literal Constant 0-255
	4		ignored			lit index			Push Literal Variable 0-255
	5		ignored			rcvr index		Store Receiver Variable 0-255
	6		ignored			rcvr index		Store-pop Receiver Variable 0-255
	7		ignored			lit index			Store Literal Variable 0-255

	This has allowed bytecode 134 also to be redefined as a second extended send
	that can access literals up to 64 for nargs up to 3 without needing three bytes.
	It is just like 131, except that the extension byte is aallllll instead of aaalllll,
	where aaa are bits of argument count, and lll are bits of literal index.'!
!LeafNode methodsFor: 'code generation'!
emitLong: mode on: aStream 
	"Emit extended variable access."
	| type index |
	code < 256
		ifTrue:
			[code < 16
			ifTrue: [type _ 0.
					index _ code]
			ifFalse: [code < 32
					ifTrue: [type _ 1.
							index _ code - 16]
					ifFalse: [code < 96
							ifTrue: [type _ code // 32 + 1.
									index _ code \\ 32]
							ifFalse: [self error: 
									'Sends should be handled in SelectorNode']]]]
		ifFalse: 
			[index _ code \\ 256.
			type _ code // 256 - 1].
	index <= 63 ifTrue:
		[aStream nextPut: mode.
		^ aStream nextPut: type * 64 + index].
	"Compile for Double-exetended Do-anything instruction..."
	mode = LoadLong ifTrue:
		[aStream nextPut: DblExtDoAll.
		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"
		^ aStream nextPut: index].
	mode = Store ifTrue:
		[aStream nextPut: DblExtDoAll.
		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"
		^ aStream nextPut: index].
	mode = StorePop ifTrue:
		[aStream nextPut: DblExtDoAll.
		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"
		^ aStream nextPut: index].
!
sizeForValue: encoder
	self reserve: encoder.
	code < 256 ifTrue: [^ 1].
	(code \\ 256) <= 63 ifTrue: [^ 2].
	^ 3! !
!ListParagraph methodsFor: 'private'!
withArray: anArray 
	"Modifies self to contain the list of strings in anArray"
	| startOfLine endOfLine lineIndex aString |
	lines _ Array new: 20.
	lastLine _ 0.
	startOfLine _ 1.
	endOfLine _ 1.
	lineIndex _ 0.
	anArray do: 
		[:item | 
		endOfLine _ startOfLine + item size.		"this computation allows for a cr after each line..."
												"...but later we will adjust for no cr after last line"
		lineIndex _ lineIndex + 1.
		self lineAt: lineIndex put:
			((TextLineInterval start: startOfLine stop: endOfLine
				internalSpaces: 0 paddingWidth: 0)
				lineHeight: textStyle lineGrid baseline: textStyle baseline).
		startOfLine _ endOfLine + 1].
	endOfLine _ endOfLine - 1.		"endOfLine is now the total size of the text"
	self trimLinesTo: lineIndex.
	aString _ String new: endOfLine.
	anArray with: lines do: 
		[:item :interval | 
		aString
			replaceFrom: interval first
			to: interval last - 1
			with: item
			startingAt: 1.
		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].
	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"
	self text: aString asText.
	self updateCompositionHeight! !
!ListParagraph class methodsFor: 'instance creation'!
withArray: anArray
	"Convert an array of strings into a ListParagraph."

	^ (super withText: Text new style: ListStyle) withArray: anArray! !
!ListParagraph class methodsFor: 'initialization'!
initialize  "ListParagraph initialize"
	"Allow different line spacing for lists"
	ListStyle _ TextStyle default copy gridForFont: 1 withLead: 1! !
!ListView methodsFor: 'initialize-release'!
initialize 
	"Refer to the comment in View|initialize."

	super initialize.
	topDelimiter _ '------------'.
	bottomDelimiter _ '------------'.
	isEmpty _ true.
	self list: Array new! !
!ListView methodsFor: 'list access'!
list: anArray 
	"Set the list of items the receiver displays to be anArray."
	| arrayCopy i |
	isEmpty _ anArray isEmpty.
	arrayCopy _ Array new: (anArray size + 2).
	arrayCopy at: 1 put: topDelimiter.
	arrayCopy at: arrayCopy size put: bottomDelimiter.
	i _ 2.
	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].
	arrayCopy _ arrayCopy copyWithout: nil.
	list _ ListParagraph withArray: arrayCopy.
	selection _ 0.
	self positionList! !
!ListView methodsFor: 'displaying'!
scrollSelectionIntoView
	"Selection is assumed to be on and clipped out of view.
	Uses controller scrollView to keep selection right"
	| delta |
	(delta _ self insetDisplayBox bottom - self selectionBox bottom) < 0
		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"
	(delta _ self insetDisplayBox top - self selectionBox top) > 0
		ifTrue: [^ self controller scrollView: delta + 1] "down"! !
!LiteralNode methodsFor: 'code generation'!
emitForValue: stack on: strm

	code < 256
		ifTrue: [strm nextPut: code]
		ifFalse: [self emitLong: LoadLong on: strm].
	stack push: 1! !
!LiteralNode methodsFor: 'C translation'!
asTranslatorNode 
	^TConstantNode new setValue: key! !
!MaskedForm methodsFor: 'access'!
colorMap: anArray 
	"Map the pixelValues in theForm through the colors is this array.  Array should be 2^(theForm depth) long.  If shorter, will be padded.  If longer, truncated.  Map is cached in rawColorMap.  6/28/96 tk"
	| d mapSize |
	anArray == nil ifTrue: ["clear it"
		colorMap _ nil.
		rawColorMap _ nil.	"uncache"
		^ self].
	d _ theForm depth.
	colorMap _ anArray.
	mapSize _ (1 bitShift: d) min: (512 max: anArray size).
		"Want 2^^depth, except where huge, except if big map supplied"
	rawColorMap _ Bitmap new: mapSize.
	colorMap doWithIndex: [:color :ind |
		rawColorMap at: ind put: (color pixelWordForDepth: d)].
		"Note that we don't supply default colors in the added part of the map.  We assume no pixel values are used outside the supplied map." !
colorMap: anArray depth: d
	"Set rawColorMap for case when display depth is 16 or 24, and theForm is 8 bits.  256 values, but at higher resolution for each.  GIFs use this.  Pixels unchanged at 8 bits, colorMap of colors, rawColorMap of 16 or 24 bit values.  12/8/96 tk"

	| mapSize |
	anArray == nil ifTrue: ["clear it"
		colorMap _ nil.
		^ rawColorMap _ nil].	"uncache"
	colorMap _ anArray.
	mapSize _ (1 bitShift: theForm depth) min: (512 max: anArray size).
		"Want 2^^depth, except where huge, except if big map supplied"
	rawColorMap _ Bitmap new: mapSize.
	colorMap doWithIndex: [:color :ind |
		rawColorMap at: ind put: (color pixelWordForDepth: d)].
		"Note that we don't supply default colors in the added part of the map.  We assume no pixel values are used outside the supplied map." !
rawColorMap: map
	"Map the pixelValues in theForm to the 32-bit raw color pixel-values is this array.  This is what BitBlt wants and is computed for theForm's depth.  12/6/96 tk"

	rawColorMap _ map! !
!MaskedForm methodsFor: 'pattern'!
applyColorMap
	"Convert theForm to the best approximation of the colors in colorMap.  Then make the map be nil.  Informaion will be lost.  Converts the arbitrary 256 colors in the picture (via the map) to the standard 256 colors.  When colorMaps are fully supported, stop using this.  7/1/96 tk"

	| port |
	port _ BitBlt toForm: theForm.
	port colorMap: self rawColorMap.
	theForm displayOnPort: port at: 0@0.
		"Write over self using the transforming color map"
	colorMap _ nil.
	rawColorMap _ nil.! !
!MaskedForm methodsFor: 'displaying'!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle
rule: ruleInteger fillColor: fillColor
	"This is the real display message.  Remove the area of the mask,
and OR in theForm."

	| port doTrans |
	(rawColorMap == nil) ifTrue: [
		(aDisplayMedium depth > 8) & (theForm depth <= 8) ifTrue: [
			doTrans _ true.
			rawColorMap _ (Color defaultColorMapFrom: theForm
depth
					to: aDisplayMedium depth) copy.	"If
speed is a problem, we can
						establish a cache for
transparnt color maps and reuse"
			rawColorMap at: 1 "0+1" put: 0]].
			"already transparent->0 in theForm (8 bits), map in
copyBits 0->32767 (white).
				We override with 0->0 for transparent."
	(aDisplayMedium isKindOf: MaskedForm)
		ifFalse: ["aDisplayMedium is a normal Form"
			mask displayOn: aDisplayMedium
				at: aDisplayPoint
				clippingBox: clipRectangle
				rule: Form erase1bitShape
				fillColor: nil.	"Cut a hole in the picture
with my mask"
			rawColorMap == nil ifTrue: [
					theForm displayOn: aDisplayMedium
						at: aDisplayPoint
						clippingBox: clipRectangle
						rule: Form under	"OR
my picture into the hole"
						fillColor: fillColor]
				ifFalse: [
					port _ BitBlt toForm: aDisplayMedium.
					port colorMap: rawColorMap.
					port clipRect: clipRectangle.
					port copyForm: theForm to:
aDisplayPoint rule: Form under]]
		ifTrue: ["aDisplayMedium is a MaskedForm"
			mask displayOn: aDisplayMedium mask
				at: aDisplayPoint
				clippingBox: clipRectangle
				rule: Form under
				fillColor: nil.	"OR my mask into the mask"
			mask displayOn: aDisplayMedium form
				at: aDisplayPoint
				clippingBox: clipRectangle
				rule: Form erase1bitShape
				fillColor: nil.	"Cut a hole in the picture
with my mask"
			rawColorMap == nil ifTrue: [
					theForm displayOn: aDisplayMedium form
						at: aDisplayPoint
						clippingBox: clipRectangle
						rule: Form under	"OR
my picture into the hole"
						fillColor: fillColor]
				ifFalse: [
					port _ BitBlt toForm:
aDisplayMedium form.
					port colorMap: rawColorMap.
					port clipRect: clipRectangle.
					port copyForm: theForm to:
aDisplayPoint rule: Form under]].

	doTrans == true ifTrue: [rawColorMap _ nil].	"put it back"
!
displayOn: aDisplayMedium transformation: displayTransformation
clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule:
ruleInteger fillColor: aForm
	"Copied from Form, basically"
	| absolutePoint scale magnifiedForm |
	absolutePoint _ displayTransformation applyTo: relativePoint.
	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.
	displayTransformation noScale
		ifTrue: [magnifiedForm _ self]
		ifFalse:
			[scale _ displayTransformation scale.
			scale = (1@1)
					ifTrue: [scale _ nil. magnifiedForm
_ self]
					ifFalse: [magnifiedForm _ self
magnify: self boundingBox by: scale]].
	magnifiedForm
		displayOn: aDisplayMedium
		at: absolutePoint - alignmentPoint
		clippingBox: clipRectangle
		rule: ruleInteger
		fillColor: aForm!
displayOnPort: port at: location
	"Must map between different form depths.  12/10/96 tk"

	| save map |
	(rawColorMap == nil) 
		ifFalse: [map _ rawColorMap]
		ifTrue: [
			(port destForm depth > 8) & (theForm depth <= 8) ifTrue: [
				map _ (Color defaultColorMapFrom: theForm depth 
						to: port destForm depth) copy.	"If speed is a problem, we can 
							establish a cache for transparnt color maps and reuse"
				map at: 1 "0+1" put: 0]]. 
				"already transparent->0 in theForm (8 bits), map in copyBits 0->32767 (white).  
					We override with 0->0 for transparent."
	port copyForm: mask to: location rule: Form erase1bitShape.
	port destForm depth ~= theForm depth 
		ifTrue: ["need a map"
			save _ port colorMap.
			port colorMap: map.
			port copyForm: theForm to: location rule: Form under.
			port colorMap: save]
		ifFalse: [port copyForm: theForm to: location rule: Form under]! !
!MaskedForm methodsFor: 'scaling'!
magnify: aRectangle by: scale 
	"Answer an MaskedForm created as a multiple of the receiver; the
result is smaller. Each bit in the new form corresponds to scale number of
bits in the receiver."

	^ (MaskedForm new setForm: (theForm magnify: aRectangle by: scale)
		mask: (mask magnify: aRectangle by: scale)
		removeOverlap: false transpPixVal: transparentPixelValue)
		colorMap: colorMap;
		rawColorMap: rawColorMap!
shrink: aRectangle by: scale
	"Answer an MaskedForm created as a multiple of the receiver; the result is smaller. Each bit in the new form corresponds to scale number of bits in the receiver."

	^ (MaskedForm new setForm: (theForm shrink: aRectangle by: scale)
		mask: (mask shrink: aRectangle by: scale)
		removeOverlap: false transpPixVal: transparentPixelValue)
		colorMap: colorMap;
		rawColorMap: rawColorMap! !
!MaskedForm methodsFor: 'setup'!
setForm: aForm transparentColor: aColor
	"Create a MaskedForm with transparent where aColor is.  Substitute
0 into theForm where the mask is 1.  6/21/96 tk"

	| d cMap |
	theForm _ aForm.
	aColor == nil ifTrue: [
		"no transparency, take whole form, don't mask off any of it."
		mask _ Form extent: theForm extent offset: theForm offset.
		mask fillWithColor: #black.
		^ self].
	d _ theForm depth.
	transparentPixelValue _ aColor pixelValueForDepth: d.
	mask _ Form extent: theForm extent offset: theForm offset.
	  "Copy the figure"
	cMap _ Bitmap new: (1 bitShift: d) withAll: 1.
	cMap at: transparentPixelValue+1 put: 0.
	mask copyBits: mask boundingBox from: theForm
		at: 0@0 colorMap: cMap.

	"Erase the color pixelValues where theForm needs to be transparent"
	transparentPixelValue = 0 ifFalse: [self removeOverlap].
!
setForm: aForm transparentPixelValue: pixVal
	"Create a MaskedForm with transparent where aColor is.  Substitute
0 into theForm where the mask is 1.  6/21/96 tk"

	| tColorMap |
	theForm _ aForm.
	transparentPixelValue _ pixVal.
	mask _ Form extent: theForm extent offset: theForm offset.
	  "Copy the figure, depth 1"
	tColorMap _ Bitmap new: (1 bitShift: theForm depth) withAll: 1.
	tColorMap at: transparentPixelValue+1 put: 0.
	mask copyBits: mask boundingBox from: theForm
		at: 0@0 colorMap: tColorMap.

	"Erase the color pixelValues where theForm needs to be transparent"
	transparentPixelValue = 0 ifFalse: [self removeOverlap].
		! !
!MaskedForm class methodsFor: 'instance creation'!
makeShip: aScale hd: aHeading
	"Make a 'ship' (arrowhead-shaped) facing in the heading given by aHeading.   Use s as scale factor.
	 By Alan Kay 2/96.  Simplified and reformatted by 5/30/96 sw"

	| sampleForm scaled aPen m n r loc  box | 

	scaled _ (80 * aScale) asInteger.
	sampleForm _ Form extent: (scaled@scaled) depth: 8.  "Make a form"
	sampleForm fillWithColor: Color lightGreen lighter lighter.
	aPen _ Pen newOnForm: sampleForm. 

"make a ship shape"
	loc _ 40@40. 		
	m _ 8. n _ 20. r _ 54.
	aPen place: loc. aPen north.
		box _ loc corner: loc.
	aPen turn: aHeading +180; up.
	aPen go: m * aScale; down; turn: 45.
		box _ box encompass: aPen location.
	aPen go: n * aScale.
		box _ box encompass: aPen location.
	aPen turn: 150; go: r * aScale.
		box _ box encompass: aPen location.
	aPen place: loc. aPen north.
	aPen turn: aHeading + 180; up.
	aPen go: m * aScale; down; turn: -45.
		box _ box encompass: aPen location.
	aPen go: n* aScale.
		box _ box encompass: aPen location.
	aPen turn: -150; go: r * aScale.
		box _ box encompass: aPen location.

	^ Cursor wait showWhile:		"Transparent around the outside"
		[self from: sampleForm box: ((box truncated) expandBy: 2)].

"Try it.
	(MaskedForm makeShip: 1 hd: 0) followCursor
"


! !
!MessageCategoryListView methodsFor: 'updating'!
list: anArray 
	super list: anArray.
	(Preferences browserAutoSelect and: [list numberOfLines = 3]) ifTrue:
		[controller isNil ifFalse: [controller changeModelSelection: 1]].
! !
!MessageListController methodsFor: 'menu messages'!
methodHierarchy
	"Create and schedule a message browser on the hierarchical implementors."

	self controlTerminate.
	model methodHierarchy.
	self controlInitialize!
shiftedYellowButtonMenu
	"Answer the menu to be put up when shift key is down.  1/26/96 sw"

	^ PopUpMenu labels: 'browse full
browse inheritance
browse method
implementors of sent messages
inspect instances
inspect subinstances
remove from browser
more...' 
lines: #(4 6)!
shiftedYellowButtonMessages
	"Answer the messages corresponding to the shifted-yellow-button menu, to be put up when shift key is down.  1/26/96 sw.  Adjustments, 2/5/96 sw"

	^ #(browseFull methodHierarchy browse allImplementorsOf inspectInstances inspectSubInstances removeMessageFromBrowser unshiftedYellowButtonActivity)! !
!MessageListView methodsFor: 'updating'!
displayView 
	"Refer to the comment in View|displayView."

	| aClass sel index baseClass |
	Browser postOpenSuggestion == nil ifFalse: [
		"Set the class and message"
		aClass _ Browser postOpenSuggestion first.
		sel _ Browser postOpenSuggestion last.
		Browser postOpenSuggestion: nil.
		baseClass _ aClass theNonMetaClass.
		model systemCategoryListIndex:
			(SystemOrganization numberOfCategoryOfElement: baseClass name).
		model selectClass: baseClass.
		model metaClassIndicated: aClass isMeta.
		sel notNil ifTrue: [
			model messageCategoryListIndex:
				(index _ aClass organization numberOfCategoryOfElement: sel).
			model messageListIndex: 
				((aClass organization listAtCategoryNumber: index) indexOf: sel)
			].
		self topView deEmphasize.
		^ self   "a redisplay has already been done"].
	super displayView.! !
!MessageNode methodsFor: 'macro transformations'!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
		and: [initStmt isMemberOf: AssignmentNode])
		ifFalse: [^ nil].
	body _ arguments last statements.
	variable _ initStmt variable.
	increment _ body last toDoIncrement: variable.
	(increment == nil or: [receiver statements size ~= 1])
		ifTrue: [^ nil].
	test _ receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	((test isMemberOf: MessageNode)
		and: [(limit _ test toDoLimit: variable) notNil])
		ifFalse: [^ nil].
	toDoBlock _ BlockNode new
			statements: (body copyFrom: 1 to: body size-1)
			returns: false.
	toDoBlock arguments: (Array with: variable).
	^ MessageNode new
		receiver: initStmt value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence!
toDoWithLimit: limitStmt
	"The receiver is a to:do: statement, preceded by a statement
	that might be of the form {iLimiT _ expr}.  If so, replace the
	limit argument by the given expr and return a new to:do: node.
	Otherwise, return nil"
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable = arguments first])
		ifFalse: [^ nil].
	limitStmt variable key = (arguments last firstArgument key , 'LimiT')
		ifFalse: [^ nil].  "Must be a generated temp"
	arguments at: 1 put: (limitStmt value)!
transformToDo: encoder
	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "
	| limit increment block initStmt test incStmt limitInit blockVar |
	"First check for valid arguments"
	((arguments last isMemberOf: BlockNode)
			and: [arguments last numberOfArguments = 1])
		ifFalse: [^ false].
	arguments last firstArgument isVariableReference
		ifFalse: [^ false]. "As with debugger remote vars"
	arguments size = 3
		ifTrue: [increment _ arguments at: 2.
				increment isConstantNumber ifFalse: [^ false]]
		ifFalse: [increment _ encoder encodeLiteral: 1].
	arguments size < 3 ifTrue:   "transform to full form"
		[selector _ SelectorNode new key: #to:by:do: code: #macro].

	"Now generate auxiliary structures"
	block _ arguments last.
	blockVar _ block firstArgument.
	initStmt _ AssignmentNode new variable: blockVar value: receiver.
	limit _ arguments at: 1.
	limit isVariableReference | limit isConstantNumber
		ifTrue: [limitInit _ nil]
		ifFalse:  "Need to store limit in a var"
			[limit _ encoder autoBind: blockVar key , 'LimiT'.
			limit scope: -2.  "Already done parsing block"
			limitInit _ AssignmentNode new
					variable: limit
					value: (arguments at: 1)].
	test _ MessageNode new receiver: blockVar
			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])
			arguments: (Array with: limit)
			precedence: precedence from: encoder.
	incStmt _ AssignmentNode new
			variable: blockVar
			value: (MessageNode new
				receiver: blockVar selector: #+
				arguments: (Array with: increment)
				precedence: precedence from: encoder).
	arguments _ (Array with: limit with: increment with: block)
		, (Array with: initStmt with: test with: incStmt with: limitInit).
	^ true! !
!MessageNode methodsFor: 'code generation'!
emitForValue: stack on: strm

	special > 0
		ifTrue: 
			[self perform: (MacroEmitters at: special) with: stack with: strm with: true.
			pc _ 0]
		ifFalse: 
			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].
			arguments do: [:argument | argument emitForValue: stack on: strm].
			selector
				emit: stack
				args: arguments size
				on: strm
				super: receiver == NodeSuper.
			pc _ strm position]!
sizeForValue: encoder
	| total argSize |
	special > 0 
		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].
	receiver == NodeSuper
		ifTrue: [selector _ selector copy "only necess for splOops"].
	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.
	receiver == nil 
		ifFalse: [total _ total + (receiver sizeForValue: encoder)].
	sizes _ arguments collect: 
					[:arg | 
					argSize _ arg sizeForValue: encoder.
					total _ total + argSize.
					argSize].
	^total! !
!MessageNode methodsFor: 'printing'!
printKeywords: key arguments: args on: aStream indent: level
	| keywords prev arg indent thisKey |
	args size = 0 
		ifTrue: [aStream space.
				aStream withAttribute: (TextLinkToImplementors of: key)
					do: [aStream nextPutAll: key].
				^ self].
	keywords _ key keywords.
	prev _ receiver.
	1 to: keywords size do:
		[:part | arg _ args at: part.
		thisKey _ keywords at: part.
		(prev isMemberOf: BlockNode)
		 | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])
		 | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])
		 | (args size > 2)
		 | (key = #ifTrue:ifFalse:)
			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"
			ifFalse: [aStream space. indent _ 0].
		aStream withAttribute: (TextLinkToImplementors of: key) do: 
			[aStream nextPutAll: thisKey].  aStream space.
		arg  printOn: aStream indent: level + 1 + indent
			 precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).
		prev _ arg]!
printToDoOn: aStream indent: level
	| limitNode |
	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode _ arguments first]
		ifFalse: [limitNode _ arguments last value].
	(selector key = #to:by:do:
			and: [(arguments at: 2) isConstantNumber
				and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array with: limitNode) ,
								(arguments copyFrom: 2 to: arguments size)
					on: aStream indent: level]! !
!MessageNode methodsFor: 'C translation'!
asTranslatorNode
	"selector is sometimes a Symbol, sometimes a SelectorNode!!
	On top of this, numArgs is needed due to the (truly grody) use of
	arguments as a place to store the extra expressions needed to generate
	code for in-line to:by:do:, etc.  see below, where it is used."
	| sel args |
	sel _ (selector isMemberOf: Symbol) ifTrue: [selector] ifFalse: [selector key].
	args _ (1 to: sel numArgs) collect:
			[:i | (arguments at: i) asTranslatorNode].
	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])
		ifTrue: ["Restore limit expr that got moved by transformToDo:"
				args at: 1 put: (arguments at: 7) value asTranslatorNode].
	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])
		ifTrue: ["Restore argument block that got moved by transformOr:"
				args at: 1 put: (arguments at: 2) asTranslatorNode].
	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])
		ifTrue: ["Restore argument block that got moved by transformIfFalse:"
				args at: 1 put: (arguments at: 2) asTranslatorNode].
	^ TSendNode new
		setSelector: sel
		receiver: ((receiver == nil)
					ifTrue: [nil]
					ifFalse: [receiver asTranslatorNode])
		arguments: args! !
!MessageSet methodsFor: 'contents'!
contents: aString notifying: aController 
	"Compile the code in aString. Notify aController of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."
	| category selector notice |
	messageListIndex = 0 ifTrue: [^ false].
	self setClassAndSelectorIn: [:class :oldSelector].
	category _ class organization categoryOfElement: oldSelector.
	selector _ class
				compile: aString
				classified: category
				notifying: aController.
	selector == nil ifTrue: [^false].
	selector == oldSelector ifFalse: [self messageListIndex: 0].
	notice _ class checkForPerform: selector in: aController.
	notice size = 0 ifFalse: ["insert the notice"
			aController notify: notice
				at: contents size + 1
				in: nil.
			self lock  "code is dirty"].
	^true! !
!MessageTally methodsFor: 'printing'!
printOn: aStream total: total tallyExact: isExact
	| aSelector className myTally |
	isExact ifTrue:
		[myTally _ tally.
		receivers == nil
			ifFalse: [receivers do: [:r | myTally _ myTally - r tally]].
		aStream print: myTally; space]
		ifFalse:
		[aStream print: (tally asFloat / total * 100.0 roundTo: 0.1); space].
	receivers == nil
		ifTrue: [aStream nextPutAll: 'primitives'; cr]
		ifFalse: 
			[aSelector _ class selectorAtMethod: method setClass: [:aClass].
			className _ aClass name contractTo: 30.
			aStream nextPutAll: className; space;
				nextPutAll: (aSelector contractTo: 60-className size); cr]! !
!MessageTally class methodsFor: 'spying'!
tallySendsTo: receiver inBlock: aBlock showTree: treeOption
	"MessageTally tallySends: [3.14159 printString]"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies |
	tallies _ MessageTally new class: aBlock receiver class
							method: aBlock method.
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: 
				["call or return"
				prev sender == nil ifFalse: 
					["call only"
					(receiver == nil or: [current receiver == receiver])
						ifTrue: [tallies tally: current]].
				prev _ current]].

	StringHolderView open: (StringHolder new contents:
		(String streamContents:
			[:s |
			treeOption
				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]
				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].
			tallies close]))
		label: 'Spy Results'! !
!Metaclass methodsFor: 'initialize-release'!
instanceVariableNames: instVarString 
	"Declare additional named variables for my instance."
	| newMeta invalid |
	newMeta _ self copyForValidation.
	invalid _ newMeta
				subclassOf: superclass
				oldClass: self
				instanceVariableNames: instVarString
				variable: false
				words: true
				pointers: true
				ifBad: [^false].
	(invalid or: [instVarString ~= self instanceVariablesString])
		ifTrue: [newMeta validateFrom: self
					in: Smalltalk
					instanceVariableNames: true
					methods: true.
				Smalltalk changes changeClass: self]! !
!Metaclass methodsFor: 'fileIn/Out'!
definition 
	"Refer to the comment in ClassDescription|definition."
	| aStream names |
	aStream _ WriteStream on: (String new: 300).
	self printOn: aStream.
	names _ self instVarNames.
"
	names isEmpty ifTrue: [^  aStream contents].
"
	aStream nextPutAll: '
	instanceVariableNames: '''.
	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].
	aStream nextPut: $'.
	^ aStream contents! !
!MethodNode methodsFor: 'code generation'!
generate: trailer
	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 
	argument, trailer, is the references to the source code that is stored with 
	every CompiledMethod."
	| blkSize nLits stack strm nArgs |
	self generateIfQuick: 
		[:method | 
		1 to: 3 do: [:i | method at: method size - 3 + i put: (trailer at: i)].
		method cacheTempNames: self tempNames.
		^method].
	nArgs _ arguments size.
	blkSize _ block sizeForEvaluatedValue: encoder.
	encoder maxTemp > 31
		ifTrue: [^self error: 'Too many temporary variables'].	
	literals _ encoder allLiterals.
	(nLits _ literals size) > 255
		ifTrue: [^self error: 'Too many literals referenced'].
	method _ CompiledMethod	"Dummy to allocate right size"
				newBytes: blkSize
				nArgs: nArgs
				nTemps: encoder maxTemp
				nStack: 0
				nLits: nLits
				primitive: primitive.
	strm _ ReadWriteStream with: method.
	strm position: method initialPC - 1.
	stack _ ParseStack new init.
	block emitForEvaluatedValue: stack on: strm.
	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].
	strm position ~= (method size - 3) 
		ifTrue: [^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	1 to: 3 do: [:i | method at: method size - 3 + i put: (trailer at: i)].
	method cacheTempNames: self tempNames.
	^method! !
!MethodNode methodsFor: 'converting'!
decompileString 
	"Answer a string description of the parse tree whose root is the receiver."
	^ String streamContents: [:strm | self printOn: strm]!
decompileText 
	"Answer a string description of the parse tree whose root is the receiver."
	^ Text streamContents: [:strm | self printOn: strm]! !
!MethodNode methodsFor: 'printing'!
printOn: aStream 
	| args |
	precedence = 1
		ifTrue: 
			[aStream nextPutAll: self selector]
		ifFalse: 
			[args _ ReadStream on: arguments.
			self selector keywords do: 
				[:s | 
				aStream nextPutAll: s; space.
				aStream withAttribute: (TextColor color: Color green)
					do: [aStream nextPutAll: args next key].
				aStream space]].
	comment == nil ifFalse: 
			[aStream crtab: 1.
			self printCommentOn: aStream indent: 1].
	temporaries size > 0 ifTrue: 
			[aStream crtab: 1.
			aStream nextPutAll: '| '.
			aStream withAttribute: (TextColor color: Color green)
				do: [temporaries do: 
					[:temp | 
					aStream nextPutAll: temp key.
					aStream space]].
			aStream nextPut: $|].
	primitive > 0 ifTrue:
			[primitive < 256 ifTrue:  " Dont decompile <prim> for, eg, ^ self "
				[aStream crtab: 1.
				self printPrimitiveOn: aStream]].
	aStream crtab: 1.
	^block printStatementsOn: aStream indent: 0! !
!MethodNode methodsFor: 'C translation'!
asTMethodFromClass: aClass
 
	^ TMethod new
		setSelector: selectorOrFalse
		args: arguments
		locals: encoder tempsAndBlockArgs
		block: block! !
!MixedSound methodsFor: 'sound generation'!
samplesRemaining

	| remaining r |
	remaining _ 0.
	1 to: sounds size do: [ :i |
		r _ (sounds at: i) samplesRemaining.
		r > remaining ifTrue: [ remaining _ r ].
	].
	^ remaining! !
!Model methodsFor: 'dependents'!
addDependent: anObject
	"Make the given object one of the receiver's dependents."

	dependents == nil
		ifTrue: [dependents _ Array with: anObject]
		ifFalse: [
			"done if anObject is already a dependent"
			dependents do: [:o | o == anObject ifTrue: [^ self]].
			"otherwise, add it"
			dependents _ dependents copyWith: anObject].
!
breakDependents
	"Remove all of the receiver's dependents."

	dependents _ nil.!
dependents
	"Answer a collection of objects that are 'dependent' on the receiver;
	 that is, all objects that should be notified if the receiver changes."

	dependents == nil ifTrue: [^ #()].
	^ dependents
!
removeDependent: anObject
	"Remove the given object as one of the receiver's dependents.
	10/30/96 sw: if dependents nil on entry, simply exit; workaround for confusing bug encountered in bringing Fabrik up on Squeak."

	| newDependents |
	dependents == nil ifTrue: [^ self].
	newDependents _ dependents select: [ :d | (d == anObject) not].
	newDependents isEmpty
		ifTrue: [dependents _ nil]
		ifFalse: [dependents _ newDependents]! !
!MouseMenuController methodsFor: 'menu messages'!
redButtonActivity
	"Determine which item in the red button pop-up menu is selected. If one 
	is selected, then send the corresponding message to the object designated 
	as the menu message receiver."

	| index |
	redButtonMenu ~~ nil
		ifTrue: 
			[index _ redButtonMenu startUp.
			index ~= 0 
				ifTrue: [self menuMessageReceiver perform:
							(redButtonMessages at: index)]]
		ifFalse: [super controlActivity]!
shiftedYellowButtonActivity
	"Present the alternate (shifted) menu and take action accordingly.  1/17/96 sw.
	1/25/96 sw: let #shiftedYellowButtonActivity: do the work"

	| index shiftMenu |

	(shiftMenu _ self shiftedYellowButtonMenu) == nil ifTrue:
		[^ super controlActivity].
	self shiftedYellowButtonActivity: shiftMenu!
shiftedYellowButtonActivity: shiftMenu
	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  1/26/96 sw"

	| index  |

	(index _ shiftMenu startUp) ~= 0
		ifTrue:
			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]
		ifFalse:
			[super controlActivity]!
unshiftedYellowButtonActivity
	"Put up the regular yellow-button menu and take action as appropriate.  1/24/96 sw"

	| index  |

	yellowButtonMenu ~~ nil
		ifTrue: 
			[index _ yellowButtonMenu startUp.
			index ~= 0 
				ifTrue: [self menuMessageReceiver performMenuMessage:
							(yellowButtonMessages at: index)]]
		ifFalse:
			[super controlActivity]! !
!NotifyStringHolderController methodsFor: 'menu messages'!
debug
	"Open a full DebuggerView."
	| debuggerTemp topView |
	topView _ view topView.
	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"
	self controlTerminate.
	topView deEmphasizeView; erase.
	DebuggerView openNoSuspendDebugger: debuggerTemp label: topView label.
	topView controller closeAndUnscheduleNoErase.
	Processor terminateActive!
proceed
	"Proceed execution of the suspended process."
	| debuggerTemp |
	Smalltalk okayToProceedEvenIfSpaceIsLow ifFalse: [^ self].
	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"
	self controlTerminate.
	debuggerTemp proceed: view superView controller.
	self controlInitialize! !

NullColor comment:
'A NullColor represents a color to be used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits.'!
!NullColor methodsFor: 'printing'!
printOn: aStream

	aStream nextPutAll: 'Color none'.
!
storeOn: aStream

	aStream nextPutAll: 'Color none'.
! !
!NullColor methodsFor: 'conversions'!
pixelWordForDepth: depth
	"Answer bits that appear in a 32-bit word of a Bitmap of the given depth.
	This is overridden to allow blts with transparency to work right
	by specifying a null color for the background."

	^ 0! !
!NullColor methodsFor: 'private'!
setRed: r green: g blue: b
	rgb _ -1  "A fiction to avoid equality with Color black"! !
!Number methodsFor: 'arithmetic'!
/ aNumber 
	"Answer the result of dividing the receiver by aNumber."

	self subclassResponsibility! !
!Object methodsFor: 'accessing'!
isDescendedFrom: anObject
	"Answer whether the receiver is, from the containment perspective, descended from anObject.  10/9/96 sw"

	^ false! !
!Object methodsFor: 'testing'!
name
	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  9/27/96 sw"

	^ self printString! !
!Object methodsFor: 'dependents access'!
addDependent: anObject
	"Make the given object one of the receiver's dependents."

	| dependents |
	dependents _ self dependents.
	dependents do: [:o | o == anObject ifTrue: [^ self]].  "anObject is already a dependent"
	DependentsFields at: self put: (dependents copyWith: anObject).
!
breakDependents
	"Remove all of the receiver's dependents."

	DependentsFields removeKey: self ifAbsent: [].
!
dependents
	"Answer a collection of objects that are 'dependent' on the receiver;
	 that is, all objects that should be notified if the receiver changes."

	(DependentsFields includesKey: self)
		ifTrue: [^ DependentsFields at: self]
		ifFalse: [^ #()].
!
removeDependent: anObject
	"Remove the given object as one of the receiver's dependents."

	| dependents newDependents |
	dependents _ self dependents.
	newDependents _ dependents select: [ :d | (d == anObject) not].
	newDependents isEmpty
		ifTrue: [DependentsFields removeKey: self ifAbsent: []]
		ifFalse: [DependentsFields at: self put: newDependents].
! !
!Object methodsFor: 'error handling'!
confirm: queryString 
	"Put up a yes/no menu with caption aString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."
	"nil confirm: 'Are you hungry?'"

	^ SelectionMenu confirm: queryString!
doesNotUnderstand: aMessage 
	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."
	"Unless the receiver has an error handler defined for the active process (this mechanism appears vestigal so it is probably defunct), report to the user that the receiver does not understand the argument, aMessage, as a message."
	"Testing: (3 activeProcess)"
	| thisProcess errorString |
	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])
		ifTrue: [^ aMessage sentTo: self].
	errorString _ 'Message not understood: ', aMessage selector.
	(thisProcess _ Processor activeProcess) isErrorHandled
		ifTrue: [thisProcess errorHandler value: errorString value: self]
		ifFalse: [DebuggerView openContext: thisContext
					label: errorString
					contents: thisContext shortStack].
	^ aMessage sentTo: self! !
!Object methodsFor: 'user interface'!
basicInspect
	"Create and schedule an Inspector in which the user can examine the 
	receiver's variables. This method should not be overriden."

	Inspector openOn: self withEvalPane: false!
inspect
	"Create and schedule an Inspector in which the user can examine the 
	receiver's variables."
	Inspector openOn: self withEvalPane: true!
inspectWithLabel: aLabel
	Inspector openOn: self withEvalPane: true withLabel: aLabel! !
!Object methodsFor: 'translation support'!
var: varSymbol declareC: declString
	"For translation only; noop when running in Smalltalk."! !
!Object class methodsFor: 'class initialization'!
initializeOnceOnly 
	"Refer to the comment in Class|initialize.  This is the initilaize message for Object class, but if called initialize, then all classes would inherit it as a class message, and clearly this is not the default desired."

	self initializeDependentsFields.  "Note this will disconnect views!!"
	self initializeErrorRecursion.

	"Object initializeOnceOnly"! !

ObjectMemory comment:
'This class describes a 32-bit direct-pointer object memory for Smalltalk.  The model is very simple in principle:  a pointer is either a SmallInteger or a 32-bit direct object pointer.

SmallIntegers are tagged with a low-order bit equal to 1, and an immediate 31-bit 2s-complement signed value in the rest of the word.

All object pointers point to a header, which may be followed by a number of data fields.  This object memory achieves considerable compactness by using a variable header size (the one complexity of the design).  The format of the 0th header word is as follows:
	3 bits	reserved for gc (mark, old, dirty)
	12 bits	object hash (for HashSets)
	5 bits	compact class index
	4 bits	object format
	6 bits	object size in 32-bit words
	2 bits	header type (0: 3-word, 1: 2-word, 2: forbidden, 3: 1-word)

If a class is in the compact class table, then this is the only header information needed.  If it is not, then it will have another header word at offset -4 bytes with its class in the high 30 bits, and the header type repeated in its low 2 bits.  It the objects size is greater than 255 bytes, then it will have yet another header word at offset -8 bytes with its full word size in the high 30 bits and its header type repeated in the low two bits.

The object format field provides the remaining information as given in the formatOf: method (including isPointers, isVariable, isBytes, and the low 2 size bits of byte-sized objects).

This implementation includes incremental (2-generation) and full garbage collection, each with compaction and rectification of direct pointers.  It also supports a bulk-become (exchange object identity) feature that allows many objects to be becomed at once, as when all instances of a class must be grown or shrunk.'!
!ObjectMemory methodsFor: 'initialization'!
adjustAllOopsBy: bytesToShift
	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."

	| oop last |
	bytesToShift = 0 ifTrue: [ ^ nil ].

	oop _ self firstObject.
	[oop < endOfMemory] whileTrue: [
		(self isFreeObject: oop) ifFalse: [
			self adjustFieldsAndClassOf: oop by: bytesToShift.
 		].
		last _ oop.
		oop _ self objectAfter: oop.
	].
!
adjustFieldsAndClassOf: oop by: offsetBytes
	"Adjust all pointers in this object by the given offset."

	| fieldAddr fieldOop classHeader newClassOop |
	fieldAddr _ oop + (self lastPointerOf: oop).
	[fieldAddr > oop] whileTrue: [
		fieldOop _ self longAt: fieldAddr.
		(self isIntegerObject: fieldOop) ifFalse: [
			self longAt: fieldAddr put: (fieldOop + offsetBytes).
		].
		fieldAddr _ fieldAddr - 4.
	].

	(self headerType: oop) ~= HeaderTypeShort ifTrue: [
		"adjust class header if not a compact class"

		classHeader _ self longAt: (oop - 4).
		newClassOop _
			(classHeader bitAnd: AllButTypeMask) + offsetBytes.
		self longAt: (oop - 4) put: (newClassOop bitOr: (classHeader bitAnd: TypeMask)).
	].
!
initializeMemoryFirstFree: firstFree 
	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."
	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."

	| fwdBlockBytes |
	"reserve space for forwarding blocks"
	fwdBlockBytes _ MinimumForwardTableBytes.
	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [
		"reserve enough space for a minimal free block of BaseHeaderSize bytes"
		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).
	].

	"set endOfMemory and initialize freeBlock"
	endOfMemory _ memoryLimit - fwdBlockBytes.
	freeBlock _ firstFree.
	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"

	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"
	self setSizeOfFree: endOfMemory to: BaseHeaderSize.

	checkAssertions ifTrue: [
		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])
			ifFalse: [ self error: 'error in free space computation' ].	
		(self oopFromChunk: endOfMemory) = endOfMemory
			ifFalse: [ self error: 'header format must have changed' ].
		(self objectAfter: freeBlock) = endOfMemory
			ifFalse: [ self error: 'free block not properly initialized' ].
	].!
initializeObjectMemory: bytesToShift
	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."
	"Assume: image reader initializes the following variables:
		memory
		endOfMemory
		memoryLimit
		specialObjectsOop
		lastHash
	"

	checkAssertions _ false.  "set this early to allow assertions in initialization code to use it"

	"set the start of the young object space"
	youngStart _ endOfMemory.
	self initializeMemoryFirstFree: endOfMemory.
		"initializes endOfMemory, freeBlock"

	"image may be at a different address; adjust oops for new location"
	self adjustAllOopsBy: bytesToShift.
	specialObjectsOop _ specialObjectsOop + bytesToShift.

	"heavily used special objects"
	nilObj	_ self splObj: NilObject.
	falseObj	_ self splObj: FalseObject.
	trueObj	_ self splObj: TrueObject.

	rootTableCount _ 0.
	child _ 0.
	field _ 0.
	parentField _ 0.
	freeLargeContexts _ NilContext.
	freeSmallContexts _ NilContext.
	allocationCount _ 0.
	lowSpaceThreshold _ 0.
	signalLowSpace _ false.
	compStart _ 0.
	compEnd _ 0.
	fwdTableNext _ 0.
	fwdTableLast _ 0.
	remapBufferCount _ 0.! !
!ObjectMemory methodsFor: 'interpreter access'!
fetchByte: byteIndex ofObject: objectPointer
	^ self byteAt: objectPointer + BaseHeaderSize + byteIndex!
fetchClassOf: oop

	| ccIndex |
	(self isIntegerObject: oop)
		ifTrue: [ ^ self splObj: ClassInteger ].

	ccIndex _ (((self baseHeader: oop) >> 12) bitAnd: 16r1F) - 1.
	ccIndex < 0
		ifTrue: [ ^ (self classHeader: oop) bitAnd: AllButTypeMask ]
		ifFalse: [
			"look up compact class"
			^ self fetchPointer: ccIndex
				ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)
		].
!
fetchPointer: fieldIndex ofObject: objectPointer
	^ self longAt: objectPointer + BaseHeaderSize + (fieldIndex*4)!
fetchWord: wordIndex ofObject: objectPointer
	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)!
fetchWordLengthOf: objectPointer
	| sz |
	sz _ self sizeBitsOf: objectPointer.
	^ (sz - BaseHeaderSize) // 4!
instantiateClass: classPointer indexableSize: size
	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |
"
	NOTE: This method supports the backward-compatible split instSize field of the
	class format word.  The sizeHiBits will go away and other shifts change by 2
	when the split fields get merged in an (incompatible) image change.
"
	checkAssertions ifTrue: [
		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].

	hash _ self newObjectHash.
	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"
	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.
	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).
	header2 _ classPointer.
	header3 _ 0.

	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"
	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"
	format _ (header1 >> 8) bitAnd: 16rF.

	format < 8 ifTrue: [
		"Bitmaps and Arrays"
		inc _ size * 4.
	] ifFalse: [
		"Strings and Methods"
		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"
		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"
		"low bits of byte size go in format field"
		header1 _ header1 bitOr: (binc << 8).
	].

	(byteSize + inc) > 255 ifTrue: [
		"requires size header word"
		header3 _ byteSize + inc.
		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"
	] ifFalse: [
		header1 _ header1 + inc.
	].
	byteSize _ byteSize + inc.

	header3 > 0 ifTrue: [
		"requires full header"
		hdrSize _ 3.
	] ifFalse: [
		cClass = 0
			ifTrue: [ hdrSize _ 2 ]
			ifFalse: [ hdrSize _ 1 ].
	].

	format < 4  "if pointers, fill with nil oop"
		ifTrue: [ fillWord _ nilObj ]
		ifFalse: [ fillWord _ 0 ].

	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.
	^ newObj!
instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue
	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."

	| hash header1 header2 hdrSize |
	hash _ self newObjectHash.
	header1 _ ((hash << 17) bitAnd: 16r1FFE0000) bitOr:
			   (self formatOfClass: classPointer).
	header1 _ header1 + (sizeInBytes - (header1 bitAnd: 16rFC)).
	header2 _ classPointer.

	(header1 bitAnd: 16r1F000) = 0 "is compact class field from format word zero?"
		ifTrue: [ hdrSize _ 2 ]
		ifFalse: [ hdrSize _ 1 ].

	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue!
integerObjectOf: value
	value < 0
		ifTrue: [^ ((16r80000000 + value) << 1) + 1]
		ifFalse: [^ (value << 1) + 1]!
integerValueOf: objectPointer
	"Translator produces 'objectPointer >> 1'"

	((objectPointer bitAnd: 16r80000000) ~= 0)
		ifTrue: ["negative"
				^ ((objectPointer bitAnd: 16r7FFFFFFF) >> 1)
					- 16r3FFFFFFF - 1  "Faster than -16r40000000 (a LgInt)"]
		ifFalse: ["positive"
				^ objectPointer >> 1]!
isIntegerObject: objectPointer
	^(objectPointer bitAnd: 1) = 1!
isIntegerValue: valueWord 
	^ valueWord >= 16r-40000000 and: [valueWord < 16r40000000]!
nilObject  "For access from BitBlt module"
	^ nilObj!
popRemappableOop
	"Pop and return the possibly remapped object from the remap buffer."

	| oop |
	oop _ remapBuffer at: remapBufferCount.
	remapBufferCount _ remapBufferCount - 1.
	^ oop!
pushRemappableOop: oop
	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."

	remapBuffer at: (remapBufferCount _ remapBufferCount + 1) put: oop.!
splObj: index
	"Return one of the objects in the SpecialObjectsArray"
	^ self fetchPointer: index ofObject: specialObjectsOop!
storeByte: byteIndex ofObject: objectPointer withValue: valueByte
	^ self byteAt: objectPointer + BaseHeaderSize + byteIndex
		put: valueByte!
storePointer: fieldIndex ofObject: objectPointer withValue: valuePointer
	"Note must check here for stores of young objects into old ones."

	(objectPointer < youngStart) ifTrue: [
		self possibleRootStoreInto: objectPointer value: valuePointer.
	].

	^ self longAt: objectPointer + BaseHeaderSize + (fieldIndex*4)
		put: valuePointer!
storePointerUnchecked: wordIndex ofObject: objectPointer withValue: valuePointer
	"Like storePointer:ofObject:withValue:, but the caller guarantees that the object being stored into is a young object or already marked as a root."

	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)
			  put: valuePointer
!
storeWord: wordIndex ofObject: objectPointer withValue: valueWord
	^ self longAt: objectPointer + BaseHeaderSize + (wordIndex*4)
		put: valueWord! !
!ObjectMemory methodsFor: 'memory access'!
checkAddress: byteAddress
	"Keep this method around for debugging the C code."

	byteAddress < (self startOfMemory) ifTrue: [
		self error: 'bad address: negative'.
	].
	byteAddress >= memoryLimit ifTrue: [
		self error: 'bad address: past end of heap'.
	].!
checkedByteAt: byteAddress
	"Assumes zero-based array indexing."

	self checkAddress: byteAddress.
	^ self byteAt: byteAddress!
checkedByteAt: byteAddress put: byte
	"Assumes zero-based array indexing."

	self checkAddress: byteAddress.
	self byteAt: byteAddress put: byte.!
checkedLongAt: byteAddress
	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."

	self checkAddress: byteAddress.
	self checkAddress: byteAddress + 3.
	^ self longAt: byteAddress!
checkedLongAt: byteAddress put: a32BitInteger
	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."

	self checkAddress: byteAddress.
	self checkAddress: byteAddress + 3.
	self longAt: byteAddress put: a32BitInteger.! !
!ObjectMemory methodsFor: 'header access'!
baseHeader: oop

	^ self longAt: oop!
classHeader: oop

	^ self longAt: oop - 4!
formatOf: oop
"       0      no fields
        1      fixed fields only (possibly containing pointers)
        2      indexable fields only (possibly containing pointers)
        3      both fixed and indexable fields (possibly containing pointers)
 
        4      unused  -- may use for contexts (size = stackPointer for scanning purposes)
        5      unused
        6      indexable word fields only (no pointers)
        7      unused
 
    8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)
   12-15     compiled methods:
                   # of literal oops specified in method header,
                   followed by indexable bytes (same interpretation of low 2 bits as above)
"

	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF!
hashBitsOf: oop

	^ ((self baseHeader: oop) >> 17) bitAnd: 16rFFF!
headerType: oop

	^ (self longAt: oop) bitAnd: TypeMask!
isBytes: oop
	"Answer true if the argument contains indexable bytes. See comment in formatOf:"
	"Note: Includes CompiledMethods."

	^ (self formatOf: oop)  >= 8!
isFreeObject: oop

	^ (self headerType: oop) = HeaderTypeFree!
isPointers: oop
	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"

	^ (self formatOf: oop) <= 4!
isWords: oop
	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"

	^ (self formatOf: oop) = 6!
isWordsOrBytes: oop
	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"
	"Note: Excludes CompiledMethods."

	| fmt |
	fmt _ self formatOf: oop.
	^ fmt = 6 or: [(fmt >= 8) and: [fmt <= 11]]!
newObjectHash
	"Answer a new pseudo random number for use as an indentity hash."

	lastHash _ 13849 + (27181 * lastHash) bitAnd: 65535.
	^ lastHash bitAnd: 16rFFF!
rightType: headerWord
	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."

	(headerWord bitAnd: 16rFC) = 0  "zero size field in header word"
		ifTrue: [ ^ HeaderTypeSizeAndClass ]
		ifFalse: [
			(headerWord bitAnd: 16r1F000) = 0  "zero compact class field  in header word"
				ifTrue: [ ^ HeaderTypeClass ]
				ifFalse: [ ^ HeaderTypeShort ]].!
setSizeOfFree: chunk to: byteSize
	"Set the header of the given chunk to make it be a free chunk of the given size."

	self longAt: chunk put: ((byteSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).!
sizeBitsOf: oop
	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."
	"Note: byte indexable objects need to have low bits subtracted from this size."

	| header |
	header _ self baseHeader: oop.
	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass
		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
		ifFalse: [ ^ header bitAnd: 16rFC ].!
sizeBitsOfSafe: oop
	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."

	| header type |
	header _ self baseHeader: oop.
	type _ self rightType: header.
	type = HeaderTypeSizeAndClass
		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
		ifFalse: [ ^ header bitAnd: 16rFC ].!
sizeHeader: oop

	^ self longAt: oop - 8!
sizeOfFree: oop
	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."

	^ (self longAt: oop) bitAnd: FreeSizeMask! !
!ObjectMemory methodsFor: 'object enumeration'!
accessibleObjectAfter: oop
	"Return the accessible object following the given object or free chunk in the heap. Return nil when heap is exhausted."

	| obj |
	obj _ self objectAfter: oop.
	[obj < endOfMemory] whileTrue: [
		(self isFreeObject: obj) ifFalse: [ ^obj ].
		obj _ self objectAfter: obj.
	].
	^ nil!
firstAccessibleObject
	"Return the first accessible object in the heap."

	| obj |
	obj _ self firstObject.
	[obj < endOfMemory] whileTrue: [
		(self isFreeObject: obj) ifFalse: [ ^obj ].
		obj _ self objectAfter: obj.
	].
	self error: 'heap is empty'!
firstObject
	"Return the first object or free chunk in the heap."

	^ self oopFromChunk: self startOfMemory!
initialInstanceOf: classPointer
	"Support for instance enumeration. Return the first instance of the given class, or nilObj if it has no instances."

	| thisObj thisClass |
	thisObj _ self firstAccessibleObject.
	[thisObj = nil] whileFalse: [
		thisClass _ self fetchClassOf: thisObj.
		thisClass = classPointer ifTrue: [ ^thisObj ].
		thisObj _ self accessibleObjectAfter: thisObj.
	].
	^nilObj!
instanceAfter: objectPointer
	"Support for instance enumeration. Return the next instance of the class of the given object, or nilObj if the enumeration is complete."

	| classPointer thisObj thisClass |
	classPointer _ (self fetchClassOf: objectPointer).
	thisObj _ self accessibleObjectAfter: objectPointer.
	[thisObj = nil] whileFalse: [
		thisClass _ self fetchClassOf: thisObj.
		thisClass = classPointer ifTrue: [ ^thisObj ].
		thisObj _ self accessibleObjectAfter: thisObj.
	].
	^nilObj!
lastPointerOf: objectPointer
	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."

	| fmt sz methodHeader |
	fmt _ self formatOf: objectPointer.
	fmt < 4 ifTrue: [
		sz _ self sizeBitsOfSafe: objectPointer.
		^ sz - BaseHeaderSize  "all pointers"
	].
	fmt < 12 ifTrue: [ ^0 ].  "no pointers"

	"CompiledMethod: contains both pointers and bytes:"
	methodHeader _ self longAt: objectPointer + BaseHeaderSize.
	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!
objectAfter: oop
	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."

	| sz |
	checkAssertions ifTrue: [
		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].
	].

	(self isFreeObject: oop)
		ifTrue: [ sz _ self sizeOfFree: oop ]
		ifFalse: [ sz _ self sizeBitsOf: oop ].

	^ self oopFromChunk: (oop + sz)!
startOfMemory
	"Return the start of object memory."

	^ self cCode: '(int) memory'! !
!ObjectMemory methodsFor: 'oop/chunk conversion'!
chunkFromOop: oop
	"Compute the chunk of this oop by subtracting its extra header bytes."

	^ oop - (self extraHeaderBytes: oop)!
extraHeaderBytes: oopOrChunk
	"Return the number of extra bytes used by the given object's header."
	"Warning: This method should not be used during marking, when the header type bits of an object may be incorrect."
	| type |
	type _ self headerType: oopOrChunk.
	type > 1 ifTrue: [^ 0].  "Free(2) or 1-word header(3) most common"
	type = 1 ifTrue: [^ 4].
	type = 0 ifTrue: [^ 8].  "unneccess test for clarity only"
!
oopFromChunk: chunk
	"Compute the oop of this chunk by adding its extra header bytes."

	^ chunk + (self extraHeaderBytes: chunk)! !
!ObjectMemory methodsFor: 'allocation'!
allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize fill: fillWord
	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."

	| newObj remappedClassOop end i |
	"remap classOop in case GC happens during allocation"
	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].
  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).
	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].

	hdrSize = 3 ifTrue: [
		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).
		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).
		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).
		newObj _ newObj + 8.
	].
	hdrSize = 2 ifTrue: [
		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).
		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).
		newObj _ newObj + 4.
	].
	hdrSize = 1 ifTrue: [
		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).
	].

	"clear new object"
	end _ newObj + byteSize.
	i _ newObj + 4.
	[i < end] whileTrue: [
		self longAt: i put: fillWord.
		i _ i + 4.
	].

	checkAssertions ifTrue: [
		self okayOop: newObj.
		self oopHasOkayClass: newObj.
		(self objectAfter: newObj) = freeBlock
			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].
		(self objectAfter: freeBlock) = endOfMemory
			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].
	].

	^ newObj!
allocateChunk: byteSize 
	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."
	"Details: To limit the time per incremental GC, do one every so many allocations."

	| enoughSpace newFreeSize newChunk |
	allocationCount >= AllocationsBetweenGCs ifTrue: [
		"do an incremental GC every so many allocations to keep pauses short"
		self incrementalGC.
	].

	enoughSpace _ self sufficientSpaceToAllocate: byteSize.
	enoughSpace ifFalse: [
		"signal that space is running low, put proceed with allocation if possible"
		signalLowSpace _ true.
		interruptCheckCounter _ 0.
	].

	(self sizeOfFree: freeBlock) < (byteSize + BaseHeaderSize) ifTrue: [
		self error: 'out of memory'.
	].

	"if we get here, there is enough space for allocation to succeed"
	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.
	newChunk _ freeBlock.
	freeBlock _ freeBlock + byteSize.
	"Assume: client will initialize object header of free chunk, so following is not needed:"
	"self setSizeOfFree: newChunk to: byteSize."
	self setSizeOfFree: freeBlock to: newFreeSize.
	allocationCount _ allocationCount + 1.

	^ newChunk!
allocateOrRecycleContext: smallContextWanted
	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."

	| cntxt |
	smallContextWanted ifTrue: [
		freeSmallContexts ~= NilContext ifTrue: [
			cntxt _ freeSmallContexts.
			freeSmallContexts _ self fetchPointer: 0 ofObject: cntxt.
		] ifFalse: [
			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)
								 sizeInBytes: SmallContextSize
										 fill: nilObj.
		].
	] ifFalse: [
		freeLargeContexts ~= NilContext ifTrue: [
			cntxt _ freeLargeContexts.
			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.
		] ifFalse: [
			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)
								sizeInBytes: LargeContextSize
										fill: nilObj.
		].
	].
	^ cntxt
!
clone: oop
	"Return a shallow copy of the given object."
	"Assume: Oop is a real object, not a small integer."

	| extraHdrBytes oldChunk bytes newChunk remappedOop fromIndex toIndex lastFrom |
	extraHdrBytes _ self extraHeaderBytes: oop.
	oldChunk _ oop - extraHdrBytes.
	bytes _ self sizeBitsOf: oop.
	bytes _ bytes + extraHdrBytes.

	"allocate space for the copy, remapping oop in case of a GC"
	self pushRemappableOop: oop.
	newChunk _ self allocateChunk: bytes.
	remappedOop _ self popRemappableOop.
	oldChunk _ remappedOop - extraHdrBytes.

	"copy old chunk to new including the header words"
	fromIndex _ oldChunk - 4.
	toIndex _ newChunk - 4.
	lastFrom _ fromIndex + bytes.
	[fromIndex < lastFrom] whileTrue: [
		self longAt: (toIndex _ toIndex + 4)
			put: (self longAt: (fromIndex _ fromIndex + 4)).
	].
	^ newChunk + extraHdrBytes  "convert from chunk to oop"
!
recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass
	"If possible, save the given context on a list of free contexts to be recycled."
	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."
	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."

	| cntxHeader ccField isMethodCntx |
	"only recycle young contexts (which should be most of them)"
	cntxOop >= youngStart ifTrue: [
		"is the context of class methodCntxClass?"
		cntxHeader _ self baseHeader: cntxOop.
		ccField _ cntxHeader bitAnd: 16r1F000.
		ccField = 0 ifTrue: [
			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.
		] ifFalse: [
			"compare ccField with compact class bits from format word of methodCntxClass"
			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: 16r1F000).
		].

		isMethodCntx ifTrue: [
			"Note: The following test depends on the format of object headers
			 and the fact that both small and large contexts are small enough
			 for their size to be encoded in the base object header. If these
			 assumptions is false, contexts won't be recycled properly, but the
			 code should not break."

			(cntxHeader bitAnd: 16rFC) = SmallContextSize ifTrue: [
				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.
				freeSmallContexts _ cntxOop.	
			] ifFalse: [
				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.
				freeLargeContexts _ cntxOop.	
			].
		].
	].
!
sufficientSpaceAfterGC: minFree
	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."

	self incrementalGC.  "try to recover some space"
	(self sizeOfFree: freeBlock) < minFree ifTrue: [
		signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"
		self fullGC.  "try harder"
		"for stability, require more free space after doing an expensive full GC"
		(self sizeOfFree: freeBlock) < (minFree + 15000) ifTrue: [ ^ false ].  "still not enough"
	].
	^ true!
sufficientSpaceToAllocate: bytes
	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."

	| minFree |
	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.

	"check for low-space"
	(self sizeOfFree: freeBlock) >= minFree ifTrue: [
		^ true.
	] ifFalse: [
		^ self sufficientSpaceAfterGC: minFree.
	].! !
!ObjectMemory methodsFor: 'garbage collection'!
beRootIfOld: oop
	"Record that the given oop in the old object area may point to an object in the young area."

	| header |
	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue: [
		"oop is in the old object area"
		header _ self longAt: oop.
		(header bitAnd: RootBit) = 0 ifTrue: [
			"record oop as root only if not already recorded"
			rootTableCount < RootTableSize ifTrue: [
				"record root only if there is room in the roots table"
				rootTableCount _ rootTableCount + 1.
				rootTable at: rootTableCount put: oop.
				self longAt: oop put: (header bitOr: RootBit).
			].
		].
	].!
clearRootsTable
	"Clear the root bits of the current roots, then empty the roots table."
	"Caution: This should only be done when the young object space is empty."

	| oop |
	"reset the roots table (after this, all objects are old so there are no roots)"
	1 to: rootTableCount do: [ :i |
		"clear root bits of current root table entries"
		oop _ rootTable at: i.
		self longAt: oop put: ((self longAt: oop) bitAnd: AllButRootBit).
		rootTable at: i put: 0.
	].
	rootTableCount _ 0.!
fullCompaction
	"Move all accessible objects down to leave one big free chunk at the end of memory."
	"Assume: Incremental GC has just been done to maximimize forwarding table space."

	"need not move objects below the first free chunk"
	compStart _ self lowestFreeAfter: (self startOfMemory).
	compStart = freeBlock ifTrue: [
		"memory is already compact; only free chunk is at the end"
		^ self initializeMemoryFirstFree: freeBlock
	].

	"work up through memory until all free space is at the end"
	[compStart < freeBlock] whileTrue: [
		"free chunk returned by incCompBody becomes start of next compaction"
		compStart _ self incCompBody.  "bubble of free space moves up each time"
	].!
fullGC
	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."

	self clearRootsTable.
	youngStart _ self startOfMemory.  "process all of memory"
	self markPhase.
	self sweepPhase.
	self fullCompaction.
	allocationCount _ 0.

	youngStart _ freeBlock.  "reset the young object boundary"
	self postGCAction.!
incrementalCompaction
	"Move objects down to make one big free chunk. Compact the last N objects (where N = number of forwarding table entries) of the young object area."
	"Assume: compStart was set during the sweep phase"

	compStart = freeBlock ifTrue: [
		"Note: If compStart = freeBlock then either the young space is already compact
		 or there are enough forwarding table entries to do a one-pass incr. compaction."

		self initializeMemoryFirstFree: freeBlock.
	] ifFalse: [
		self incCompBody.
	].
!
incrementalGC
	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."

	| survivorCount |
	rootTableCount >= RootTableSize ifTrue: [
		"root table overflow; cannot do an incremental GC (this should be very rare)"
		^ self fullGC
	].

	"incremental GC and compaction"
	self markPhase.
	survivorCount _ self sweepPhase.
	self incrementalCompaction.
	allocationCount _ 0.

	survivorCount > 2000 ifTrue: [
		"move up the young space boundary if there are too many survivors;
		 this limits the number of objects that must be processed on future
		 incremental GC's"

		self clearRootsTable.
		youngStart _ freeBlock.  "reset the young object boundary"
	].
	self postGCAction.
!
lowestFreeAfter: chunk
	"Return the first free block after the given chunk in memory."

	| oop oopHeader oopHeaderType oopSize |
	oop _ self oopFromChunk: chunk.
	[oop < endOfMemory] whileTrue: [
		oopHeader _ self baseHeader: oop.
		oopHeaderType _ oopHeader bitAnd: TypeMask.
		(oopHeaderType = HeaderTypeFree)
			ifTrue: [ ^ oop ]
			ifFalse: [
				oopHeaderType = HeaderTypeSizeAndClass
					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].
			].
		oop _ self oopFromChunk: (oop + oopSize).
	].
	self error: 'expected to find at least one free object'.
!
possibleRootStoreInto: oop value: valueObj
	"Called when storing the given value object into the given old object. If valueObj is young, record the fact that oldObj is now a root for incremental garbage collection."
	"Warning: No young objects should be recorded as roots."

	| header |
	((valueObj >= youngStart) and:
	 [(self isIntegerObject: valueObj) not]) ifTrue: [
		header _ self longAt: oop.
		(header bitAnd: RootBit) = 0 ifTrue: [
			"record oop as root only if not already recorded"
			rootTableCount < RootTableSize ifTrue: [
				"record root only if there is room in the roots table"
				rootTableCount _ rootTableCount + 1.
				rootTable at: rootTableCount put: oop.
				self longAt: oop put: (header bitOr: RootBit).
			].
		].
	].! !
!ObjectMemory methodsFor: 'gc -- mark and sweep'!
aComment
	"The mark phase is based on a pointer reversing traversal. This is a little tricky because the class, which is needed by the traversal, may be in either the header (as a compact class index) or in the word above the header. See memo 'Revised object format'.
	Compact classes are marked and traced separately.
	How do you know that you are returning from having marked a class? Parent pointer has 10 in low bits.

Here are the states an object may be in, followed by what to do next in brackets []:

  Start Object: parentField is set, [obj _ child]:
	obj is pointed at by a field in parent that is being traced now. obj is marked.
		[(parent goes up to the next field) field addr _ obj. go to Upward]
	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has no pointers.
		[put 10 into low bits of header. field addr _ obj. go to Start Field (to process class word)]
	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has pointers.
		[put 10 into low bits of header. point to last field. go to Start Field]

  Start Field: 
	Field ends in 10. It is the header. Short Class is not 0.
		[Set low bits to correct value. (have parent pointer) go to Upward]
	Field ends in 10. It is the header. Short Class is 0.
		[child _ word above header. low bits of child _ 01. class word _ parentField. parentField _ loc of class word. go to Start Obj]
	Field is Integer.
		[point one word up, go to Start Field]
	Field is oop.
		[child _ field. field _ parentField. parentField _ loc of field. go to Start Obj]

  Upward [restore low bits of header (at field addr)]:
	parentField is 3. (bits 11, int 1).
		[done!!]
	parentField ends in 00.
		[child _ field addr. field addr _ parentField. parentField _ field addr contents.
		field addr contents _ child (addr of prev object. its oop). field addr - 4. go to Start Field]
	parentField ends in 01. Were tracing the class.
		[child _ field addr. field addr _ parentField (loc of class word). parentField _ field addr contents.
		field addr contents _ child (addr of prev object. its oop). field addr + 4 (header). go to Upward]
"!
markAndTrace: oop
	"Mark all objects reachable from the given one. Trace from the given object even if it is old or already marked. Mark it only if it is a young object."
	"Tracer state variables:
		child		object being examined
		field		next field of child to examine
		parentField	field where child was stored in its referencing object"

	| header lastFieldOffset action |
	"record tracing status in object's header"
	header _ self longAt: oop.
	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.
	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"
	self longAt: oop put: header.

	"initialize the tracer state machine"
	parentField _ GCTopMarker.
	child _ oop.
	lastFieldOffset _ self lastPointerOf: oop.
	field _ oop + lastFieldOffset.
	action _ StartField.

	"run the tracer state machine until all objects reachable from oop are marked"
	[action = Done] whileFalse: [
		action = StartField	ifTrue: [ action _ self startField ].
		action = StartObj		ifTrue: [ action _ self startObj ].
		action = Upward		ifTrue: [ action _ self upward ].
	].!
markPhase
	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."
	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."

	| oop |
	"clear the recycled context lists"
	freeSmallContexts _ NilContext.
	freeLargeContexts _ NilContext.

	"trace the interpreter's objects, including the active stack and special objects array"
	self markAndTraceInterpreterOops.

	"trace the roots"
	1 to: rootTableCount do: [ :i | 
		oop _ rootTable at: i.
		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].
	].
!
startField
	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."

	| typeBits childType |
	child _ self longAt: field.
	typeBits _ child bitAnd: TypeMask.

	(typeBits bitAnd: 1) = 1 ifTrue: [
		"field contains a SmallInteger; skip it"
		field _ field - 4.
		^ StartField
	].

	typeBits = 0 ifTrue: [
		"normal oop, go down"
		self longAt: field put: parentField.
		parentField _ field.
		^ StartObj
	].

	typeBits = 2 ifTrue: [
		"reached the header; do we need to process the class word?"
		(child bitAnd: 16r1F000) ~= 0 ifTrue: [
			"object's class is compact; we're done"
			"restore the header type bits"
			child _ child bitAnd: AllButTypeMask.
			childType _ self rightType: child.
			self longAt: field put: (child bitOr: childType).
			^ Upward
		] ifFalse: [
			"object has a full class word; process that class"
			child _ self longAt: (field - 4).  "class word"
			child _ child bitAnd: AllButTypeMask.  "clear type bits"
			self longAt: (field - 4) put: parentField.
			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."
			^ StartObj
		].
	].!
startObj
	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."

	| oop header lastFieldOffset |
	oop _ child.
	oop < youngStart ifTrue: [
		"old object; skip it"
		 field _ oop.
		^ Upward
	].

	header _ self longAt: oop.
	(header bitAnd: MarkBit) = 0 ifTrue: [
		"unmarked; mark and trace"
		header _ header bitAnd: AllButTypeMask.
		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.
		self longAt: oop put: header.
		lastFieldOffset _ self lastPointerOf: oop.
		field _ oop + lastFieldOffset.
		^ StartField	"trace its fields and class"
	] ifFalse: [
		"already marked; skip it"
		field _ oop.
		^ Upward
	].!
sweepPhase
	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."
	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."

	| entriesAvailable survivors freeChunk oop oopHeader oopHeaderType oopSize freeChunkSize |
	entriesAvailable _ self fwdTableInit.
	survivors _ 0.
	freeChunk _ nil.
	compStart _ nil.  "will be updated later"
	oop _ self oopFromChunk: youngStart.
	[oop < endOfMemory] whileTrue: [
		"get oop's header, header type, and size"
		oopHeader _ self baseHeader: oop.
		oopHeaderType _ oopHeader bitAnd: TypeMask.
		(oopHeaderType = HeaderTypeFree)
			ifTrue: [ oopSize _ oopHeader bitAnd: FreeSizeMask ]
			ifFalse: [
				oopHeaderType = HeaderTypeSizeAndClass
					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]
					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].
			].

		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [
			"object is not marked; free it"
			freeChunk ~= nil ifTrue: [
				"enlarge current free chunk to include this oop"
				freeChunkSize _ freeChunkSize + oopSize + (self extraHeaderBytes: oop).
			] ifFalse: [
				"start a new free chunk"
				freeChunk _ oop - (self extraHeaderBytes: oop).  "chunk may start 4 or 8 bytes before oop"
				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"
				compStart = nil ifTrue: [
					compStart _ freeChunk.
				].
			].
		] ifFalse: [
			"object is marked; clear its mark bit and possibly adjust the compaction start"
			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).
			entriesAvailable > 0 ifTrue: [
				entriesAvailable _ entriesAvailable - 1.
			] ifFalse: [
				"start compaction at the last free chunk before this object"
				compStart _ freeChunk.
			].
			freeChunk ~= nil ifTrue: [
				"record the size of the last free chunk"
				self longAt: freeChunk
					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).
			].
			freeChunk _ nil.
			survivors _ survivors + 1.
		].
		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"
	].

	freeChunk ~= nil ifTrue: [
		"record size of final free chunk"
		self longAt: freeChunk
			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).
	].

	oop = endOfMemory
		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].

	compStart = nil
		ifTrue: [ self error: 'expected to find at least one free object' ].

	^ survivors!
upward
	"Return from marking an object below. Incoming:
		field = oop we just worked on, needs to be put away
		parentField = where to put it in our object
	NOTE: Type field of object below has already been restored!!!!!!"

	| type header |
	(parentField bitAnd: 1) = 1 ifTrue: [
		parentField = GCTopMarker ifTrue: [
			"top of the chain"
			header _ (self longAt: field) bitAnd: AllButTypeMask.
			type _ self rightType: header.
			self longAt: field put: header + type.  "install type on class oop"
			^ Done
		] ifFalse: [
			"was working on the extended class word"
			child _ field.	"oop of class"
			field _ parentField - 1.  "class word, ** clear the low bit **"
			parentField _ self longAt: field.
			header _ self longAt: field+4.  "base header word"
			type _ self rightType: header.
			self longAt: field put: child + type.  "install type on class oop"
			field _ field + 4.  "point at header"
			"restore type bits"
			header _ header bitAnd: AllButTypeMask.
			self longAt: field put: (header + type).
			^ Upward
		].
	] ifFalse: [
		"normal"
		child _ field.  "who we worked on below"
		field _ parentField.  "where to put it"
		parentField _ self longAt: field.
		self longAt: field put: child.
		field _ field - 4.  "point at header"
		^ StartField
	].! !
!ObjectMemory methodsFor: 'gc -- compaction'!
beRootWhileForwarding: oop
	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"
	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."

	| header forwarding fwdBlock newHeader |
	header _ self longAt: oop.
	(header bitAnd: MarkBit) ~= 0 ifTrue: [
		forwarding _ true.
		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.
		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
		header _ self longAt: fwdBlock + 4.
	] ifFalse: [
		forwarding _ false.
	].

	(header bitAnd: RootBit) = 0 ifTrue: [
		"record oop as root only if not already recorded"
		rootTableCount < RootTableSize ifTrue: [
			"record root only if there is room in the roots table"
			rootTableCount _ rootTableCount + 1.
			rootTable at: rootTableCount put: oop.
			newHeader _ header bitOr: RootBit.
			forwarding
				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]
				ifFalse: [ self longAt: oop put: newHeader ].
		].
	].!
fwdBlockGet
	"Return the address of a two-word forwarding block or nil if no more entries are available."

	fwdTableNext _ fwdTableNext + 8.
	fwdTableNext <= fwdTableLast
		ifTrue: [ ^ fwdTableNext ]
		ifFalse: [ ^ nil ].  "no more forwarding blocks available"!
fwdBlockValidate: addr
	"Raise an error if the given address is not a valid forward table entry."

	(( addr > endOfMemory) and:
	 [(addr <= fwdTableNext) and:
	 [(addr bitAnd: 3) = 0]])
		ifFalse: [ self error: 'invalid fwd table entry' ].!
fwdTableInit
	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."

	"set endOfMemory to just after a minimum-sized free block"
	self setSizeOfFree: freeBlock to: BaseHeaderSize.
	endOfMemory _ freeBlock + BaseHeaderSize.

	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"
	self setSizeOfFree: endOfMemory to: BaseHeaderSize.

	"use all memory free between freeBlock and memoryLimit for forwarding table"
	fwdTableNext _ endOfMemory + BaseHeaderSize.
	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"

	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [
		"Note: Address bits must not interfere with the mark bit in header of
		 an object, which shows that the object is forwarded."
		self error: 'fwd table must be in low half of the 32-bit address space'.
	].

	"return the number of forwarding blocks available"
	^ (fwdTableLast - fwdTableNext) // 8  "round down"!
incCompBody
	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."

	| bytesFreed |
	"reserve memory for forwarding table"
	self fwdTableInit.

	"assign new oop locations, reverse their headers, and initialize forwarding blocks"
	bytesFreed _ self incCompMakeFwd.

	"update pointers to point at new oops"
	self mapPointersInObjectsFrom: youngStart to: endOfMemory.

	"move the objects and restore their original headers; return the new free chunk"
	^ self incCompMove: bytesFreed!
incCompMakeFwd
	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."

	| bytesFreed oop fwdBlock newOop |
	bytesFreed _ 0.
	oop _ self oopFromChunk: compStart.
	[oop < endOfMemory] whileTrue: [
		(self isFreeObject: oop) ifTrue: [
			bytesFreed _ bytesFreed + (self sizeOfFree: oop).
		] ifFalse: [
			"create a forwarding block for oop"
			fwdBlock _ self fwdBlockGet.
			fwdBlock = nil ifTrue: [
				"stop; we have used all available forwarding blocks"
				compEnd _ self chunkFromOop: oop.
				^ bytesFreed
			].

			newOop _ oop - bytesFreed.
			self initForwardBlock: fwdBlock mapping: oop to: newOop.
		].
		oop _ self objectAfterWhileForwarding: oop.
	].
	compEnd _ endOfMemory.
	^ bytesFreed!
incCompMove: bytesFreed
	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."
	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."

	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |
	newOop _ nil.
	oop _ self oopFromChunk: compStart.
	[oop < compEnd] whileTrue: [
		next _ self objectAfterWhileForwarding: oop.
		(self isFreeObject: oop) ifFalse: [
			"a moving object; unwind its forwarding block"
			fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.
			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
			newOop _ self longAt: fwdBlock.
			header _ self longAt: fwdBlock + 4.
			self longAt: oop put: header.  "restore the original header"
			bytesToMove _ oop - newOop.

			"move the oop (including any extra header words)"
			sz _ self sizeBitsOf: oop.
			firstWord _ oop - (self extraHeaderBytes: oop).
			lastWord _ (oop + sz) - BaseHeaderSize.
			firstWord to: lastWord by: 4 do: [ :w |
				self longAt: (w - bytesToMove) put: (self longAt: w).
			].
		].
		oop _ next.
	].

	newOop = nil ifTrue: [
		"no objects moved"
		oop _ self oopFromChunk: compStart.
		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])
			ifTrue: [ newFreeChunk _ oop ]
			ifFalse: [ newFreeChunk _ freeBlock ].
	] ifFalse: [
		"initialize the newly freed memory chunk"
		"newOop is the last object moved; free chunk starts right after it"
		newFreeChunk _ newOop + (self sizeBitsOf: newOop).
		self setSizeOfFree: newFreeChunk to: bytesFreed.
	].

	checkAssertions ifTrue: [
		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)
			ifFalse: [ self error: 'problem creating free chunk after compaction' ].
	].

	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [
		self initializeMemoryFirstFree: newFreeChunk.
	] ifFalse: [
		"newFreeChunk is not at end of memory; re-install freeBlock"
		self initializeMemoryFirstFree: freeBlock.
	].

	^ newFreeChunk!
initForwardBlock: fwdBlock mapping: oop to: newOop
	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."
	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."

	| originalHeader originalHeaderType |
	originalHeader _ self longAt: oop.
	checkAssertions ifTrue: [
		fwdBlock = nil
			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].
		(originalHeader bitAnd: MarkBit) ~= 0
			ifTrue: [ self error: 'object already has a forwarding table entry' ].
	].

	originalHeaderType _ originalHeader bitAnd: TypeMask.
	self longAt: fwdBlock put: newOop.
	self longAt: fwdBlock + 4 put: originalHeader.
	self longAt: oop put: (fwdBlock bitOr: (MarkBit bitOr: originalHeaderType)).!
isObjectForwarded: oop
	"Return true if the given object has a forwarding table entry during a compaction or become operation."

	^ (oop bitAnd: 1) = 0 "(isIntegerObject: oop) not" and:
	   [ ((self longAt: oop) bitAnd: MarkBit) ~= 0 ]!
lastPointerWhileForwarding: oop
	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."

	| header fwdBlock fmt size methodHeader |
	header _ self longAt: oop.
	(header bitAnd: MarkBit) ~= 0 ifTrue: [
		"oop is forwarded; get its real header from its forwarding table entry"
		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.
		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
		header _ self longAt: fwdBlock + 4.
	].

	fmt _ (header >> 8) bitAnd: 16rF.
	fmt < 4 ifTrue: [
		"do sizeBitsOf: using the header we obtained"
		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass
			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]
			ifFalse: [ size _ header bitAnd: 16rFC ].
		^ size - BaseHeaderSize
	].
	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"

	methodHeader _ self longAt: oop + BaseHeaderSize.
	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!
mapPointersInObjectsFrom: memStart to: memEnd
	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."

	| oop |
	"update interpreter variables"
	self mapInterpreterOops.

	"update pointers in root objects"
	1 to: rootTableCount do: [ :i | 
		oop _ rootTable at: i.
		((oop < memStart) or: [oop >= memEnd]) ifTrue: [
			"Note: must not remap the fields of any object twice!!"
			"remap this oop only if not in the memory range covered below"
			self remapFieldsAndClassOf: oop.
		].
	].

	"update pointers in the given memory range"
	oop _ self oopFromChunk: memStart.
	[oop < memEnd] whileTrue: [
		(self isFreeObject: oop) ifFalse: [
			self remapFieldsAndClassOf: oop.
		].
		oop _ self objectAfterWhileForwarding: oop.
	].!
objectAfterWhileForwarding: oop
	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."

	| header fwdBlock realHeader sz |
	header _ self longAt: oop.
	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"

	"Assume: mark bit cannot be set on a free chunk, so if we get here,
	 oop is not free and it has a forwarding table entry"

	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.
	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
	realHeader _ self longAt: fwdBlock + 4.
	"following code is like sizeBitsOf:"
	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass
		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]
		ifFalse: [ sz _ realHeader bitAnd: 16rFC ].

	^ self oopFromChunk: (oop + sz)!
remap: oop
	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."

	| fwdBlock |
	(self isObjectForwarded: oop) ifTrue: [
		"get the new value for oop from its forwarding block"
		fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.
		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
		^ self longAt: fwdBlock
	].
	^ oop!
remapClassOf: oop
	"Update the class of the given object, if necessary, using its forwarding table entry."
	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."

	| classHeader classOop fwdBlock newClassOop newClassHeader |
	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"

	classHeader _ self longAt: (oop - 4).
	classOop _ classHeader bitAnd: AllButTypeMask.
	(self isObjectForwarded: classOop) ifTrue: [
		fwdBlock _ (self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask.
		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
		newClassOop _ self longAt: fwdBlock.
		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).
		self longAt: (oop - 4) put: newClassHeader.

		"The following ensures that become: into an old object's class makes it a root.
		  It does nothing during either incremental or full compaction because
		  oop will never be < youngStart."
		((oop < youngStart) and: [newClassOop >= youngStart])
			ifTrue: [ self beRootWhileForwarding: oop ].
	].!
remapFieldsAndClassOf: oop
	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."
	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."

	| fieldOffset fieldOop fwdBlock newOop |
	fieldOffset _ self lastPointerWhileForwarding: oop.
	[fieldOffset >= BaseHeaderSize] whileTrue: [
		fieldOop _ self longAt: (oop + fieldOffset).
		(self isObjectForwarded: fieldOop) ifTrue: [
			"update this oop from its forwarding block"
			fwdBlock _ (self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask.
			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].
			newOop _ self longAt: fwdBlock.
			self longAt: (oop + fieldOffset) put: newOop.

			"The following ensures that become: into old object makes it a root.
			  It does nothing during either incremental or full compaction because
			  oop will never be < youngStart."
			((oop < youngStart) and: [newOop >= youngStart])
				ifTrue: [ self beRootWhileForwarding: oop ].
		].
		fieldOffset _ fieldOffset - 4.
	].
	self remapClassOf: oop.! !
!ObjectMemory methodsFor: 'become'!
allYoung: array1 and: array2
	"Return true if all the oops in both arrays, and the arrays themselves, are in the young object space."

	| fieldOffset |
	array1 < youngStart ifTrue: [ ^ false ].
	array2 < youngStart ifTrue: [ ^ false ].
	fieldOffset _ self lastPointerOf: array1.  "same size as array2"
	[fieldOffset >= BaseHeaderSize] whileTrue: [
		(self longAt: array1 + fieldOffset) < youngStart ifTrue: [ ^ false ].
		(self longAt: array2 + fieldOffset) < youngStart ifTrue: [ ^ false ].
		fieldOffset _ fieldOffset - 4.
	].
	^ true!
become: array1 with: array2
	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."
	"Implementation: Uses forwarding blocks to update references as done in compaction."

	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].
	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].
	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].
	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].

	(self prepareForwardingTableForBecoming: array1 with: array2) ifFalse: [
		^ false  "fail; not enough space for forwarding table"
	].

	(self allYoung: array1 and: array2) ifTrue: [
		"sweep only the young objects plus the roots"
		self mapPointersInObjectsFrom: youngStart to: endOfMemory.
	] ifFalse: [
		"sweep all objects"
		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.
	].

	self restoreHeadersAfterBecoming: array1 with: array2.
	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"

	^ true  "success"!
containOnlyOops: array1 and: array2
	"Return true if neither array contains a small integer. You can't become: integers!!"

	| fieldOffset |
	fieldOffset _ self lastPointerOf: array1.  "same size as array2"
	[fieldOffset >= BaseHeaderSize] whileTrue: [
		(self isIntegerObject: (self longAt: array1 + fieldOffset)) ifTrue: [ ^ false ].
		(self isIntegerObject: (self longAt: array2 + fieldOffset)) ifTrue: [ ^ false ].
		fieldOffset _ fieldOffset - 4.
	].
	^ true!
exchangeHashBits: oop1 with: oop2

	| hdr1 hdr2 |
	hdr1 _ self longAt: oop1.
	hdr2 _ self longAt: oop2.
	self longAt: oop1 put:
		((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).
	self longAt: oop2 put:
		((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).
!
prepareForwardingTableForBecoming: array1 with: array2
	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."
	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."

	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock |
	entriesNeeded _ 2 * ((self lastPointerOf: array1) // 4).  "need enough entries for both directions"
	entriesAvailable _ self fwdTableInit.
	entriesAvailable < entriesNeeded ifTrue: [
		self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"
		^ false
	].

	fieldOffset _ self lastPointerOf: array1.
	[fieldOffset >= BaseHeaderSize] whileTrue: [
		oop1 _ self longAt: array1 + fieldOffset.
		oop2 _ self longAt: array2 + fieldOffset.
		fwdBlock _ self fwdBlockGet.
		self initForwardBlock: fwdBlock mapping: oop1 to: oop2.
		fwdBlock _ self fwdBlockGet.
		self initForwardBlock: fwdBlock mapping: oop2 to: oop1.
		fieldOffset _ fieldOffset - 4.
	].
	^ true!
restoreHeaderOf: oop
	"Restore the original header of the given oop from its forwarding block."

	| fwdHeader fwdBlock |
	fwdHeader _ self longAt: oop.
	fwdBlock _ fwdHeader bitAnd: AllButMarkBitAndTypeMask.

	checkAssertions ifTrue: [
		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [
			self error: 'attempting to restore the header of an object that has no forwarding block'.
		].
		self fwdBlockValidate: fwdBlock.
	].

	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"!
restoreHeadersAfterBecoming: list1 with: list2
	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."

	| fieldOffset oop1 oop2 |
	fieldOffset _ self lastPointerOf: list1.
	[fieldOffset >= BaseHeaderSize] whileTrue: [
		oop1 _ self longAt: list1 + fieldOffset.
		oop2 _ self longAt: list2 + fieldOffset.
		self restoreHeaderOf: oop1.
		self restoreHeaderOf: oop2.
		self exchangeHashBits: oop1 with: oop2.
		fieldOffset _ fieldOffset - 4.
	].! !
!ObjectMemory class methodsFor: 'initialization'!
initialize
	"ObjectMemory initialize"

	self initializeSpecialObjectIndices.
	self initializeObjectHeaderConstants.

	LargeContextSize _ 156.
	SmallContextSize _ 76.
	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"

	AllocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"
	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"
	RemapBufferSize _ 25.
	RootTableSize _ 1000.  "number of root table entries (4 bytes/entry)"

	"tracer actions"
	StartField _ 1.
	StartObj _ 2.
	Upward _ 3.
	Done _ 4.!
initializeObjectHeaderConstants

	BaseHeaderSize _ 4.

	"masks for type field"
	TypeMask _ 3.
	AllButTypeMask _ 16rFFFFFFFF - TypeMask.

	"type field values"
	HeaderTypeSizeAndClass _ 0.
	HeaderTypeClass _ 1.
	HeaderTypeFree _ 2.
	HeaderTypeShort _ 3.

	"type field values used during the mark phase of GC"
	HeaderTypeGC _ 2.
	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."

	"mask for a free chunk size"
	FreeSizeMask _ 16r1FFFFFFC.

	"base header word bit fields"
	HashBits _ 16r1FFE0000.
	AllButHashBits _ 16rFFFFFFFF - HashBits.
	HashBitsOffset _ 17.

	"masks for root and mark bits"
	MarkBit _ 16r80000000.
	RootBit _ 16r40000000.
	AllButMarkBit _ 16rFFFFFFFF - MarkBit.
	AllButRootBit _ 16rFFFFFFFF - RootBit.

	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.!
initializeSpecialObjectIndices
	"Initialize indices into specialObjects array."

	NilObject _ 0.
	FalseObject _ 1.
	TrueObject _ 2.
	SchedulerAssociation _ 3.
	ClassBitmap _ 4.
	ClassInteger _ 5.
	ClassString _ 6.
	ClassArray _ 7.
	"SmalltalkDictionary _ 8."  "Do not delete!!"
	ClassFloat _ 9.
	ClassMethodContext _ 10.
	ClassBlockContext _ 11.
	ClassPoint _ 12.
	ClassLargePositiveInteger _ 13.
	TheDisplay _ 14.
	ClassMessage _ 15.
	ClassCompiledMethod _ 16.
	TheLowSpaceSemaphore _ 17.
	ClassSemaphore _ 18.
	ClassCharacter _ 19.
	SelectorDoesNotUnderstand _ 20.
	SelectorCannotReturn _ 21.
	TheInputSemaphore _ 22.
	SpecialSelectors _ 23.
	CharacterTable _ 24.
	SelectorMustBeBoolean _ 25.
	ClassByteArray _ 26.
	ClassProcess _ 27.
	CompactClasses _ 28.
	TheTimerSemaphore _ 29.
	TheInterruptSemaphore _ 30.! !
!ObjectMemory class methodsFor: 'translation'!
declareCVarsIn: aCCodeGenerator

	aCCodeGenerator var: 'memory'
		declareC: 'unsigned char *memory'.
	aCCodeGenerator var: 'remapBuffer'
		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.
	aCCodeGenerator var: 'rootTable'
		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.! !
!OrderedCollection methodsFor: 'accessing'!
inspect
	"Open an OrderedCollectionInspector on the receiver.
	Use basicInspect to get a normal type of inspector."

	OrderedCollectionInspector openOn: self withEvalPane: true! !
!OrderedCollection methodsFor: 'copying'!
copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."

	| targetCollection |
	endIndex < startIndex ifTrue: [^self species new: 0].
	targetCollection _ self species new: endIndex + 1 - startIndex.
	startIndex to: endIndex do: [:index | targetCollection add: (self at: index)].
	^ targetCollection!
copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| newOrderedCollection delta startIndex stopIndex |
	"if start is less than 1, ignore stop and assume this is inserting at the front. 
	if start greater than self size, ignore stop and assume this is appending. 
	otherwise, it is replacing part of me and start and stop have to be within my 
	bounds. "
	delta _ 0.
	startIndex _ start.
	stopIndex _ stop.
	start < 1
		ifTrue: [startIndex _ stopIndex _ 0]
		ifFalse: [startIndex > self size
				ifTrue: [startIndex _ stopIndex _ self size + 1]
				ifFalse: 
					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])
						ifTrue: [self errorOutOfBounds].
					delta _ stopIndex - startIndex + 1]].
	newOrderedCollection _ 
		self species new: self size + replacementCollection size - delta.
	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].
	1 to: replacementCollection size do: 
		[:index | newOrderedCollection add: (replacementCollection at: index)].
	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].
	^newOrderedCollection!
copyWithout: oldElement 
	"Answer a copy of the receiver that does not contain any elements equal
	to oldElement."
	| newCollection |
	newCollection _ self species new: self size.
	self do: [:each | oldElement = each ifFalse: [newCollection add: each]].
	^newCollection!
reversed
	"Answer a copy of the receiver with element order reversed.  1/26/96 sw"
	| newCol |
	newCol _ self species new.
	self reverseDo:
		[:elem | newCol addLast: elem].
	^ newCol

"#(2 3 4 'fred') reversed"! !
!OrderedCollection methodsFor: 'private'!
makeRoomAtLast
	| newLast delta |
	newLast _ self size.
	array size - self size = 0 ifTrue: [self grow].
	(delta _ firstIndex - 1) = 0 ifTrue: [^ self].
	"we might be here under false premises or grow did the job for us"
	1 to: newLast do:
		[:index |
		array at: index put: (array at: index + delta).
		array at: index + delta put: nil].
	firstIndex _ 1.
	lastIndex _ newLast! !
!Paragraph methodsFor: 'accessing'!
backgroundColor
	backColor == nil ifTrue: [^ Color white].
	^ backColor!
replaceFrom: start to: stop with: aText displaying: displayBoolean
	"Replace the receiver's text starting at position start, stopping at stop, by 
	the characters in aText. It is expected that most requirements for 
	modifications to the receiver will call this code. Certainly all cut's or 
	paste's." 

	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex
	startLine stopLine replacementRange visibleRectangle startIndex newLine done
	newStop obsoleteY newY moveRectangle |

	text replaceFrom: start to: stop with: aText.		"Update the text."
	lastLine = 0 ifTrue:
		["if lines have never been set up, measure them and display
		all the lines falling in the visibleRectangle"
		self composeAll.
		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].

	"save -- things get pretty mashed as we go along"
	obsoleteLines _ lines copy.
	obsoleteLastLine _ lastLine.

	"find the starting and stopping lines"
	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.
	stopLine _ self lineIndexOfCharacterIndex: stop.

	"how many characters being inserted or deleted
		-- negative if aText size is < characterInterval size."
	replacementRange _ aText size - (stop - start + 1).
	"Give ourselves plenty of elbow room."
	compositionRectangle height: textStyle lineGrid * 8196.	"max Vector length"
	"build a boundingBox of the actual screen space in question -- we'll need it later"
	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)
							intersect: destinationForm boundingBox.
	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."

	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."
	startIndex _ (lines at: firstLineIndex) first.
	startLine > 1
		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1
						fromCharacterIndex: (lines at: startLine - 1) first
						inParagraph: self.
				(lines at: startLine - 1) = newLine
					ifFalse:	["start in line preceding the one with the starting character"
							startLine _ startLine - 1.
							self lineAt: startLine put: newLine.
							startIndex _ newLine last + 1]].
	startIndex > text size ifTrue:
		["nil lines after a deletion -- remeasure last line below"
		self trimLinesTo: (firstLineIndex - 1 max: 0).
		text size = 0 ifTrue:
			["entire text deleted -- clear visibleRectangle and return."
			destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor.
			self updateCompositionHeight.
			^self]].

	"Now we really get to it."
	done _ false.
	lastLineIndex _ stopLine.
	[done or: [startIndex > text size]]
		whileFalse: 
		[self lineAt: firstLineIndex put:
			(newLine _ compositionScanner composeLine: firstLineIndex
							fromCharacterIndex: startIndex inParagraph: self).
		[(lastLineIndex > obsoleteLastLine
			or: ["no more old lines to compare with?"
				newLine last <
					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])
			  	or: [done]]
			whileFalse: 
			[newStop = newLine last
				ifTrue:	["got the match"
						"get source and dest y's for moving the unchanged lines"
						obsoleteY _ self topAtLineIndex: lastLineIndex + 1
									using: obsoleteLines and: obsoleteLastLine.
						newY _ self topAtLineIndex: firstLineIndex + 1.
						stopLine _ firstLineIndex.
						done _ true.
							"Fill in the new line vector with the old unchanged lines.
							Update their starting and stopping indices on the way."
						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:
							[:upDatedIndex | 
							self lineAt: (firstLineIndex _ firstLineIndex + 1) 
								put: ((obsoleteLines at: upDatedIndex)
							  		slide: replacementRange)].
							"trim off obsolete lines, if any"
						self trimLinesTo: firstLineIndex]
				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].
		startIndex _ newLine last + 1.
		firstLineIndex _ firstLineIndex + 1].

	"Now the lines are up to date -- Whew!!.  What remains is to move
	the 'unchanged' lines and display those which have changed."
	displayBoolean   "Not much to do if not displaying"
		ifFalse: [^ self updateCompositionHeight].
	startIndex > text size ifTrue:
		["If at the end of previous lines simply display lines from the line in
		which the first character of the replacement occured through the
		end of the paragraph."
		self updateCompositionHeight.
		self displayLines:
			(startLine to: (stopLine _ firstLineIndex min: lastLine)).
		destinationForm  "Clear out area at the bottom"
			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)
						extent: visibleRectangle extent)
					intersect: visibleRectangle)
			rule: rule fillColor: self backgroundColor]
		ifFalse:
		[newY ~= obsoleteY ifTrue:
			["Otherwise first move the unchanged lines within
			the visibleRectangle with a good old bitblt."
			moveRectangle _
				visibleRectangle left @ (obsoleteY max: visibleRectangle top)
					corner: visibleRectangle corner.
			destinationForm copyBits: moveRectangle from: destinationForm
				at: moveRectangle origin + (0 @ (newY-obsoleteY))
				clippingBox: visibleRectangle
				rule: Form over fillColor: nil].

		"Then display the altered lines."
		self displayLines: (startLine to: stopLine).

		newY < obsoleteY
			ifTrue:
			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom
				ifTrue:
				["A deletion may have 'pulled' previously undisplayed lines
				into the visibleRectangle.  If so, display them."
				self displayLines:
					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))
						to: (self lineIndexOfTop: visibleRectangle bottom))].
			"Clear out obsolete material at the bottom of the visibleRectangle."
			destinationForm
				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)
						extent: visibleRectangle extent)
					intersect: visibleRectangle)  "How about just corner: ??"
				rule: rule fillColor: self backgroundColor].

		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])
			ifTrue:
				["An insertion may have 'pushed' previously undisplayed lines
				into the visibleRectangle.  If so, display them."
				self displayLines:
					((self lineIndexOfTop: visibleRectangle top)
						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].

		self updateCompositionHeight]! !
!Paragraph methodsFor: 'selecting'!
clickAt: clickPoint for: model 
	"Give sensitive text a chance to fire"
	"NOTE: Should highight on mouseDown, then abort if drag, else act on mouseUp.
	This will require first asking, eg, wantToActOnClick, and then using
	Utilities awaitMouseUpIn: box, where box is determined by range of attribute."
	| startBlock action |
	action _ false.
	startBlock _ self characterBlockAtPoint: clickPoint.
	(text attributesAt: startBlock stringIndex) 
		do: [:att | (att actOnClickFor: model) ifTrue: [action _ true]].
	^ action!
reverseFrom: characterBlock1 to: characterBlock2 
	"Reverse area between the two character blocks given as arguments."
	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |
	characterBlock1 = characterBlock2 ifTrue:
		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.
		baseline _ lineNo = 0 ifTrue: [textStyle baseline]
							ifFalse: [(lines at: lineNo) baseline].
		^ CaretForm  "Use a caret to indicate null selection"
				displayOn: destinationForm at: characterBlock1 topLeft + (0 @ baseline)
				clippingBox: clippingRectangle
				rule: (Display depth>8 ifTrue: [9 "not-reverse"]
									ifFalse: [Form reverse])
				fillColor: nil].
	visibleRectangle _ 
		(clippingRectangle intersect: compositionRectangle)
			"intersect: destinationForm boundingBox" "not necessary".
	characterBlock1 top = characterBlock2 top
		ifTrue: [characterBlock1 left < characterBlock2 left
					ifTrue: 
						[initialRectangle _ 
							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)
								intersect: visibleRectangle]
					ifFalse: 
						[initialRectangle _ 
							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)
								intersect: visibleRectangle]]
		ifFalse: [characterBlock1 top < characterBlock2 top
					ifTrue: 
						[initialRectangle _ 
							(characterBlock1 topLeft 
								corner: visibleRectangle right @ characterBlock1 bottom)
								intersect: visibleRectangle.
						characterBlock1 bottom = characterBlock2 top
							ifTrue: 
								[finalRectangle _ 
									(visibleRectangle left @ characterBlock2 top 
										corner: characterBlock2 bottomLeft)
										intersect: visibleRectangle]
							ifFalse: 
								[interiorRectangle _ 
									(visibleRectangle left @ characterBlock1 bottom
										corner: visibleRectangle right 
														@ characterBlock2 top)
										intersect: visibleRectangle.
								finalRectangle _ 
									(visibleRectangle left @ characterBlock2 top 
										corner: characterBlock2 bottomLeft)
										intersect: visibleRectangle]]
				ifFalse: 
					[initialRectangle _ 
						(visibleRectangle left @ characterBlock1 top 
							corner: characterBlock1 bottomLeft)
							intersect: visibleRectangle.
					characterBlock1 top = characterBlock2 bottom
						ifTrue: 
							[finalRectangle _ 
								(characterBlock2 topLeft 
									corner: visibleRectangle right 
												@ characterBlock2 bottom)
									intersect: visibleRectangle]
						ifFalse: 
							[interiorRectangle _ 
								(visibleRectangle left @ characterBlock2 bottom 
									corner: visibleRectangle right @ characterBlock1 top)
									intersect: visibleRectangle.
							finalRectangle _ 
								(characterBlock2 topLeft 
									corner: visibleRectangle right 
												@ characterBlock2 bottom)
									intersect: visibleRectangle]]].
	self hiliteRect: initialRectangle.
	self hiliteRect: interiorRectangle.
	self hiliteRect: finalRectangle.! !
!Paragraph methodsFor: 'converting'!
asForm
	"Answer a Form made up of the bits that represent the receiver's 
	displayable text."
	| theForm |
	((foreColor == nil or: [foreColor = Color black])
		and: [backColor == nil or: [backColor = Color white]])
		ifTrue: [theForm _ Form extent: compositionRectangle extent]
		ifFalse: [theForm _ TwoToneForm extent: compositionRectangle extent.
				theForm foregroundColor: (foreColor == nil ifTrue: [Color black]
															ifFalse: [foreColor])
						backgroundColor: (backColor == nil ifTrue: [Color white]
															ifFalse: [backColor])].
	self displayOn: theForm
		at: 0 @ 0
		clippingBox: theForm boundingBox
		rule: Form over
		fillColor: nil.
	theForm offset: offset.
	^ theForm! !
!Paragraph methodsFor: 'private'!
bottomAtLineIndex: lineIndex 
	"Answer the bottom y of given line."
	| y |
	y _ compositionRectangle top.
	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].
	1 to: (lineIndex min: lastLine) do:
		[:i | y _ y + (lines at: i) lineHeight].
	^ y
!
compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint

	compositionRectangle _ compositionRect copy.
	text _ aText.
	textStyle _ aTextStyle.
	rule _ DefaultRule.
	mask _ nil.		"was DefaultMask 9/30/96 tk"
	marginTabsLevel _ 0.
	destinationForm _ Display.
	offset _ aPoint.
	^self composeAll!
displayLines: linesInterval affectedRectangle: affectedRectangle
	"This is the first level workhorse in the display portion of the TextForm routines.
	It checks to see which lines in the interval are actually visible, has the
	CharacterScanner display only those, clears out the areas in which display will
	occur, and clears any space remaining in the visibleRectangle following the space
	occupied by lastLine."

	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |

	"Save some time by only displaying visible lines"
	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.
	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].
	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.
	lastLineIndex > linesInterval last ifTrue:
			[linesInterval last > lastLine
		 		ifTrue: [lastLineIndex _ lastLine]
		  		ifFalse: [lastLineIndex _ linesInterval last]].
	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).
	((Rectangle 
		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 
		corner: affectedRectangle right @ lastLineIndexBottom)
	  intersects: affectedRectangle)
		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"
				DisplayScanner new
					displayLines: (firstLineIndex to: lastLineIndex)
					in: self clippedBy: affectedRectangle].
	lastLineIndex = lastLine ifTrue: 
		 [destinationForm  "Clear out white space below last line"
		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)
				corner: affectedRectangle bottomRight)
		 	rule: rule fillColor: self backgroundColor]!
leftMarginForDisplayForLine: lineIndex 
	"Build the left margin for display of a line. Depends upon
	leftMarginForComposition, compositionRectangle left and the alignment."

	| pad |
	(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])
		ifTrue: 
			[^compositionRectangle left 
				+ (self leftMarginForCompositionForLine: lineIndex)].
	"When called from character location code and entire string has been cut,
	there are no valid lines, hence following nil check."
	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])
		ifTrue: 
			[pad _ (lines at: lineIndex) paddingWidth]
		ifFalse: 
			[pad _ 
				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].
	textStyle alignment = Centered 
		ifTrue: 
			[^compositionRectangle left 
				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].
	textStyle alignment = RightFlush 
		ifTrue:
			[^compositionRectangle left 
				+ (self leftMarginForCompositionForLine: lineIndex) + pad].
	self error: ['no such alignment']!
lineIndexOfTop: top 
	"Answer the line index at a given top y."
	| y line |
	lastLine = 0 ifTrue: [^ 1].
	y _ compositionRectangle top.
	1 to: lastLine do:
		[:i | line _ lines at: i.
		(y _ y + line lineHeight) > top ifTrue: [^ i]].
	^ lastLine
!
setWithText: aText style: aTextStyle 
	"Set text and adjust bounding rectangles to fit."

	| shrink compositionWidth unbounded |
	unbounded _ Rectangle origin: 0 @ 0 extent: 10000@10000.
	compositionWidth _ self
		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.
	compositionRectangle width: compositionWidth.
	clippingRectangle _ compositionRectangle copy.
	shrink _ unbounded width - compositionWidth.
	"Shrink padding widths accordingly"
	1 to: lastLine do:
		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]!
topAtLineIndex: lineIndex 
	"Answer the top y of given line."
	| y |
	y _ compositionRectangle top.
	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].
	1 to: (lineIndex-1 min: lastLine) do:
		[:i | y _ y + (lines at: i) lineHeight].
	^ y
!
topAtLineIndex: lineIndex using: otherLines and: otherLastLine
	"Answer the top y of given line."
	| y |
	y _ compositionRectangle top.
	otherLastLine = 0 ifTrue: [^ y].
	1 to: (lineIndex-1 min: otherLastLine) do:
		[:i | y _ y + (otherLines at: i) lineHeight].
	^ y
!
updateCompositionHeight
	"Mainly used to insure that intersections with compositionRectangle work." 

	compositionRectangle height:
		(self bottomAtLineIndex: lastLine) - compositionRectangle top.
	(text size ~= 0 and: [(text at: text size) = CR])
		ifTrue: [compositionRectangle 
					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !
!Paragraph class methodsFor: 'examples'!
example
	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  
	Fixed. 9/30/96 tk"

	| para point |
	point _ Sensor waitButton.
	para _ 'This is the first line of characters
and this is the second line.' asParagraph.
	para displayOn: Display at: point.

	"Paragraph example"! !
!ParagraphEditor methodsFor: 'sensor access'!
processRedButton
	"The user pressed a red mouse button, meaning create a new text 
	selection. Highlighting the selection is carried out by the paragraph 
	itself. Double clicking causes a selection of the area between the nearest 
	enclosing delimitors."

	| previousStartBlock previousStopBlock selectionBlocks tempBlock clickPoint oldDelta oldInterval |

	clickPoint _ sensor cursorPoint.
	(view containsPoint: clickPoint) ifFalse: [^ self].
	(paragraph clickAt: clickPoint for: nil) ifTrue: [^ self].
	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.
	previousStartBlock _ startBlock.
	previousStopBlock _ stopBlock.
	oldDelta _ paragraph scrollDelta.
	sensor leftShiftDown
		ifFalse:
			[self deselect.
			self closeTypeIn.
			selectionBlocks _ paragraph mouseSelect: clickPoint]
		ifTrue:
			[selectionBlocks _ paragraph extendSelectionAt: startBlock endBlock: stopBlock.
			self closeTypeIn].
	selectionShowing _ true.
	startBlock _ selectionBlocks at: 1.
	stopBlock _ selectionBlocks at: 2.
	startBlock > stopBlock
		ifTrue: 
			[tempBlock _ startBlock.
			startBlock _ stopBlock.
			stopBlock _ tempBlock].
	(startBlock = stopBlock 
		and: [previousStartBlock = startBlock and: [previousStopBlock = stopBlock]])
		ifTrue: [self selectWord].
	oldDelta ~= paragraph scrollDelta "case of autoscroll"
			ifTrue: [self updateMarker].
	self setEmphasisHere.
	(self isDisjointFrom: oldInterval) ifTrue:
		[otherInterval _ oldInterval]! !
!ParagraphEditor methodsFor: 'menu messages'!
changeStyle
	"Let user change styles for the current text pane  8/20/96 tk
	 Moved from experimentalCommand to its own method  8/20/96 sw"

	| aList reply style |
	aList _ (TextConstants select: [:thang | thang isKindOf: TextStyle])
			keys asOrderedCollection.
	reply _ (SelectionMenu labelList: aList selections: aList) startUp.
	reply ~~ nil ifTrue:
		[style _ TextConstants at: reply ifAbsent: [self beep. ^ true].
		paragraph textStyle: style copy.
		paragraph composeAll.
		self recomputeSelection.
		Display fill: paragraph clippingRectangle 
			fillColor: view backgroundColor.	"very brute force"
		self display.
		"paragraph changed"].
	^ true!
clipboardText
	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."

	| s |
	s _ Smalltalk clipboardText.
	(s isEmpty or: [s = CurrentSelection string])
		ifTrue: [^ CurrentSelection]
		ifFalse: [^ s asText]!
explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil.
	1/15/96 sw: put here intact from BrowserCodeController.  But there's too many things that still don't work, as the explain code was very tightly bound with properties of code browsers.  So for the moment, in the interest of system integrity, we don't permit.  2/5/96 sw"

	| string tiVars cgVars selectors delimitors numbers sorry reply newLine |

	true ifTrue:
		[self flag: #noteToTed.   "Feel like taking this on?  Plenty of things make sense to explain in any text window, but my efforts to elevate the explain facility to more generic use ran out of steam before success."
		^ self inform: 'Sorry, explain is currently available
only in code panes.  Someday, it may be available
in any text pane.  Maybe.'].

	newLine _ String with: Character cr.
	Cursor execute
		showWhile: 
			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.
			sorry _ sorry , (model isUnlocked
							ifTrue: ['"']
							ifFalse: ['  Also, please cancel or accept."']).
			(string _ self selection asString) isEmpty
				ifTrue: [reply _ '']
				ifFalse: 
					[string _ self explainScan: string.
					"Remove space, tab, cr"
					"Temps and Instance vars need only test strings that are 
					all  
					letters"
					(string detect: [:char | (char isLetter or: [char isDigit]) not]
						ifNone: [])
						~~ nil
						ifFalse: 
							[tiVars _ self explainTemp: string.
							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].
					(tiVars == nil and: [model class == Browser])
						ifTrue: [tiVars _ model explainSpecial: string].
					tiVars == nil
						ifTrue: [tiVars _ '']
						ifFalse: [tiVars _ tiVars , newLine].
					"Context, Class, Pool, and Global vars, and Selectors need 
					only test symbols"
					(Symbol hasInterned: string ifTrue: [:symbol | symbol])
						ifTrue: 
							[cgVars _ self explainCtxt: symbol.
							cgVars == nil
								ifTrue: 
									[cgVars _ self explainClass: symbol.
									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].
							"See if it is a Selector (sent here or not)"
							selectors _ self explainMySel: symbol.
							selectors == nil
								ifTrue: 
									[selectors _ self explainPartSel: string.
									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]
						ifFalse: [selectors _ self explainPartSel: string].
					cgVars == nil
						ifTrue: [cgVars _ '']
						ifFalse: [cgVars _ cgVars , newLine].
					selectors == nil
						ifTrue: [selectors _ '']
						ifFalse: [selectors _ selectors , newLine].
					string size = 1
						ifTrue: ["single special characters"
							delimitors _ self explainChar: string]
						ifFalse: ["matched delimitors"
							delimitors _ self explainDelimitor: string].
					numbers _ self explainNumber: string.
					numbers == nil ifTrue: [numbers _ ''].
					delimitors == nil ifTrue: [delimitors _ ''].
					reply _ tiVars , cgVars , selectors , delimitors , numbers].
			reply size = 0 ifTrue: [reply _ sorry].
			self afterSelectionInsertAndSelect: reply]!
explainGlobal: symbol 
	"Is symbol a global variable?
	 1/15/96 sw: copied intact from BrowserCodeController"
	| reply classes newLine |
	self flag: #noteToTed.  "a fumbling piece of the generic-explain attempt."

	newLine _ String with: Character cr.
	reply _ Smalltalk at: symbol ifAbsent: [^nil].
	(reply isKindOf: Behavior)
		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,
			'."', newLine, 'Browser newOnClass: ' , symbol , '.'].
	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].
	reply class == Dictionary
		ifTrue: 
			[classes _ Set new.
			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]
					ifNone: [])
					~~ nil ifTrue: [classes add: each]].
			classes _ classes printString.
			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].
	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'!
methodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"

	startBlock = stopBlock ifTrue: [view flash.  ^ self].
	(self confirm: 'This will take a few minutes.
Shall I proceed?') ifFalse: [^ self].
	Smalltalk browseMethodsWithSourceString: self selection string!
specialMenuItems
	"Refer to comment under #presentSpecialMenu.  4/29/96 sw.
	 9/27/96 sw: added objectsReferencingIt,"

	^ #(	'Transcript cr; show: ''testing'''
			'view superView model inspect'
			'view superView model browseObjClass'
			'view display'
			'self inspect'
			'view backgroundColor: Color fromUser'
			'view topView inspect'
			'self compareToClipboard'
			'view insideColor: Form white'
			'self objectsReferencingIt'
		) ! !
!ParagraphEditor methodsFor: 'editing keys'!
changeEmphasis: characterStream 
	"Change the emphasis of the current selection or prepare to accept 
	characters with the change in emphasis. Emphasis change amounts to a 
	font change.  Keeps typeahead."
	| keyCode attribute oldAttributes index |		 "control 0..9 -> 0..9"
	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.
	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.

	"Decipher keyCodes for Command 0-9..."
	(keyCode between: 1 and: 5) ifTrue:
		[attribute _ TextFontChange fontNumber: keyCode].
	keyCode = 6 ifTrue:
		[index _ (PopUpMenu labelArray: #(black magenta red yellow green blue active)
							lines: #(6)) startUp.
		index = 0 ifTrue: [^ true].
		attribute _ index = 7
		ifTrue: [TextAction evalString: self selection asString]
		ifFalse: [TextColor color: (Color perform: (#(black magenta red yellow green blue cyan) at: index))]].
	(keyCode between: 7 and: 11) ifTrue:
		[attribute _ TextEmphasis perform:
					(#(bold italic narrow underlined struckOut) at: keyCode - 6).
		oldAttributes do:
			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].
	(keyCode = 0) ifTrue:
		[attribute _ TextEmphasis normal].

	beginTypeInBlock ~~ nil
		ifTrue:  "only change emphasisHere while typing"
			[self insertTypeAhead: characterStream.
			emphasisHere _ Text addAttribute: attribute toArray:
					oldAttributes.
			^ true].
	self replaceSelectionWith: (self selection addAttribute: attribute).
	^ true!
offerFontMenu
	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  5/27/96 sw
	Use only names of Fonts of this paragraph  8/19/96 tk"

	| aList reply |
	aList _ paragraph textStyle fontNames.
	reply _ (SelectionMenu labelList: aList selections: aList) startUp.
	reply ~~ nil ifTrue:
		[self replaceSelectionWith:
			(Text string: self selection asString 
				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] !
swapChars: characterStream 
	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  1/18/96 sw"

	| currentSelection aString chars |
	sensor keyboard.		"flush the triggering cmd-key character"
	(chars _ self selection) size == 0
		ifTrue:
			[currentSelection _ startBlock stringIndex]
		ifFalse:
			[chars size == 2
				ifFalse:
					[view flash.  ^ true]
				ifTrue:
					[currentSelection _ startBlock stringIndex + 1]].

	self selectFrom: currentSelection - 1 to: currentSelection.
	aString _ self selection string.
	self replaceSelectionWith: (Text fromString: aString reversed).
	self selectAt: currentSelection + 1.
	^ true! !
!ParagraphEditor methodsFor: 'typing/selecting keys'!
crWithIndent: characterStream 
	"Replace the current text selection with CR followed by as many tabs
	as on the current line (+/- bracket count) -- initiated by Shift-Return."
	| char s i tabCount |
	sensor keyboard.		"flush character"
	s _ paragraph string.
	i _ stopBlock stringIndex.
	tabCount _ 0.
	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]
		whileTrue:  "Count tabs and brackets (but not a leading bracket)"
		[(char = Character tab and: [(s at: i+1) ~= $[]) ifTrue: [tabCount _ tabCount + 1].
		char = $[ ifTrue: [tabCount _ tabCount + 1].
		char = $] ifTrue: [tabCount _ tabCount - 1]].
	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"
	^ false!
forwardDelete: characterStream
	"Delete forward over the next character.
	11/4/96 tk  Make Undo work on the whole type-in, not just the one char."
	| startIndex usel upara uinterval ind |
	startIndex _ startBlock stringIndex.
	startIndex > paragraph text size ifTrue:
		[Sensor keyboard.
		^ false].
	startIndex = stopBlock stringIndex ifFalse:
		["there was a selection"
		"Just like regular Backspace -- delete the selection"
		^ self backspace: characterStream].
	"Null selection - do the delete forward"
	beginTypeInBlock == nil	"no previous typing.  openTypeIn"
		ifTrue: [self openTypeIn. UndoSelection _ self nullText].
	uinterval _ UndoInterval deepCopy.
	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"
	"usel _ UndoSelection deepCopy."
	upara _ UndoParagraph deepCopy.
	Sensor keyboard.
	self selectFrom: startIndex to: startIndex.
	self replaceSelectionWith: self nullText.
	self selectFrom: startIndex to: startIndex-1.
	UndoParagraph _ upara.  UndoInterval _ uinterval.
	UndoMessage selector == #noUndoer ifTrue: [
		(UndoSelection isKindOf: Text) ifTrue: [
			usel _ UndoSelection.
			ind _ startIndex. "UndoInterval startIndex"
			usel replaceFrom: usel size + 1 to: usel size with:
				(UndoParagraph text copyFrom: ind to: ind).
			UndoParagraph text replaceFrom: ind to: ind with:
self nullText]].
	^false! !
!ParagraphEditor methodsFor: 'typing support'!
setEmphasisHere

	emphasisHere _ paragraph text attributesAt: startBlock stringIndex! !
!ParagraphEditor class methodsFor: 'class initialization'!
initialize
	"Initialize the keyboard shortcut maps and the shared buffers
	for copying text across views and managing again and undo.
	6/18/96 sw: call initializeTextEditorMenus
	other times: marked change to trigger reinit" 

	"ParagraphEditor initialize"

	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.
	UndoMessage _ Message selector: #halt.

	self initializeCmdKeyShortcuts.
	self initializeShiftCmdKeyShortcuts.
	self initializeTextEditorMenus
! !
!ParagraphEditor class methodsFor: 'keyboard shortcut tables'!
initializeCmdKeyShortcuts
	"Initialize the (unshifted) command-key shortcut table."
	"ParagraphEditor initialize"

	| cmdMap cmds |
	cmdMap _ Array new: 256.  "use temp in case of a crash"
	cmdMap atAllPut: #noop:.
	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"
	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"
	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"

	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].
	'([{''"<'         do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].
	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.

	cmds _ #(
		$a	selectAll:
		$b	browseIt:
		$c	copySelection:
		$d	doIt:
		$e	exchange:
		$f	find:
		$g	findAgain:
		$h	setSearchString:
		$i	inspectIt:
		$j	doAgainOnce:
		$k  offerFontMenu:
		$l	cancel:
		$m	implementorsOfIt:
		$n	sendersOfIt:
		$o	spawnIt:
		$p	printIt:
		$q	querySymbol:
		$r	recognizer:
		$s	save:
		$t	tempCommand:
		$u	align:
		$v	paste:
		$w	backWord:
		$x	cut:
		$y	swapChars:
		$z	undo:
	).
	1 to: cmds size by: 2 do: [ :i |
		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).
	].
	CmdActions _ cmdMap.
!
initializeShiftCmdKeyShortcuts
	"Initialize the shift-command-key (or control-key) shortcut table."

	| cmdMap cmds |
	"shift-command and control shortcuts"
	cmdMap _ Array new: 256.  "use temp in case of a crash"
	cmdMap atAllPut: #noop:.
	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"
	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"
	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"

	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("
	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"
	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."
	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["

	cmds _ #(
		$a	argAdvance:
		$b	browseItHere:
		$c	compareToClipboard:
		$d	duplicate:
		$f	displayIfFalse:
		$j	doAgainMany:
		$k	changeStyle:
		$n	referencesToIt:
		$r	indent:
		$l	outdent:
		$s	search:
		$t	displayIfTrue:
		$w	methodNamesContainingIt:
		$v	pasteInitials:
	).
	1 to: cmds size by: 2 do: [ :i |
		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).
		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).
	].
	ShiftCmdActions _ cmdMap.! !
!ParseNode methodsFor: 'testing'!
isUndefTemp
	^ false!
isUnusedTemp
	^ false!
nowHasDef  "Ignored in all but VariableNode"!
nowHasRef  "Ignored in all but VariableNode"! !
!ParseNode methodsFor: 'printing'!
printCommentOn: aStream indent: indent 
	| thisComment |
	comment == nil ifTrue: [^self].
	"Show comments in green"
	aStream withAttribute: (TextColor color: Color blue) do: 
	[1 to: comment size do: 
		[:index | 
		index > 1 ifTrue: [aStream crtab: indent].
		aStream nextPut: $".
		thisComment _ comment at: index.
		self printSingleComment: thisComment
			on: aStream
			indent: indent.
		aStream nextPut: $"]].
	comment _ nil! !
!ParseNode methodsFor: 'private'!
printSingleComment: aString on: aStream indent: indent 
	"Print the comment string, assuming it has been indented indent tabs.   
	Break the string at word breaks, given the widths in the default font, at 
	450 points."

	| readStream word position lineBreak font wordWidth tabWidth spaceWidth |
	readStream _ ReadStream on: aString.
	font _ TextStyle default defaultFont.
	tabWidth _ TextConstants at: #DefaultTab.
	spaceWidth _ font widthOf: Character space.
	position _ indent * tabWidth.
	lineBreak _ 450.
	[readStream atEnd]
		whileFalse: 
			[word _ self nextWordFrom: readStream setCharacter: [:lastChar | lastChar].
			wordWidth _ 0.
			word do: [:char | wordWidth _ wordWidth + (font widthOf: char)].
			position _ position + wordWidth.
			position > lineBreak
				ifTrue: 
					[aStream crtab: indent.
					position _ indent * tabWidth + wordWidth + spaceWidth.
					lastChar = Character cr
						ifTrue: [[readStream peekFor: Character tab] whileTrue].
					aStream nextPutAll: word; space]
				ifFalse: 
					[aStream nextPutAll: word.
					readStream atEnd
						ifFalse: 
							[position _ position + spaceWidth.
							aStream space].
					lastChar = Character cr
						ifTrue: 
							[aStream crtab: indent.
							position _ indent * tabWidth.
							[readStream peekFor: Character tab] whileTrue]]]! !
!ParseNode class methodsFor: 'class initialization'!
initialize
	"ParseNode initialize. VariableNode initialize"
	LdInstType _ 1.
	LdTempType _ 2.
	LdLitType _ 3.
	LdLitIndType _ 4.
	SendType _ 5.
	CodeBases _ #(0 16 32 64 208 ).
	CodeLimits _ #(16 16 32 32 16 ).
	LdSelf _ 112.
	LdTrue _ 113.
	LdFalse _ 114.
	LdNil _ 115.
	LdMinus1 _ 116.
	LoadLong _ 128.
	Store _ 129.
	StorePop _ 130.
	ShortStoP _ 96.
	SendLong _ 131.
	DblExtDoAll _ 132.
	SendLong2 _ 134.
	LdSuper _ 133.
	Pop _ 135.
	Dup _ 136.
	LdThisContext _ 137.
	EndMethod _ 124.
	EndRemote _ 125.
	Jmp _ 144.
	Bfp _ 152.
	JmpLimit _ 8.
	JmpLong _ 164.  "code for jmp 0"
	BtpLong _ 168.
	SendPlus _ 176.
	Send _ 208.
	SendLimit _ 16! !
!Parser methodsFor: 'expression types'!
assignment: varNode
	" var '_' expression => AssignmentNode."
	| loc |
	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0
		ifTrue: [^self notify: 'Cannot store into' at: loc].
	varNode nowHasDef.
	self advance.
	self expression ifFalse: [^self expected: 'Expression'].
	parseNode _ AssignmentNode new
				variable: varNode
				value: parseNode
				from: encoder.
	^true!
blockExpression
	" [ {:var} ( | statements) ] => BlockNode."

	| argNodes |
	argNodes _ OrderedCollection new.
	[self match: #colon
	"gather any arguments"]
		whileTrue: 
			[argNodes addLast: (encoder autoBind: self argumentName)].
	(argNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not])
		ifTrue: [^self expected: 'Vertical bar'].
	self statements: argNodes innerBlock: true.
	(self match: #rightBracket)
		ifFalse: [^self expected: 'Period or right bracket'].
	argNodes do: [:arg | arg scope: -1] "Scope no longer active"!
method: doit context: ctxt 
	" pattern [ | temporaries ] block => MethodNode."

	| sap blk prim temps messageComment methodNode |
	sap _ self pattern: doit inContext: ctxt.
	"sap={selector, arguments, precedence}"
	(sap at: 2) do: [:argNode | argNode isArg: true].
	temps _ self temporaries.
	messageComment _ currentComment.
	currentComment _ nil.
	prim _ doit ifTrue: [0] ifFalse: [self primitive].
	self statements: #() innerBlock: doit.
	blk _ parseNode.
	doit ifTrue: [blk returnLast]
		ifFalse: [blk returnSelfIfNoOther].
	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].
	self interactive ifTrue: [self removeUnusedTemps].
	methodNode _ MethodNode new comment: messageComment.
	^methodNode
		selector: (sap at: 1)
		arguments: (sap at: 2)
		precedence: (sap at: 3)
		temporaries: temps
		block: blk
		encoder: encoder
		primitive: prim!
pattern: fromDoit inContext: ctxt 
	" unarySelector | binarySelector arg | keyword arg {keyword arg} => 
	{selector, arguments, precedence}."

	| args selector |
	fromDoit 
		ifTrue: 
			[ctxt == nil
				ifTrue: [^Array with: #DoIt with: #() with: 1]
				ifFalse: [^Array 
							with: #DoItIn: 
							with: (Array 
									with: (encoder encodeVariable: 'homeContext')) 
									with: 3]].
	hereType == #word 
		ifTrue: [^Array with: self advance asSymbol with: #() with: 1].
	(hereType == #binary or: [hereType == #verticalBar])
		ifTrue: 
			[selector _ self advance asSymbol.
			args _ Array with: (encoder bindArg: self argumentName).
			^Array with: selector with: args with: 2].
	hereType == #keyword
		ifTrue: 
			[selector _ WriteStream on: (String new: 32).
			args _ OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[selector nextPutAll: self advance.
					args addLast: (encoder bindArg: self argumentName)].
			^Array with: selector contents asSymbol with: args with: 3].
	^self expected: 'Message pattern'!
primaryExpression 
	hereType == #word 
		ifTrue: 
			[parseNode _ self variable.
			(parseNode isUndefTemp and: [self interactive])
				ifTrue: [self queryUndefined].
			parseNode nowHasRef.
			^ true].
	hereType == #leftBracket
		ifTrue: 
			[self advance.
			self blockExpression.
			^true].
	hereType == #leftBrace
		ifTrue: 
			[self braceExpression.
			^true].
	hereType == #leftParenthesis
		ifTrue: 
			[self advance.
			self expression ifFalse: [^self expected: 'expression'].
			(self match: #rightParenthesis)
				ifFalse: [^self expected: 'right parenthesis'].
			^true].
	(hereType == #string or: [hereType == #number or: [hereType == #literal]])
		ifTrue: 
			[parseNode _ encoder encodeLiteral: self advance.
			^true].
	(here == #- and: [tokenType == #number])
		ifTrue: 
			[self advance.
			parseNode _ encoder encodeLiteral: self advance negated.
			^true].
	^false! !
!Parser methodsFor: 'temps'!
bindArg: name

	^ self bindTemp: name! !
!Parser methodsFor: 'error correction'!
correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| alternatives aStream choice correctSelector userSelection lines firstLine |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].

	userSelection _ requestor selectionInterval.
	requestor selectFrom: spots first first to: spots last last.
	requestor select.
	alternatives _ tryHard
		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]
		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].

	aStream _ WriteStream on: (String new: 200).
	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.
	firstLine _ 1.
 	alternatives do:
		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].
	aStream nextPutAll: 'cancel'.
	lines _ Array with: firstLine with: (alternatives size + firstLine).
	tryHard ifFalse:
		[aStream cr; nextPutAll: 'try harder'.
		lines _ lines copyWith: (alternatives size + firstLine + 1)].
	
	choice _ (PopUpMenu labels: aStream contents lines: lines)
		startUpWithCaption: 
'Unknown selector, please 
confirm, correct, or cancel'.

	tryHard not & (choice > lines last) ifTrue:
		[^ self correctSelector: proposedKeyword wordIntervals: spots
				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 

	(choice = 0) | (choice > (lines at: 2))
		ifTrue: [ ^ abortAction value ].

	requestor deselect.
	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].
	correctSelector _ alternatives at: choice - 1.
	self substituteSelector: correctSelector keywords wordIntervals: spots.
	^ correctSelector.
!
queryUndefined
	| varStart varName | 
	varName _ parseNode key.
	varStart _ self endOfLastToken + requestorOffset - varName size + 1.
	requestor selectFrom: varStart to: varStart + varName size - 1; select.
	((PopUpMenu labels:
'yes
no') startUpWithCaption:
		((varName , ' appears to be
undefined at this point.
Proceed anyway?') asText makeBoldFrom: 1 to: varName size))
		= 1 ifFalse: [^ self fail]!
removeUnusedTemps 
	| str end start | 
	str _ requestor text string.
	((tempsMark between: 1 and: str size)
		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].
	encoder unusedTempNames do:
		[:temp |
		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:
			((temp , ' appears to be
unused in this method.
OK to remove it?') asText makeBoldFrom: 1 to: temp size))
			= 1
		ifTrue:
		[(encoder encodeVariable: temp) isUndefTemp
			ifTrue:
			[end _ tempsMark.
			["Beginning at right temp marker..."
			start _ end - temp size + 1.
			end < temp size or: [temp = (str copyFrom: start to: end)
								and: [(str at: start-1) isSeparator]]]
			whileFalse:
				["Search left for the unused temp"
				end _ requestor nextTokenFrom: end direction: -1].
			end < temp size ifFalse:
				[(str at: start-1) = $  ifTrue: [start _ start-1].
				requestor correctFrom: start to: end with: ''.
				tempsMark _ tempsMark - (end-start+1)]]
			ifFalse:
			[PopUpMenu notify:
'You''ll first have to remove the
statement where it''s stored into']]]! !
!PluckedSound methodsFor: 'sound generation'!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan
	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. It may be out of tune for higher pitches because the buffer length must be an integral number of samples and the nearest integer may not result in the exact pitch desired."
	"(PluckedSound pitch: 220.0 dur: 3.0 loudness: 1000) play"

	| lastIndex thisIndex nextIndex mySample channelIndex sample |
	<primitive: 178>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #ring declareC: 'short int *ring'.

	lastIndex _ (startIndex + n) - 1.
	thisIndex _ ringIndx.
	startIndex to: lastIndex do: [ :i |
		nextIndex _ (thisIndex \\ ringSize) + 1.
		mySample _ ((ring at: thisIndex) + (ring at: nextIndex)) // 2.
		ring at: thisIndex put: mySample.
		thisIndex _ nextIndex.

		pan > 0 ifTrue: [
			channelIndex _ 2 * i.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].
		pan < 1000 ifTrue: [
			channelIndex _ (2 * i) - 1.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].
	].
	ringIndx _ nextIndex.
	count _ count - n.
! !
!PluggableListController methodsFor: 'all'!
changeModelSelection: anInteger
	"Let the view handle this."

	view changeModelSelection: anInteger.!
controlActivity
	"Overridden to handle keystrokes."

	sensor keyboardPressed ifTrue: [view handleKeystroke: sensor keyboard].
	super controlActivity.!
yellowButtonActivity
	"Invoke the model's menu."

	| menu |
	menu _ view getMenu.
	menu == nil ifFalse: [menu invokeOn: model].! !
!PluggableListView methodsFor: 'initialization'!
list: arrayOfStrings
	"Set the receivers items to be the given list of strings."
	"Note: the instance variable 'itemsList' holds the original list.
	 The instance variable 'items' is a paragraph constructed from
	 this list."

	| s |
	items _ arrayOfStrings.
	isEmpty _ arrayOfStrings isEmpty.

	s _ WriteStream on: Array new.
	"add top and bottom delimiters"
	s nextPut: topDelimiter.
	arrayOfStrings do: [:item |
		item == nil ifFalse: [s nextPut: item].
	].
	s nextPut: bottomDelimiter.
	list _ ListParagraph withArray: s contents.

	selection _ self getCurrentSelectionIndex.
	self positionList.!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel

	self model: anObject.
	getListSelector _ getListSel.
	getSelectionSelector _ getSelectionSel.
	setSelectionSelector _ setSelectionSel.
	getMenuSelector _ getMenuSel.
	keystrokeActionSelector _ keyActionSel.
	self borderWidth: 1.
	self list: self getList.! !
!PluggableListView methodsFor: 'model access'!
changeModelSelection: anInteger
	"Change the model's selected item to be the one at the given index."

	| item |
	setSelectionSelector ~~ nil ifTrue: [
		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [items at: anInteger]).
		model perform: setSelectionSelector with: item.
		getSelectionSelector == nil ifFalse: [model perform: getSelectionSelector].
	].!
getCurrentSelectionIndex
	"Answer the index of the current selection."

	| item |
	getSelectionSelector == nil ifTrue: [^ 0].
	item _ model perform: getSelectionSelector.
	^ items findFirst: [ :x | x = item]
!
getList 
	"Answer the list to be displayed."

	| lst |
	getListSelector == nil ifTrue: [^ #()].
	lst _ model perform: getListSelector.
	lst == nil ifTrue: [^ #()].
	^ lst!
getMenu
	"Answer the menu for this list view."

	getMenuSelector == nil ifTrue: [^ nil].
	^ model perform: getMenuSelector!
handleKeystroke: aCharacter
	"Answer the menu for this list view."

	keystrokeActionSelector == nil ifTrue: [^ nil].
	model perform: keystrokeActionSelector with: aCharacter.! !
!PluggableListView methodsFor: 'controller access'!
defaultControllerClass 

	^ PluggableListController! !
!PluggableListView methodsFor: 'updating'!
update: aSymbol 
	"Refer to the comment in View|update:."

	| oldIndex newIndex |
	aSymbol == getListSelector ifTrue: [
		oldIndex _ self getCurrentSelectionIndex.
		self list: self getList.
		newIndex _ self getCurrentSelectionIndex.
		(oldIndex > 0 and: [newIndex = 0]) ifTrue: [
			"new list did not include the old selection; deselecting"
			self changeModelSelection: newIndex].
		self displayView.
		self displaySelectionBox.
		^self].
	aSymbol == getSelectionSelector ifTrue: [
		self moveSelectionBox: self getCurrentSelectionIndex.
		^self].
! !
!PluggableListView class methodsFor: 'as yet unclassified'!
aboutPluggability
	"A pluggable list view gets its content from the model. This allows the same kind of view can be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:

		getListSel		fetch the list of items (strings) to be displayed
		getSelectionSel	get the currently selected item
		setSelectionSel	set the currently selected item (takes an argument)
		getMenuSel		get the pane-specific (or 'yellow-button') menu
		keyActionSel	process keystrokes typed to this view (takes an argument)

	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default, do-nothing behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!! (Such behavior can actually be useful during debugging.)

	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.

	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song."!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."

	^ self new
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: nil
		keystroke: nil
!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."

	^ self new
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: getMenuSel
		keystroke: nil
!
on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel
	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."

	^ self new
		on: anObject
		list: getListSel
		selected: getSelectionSel
		changeSelected: setSelectionSel
		menu: getMenuSel
		keystroke: keyActionSel
! !
!PluggableTest methodsFor: 'initialization'!
initialize

	list1 _ #('reggae' 'early' 'classical').
	list2 _ #('marley' 'alpha blondy' 'burning spear' 'ziggy').! !
!PluggableTest methodsFor: 'artist pane'!
artist

	^ selection2!
artist: aString

	selection2 _ aString.
	self changed: #artist.!
artistKeystroke: aCharacter

	list2 do: [ :artist |
		(artist first asLowercase = aCharacter asLowercase) ifTrue: [
			self artist: artist]].!
artists

	selection1 = 'reggae' ifTrue: [^ list2].
	selection1 = 'early' ifFalse: [^ #('ziggy' 'marley')].
	^ #()! !
!PluggableTest methodsFor: 'music type pane'!
musicType

	^ selection1!
musicType: aString

	selection1 _ aString.
	self changed: #musicType.
	self changed: #artists.!
musicTypeKeystroke: aCharacter

	list1 do: [ :type |
		(type first asLowercase = aCharacter asLowercase) ifTrue: [
			self musicType: type]].!
musicTypeMenu

	^ SelectionMenu
		labels: 'reggae\grunge\flash' withCRs
		lines: #(2)
		selections: #(reggaeCmd grungeCmd flashCmd)!
musicTypes

	^ list1! !
!PluggableTest methodsFor: 'menu commands'!
flashCmd

	Display reverse; reverse.!
grungeCmd

	SelectionMenu confirm:
		'You mean, like those strange bands from Seattle?'!
reggaeCmd

	self musicType: 'reggae'.! !
!PluggableTest class methodsFor: 'as yet unclassified'!
open
	"PluggableTest open"

	| model listView1 topView listView2 |
	model _ self new initialize.
	listView1 _
		PluggableListView on: model
			list: #musicTypes
			selected: #musicType
			changeSelected: #musicType:
			menu: #musicTypeMenu
			keystroke: #musicTypeKeystroke:.

	listView2 _
		PluggableListView on: model
			list: #artists
			selected: #artist
			changeSelected: #artist:
			menu: nil
			keystroke: #artistKeystroke:.

	topView _ StandardSystemView new
		label: 'Pluggable Test';
		minimumSize: 300@200;
		borderWidth: 1;
		addSubView: listView1;
		addSubView: listView2 toRightOf: listView1.
	topView controller open.! !
!PopUpMenu methodsFor: 'displaying'!
displayAt: aPoint withCaption: captionOrNil during: aBlock
	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."
	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |
	frame _ frame align: marker leftCenter with: aPoint + (2@0).
	outerFrame _ frame.
	captionOrNil notNil ifTrue:
		[captionText _ DisplayText
				text: captionOrNil asText
				textStyle: TextStyle default copy centered.
		tFrame _ captionText boundingBox insetBy: -2.
		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter
					with: frame topCenter + (0@2))].
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	frame moveBy: delta.
	captionOrNil notNil ifTrue:
		[captionView _ DisplayTextView new model: captionText.
		captionView align: captionView boundingBox bottomCenter
					with: frame topCenter + (0@2).
		captionView insideColor: Display white.
		captionView borderWidth: 2.
		captionSave _ Form fromDisplay: captionView displayBox.
		captionView unlock; display; release].
	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).
	savedArea _ Form fromDisplay: frame.
	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).
	selection ~= 0 ifTrue: [Display reverse: marker].
	Cursor normal showWhile: [aBlock value].
	savedArea displayOn: Display at: frameSaveLoc.
	captionOrNil notNil ifTrue:
		[captionSave displayOn: Display at: captionView displayBox topLeft]! !
!PopUpMenu methodsFor: 'marker adjustment'!
manageMarker
	"If the cursor is inside the receiver's frame, then highlight the marked 
	item. Otherwise no item is to be marked."
	| pt |
	"Don't let pt get far from display box, so scrolling will go all the way"
	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).
	(frame inside containsPoint: pt)
		ifTrue: ["Need to cache the form for reasonable scrolling performance"
				(Display boundingBox containsPoint: pt)
					ifTrue: [CacheMenuForms ifFalse: [form _ nil]]
					ifFalse: [form == nil ifTrue: [form _ self computeForm].
							pt _ pt - (self scrollIntoView: pt)].
				self markerOn: pt]
		ifFalse: [self markerOff]!
scrollIntoView: cursorLoc
	| dy |
	dy _ 0.
	cursorLoc y < 0 ifTrue: [dy _ font height].
	cursorLoc y > Display height ifTrue: [dy _ font height negated].
	dy = 0 ifTrue: [^ 0@0].
	self markerOff.
	frame moveBy: 0@dy.
	marker moveBy: 0@dy.
	self menuForm displayOn: Display at: frame topLeft.
	^ 0@dy! !
!PopUpMenu methodsFor: 'private'!
computeForm
	"Compute and answer a Form to be displayed for this menu."

	| borderInset paraForm menuForm |
	borderInset _ 2@2.
	paraForm _ self computeLabelParagraph asForm.
	menuForm _ Form extent: paraForm extent + (borderInset * 2).
	menuForm fillBlack.
	paraForm displayOn: menuForm at: borderInset.
	lineArray == nil ifFalse: [
		lineArray do: [ :line |
			menuForm fillBlack:
				(0 @ ((line * font height) + borderInset y) extent: (menuForm width @ 1)).
		].
	].
	^ menuForm
!
computeLabelParagraph
	"Answer a Paragraph containing this menu's labels, one per line and centered."

	^ Paragraph withText: labelString asText style: MenuStyle!
labels: aString font: aFont lines: anArray

	| style inside |
	labelString _ aString.
	font _ aFont.
	lineArray _ anArray.
	frame _ Quadrangle new.
	frame region: self menuForm boundingBox.
	frame borderWidth: 2.
	inside _ frame inside.
	marker _ inside topLeft extent: (inside width @ self computeLabelParagraph lineGrid).
	selection _ 1.!
menuForm
	"Answer a Form to be displayed for this menu."
	"Details: On slower systems, cache the menu Form for speed."

	form == nil ifFalse: [^ form].
	CacheMenuForms
		ifTrue: [^ form _ self computeForm]
		ifFalse: [^ self computeForm]!
rescan
	"Cause my form to be recomputed after a font change."

	labelString == nil ifTrue: [labelString _ 'NoText!!'].
	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.
	form _ nil.

	"PopUpMenu withAllSubclasses do: [ :menuClass |
		menuClass allInstancesDo: [ :m | m rescan ]]"! !
!PopUpMenu class methodsFor: 'instance creation'!
labels: aString lines: anArray
	"Answer an instance of me whose items are in aString, with lines drawn 
	after each item indexed by anArray."

	^self new
		labels: aString
		font: (MenuStyle fontAt: 1)
		lines: anArray! !
!PopUpMenu class methodsFor: 'class initialization'!
initialize  "PopUpMenu initialize"
	"Change CacheMenuForms to true to get faster popup menus on slower systems."
	"CacheMenuForms _ true"

	CacheMenuForms _ false.
	(MenuStyle _ TextStyle default copy)
		gridForFont: 1 withLead: 0;
		centered.
	PopUpMenu withAllSubclasses do:
		[:menuClass | menuClass allInstancesDo:
			[:m | m rescan]]
! !
!PositionableStream methodsFor: 'accessing'!
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	| newStream el |
	newStream _ WriteStream on: (collection species new: 100).
	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].
	^ newStream contents! !
!PositionableStream methodsFor: 'fileIn/Out'!
nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."

	| terminator out ch |
	terminator _ $!!.
	out _ WriteStream on: (String new: 1000).
	self skipSeparators.
	[(ch _ self next) == nil] whileFalse: [
		(ch == terminator) ifTrue: [
			self peek == terminator ifTrue: [
				self next.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents! !

Preferences comment:
'A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  It is also possible to store non-boolean data in the preference table.  sw 8/91'!
!Preferences class methodsFor: 'hard-coded prefs'!
startAllWindowTicking
	"Execute this to set the system to start the ticking of inactive windows"
	"Preferences startAllWindowTicking"

	Preferences class compile:
'letInactiveWindowsTick
	"Set to true if you want inactive windows to tick in HyperSqueak"

	^ true' classified: 'HyperSqueak'!
startCollisionDetection
	"Execute this to set the system to start collision detection"
	"Preferences startLoggingUserScripts"

	Preferences class compile:
'collisionDetection
	"Set to true if you want collision detection to take place automatically in HyperSqueak"

	^ true' classified: 'HyperSqueak'!
startLoggingUserScripts
	"Execute this to set the system to start logging user scripts to the changes log.  7/18/96 sw"
	"Preferences startLoggingUserScripts"

	Preferences class compile:
'logUserScripts
	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"

	^ true' classified: 'HyperSqueak'!
stopAllWindowTicking
	"Execute this to set the system to stop the ticking of inactive windows"
	"Preferences stopAllWindowTicking"

	Preferences class compile:
'letInactiveWindowsTick
	"Set to true if you want inactive windows to tick in HyperSqueak"

	^ false' classified: 'HyperSqueak'!
stopCollisionDetection
	"Execute this to set the system to stop collision detection"
	"Preferences startLoggingUserScripts"

	Preferences class compile:
'collisionDetection
	"Set to true if you want automatic collision detection to take place"

	^ false' classified: 'HyperSqueak'!
stopLoggingUserScripts
	"Execute this to set the system to stop logging user scripts to the changes log.  7/18/96 sw"
	"Preferences stopLoggingUserScripts"

	Preferences class compile:
'logUserScripts
	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"

	^ false' classified: 'HyperSqueak'! !
!Preferences class methodsFor: 'general'!
chooseInitialSettings
	"Set up the initial choices for Preferences.  2/7/96 sw
	 5/2/96 sw: added init for uniformWindowColors
	 5/22/96 sw: init reverseWindowStagger, clear out old window parms"

	"Preferences chooseInitialSettings"

	self setPreference: #uniformWindowColors toValue: false.
	self setPreference: #reverseWindowStagger toValue: true.
	self setPreference: #programmerMode toValue: false.
	AutoAccessors _ false.
	BrowserAutoSelect _ false.
!
initialize
	"5/22/96 sw: Included within a 22 May96 fileout to trigger reinitialization"

	FlagDictionary _ Dictionary new.
	self chooseInitialSettings.

	"Preferences initialize"! !
!Preferences class methodsFor: 'HyperSqueak'!
collisionDetection
	"Set to true if you want automatic collision detection to take place"

	^ false!
letInactiveWindowsTick
	"Set to true if you want inactive windows to tick in HyperSqueak"

	^ true! !
!Preferences class methodsFor: 'ui prefs'!
autoAccessors
	"Answer the preference; change by: Preferences classPool inspect"
	
	^ AutoAccessors!
browserAutoSelect
	"Answer the preference; change by: Preferences classPool inspect"
	
	^ BrowserAutoSelect!
desktopColor
	"Answer the desktop color.  Initialize it if it's never been done.  11/26/96 sw"
	
	DesktopColor == nil ifTrue:
		[DesktopColor _ Color gray].
	^ DesktopColor!
desktopColor: aColor
	"Set the desktop color"

	DesktopColor _ aColor! !
!Project methodsFor: 'release'!
okToChange

	^ self confirm:
'Are you sure you have saved
all changes that you care about
in ', self name printString.! !
!ProjectView methodsFor: 'displaying'!
displayView
	| scale rect topLeft ibox |
	super displayView.
	self label = model name
		ifFalse: [super relabel: model name].
	self isCollapsed ifTrue: [^ self].
	Display fill: (ibox _ self insetDisplayBox) fillColor: Color lightGray.
	scale _ ibox extent / Display extent.
	topLeft _ ibox topLeft.
	model views reverseDo:
		[:v | rect _ ((v displayBox scaleBy: scale) rounded
				translateBy: topLeft) intersect: ibox.
		Display fill: rect fillColor: v backgroundColor;
			border: rect width: 1;
			border: (rect topLeft extent: rect width@3) width: 1.
		]! !

ProtocolBrowser comment:
'An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.'!
!ProtocolBrowser methodsFor: 'accessing'!
classDictionary
        "Answer the receiver's class dictionary."

        ^classDictionary!
classDictionary: aDictionary
        "Set the receiver's class dictionary to be the argument."

        classDictionary := aDictionary!
getList
        "Answer the receiver's message list."

        ^messageList!
list
        "Answer the receiver's message list."

        ^messageList!
selectedClass
        "Answer the receiver's selected class."

        ^selectedClass!
selectedClass: aClass
        "Set the receiver's selected class to be the argument."

        selectedClass := aClass!
selector
        "Answer the receiver's selected selector."

        ^selectedSelector!
selector: aString
        "Set the currently selected message selector to be aString."

        selectedSelector := aString.
        self changed: #selector!
selectorList
        "Answer the receiver's message list."

        ^messageList!
selectorList: aList
        "Set the receiver's message list to the argument."

        messageList := aList!
setSelector: aString
        "Set the currently selected message selector to be aString."

        selectedSelector := aString! !
!ProtocolBrowser methodsFor: 'private'!
on: aClass 
        "Create the protocol browser for the class, a Class."

        | defClass |
        baseClass := aClass.
        self selectorList: OrderedCollection new.
        self classDictionary: IdentityDictionary new.
        aClass allSelectors asSortedCollection do: 
                [ :selector | 
                        defClass := aClass whichClassIncludesSelector: selector.
                        defClass == self class
                                ifTrue:[self selectorList add: selector asText, '       (' , defClass name asText allBold , ')']
                                ifFalse:[self selectorList add: selector, '     (' , defClass name , ')'].
                        self classDictionary add: (Association key: selector value: defClass)]!
onSubProtocolOf: aClass 
        "Create the protocol browser for the class, a Class."

        | defClass aSet aCollection |
        baseClass := aClass.
        messageList := OrderedCollection new.
        classDictionary := IdentityDictionary new.
        selectedClass := aClass.
        aSet := Set new.
        aCollection := aClass withAllSuperclasses.
        aCollection remove: Object.
        aCollection do: [:each | aSet addAll: each selectors].
        aSet asSortedCollection do: 
                [ :selector | 
                defClass := aClass whichClassIncludesSelector: selector.
                defClass == self selectedClass
                        ifTrue:[self selectorList add: selector asText, '       (' , defClass name asText allBold , ')']
                        ifFalse:[self selectorList add: selector, '     (' , defClass name , ')'].
                self classDictionary add: (Association key: selector value: defClass)]!
parse: messageString toClassAndSelector: csBlock
        "Decode strings of the form <className> [class] <selectorName>."
        | tuple cl |
        tuple _ messageString string findTokens: '      '.
        cl _ tuple at: 2.
        cl _ (cl copyFrom: 2 to: cl size - 1) asSymbol.
        cl _ Smalltalk at: cl.
        self selectedClass: cl.
        self setSelector: tuple first.
        tuple size = 2
                ifTrue: [^ csBlock value: cl value: tuple first asSymbol]
                ifFalse: [^ csBlock value: cl class value: tuple first asSymbol]!
setClassAndSelectorIn: csBlock
        "Decode strings of the form <className> [class] <selectorName>."
        ^ self parse: self selection toClassAndSelector: csBlock! !
!ProtocolBrowser class methodsFor: 'instance creation'!
openForClass: aClass 
        "Create and schedule a browser for the protocol of the class."
        "ProtocolBrowser openForClass: ProtocolBrowser."

        ^self openSubProtocolForClass: aClass!
openFullProtocolForClass: aClass 
        "Create and schedule a browser for the entire protocol of the class."
        "ProtocolBrowser openForClass: ProtocolBrowser."

        | aPBrowser label |
        aPBrowser := ProtocolBrowser new on: aClass.
        label := 'Entire protocol of: ', aClass name.
        self open: aPBrowser name: label!
openSubProtocolForClass: aClass 
        "Create and schedule a browser for the entire protocol of the class."
        "ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."

        | aPBrowser label |
        aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.
        label := 'Sub-protocol of: ', aClass name.
        self open: aPBrowser name: label! !
!RealEstateAgent class methodsFor: 'as yet unclassified'!
assignCollapsePointFor: aSSView
	"Offer up a location along the left edge of the screen for a collapsed SSView.
	Make sure it doesn't overlap any other collapsed frames.
	10/24/96 di"
	| grid extent allOthers y putativeFrame free |
	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"
	extent _ aSSView labelDisplayBox extent.
	allOthers _ ScheduledControllers scheduledWindowControllers
				collect: [:aController | aController view collapsedFrame]
				thenSelect: [:rect | rect notNil].
	y _ 0.
	[(y _ y + grid) < (Display height - extent y)]
		whileTrue:
		[putativeFrame _ 0@y extent: extent.
		free _ true.
		allOthers do: [:w | free _ free & (w intersects: putativeFrame) not].
		free ifTrue: [^ putativeFrame topLeft]].
	"If all else fails..."
	^ 0 @ 0!
standardPositions
	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  5/22/96 sw"

	| anArea aList  midX midY |

	anArea _ Display usableArea.

	midX _ ScrollBarSetback +   ((anArea width - ScrollBarSetback)  // 2).
	midY _ ScreenTopSetback + ((anArea height - ScreenTopSetback) // 2).
	aList _ OrderedCollection with: (ScrollBarSetback @ ScreenTopSetback).
	self windowColumnsDesired > 1
		ifTrue:
			[aList add: (midX @ ScreenTopSetback)].
	self windowRowsDesired > 1
		ifTrue:
			[aList add: (ScrollBarSetback @ (midY+ScreenTopSetback)).
			self windowColumnsDesired > 1 ifTrue:
				[aList add: (midX @ (midY+ScreenTopSetback))]].
	^ aList!
standardWindowExtent
	"Answer the standard default extent for new windows.  5/23/96 sw"

	| effectiveExtent width strips height grid allowedArea maxLevel |
	effectiveExtent _ Display usableArea extent - (ScrollBarSetback @ ScreenTopSetback).
	Preferences reverseWindowStagger ifTrue:
		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"
		allowedArea _ ScrollBarSetback @ ScreenTopSetback
						corner: Display usableArea bottomRight.
		"Number to be staggered at each corner (less on small screens)"
		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
		"Amount by which to stagger (less on small screens)"
		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].
	width _ (strips _ self windowColumnsDesired) > 1
		ifTrue:
			[effectiveExtent x // strips]
		ifFalse:
			[(3 * effectiveExtent x) // 4].
	height _ (strips _ self windowRowsDesired) > 1
		ifTrue:
			[effectiveExtent y // strips]
		ifFalse:
			[(3 * effectiveExtent y) //4].
	^ width @ height

"RealEstateAgent standardWindowExtent"!
strictlyStaggeredInitialFrameFor: aStandardSystemView
	"This method implements a staggered window placement policy that I like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible.
	10/24/96 di"
	| allowedArea grid initialFrame allWindows cornerSel corner delta putativeCorner free maxLevel |
	allowedArea _ ScrollBarSetback @ ScreenTopSetback
					corner: Display usableArea bottomRight.
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent
							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400")).
	allWindows _ ScheduledControllers scheduledWindowControllers
				collect: [:aController | aController view isCollapsed
								ifTrue: [aController view expandedFrame]
								ifFalse: [aController view displayBox]].
	0 to: maxLevel do:
		[:level | 
		1 to: 4 do:
			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.
			corner _ allowedArea perform: cornerSel.
			"The extra grid//2 in delta helps to keep title tabs distinct"
			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).
			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"
			putativeCorner _ corner + delta.
			free _ true.
			allWindows do:
				[:w |
				free _ free & ((w perform: cornerSel) ~= putativeCorner)].
			free ifTrue:
				[^ (initialFrame align: (initialFrame perform: cornerSel)
								with: putativeCorner)
						 squishedWithin: allowedArea]]].
	"If all else fails..."
	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)
		squishedWithin: allowedArea! !
!Rectangle methodsFor: 'rectangle functions'!
areasOutside: aRectangle
	"Answer an Array of Rectangles comprising the parts of the receiver not 
	intersecting aRectangle."

	| areas yOrigin yCorner |
	"Make sure the intersection is non-empty"
	(origin <= aRectangle corner and: [aRectangle origin <= corner])
		ifFalse: [^Array with: self].
	areas _ OrderedCollection new.
	aRectangle origin y > origin y
		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]
		ifFalse: [yOrigin _ origin y].
	aRectangle corner y < corner y
		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]
		ifFalse: [yCorner _ corner y].
	aRectangle origin x > origin x 
		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].
	aRectangle corner x < corner x 
		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].
	^areas!
bordersOn: her along: herSide 
	(herSide = #right and: [self left = her right])
	| (herSide = #left and: [self right = her left])
		ifTrue:
		[^ (self top max: her top) <= (self bottom min: her bottom)].
	(herSide = #bottom and: [self top = her bottom])
	| (herSide = #top and: [self bottom = her top])
		ifTrue:
		[^ (self left max: her left) <= (self right min: her right)].
	^ false!
withBottom: y 
	"Return a copy of me with a different bottom y"
	^ origin x @ origin y corner: corner x @ y!
withLeft: x 
	"Return a copy of me with a different left x"
	^ x @ origin y corner: corner x @ corner y!
withRight: x 
	"Return a copy of me with a different right x"
	^ origin x @ origin y corner: x @ corner y!
withSide: side setTo: value  "return a copy with side set to value"
	^ self perform: (#(withLeft: withRight: withTop: withBottom: )
							at: (#(left right top bottom) indexOf: side))
		with: value!
withTop: y 
	"Return a copy of me with a different top y"
	^ origin x @ y corner: corner x @ corner y! !
!ReturnNode methodsFor: 'C translation'!
asTranslatorNode
	^TReturnNode new setExpression: expr asTranslatorNode! !
!RunArray methodsFor: 'accessing'!
at: index

	self at: index setRunOffsetAndValue: [:run :offset :value | ^value]!
runLengthAt: index 
	"Answer the length remaining in run beginning at index."

	self at: index 
		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !
!RunArray methodsFor: 'copying'!
copyFrom: start to: stop
	| newRuns |
	stop < start ifTrue: [^RunArray new].
	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].
	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].
	run1 = run2
		ifTrue: 
			[newRuns _ Array with: offset2 - offset1 + 1]
		ifFalse: 
			[newRuns _ runs copyFrom: run1 to: run2.
			newRuns at: 1 put: (newRuns at: 1) - offset1.
			newRuns at: newRuns size put: offset2 + 1].
	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !
!RunArray methodsFor: 'printing'!
printOn: aStream
	aStream nextPutAll: self class name.
	aStream nextPutAll: ' runs: '.
	runs printOn: aStream.
	aStream nextPutAll: ' values: '.
	values printOn: aStream.
! !
!RunArray methodsFor: 'private'!
mapValues: mapBlock
	"NOTE: only meaningful to an entire set of runs"
	values _ values collect: [:val | mapBlock value: val]! !
!Scanner methodsFor: 'multi-character scans'!
xColon		"Allow := for assignment by converting to #_ "
	aheadChar = $= ifTrue:
		[self step.
		tokenType _ #leftArrow.
		self step.
		^ token _ #_].
	"Otherwise, just do what normal scan of colon would do"
	tokenType _ #colon.
	^ token _ self step asSymbol!
xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]
		whileTrue:
			["open code step for speed"
			buffer nextPut: hereChar.
			hereChar _ aheadChar.
			source atEnd
				ifTrue: [aheadChar _ 30 asCharacter "doit"]
				ifFalse: [aheadChar _ source next]].
	(type == #colon or: [type = #xColon and: [aheadChar ~= $=]])
		ifTrue: 
			[buffer nextPut: self step.
			tokenType _ #keyword]
		ifFalse: 
			[tokenType _ #word].
	token _ buffer contents! !
!Scanner class methodsFor: 'class initialization'!
initialize
	| newTable |
	newTable _ Array new: 256 withAll: #xBinary. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.
	newTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.
	newTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.
	newTable at: 30 put: #doIt.
	newTable at: $" asciiValue put: #xDoubleQuote.
	newTable at: $# asciiValue put: #xLitQuote.
	newTable at: $$ asciiValue put: #xDollar.
	newTable at: $' asciiValue put: #xSingleQuote.
	newTable at: $: asciiValue put: #xColon.
	newTable at: $( asciiValue put: #leftParenthesis.
	newTable at: $) asciiValue put: #rightParenthesis.
	newTable at: $. asciiValue put: #period.
	newTable at: $; asciiValue put: #semicolon.
	newTable at: $[ asciiValue put: #leftBracket.
	newTable at: $] asciiValue put: #rightBracket.
	newTable at: ${ asciiValue put: #leftBrace.
	newTable at: $} asciiValue put: #rightBrace.
	newTable at: $^ asciiValue put: #upArrow.
	newTable at: $_ asciiValue put: #leftArrow.
	newTable at: $| asciiValue put: #verticalBar.
	TypeTable _ newTable "bon voyage!!"

	"Scanner initialize"! !
!Scanner class methodsFor: 'testing'!
isLiteralSymbol: aSymbol 
	"Test whether a symbol can be stored as # followed by its characters.  
	Symbols created internally with asSymbol may not have this property, 
	e.g. '3' asSymbol."
	| i ascii type |
	i _ aSymbol size.
	i = 0 ifTrue: [^ false].
	i = 1 ifTrue: [('$''"()' includes: (aSymbol at: 1)) ifTrue: [^ false] ifFalse: [^ true]].
	ascii _ (aSymbol at: 1) asciiValue.
	"TypeTable should have been origined at 0 rather than 1 ..."
	ascii = 0 ifTrue: [^ false].
	type _ TypeTable at: ascii.
	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].
	type == #xBinary ifTrue: 
			[[i > 1]
				whileTrue: 
					[ascii _ (aSymbol at: i) asciiValue.
					ascii = 0 ifTrue: [^ false].
					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].
					i _ i - 1].
			^ true].
	type == #xLetter ifTrue: 
			[[i > 1]
				whileTrue: 
					[ascii _ (aSymbol at: i) asciiValue.
					ascii = 0 ifTrue: [^ false].
					type _ TypeTable at: ascii.
					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])
						ifFalse: [^ false].
					i _ i - 1].
			^ true].
	^ false! !
!ScreenController methodsFor: 'menu messages'!
changeWindowPolicy
	Preferences setPreference: #reverseWindowStagger
		toValue: (Preferences valueOfFlag: #reverseWindowStagger) not!
fastWindows
	StandardSystemView cachingBits
		ifTrue: [StandardSystemView dontCacheBits]
		ifFalse: [StandardSystemView doCacheBits]!
setDesktopColor
	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   11/26/96 sw"

	Preferences desktopColor: Color fromUser.
	ScheduledControllers updateGray; restore! !
!ScreenController methodsFor: 'nested menus'!
changesMenu
	"Answer a menu for changes-related items.  2/4/96 sw
	 5/8/96 sw: divided changelist options into two
	 5/17/96 sw: added browse recent submissions"

	ChangesMenu == nil ifTrue: 
		[ChangesMenu _ SelectionMenu labelList:
		#(	'file out changes'
			'browse changed methods'
			'browse recent submissions'
			'recent change log')
		lines: #(1 3)
		selections: #(fileOutChanges browseChangedMessages browseRecentSubmissions browseRecentLog)].

	^ ChangesMenu

"
ScreenController new changesMenu startUp
"!
helpMenu
	"Answer the help menu to be put up as a screen submenu.  7/24/96 sw
	 11/26/96 sw: added set desktop color"

	HelpMenu == nil ifTrue:
		[HelpMenu _ SelectionMenu labelList:
		#(	'preferences...'
			'about this system...'
			'command-key help'
			'useful expressions'
			'set author initials...'
			'set desktop color...'
			'view GIF imports'
			'space left'
				)
		lines: #(1 4 6)
		selections: #(editPreferences  aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor viewGIFImports garbageCollect)].
	^ HelpMenu

"
ScreenController new helpMenu startUp
ScreenController initialize
"!
openMenu
	"Answer a menu for open-related items.  2/4/96 sw
	 5/10/96 sw: useful expressions moved to help menu"

	OpenMenu == nil ifTrue:
		[OpenMenu _ SelectionMenu labelList:
		#(	'open browser'
			'open workspace'
			'open file list'
			'open change sorter'
			'open project'
			'open transcript'
			'open system workspace')
		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject openTranscript  openSystemWorkspace)].
	^ OpenMenu

"
ScreenController new openMenu startUp
"!
topScreenMenu
	"Answer the screen menu for the top project, from whence there is no relevance to the 'exit project' item.  7/24/96 sw"

	TopScreenMenu == nil ifTrue:
		[TopScreenMenu _ SelectionMenu labelList:
		#(	'restore display'
			'open...'
			'changes...'
			'window...'
			'help...'
			'do...'
			'save'
			'save as...'
			'save and quit'
			'quit...')
		lines: #(1 6)
		selections: #( restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].
	^ TopScreenMenu

"
ScreenController new newScreenMenu startUp
"!
windowMenu
	"Answer a menu for windows-related items.  10/24/96 sw"

	^ SelectionMenu labelList:
		#(	'find window...'
			'find changed windows...'
			'collapse all windows'
			'expand all windows'
			'close unchanged windows') ,
			(Array with: (StandardSystemView cachingBits
							ifTrue: ['dont save bits (compact)']
							ifFalse: ['save bits (fast)'])
				with: ((Preferences valueOfFlag: #reverseWindowStagger)
							ifTrue: ['tile windows']
							ifFalse: ['stagger windows']))
		lines: #(2 4 5)
		selections: #(findWindow indicateWindowsWithUnacceptedInput collapseAll expandAll closeUnchangedWindows fastWindows changeWindowPolicy)

"
ScreenController new windowMenu startUp
"! !
!ScreenController class methodsFor: 'class initialization'!
initialize
	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them.  7/24/96 sw
	11/4/96 sw: call installHyperSqueakScreenMenu"

	"ScreenController initialize"
	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.
	Smalltalk hyperSqueakPresent ifTrue: [self installHyperSqueakScreenMenu]!
installHyperSqueakScreenMenu
	"Install the variant of the screen menu containing the HyperSqueak submenu..  To restore the standard version, just set the TopScreenMenu class variable back to nil, or call ScreenController revertToStandardMenus, which does just that11/4/96 sw"

	"ScreenController installHyperSqueakScreenMenu"
	TopScreenMenu _ SelectionMenu labelList:
		#('HyperSqueak...'
			'restore display'
			'open...'
			'changes...'
			'window...'
			'help...'
			'do...'
			'save'
			'save as...'
			'save and quit'
			'quit...')
		lines: #(1 2 7)
		selections: #(hyperSqueakMenu restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit).

	ProjectScreenMenu _ SelectionMenu labelList:
		#('HyperSqueak...'
			'exit project'
			'restore display'
			'open...'
			'changes...'
			'window...'
			'help...'
			'do...'
			'save'
			'save as...'
			'quit...')
		lines: #(1 3 8)
		selections: #(hyperSqueakMenu exitProject restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs quit)! !
!ScrollController methodsFor: 'control defaults'!
isControlActive 
	view isNil ifTrue: [^ false].
	^ (view insetDisplayBox merge: scrollBar inside)
		containsPoint: sensor cursorPoint! !
!SelectionMenu methodsFor: 'basic control sequence'!
invokeOn: targetObject
	"Pop up this menu and return the result of sending to the target object
	 the selector corresponding to the menu item selected by the user. Return
	 nil if no item is selected."

	| sel |
	sel _ self startUp.
	sel = nil ifFalse: [^ targetObject perform: sel].
	^ nil

"(SelectionMenu labels:
'sin
cos
neg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !
!SelectionMenu methodsFor: 'marker management'!
manageMarker
	"Returns the selected item. If no selection, return nil."

	super manageMarker.
	(selections = nil or: [(selection between: 1 and: selections size) not])
		ifTrue: [^ nil].
	^ selections at: selection! !
!SelectionMenu class methodsFor: 'instance creation'!
confirm: queryString 
	"Put up a yes/no menu with caption queryString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."
	"SelectionMenu confirm: 'Are you hungry?'"

	| menu choice |
	menu _ self selections: #('yes' 'no').
	[true] whileTrue: [
		choice _ menu startUpWithCaption: queryString.
		choice = 'yes' ifTrue: [^ true].
		choice = 'no' ifTrue: [^ false]]!
labels: aString lines: linesArray selections: selectionsArray
	"Answer an instance of me whose items are in aString, with lines drawn 
	after each item indexed by anArray. Record the given array of selections
	corresponding to the items in labelsArray."

	^ (self labels: aString lines: linesArray) selections: selectionsArray!
labels: aString selections: selectionsArray
	"Answer an instance of me whose items are in aString, recording
	 the given array of selections corresponding to the items in aString."

	^ self labels: aString lines: #() selections: selectionsArray!
selections: aList
	"Answer an instance of me whose labels and selections are identical.  6/27/96 sw"

	^ self labelList: aList lines: nil selections: aList! !
!SelectorNode methodsFor: 'code generation'!
emit: stack args: nArgs on: aStream super: supered
	| index |
	stack pop: nArgs.
	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:
		["short send"
		code < Send
			ifTrue: [^ aStream nextPut: code "special"]
			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].
	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].
	(index <= 31 and: [nArgs <= 7]) ifTrue: 
		["extended (2-byte) send [131 and 133]"
		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).
		^ aStream nextPut: nArgs * 32 + index].
	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:
		["new extended (2-byte) send [134]"
		aStream nextPut: SendLong2.
		^ aStream nextPut: nArgs * 64 + index].
	"long (3-byte) send"
	aStream nextPut: DblExtDoAll.
	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).
	aStream nextPut: index!
size: encoder args: nArgs super: supered
	| index |
	self reserve: encoder.
	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])
		ifTrue: [^1]. "short send"
	(supered and: [code < Send]) ifTrue: 
		["super special:"
		code _ self code: (encoder litIndex: key) type: 5].
	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].
	(index <= 31 and: [nArgs <= 7])
		ifTrue: [^ 2]. "medium send"
	(supered not and: [index <= 63 and: [nArgs <= 3]])
		ifTrue: [^ 2]. "new medium send"
	^ 3 "long send"! !
!SequenceableCollection methodsFor: 'accessing'!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	start to: self size do:
		[:i | (self at: i) = anElement ifTrue: [^ i]].
	^ exceptionBlock value! !
!SequenceableCollection methodsFor: 'converting'!
reversed
	"Answer a copy of the receiver with element order reversed.  1/26/96 sw.
	Rewritten to work for more classes.  11/18/96 di"

	^ self species streamContents:
		[:strm | self reverseDo: [:elem | strm nextPut: elem]]

" 'frog' reversed "! !
!SequentialSound methodsFor: 'sound generation'!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan
	"Play a collection of sounds in sequence."
	"PluckedSound chromaticScale play"

	| finalIndex i snd remaining count |
	currentIndex = 0 ifTrue: [ ^ self ].  "already done"
	finalIndex _ (startIndex + n) - 1.
	i _ startIndex.
	[i <= finalIndex] whileTrue: [
		snd _ (sounds at: currentIndex).
		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [
			"find next undone sound"
			currentIndex < sounds size ifTrue: [
				currentIndex _ currentIndex + 1.
				snd _ (sounds at: currentIndex).
			] ifFalse: [
				currentIndex _ 0.
				^ self  "no more sounds"
			].
		].
		count _ (finalIndex - i) + 1.
		remaining < count ifTrue: [ count _ remaining ].
		snd mixSampleCount: count into: aSoundBuffer startingAt: i pan: pan.
		i _ i + count.
	].
! !
!Set methodsFor: 'accessing'!
asArray
	"Return an array whose elements are those of the receiver.  12/2/96 sw"

	^ self asOrderedCollection asArray! !
!SmallInteger methodsFor: 'printing'!
printOn: aStream base: b
	"Refer to the comment in Integer|printOn:base:."
	"SmallInteger maxVal printStringBase: 2"

	| digitsInReverse x i |
	self < 0 ifTrue: [
		aStream nextPut: $-.
		^ self negated printOn: aStream base: b.
	].

	b = 10 ifFalse: [aStream print: b; nextPut: $r].
	digitsInReverse _ Array new: 32.
	x _ self.
	i _ 0.
	[x >= b] whileTrue: [
		digitsInReverse at: (i _ i + 1) put: x \\ b.
		x _ x // b.
	].
	digitsInReverse at: (i _ i + 1) put: x.
	[i > 0] whileTrue: [
		aStream nextPut: (Character digitValue: (digitsInReverse at: i)).
		i _ i - 1.
	].! !
!StandardFileStream methodsFor: 'read, write, position'!
next
	"Read the next object from the file. 2/12/96 sw"

	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	count = 1
		ifTrue: [ ^ buffer1 at: 1 ]
		ifFalse: [ ^ nil ].!
upTo: delim 
	"Fast version to speed up nextChunk"
	| pos buffer count |
	pos _ self position.
	buffer _ self next: (2000 min: (self size - self position)).
	(count _ buffer indexOf: delim) > 0 ifTrue: 
		["Found the delimiter part way into buffer"
		self position: pos + count.
		^ buffer copyFrom: 1 to: count - 1].
	self atEnd ifTrue:
		["Never found it, and hit end of file"
		^ buffer].
	"Never found it, but there's more..."
	^ buffer , (self upTo: delim)! !
!StandardSystemController methodsFor: 'control defaults'!
controlActivity
	self checkForReframe.
	^ super controlActivity! !
!StandardSystemController methodsFor: 'menu messages'!
collapse
	"Get the receiver's view to change to a collapsed view on the screen."
	view collapseToPoint: view chooseCollapsePoint!
reframe
	^ view reframeTo: view getFrame!
toggleTwoTone
	(view isMemberOf: StandardSystemView) ifTrue:
		[^ view become: (view as: ColorSystemView)].
	(view isMemberOf: ColorSystemView) ifTrue:
		[^ view become: (view as: StandardSystemView)].
! !
!StandardSystemController methodsFor: 'borders'!
adjustPaneBorders 
	| side sub newRect outerFrame |
	outerFrame _ view displayBox.
	side = #none.
	VBorderCursor showWhile:
		[ [sub _ view subviewWithLongestSide: [:s | side _ s]
						near: sensor cursorPoint.
		  self cursorOnBorder and: [(side = #left) | (side = #right)]]
			whileTrue: [sensor redButtonPressed ifTrue:
				[side = #left ifTrue:
					[newRect _ sub stretchFrame:
						[:f | (f withLeft: sensor cursorPoint x)
								intersect: outerFrame]
						startingWith: sub displayBox].
				side = #right ifTrue:
					[newRect _ sub stretchFrame:
						[:f | (f withRight: sensor cursorPoint x)
								intersect: outerFrame]
						startingWith: sub displayBox].
				view reframePanesAdjoining: sub along: side to: newRect]]].
	HBorderCursor showWhile:
		[ [sub _ view subviewWithLongestSide: [:s | side _ s]
						near: sensor cursorPoint.
		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]
			whileTrue: [sensor redButtonPressed ifTrue:
				[side = #top ifTrue:
					[newRect _ sub stretchFrame:
						[:f | (f withTop: sensor cursorPoint y)
								intersect: outerFrame]
						startingWith: sub displayBox].
				side = #bottom ifTrue:
					[newRect _ sub stretchFrame:
						[:f | (f withBottom: sensor cursorPoint y)
								intersect: outerFrame]
						startingWith: sub displayBox].
				view reframePanesAdjoining: sub along: side to: newRect]]]!
adjustWindowBorders 
	| side |
	VBorderCursor showWhile:
		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.
		  self cursorOnBorder and: [(side = #left) | (side = #right)]]
			whileTrue:
			[sensor redButtonPressed ifTrue:
				[side = #left ifTrue:
					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].
				side = #right ifTrue:
					[view newFrame: [:f | f withRight: sensor cursorPoint x]]]]].
	HBorderCursor showWhile:
		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.
		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]
			whileTrue:
			[sensor redButtonPressed ifTrue:
				[side = #top ifTrue:
					[view newFrame: [:f | f withTop: sensor cursorPoint y]].
				side = #bottom ifTrue:
					[view newFrame: [:f | f withBottom: sensor cursorPoint y]].
		]]]!
adjustWindowCorners 
	| box cornerBox p clicked |
	box _ view windowBox.
	clicked _ false.
	#(topLeft topRight bottomRight bottomLeft)
		with: #(topLeft: topRight: bottomRight: bottomLeft:)
		do: [:readCorner :writeCorner |
			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.
			(cornerBox containsPoint: sensor cursorPoint)
				ifTrue: 
				["Display reverse: cornerBox."
				(Cursor perform: readCorner) showWhile:
					[[(cornerBox containsPoint: (p _ sensor cursorPoint))
						and: [(clicked _ sensor anyButtonPressed) not]]
						whileTrue.
				"Display reverse: cornerBox."
				clicked ifTrue:
					[view newFrame:
						[:f | f copy perform: writeCorner with: sensor cursorPoint]]]]].
	^ clicked!
checkForReframe
	| cp |
	view isCollapsed ifTrue: [^ self].
	cp _ sensor cursorPoint.
	((view closeBoxFrame expandBy: 2) containsPoint: cp)
		| ((view growBoxFrame expandBy: 2) containsPoint: cp)
		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"
	self adjustWindowCorners.
	self cursorOnBorder ifFalse: [^ self].
	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)
		ifFalse: [^ self adjustWindowBorders].
	(view subviewWithLongestSide: [:s | ] near: cp) == nil
		ifFalse: [^ self adjustPaneBorders].!
cursorOnBorder 
	| cp i box |
	view isCollapsed ifTrue: [^ false].
	cp _ sensor cursorPoint.
	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)
		ifTrue: [^ false].
	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0
		ifTrue: [box _ view windowBox]
		ifFalse: [box _ (view subViews at: i) insetDisplayBox].
	^ ((box insetBy: 3) containsPoint: cp) not
		and: [(box expandBy: 4) containsPoint: cp]! !
!StandardSystemController class methodsFor: 'class initialization'!
initialize   "StandardSystemController initialize"
	"Set up the menus for standard windows.  
	 6/6/96 sw: added fullScreen"

	ScheduledBlueButtonMenu _ PopUpMenu labels: 'edit label
choose color...
two-tone/full color
move
frame
full screen
collapse
close'
	lines: #(3 7).
	ScheduledBlueButtonMessages _ #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).
"
StandardSystemController initialize.
ScheduledControllers scheduledWindowControllers
		do: [:c | c initializeBlueButtonMenu]
"
	VBorderCursor _ Cursor extent: 16@16 fromArray: #(
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010010000100000
		2r1010110000110000
		2r1011111111111000
		2r1010110000110000
		2r1010010000100000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000
		2r1010000000000000)
			offset: 0@0.
	HBorderCursor _ Cursor extent: 16@16 fromArray: #(
		2r1111111111111111
		2r0000000000000000
		2r1111111111111111
		2r0000000100000000
		2r0000001110000000
		2r0000011111000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000011111000000
		2r0000001110000000
		2r0000000100000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000)
			offset: 0@0.! !
!StandardSystemView methodsFor: 'initialize-release'!
initialize 
	"Refer to the comment in View|initialize."
	super initialize.
	labelFrame _ Quadrangle new.
	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).
	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
	self label: nil.
	isLabelComplemented _ false.
	minimumSize _ 50 @ 50.
	maximumSize _ Display extent.
	collapsedViewport _ nil.
	expandedViewport _ nil.
	bitsValid _ false.! !
!StandardSystemView methodsFor: 'label access'!
label
	"Answer the string that appears in the receiver's label."
	labelText isNil
		ifTrue: [^ 'Untitled' copy]
		ifFalse: [^ labelText asString]!
label: aString 
	"Set aString to be the receiver's label."
	labelText _ Paragraph
			withText: (Text string: ((aString == nil or: [aString isEmpty])
								ifTrue: ['Untitled' copy]
								ifFalse: [aString])
							attributes: (Array with: (TextFontChange fontNumber: 2)
											with: TextEmphasis bold))
			style: LabelStyle.
	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"
	self setLabelRegion!
labelDisplayBox
	"Answer the rectangle that borders the visible parts of the receiver's label 
	on the display screen."

	^ labelFrame region
		align: labelFrame topLeft
		with: self windowOrigin!
labelFrame
	^labelFrame!
labelHeight
	^ 19!
labelOffset
	^ 0 @ (self labelHeight-2)!
labelTextRegion
	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].
	^ (labelText boundingBox
			align: labelText boundingBox center
			with: self labelDisplayBox center)
		intersect: (self labelDisplayBox insetBy: 35@0)!
setLabelRegion
	"Always follows view width"
	| labelRect |
	labelRect _ 0 @ 0 extent: self displayBox width @ self labelHeight.
	labelFrame region: labelRect.
	^ labelRect! !
!StandardSystemView methodsFor: 'framing'!
chooseCollapsePoint
	"Answer the point at which to place the collapsed window."
	| pt labelForm beenDown offset |
	labelForm _ Form fromDisplay: self labelDisplayBox.
	self uncacheBits.
	self erase.
	beenDown _ Sensor anyButtonPressed.
	self isCollapsed ifTrue:
		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.
		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]
				while: [Sensor anyButtonPressed
							ifTrue: [beenDown _ true]
							ifFalse: [beenDown not]].
		^ pt].
	collapsedViewport isNil ifTrue:
		[^ RealEstateAgent assignCollapsePointFor: self].
	labelForm slideFrom: self labelDisplayBox origin
			to: (pt _ collapsedViewport topLeft) nSteps: 10.
	^ pt!
chooseFrame
	"Answer a new frame, depending on whether the view is currently 
	collapsed or not."
	| labelForm f |
	self isCollapsed & expandedViewport notNil
		ifTrue:
			[labelForm _ bitsValid
				ifTrue: [windowBits]
				ifFalse: [Form fromDisplay: self labelDisplayBox].
			bitsValid _ false.
			self erase.
			labelForm slideFrom: self labelDisplayBox origin
					to: expandedViewport origin-self labelOffset
					nSteps: 10.
			^ expandedViewport]
		ifFalse:
			[f _ self getFrame.
			bitsValid _ false.
			self erase.
			^ f topLeft + self labelOffset extent: f extent]!
collapse
	"If the receiver is not already collapsed, change its view to be that of its 
	label only."

	self isCollapsed ifFalse:
			[expandedViewport _ self viewport.
			savedSubViews _ subViews.
			self resetSubViews.
			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].
			self window: (self inverseDisplayTransform:
					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)
						 intersect: self labelDisplayBox))]!
collapsedFrame
	"Answer the rectangle occupied by this window when collapsed."
	^ collapsedViewport  "NOTE may be nil"!
collapseToPoint: collapsePoint
	self collapse.
	self align: self displayBox topLeft with: collapsePoint.
	collapsedViewport _ self viewport.
	self displayEmphasized!
expand
	"If the receiver is collapsed, change its view to be that of all of its 
	subviews, not its label alone. "
	| newFrame |
	self isCollapsed
		ifTrue:
			[newFrame _ self chooseFrame.
			collapsedViewport _ self viewport.
			subViews _ savedSubViews.
			self window: self defaultWindow.
			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.
			savedSubViews _ nil.
			self resizeTo: newFrame.
			self displayDeEmphasized]!
expandedFrame
	"Answer the rectangle occupied by this window when expanded."
	^ expandedViewport  "NOTE may be nil"!
initialExtent
	"Answer the desired extent for the receiver when it is first opened on the screen.  1/22/96 sw"

	^ model initialExtent min: maximumSize max: minimumSize!
newDisplayBoxFor: subView adjoining: newRect along: side 
	side = #left ifTrue: [^ subView displayBox withRight: newRect left].
	side = #right ifTrue: [^ subView displayBox withLeft: newRect right].
	side = #top ifTrue: [^ subView displayBox withBottom: newRect top].
	side = #bottom ifTrue: [^ subView displayBox withTop: newRect bottom].!
reframePanesAdjoining: subView along: side to: aDisplayBox 
	| newBox delta newRect minDim |
	newRect _ aDisplayBox.
	"First check that this won't make any pane smaller than 8 screen dots"
	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])
		collect: [:sub | self newDisplayBoxFor: sub adjoining: newRect along: side])
			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].
	"If so, amend newRect as required"
	minDim < 8 ifTrue:
		[delta _ minDim - 8.
		newRect _ newRect withSide: side setTo: 
				((newRect perform: side) > (subView displayBox perform: side)
					ifTrue: [(newRect perform: side) + delta]
					ifFalse: [(newRect perform: side) - delta])].
	"Now adjust all adjoining panes for real"
	subViews do:
		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:
			[newBox _ self newDisplayBoxFor: sub adjoining: newRect along: side.
			sub window: sub window viewport:
				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].
	"And adjust the growing pane itself"
	subView window: subView window viewport:
			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.
	"Finally force a recomposition of the whole window"
	self window: self window viewport: self viewport.
	self uncacheBits; displayEmphasized!
reframeTo: newFrame
	"Reframe the receiver to the given screen rectangle.  1/26/96 sw
	Repaint difference after the change.  5/8/96 di"
	| oldBox newBox portRect |
	self uncacheBits.
	oldBox _ self windowBox.
	portRect _ newFrame topLeft + self labelOffset
				corner: newFrame corner.
	self window: self window viewport: portRect.
	self setLabelRegion.
	newBox _ self windowBox.
	(oldBox areasOutside: newBox) do:
		[:rect | ScheduledControllers restore: rect].
	self displayEmphasized!
resize
	"Determine the rectangular area for the receiver, adjusted to the 
	minimum and maximum sizes."
	| f |
	f _ self getFrame.
	self resizeTo: (f topLeft + self labelOffset extent: f extent)
!
windowOrigin
	^ self isCollapsed
		ifTrue: [self displayBox topLeft]
		ifFalse: [self displayBox topLeft - self labelOffset]! !
!StandardSystemView methodsFor: 'displaying'!
displayDeEmphasized
	"Display this view with emphasis off.
	If windowBits is not nil, then simply BLT"
	bitsValid
		ifTrue: [self lock.
				windowBits displayAt: self windowOrigin]
		ifFalse: [super display.
				CacheBits ifTrue: [self cacheBitsAsIs]]
!
displayLabelText
	"The label goes in the center of the window"
	| labelRect |
	labelText foregroundColor: self foregroundColor
			backgroundColor: self labelColor.
	labelRect _ self labelTextRegion.
	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect
			rule: labelText rule fillColor: labelText fillColor!
displayOn: aPort
	bitsValid ifFalse: [^ self].
	windowBits displayOnPort: aPort at: self windowOrigin!
displayView
	"Refer to the comment in View|displayView. "
	self displayBox width = labelFrame width ifFalse:
		["recompute label width when window changes size"
		self setLabelRegion].
	(labelFrame align: labelFrame topLeft with: self windowOrigin)
		insideColor: self labelColor;
		displayOn: Display.
	self displayLabelText!
windowBits
	^ windowBits! !
!StandardSystemView methodsFor: 'deEmphasizing'!
deEmphasizeView 
	"Refer to the comment in View|deEmphasizeView."

	isLabelComplemented ifTrue:
		[self deEmphasizeLabel.
		isLabelComplemented _ false]! !
!StandardSystemView methodsFor: 'private'!
subviewWithLongestSide: sideBlock near: aPoint 
	| region subs max rect side len theSub theSide |
	region _ aPoint - (4@4) corner: aPoint + (4@4).
	subs _ subViews select: [:sub | sub insetDisplayBox intersects: region].
	subs isEmpty ifTrue: [sideBlock value: #none.  ^ nil].
	max _ 0.
	subs do:
		[:sub | rect _ sub insetDisplayBox.
		side _ rect sideNearestTo: aPoint.
		len _ (side = #left) | (side = #right)
			ifTrue: [rect height]
			ifFalse: [rect width].
		len > max ifTrue: [max _ len.  theSub _ sub.  theSide _ side]].
	sideBlock value: theSide.
	^ theSub! !
!StandardSystemView class methodsFor: 'class initialization'!
cachingBits
	^ CacheBits!
initialize		"StandardSystemView initialize"
	self doCacheBits.
	(LabelStyle _ TextStyle default copy)
		gridForFont: 2 withLead: 0! !
!StrikeFont methodsFor: 'accessing'!
setGlyphs: newGlyphs
	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."

	glyphs _ newGlyphs!
widthOf: aCharacter 
	"Answer the width of the argument as a character in the receiver."

	| ascii |
	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.
	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !
!StrikeFont methodsFor: 'emphasis'!
bonk: glyphForm with: bonkForm
	"Bonking means to run through the glyphs clearing out black pixels
	between characters to prevent them from straying into an adjacent
	character as a result of, eg, bolding or italicizing"
	"Uses the bonkForm to erase at every character boundary in glyphs."
	| bb offset |
	offset _ bonkForm offset x.
	bb _ BitBlt toForm: glyphForm.
	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;
		combinationRule: Form erase; destY: 0.
	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].
!
emphasized: code 
	"Answer a copy of the receiver with emphasis set to include code."
	| derivative addedEmphasis base g r safeCode |
	code = 0 ifTrue: [^ self].
	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].
	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).
	derivative == nil ifFalse: [^ derivative].  "Already have this style"

	"Dont have it -- derive from another with one with less emphasis"
	addedEmphasis _ 1 bitShift: safeCode highBit - 1.
	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"
	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"
		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].
	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"
		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].
	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"
		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].
	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"
		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].
	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"
		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].
	derivative emphasis: safeCode.
	derivativeFonts at: safeCode put: derivative.
	^ derivative!
makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs deepCopy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	g copyBits: g boundingBox from: g at: (1@0)
		clippingBox: g boundingBox rule: Form under fillColor: nil.
	glyphs _ g!
makeCondensedGlyphs
	"Make an underlined set of glyphs with same widths"
	| g newXTable x x1 w |
	g _ glyphs deepCopy.
	newXTable _ Array new: xTable size.
	newXTable at: 1 put: (x _ xTable at: 1).
	1 to: xTable size-1 do:
		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.
		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"
		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.
		newXTable at: i+1 put: (x _ x + w)].
	xTable _ newXTable.
	glyphs _ g
"
(TextStyle default fontAt: 1) copy makeCondensedGlyphs
	displayLine: 'The quick brown fox jumps over the lazy dog'
	at: Sensor cursorPoint
"!
makeItalicGlyphs
	"Make an italic set of glyphs with same widths by skewing left and right
		(may require more intercharacter space)"
	| g r bonkForm bc |
	g _ glyphs deepCopy.
	"BonkForm will have bits where slanted characters overlap their neighbors."
	bonkForm _ Form extent: (self height//4+2) @ self height.
	bc _ self descent//4 + 1.  "Bonker x-coord corresponding to char boundary."
	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color black.
	4 to: self ascent-1 by: 4 do:
		[:y | 		"Slide ascenders right..."
		g copy: (1@0 extent: g width @ (self ascent - y))
			from: 0@0 in: g rule: Form over.
		bonkForm copy: (1@0 extent: bonkForm width @ (self ascent - y))
			from: 0@0 in: bonkForm rule: Form over].
	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color white.
	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color black.
	self ascent to: self height-1 by: 4 do:
		[:y | 		"Slide descenders left..."
		g copy: (0@y extent: g width @ g height)
			from: 1@y in: g rule: Form over.
		bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)
			from: 1@0 in: bonkForm rule: Form over].
	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color white.
	"Now use bonkForm to erase at every character boundary in glyphs."
	bonkForm offset: (0-bc) @ 0.
	self bonk: g with: bonkForm.
	glyphs _ g
!
makeStruckOutGlyphs
	"Make a struck-out set of glyphs with same widths"
	| g |
	g _ glyphs deepCopy.
	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).
	glyphs _ g
!
makeUnderlinedGlyphs
	"Make an underlined set of glyphs with same widths"
	| g |
	g _ glyphs deepCopy.
	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).
	glyphs _ g
!
reset
	"Reset the cache of derivative emphasized fonts"
	derivativeFonts _ Array new: 32! !
!StrikeFont methodsFor: 'file in/out'!
displayChar: ascii form: charForm
	"Convenience utility used during conversion of BitFont files"
	| m bigForm |
	Display fillBlack: (0@0 extent: 20@14).
	ascii printString displayAt: 0@2.
	charForm width > 0 ifTrue:
		[m _ 5.
		bigForm _ charForm magnify: charForm boundingBox by: m@m.
		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.
		bigForm displayAt: 50@2.
		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].!
newFromStrike: fileName
	"Build an instance from the strike font file name. The '.strike' extension
	is optional."

	| strike startName raster16 |
	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".
	strike _ FileStream oldFileNamed: name, '.strike.'.
	strike binary.
	strike readOnly.
		"strip off direcory name if any"
	startName _ name size.
	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]
		whileTrue: [startName _ startName - 1].
	name _ name copyFrom: startName+1 to: name size.

	type			_		strike nextWord16.		"type is ignored now -- simplest
												assumed.  Kept here to make
												writing and consistency more
												straightforward."
	minAscii		_		strike nextWord16.
	maxAscii		_		strike nextWord16.
	maxWidth		_		strike nextWord16.
	strikeLength	_		strike nextWord16.
	ascent			_		strike nextWord16.
	descent			_		strike nextWord16.
	"xOffset			_"		strike nextWord16. 	
	raster16			_		strike nextWord16.	
	superscript		_		ascent - descent // 3.	
	subscript		_		descent - ascent // 3.	
	emphasis		_		0.
	glyphs			_	Form extent: (raster16 * 16) @ (self height)  
							offset: 0@0.
		glyphs bits fromByteStream: strike.

	xTable _ (Array new: maxAscii + 3) atAllPut: 0.
	(minAscii + 1 to: maxAscii + 3) do:
		[:index | xTable at: index put: strike nextWord16].

	"Set up space character"
	((xTable at: (Space asciiValue + 2))  = 0 or:
			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])
		ifTrue:	[(Space asciiValue + 2) to: xTable size do:
					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].
	strike close.

	self setStopConditions !
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: '(' , self name , ')'!
readBFHeaderFrom: f
	name _ self restOfLine: 'Font name = ' from: f.
	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.
	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.
	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.
	pointSize _ (self restOfLine: 'Font size = ' from: f) asNumber.
	name _ (name copyWithout: Character space) ,
				(pointSize < 10
					ifTrue: ['0' , pointSize printString]
					ifFalse: [pointSize printString]).
	minAscii _ 258.
	maxAscii _ 0.
	superscript _ ascent - descent // 3.	
	subscript _ descent - ascent // 3.	
	emphasis _ 0.
	type _ 0.  "ignored for now"
!
readFromBitFont: fileName
	"This builds a StrikeFont instance by reading the data file format
	produced by BitFont, a widely available font conversion utility
	written by Peter DiCamillo at Brown University"
	"StrikeFont new readFromBitFont: 'Palatino10.BF' "
	| f fLength lastAscii charLine width ascii charForm line missingForm tempGlyphs s nn iRect ptSize |
	f _ FileStream readOnlyFileNamed: fileName.
	self readBFHeaderFrom: f.
	tempGlyphs _ Form extent: (maxWidth*257) @ self height.
	xTable _ (Array new: 258) atAllPut: 0.
	xTable at: 1 put: 0.

	self restOfLine: 'Extent information for entire font' from: f.
	"Parse the foloowing line (including mispelling!!)"
	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"
	s _ ReadStream on: (self restOfLine: 'Image rect' from: f).
	s upTo: $:.
	nn _ (1 to: 4) collect:
		[:i | s upTo: $=; skipSeparators. Number readFrom: (s upTo: $,)].
	iRect _ Rectangle left: (nn at: 1) right: (nn at: 2)
				top: (nn at: 3) bottom: (nn at: 4).
	
	"Read character forms and blt into tempGlyphs"
	lastAscii _ -1.
	[charLine _ self restOfLine: 'Character: ' from: f.
	charLine == nil ifFalse:
		[width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber.
		charLine = 'Missing character' ifTrue: [ascii _ 256].
		('x''*' match: charLine) ifTrue:
			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) base: 16].
		charForm _ Form extent: width@self height.
		('*[all blank]' match: charLine) ifFalse:
			[self restOfLine: '  +' from: f.
			1 to: self height do:
				[:y | line _ f upTo: Character cr.
				4 to: line size+iRect left-1 do:
					[:x | (line at: x-iRect left)=$* ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].
	charLine == nil]
		whileFalse:
			[self displayChar: ascii form: charForm.
			ascii = 256
				ifTrue: [missingForm _ charForm deepCopy]
				ifFalse:
				[minAscii _ minAscii min: ascii.
				maxAscii _ maxAscii max: ascii.
				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].
				tempGlyphs copy: ((xTable at: ascii+1)@0
										extent: charForm extent)
							from: 0@0 in: charForm rule: Form over.
				xTable at: ascii+2 put: (xTable at: ascii+1) + width.
				lastAscii _ ascii]].
	f close.
	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].
	missingForm == nil ifFalse:
		[tempGlyphs copy: missingForm boundingBox from: missingForm
				to: (xTable at: maxAscii+2)@0 rule: Form over.
		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].
	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.
	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.
	xTable _ xTable copyFrom: 1 to: maxAscii+3.

	self setStopConditions!
readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"
	"Build an instance from the strike font stored in strike2 format.
	fileName is of the form: <family name><pointSize>.sf2"
	| file |
	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].
	name _ fileName copyUpTo: $. .  "Drop filename extension"
	file _ FileStream readOnlyFileNamed: fileName.
	file binary.
	self readFromStrike2Stream: file!
readFromStrike2Stream: file 
	"Build an instance from the supplied binary stream on data in strike2 format"
	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].
	minAscii _ file nextInt32.
	maxAscii _ file nextInt32.
	maxWidth _ file nextInt32.
	ascent _ file nextInt32.
	descent _ file nextInt32.
	pointSize _ file nextInt32.
	superscript _ ascent - descent // 3.	
	subscript _ descent - ascent // 3.	
	emphasis _ file nextInt32.
	xTable _ (Array new: maxAscii + 3) atAllPut: 0.
	(minAscii + 1 to: maxAscii + 3) do:
		[:index | xTable at: index put: file nextInt32].
	glyphs _ Form new readFrom: file.
	file close.

	"Set up space character"
	((xTable at: (Space asciiValue + 2))  = 0 or:
			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])
		ifTrue:	[(Space asciiValue + 2) to: xTable size do:
					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].

	self setStopConditions!
restOfLine: leadString from: file
	"Utility method to assist reading of BitFont data files"
	| line |
	[line _ file upTo: Character cr.
	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]
	whileTrue: [file atEnd ifTrue: [^ nil]].
	^ line copyFrom: leadString size+1 to: line size!
setStopConditions
	"This has to do with scanning characters, not with the font"
	stopConditions _ Array new: 258.
	stopConditions atAllPut: nil.
	1 to: (minAscii - 1) do:
		[:index | stopConditions at: index put: #characterNotInFont].
	(maxAscii + 3) to: stopConditions size do:
		[:index | stopConditions at: index put: #characterNotInFont].
	self reset!
writeAsStrike2named: fileName
	"Write me onto a file in strike2 format.
	fileName should be of the form: <family name><pointSize>.sf2"
	| file |
	file _ FileStream fileNamed: fileName.
	file binary.
	file nextInt32Put: 2.
	file nextInt32Put: minAscii.
	file nextInt32Put: maxAscii.
	file nextInt32Put: maxWidth.
	file nextInt32Put: ascent.
	file nextInt32Put: descent.
	file nextInt32Put: pointSize.
	superscript _ ascent - descent // 3.	
	subscript _ descent - ascent // 3.	
	file nextInt32Put: emphasis.
	(minAscii + 1 to: maxAscii + 3) do:
		[:index | file nextInt32Put: (xTable at: index)].
	glyphs writeOn: file.
	file close.
! !
!StrikeFont methodsFor: 'character shapes'!
alter: char formBlock: formBlock
	self characterFormAt: char 
		put: (formBlock value: (self characterFormAt: char))!
characterForm: char pixelValueAt: pt put: val
	| f |
	f _ self characterFormAt: char.
	f pixelAt: pt put: val.
	self characterFormAt: char put: val!
characterFormAt: character 
	"Answer a Form copied out of the glyphs for the argument, character."
	| ascii leftX rightX characterForm |
	ascii _ character asciiValue.
	leftX _ xTable at: ascii + 1.
	rightX _ xTable at: ascii + 2.
	characterForm _ Form extent: (rightX-leftX) @ self height.
	characterForm copy: characterForm boundingBox
		from: leftX@0 in: glyphs rule: Form over.
	^ characterForm!
characterFormAt: character put: characterForm
	"Copy characterForm over the glyph for the argument, character."
	| ascii leftX rightX widthDif newGlyphs |
	ascii _ character asciiValue.
	leftX _ xTable at: ascii + 1.
	rightX _ xTable at: ascii + 2.
	widthDif _ characterForm width - (rightX - leftX).
	widthDif ~= 0 ifTrue:
		["Make new glyphs with more or less space for this char"
		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.
		newGlyphs copy: (0@0 corner: leftX@glyphs height)
			from: 0@0 in: glyphs rule: Form over.
		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)
			from: rightX@0 in: glyphs rule: Form over.
		glyphs _ newGlyphs.
		"adjust further entries on xTable"
		ascii+2 to: xTable size
			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].
	glyphs copy: (leftX @ 0 corner: rightX @ self height)
		from: 0@0 in: characterForm rule: Form over
"
| f |  f _ TextStyle default fontAt: 1.
f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)
"!
edit: character		"(TextStyle default fontAt: 1) edit: $_"
	"Open a Bit Editor on the given character.  Note that you must do an accept
	(in the option menu of the bit editor) if you want this work.
	Accepted edits will not take effect in the font until you leave or close the bit editor.
	Also note that unaccepted edits will be lost when you leave or close."
	| charForm smallRect editRect scaleFactor bitEditor savedForm r |
	charForm _ self characterFormAt: character.
	editRect _ BitEditor locateMagnifiedView: charForm
	                                        scale: (scaleFactor _ 8@8).
	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft
			scale: scaleFactor remoteView: nil.
	bitEditor controller blueButtonMenu: nil blueButtonMessages: nil.
	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).
	bitEditor controller startUp.
	bitEditor release.
	savedForm displayOn: Display at: r topLeft.
	self characterFormAt: character put: charForm!
widen: char by: delta
	| newForm |
	^ self alter: char formBlock:  "Make a new form, wider or narrower..."
		[:charForm | newForm _ Form extent: charForm extent + (delta@0).
		charForm displayOn: newForm.  "Copy this image into it"
		newForm]    "and substitute it in the font"! !
!StrikeFont class methodsFor: 'instance creation'!
fromStrike: fileName 
	"Read a font from disk in the old ST-80 'strike' format.
	Note: this is an old format; use strike2 format instead"

	^self new newFromStrike: fileName! !
!StrikeFont class methodsFor: 'examples'!
convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "
	"This utility is for use after you have used BitFont to produce data files 
	for the fonts you wish to use.  It will read the BitFont files and then 
	write them out in strike2 (*.sf2) format which is much more compact,
	and which can be read in again very quickly."
	"For this utility to work as is, the BitFont data files must be named
	'familyNN.BF', and must reside in the same directory as the image."
	| f |
	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:
		[:fname | Transcript cr; show: fname.
		f _ StrikeFont new readFromBitFont: fname.
		f writeAsStrike2named: f name , '.sf2']!
example
	"Displays a line of text on the display screen at the location of the cursor.
	Example depends on the strike font file, 'TimesRoman10.strike'. existing."

	(StrikeFont new readFromStrike2: 'NewYork12.sf2')
		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint
	 
	"StrikeFont example."!
size: pointSize fromLiteral: aString
	"This method allows a font set to be captured as sourcecode in a subclass.
	The string literals will presumably be created by printing, eg,
		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,
		and then pasting into a browser after a heading like, eg,
size24
	^ self size: 24 fromLiteral:
	'--unreadable binary data--'

	See the method hackDefaultStyle to see how this can be used
"
	^ (StrikeFont new readFromStrike2Stream:
		(ExternalStream on: aString asByteArray from: 1 to: aString size))
		name: self name , (pointSize < 10 ifTrue: ['0' , pointSize printString]
										ifFalse: [pointSize printString])! !
!StrikeFont class methodsFor: 'derivative font caching'!
shutDown  "StrikeFont shutDown"
	"Deallocate synthetically derived copies of base fonts to save space"
	self allInstancesDo: [:sf | sf reset]! !
!String methodsFor: 'accessing'!
atWrap: index 
	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  6/18/96 tk"
	<primitive: 63>
	^(super atWrap: index) asCharacter!
runs
        "Strings don't have runs..."

        ^#()! !
!String methodsFor: 'comparing'!
beginsWith: prefix | prefixSize |
	"Answer whether the receiver begins with the given prefix string."

	prefixSize _ prefix size.

	self size < prefixSize ifTrue: [^false].
	1 to: prefixSize do:
		[:index | (self at: index) = (prefix at: index) ifFalse: [^false]].
	^true! !
!String methodsFor: 'converting'!
asByteArray
	"Convert to a ByteArray with the ascii values of the string.
	Fast code uses primitive that avoids character conversion"

	^ (ByteArray new: self size) replaceFrom: 1 to: self size with: self!
capitalized
	"Return a copy with the first letter capitalized"
	| cap |
	cap _ self copy.
	cap at: 1 put: (cap at: 1) asUppercase.
	^ cap!
surroundedBySingleQuotes
	"Answer the receiver with leading and trailing quotes.  11/25/96 sw"

	^ $' asString, self, $' asString! !
!String methodsFor: 'private'!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take abnother block and enumerate over some list with it."

	| choices scoreMin results score |
	scoreMin _ self size // 2 min: 3.
	oldCollection isNil
		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]
		ifFalse: [ choices _ oldCollection ].
	wordBlock isNil
		ifTrue:
			[ results _ OrderedCollection new.
			1 to: (5 min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifFalse:
			[ wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue:
					[ choices add: (Association key: word value: score).
						(choices size >= 5) ifTrue: [ scoreMin _ (choices at: 5) value] ] ].
			results _ choices ].
	^ results! !
!String methodsFor: 'Celeste'!
includesSubstring: aString caseSensitive: caseSensitive
	"Note: Although less general than the 'match:' method, this method was a factor of 10 faster on both successful and unsucessful finds of a short string in a 1116 byte mail message."
	
	| first index i |
	self isEmpty ifTrue: [^false].
	caseSensitive ifTrue: [
		first _ aString first.
		1 to: self size - aString size + 1 do: [ :start |
			(self at: start) = first ifTrue: [
				i _ 1.
				[(self at: start + i - 1) = (aString at: i)] whileTrue: [
					i = aString size ifTrue: [^true].
					i _ i + 1.
				].
			].
		].
	] ifFalse: [
		first _ aString first asLowercase.
		1 to: self size - aString size + 1 do: [ :start |
			(self at: start) asLowercase = first ifTrue: [
				i _ 1.
				[(self at: start + i - 1) asLowercase =
				 (aString at: i) asLowercase] whileTrue: [
					i = aString size ifTrue: [^ true].
					i _ i + 1.
				].
			].
		].
	].
	^ false!
withCRs
	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."

	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !
!StringHolderController methodsFor: 'menu messages'!
objectsReferencingIt
	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  9/27/96 sw"

	| result |
	self controlTerminate.
	result _ self evaluateSelection.
	((result isKindOf: FakeClassPool) or:
	 [result == #failedDoit]) ifFalse: [
		Smalltalk
			browseAllObjectReferencesTo: result
			except: #()
			ifNone: [:obj | view topView flash. self controlInitialize]].
! !
!StringHolderController class methodsFor: 'class initialization'!
initialize
	"Initialize the yellow button pop-up menu and corresponding messages.
	 1/12/96 sw: added senders of it, etc.  1/15/96 sw: explain
	 1/22/96 sw: cmd keys detailed
	 1/24/96 sw: added find; moved many items to shifted side etc.
	 1/26/96 sw: made compatible with paragraph editor's version; I'm not clear on when/how this guy gets used (seemingly eg in a workspace) vs when the paragraph editor's does (seemingly in browsers)
	 2/29/96 sw: correct cmd-key equivalent for do again, and add set-search-string"

	CodeYellowButtonMenu _ 
		PopUpMenu 
			labels: 
'find...(f)
find again (g)
set search string (h)
do again (j)
undo (z)
copy (c)
cut (x)
paste (v)
do it (d)
print it (p)
inspect it (i)
accept (s)
cancel (l)
show bytecodes
more...' 
		lines: #(3 5 8 11 13 14).
	CodeYellowButtonMessages _ 
		#(find findAgain setSearchString again undo copySelection cut paste doIt printIt inspectIt accept cancel showBytecodes shiftedYellowButtonActivity)

	"StringHolderController initialize"! !
!SwitchView methodsFor: 'label access'!
centerLabel
	"Align the center of the label with the center of the receiver's window."
	label == nil  ifFalse: 
		[(label isKindOf: Paragraph)
			ifTrue: ["Compensate for leading in default style"
					label align: label boundingBox center + (0@1)
							with: self getWindow center]
			ifFalse: [label align: label boundingBox center 
							with: self getWindow center]]! !
!SyntaxError methodsFor: 'menu messages'!
autoProceed
	| someView |
	someView _ self dependents first.
	self proceed: someView topView controller!
proceed: aController 
	"The error has presumably been fixed and the file in that created the 
	syntax error can now be continued."

	debugger proceed: aController! !
!SyntaxError methodsFor: 'contents'!
contents: aString notifying: aController 
	"Compile the code in aString and notify aController of any errors.
	If there are no errors, then automatically proceed."

	(class compile: aString classified: category notifying: aController)
		 == nil ifTrue: [^ false].
	self autoProceed! !
!SyntaxError class methodsFor: 'instance creation'!
errorInClass: aClass withCode: aString 
	"Answer a standard system view whose model is an instance of me. The syntax error occurred in typing to add code, aString, to class, aClass. "

	self open: (self new setClass: aClass
						code: aString
						debugger: (Debugger context: thisContext))!
open: aSyntaxError
	"Answer a standard system view whose model is an instance of me.  TK 15 May 96"
	|  topView aListView aCodeView |
	topView _ StandardSystemView new.
	topView model: aSyntaxError.
	topView label: 'Syntax Error'.
	topView minimumSize: 380 @ 220.
	aListView _ SyntaxErrorListView new.
	aListView model: aSyntaxError.
	aListView window: (0 @ 0 extent: 380 @ 20).
	aListView
		borderWidthLeft: 2
		right: 2
		top: 2
		bottom: 0.
	topView addSubView: aListView.
	aCodeView _ BrowserCodeView new.
	aCodeView model: aSyntaxError.
	aCodeView window: (0 @ 0 extent: 380 @ 200).
	aCodeView
		borderWidthLeft: 2
		right: 2
		top: 2
		bottom: 2.
	topView
		addSubView: aCodeView
		align: aCodeView viewport topLeft
		with: aListView viewport bottomLeft.
	topView controller openNoTerminateDisplayAt: Display extent // 2.
	Processor activeProcess suspend! !
!SystemBuilder class methodsFor: 'system building'!
finalSystemBuildingSteps
	"The final steps after all the file-ins, before we can call the system built.  1/18/96 sw"

	Symbol rehash.     " Reclaim unused symbols"
	self showInTranscript: '** System Built **'.
	BuildingSystem _ false.!
initializeAfterSystemBuild
	"Reinitialize needs to be called manually after filing in the kernel because other support classes need to have been filed in before it can run successfully.  This method copied over from old macPal stuff, 1/27/96 sw, to serve as a template, but the real work needs to be done still."

	Text initTextConstants.
	
	"Rebuild snapshot lists"

	self showInTranscript: '** SystemBuilder reinitialize  **'.
	"self initMenus"! !
!SystemCategoryListController methodsFor: 'menu messages'!
browseAllClasses
	"Create and schedule a browser on all classes alphabetically."

	self controlTerminate.
	model browseAllClasses.
	self controlInitialize!
findClass
	"modified 4/29/96 sw so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"
	| pattern foundClass classNames index reply |
	self controlTerminate.
	model okToChange ifFalse: [^ self classNotFound].
	pattern _ (reply _ FillInTheBlank request: 'Class Name?') asLowercase.
	pattern isEmpty ifTrue: [^ self classNotFound].
	(Smalltalk hasClassNamed: reply)
		ifTrue:
			[foundClass _ Smalltalk at: reply asSymbol]
		ifFalse:
 			[classNames _ Smalltalk classNames asArray select: 
				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].
			classNames isEmpty ifTrue: [^ self classNotFound].
			index _ classNames size == 1
				ifTrue:	[1]
				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].
			index = 0 ifTrue: [^ self classNotFound].
			foundClass _ Smalltalk at: (classNames at: index)].
 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).
	model classListIndex: (model classList indexOf: foundClass name). 
	self controlInitialize!
findRecentClass
        "Put up a list of recently visited classes and allow the user to select one."

        self controlTerminate.
        model recent.
        self controlInitialize! !
!SystemCategoryListController class methodsFor: 'class initialization'!
initialize
	"SystemCategoryListController initialize"
	SystemCategoryListYellowButtonMenu _ 
		PopUpMenu 
			labels:
'find class...
recent classes...
browse all
browse
printOut
fileOut
reorganize
update
add item...
rename...
remove' 
			lines: #(2 4 6 8).
	SystemCategoryListYellowButtonMessages _
		#(findClass findRecentClass browseAllClasses browse
		printOut fileOut
		edit update
		add rename remove )
	"
	SystemCategoryListController initialize.
	SystemCategoryListController allInstancesDo:
		[:x | x initializeYellowButtonMenu]
	"! !
!SystemDictionary methodsFor: 'browsing'!
browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock
	"Bring up a list inspector on the objects that point to anObject. If there are none, then evaluate aBlock on anObject.  9/27/96 sw"

	| aList shortName |
	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.
	aList size > 0 ifFalse: [^ aBlock value: anObject].
	shortName _ anObject name.
	shortName size > 12 ifTrue: [
		shortName _ (shortName truncateTo: 12), '...'.
	].
	InspectorView
		open: (InspectorView inspector: (OrderedCollectionInspector inspect: aList))
		withLabel: 'Objects pointing to ', shortName.
! !
!SystemDictionary methodsFor: 'retrieving'!
pointersTo: anObject
	"Find all occurrences in the system of pointers to the argument anObject."
	"(Smalltalk pointersTo: Browser) inspect."

	^ self pointersTo: anObject except: #()
!
pointersTo: anObject except: objectsToExclude
	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."

	| results anObj |
	Smalltalk garbageCollect.
	"big collection shouldn't grow, so it's contents array is always the same"
	results _ OrderedCollection new: 1000.

	"allObjectsDo: is expanded inline to keep spurious
	 method and block contexts out of the results"
	anObj _ self someObject.
	[0 == anObj] whileFalse: [
		(anObj pointsTo: anObject) ifTrue: [
			"exclude the results collector and contexts in call chain"
			((anObj ~~ results collector) and:
			 [(anObj ~~ objectsToExclude) and:
			 [(anObj ~~ thisContext) and:
			 [(anObj ~~ thisContext sender) and:
			 [anObj ~~ thisContext sender sender]]]])
				 ifTrue: [ results add: anObj ].
		].
		anObj _ anObj nextObject.
	].
	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].

	^ results asArray
!
pointersToItem: index of: anArray
	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:

	Smalltalk pointersToItem: 2 of: self

in the inspector."

	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !
!SystemDictionary methodsFor: 'class names'!
renameClassNamed: oldName as: newName
	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  10/28/96 sw"

	| oldClass |
	(oldClass _ self at: oldName asSymbol ifAbsent: [nil]) == nil
		ifTrue:
			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.
			^ self].

	oldClass rename: newName! !
!SystemDictionary methodsFor: 'memory space'!
lowSpaceThreshold
	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."

	^ 80000!
lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting"
			^ self beep
		].
	].

	LowSpaceSemaphore _ Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess _ nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	ScheduledControllers interruptName: 'Space is low, scroll for options'.
!
okayToProceedEvenIfSpaceIsLow
	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."

	self garbageCollectMost > self lowSpaceThreshold ifTrue: [^ true].  "quick"
	self garbageCollect > self lowSpaceThreshold ifTrue: [^ true].  "work harder"

	^ self confirm:
'WARNING: There is not enough space to start the low space watcher.
If you proceed, you will not be warned again, and the system may
run out of memory and crash. If you do proceed, you can start the
low space notifier when more space becomes available simply by
opening and then closing a debugger (e.g., by hitting Cmd-period.)
Do you want to proceed?'
!
printSpaceAnalysis	"Smalltalk garbageCollect; printSpaceAnalysis"
	"Note: this all needs to be updated for 32-bit direct pointers"
	| f name space words scale count |
	f _ FileStream newFileNamed: 'STspace.text'.
	f timeStamp.
	self allClassesDo:
		[:cl | name _ cl name.
		Sensor redButtonPressed ifTrue: [Transcript cr; show: name].
		space _ cl == Character ifTrue: [#(0 0)] ifFalse: [cl space].
		count _ cl instanceCount.
		f print: name; tab;
			print: space first; tab;
			print: space last; tab;
			print: count; tab.
		words _ (cl instSize+2)*count.
		cl isVariable ifTrue:
				[scale _ cl isBytes ifTrue: [2] ifFalse: [1].
				cl allInstancesDo: [:x | words _ words + (x size//scale)]].
		f print: words; cr].
	f close!
useUpMemory
	"For testing the low space handler..."
	"Smalltalk installLowSpaceWatcher; useUpMemory"

	| lst |
	lst _ nil.
	[true] whileTrue: [
		lst _ Link new nextLink: lst; yourself.
	].! !
!SystemDictionary methodsFor: 'special objects'!
recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"
	"The Special Objects Array is an array of object pointers used by the
	Smalltalk virtual machine.  Its contents are critical and unchecked,
	so don't even think of playing here unless you know what you are doing."
	| newArray smallFrameSize largeFrameSize |
	newArray _ Array new: 39.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (Smalltalk associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk. 
	newArray at: 10 put: Float.
	newArray at: 11 put: MethodContext.
	newArray at: 12 put: BlockContext.
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil.  "*unused*"
	"An array of the 32 selectors that are compiled as special bytecodes,
	paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).
	"An array of the 255 Characters in ascii order."
	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	"An array of up to 31 classes whose instances will have compact headers"
	newArray at: 29 put: self compactClassesArray.
	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".
	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".

	"Prototype instances that can be copied for fast initialization"
	newArray at: 32 put: (Float new: 2).
	newArray at: 33 put: (LargePositiveInteger new: 4).
	newArray at: 34 put: Point new.
	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0
						nStack: 0 nLits: 0 primitive: 0) frameSize.
	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0
						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.
	newArray at: 35 put: (MethodContext new: smallFrameSize).
	newArray at: 36 put: (MethodContext new: largeFrameSize).
	newArray at: 37 put: (BlockContext new: smallFrameSize).
	newArray at: 38 put: (BlockContext new: largeFrameSize).
	newArray at: 39 put: Array new.  "coming soon... Socket Semaphores"

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray!
specialNargsAt: anInteger 
	"Answer the number of arguments for the special selector at: anInteger."

	^ (self specialObjectsArray at: 24) at: anInteger * 2!
specialSelectorAt: anInteger 
	"Answer the special message selector from the interleaved specialSelectors array."

	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1!
specialSelectorSize
	"Answer the number of special selectors in the system."

	^ (self specialObjectsArray at: 24) size // 2! !
!SystemDictionary methodsFor: 'image, changes name'!
sourcesName
	"Answer the sources file name used in this Smalltalk release."

	^ self vmPath, 'SqueakV1.sources'! !
!SystemDictionary methodsFor: 'sources, change log'!
abandonSources    "Smalltalk abandonSources"
	"Replaces every method by a copy with the 3-byte source pointer 
	replaced by a string of all arg and temp names, followed by its length.
	These names can then be used to inform the decompiler.  See stats below"
	 | oldMethod oldCodeString argsAndTemps |
	(self confirm:  'CAUTION -- do not undertake this lightly!!
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, hit Yes.
If you have any doubts, hit No,
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - abandoned'].
	Smalltalk forgetDoIts.
	Smalltalk allBehaviorsDo:
		[:cl |  Transcript show: cl name; cr.
		cl selectors do:
			[:selector |
			oldCodeString _ cl sourceCodeAt: selector.
			argsAndTemps _ (cl compilerClass new
				parse: oldCodeString in: cl notifying: nil)
				tempNames.
			oldMethod _ cl compiledMethodAt: selector.
			oldMethod tempNamesPut: argsAndTemps]].
	CompiledMethod magicSources: true.
	Smalltalk closeSourceFiles.
"
In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).

Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 6 bytes more than the current 3-byte trailer.
"!
version
	"Answer the version of this release."

	^ 'Squeak 1.18 of December 12, 1996'! !
!SystemDictionary methodsFor: 'snapshot and quit'!
processShutDownList
	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."

	SoundPlayer shutDown.
	Smalltalk shutDown.
	Delay shutDown.
	Color shutDown.
	ControlManager shutDown.
	StrikeFont shutDown.
	DisplayScreen shutDown.
!
processStartUpList
	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."

	DisplayScreen startUp.
	Cursor startUp.
	Smalltalk installLowSpaceWatcher.	"OK to do again later"
	InputSensor startUp.
	ProcessorScheduler hiddenBackgroundProcess.
	Delay startUp.
	Smalltalk startUp.
	ControlManager startUp.  "NOTE: The active process terminates here."
!
snapshot: save andQuit: quit
	"Mark the changes file and close all files.  If save is true, save the current state of this Smalltalk in the image file.  If quit is true, then exit to the outer shell.  Note: latter part of this method runs when resuming a previously saved image. 
	1/17/96 sw: ripped out the disk-library maintenance stuff
	5/8/96 sw: report snapshot/quit to transcript as well as chgs log"
	| resuming msg sourceLink |
	save & (SourceFiles at: 2) notNil ifTrue:
		[msg _  (quit
			ifTrue: ['----QUIT----']
			ifFalse: ['----SNAPSHOT----'])
			, Date dateAndTimeNow printString.
		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.

		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.
		self logChange: msg , sourceLink.
		Transcript cr; show: msg].

	self processShutDownList.
	Cursor write show.
	save ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"
		ifFalse: [resuming _ false].
	quit & resuming not ifTrue: [self quitPrimitive].
	Cursor normal show.
	self processStartUpList.
	!
startUp
	"Open the files for sources and changes."

	self openSourceFiles.! !
!SystemDictionary methodsFor: 'housekeeping'!
condenseSources		"Smalltalk condenseSources"
	"Move all the changes onto a compacted sources file."
	| f name oldChanges classCount dir |
	dir _ FileDirectory default.

	"Write all sources with fileIndex 1"
	f _ FileStream newFileNamed: self sourcesName , '.temp'.
	f header; timeStamp.
'Condensing Sources File...'
	displayProgressAt: Sensor cursorPoint
	from: 0 to: Smalltalk classNames size
	during:
		[:bar | classCount _ 0.
		Smalltalk allClassesDo:
			[:class | bar value: (classCount _ classCount + 1).
			class fileOutOn: f moveSource: true toFile: 1]].
	f trailer; close.

	"Make a new empty changes file"
	self closeSourceFiles.
	dir rename: self changesName
		toBe: self changesName , '.old'.
	(FileStream newFileNamed: self changesName)
		header; timeStamp; close.
	LastQuitLogPosition _ 0.

	dir rename: self sourcesName
		toBe: self sourcesName , '.old'.
	dir rename: self sourcesName , '.temp'
		toBe: self sourcesName.
	self openSourceFiles.
	SelectionMenu notify: 'Source files have been rewritten!!
Check that all is well,
and then save/quit.'!
makeInternalRelease		"Smalltalk makeInternalRelease"
	(self confirm: self version , '
Is this the correct version designation?
If not, choose no, and fix it.') ifFalse: [^ self].
	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].
	Browser initialize.
	Undeclared isEmpty ifFalse: [self halt].
	Smalltalk garbageCollect.
	self obsoleteClasses isEmpty ifFalse: [self halt].
	Symbol rehash.
	self halt: 'Ready to condense changes'.
	Smalltalk condenseChanges!
recompileAllFrom: firstName 
	"Recompile all classes, starting with given name."

	Smalltalk forgetDoIts.
	self allClassesDo: 
		[:class | class name >= firstName
			ifTrue: 
				[Transcript show: class name; cr.
				class compileAll]]

	"Smalltalk recompileAllFrom: 'Aardvark'."
!
testFormatter    "Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then
	compiles that source and verifies that it generates identical code"
	 | newCodeString methodNode oldMethod newMethod |
	Smalltalk forgetDoIts.
	Smalltalk allBehaviorsDo:
		[:cls |  Transcript show: cls name; cr.
		cls selectors do:
			[:selector |
			newCodeString _ (cls compilerClass new)
				format: (cls sourceCodeAt: selector)
				in: cls notifying: nil.
			methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls notifying: nil ifFail: [].
			newMethod _ methodNode generate: #(0 0 0).
			oldMethod _ cls compiledMethodAt: selector.
			oldMethod initialPC to: oldMethod endPC do:
				[:i | (oldMethod at: i) = (newMethod at: i) ifFalse: [self halt]]]]
! !
!SystemDictionary methodsFor: 'miscellaneous'!
clipboardText
	"Get the current clipboard text. Return the empty string if the primitive fails."

	<primitive: 141>
	^ ''! !
!TAssignmentNode methodsFor: 'all'!
bindVariablesIn: aDictionary

	variable _ variable bindVariablesIn: aDictionary.
	expression _ expression bindVariablesIn: aDictionary.!
copyTree

	^self class new
		setVariable: variable copyTree
		expression: expression copyTree!
emitCCodeOn: aStream level: level generator: aCodeGen

	variable emitCCodeOn: aStream level: level generator: aCodeGen.
	aStream nextPutAll: ' = '.
	expression emitCCodeOn: aStream level: level generator: aCodeGen.!
expression

	^expression!
inlineMethodsUsing: aDictionary

	variable inlineMethodsUsing: aDictionary.
	expression inlineMethodsUsing: aDictionary.!
isAssignment

	^true!
nodesDo: aBlock

	variable nodesDo: aBlock.
	expression nodesDo: aBlock.
	aBlock value: self.!
printOn: aStream level: level

	variable printOn: aStream level: level.
	aStream nextPutAll: ' _ '.
	expression printOn: aStream level: level + 2.!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [
		variable _ variable replaceNodesIn: aDictionary.
		expression _ expression replaceNodesIn: aDictionary.
		self]!
setVariable: varNode expression: expressionNode

	variable _ varNode.
	expression _ expressionNode.!
variable

	^variable! !
!TCaseStmtNode methodsFor: 'all'!
bindVariablesIn: aDictionary

	expression _ expression bindVariablesIn: aDictionary.
	cases _ cases collect: [ :c | c bindVariablesIn: aDictionary ].!
cases

	^cases!
copyTree

	^self class new
		setExpression: expression copyTree
		firsts: firsts copy
		lasts: lasts copy
		cases: (cases collect: [ :case | case copyTree ])!
customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex
	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."

	| newCases dict newCase |
	newCases _ OrderedCollection new.
	firstIndex to: lastIndex do: [ :caseIndex |
		dict _ Dictionary new.
		dict at: varName put: (TConstantNode new setValue: caseIndex).
		newCase _ caseParseTree copyTree bindVariablesIn: dict.
		newCases addLast: newCase.
	].
	^ newCases!
customizeShortCasesForDispatchVar: varName
	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."

	| newFirsts newLasts newCases l f case sel expanded |
	newFirsts _ OrderedCollection new.
	newLasts _ OrderedCollection new.
	newCases _ OrderedCollection new.
	1 to: cases size do: [ :i |
		l _ lasts at: i.
		f _ firsts at: i.
		case _ cases at: i.
		expanded _ false.
		(l - f) > 1 ifTrue: [  "case code covers multiple cases"
			case nodeCount < 100 ifTrue: [
				newFirsts addAll: (f to: l) asArray.
				newLasts addAll: (f to: l) asArray.
				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).
				expanded _ true.
			].
		].
		expanded ifFalse: [
			newFirsts addLast: f.
			newLasts addLast: l.
			newCases addLast: case.
		].
	].
	firsts _ newFirsts asArray.
	lasts _ newLasts asArray.
	cases _ newCases asArray.
!
emitCCodeOn: aStream level: level generator: aCodeGen

	| indent |
	indent _ (String new: level) collect: [ :ch | Character tab ].
	aStream nextPutAll: 'switch ('.
	expression emitCCodeOn: aStream level: level generator: aCodeGen.
	aStream nextPutAll: ') {'; cr.
	1 to: cases size do: [ :i |
		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |
			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.
		].
		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.
		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.
		aStream cr.
	].
	level timesRepeat: [ aStream tab ].
	aStream nextPutAll: '}'.!
expression

	^expression!
inlineMethodsUsing: aDictionary

	expression inlineMethodsUsing: aDictionary.
	cases do: [ :c | c inlineMethodsUsing: aDictionary ].!
isCaseStmt

	^true!
nodesDo: aBlock

	expression nodesDo: aBlock.
	cases do: [ :c | c nodesDo: aBlock ].
	aBlock value: self.!
printOn: aStream level: level

	aStream crtab: level.
	aStream nextPutAll: 'select '.
	expression printOn: aStream level: level.
	aStream nextPutAll: ' in'.
	1 to: cases size do: [ :i |
		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |
			aStream crtab: level.
			aStream nextPutAll: 'case ', caseIndex printString, ':'.
		].
		aStream crtab: level + 1.
		(cases at: i) printOn: aStream level: level + 1.
	].
	aStream crtab: level.
	aStream nextPutAll: 'end select'.!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [
		expression _ expression replaceNodesIn: aDictionary.
		cases _ cases collect: [ :c | c replaceNodesIn: aDictionary ].
		self]!
setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList

	expression _ aNode.
	firsts _ firstsList.
	lasts _ lastsList.
	cases _ caseList.!
setExpression: aNode selectors: selectorList
	"Initialize the node from the given set of selectors."
	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."

	| selfNode stmt lastSel firstInRun sel |
	expression _ aNode.
	selfNode _ TVariableNode new setName: 'self'.
	firsts _ OrderedCollection new: 400.
	lasts _ OrderedCollection new: 400.
	cases _ OrderedCollection new: 400.
	lastSel _ selectorList first.
	firstInRun _ 0.
	1 to: selectorList size do: [ :i |
		sel _ selectorList at: i.
		sel ~= lastSel ifTrue: [
			firsts add: firstInRun.
			lasts add: i - 2.
			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().
			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).
			lastSel _ sel.
			firstInRun _ i - 1.
		].
	].
	firsts add: firstInRun.
	lasts add: selectorList size - 1.
	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().
	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !
!TConstantNode methodsFor: 'all'!
copyTree

	^self class new
		setValue: value!
emitCCodeOn: aStream level: level generator: aCodeGen
	"Emit a C literal."

	aStream nextPutAll: (aCodeGen cLiteralFor: value).!
isConstant

	^true!
isLeaf

	^true!
printOn: aStream level: level

	value storeOn: aStream.!
setValue: anObject

	value _ anObject.!
value

	^value! !

TempVariableNode comment:
'I am a parse tree leaf representing a temporary variable'!
!TempVariableNode methodsFor: 'initialize-release'!
isArg: aBoolean

	isAnArg _ aBoolean.
	isAnArg ifTrue: [hasDefs _ true]!
name: varName index: i type: type scope: level
	"Only used for initting temporary variables"
	name _ varName.
	self key: varName
		index: i
		type: type.
	isAnArg _ hasDefs _ hasRefs _ false.
	scope _ level!
nowHasDef
	hasDefs _ true!
nowHasRef
	hasRefs _ true!
scope: level
	"Note scope of temporary variables.
	Currently only the following distinctions are made:
		0	outer level: args and user-declared temps
		1	block args and doLimiT temps
		-1	a block temp that is no longer active
		-2	a block temp that held limit of to:do:"
	scope _ level! !
!TempVariableNode methodsFor: 'testing'!
assignmentCheck: encoder at: location

	isAnArg ifTrue: [^ location]
			ifFalse: [^ -1]!
isArg
	^ isAnArg!
isTemp
	^ true!
isUndefTemp
	^ hasDefs not!
isUnusedTemp
	^ hasRefs not!
scope
	^ scope! !
!TempVariableNode methodsFor: 'printing'!
printOn: aStream indent: level 
	aStream withAttribute: (TextColor color: Color blue)
			do: [aStream nextPutAll: name]! !
!TestCClass1 methodsFor: 'all'!
arg1: a arg2: b
	"CCodeGenerator new initialize addClass: TestCClass1"

	| i j k |
	self var: #i declareC: 'char *i'.
	i _ 'abc'.
	j _ 2.
	k _ 3.!
ifTests

	true ifTrue: [
		self print: 'true case'
	].

	true ifFalse: [
		self print: 'false case'
	].

	true ifTrue: [
		self print: 'true case'
	] ifFalse: [
		self print: 'false case'
	].

	true ifFalse: [
		self print: 'false case'
	] ifTrue: [
		self print: 'true case'
	].!
loopTests
	| v |
	v _ 0.
	[v < 10] whileTrue: [ self printNum: v.  v _ v + 1 ].
	self print: ''.
	[v < 1] whileFalse: [ self printNum: v.  v _ v - 1 ].
	self print: ''.
	1 to: 10 do: [ :i | self printNum: i ].
	self print: ''.
	1 to: 10 by: 2 do: [ :i | self printNum: i ].
	self print: ''.!
method1
	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"

	x & y ifTrue: [
		x _ 10.
		y _ 20.
	].
	y _ nil + 3.
	x = nil ifTrue: [ x _ 18 ].
	^nil!
method2

	self method1; method8: 0; setX: 10 Y: 20.!
method3

	x > 0 ifTrue: [ ^x ] ifFalse: [ ^y ].!
method4

	x _ 0.
	y _ 0.
	[x < 100] whileTrue: [
		y _ y + x.
		x _ x + 1.
	].
	^y!
method5

	x & y.
	x | y.
	x and: [y].
	x or: [y].
	x not.

	x + y.
	x - y.
	x * y.
	x // y.
	x \\ y.
	x min: y.
	x max: y.

	x bitAnd: y.
	x bitOr: y.
	x bitXor: y.
	x bitInvert32.
	x bitShift: y.
	x >> y.
	x << y.

	x < y.
	x <= y.
	x = y.
	x >= y.
	x > y.
	x ~= y.
	x == y.
	x isNil.
	x notNil.

	[x > y] whileTrue: [ x _ x + 1 ].
	[x > y] whileFalse: [ x _ x + 1 ].

	x > y ifTrue: [ x _ x - 1 ].
	x > y ifFalse: [ x _ x + 1 ].
	x > y ifTrue: [ x _ x - 1] ifFalse: [ x _ x + 1 ].
	x > y ifFalse: [ x _ x + 1] ifTrue: [ x _ x - 1 ].

	x at: 3.
	x at: 3 put: y.

	self integerValueOf: 5.
	self integerObjectOf: 3 + 5.
	x preDecrement.
	y preIncrement > 0 ifTrue: [ x _ x + 1 ].
!
method6

	self dispatchOn: x in: #(f1 f2 f3 f4 f5).!
method8: arg

	| a |
	self returnTypeC: 'float'.
	self var: #a    declareC: 'float a = 0'.
	self var: #arg declareC: 'float arg'.
	self cCode: 'a = arg * 3.14159'.
	^a!
print: val

	self cCode: 'printf("%d\n", val)'.!
printNum: i

	self cCode: 'printf("%d ", i)'.!
setX: newX Y: newY

	x _ newX min: newY.
	y _ newY.! !
!TestCClass2 methodsFor: 'all'!
atAllPut

	| i |
	i _ VectSize.
	[i > 0] whileTrue: [
		vect at: i put: 5.
		i _ i - 1.
	].
	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].!
error: s
	"Print an error message and exit."

	self print: 'Error in %s\n' f: s.
	self exit: -1.!
incrementAll

	| oldVal i |
	oldVal _ vect at: 1.
	i _ VectSize.
	[i > 0] whileTrue: [
		vect at: i put: ((vect at: i) + 1).
		i _ i - 1.
	].
	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].!
initialize

	VectSize _ 10000.
	vect _ Array new: VectSize.!
main

	| startTicks ticks |
	self printf: 'atAllPut: '.
	startTicks _ self clock.
	self atAllPut.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.

	self printf: 'incrementAll: '.
	self incrementAll.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.

	self printf: 'nestedWhileLoop: '.
	self nestedWhileLoop.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.

	self printf: 'sieve: '.
	self sieve.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.

	self printf: 'sumAll: '.
	self sumAll.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.

	self printf: 'sumFromTo: '.
	self sumFromTo.
	ticks _ self clock - startTicks.
	self print: '%ld\n' f: ticks.!
nestedWhileLoop

	| sum i j |
	sum _ 0.
	i _ 1000.
	[i > 0] whileTrue: [
		j _ 100.
		[j > 0] whileTrue: [
			sum _ sum + 1.
			j _ j - 1.
		].
		i _ i - 1.
	].
	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].!
sieve

	| flagsSize flags primeCount i k |
	flagsSize _ 8190.
	flags _ Array new: flagsSize.
	i _ flagsSize.
	[i > 0] whileTrue: [
		flags at: i put: true.
		i _ i - 1.
	].

	primeCount _ 0.
	i _ 2.
	[i <= flagsSize] whileTrue: [
		(flags at: i) ifTrue: [
			primeCount _ primeCount + 1. "i is a prime"
			k _ i + i.
			[k <= flagsSize] whileTrue: [
				flags at: k put: false. "k is not a prime; it is a multiple of i"
				k _ k + i.
			].
		].
		i _ i + 1.
	].

	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].!
sumAll

	| elementVal sum i |
	elementVal _ vect at: 1.
	sum _ 0.
	i _ VectSize.
	[i > 0] whileTrue: [
		sum _ sum + (vect at: i).
		i _ i - 1.
	].
	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].!
sumFromTo

	| sum i j |
	i _ 10.
	[i > 0] whileTrue: [
		sum _ 0.
		j _ 10000.
		[j > 0] whileTrue: [
			sum _ sum + j.
			j _ j - 1.
		].
		i _ i - 1.
	].
	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].! !
!TestCClass2 class methodsFor: 'testing'!
test
	"TestCClass2 test"
	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"

	| bm |
	bm _ self new initialize.
	Transcript show: 'atAllPut: '.
	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.
	Transcript show: 'incrementAll: '.
	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.
	Transcript show: 'nestedWhileLoop: '.
	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.
	Transcript show: 'sieve: '.
	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.
	Transcript show: 'sumAll: '.
	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.
	Transcript show: 'sumFromTo: '.
	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.! !
!TestCClass3 methodsFor: 'all'!
dispatchOn: anInteger in: selectorArray
	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (anInteger + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."
	"Note: Delete this method from the generated code."

	"assert: (anInteger >= 0) | (anInteger < selectorArray size)"
	self perform: (selectorArray at: (anInteger + 1)).!
f1

	| local r |
	local _ self functionWithLabel: 1.
	r _ 7.
	self print: 'f1'.!
f2

	| local i |
	local _ 2.
	i _ self functionWithLabel: -2.
	i > 0 ifTrue: [ ^ -1 ].
	self print: 'f2'.!
f3

	self print: 'f3'.!
f4

	self print: 'f4'.!
f5

	self print: 'f5'.!
functionWithLabel: arg

	arg > 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].!
main
	"TestCClass3 new main"
	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"

	0 to: 9 do: [ :i |
		self dispatchOn: i in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).
	].
!
print: s

	self var: #s declareC: 'char *s'.
	self cCode: 'printf("%s", s)'.! !

Text comment:
'I represent a String that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set (Array actually) of TextAttributes with each character in its character string.  These attributes include mainly a font number and possibly some other emphasis.  Font numbers are interpreted relative to a TextStyle, which may be a copy of the default, or some other textStyle stored, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.'!
!Text methodsFor: 'emphasis'!
addAttribute: att 
	^ self addAttribute: att from: 1 to: self size!
addAttribute: att from: start to: stop 
	"Set the attribute for characters in the interval start to stop."
	runs _  runs copyReplaceFrom: start to: stop
			with: ((runs copyFrom: start to: stop)
				mapValues:
				[:attributes | Text addAttribute: att toArray: attributes])
!
allBold 
	"Force this whole text to be bold."
	string size = 0 ifTrue: [^self].
	self makeBoldFrom: 1 to: string size!
attributesAt: characterIndex 
	"Answer the code for characters in the run beginning at characterIndex."
	| attributes |
	self size = 0
		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"
	attributes _ runs at: characterIndex.
	attributes isNumber
		ifTrue: [^ Array with: (TextFontChange new fontNumber: attributes)].  "backward compat"
	^ attributes
	!
emphasizeFrom: start to: stop with: emphasis
	"Set the emphasis for characters in the interval start to stop."
	runs _ 
		runs
			copyReplaceFrom: start
			to: stop
			with: (RunArray new: stop - start + 1 withAll: 
					(Array with: (TextFontChange new fontNumber: emphasis)))!
fontNumberAt: characterIndex 
	"Answer the fontNumber for characters in the run beginning at characterIndex."
	| attributes fontNumber |
	self size = 0 ifTrue: [^1].	"null text tolerates access"
	attributes _ runs at: characterIndex.
	attributes isNumber ifTrue: [^ attributes].  "Backward compatibility"
	fontNumber _ 1.
	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].
	^ fontNumber
	!
makeBoldFrom: start to: stop

	^ self addAttribute: TextEmphasis bold from: start to: stop! !
!Text methodsFor: 'private'!
becomeModern	"Text allInstancesDo: [:txt | txt becomeModern]" 
	runs mapValues:
	[:val | val isNumber
		 ifTrue: [val = 0 ifTrue: [Array new]
					ifFalse: [val\\3=0
							ifTrue: [Array with: (TextFontChange fontNumber: val//3+1)]
							ifFalse: [Array with: (TextFontChange fontNumber: val//3+1)
										with: (TextEmphasis perform: (#(bold italic) at: val\\3))]]]
		ifFalse: [val]]!
checkModern	"Text allInstancesDo: [:txt | txt checkModern]" 
	runs values do: [:val | val isNumber ifTrue: [self halt]]! !
!Text class methodsFor: 'class initialization'!
initialize	"Text initialize"
	"Initialize constants shared by classes associated with text display."

	TextConstants at: #CaretForm put:
				(Form extent: 16@5
					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)
					offset: -3@0).
	self initTextConstants! !
!Text class methodsFor: 'instance creation'!
fromString: aString 
	"Answer an instance of me whose characters are those of the argument, 
	aString."

	^self string: aString attribute: (TextFontChange fontNumber: 1)!
fromUser
	"Answer an instance of me obtained by requesting the user to type some 
	characters into a prompter (a FillInTheBlank object)."

	FillInTheBlank
		request: 'Type text followed by carriage return'
		displayAt: (50@ Display boundingBox height//2)
		centered: false
		action: [:result]
		initialAnswer: ''.
	^self fromString: result!
streamContents: blockWithArg 
	| stream |
	stream _ TextStream on: (self new: 400).
	blockWithArg value: stream.
	^ stream contents!
string: aString attribute: att
	"Answer an instance of me whose characters are aString.
	att is a TextAttribute."

	^self string: aString attributes: (Array with: att)!
string: aString attributes: atts
	"Answer an instance of me whose characters are those of the argument, 
	aString. atts is an array of TextAttributes."

	^self string: aString runs: (RunArray new: aString size withAll: atts)!
string: aString emphasis: code
	"Answer an instance of me whose characters are those of the argument, 
	aString. Use the font whose index into the default TextStyle font array is 
	code."

	code isNumber ifTrue:
		[^ self string: aString runs: (RunArray new: aString size withAll: 
			(Array with: (TextFontChange new fontNumber: code)))].
	^ self string: aString attributes: code! !
!Text class methodsFor: 'private'!
addAttribute: att toArray: others 
	"Add a new text attribute to an existing set"
	| oldEmph |
	^ Array streamContents:
		[:strm | others do:
			[:other | other isNumber
				ifTrue: [oldEmph _ TextFontChange new fontNumber: other.
						(att dominates: oldEmph) ifFalse: [strm nextPut: oldEmph]]
				ifFalse: [(att dominates: other) ifFalse: [strm nextPut: other]]].
		att set ifTrue: [strm nextPut: att]]! !
!TextAction methodsFor: 'as yet unclassified'!
actOnClickFor: anObject
	"Note: evalString gets evaluated IN THE CONTEXT OF anObject
	 -- meaning that self and all instVars are accessible"
	Compiler evaluate: evalString for: anObject logged: false.
	^ true!
emphasizeScanner: scanner
	"Set the emphasis for text display"
	scanner textColor: Color cyan!
evalString: str
	evalString _ str! !
!TextAction class methodsFor: 'as yet unclassified'!
evalString: str
	^ self new evalString: str! !
!TextAttribute methodsFor: 'as yet unclassified'!
actOnClickFor: model
	"Subclasses may override to provide, eg, hot-spot actions"
	^ false!
dominates: another
	"Subclasses may override condense multiple attributes"
	^ false!
emphasizeScanner: scanner
	"Subclasses may override to set, eg, font, color, etc"!
oldEmphasisCode: default
	"Allows running thorugh possibly multiple attributes
	and getting the emphasis out of any that has an emphasis (font number)"
	^ default!
set
	"Respond true to include this attribute (as opposed to, eg, a bold
	emphasizer that is clearing the property"
	^ true! !
!TextColor methodsFor: 'as yet unclassified'!
= other 
	^ (other isMemberOf: self class) 
		and: [other color = color]!
color
	^ color!
color: aColor
	color _ aColor!
dominates: other
	^ other isMemberOf: self class!
emphasizeScanner: scanner
	"Set the emphasis for text display"
	scanner textColor: color!
printOn: strm
	super printOn: strm.
	strm nextPutAll: ' code: '; print: color! !
!TextColor class methodsFor: 'as yet unclassified'!
black
	^ self new color: Color black!
blue
	^ self new color: Color blue!
color: aColor
	^ self new color: aColor!
cyan
	^ self new color: Color cyan!
green
	^ self new color: Color green!
magenta
	^ self new color: Color magenta!
red
	^ self new color: Color red!
yellow
	^ self new color: Color yellow! !
!TextEmphasis methodsFor: 'as yet unclassified'!
= other 
	^ (other isMemberOf: self class) 
		and: [other emphasisCode = emphasisCode]!
dominates: other
	(emphasisCode = 0 and: [other isMemberOf: TextAction]) ifTrue: [^ true].
	^ (other isMemberOf: self class)
		and: [emphasisCode = 0
			or: [emphasisCode = other emphasisCode]]!
emphasisCode
	^ emphasisCode!
emphasisCode: int
	emphasisCode _ int.
	setMode _ true!
emphasizeScanner: scanner
	"Set the emphasist for text display"
	scanner addEmphasis: emphasisCode!
printOn: strm
	super printOn: strm.
	strm nextPutAll: ' code: '; print: emphasisCode!
set
	^ setMode and: [emphasisCode ~= 0]!
turnOff
	setMode _ false! !
!TextEmphasis class methodsFor: 'as yet unclassified'!
bold
	^ self new emphasisCode: 1!
italic
	^ self new emphasisCode: 2!
narrow
	^ self new emphasisCode: 8!
normal
	^ self new emphasisCode: 0!
struckOut
	^ self new emphasisCode: 16!
underlined
	^ self new emphasisCode: 4! !
!TextFontChange methodsFor: 'as yet unclassified'!
= other 
	^ (other isMemberOf: self class) 
		and: [other fontNumber = fontNumber]!
dominates: other
	^ other isMemberOf: self class!
emphasizeScanner: scanner
	"Set the font for text display"
	scanner setFont: fontNumber!
fontNumber
	^ fontNumber!
fontNumber: int
	fontNumber _ int!
printOn: strm
	super printOn: strm.
	strm nextPutAll: ' font: '; print: fontNumber! !
!TextFontChange class methodsFor: 'as yet unclassified'!
font1
	^ self new fontNumber: 1!
font2
	^ self new fontNumber: 2!
font3
	^ self new fontNumber: 3!
font4
	^ self new fontNumber: 4!
fontNumber: n
	^ self new fontNumber: n! !
!TextFontReference methodsFor: 'as yet unclassified'!
emphasizeScanner: scanner
	"Set the actual font for text display"
	scanner setActualFont: font!
toFont: aFont

	font _ aFont! !
!TextFontReference class methodsFor: 'as yet unclassified'!
toFont: aFont
	^ self new toFont: aFont! !
!TextLineInterval methodsFor: 'accessing'!
baseline
	^ baseline!
lineHeight
	^ lineHeight! !
!TextLineInterval methodsFor: 'private'!
lineHeight: height baseline: ascent

	lineHeight _ height.
	baseline _ ascent! !
!TextLineInterval class methodsFor: 'instance creation'!
start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger
	"Answer an instance of me with the arguments as the start, stop points, 
	number of spaces in the line, and width of the padding."
	| newSelf |
	newSelf _ super from: startInteger to: stopInteger by: 1.
	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !
!TextLinkToImplementors methodsFor: 'as yet unclassified'!
actOnClickFor: modelIgnored
	Smalltalk browseAllImplementorsOf: selector.
	^ true!
emphasizeScanner: scanner
	"Set the emphasis for text display"
	scanner textColor: Color red!
selector: sel
	selector _ sel! !
!TextLinkToImplementors class methodsFor: 'as yet unclassified'!
of: selector
	^ self new selector: selector! !
!TextStream methodsFor: 'as yet unclassified'!
applyAttribute: att beginningAt: startPos
	collection addAttribute: att from: startPos to: self position!
nextPutAll: aCollection 
	"Optimized access to get around Text at:Put: overhead"
	| n |
	n _ aCollection size.
	((aCollection isMemberOf: String) not or: [position + n > writeLimit])
		ifTrue: [^ super nextPutAll: aCollection].
	collection string
		replaceFrom: position+1
		to: position + n
		with: aCollection
		startingAt: 1.
	position _ position + n!
withAttribute: att do: strmBlock
	| pos1 val |
	pos1 _ self position.
	val _ strmBlock value.
	collection addAttribute: att from: pos1+1 to: self position.
	^ val! !
!TextStyle methodsFor: 'accessing'!
centered
	alignment _ 2!
justified
	alignment _ 3!
leading
	"Leading (from typographers historical use of extra lead (type metal))
	is the extra spacing above and beyond that needed just to accomodate
	the various font heights in the set."
	^ leading!
leading: yDelta

	leading _ yDelta!
leftFlush
	alignment _ 0!
rightFlush
	alignment _ 1! !
!TextStyle methodsFor: 'private'!
consolidate
	"If this style includes any fonts that are also in the default style,
	then replace them with references to the default ones."
"
	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]
"
	| defFonts font |
	defFonts _ TextStyle default fontArray.
	1 to: fontArray size do:
		[:i | font _ fontArray at: i.
		1 to: defFonts size do:
			[:j | (font name asUppercase copyWithout: $ )
			= ((defFonts at: j) name asUppercase copyWithout: $ )
			ifTrue: [fontArray at: i put: (defFonts at: j)]]]!
gridForFont: fontIndex withLead: leadInteger 
	"Force whole style to suit one of its fonts. Assumes only one font referred
	to by runs."
	| font |
	font _ self fontAt: fontIndex.
	self lineGrid: font height + leadInteger.
	self baseline: font ascent.
	self leading: leadInteger!
newFontArray: anArray
	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  
	8/20/96 tk, Make size depend on first font."

	fontArray _ anArray.
	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"
	baseline _ (fontArray at: 1) ascent + leading.
	alignment _ 0.
	firstIndent _ 0.
	restIndent _ 0.
	rightIndent _ 0.
	tabsArray _ DefaultTabsArray.
	marginTabsArray _ DefaultMarginTabsArray
"
TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray].
"! !
!TextStyle class methodsFor: 'instance creation'!
initDefaultFontsAndStyle
	"This provides the system with 10 and 12-pt basal fonts.
	Bold and italic versions will be automatically generated as needed"
	| fontArray |	
	fontArray _ Array new: 2.
	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').
	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').
	TextConstants at: #DefaultTextStyle put:
		(TextStyle fontArray: fontArray).

	"TextStyle initDefaultFontsAndStyle."!
initialize  "TextStyle initialize"
	"Just for installing new text changes; then throw away"
	TextStyle allInstancesDo: [:s | s leading: 2]!
new
	^ super new leading: 2! !
!TGoToNode methodsFor: 'all'!
copyTree

	^self class new setLabel: label!
emitCCodeOn: aStream level: level generator: aCodeGen
	"Emit a C goto statement."

	aStream nextPutAll: 'goto '.
	aStream nextPutAll: label.!
isGoTo

	^true!
label

	^label!
printOn: aStream level: level

	aStream nextPutAll: 'goto '.
	aStream nextPutAll: label.!
setLabel: aString

	label _ aString.! !
!Time class methodsFor: 'instance creation'!
fromSeconds: secondCount 
	"Answer an instance of me that is secondCount number of seconds since midnight."

	| secondsInHour hours secs |
	secs _ secondCount asInteger.
	hours _ secs // 3600.
	secondsInHour _ secs \\ 3600.
	^self new hours: hours
			   minutes: secondsInHour // 60
			   seconds: secondsInHour \\ 60! !
!TLabeledCommentNode methodsFor: 'all'!
copyTree

	^self class new
		setLabel: label
		comment: comment!
emitCCodeOn: aStream level: level generator: aCodeGen
	"Emit a C comment with optional label."

	self printOptionalLabelOn: aStream.
	aStream nextPutAll: '/* '.
	aStream nextPutAll: comment.
	aStream nextPutAll: ' */'.!
isComment
	"Answer true if the receiver is just a comment (i.e., it has no label)."

	^label = nil!
isLabel

	^true!
isLeaf

	^true!
label

	^label!
printOn: aStream level: level

	self printOptionalLabelOn: aStream.
	aStream nextPut: $".
	aStream nextPutAll: comment.
	aStream nextPut: $".!
printOptionalLabelOn: aStream

	label ~= nil ifTrue: [
		self unindentOneTab: aStream.
		aStream nextPutAll: label.
		aStream nextPut: $:.
		aStream tab.	
	].!
setComment: commentString

	label _ nil.
	comment _ commentString.!
setLabel: labelString

	label _ labelString.!
setLabel: labelString comment: commentString

	label _ labelString.
	comment _ commentString.!
unindentOneTab: aStream
	"Remove the last tab from the given stream if possible."

	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].
	aStream position > 0 ifTrue: [
		aStream position: aStream position - 1.
		"restore stream position if previous char was not a tab"
		aStream peek = Character tab ifFalse: [ aStream next ].
	].! !
!TMethod methodsFor: 'initialization'!
setSelector: sel args: argList locals: localList block: aBlockNode
	"Initialize this method using the given information."

	selector _ sel.
	returnType _ 'int'. 	 "assume return type is int for now"
	args _ argList asOrderedCollection collect: [ :arg | arg key ].
	locals _ localList asOrderedCollection collect: [ :arg | arg key ].
	declarations _ Dictionary new.
	parseTree _ aBlockNode asTranslatorNode.
	labels _ OrderedCollection new.
	complete _ false.		"set to true when all possible inlining has been done"

	self removeFinalSelfReturn.
	self recordDeclarations.!
setSelector: sel returnType: retType args: argList locals: localList declarations: decls parseTree: aNode labels: labelList complete: completeFlag
	"Initialize this method using the given information. Used for copying."

	selector _ sel.
	returnType _ retType.
	args _ argList.
	locals _ localList.
	declarations _ decls.
	parseTree _ aNode.
	labels _ labelList.
	complete _ completeFlag.! !
!TMethod methodsFor: 'accessing'!
args
	"The arguments of this method."

	^args!
declarations
	"The type declaration dictionary of this method."

	^declarations!
isComplete
	"A method is 'complete' if it does not contain any more inline-able calls."

	^complete!
labels

	^labels!
locals
	"The local variables of this method."

	^locals!
parseTree
	"The parse tree of this method."

	^parseTree!
parseTree: aNode
	"Set the parse tree of this method."

	parseTree _ aNode.!
returnType
	"The type of the values returned by this method. This string will be used in the C declaration of this function."

	^returnType!
selector
	"The Smalltalk selector of this method."

	^selector!
selector: newSelector

	selector _ newSelector.!
statements

	parseTree isStmtList
		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].
	((parseTree args = nil) or: [parseTree args isEmpty])
		ifFalse: [ self error: 'expected method parse tree to have no args' ].

	^parseTree statements! !
!TMethod methodsFor: 'primitive compilation'!
argConversionExprFor: varName stackIndex: stackIndex
	"Return the parse tree for an expression that fetches and converts the primitive argument at the given stack offset."

	| expr decl meth |
	expr _ '(self longAt: stackPointer - ( ', stackIndex printString, ' * 4))'.
	(declarations includesKey: varName) ifTrue: [  "array"
		decl _ declarations at: varName.
		(decl includes: $*) ifTrue: [
			expr _ varName, ' _ self arrayValueOf: ', expr.
		] ifFalse: [  "must be a double"
			((decl findString: 'double' startingAt: 1) = 0)
				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].
			expr _ varName, ' _ self floatValueOf: ', expr.
		].
	] ifFalse: [  "undeclared variables are taken to be integer"
		expr _ varName, ' _ self checkedIntegerValueOf: ', expr.
	].

	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements!
checkSuccessExpr
	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."

	| expr meth |
	expr _ 'successFlag ifFalse: [ ^ nil ]'.
	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements
!
covertToZeroBasedArrayReferences
	"Replace the index expressions in at: and at:put: messages with (<expr> - 1), since C uses zero-based array indexing."

	| oldIndexExpr newIndexExpr |
	parseTree nodesDo: [ :n |
		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [
			oldIndexExpr _ n args first.
			oldIndexExpr isConstant ifTrue: [
				"index expression is a constant: decrement the constant now"
				newIndexExpr _ TConstantNode new setValue: (n args first value - 1).
			] ifFalse: [
				"index expression is complex: build an expression to decrement result at runtime"
				newIndexExpr _ TSendNode new
					setSelector: #-
					receiver: oldIndexExpr
					arguments: (Array with: (TConstantNode new setValue: 1)).
			].
			n args at: 1 put: newIndexExpr.
		].
	].
!
fetchRcvrExpr
	"Return the parse tree for an expression that fetches the receiver from the stack."

	| expr meth |
	expr _ 'rcvr _ self longAt: stackPointer - (', args size printString, ' * 4)'.
	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements
!
instVarGetExprFor: varName offset: instIndex
	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."

	| decl expr meth |
	(declarations includesKey: varName) ifTrue: [
		decl _ declarations at: varName.
		(decl includes: $*) ifTrue: [  "array"
			expr _ varName, ' _ self fetchArray: ', instIndex printString, ' ofObject: rcvr'.
		] ifFalse: [  "must be a double"
			((decl findString: 'double' startingAt: 1) = 0)
				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].
			expr _ varName, ' _ self fetchFloat: ', instIndex printString, ' ofObject: rcvr'.
		].
	] ifFalse: [  "undeclared variables are taken to be integer"
		expr _ varName, ' _ self fetchInteger: ', instIndex printString, ' ofObject: rcvr'.
	].

	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements
!
instVarPutExprFor: varName offset: instIndex
	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."

	| expr meth |
	(declarations includesKey: varName) ifTrue: [
		self error: 'a primitive method can only modify integer instance variables'.
	].
	expr _ 'self storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.
	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements
!
popArgsExpr
	"Return the parse tree for an expression that removes the primitive's arguments from the stack."

	| expr meth |
	expr _ 'self pop: ', args size printString.
	meth _ (Compiler new parse: 'temp ', expr in: Object notifying: nil) asTMethodFromClass: Object.
	^ meth statements
!
preparePrimitiveInClass: aClass
	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.

The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:

	int *		-- an array of 32-bit values (e.g., a BitMap)
	short *		-- an array of 16-bit values (e.g., a SoundBuffer)
	char *		-- an array of unsigned bytes (e.g., a String)
	double		-- a double precision floating point number (e.g., 3.14159)

Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints."

"Current restrictions:
	o method must not contain explicit returns
	o method must not contain message sends
	o method must not allocate objects
	o method must not manipulate raw oops
	o method cannot access class variables
	o compiled primitives can only return self"

	| prolog postlog instVarsUsed varsAssignedTo instVarList varName |
	prolog _ OrderedCollection new.
	postlog _ OrderedCollection new.
	instVarsUsed _ self freeVariableReferences asSet.
	varsAssignedTo _ self variablesAssignedTo asSet.
	instVarList _ aClass allInstVarNames.

	"add receiver fetch to prolog"
	prolog addAll: self fetchRcvrExpr.

	"add arg conversions to prolog"
	1 to: args size do: [ :argIndex |
		varName _ args at: argIndex.
		prolog addAll: (self argConversionExprFor: varName stackIndex: args size - argIndex).
	].

	"add instance variable fetches to prolog and instance variable stores to postlog"
	1 to: instVarList size do: [ :varIndex |
		varName _ instVarList at: varIndex.
		(instVarsUsed includes: varName) ifTrue: [
			locals add: varName.
			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).
			(varsAssignedTo includes: varName) ifTrue: [
				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1).
			].
		].
	].

	prolog addAll: self checkSuccessExpr.
	postlog addAll: self popArgsExpr.

	locals addAllFirst: args.
	locals addFirst: 'rcvr'.
	args _ args class new.
	locals asSet size = locals size
		ifFalse: [ self error: 'local name conflicts with instance variable name' ].
	self hasReturn
		ifTrue: [ self error: 'returns in primitive methods are not yet supported' ].

	selector _ 'prim', aClass name, selector.
	parseTree setStatements: prolog, parseTree statements, postlog.
	self covertToZeroBasedArrayReferences.
! !
!TMethod methodsFor: 'transformations'!
bindClassVariablesIn: constantDictionary
	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."

	parseTree _ parseTree bindVariablesIn: constantDictionary.!
buildCaseStmt: aSendNode
	"Build a case statement node for the given send of dispatchOn:in:."
	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."

	((aSendNode args size = 2) and:
	 [aSendNode args last isConstant and:
	 [aSendNode args last value class = Array]]) ifFalse: [
		self error: 'wrong node structure for a case statement'.
	].

	^TCaseStmtNode new
		setExpression: aSendNode args first
		selectors: aSendNode args last value!
prepareMethodIn: aCodeGen
	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."
	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."

	| stmts stmt |
	parseTree nodesDo: [ :node |
		node isSend ifTrue: [
			"record sends of builtin operators"
			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].
		].
		node isStmtList ifTrue: [
			"replace dispatchOn:in: with case statement node"
			stmts _ node statements.
			1 to: stmts size do: [ :i |
				stmt _ stmts at: i.
				(stmt isSend and: [stmt selector = #dispatchOn:in:]) ifTrue: [
					stmts at: i put: (self buildCaseStmt: stmt).
				].
			].
		].
	].!
recordDeclarations
	"Record C type declarations of the forms

		self returnTypeC: 'float'.
		self var: #foo declareC: 'float foo'

	 and remove the declarations from the method body."

	| newStatements isDeclaration |
	newStatements _ OrderedCollection new: parseTree statements size.
	parseTree statements do: [ :stmt |
		isDeclaration _ false.
		stmt isSend ifTrue: [
			stmt selector = #var:declareC: ifTrue: [
				isDeclaration _ true.
				declarations at: stmt args first value asString put: stmt args last value.
			].
			stmt selector = #returnTypeC: ifTrue: [
				isDeclaration _ true.
				returnType _ stmt args last value.
			].
		].
		isDeclaration ifFalse: [
			newStatements add: stmt.
		].
	].
	parseTree setStatements: newStatements asArray.!
removeFinalSelfReturn
	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."

	| stmtList lastStmt |
	stmtList _ parseTree statements asOrderedCollection.
	lastStmt _ stmtList last.

	((lastStmt isReturn) and:
	 [(lastStmt expression isVariable) and:
	 [lastStmt expression name = 'self']]) ifTrue: [
		stmtList removeLast.
		parseTree setStatements: stmtList.
	].! !
!TMethod methodsFor: 'utilities'!
allCalls
	"Answer a collection of selectors for the messages sent by this method."

	^parseTree allCalls!
copy
	"Make a deep copy of this TMethod."

	^self class basicNew
		setSelector: selector
		returnType: returnType
		args: args copy
		locals: locals copy
		declarations: declarations copy
		parseTree: parseTree copyTree
		labels: labels copy
		complete: complete!
freeVariableReferences
	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."

	| refs |
	refs _ Set new.
	parseTree nodesDo: [ :node |
		node isVariable ifTrue: [ refs add: node name asString ].
	].
	args do: [ :var | refs remove: var asString ifAbsent: [] ].
	locals do: [ :var | refs remove: var asString ifAbsent: [] ].
	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].
	^ refs asSortedCollection!
hasNoCCode
	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."

	declarations isEmpty ifFalse: [ ^ false ].

	parseTree nodesDo: [ :node |
		node isSend ifTrue: [
			node selector = #cCode: ifTrue: [ ^ false ].
		].
	].
	^ true!
nodeCount
	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."

	| cnt |
	cnt _ 0.
	parseTree nodesDo: [ :n | cnt _ cnt + 1 ].
	^cnt!
variablesAssignedTo
	"Answer a collection of variables assigned to by this method."

	| refs |
	refs _ Set new.
	parseTree nodesDo: [ :node |
		node isAssignment ifTrue: [ refs add: node variable name ].
	].
	^ refs! !
!TMethod methodsFor: 'inlining'!
argAssignmentsFor: meth args: argList in: aCodeGen
	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."
	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."

	| stmtList substitutionDict |
	stmtList _ OrderedCollection new: 16.
	substitutionDict _ Dictionary new.
	meth args with: argList do: [ :argName :exprNode |
		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [
			substitutionDict at: argName asSymbol put: exprNode.
			locals remove: argName.
		] ifFalse: [
			stmtList add: (TAssignmentNode new
				setVariable: (TVariableNode new setName: argName)
				expression: exprNode copyTree).
		].
	].
	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).
	^stmtList!
checkForCompleteness: stmtLists in: aCodeGen
	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."

	complete _ true.
	stmtLists do: [ :stmtList |
		stmtList statements do: [ :node |
			(self inlineableSend: node in: aCodeGen) ifTrue: [
				complete _ false.  "more inlining to do"
				^self
			].
		].
	].
	parseTree nodesDo: [ :n |
		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [
			complete _ false.  "more inlining to do"
			^self
		].
	].!
exitVar: exitVar label: exitLabel
	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."
	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."

	| newStmts labelUsed |
	labelUsed _ false.
	parseTree nodesDo: [ :node |
		node isStmtList ifTrue: [
			newStmts _ OrderedCollection new: 100.
			node statements do: [ :stmt |
				(stmt isReturn) ifTrue: [
					exitVar = nil ifTrue: [
						stmt expression isLeaf ifFalse: [
							"evaluate return expression even though value isn't used"
							newStmts add: stmt expression.
						].
					] ifFalse: [
						"assign return expression to exit variable"
						newStmts add:
							(TAssignmentNode new
								setVariable: (TVariableNode new setName: exitVar)
								expression: stmt expression).
					].
					(stmt == parseTree statements last) ifFalse: [
						"generate a goto (this return is NOT the last statement in the method)"
						newStmts add: (TGoToNode new setLabel: exitLabel).
						labelUsed _ true.
					].
				] ifFalse: [
					newStmts addLast: stmt.
				].
			].
			node setStatements: newStmts asArray.
		].
	].
	^labelUsed!
inlineableFunctionCall: aNode in: aCodeGen
	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."

	| m |
	aNode isSend ifFalse: [ ^false ].
	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"
	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [
		aNode args do: [ :a | (self isSubstitutableNode: a intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].
		^true
	] ifFalse: [
		^false
	].!
inlineableSend: aNode in: aCodeGen
	"Answer true if the given send node is a call to a method that can be inlined."

	| m |
	aNode isSend ifFalse: [ ^false ].
	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"
	^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]!
inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList

	| stmt sel meth newStatements maxTemp usedVars exitLabel v |
	maxTemp _ 0.
	parseTree nodesDo: [ :n |
		n isCaseStmt ifTrue: [
			n cases do: [ :stmtNode |
				stmt _ stmtNode statements first.
				stmt isSend ifTrue: [
					sel _ stmt selector.
					meth _ aCodeGen methodNamed: sel.
					((meth ~= nil) and:
					 [meth hasNoCCode and:
					 [meth args size = 0]]) ifTrue: [
						meth _ meth copy.
						maxTemp _ maxTemp max: (meth renameVarsForCaseStmt).

						meth hasReturn ifTrue: [
							exitLabel _ self unusedLabelForInliningInto: self.
							meth exitVar: nil label: exitLabel.
							labels add: exitLabel.
						] ifFalse: [ exitLabel _ nil ].

						meth renameLabelsForInliningInto: self.
						meth labels do: [ :label | labels add: label ].
						newStatements _ stmtNode statements asOrderedCollection.
						newStatements removeFirst.

						exitLabel ~= nil ifTrue: [
							newStatements addFirst:
								(TLabeledCommentNode new
									setLabel: exitLabel comment: 'end case').
						].

						newStatements addAllFirst: meth statements.
						newStatements addFirst:
							(TLabeledCommentNode new setComment: meth selector).
						stmtNode setStatements: newStatements.
					].
				].
			].
		].
	].
	usedVars _ (locals, args) asSet.
	1 to: maxTemp do: [ :i |
		v _ ('t', i printString).
		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].
		locals addLast: v.
	].

	"make local versions of the given globals"
	varsList do: [ :var |
		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].
	].
!
inlineCodeOrNilForStatement: aNode in: aCodeGen
	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."

	| stmts |
	aNode isReturn ifTrue: [
		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [
			stmts _ self inlineSend: aNode expression
				directReturn: true exitVar: nil in: aCodeGen.
			^stmts
		].
	].
	aNode isAssignment ifTrue: [
		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [
			^self inlineSend: aNode expression
				directReturn: false exitVar: aNode variable name in: aCodeGen
		].
	].
	aNode isSend ifTrue: [
		(self inlineableSend: aNode in: aCodeGen) ifTrue: [
			^self inlineSend: aNode
				directReturn: false exitVar: nil in: aCodeGen
		].
	].
	^nil!
inlineFunctionCall: aSendNode in: aCodeGen
	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."
	"Assume caller has established that:
		1. the method arguments are all substitutable nodes, and
		2. the method to be inlined contains no additional embedded returns."

	| sel meth substitutionDict |
	sel _ aSendNode selector.
	meth _ (aCodeGen methodNamed: sel) copy.
	meth renameVarsForInliningInto: self in: aCodeGen.
	meth renameLabelsForInliningInto: self.
	self addVarsDeclarationsAndLabelsOf: meth.
	substitutionDict _ Dictionary new.
	meth args with: aSendNode args do: [ :argName :exprNode |
		substitutionDict at: argName asSymbol put: exprNode.
		locals remove: argName.
	].
	meth parseTree bindVariablesIn: substitutionDict.
	^meth statements first expression!
inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen
	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."

	| sel meth exitLabel labelUsed inlineStmts |
	sel _ aSendNode selector.
	meth _ (aCodeGen methodNamed: sel) copy.
	meth renameVarsForInliningInto: self in: aCodeGen.
	meth renameLabelsForInliningInto: self.
	self addVarsDeclarationsAndLabelsOf: meth.
	meth hasReturn ifTrue: [
		directReturn ifTrue: [
			"propagate the return type, if necessary"
			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"
			returnType _ meth returnType.
		] ifFalse: [
			exitLabel _ self unusedLabelForInliningInto: self.
			labelUsed _ meth exitVar: exitVar label: exitLabel.
			labelUsed
				ifTrue: [ labels add: exitLabel ]
				ifFalse: [ exitLabel _ nil ].
		].
		"propagate type info if necessary"
		((exitVar ~= nil) and: [meth returnType ~= 'int']) ifTrue: [
			declarations at: exitVar put: meth returnType, ' ', exitVar.
		].
	].
	inlineStmts _ OrderedCollection new: 100.
	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).
	inlineStmts addAll:
		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).
	inlineStmts addAll: meth statements.  "method body"
	(directReturn and: [meth endsWithReturn not]) ifTrue: [
		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).
	].
	exitLabel ~= nil ifTrue: [
		inlineStmts add:
			(TLabeledCommentNode new
				setLabel: exitLabel comment: 'end ', meth selector).
	].
	^inlineStmts!
isFunctional
	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."

	(parseTree statements size = 1 and:
	 [parseTree statements last isReturn]) ifFalse: [ ^false ].
	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].
	^true!
isSubstitutableNode: aNode
	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."

	aNode isConstant ifTrue: [ ^true ].
	^aNode isVariable and:
		[(locals includes: aNode name) or:
		[args includes: aNode name]]!
isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen
	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."

	| var |
	aNode isConstant ifTrue: [ ^ true ].

	aNode isVariable ifTrue: [
		var _ aNode name.
		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].
		(#(self true false nil) includes: var) ifTrue: [ ^ true ].
		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].
	].

	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"
	aNode nodesDo: [ :node |
		node isSend ifTrue: [
			node isBuiltinOperator ifFalse: [ ^false ].
		].
		node isVariable ifTrue: [
			var _ node name.
			((locals includes: var) or:
			 [(args includes: var) or:
			 [(#(self true false nil) includes: var) or:
			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].
		].
		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].
	].

	^ true!
statementsListsForInlining
	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."

	| stmtLists |
	stmtLists _ OrderedCollection new: 10.
	parseTree nodesDo: [ :node | 
		node isStmtList ifTrue: [ stmtLists add: node ].
	].
	parseTree nodesDo: [ :node | 
		node isSend ifTrue: [
			((node selector = #and:) or: [node selector = #or:]) ifTrue: [
				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"
				stmtLists remove: node args first ifAbsent: [].
				stmtLists remove: node args last ifAbsent: [].
			].
			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [
				stmtLists remove: node receiver ifAbsent: [].
			].
			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [
				stmtLists remove: node receiver ifAbsent: [].
			].
			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [
				stmtLists remove: node receiver ifAbsent: [].
			].
			(node selector = #to:do) ifTrue: [
				stmtLists remove: node receiver ifAbsent: [].
				stmtLists remove: node args first ifAbsent: [].
			].
			(node selector = #to:do) ifTrue: [
				stmtLists remove: node receiver ifAbsent: [].
				stmtLists remove: node args first ifAbsent: [].
				stmtLists remove: (node args at: 2) ifAbsent: [].
			].
		].
		node isCaseStmt ifTrue: [
			"don't inline cases"
			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].
		].
	].
	^stmtLists!
tryToInlineMethodsIn: aCodeGen
	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."

	| stmtLists didSomething newStatements inlinedStmts sendsToInline |
	didSomething _ false.

	sendsToInline _ Dictionary new.
	parseTree nodesDo: [ :n |
		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [
			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).
		].
	].
	sendsToInline isEmpty ifFalse: [
		didSomething _ true.
		parseTree _ parseTree replaceNodesIn: sendsToInline.
	].

	didSomething ifTrue: [
		possibleSideEffectsCache _ nil.
		^didSomething
	].

	stmtLists _ self statementsListsForInlining.
	stmtLists do: [ :stmtList | 
		newStatements _ OrderedCollection new: 100.
		stmtList statements do: [ :stmt |
			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.
			(inlinedStmts = nil) ifTrue: [
				newStatements addLast: stmt.
			] ifFalse: [
				didSomething _ true.
				newStatements addAllLast: inlinedStmts.
			].
		].
		stmtList setStatements: newStatements asArray.
	].

	didSomething ifTrue: [
		possibleSideEffectsCache _ nil.
		^didSomething
	].

	complete ifFalse: [
		self checkForCompleteness: stmtLists in: aCodeGen.
		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"
	].
	^didSomething!
unusedLabelForInliningInto: targetMethod

	| usedLabels |
	usedLabels _ labels asSet.
	usedLabels addAll: targetMethod labels.
	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels! !
!TMethod methodsFor: 'inlining support'!
addVarsDeclarationsAndLabelsOf: methodToBeInlined
	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."

	methodToBeInlined args, methodToBeInlined locals do: [ :v |
		(locals includes: v) ifFalse: [ locals addLast: v ].
	].
	methodToBeInlined declarations associationsDo: [ :assoc |
		declarations add: assoc.
	].
	methodToBeInlined labels do: [ :label |
		labels add: label.
	].!
computePossibleSideEffectsIn: aCodeGen
	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."

	parseTree nodesDo: [ :node |
		node isSend ifTrue: [
			node isBuiltinOperator ifFalse: [ ^true ].
		].
	].
	^ false!
endsWithReturn
	"Answer true if the last statement of this method is a return."

	^ parseTree statements last isReturn!
hasReturn
	"Answer true if this method contains a return statement."

	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].
	^ false!
maySubstituteGlobal: globalVar in: aCodeGen
	"Answer true if this method does or may have side effects on the given global variable."

	possibleSideEffectsCache = nil ifTrue: [
		"see if this calls any other method and record the result"
		possibleSideEffectsCache _ self computePossibleSideEffectsIn: aCodeGen.
	].
	possibleSideEffectsCache ifTrue: [ ^ false ].

	parseTree nodesDo: [ :node |
		node isAssignment ifTrue: [
			node variable name = globalVar ifTrue: [ ^ false ].
		].
	].

	"if we get here, receiver calls no other method
	 and does not itself assign to the given global variable"
	^ true!
renameLabelsForInliningInto: destMethod
	"Rename any labels that would clash with those of the destination method."

	| destLabels usedLabels labelMap newLabelName |
	destLabels _ destMethod labels asSet.
	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"
	usedLabels addAll: labels.
	labelMap _ Dictionary new.
	self labels do: [ :l |
		(destLabels includes: l) ifTrue: [
			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.
			labelMap at: l put: newLabelName.
		].
	].
	self renameLabelsUsing: labelMap.!
renameLabelsUsing: aDictionary
	"Rename all labels according to the old->new mappings of the given dictionary."

	labels _ labels collect: [ :label |
		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].
	].

	parseTree nodesDo: [ :node |
		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [
			node setLabel: (aDictionary at: node label).
		].
		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [
			node setLabel: (aDictionary at: node label).
		].
	].!
renameVariablesUsing: aDictionary
	"Rename all variables according to old->new mappings of the given dictionary."

	| newDecls |
	"map args and locals"
	args _ args collect: [ :arg |
		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].
	].
	locals _ locals collect: [ :v |
		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].
	].

	"map declarations"
	newDecls _ declarations species new.
	declarations associationsDo: [ :assoc |
		(aDictionary includesKey: assoc key)
			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]
			ifFalse: [ newDecls add: assoc ].
	].
	declarations _ newDecls.

	"map variable names in parse tree"
	parseTree nodesDo: [ :node |
		(node isVariable and:
		 [aDictionary includesKey: node name]) ifTrue: [
			node setName: (aDictionary at: node name).
		].
		(node isStmtList and: [node args size > 0]) ifTrue: [
			node setArguments:
				(node args collect: [ :arg |
					(aDictionary includesKey: arg)
						ifTrue: [ aDictionary at: arg ]
						ifFalse: [ arg ].
				]).
		].
	].!
renameVarsForCaseStmt
	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."

	| i varMap |
	i _ 1.
	varMap _ Dictionary new.
	args, locals do: [ :v |
		varMap at: v put: ('t', i printString) asSymbol.
		i _ i + 1.
	].
	self renameVariablesUsing: varMap.
	^ i - 1!
renameVarsForInliningInto: destMethod in: aCodeGen
	"Rename any variables that would clash with those of the destination method."

	| destVars usedVars varMap newVarName |
	destVars _ aCodeGen globalsAsSet copy.
	destVars addAll: destMethod locals.
	destVars addAll: destMethod args.
	usedVars _ destVars copy.  "keeps track of names in use"
	usedVars addAll: args; addAll: locals.
	varMap _ Dictionary new.
	args, locals do: [ :v |
		(destVars includes: v) ifTrue: [
			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.
			varMap at: v put: newVarName.
		].
	].
	self renameVariablesUsing: varMap.!
unusedNamePrefixedBy: aString avoiding: usedNames
	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."

	| n newVarName |
	n _ 1.
	newVarName _ aString, n printString.
	[usedNames includes: newVarName] whileTrue: [
		n _ n + 1.
		newVarName _ aString, n printString.
	].
	usedNames add: newVarName.
	^ newVarName! !
!TMethod methodsFor: 'C code generation'!
emitCCodeOn: aStream generator: aCodeGen
	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."

	self emitCHeaderOn: aStream generator: aCodeGen.
	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.
	aStream nextPutAll: '}'; cr.!
emitCFunctionPrototype: aStream generator: aCodeGen
	"Emit a C function header for this method onto the given stream."

	| arg |
	aStream nextPutAll: returnType; space.
	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.
	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].
	1 to: args size do: [ :i |
		arg _ args at: i.
		(declarations includesKey: arg) ifTrue: [
			aStream nextPutAll: (declarations at: arg).
		] ifFalse: [
			aStream nextPutAll: 'int ', (args at: i).
		].
		i < args size ifTrue: [ aStream nextPutAll: ', ' ].
	].
	aStream nextPutAll: ')'.!
emitCHeaderOn: aStream generator: aCodeGen
	"Emit a C function header for this method onto the given stream."

	aStream cr.
	self emitCFunctionPrototype: aStream generator: aCodeGen.
	aStream nextPutAll: ' {'; cr.
	locals do: [ :var |
		aStream nextPutAll: '    '.
		aStream nextPutAll: (declarations at: var ifAbsent: [ 'int ', var]), ';'; cr.
	].
	locals isEmpty ifFalse: [ aStream cr ].! !
!TMethod methodsFor: 'printing'!
printOn: aStream

	aStream nextPutAll: 'TMethod(', selector, ')'.! !
!TParseNode methodsFor: 'all'!
allCalls
	"Answer a collection of selectors for the messages sent in this parse tree."

	| calls |
	calls _ Set new: 100.
	self nodesDo: [ :node |
		node isSend ifTrue: [ calls add: node selector ].
	].
	^calls!
bindVariablesIn: aDictionary

	^self!
hasExplicitReturn

	self nodesDo: [ :node |
		node isReturn ifTrue: [ ^true ].
	].
	^false!
inlineMethodsUsing: aDictionary

	self!
isAssignment

	^false!
isCaseStmt

	^false!
isComment

	^false!
isConstant

	^false!
isGoTo

	^false!
isLabel

	^false!
isLeaf
	"Answer true if the receiver is a variable or a constant node."

	^false!
isReturn

	^false!
isSend

	^false!
isStmtList

	^false!
isVariable

	^false!
nodeCount
	"Answer the number of nodes in this parseTree (a rough measure of its size)."

	| cnt |
	cnt _ 0.
	self nodesDo: [ :n | cnt _ cnt + 1 ].
	^cnt!
nodesDo: aBlock

	aBlock value: self.!
printOn: aStream 
	"Append a description of the receiver onto the given stream."

	self printOn: aStream level: 0.!
printOn: aStream level: anInteger 
	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."

	super printOn: aStream.!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [self]! !
!TReturnNode methodsFor: 'all'!
bindVariablesIn: aDictionary

	expression _ expression bindVariablesIn: aDictionary.!
copyTree

	^self class new
		setExpression: expression copyTree!
emitCCodeOn: aStream level: level generator: aCodeGen

	aStream nextPutAll: 'return '.
	expression emitCCodeOn: aStream level: level generator: aCodeGen.!
expression

	^expression!
inlineMethodsUsing: aDictionary

	expression _ expression inlineMethodsUsing: aDictionary.!
isReturn

	^true!
nodesDo: aBlock

	expression nodesDo: aBlock.
	aBlock value: self.!
printOn: aStream level: level

	aStream nextPut: $^.
	expression printOn: aStream level: level.!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [
		expression _ expression replaceNodesIn: aDictionary.
		self]!
setExpression: aNode

	expression _ aNode.! !
!TSendNode methodsFor: 'all'!
args

	^arguments!
bindVariablesIn: aDictionary

	receiver _ receiver bindVariablesIn: aDictionary.
	arguments _ arguments collect: [ :a | a bindVariablesIn: aDictionary ].!
copyTree

	^self class new
		setSelector: selector
		receiver: receiver copyTree
		arguments: (arguments collect: [ :arg | arg copyTree ])
		isBuiltInOp: isBuiltinOperator!
emitCCodeOn: aStream level: level generator: aCodeGen

	"If the selector is a built-in construct, translate it and return"
	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].

	"Translate this message send into a C function call."
	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.
	(receiver isVariable and:
	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [
		"self is omitted from the arguments list of the generated call"
		"Note: special case for translated BitBltSimulator--also omit
		 the receiver if this is a send to the variable 'interpreterProxy'"
		receiver emitCCodeOn: aStream level: level generator: aCodeGen.
		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].
	].
	1 to: arguments size do: [ :i |
		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.
		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].
	].
	aStream nextPutAll: ')'.!
inlineMethodsUsing: aDictionary

	arguments _ arguments collect: [ :arg |
		arg inlineMethodsUsing: aDictionary.
	].
	"xxx inline this message if it is in the dictionary xxx"!
isBuiltinOperator

	^ isBuiltinOperator!
isBuiltinOperator: builtinFlag

	isBuiltinOperator _ builtinFlag.!
isSend

	^true!
nodesDo: aBlock

	receiver nodesDo: aBlock.
	arguments do: [ :arg | arg nodesDo: aBlock ].
	aBlock value: self.!
printOn: aStream level: level

	| keywords |
	receiver printOn: aStream level: level.
	arguments size = 0 ifTrue: [
		aStream space; nextPutAll: selector.
		^self
	].
	keywords _ selector keywords.
	1 to: keywords size do: [ :i |
		aStream space.
		aStream nextPutAll: (keywords at: i); space.
		(arguments at: i) printOn: aStream level: level + 1.
	].!
receiver

	^receiver!
receiver: aNode

	receiver _ aNode.!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [
		receiver _ receiver replaceNodesIn: aDictionary.
		arguments _ arguments collect: [ :a | a replaceNodesIn: aDictionary ].
		self]!
selector

	^selector!
setSelector: aSymbol receiver: rcvrNode arguments: argList

	selector _ aSymbol.
	receiver _ rcvrNode.
	arguments _ argList asArray.
	isBuiltinOperator _ false.!
setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag

	selector _ aSymbol.
	receiver _ rcvrNode.
	arguments _ argList asArray.
	isBuiltinOperator _ builtinFlag.! !
!TStmtListNode methodsFor: 'all'!
args

	^arguments!
bindVariablesIn: aDictionary

	statements _ statements collect: [ :s | s bindVariablesIn: aDictionary ].!
copyTree

	^self class new
		setArguments: arguments copy
		statements: (statements collect: [ :s | s copyTree ])!
emitCCodeOn: aStream level: level generator: aCodeGen

	statements do: [ :s |
		level timesRepeat: [ aStream tab ].
		s emitCCodeOn: aStream level: level generator: aCodeGen.
		((self endsWithCloseBracket: aStream) or: [s isComment]) ifFalse: [ aStream nextPut: $; ].
		aStream cr.
	].!
endsWithCloseBracket: aStream
	"Answer true if the given stream ends in with $} character."
	| ch pos |
	(pos _ aStream position) > 0 ifTrue: [
		aStream position: pos - 1.
		ch _ aStream next.
		aStream position: pos.
	].
	^ ch = $}

" *** There's something wrong with File positioning.  If you execute the following code, it will print '(hello));;' , but it will give an error if you remove the line the says
	f position: f position.

 | f c p1 p2 p3 | 
f _ FileStream fileNamed: 'test'.
f nextPutAll: '(hello))'.
f position: (p1 _ f position)-1.
p2 _ f position.
c _ f next.
p3 _ f position.
f position: f position.
f nextPut: $;; nextPut: $;.
f close.
(FileStream fileNamed: 'test') contentsOfEntireFile
"!
inlineMethodsUsing: aDictionary

	statements do: [ :s | s inlineMethodsUsing: aDictionary ].!
isStmtList

	^true!
nodesDo: aBlock

	statements do: [ :s | s nodesDo: aBlock ].	
	aBlock value: self.!
printOn: aStream level: level

	aStream nextPut: $[.
	arguments size > 0 ifTrue: [
		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].
		aStream nextPutAll: ' | '.
	].
	self printStatementsOn: aStream level: level.
	aStream nextPut: $].!
printStatementsOn: aStream level: level

	statements size > 1 ifTrue: [ aStream crtab: level + 1 ].
	1 to: statements size do: [ :i |
		(statements at: i) printOn: aStream level: level.
		i = statements size ifTrue: [
			(statements size > 1) ifTrue: [
				aStream crtab: level.
			].
		] ifFalse: [
			aStream nextPut: $.; crtab: level + 1.
		].
	].!
replaceNodesIn: aDictionary

	^aDictionary at: self ifAbsent: [
		statements _ statements collect: [ :s | s replaceNodesIn: aDictionary ].
		self]!
setArguments: argList

	arguments _ argList.!
setArguments: argList statements: statementList
	"Initialize this method using the given information."

	arguments _ argList.
	statements _ statementList.!
setStatements: stmtList

	statements _ stmtList asOrderedCollection.!
statements

	^statements! !
!TVariableNode methodsFor: 'all'!
bindVariablesIn: aDictionary

	| newNode |
	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].
	^newNode copyTree!
copyTree

	^self class new setName: name!
emitCCodeOn: aStream level: level generator: aCodeGen

	name = 'nil'
		ifTrue: [ aStream nextPutAll: (aCodeGen cLiteralFor: nil) ]
		ifFalse: [ aStream nextPutAll: name ].!
isLeaf

	^true!
isVariable

	^true!
name

	^name!
printOn: aStream level: level

	aStream nextPutAll: name.!
setName: aString

	name _ aString.! !
!TwoToneForm methodsFor: 'as yet unclassified'!
displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm

	aDisplayMedium copyBits: self boundingBox
		from: self
		at: aDisplayPoint + self offset
		clippingBox: clipRectangle
		rule: (ruleInteger = Form over ifTrue: [self paintRule] ifFalse: [ruleInteger])
		fillColor: aForm!
displayOnPort: port at: location
	port colorMap: (self colorMapForDepth: port destForm depth);
		copyForm: self to: location rule: self paintRule;
		colorMap: nil!
paintRule
	backgroundColor = Color none
		ifTrue: [^ Form paint]
		ifFalse: [^ Form over]! !
!UndefinedObject methodsFor: 'dependents access'!
addDependent: ignored 
	"Refer to the comment in Object|dependents."

	self error: 'Nil should not have dependents'! !
!UnixFileDirectory methodsFor: 'file creation'!
fileClass
	^ StandardFileStream! !
!UnixFileDirectory class methodsFor: 'initialization'!
lookupEntryIn: pathName index: index
	"Workaround for discrepency between behavior of the Unix enumeration primitive and the spec with respect to empty path names. [Sorry, I didn't comment the primitive precisely enough. -- John Maloney]"

	pathName isEmpty
		ifTrue: [^ super lookupEntryIn: '/' index: index]
		ifFalse: [^ super lookupEntryIn: pathName index: index]!
pathNameDelimiter
	^ $/! !

UnsavableWorkspace comment:
'A workspace whose window will happily close without warning when the user so requests.  Used for throwaway windows, for example, to hold help messages..  1/27/96 sw'!
!Utilities class methodsFor: 'support windows'!
commandKeyMappings
	^ self class firstCommentAt: #commandKeyMappings

"Lower-case command keys
a	Select all
b	Browse it
c	Copy
d	Do it
e	Exchange
f	Find
g	Find again
h	Set Search String
i	Inspect it
j	Again once
k	Set font
l	Cancel
m	Implementors of it
n	Senders of it
o	Spawn
p	Print it
q	Query symbol
r	Recognizer
s	Save (i.e. accept)
u	Align
v	Paste
w	Delete preceding word
x	Cut
y	Swap characters
z	Undo

Upper-case command keys (Hold down Cmd & Shift, or Ctrl key)
A	Advance argument
B	Browse it in this same browser (in System browsers only)
C	Compare argument to clipboard
D	Duplicate
F	Insert 'ifFalse:'
J	Again many
K	Set style
L	Outdent (move selection one tab-stop left)
N	References to it
R	Indent (move selection one tab-stap right)
S	Search
T	Insert 'ifTrue:'
W	Selectors containing it
V	Paste author's initials
<return>		Insert return followed by as many tabs as the previous line
			(with a further adjustment for additional brackets in that line)

esc			Select current type-in
shift-delete	Forward delete character (not currently undo-able)

[	Enclose within [ and ], or remove enclosing [ and ]
(	Enclose within ( and ), or remove enclosing ( and )   NB: use ctrl (
{	Enclose within { and }, or remove enclosing { and }
<	Enclose within < and >, or remove enclosing < and >
'	Enclose within ' and ', or remove enclosing ' and '
""	Enclose within "" and "", or remove enclosing "" and ""

1	10 point font
2	12 point font
3	18 point font  (not in base image)
4	24 point font  (not in base image)
5	8 point font  (not in base image)

6	add color / make active
	(nb: to remove the active quality of text, you must select
	more than the active part and then use command-0)

7	bold
8	italic
9	narrow
0	plain text (resets all emphasis)
-	underlined
=	struck out

"
	
"Answer a string to be presented in a window at user request as a crib sheet for command-key mappings.  2/7/96 sw
5/1/96 sw: modified so that the long string lives in a comment, hence doesn't take up memory.  Also, fixed up some of the actual text, and added help for parentheses-enclosing items and text-style controls.
5/10/96 sw: added a bunch of changes at JM's suggestion
8/11/96 sw: fixed the font sizes, added align & references to it, and help for cmd-shift-B
11/2/96 di: added ctrl-return and shift-delete, and new assignments of cmd 0-9
11/7/96 di: new assignments of cmd 0-9, with - and = "! !
!Utilities class methodsFor: 'user interface'!
informUser: aString during: aBlock
	"Put a message above (or below if insufficient room) the cursor.
	 Like informUser:while:, but end when aBlock ends.  9/1/96 di"

	(SelectionMenu labels: '') displayAt: Sensor cursorPoint
		withCaption: aString during: [aBlock value]!
informUser: aString while: aBlock
	"Put a message above (or below if insufficient room) the cursor.
	 1/22/96 sw"

	"Utilities informUser: 'How do you do' while: [Sensor anyButtonPressed not]"
	| cp  |
	cp _ Sensor cursorPoint.
	(SelectionMenu labels: '') displayAt: cp
				withCaption: aString
				during: [[aBlock value] whileTrue]! !
!Utilities class methodsFor: 'recent method submissions'!
browseRecentSubmissions
	"Open up a browser on the most recent methods submitted in the image.  5/96 sw.
	5/29/96 sw: fixed so the browser doesn't go all wonkie after you submit more code"

	"Utilities browseRecentSubmissions"
	| count |
	(count _ self recentMethodSubmissions size) == 0 ifTrue:
		[^ SelectionMenu notify: 'There are no recent submissions'].
	
	Smalltalk browseMessageList: RecentSubmissions copy name: 'Recently submitted methods -- oldest first' autoSelect: nil ! !
!VariableNode methodsFor: 'initialize-release'!
name: varName index: i type: type
	"Only used for initting instVar refs"
	name _ varName.
	self key: varName
		index: i
		type: type!
name: string key: object code: byte
	"Only used for initting std variables, nil, true, false, self, etc."
	name _ string.
	key _ object.
	code _ byte!
name: varName key: objRef index: i type: type
	"Only used for initting global (litInd) variables"
	name _ varName.
	self key: objRef
		index: i
		type: type! !
!VariableNode methodsFor: 'testing'!
assignmentCheck: encoder at: location

	(encoder cantStoreInto: name)
		ifTrue: [^ location]
		ifFalse: [^ -1]
!
isTemp
	^ false! !
!VariableNode methodsFor: 'code generation'!
emitForValue: stack on: strm

	code < 256
		ifTrue: 
			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).
			stack push: 1]
		ifFalse: 
			[self emitLong: LoadLong on: strm.
			stack push: 1]!
emitStorePop: stack on: strm
	(code between: 0 and: 7)
		ifTrue: 
			[strm nextPut: ShortStoP + code "short stopop inst"]
		ifFalse:
			[(code between: 16 and: 23)
				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]
				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])
						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]
						ifFalse: [self emitLong: StorePop on: strm]]].
	stack pop: 1!
sizeForStore: encoder
	self reserve: encoder.
	code < 256 ifTrue: [^ 2].
	(code \\ 256) <= 63 ifTrue: [^ 2].
	^ 3!
sizeForStorePop: encoder
	self reserve: encoder.
	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].
	code < 256 ifTrue: [^ 2].
	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"
	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"
	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"
	self halt.  "Shouldn't get here"! !
!VariableNode methodsFor: 'printing'!
printOn: aStream indent: level 
	aStream nextPutAll: name! !
!VariableNode methodsFor: 'C translation'!
asTranslatorNode
	^TVariableNode new setName: name! !
!VariableNode class methodsFor: 'class initialization'!
initialize    "VariableNode initialize.  Decompiler initialize"
	| encoder |
	encoder _ Encoder new.
	StdVariables _ Dictionary new: 16.
	encoder
		fillDict: StdVariables
		with: VariableNode
		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )
		to: (Array with: LdSelf with: LdThisContext with: LdSuper)
				, (Array with: LdNil with: LdFalse with: LdTrue).
	StdSelectors _ Dictionary new: 64.
	encoder
		fillDict: StdSelectors
		with: SelectorNode
		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 
							[:i | Smalltalk specialSelectorAt: i])
		to: (SendPlus to: SendPlus + 31).
	StdLiterals _ LiteralDictionary new: 16.
	encoder
		fillDict: StdLiterals
		with: LiteralNode
		mapping: #(-1 0 1 2 )
		to: (LdMinus1 to: LdMinus1 + 3).
	encoder initScopeAndLiteralTables.

	NodeNil _ encoder encodeVariable: 'nil'.
	NodeTrue _ encoder encodeVariable: 'true'.
	NodeFalse _ encoder encodeVariable: 'false'.
	NodeSelf _ encoder encodeVariable: 'self'.
	NodeThisContext _ encoder encodeVariable: 'thisContext'.
	NodeSuper _ encoder encodeVariable: 'super'! !
!View methodsFor: 'testing'!
bordersOn: otherView along: herSide 
	| myBox herBox |
	myBox _ self displayBox.
	herBox _ otherView displayBox.
	(herSide = #right and: [myBox left = herBox right])
	| (herSide = #left and: [myBox right = herBox left])
		ifTrue:
		[^ (myBox top max: herBox top) <= (myBox bottom min: herBox bottom)].
	(herSide = #bottom and: [myBox top = herBox bottom])
	| (herSide = #top and: [myBox bottom = herBox top])
		ifTrue:
		[^ (myBox left max: herBox left) <= (myBox right min: herBox right)].
	^ false!
containsPoint: aPoint
	"Answer whether aPoint is within the receiver's display box. It is sent to 
	a View's subViews by View|subViewAt: in order to determine which 
	subView contains the cursor point (so that, for example, control can be 
	pass down to that subView's controller)."

	^ self insetDisplayBox containsPoint: aPoint! !
!View methodsFor: 'bordering'!
backgroundColor
	insideColor == nil ifFalse:
		[(insideColor isMemberOf: Symbol) ifTrue:
			[^ Color perform: insideColor].
		^ insideColor].
	superView == nil ifFalse: [^ superView backgroundColor].
	^ Color white! !
!View methodsFor: 'miscellaneous'!
stretchFrame: newFrameBlock startingWith: startFrame 
	"Track the outline of a newFrame as long as mouse drags it.
	Maintain max and min constraints throughout the drag"
	| frame newFrame click |
	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)
											max: self minimumSize).
	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
	click _ false.
	[click and: [Sensor noButtonPressed]] whileFalse: 
		[Processor yield.
		click _ click | Sensor anyButtonPressed.
		newFrame _ newFrameBlock value: frame.
		newFrame extent: ((newFrame extent min: self maximumSize)
											max: self minimumSize).
		newFrame = frame ifFalse:
			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.
			frame _ newFrame]].
	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.
	^ frame! !
!WarpBlt methodsFor: 'setup'!
cellSize: s
	cellSize _ s.
	cellSize = 1 ifTrue: [^ self].
	cellSize > 3 ifTrue:
		[(self confirm:
'Do you really want to average
more than 3x3 pixels?') ifFalse: [self halt]].
	(destForm depth < 16 and: [colorMap == nil])
		ifTrue: [self setDestMap: 3]!
rgbValues
	"RGB forms (depth 16 and 32) don't need a source map"
	sourceForm depth >= 16 ifTrue: [^ nil].

	"All other forms, for now, are assumed to use our
	standard color map, so all warps will share it."
	SourceMapCache == nil ifTrue:
		[SourceMapCache _ "Compute once and save around"
			(Color indexedColors collect: [:c | c pixelValueForDepth: 32])
					as: Bitmap].
	^ SourceMapCache

	"Special applications such as external GIF images might want to
	supply their own RGB map by directly calling, eg,
		self warpBitsSmoothing: cellSize sourceMap: specialRGBmap"!
setDestMap: bitsPerColor
	"Establish a destination color map to convert from pixel-averaged
	RGB values to (presumably non-RGB) destination pixel values"
	| mask |
	DestMapCache size = (1 bitShift: bitsPerColor*3) ifTrue:
		["Just use the last one if same bits per color"
		colorMap _ DestMapCache.
		^ self].
	mask _ (1 bitShift: bitsPerColor) - 1.
	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).
	0 to: colorMap size - 1 do:
		[:i | colorMap at: i+1 put:
			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)
				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
				blue: ((i bitShift: 0) bitAnd: mask)
				range: mask)
			pixelValueForDepth: destForm depth)].
	"Cache for possible reuse"
	DestMapCache _ colorMap! !
!WarpBlt methodsFor: 'smoothing'!
mixPix: pix sourceMap: sourceMap destMap: destMap
	"Average the pixels in array pix to produce a destination pixel.
	First average the RGB values either from the pixels directly,
	or as supplied in the sourceMap.  Then return either the resulting
	RGB value directly, or use it to index the destination color map." 
	| r g b rgb nPix bitsPerColor d |
	nPix _ pix size.
	r _ 0. g _ 0. b _ 0.
	1 to: nPix do:
		[:i |   "Sum R, G, B values for each pixel"
		rgb _ sourceForm depth <= 8
				ifTrue: [sourceMap at: (pix at: i) + 1]
				ifFalse: [sourceForm depth = 32
						ifTrue: [pix at: i]
						ifFalse: [BitBltSimulation new
								rgbMap: (pix at: i) from: 5 to: 8]].
		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).
		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).
		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].
	destMap == nil
		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"
				destForm depth = 16 ifTrue: [bitsPerColor _ 5].
				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]
		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].
				destMap size = 4096 ifTrue: [bitsPerColor _ 4].
				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].
	d _ bitsPerColor - 8.
	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)
		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)
		+ ((b // nPix bitShift: d) bitShift: 0).
	destMap == nil
		ifTrue: [^ rgb]
		ifFalse: [^ destMap at: rgb+1]! !
!WarpBlt methodsFor: 'primitives'!
deltaFrom: x1 to: x2 nSteps: n
	"Utility routine for computing Warp increments.
	Takes care to deal with 0...N meaning pixels 0 through N-1"
	| delta |  "assume n >= 1"
	delta _ x2 - x1.
	delta > 0 ifTrue: [^ delta - 1 quo: n]  "Shrink by 1 so never hit pix N"
		ifFalse: [delta = 0 ifTrue: [^ 0]
			ifFalse: [^ delta + 2 quo: n]]  "Same for neg delta, but shrink
										by 2 because start is offset by 1"!
startFrom: x1 to: x2
	"Utility routine for computing Warp increments.
	Takes care to deal with 0...N meaning pixels 0 through N-1"
	x2 >= x1
		ifTrue: [^ x1]
		ifFalse: [^ x1 - 1]  "If delta is neg, then start in pix N-1"!
warpBits
	^ self warpBitsSmoothing: cellSize sourceMap: self rgbValues!
warpBitsSmoothing: n sourceMap: sourceMap
	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix |
	<primitive: 147>
	(width < 1) | (height < 1) ifTrue: [^ self].
	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"
	n > 1 ifTrue:
		[(destForm depth < 16 and: [colorMap == nil])
			ifTrue: ["color map is required to smooth non-RGB dest"
					^ self primitiveFail].
		pix _ Array new: n*n].
	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: (height-1 max: 1))
			@ (self deltaFrom: p1y to: p2y nSteps: (height-1 max: 1)).
	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: (height-1 max: 1))
			@ (self deltaFrom: p4y to: p3y nSteps: (height-1 max: 1)).
	pA _ (self startFrom: p1x to: p2x) @ (self startFrom: p1y to: p2y).
	pB _ (self startFrom: p4x to: p3x) @ (self startFrom: p4y to: p3y).
	picker _ BitBlt bitPeekerFromForm: sourceForm.
	poker _ BitBlt bitPokerToForm: destForm.
	destY to: destY+height-1 do:
		[:y |
		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: (width-1 max: 1))
				@ (self deltaFrom: pA y to: pB y nSteps: (width-1 max: 1)).
		sp _ (self startFrom: pA x to: pB x) @ (self startFrom: pA y to: pB y).
		destX to: destX+width-1 do:
			[:x | 
			n = 1
			ifTrue:
				[Transcript cr; print: sp // fixedPtOne asPoint.
				poker pixelAt: x@y
						put: (picker pixelAt: sp // fixedPtOne asPoint)]
			ifFalse:
				[0 to: n-1 do:
					[:dx | 0 to: n-1 do:
						[:dy |
						pix at: dx*n+dy+1 put:
								(picker pixelAt: sp
									+ (deltaPAB*dx//n)
									+ (deltaP12*dy//n)
										// fixedPtOne asPoint)]].
				poker pixelAt: x@y put: (self mixPix: pix
										sourceMap: sourceMap
										destMap: colorMap)].
			sp _ sp + deltaPAB].
		pA _ pA + deltaP12.
		pB _ pB + deltaP43]! !
!WarpBlt class methodsFor: 'initialization'!
toForm: destinationForm
	"Default cell size is 1 (no pixel smoothing)"
	^ (super toForm: destinationForm) cellSize: 1! !
!WarpBlt class methodsFor: 'examples'!
test1   "Display restoreAfter: [WarpBlt test1]"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p ext |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display)
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor cursorPoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].
		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]!
test12   "Display restoreAfter: [WarpBlt test12]"
	"Just like test1, but comparing smooth to non-smooth warps"
	| warp pts r1 p0 p ext warp2 |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 _ Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 _ Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp _ (self toForm: Display) cellSize: 2;
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	warp2 _ (self toForm: Display)
		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor cursorPoint.
		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].
		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).
		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).
		]!
test3   "Display restoreAfter: [WarpBlt test3]"

	"The Squeak Release Mandala - 9/23/96 di"

	"Move the mouse near the center of the square.
	Up and down affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box map d t |
	box _ 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	"Make a color map that steps through the color space"
	map _ (Display depth > 8
		ifTrue: ["RGB is a bit messy..."
				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].
				(1 to: 512) collect: [:i | t _ i bitAnd: 511.
					((t bitAnd: 16r7) bitShift: d-3)
					+ ((t bitAnd: 16r38) bitShift: d-3*2)
					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]
		ifFalse: ["otherwise simple"
				1 to: (1 bitShift: Display depth)])
			as: Bitmap.
	warp _ (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		colorMap: map;
		combinationRule: Form over.
	p0 _ box center.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor cursorPoint.
		pts _ (box insetBy: p y - p0 y) corners
			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box]!
test4   "Display restoreAfter: [WarpBlt test4]"

	"The Squeak Release Mandala - 9/23/96 di"

	"Move the mouse near the center of the square.
	Up and down affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box map d t |
	box _ 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	warp _ (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		cellSize: 2;
		combinationRule: Form over.
	p0 _ box center.
	[Sensor anyButtonPressed] whileFalse:
		[p _ Sensor cursorPoint.
		pts _ (box insetBy: p y - p0 y) corners
			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box]! !
!WaveTableSound methodsFor: 'sound generation'!
doControl

	decayRate ~= 1.0 ifTrue: [
		amplitude _ (decayRate * amplitude asFloat) truncated.
	].
!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan
	"Play samples from a wave table by stepping a fixed amount throught the table on every sample. The decay parameter may be used to make the sound fade away, but its default value of 1.0 produces a sustained sound, like a flute. The abrupt start and stops of this sound result in transient clicks; it would benefit greatly from a simple attack-sustain-decay envelope."
	"(WaveTableSound pitch: 440.0 dur: 1.0 loudness: 200) play"

	| lastIndex mySample channelIndex sample |
	<primitive: 176>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #waveTable declareC: 'short int *waveTable'.

	lastIndex _ (startIndex + n) - 1.
	startIndex to: lastIndex do: [ :i |
		mySample _ (amplitude * (waveTable at: index)) // 1000.
		pan > 0 ifTrue: [
			channelIndex _ 2 * i.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].
		pan < 1000 ifTrue: [
			channelIndex _ (2 * i) - 1.
			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).
			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"
			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"
			aSoundBuffer at: channelIndex put: sample.
		].

		index _ index + increment.
		index > waveTableSize ifTrue: [
			index _ index - waveTableSize.
		].
	].
	count _ count - n.
! !
!WriteStream methodsFor: 'private'!
withAttribute: att do: strmBlock 
	"No-op here is overriden in TextStream for font emphasis"
	^ strmBlock value! !

Smalltalk makeExternalRelease!

----QUIT----(13 December 1996 2:26:14 pm ) priorSource: 908105!

'From Squeak 1.18 of December 12, 1996 on 14 December 1996 at 7:35:39 am'!

"Change Set:		ByteSwapFix
Date:			14 December 1996
Author:			John Maloney

Fixes an omission in the bytecode swapping code that
supports image portability between machines. Based
on the design by Ian Piumarta. Tested by reading a
windows image on a Mac."!
!Interpreter methodsFor: 'image save/restore'!
byteSwapByteObjects
	"Byte-swap the words of all bytes objects in the image, including Strings, ByteArrays, and CompiledMethods. This returns these objects to their original byte ordering after blindly byte-swapping the entire image. For compiled methods, byte-swap only their bytecodes part."

	| oop fmt wordAddr methodHeader end |
	oop _ self firstObject.
	[oop < endOfMemory] whileTrue: [
		(self isFreeObject: oop) ifFalse: [
			fmt _ self formatOf: oop.
			fmt >= 8 ifTrue: [  "oop contains bytes"
				wordAddr _ oop + BaseHeaderSize.
				fmt >= 12 ifTrue: [
					"compiled method; start after methodHeader and literals"
					methodHeader _ self longAt: oop + BaseHeaderSize.
					wordAddr _ wordAddr + 4 + (((methodHeader >> 10) bitAnd: 16rFF) * 4).
				].
				end _ oop + (self sizeBitsOf: oop).
				[wordAddr < end] whileTrue: [
					self longAt: wordAddr put: (self byteSwapped: (self longAt: wordAddr)).
					wordAddr _ wordAddr + 4.
				].
			].
 		].
		oop _ self objectAfter: oop.
	].
! !
!Interpreter methodsFor: 'image save/restore' priorSource: 412426 inFile: 2!
reverseBytesInImage
	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."

	| addr lastAddr |
	"First, byte-swap every word in the image. This fixes objects headers."
	addr _ self startOfMemory.
	lastAddr _ endOfMemory.
	[addr < lastAddr] whileTrue: [
		self longAt: addr put: (self byteSwapped: (self longAt: addr)).
		addr _ addr + 4.
	].

	"Second, return the bytes of bytes-type objects to their orginal order."
	self byteSwapByteObjects.! !

----QUIT----(14 December 1996 9:10:29 am ) priorSource: 908137!

'From Squeak 1.18 of December 12, 1996 on 14 December 1996 at 7:35:39 am'!

"Change Set:		ByteSwapFix
Date:			14 December 1996
Author:			John Maloney

Fixes an omission in the bytecode swapping code that
supports image portability between machines. Based
on the design by Ian Piumarta. Tested by reading a
windows image on a Mac."!
!Interpreter methodsFor: 'image save/restore' priorSource: 908583 inFile: 2!
byteSwapByteObjects
	"Byte-swap the words of all bytes objects in the image, including Strings, ByteArrays, and CompiledMethods. This returns these objects to their original byte ordering after blindly byte-swapping the entire image. For compiled methods, byte-swap only their bytecodes part."

	| oop fmt wordAddr methodHeader end |
	oop _ self firstObject.
	[oop < endOfMemory] whileTrue: [
		(self isFreeObject: oop) ifFalse: [
			fmt _ self formatOf: oop.
			fmt >= 8 ifTrue: [  "oop contains bytes"
				wordAddr _ oop + BaseHeaderSize.
				fmt >= 12 ifTrue: [
					"compiled method; start after methodHeader and literals"
					methodHeader _ self longAt: oop + BaseHeaderSize.
					wordAddr _ wordAddr + 4 + (((methodHeader >> 10) bitAnd: 16rFF) * 4).
				].
				end _ oop + (self sizeBitsOf: oop).
				[wordAddr < end] whileTrue: [
					self longAt: wordAddr put: (self byteSwapped: (self longAt: wordAddr)).
					wordAddr _ wordAddr + 4.
				].
			].
 		].
		oop _ self objectAfter: oop.
	].
! !
!Interpreter methodsFor: 'image save/restore' priorSource: 909663 inFile: 2!
reverseBytesInImage
	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."

	| addr lastAddr |
	"First, byte-swap every word in the image. This fixes objects headers."
	addr _ self startOfMemory.
	lastAddr _ endOfMemory.
	[addr < lastAddr] whileTrue: [
		self longAt: addr put: (self byteSwapped: (self longAt: addr)).
		addr _ addr + 4.
	].

	"Second, return the bytes of bytes-type objects to their orginal order."
	self byteSwapByteObjects.! !

Time millisecondsToRun: [
		Interpreter translate: 'InterpTest.c' doInlining: false.
		Smalltalk beep]!

Time millisecondsToRun: [
		Interpreter translate: 'InterpTestInline.c' doInlining: true.
		Smalltalk beep]!

InterpreterSupportCode writeMacSourceFiles!