'From Squeak 1.19d of April 13, 1997 on 13 April 1997 at 11:38:03 pm'!!AbstractSound methodsFor: 'playing'!playSampleCount: n into: aSoundBuffer startingAt: startIndex stereo: stereoFlag	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| leftRightPan samplesBetweenControlUpdates pastEnd i remainingSamples count |	stereoFlag ifTrue: [leftRightPan _ 500] ifFalse: [leftRightPan _ 1000].	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just index of after last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [ ^ self ].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [ count _ samplesUntilNextControl ].		remainingSamples < count		ifTrue: [ count _ remainingSamples ].		self mixSampleCount: count into: aSoundBuffer startingAt: i pan: leftRightPan.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates.		].		i _ i + count.	].! !!AbstractSound class methodsFor: 'examples'!bachFugue	"Play a fugue by J. S. Bach using the receiver as the sound for all four voices."	"FMSound bachFugue play"	^ MixedSound new		add: self bachFugueVoice1 pan: 1000;		add: self bachFugueVoice2 pan: 0;		add: self bachFugueVoice3 pan: 1000;		add: self bachFugueVoice4 pan: 0.!stereoBachFugue	"Play fugue by J. S. Bach in stereo using different timbres."	"AbstractSound bachFugue play"	"BoinkSound			bachFugueVoice1 play"	"WaveTableSound	bachFugueVoice1 play"	"PluckedSound		bachFugueVoice1 play"	"FMSound			bachFugueVoice1 play"	^ MixedSound new		add: BoinkSound bachFugueVoice1 pan: 200;		add: WaveTableSound bachFugueVoice2 pan: 800;		add: FMSound bachFugueVoice3 pan: 400;		add: FMSound bachFugueVoice4 pan: 600.! !!AbstractSound class methodsFor: 'primitive generation'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	^ CCodeGenerator new codeStringForPrimitives: #(		(WaveTableSound mixSampleCount:into:startingAt:pan:)		(FMSound mixSampleCount:into:startingAt:pan:)		(PluckedSound mixSampleCount:into:startingAt:pan:)		(SampledSound mixSampleCount:into:startingAt:pan:)	).! !!AbstractSound class methodsFor: 'utilities'!convert8bitSignedTo16Bit: anArray	"Convert the given array of samples--assumed to be 8-bit signed, linear data--into 16-bit signed samples. Return an array containing the resulting samples."	| n samples s |	n _ anArray size.	samples _ Array new: n.	1 to: n do: [:i |		s _ anArray at: i.		s > 127 ifTrue: [s _ s - 256].		samples at: i put: (s * 256)].	^ samples! !!ActorMorph methodsFor: 'initialization'!initialize	super initialize.	self form: (MaskedForm		form: ((Form extent: 50@30 depth: Display depth) fillColor: Color green)		transparentColor: Color white).	running _ false.	cargo _ nil.! !!ActorMorph methodsFor: 'accessing'!cargo	^ cargo!cargo: anObject	cargo _ anObject.!heading	^ rotationDegrees!heading: degrees	self rotationDegrees: (self asAngleInDegrees: degrees) \\ 360.0.!parts	^ #(cargo heading position)!position: aPoint	super position: aPoint asPoint.! !!ActorMorph methodsFor: 'stepping'!step	running		ifTrue: [self world model perform: self onTicksSelector].!stepTime	^ 100! !!ActorMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'script' action: #editScript:.	aCustomMenu addLine.	aCustomMenu add: 'run' action: #startRunning.	aCustomMenu add: 'stop' action: #stopRunning.!editScript: evt	self nameInModel ifNil: [self choosePartNameSilently].	evt hand attachMorph:		(self scriptEditorFor: 'onTicks').!scriptEditorFor: ignored	(lastScriptEditor ~= nil and: [lastScriptEditor isInWorld])		ifTrue: [^ lastScriptEditor].	lastAcceptedScript = nil ifTrue: [		^ lastScriptEditor _ ScriptEditorMorph new			setMorph: self			scriptName: 'OnTicks'.	] ifFalse: [		^ lastScriptEditor _ lastAcceptedScript fullCopy].!startRunning	self nameInModel ifNotNil: [running _ true].!stopRunning	running _ false.! !!ActorMorph methodsFor: 'other'!acceptScript: aScriptEditorMorph for: ignored	lastAcceptedScript _ aScriptEditorMorph.	self world model class		compile: lastAcceptedScript methodString		classified: 'scripts'		notifying: nil.	self startRunning.!choosePartName	"Override to add null on-ticks script when this morph is named."	| newName |	newName _ super choosePartName.	newName ifNil: [^ self].  "user cancelled or chose a bad part name"	(self world model class)		compile: self onTicksSelector		classified: 'scripts'		notifying: nil.!choosePartNameSilently	super choosePartNameSilently.	(self world model class)		compile: self onTicksSelector		classified: 'scripts'		notifying: nil.!commandsWithDefaultArgs	"Return a list of (command arg1 arg2 ...) arrays where each command is followed by the default values for is parameters."	| r |	r _ OrderedCollection new.	r add: #(beep).	r add: #(bounce).	r add: #(forward: 15).	r add: #(hide).	r add: (Array with: #jumpTo: with: 10@10).	r add: #(show).	r add: #(turn: 15).	r add: #(#wearCostume:).	r add: #(wrap).	"general parameter setting/updating"	r add: (Array with: #set: with: 20@20).	r add: #(incr: 15).	r add: #(decr: 15).	^ r!copy	^ super copy initScripts!initScripts	"Used to remove the scripts from a newly made copy of myself."	lastAcceptedScript _ lastScriptEditor _ nil.!onTicksSelector	^ (self nameInModel, 'OnTicks') asSymbol! !!Array2D methodsFor: 'access'!atCol: i put: list    "Put in a whole column.     hold first index constant"    list size = self height ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :j |        self at: i at: j put: value].!atRow: j put: list    "Put in a whole row.     hold second index constant"    list size = self width ifFalse: [self error: 'wrong size'].    list doWithIndex: [:value :i |        self at: i at: j put: value].! !!AssignmentNode methodsFor: 'C translation'!asTranslatorNode	^TAssignmentNode new		setVariable: variable asTranslatorNode		expression: value asTranslatorNode! !!AtomMorph methodsFor: 'all'!bounceIn: aRect	| p |	p _ self position + velocity.	p x > aRect right ifTrue: [		p x: aRect right - (p x - aRect right).		velocity x: velocity x negated.	].	p y > aRect bottom ifTrue: [		p y: aRect bottom - (p y - aRect bottom).		velocity y: velocity y negated.	].	p x < aRect left ifTrue: [		p x: aRect left - (p x - aRect left).		velocity x: velocity x negated.	].	p y < aRect top ifTrue: [		p y: aRect top - (p y - aRect top).		velocity y: velocity y negated.	].	self position: p.!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect _ false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].!infected	^ color = Color red!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].!initialize	"Make a new atom with a random position and velocity."	super initialize.	self extent: 8@7.	self color: Color blue.	self borderWidth: 0.	self randomPositionIn: (0@0 corner: 300@300) maxVelocity: 10.!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin _ aRectangle origin.	extent _ aRectangle extent - self bounds extent.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity _		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).!velocity	^ velocity!velocity: newVelocity	velocity _ newVelocity.! !!Behavior methodsFor: 'initialize-release'!obsolete	"Invalidate and recycle local messages. Remove the receiver from its 	superclass' subclass list."	methodDict _ MethodDictionary new.	superclass == nil ifFalse: [superclass removeSubclass: self]! !!Behavior methodsFor: 'accessing'!confirmRemovalOf: aSelector	"Determine if it is okay to remove the given selector.  Answer 1 if it should be removed, 2 if it should be removed followed by a senders browse, and 3 if it should not be removed. 1/17/96 sw	9/18/96 sw: made the wording more delicate	3/10/97 sw: bug fix -- auto select string needs to be first keyword only"	| count aMenu answer caption allCalls |	(count _ (allCalls _ Smalltalk allCallsOn: aSelector) size) > 0		ifTrue:			[aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.			caption _ 'This message has ', count printString, ' sender'.			count > 1 ifTrue:				[caption _ caption copyWith: $s].			answer _ aMenu startUpWithCaption: caption.			answer == 3 ifTrue:				[Smalltalk browseMessageList: allCalls					name: 'Senders of ', aSelector					autoSelect: aSelector keywords first].			answer == 0 ifTrue: [answer _ 3].  "If user didn't answer, treat it as cancel"			^ answer min: 3]		ifFalse:			[^ 1]	! !!Behavior methodsFor: 'testing'!instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !!Behavior methodsFor: 'creating class hierarchy'!superclass: aClass 	"Change the receiver's superclass to be aClass."	(aClass == nil or: [aClass isKindOf: Behavior])		ifTrue: [superclass _ aClass]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'creating method dictionary'!compile: code notifying: requestor 	"Compile the argument, code, as source code in the context of the 	receiver and insEtall the result in the receiver's method dictionary. The 	second argument, requestor, is to be notified if an error occurs. The 	argument code is either a string or an object that converts to a string or 	a PositionableStream. This method also saves the source code."	| method selector methodNode |	method _ self		compile: code		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :parseNode | selector _ sel.  methodNode _ parseNode].	method putSource: code asString fromParseNode: methodNode inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	^selector!compress	"Compact the method dictionary of the receiver."	methodDict rehash!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	| method trailer methodNode |	method _ self compiledMethodAt: selector.	trailer _ (method size - 3 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'instance creation'!new	"Answer a new instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."	"Essential Primitive. See Object documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [^ self basicNew: 0].	"space must be low"	Smalltalk signalLowSpace.	^ self basicNew  "retry if user proceeds"!new: anInteger 	"Primitive. Answer an instance of the receiver (which is a class) with the 	number of indexable variables specified by the argument, anInteger. Fail 	if the class is not indexable or if the argument is not a positive Integer. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	(anInteger isInteger and: [anInteger >= 0]) ifTrue: [		"arg okay; space must be low"		Smalltalk signalLowSpace.		^ self basicNew: anInteger  "retry if user proceeds"	].	self primitiveFailed! !!Behavior methodsFor: 'accessing class hierarchy'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames subclass |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames _ SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (Smalltalk at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Behavior methodsFor: 'accessing method dictionary'!sourceCodeAt: selector	^ (methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'testing method dictionary'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who method |	who _ Set new.	methodDict associationsDo:		[:assn |		method _ assn value.		((method pointsTo: literal "faster than hasLiteral:") or:				[specialFlag and: [method scanFor: specialByte]])			ifTrue:			[((literal isKindOf: Association) not				or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])				ifTrue: [who add: assn key]]].	^who! !!Behavior methodsFor: 'private'!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isPointers		ifTrue: [isVar				ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]				ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]		ifFalse: [isWords ifTrue: [6] ifFalse: [8]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !BitBlt comment:'I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Sum of color components	22	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)'!!BitBlt methodsFor: 'accessing'!colorMap	^ colorMap!destRect	"The rectangle we are about to blit to or just blitted to.  3/19/97 tk"	^ destX @ destY extent: width @ height!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX _ x.	destY _ y.	width _ w.	height _ h.!fillColor	^ halftoneForm!sourceForm	^ sourceForm! !!BitBlt methodsFor: 'copying'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer 	or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord"	<primitive: 96>	"Set the variables and try again (BitBlt|copyBitsAgain, also a Primitive)."	combinationRule = Form paint ifTrue: [^ self paintBits].	combinationRule = Form erase1bitShape ifTrue: [^ self eraseBits].	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'line drawing'!drawFrom: startPoint to: stopPoint 		 ^ self drawFrom: startPoint to: stopPoint withFirstPoint: true!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards _ (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	sourceForm == nil ifTrue:		[destX _ (point1 x - (width//2)) rounded.		destY _ (point1 y - (height//2)) rounded]		ifFalse:		[width _ sourceForm width.		height _ sourceForm height.		offset _ sourceForm offset.		destX _ (point1 x + offset x) rounded.		destY _ (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded.	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 104>	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx.				(P _ P - px) < 0 ifTrue: 						[destY _ destY + dy.						P _ P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy.				(P _ P - py) < 0 ifTrue: 						[destX _ destX + dx.						P _ P + px].				i < px ifTrue: [self copyBits]]]! !!BitBlt methodsFor: 'private'!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule _ combinationRule.	color _ halftoneForm.  halftoneForm _ nil.	oldMap _ colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule _ Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm _ color.	combinationRule _ Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap _ oldMap.	combinationRule _ saveRule" | dot |dot _ Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!BitBlt class methodsFor: 'examples'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect bitsPerColor mask updateRect |  	"First compute color maps if any (nils are fine for RGB)"	(Display depth <= 8) ifTrue:		[mapDto32 _ (Color defaultColorMapFrom: Display depth to: 32) copy.		"Use 4 bits per color to map down from 32 bits to 8 or less"		"Following code copied from Color>>defaultColorMapFrom:"		bitsPerColor _ 4.   "... except for this"		map32toD _ Bitmap new: (1 bitShift: bitsPerColor*3).		mask _ (1 bitShift: bitsPerColor) - 1.		0 to: map32toD size - 1 do:			[:i | map32toD at: i+1 put:				((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)					green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)					blue: ((i bitShift: 0) bitAnd: mask)					range: mask)				pixelValueForDepth: Display depth)]].	"Now display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p farFrom: prevP by: buffSize) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect _ buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP _ p]]]!antiAliasDemo 	"To run this demo, use...		Display restoreAfter: [BitBlt antiAliasDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"		"This version also uses WarpBlt to paint into twice as large a buffer,	and then use smoothing when reducing back down to the display.	In fact this same routine will now work for 3x3 soothing as well. - di 3/19/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect bitsPerColor mask updateRect scale p0 |  	"First compute color maps if any (nils are fine for RGB)"	(Display depth <= 8) ifTrue:		[mapDto32 _ (Color defaultColorMapFrom: Display depth to: 32) copy.		"Use 4 bits per color to map down from 32 bits to 8 or less"		"Following code copied from Color>>defaultColorMapFrom:"		bitsPerColor _ 4.   "... except for this"		map32toD _ Bitmap new: (1 bitShift: bitsPerColor*3).		mask _ (1 bitShift: bitsPerColor) - 1.		0 to: map32toD size - 1 do:			[:i | map32toD at: i+1 put:				((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)					green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)					blue: ((i bitShift: 0) bitAnd: mask)					range: mask)				pixelValueForDepth: Display depth)]].	"Now display 10 different alphas, across top of screen"	buff _ Form extent: 500@50 depth: 32.	dispToBuff _ BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay _ BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush _ Form extent: 3@3 depth: 32.	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).	scale _ 2.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	"Now paint with the brush using alpha blending."	buffSize _ 100.	buff _ Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"	dispToBuff _ (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"		sourceForm: Display;		colorMap: mapDto32;		combinationRule: Form over.	brushToBuff _ (BitBlt toForm: buff)  "From brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	buffToDisplay _ (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"		sourceForm: buff;		cellSize: scale;    "...and use 2x2 smoothing"		colorMap: map32toD;		combinationRule: Form over.	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP _ nil.		buffRect _ Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.		p0 _ (buff extent // 2) - (buffRect extent // 2).		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.buff displayAt: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p _ Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP _ p].				(p farFrom: prevP by: buffSize-1) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta _ (p-prevP) theta.					p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].				brushRect _ p extent: brush extent.				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta _ (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.					newBuffRect _ buffRect translateBy: delta negated.					p _ p translateBy: delta*scale.					prevP _ prevP translateBy: delta*scale.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].					buffRect _ newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP to: p withFirstPoint: false.buff displayAt: 0@0.				"Update (only) the altered pixels of the destination"				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.				updateRect _ updateRect origin // scale * scale						corner: updateRect corner + scale // scale * scale.				buffToDisplay copyQuad: updateRect innerCorners							toRect: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale).				prevP _ p]]]! !BitBltSimulation comment:'This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.'!!BitBltSimulation methodsFor: 'interpreter interface'!drawLoopX: xDelta Y: yDelta 	"This is the primitive implementation of the line-drawing loop.	See the comments in BitBlt>>drawLoopX:Y:"	| dx1 dy1 px py P affL affR affT affB |	xDelta > 0		ifTrue: [dx1 _ 1]		ifFalse: [xDelta = 0				ifTrue: [dx1 _ 0]				ifFalse: [dx1 _ -1]].	yDelta > 0		ifTrue: [dy1 _ 1]		ifFalse: [yDelta = 0				ifTrue: [dy1 _ 0]				ifFalse: [dy1 _ -1]].	px _ yDelta abs.	py _ xDelta abs.	affL _ affT _ 9999.  "init null rectangle"	affR _ affB _ -9999.	py > px		ifTrue: 			["more horizontal"			P _ py // 2.			1 to: py do: 				[:i |				destX _ destX + dx1.				(P _ P - px) < 0 ifTrue: 					[destY _ destY + dy1.					P _ P + py].				i < py ifTrue:					[self copyBits.					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							interpreterProxy showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]]		ifFalse: 			["more vertical"			P _ px // 2.			1 to: px do:				[:i |				destY _ destY + dy1.				(P _ P - py) < 0 ifTrue: 					[destX _ destX + dx1.					P _ P + px].				i < px ifTrue:					[self copyBits.					(affectedL < affectedR and: [affectedT < affectedB]) ifTrue:						["Affected rectangle grows along the line"						affL _ affL min: affectedL.						affR _ affR max: affectedR.						affT _ affT min: affectedT.						affB _ affB max: affectedB.						(affR - affL) * (affB - affT) > 4000 ifTrue:							["If affected rectangle gets large, update it in chunks"							affectedL _ affL.  affectedR _ affR.							affectedT _ affT.  affectedB _ affB.							interpreterProxy showDisplayBits.							affL _ affT _ 9999.  "init null rectangle"							affR _ affB _ -9999]].					]]].	"Remaining affected rect"	affectedL _ affL.  affectedR _ affR.	affectedT _ affT.  affectedB _ affB.	"store destX, Y back"		interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.	interpreterProxy storeInteger: BBDestYIndex ofObject: bitBltOop withValue: destY.!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 29]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchInteger: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchInteger: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchInteger: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchInteger: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchInteger: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchInteger: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchInteger: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchInteger: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchInteger: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	self inline: false.	"Load arguments and Scanner state"	scanStart _ start.	scanStop _ stop.	scanString _ string.	scanRightX _ rightX.	scanStopArray _ stopArray.	scanDisplayFlag _ displayFlag.	interpreterProxy success: (		(interpreterProxy isPointers: scanStopArray)			and: [(interpreterProxy lengthOf: scanStopArray) >= 1]).	scanXTable _ interpreterProxy fetchPointer: BBXTableIndex ofObject: bbObj.	interpreterProxy success: (		(interpreterProxy isPointers: scanXTable)			and: [(interpreterProxy lengthOf: scanXTable) >= 1]).	"width and sourceX may not be set..."	interpreterProxy storeInteger: BBWidthIndex ofObject: bbObj withValue: 0.	interpreterProxy storeInteger: BBSourceXIndex ofObject: bbObj withValue: 0.	"Now load BitBlt state if displaying"	scanDisplayFlag		ifTrue: [interpreterProxy success: (self loadBitBltFrom: bbObj)]		ifFalse: [bitBltOop _ bbObj.				destX _ interpreterProxy fetchInteger: BBDestXIndex ofObject: bbObj].	^interpreterProxy failed not!scanCharacters	| left top lastIndex charVal ascii sourceX2 nextDestX |	scanDisplayFlag ifTrue:		[self clipRange.  "Need to get true x, y for affectedRectangle"		left _ dx.		top _ dy].	lastIndex _ scanStart.	[lastIndex <= scanStop]		whileTrue: [			charVal _ interpreterProxy stObject: scanString at: lastIndex.			ascii _ interpreterProxy integerValueOf: charVal.			interpreterProxy failed ifTrue: [^ nil].			stopCode _ interpreterProxy stObject: scanStopArray at: ascii + 1.			interpreterProxy failed ifTrue: [^ nil].			stopCode = interpreterProxy nilObject				ifFalse: [^ self returnAt: ascii + 1							 lastIndex: lastIndex								  left: left								  top: top].			sourceX _ interpreterProxy stObject: scanXTable at: ascii + 1.			sourceX2 _ interpreterProxy stObject: scanXTable at: ascii + 2.			interpreterProxy failed ifTrue: [^ nil].			(interpreterProxy isIntegerObject: sourceX) & (interpreterProxy isIntegerObject: sourceX2)				ifTrue: [sourceX _ interpreterProxy integerValueOf: sourceX.						sourceX2 _ interpreterProxy integerValueOf: sourceX2]				ifFalse: [interpreterProxy primitiveFail. ^ nil].			nextDestX _ destX + (width _ sourceX2 - sourceX).			nextDestX > scanRightX				ifTrue: [^ self returnAt: CrossedX							 lastIndex: lastIndex								  left: left								  top: top].			scanDisplayFlag ifTrue: [self copyBits].			destX _ nextDestX.			interpreterProxy storeInteger: BBDestXIndex ofObject: bitBltOop withValue: destX.			lastIndex _ lastIndex + 1].	self returnAt: EndOfRun		 lastIndex: scanStop			  left: left			  top: top!setInterpreter: anInterpreter	"Interface for InterpreterSimulator. Allows BitBltSimulation object to send messages to the interpreter. The translator will replace sends to 'interpreterProxy' with sends to self, as if BitBltSimulation were part of the interpreter."	interpreterProxy _ anInterpreter.! !!BitBltSimulation methodsFor: 'accessing'!affectedBottom	^affectedB!affectedLeft	^affectedL!affectedRight	^affectedR!affectedTop	^affectedT!stopReason	^stopCode!targetForm	"Return the destination form of a copyBits or scanCharacters operation."	^destForm! !!BitBltSimulation methodsFor: 'setup'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[dx > sx ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	destX >= clipX		ifTrue: [sx _ sourceX.				dx _ destX.				bbW _ width]		ifFalse: [sx _ sourceX + (clipX - destX).				bbW _ width - (clipX - destX).				dx _ clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW _ bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy _ sourceY.				dy _ destY.				bbH _ height]		ifFalse: [sy _ sourceY + clipY - destY.				bbH _ height - (clipY - destY).				dy _ clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH _ bbH - ((dy + bbH) - (clipY + clipHeight))].	noSource ifTrue: [^ nil].	sx < 0		ifTrue: [dx _ dx - sx.				bbW _ bbW + sx.				sx _ 0].	sx + bbW > srcWidth		ifTrue: [bbW _ bbW - (sx + bbW - srcWidth)].	sy < 0		ifTrue: [dy _ dy - sy.				bbH _ bbH + sy.				sy _ 0].	sy + bbH > srcHeight		ifTrue: [bbH _ bbH - (sy + bbH - srcHeight)]!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	combinationRule = 22 ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]!destMaskAndPointerInit	"Compute masks for left and right destination words"	| startBits pixPerM1 endBits |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	"how many pixels in first word"	startBits _ pixPerWord - (dx bitAnd: pixPerM1).	mask1 _ AllOnes >> (32 - (startBits*destPixSize)).	"how many pixels in last word"	endBits _ ((dx + bbW - 1) bitAnd: pixPerM1) + 1.	mask2 _ AllOnes << (32 - (endBits*destPixSize)).	"determine number of words stored per line; merge masks if only 1"	bbW < startBits		ifTrue: [mask1 _ mask1 bitAnd: mask2.				mask2 _ 0.				nWords _ 1]		ifFalse: [nWords _ (bbW - startBits) + pixPerM1 // pixPerWord + 1].	hDir _ vDir _ 1. "defaults for no overlap with source"	"calculate byte addr and delta, based on first word of data"	"Note raster and nwords are longs, not bytes"	destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).	destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir)).  "byte addr delta"!ignoreSourceOrHalftone: formPointer	formPointer = interpreterProxy nilObject ifTrue: [ ^true ].	combinationRule = 0 ifTrue: [ ^true ].	combinationRule = 5 ifTrue: [ ^true ].	combinationRule = 10 ifTrue: [ ^true ].	combinationRule = 15 ifTrue: [ ^true ].	^false!returnAt: stopIndex lastIndex: lastIndex left: left top: top	stopCode _ interpreterProxy stObject: scanStopArray at: stopIndex.	interpreterProxy failed ifTrue: [^ nil].	interpreterProxy storeInteger: BBLastIndex ofObject: bitBltOop withValue: lastIndex.	scanDisplayFlag ifTrue: [		"Now we know extent of affected rectangle"		affectedL _ left.		affectedR _ bbW + dx.		affectedT _ top.		affectedB _ bbH + dy.	].!sourceSkewAndPointerInit	"This is only used when source and dest are same depth,	ie, when the barrel-shift copy loop is used."	| dWid sxLowBits dxLowBits pixPerM1 |	pixPerM1 _ pixPerWord - 1.  "A mask, assuming power of two"	sxLowBits _ sx bitAnd: pixPerM1.	dxLowBits _ dx bitAnd: pixPerM1.	"check if need to preload buffer	(i.e., two words of source needed for first word of destination)"	hDir > 0 ifTrue:		["n Bits stored in 1st word of dest"		dWid _ bbW min: pixPerWord - dxLowBits.		preload _ (sxLowBits + dWid) > pixPerM1]	ifFalse:		[dWid _ bbW min: dxLowBits + 1.		preload _ (sxLowBits - dWid + 1) < 0].	"calculate right-shift skew from source to dest"	skew _ (sxLowBits - dxLowBits) * destPixSize.  " -32..32 "	preload ifTrue: 		[skew < 0			ifTrue: [skew _ skew+32]			ifFalse: [skew _ skew-32]].	"Calc byte addr and delta from longWord info"	sourceIndex _ (sourceBits + 4) + (sy * sourceRaster + (sx // (32//sourcePixSize)) *4).	"calculate increments from end of 1 line to start of next"	sourceDelta _ 4 * ((sourceRaster * vDir) - (nWords * hDir)).	preload ifTrue:		["Compensate for extra source word fetched"		sourceDelta _ sourceDelta - (4*hDir)].!warpBits	| ns |	ns _ noSource.  noSource _ true.		self clipRange.  "noSource suppresses sourceRect clipping"		noSource _ ns.	(noSource or: [bbW <= 0 or: [bbH <= 0]]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	self warpLoop. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop'!copyLoop 	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask |	"This version of the inner loop assumes noSource = false."	self inline: false.	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			sourceIndex _ sourceIndex + hInc.			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)								with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]!copyLoopNoSource	| halftoneWord mergeWord |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask1 bitAnd: mergeWord)					bitOr: (mask1 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[mergeWord _ self merge: halftoneWord with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((mask2 bitAnd: mergeWord)					bitOr: (mask2 bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord destMask srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap |	self inline: false.	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	sourcePixMask _ (1 bitShift: sourcePixSize) - 1.	destPixMask _ (1 bitShift: destPixSize) - 1.	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]!warpLoop	| skewWord halftoneWord mergeWord destMask startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchInteger: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchInteger: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchInteger: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchInteger: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchInteger: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchInteger: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchInteger: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchInteger: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].		].	pAx _ pAx + deltaP12x.	pAy _ pAy + deltaP12y.	pBx _ pBx + deltaP43x.	pBy _ pBy + deltaP43y.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules'!alphaBlend: sourceWord with: destinationWord	"Blend sourceWord with destinationWord, assuming both are 32-bit pixels.	The source is assumed to have 255*alpha in the high 8 bits of each pixel,	while the high 8 bits of the destinationWord will be ignored.	The blend produced is alpha*source + (1-alpha)*dest, with	the computation being performed independently on each color	component.  The high byte of the result will be 0."	| alpha unAlpha colorMask result blend shift |	self inline: false.	alpha _ sourceWord >> 24.  "High 8 bits of source pixel"	unAlpha _ 255 - alpha.	colorMask _ 16rFF.	result _ 0.	1 to: 3 do:		[:i | shift _ (i-1)*8.		blend _ (((sourceWord>>shift bitAnd: colorMask) * alpha)					+ ((destinationWord>>shift bitAnd: colorMask) * unAlpha))			 	+ 254 // 255 bitAnd: colorMask.		result _ result bitOr: blend<<shift].	^ result!merge: sourceWord with: destinationWord"	^ self dispatchOn: combinationRule		with: sourceWord with: destinationWord		in: RuleTable."	self inline: true.	"These are the combination rules..."combinationRule < 16 ifTrue:[combinationRule < 8 ifTrue:	[combinationRule < 4 ifTrue:		[combinationRule < 2 ifTrue:			[combinationRule < 1 ifTrue:				["0" ^ 0]				ifFalse:				["1" ^ sourceWord bitAnd: destinationWord]]			ifFalse:			[combinationRule < 3 ifTrue:				["2" ^ sourceWord bitAnd: destinationWord bitInvert32]				ifFalse:				["3" ^ sourceWord]]]		ifFalse:		[combinationRule < 6 ifTrue:			[combinationRule < 5 ifTrue:				["4" ^ sourceWord bitInvert32 bitAnd: destinationWord]				ifFalse:				["5" ^ destinationWord]]			ifFalse:			[combinationRule < 7 ifTrue:				["6" ^ sourceWord bitXor: destinationWord]				ifFalse:				["7" ^ sourceWord bitOr: destinationWord]]]]	ifFalse:	[combinationRule < 12 ifTrue:		[combinationRule < 10 ifTrue:			[combinationRule < 9 ifTrue:				["8" ^ sourceWord bitInvert32 bitAnd: destinationWord bitInvert32]				ifFalse:				["9" ^ sourceWord bitInvert32 bitXor: destinationWord]]			ifFalse:			[combinationRule < 11 ifTrue:				["10" ^ destinationWord bitInvert32]				ifFalse:				["11" ^ sourceWord bitOr: destinationWord bitInvert32]]]		ifFalse:		[combinationRule < 14 ifTrue:			[combinationRule < 13 ifTrue:				["12" ^ sourceWord bitInvert32]				ifFalse:				["13" ^ sourceWord bitInvert32 bitOr: destinationWord]]			ifFalse:			[combinationRule < 15 ifTrue:				["14" ^ sourceWord bitInvert32 bitOr: destinationWord bitInvert32]				ifFalse:				["15" ^ destinationWord]]]]]ifFalse:[combinationRule < 24 ifTrue:	[combinationRule < 20 ifTrue:		[combinationRule < 18 ifTrue:			[combinationRule < 17 ifTrue:				["16" ^ destinationWord "no op"]				ifFalse:				["17" ^ destinationWord "no op"]]			ifFalse:			[combinationRule < 19 ifTrue:				["18" ^ sourceWord + destinationWord]				ifFalse:				["19" ^ sourceWord - destinationWord]]]		ifFalse:		[combinationRule < 22 ifTrue:			[combinationRule < 21 ifTrue:				["20" ^ self rgbAdd: sourceWord with: destinationWord]				ifFalse:				["21" ^ self rgbSub: sourceWord with: destinationWord]]			ifFalse:			[combinationRule < 23 ifTrue:				["22" ^ self rgbDiff: sourceWord with: destinationWord]				ifFalse:				["23" ^ self tallyIntoMap: destinationWord]]]]	ifFalse:	[combinationRule < 28 ifTrue:		[combinationRule < 26 ifTrue:			[combinationRule < 25 ifTrue:				["24" ^ self alphaBlend: sourceWord with: destinationWord]				ifFalse:				["25"  ^ self pixPaint: sourceWord with: destinationWord]]			ifFalse:			[combinationRule < 27 ifTrue:				["26" ^ self pixMask: sourceWord with: destinationWord]				ifFalse:				["27" ^ self rgbMax: sourceWord with: destinationWord]]]		ifFalse:		[combinationRule < 30 ifTrue:			[combinationRule < 29 ifTrue:				["28" ^ self rgbMin: sourceWord with: destinationWord]				ifFalse:				["29" ^ self rgbMin: sourceWord bitInvert32 with: destinationWord]]			ifFalse:			[combinationRule < 31 ifTrue:				["30" ^ destinationWord "no op"]				ifFalse:				["31" ^ destinationWord "no op"]]]]]!partitionedAdd: word1 to: word2 nBits: nBits nPartitions: nParts	"Add word1 to word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask sum result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		sum _ (word1 bitAnd: mask) + (word2 bitAnd: mask).		sum <= mask  "result must not carry out of partition"			ifTrue: [result _ result bitOr: sum]			ifFalse: [result _ result bitOr: mask].		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedAND: word1 to: word2 nBits: nBits nPartitions: nParts	"AND word1 to word2 as nParts partitions of nBits each.	Any field of word1 not all-ones is treated as all-zeroes.	Used for erasing, eg, brush shapes prior to ORing in a color"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		(word1 bitAnd: mask) = mask			ifTrue: [result _ result bitOr: (word2 bitAnd: mask)].		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedMax: word1 with: word2 nBits: nBits nPartitions: nParts	"Max word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) max: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedMin: word1 with: word2 nBits: nBits nPartitions: nParts	"Min word1 to word2 as nParts partitions of nBits each"	| mask result |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		result _ result bitOr: ((word2 bitAnd: mask) min: (word1 bitAnd: mask)).		mask _ mask << nBits  "slide left to next partition"].	^ result!partitionedSub: word1 from: word2 nBits: nBits nPartitions: nParts	"Subtract word1 from word2 as nParts partitions of nBits each.	This is useful for packed pixels, or packed colors"	| mask result p1 p2 |	mask _ (1 << nBits) - 1.  "partition mask starts at the right"	result _ 0.	1 to: nParts do:		[:i |		p1 _ word1 bitAnd: mask.		p2 _ word2 bitAnd: mask.		p1 < p2  "result is really abs value of thedifference"			ifTrue: [result _ result bitOr: p2 - p1]			ifFalse: [result _ result bitOr: p1 - p2].		mask _ mask << nBits  "slide left to next partition"].	^ result!pixMask: sourceWord with: destinationWord	self inline: false.	^ self partitionedAND: sourceWord bitInvert32 to: destinationWord					nBits: destPixSize nPartitions: pixPerWord!pixPaint: sourceWord with: destinationWord	self inline: false.	^ sourceWord bitOr:		(self partitionedAND: sourceWord bitInvert32 to: destinationWord						nBits: destPixSize nPartitions: pixPerWord)!rgbAdd: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Add each pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Add RGB components of each pixel separately"		^ (self partitionedAdd: sourceWord to: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedAdd: sourceWord>>16 to: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Add RGB components of the pixel separately"		^ self partitionedAdd: sourceWord to: destinationWord						nBits: 8 nPartitions: 3]!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"!rgbMax: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Max each pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Max RGB components of each pixel separately"		^ (self partitionedMax: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMax: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Max RGB components of the pixel separately"		^ self partitionedMax: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]!rgbMin: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Min each pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Min RGB components of each pixel separately"		^ (self partitionedMin: sourceWord with: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedMin: sourceWord>>16 with: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Min RGB components of the pixel separately"		^ self partitionedMin: sourceWord with: destinationWord						nBits: 8 nPartitions: 3]!rgbSub: sourceWord with: destinationWord	self inline: false.	destPixSize < 16 ifTrue:		["Sub each pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: destPixSize nPartitions: pixPerWord].	destPixSize = 16 ifTrue:		["Sub RGB components of each pixel separately"		^ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3)		+ ((self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3) << 16)]	ifFalse:		["Sub RGB components of the pixel separately"		^ self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3]!tallyIntoMap: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: destinationWord from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'pixel mapping'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments."	x2 > x1		ifTrue: [^ x2 - x1 + FixedPt1 // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + FixedPt1 // (n+1) + 1)]!pickSourcePixels: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This is intended to be expanded in-line; it merely calls the others"	sourcePixSize >= 16 ifTrue:		[^ self pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask].	nullMap ifTrue:		[^ self pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask].	^ self pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask!pickSourcePixels: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for sourcePixSize <= 8		and colorMap notNil"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord."	| sourceWord destWord sourcePix destPix |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		"look up sourcePix in colorMap"		destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask.		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!pickSourcePixelsNullMap: nPix srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for colorMap==nil.		SourcePixelSize is also known to be 8 bits or less."	"With no color map, pixels are just masked or zero-filled."	| sourceWord destWord sourcePix |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		destWord _ (destWord << destPixSize) 					bitOr: (sourcePix bitAnd: destPixMask).		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!pickSourcePixelsRGB: nPix nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask	"This version of pickSourcePixels is for destPixSize >= 16"	"Pick nPix pixels from the source, mapped by the	color map, and right-justify them in the resulting destWord.	Incoming pixels of 16 or 32 bits are first reduced to cmBitsPerColor.	With no color map, pixels are just masked or zero-filled or	if 16- or 32-bit pixels, the r, g, and b are so treated individually."	| sourceWord destWord sourcePix destPix |	sourceWord _ (interpreterProxy longAt: sourceIndex).	destWord _ 0.	1 to: nPix do:		[:i |		sourcePix _ sourceWord >> ((32-sourcePixSize) - srcBitIndex)					bitAnd: sourcePixMask.		nullMap		ifTrue:			["Map between RGB pixels"			sourcePixSize = 16				ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]				ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]		ifFalse:			["RGB pixels first get reduced to cmBitsPerColor"			sourcePixSize = 16				ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]				ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor].			"Then look up sourcePix in colorMap"			destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask].		destWord _ (destWord << destPixSize) bitOr: destPix.		(srcBitIndex _ srcBitIndex + sourcePixSize) > 31 ifTrue:			[srcBitIndex _ srcBitIndex - 32.			sourceIndex _ sourceIndex + 4.			sourceWord _ interpreterProxy longAt: sourceIndex]].	^ destWord!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			^ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut)]!smoothPix: n atXf: xf yf: yf dxh: dxh dyh: dyh dxv: dxv dyv: dyv	pixPerWord: srcPixPerWord pixelMask: sourcePixMask	sourceMap: sourceMap	| sourcePix r g b x y rgb bitsPerColor d nPix |	r _ g _ b _ 0.  "Separate r, g, b components"	nPix _ n*n.	x _ xf.  y _ yf.	0 to: n-1 do:		[:i |		0 to: n-1 do:			[:j |			sourcePix _ (self sourcePixAtX: x + (dxh*i) + (dxv*j)  >> BinaryPoint									y: y + (dyh*i) + (dyv*j)  >> BinaryPoint									pixPerWord: srcPixPerWord)									bitAnd: sourcePixMask.			sourcePixSize < 16				ifTrue: ["Get 24-bit RGB values from sourcemap table"						rgb _ (interpreterProxy fetchWord: sourcePix ofObject: sourceMap) bitAnd: 16rFFFFFF]				ifFalse: ["Already in RGB format"						sourcePixSize = 32						ifTrue: [rgb _ sourcePix bitAnd: 16rFFFFFF]						ifFalse: ["Note could be faster"								rgb _ self rgbMap: sourcePix from: 5 to: 8]].			r _ r + ((rgb >> 16) bitAnd: 16rFF).			g _ g + ((rgb >> 8) bitAnd: 16rFF).			b _ b + (rgb bitAnd: 16rFF).			].		].	colorMap ~= interpreterProxy nilObject		ifTrue: [bitsPerColor _ cmBitsPerColor]		ifFalse: [destPixSize = 16 ifTrue: [bitsPerColor _ 5].				destPixSize = 32 ifTrue: [bitsPerColor _ 8]].	d _ 8 - bitsPerColor.	rgb _ ((r // nPix >> d) << (bitsPerColor*2))		+ ((g // nPix >> d) << bitsPerColor)		+ ((b // nPix >> d)).	colorMap ~= interpreterProxy nilObject		ifTrue: [^ interpreterProxy fetchWord: rgb ofObject: colorMap]		ifFalse: [^ rgb]!sourcePixAtX: x y: y pixPerWord: srcPixPerWord	| sourceWord index |	self inline: true.	(x < 0 or: [x >= srcWidth]) ifTrue: [^ 0].	(y < 0 or: [y >= srcHeight]) ifTrue: [^ 0].	index _ (y * sourceRaster + (x // srcPixPerWord) *4).												"4 = BaseHeaderSize"	sourceWord _ interpreterProxy longAt: sourceBits + 4 + index.	^ sourceWord >> ((32-sourcePixSize) - (x\\srcPixPerWord*sourcePixSize))!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	sourcePixMask _ (1 << sourcePixSize) - 1.	srcPixPerWord _ 32 // sourcePixSize.	destPixMask _ (1 << destPixSize) - 1.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !!BitBltSimulation class methodsFor: 'initialization'!initialize	"BitBltSimulation initialize" 	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.!test2  "BitBltSimulation test2"	| f |	Display fillWhite: (0@0 extent: 300@140).	1 to: 12 do:		[:i | f _ (Form extent: i@5) fillBlack.		0 to: 20 do:			[:x | f displayOn: Display					at: (x*13) @ (i*10)]]!timingTest: extent  "BitBltSimulation timingTest: 640@480"	| f f2 map |	f _ Form extent: extent depth: 8.	f2 _ Form extent: extent depth: 8.	map _ Bitmap new: 1 << f2 depth.	^ Array with:	(Time millisecondsToRun: [100 timesRepeat:		[f fillWithColor: Color white]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copy: f boundingBox from: 0@0 in: f2 rule: Form over]])	with:	(Time millisecondsToRun: [100 timesRepeat:		[f copyBits: f boundingBox from: f2 at: 0@0 colorMap: map]])! !!BitBltSimulation class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	"Nothing to declare..."! !!BitEditor methodsFor: 'control defaults'!redButtonActivity	| formPoint displayPoint |	model depth = 1 ifTrue:		["If this is just a black&white form, then set the color to be		the opposite of what it was where the mouse was clicked"		formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		color _ 1-(view workingForm pixelValueAt: formPoint).		squareForm fillColor: (color=1 ifTrue: [Color black] ifFalse: [Color white])].	[sensor redButtonPressed]	  whileTrue: 		[formPoint _ (view inverseDisplayTransform: sensor cursorPoint - (scale//2)) rounded.		displayPoint _ view displayTransform: formPoint.		squareForm 			displayOn: Display			at: displayPoint 			clippingBox: view insetDisplayBox 			rule: Form over			fillColor: nil.		view changeValueAt: formPoint put: color]! !!BitEditor class methodsFor: 'private'!buildColorMenu: extent colorCount: nColors	"See BitEditor magnifyWithSmall."	| menuView form aSwitchView	button formExtent highlightForm color leftOffset |	menuView _ FormMenuView new.	menuView window: (0@0 corner: extent).	formExtent _ 30@30 min: extent//(nColors*2+1@2).  "compute this better"	leftOffset _ extent x-(nColors*2-1*formExtent x)//2.	highlightForm _ Form extent: formExtent.	highlightForm borderWidth: 4.	1 to: nColors do:		[:index | 		color _ (nColors=1			ifTrue: [#(black)]			ifFalse: [#(black gray)]) at: index.		form _ Form extent: formExtent.		form fill: form boundingBox fillColor: (Color perform: color).		form borderWidth: 5.		form border: form boundingBox width: 4 fillColor: form white.		button _ Button new.		index = 1 ifTrue:			[button onAction: [menuView model setColor: Color fromUser]]			ifFalse:			[button onAction: [menuView model setTransparentColor]].		aSwitchView _ SwitchView new model: button.		aSwitchView key: ((nColors=3 ifTrue: ['xvn'] ifFalse: ['xn']) at: index).		aSwitchView label: form.		aSwitchView window: (0@0 extent: form extent).		aSwitchView translateBy: (index-1*2*form width+leftOffset) @ (form height//2).		aSwitchView highlightForm: highlightForm.			aSwitchView borderWidth: 1.		aSwitchView controller selector: #turnOn.		menuView addSubView: aSwitchView].	^menuView!locateMagnifiedView: aForm scale: scaleFactor	"Answer a rectangle at the location where the scaled view of the form,	aForm, should be displayed."	^ Rectangle originFromUser: (aForm extent * scaleFactor + (0@50)).	! !!Bitmap methodsFor: 'accessing'!pixelValueForDepth: depth	"Self is being used to represent a single color.  Answer bits that appear in ONE pixel of this color in a Bitmap of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32.  Returns an integer.  First pixel only.  3/15/97 tk"	^ (self at: 1) bitAnd: (1 bitShift: depth) - 1!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	<primitive: 145>	self errorImproperStore.! !!BlockNode methodsFor: 'initialize-release'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast _ returnBool.	returns _ false.	statements _ 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast _ false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments _ Array new: 0.	returnLast ifTrue: [self returnLast]! !!BlockNode methodsFor: 'code generation'!emitForValue: stack on: aStream	aStream nextPut: LdThisContext.	stack push: 1.	nArgsNode emitForValue: stack on: aStream.	remoteCopyNode		emit: stack		args: 1		on: aStream.	"Force a two byte jump."	self emitLong: size code: JmpLong on: aStream.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].	self emitForEvaluatedValue: stack on: aStream.	self returns ifFalse: [aStream nextPut: EndRemote].	stack pop: 1! !!BlockNode methodsFor: 'printing'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level _ 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len _ shown _ statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown _ 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown _ shown - 1]].	1 to: shown do: 		[:i | 		thisStatement _ statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		thisStatement comment size > 0			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'C translation'!asTranslatorNode	| statementList newS |	statementList _ OrderedCollection new.	statements do: [ :s |		newS _ s asTranslatorNode.		newS isStmtList ifTrue: [			"inline the statement list returned when a CascadeNode is translated"			statementList addAll: newS statements.		] ifFalse: [			statementList add: newS.		].	].	^TStmtListNode new		setArguments: (arguments asArray collect: [ :arg | arg key ])		statements: statementList! !!BookMorph methodsFor: 'all'!addButtonRow	| r |	r _ LayoutMorph newRow color: color.	r addMorphBack: (SimpleButtonMorph new		target: self;		label: 'Previous';		actionSelector: #previousPage).	r addMorphBack: (SimpleButtonMorph new		target: self;		label: 'Next';		actionSelector: #nextPage).	r addMorphBack: (SimpleButtonMorph new		target: self;		label: 'Insert Page';		actionSelector: #insertPage).	r addMorphBack: (SimpleButtonMorph new		target: self;		label: 'Delete Page';		actionSelector: #deletePage).	self addMorphFront: r.!deletePage	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].!initialize	super initialize.	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 4.	color _ Color r: 0.8 g: 0.8 b: 0.8.	self borderWidth: 2.	pages _ OrderedCollection new.	self addButtonRow.	self insertPage.!insertPage	| newPage |	newPage _ Morph new extent: self pageSize.	newPage color: (Color r: 0.937 g: 0.937 b: 0.937).	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.!nextPage	| i |	pages isEmpty ifTrue: [^ self].	i _ (pages indexOf: currentPage ifAbsent: [0]) + 1.	i > pages size ifTrue: [i _ pages size].	currentPage delete.	currentPage _ pages at: i.	self addMorphBack: currentPage.	self world ifNotNil: [		self world startSteppingSubmorphsOf: currentPage].!pages: aPageList	pages _ aPageList asOrderedCollection.	pages size > 0		ifTrue: [currentPage _ pages first]		ifFalse: [self insertPage].!pageSize	^ 300@400!previousPage	| i |	pages isEmpty ifTrue: [^ self].	i _ (pages indexOf: currentPage ifAbsent: [2]) - 1.	i < 1 ifTrue: [i _ 1].	currentPage delete.	currentPage _ pages at: i.	self addMorphBack: currentPage.	self world startSteppingSubmorphsOf: currentPage.! !BouncingAtomsMorph comment:'This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:  1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.'!!BouncingAtomsMorph methodsFor: 'all'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to be circles of known radius. This version uses the morph's positions--i.e. the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared |	count _ submorphs size.	sortedAtoms _ submorphs asSortedCollection:		[ :m1 :m2 | m1 position x < m2 position x].	radius _ 8.	twoRadii _ 2 * radius.	radiiSquared _ radius squared * 2.	collisions _ OrderedCollection new.	1 to: count - 1 do: [ :i |		m1 _ sortedAtoms at: i.		p1 _ m1 position.		continue _ (j _ i + 1) <= count.		[continue] whileTrue: [			m2 _ sortedAtoms at: j.			p2 _ m2 position.			(p2 x - p1 x) <= twoRadii  ifTrue: [				distSquared _ (p1 x - p2 x) squared + (p1 y - p2 y) squared.				distSquared < radiiSquared ifTrue: [					collisions add: (Array with: m1 with: m2)].				continue _ (j _ j + 1) <= count.			] ifFalse: [				continue _ false.			].		].	].	^ collisions!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported _ false.!initialize	super initialize.	damageReported _ false.	self extent: 400@250.	self color: (Color red: 0.8 green: 1.0 blue: 0.8).	infectionHistory _ OrderedCollection new.	transmitInfection _ false.!invalidRect: damageRect	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw _ true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds].  "just report once"		damageReported _ true.	] ifFalse: [super invalidRect: damageRect].  "ordinary damage report"!setGermCount	| countString count |	countString _ FillInTheBlank		request: 'Number of cells?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory _ OrderedCollection new: 500.	transmitInfection _ true.	self startStepping.!step	"Bounce those atoms!!"	| r |	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [m bounceIn: r]].	transmitInfection ifTrue: [self transmitInfection].!stepTime	"As fast as possible."	^ 0!transmitInfection	| infected count graph |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		"done!! place a graph of the infection history in the world"		graph _ GraphMorph new data: infectionHistory.		graph position: bounds topRight + (10@0).		graph extent: (((infectionHistory size * 3) + (2 * graph borderWidth))@count).		self world addMorph: graph.		graph changed.		transmitInfection _ false.		self stopStepping].! !!BouncingAtomsMorph class methodsFor: 'all'!new	^ super new addAtoms: 30! !!BraceNode methodsFor: 'code generation'!emitForValue: stack on: aStream	"elem1, ..., elemN, collectionClass, N, fromBraceStack:"	elements do: [:element | element emitForValue: stack on: aStream].	collClassNode emitForValue: stack on: aStream.	nElementsNode emitForValue: stack on: aStream.	fromBraceStackNode emit: stack args: 1 on: aStream.	stack pop: elements size! !!Browser methodsFor: 'system category functions'!browseAllClasses	"Create and schedule a new browser on all classes alphabetically."	| newBrowser view |	newBrowser _ HierarchyBrowser new initAlphabeticListing.	BrowserView openBrowserView: (BrowserView systemCategoryBrowser: newBrowser editString: nil)		label: 'All Classes Alphabetically'! !!Browser methodsFor: 'class list'!classListIndex: anInteger         "Set anInteger to be the index of the current class selection."        | className |classListIndex _ anInteger.        self setClassOrganizer.        messageCategoryListIndex _ 0.        messageListIndex _ 0.        editSelection _ anInteger = 0                        ifTrue: [metaClassIndicated                                ifTrue: [#none]                                ifFalse: [#newClass]]                        ifFalse: [#editClass].        contents _ nil.        self selectedClass isNil                ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)                                ifTrue: [RecentClasses remove: className].                        RecentClasses addFirst: className.                        RecentClasses size > 16                                ifTrue: [RecentClasses removeLast]].        self changed: #classSelectionChanged!hierarchy        "Display the inheritance hierarchy of the receiver's selected class."        classListIndex = 0 ifTrue: [^ self].        self okToChange ifFalse: [^ self].        self messageCategoryListIndex: 0.        editSelection := #hierarchy.        self changed: #editComment.        ^ self!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 12/19/96 sw: dont fall into debugger in empty case"	| className class recentList |	recentList _ RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ self beep].	className := (SelectionMenu selections: recentList) startUp.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self systemCategoryListIndex: (self systemCategoryList indexOf: class category).	self classListIndex: (self classList indexOf: class name)!selectClass: classNotMeta	self classListIndex: (self classList findFirst: [:each | each == classNotMeta name])!spawnHierarchy        "Create and schedule a new class hierarchy browser on the currently selected class or meta."        | newBrowser view |        classListIndex = 0 ifTrue: [^ self].        newBrowser _ HierarchyBrowser new initHierarchyForClass: self selectedClass                         meta: self metaClassIndicated.        view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.        Browser postOpenSuggestion: (Array with: self selectedClassOrMetaClass                         with: self selectedMessageName).        BrowserView openBrowserView: view                label: self selectedClassName , ' hierarchy'! !!Browser methodsFor: 'class functions'!spawnProtocol        "Create and schedule a new protocol browser on the currently selected class or meta."        classListIndex = 0 ifTrue: [^ self].        ProtocolBrowser openSubProtocolForClass: self selectedClass ! !!Browser methodsFor: 'message functions'!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"!methodHierarchy 	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| sel list tab stab |	messageListIndex = 0 ifTrue: [^ self].	sel _ self selectedMessageName.	list _ OrderedCollection new.	tab _ ''.	self selectedClassOrMetaClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	self selectedClassOrMetaClass allSubclassesWithLevelDo:		[:cl :level |		(cl includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , cl name, ' ', sel]]	 	startingLevel: 0.	Smalltalk browseMessageList: list		name: 'Inheritance of ' , self selectedMessageName! !!Browser methodsFor: 'metaclass'!classMessagesIndicated	"Answer whether the messages to be presented should come from the 	metaclass."	^ self metaClassIndicated!classOrMetaClassOrganizer	"Answer the class organizer for the metaclass or class, depending on 	which (instance or class) is indicated."	self metaClassIndicated		ifTrue: [^metaClassOrganizer]		ifFalse: [^classOrganizer]!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass class]		ifFalse: [^ self selectedClass]!setClassOrganizer	"Install whatever organization is appropriate"	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	self metaClassIndicated		ifTrue: [metaClassOrganizer _ self selectedClass class organization]		ifFalse: [classOrganizer _ self selectedClass organization]! !!Browser class methodsFor: 'instance creation'!newOnClass: aClass 	"Open a new class browser on this class."	| index newBrowser |	newBrowser _ Browser new.	newBrowser systemCategoryListIndex:		(index _ SystemOrganization numberOfCategoryOfElement: aClass name).	newBrowser classListIndex: ((SystemOrganization listAtCategoryNumber: index)			findFirst: [:each | each == aClass name]).	newBrowser metaClassIndicated: false.	BrowserView openClassBrowser: newBrowser editString: nil label: 'Class Browser:', aClass name! !!Browser class methodsFor: 'class initialization'!initialize        "Browser initialize"        RecentClasses := OrderedCollection new! !!BrowserCodeController methodsFor: 'menu messages'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply |	Cursor execute		showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.			sorry _ sorry , (model isUnlocked							ifTrue: ['"']							ifFalse: ['  Also, please cancel or accept."']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: 					[string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are 					all  					letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: [])						~~ nil						ifFalse: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model class == Browser])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , NewLine].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:symbol | symbol])						ifTrue: 							[cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: 									[cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , NewLine].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , NewLine].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]!format	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText locked |	locked _ model isLocked.	model messageListIndex = 0 | locked ifTrue: [^view flash].	selectedClass _ model selectedClassOrMetaClass.	Cursor execute showWhile: 		[aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: self.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1]].	locked ifFalse: [self unlockModel] !showBytecodes	"Show the bytecodes of the selected method."	| selectedClass newText |	(model messageListIndex = 0) | (model isLocked) ifTrue: [		^view flash.	].	selectedClass _ model selectedClassOrMetaClass.	Cursor execute showWhile: [		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ (selectedClass compiledMethodAt: model selectedMessageName) symbolic asText.		self replaceSelectionWith: newText.		self selectAt: 1.	].	self unlockModel.! !!BrowserCodeController methodsFor: 'private'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	class _ model selectedClass.	class == nil ifTrue: [^nil].	  "no class is selected"	(class isKindOf: Metaclass) ifTrue: [class _ class soleInstance].	classes _ (Array with: class) , class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames			detect: [:name | symbol = name] ifNone: [])			~~ nil] ifNone: [].	reply == nil ifFalse: [^'"is a class variable; defined in class ' , reply printString, '"', NewLine,		'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]			ifNone: []) ~~ nil].	reply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].	reply == nil		ifFalse: 			[classes _ WriteStream on: Array new.			Smalltalk allBehaviorsDo: [:each |					(each sharedPools detect: [:pool | pool == reply] ifNone: [])					~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^'"is a pool variable from the pool ' , (Smalltalk keyAtValue: reply),			', which is used by the following classes ' , classes contents printString , '"', NewLine,			'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtValue: reply) printString,			' associationAt: #', symbol, ').'].	^nil!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str _ string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', NewLine, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	reply class == Dictionary		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'!explainInst: string 	"Is string an instance variable of this class?"	| classes |	model selectedClassOrMetaClass == nil ifTrue: [^nil].	  "no class is selected"	classes _ (Array with: model selectedClassOrMetaClass)				, model selectedClassOrMetaClass allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , '"',		NewLine , classes , ' browseAllAccessesTo: ''' , string , '''.'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s |	model messageListIndex = 0 ifTrue: [^nil].  "not in a message"	string last == $: ifFalse: [^nil].	"Name of this method"	lits _ Array with: model selectedMessageName.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				model selectedMessageName) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!BrowserListView methodsFor: 'updating'!getListAndDisplayView	"Display the list of items."	| newList |	newList _ self getList.	isEmpty & newList isEmpty		ifTrue: [^self]		ifFalse: 			[self list: newList.			model maybeSetSelection.			self displayView; emphasizeView]! !!BrowserView class methodsFor: 'instance creation'!instanceBrowserViewOn: aBrowser	"Answer an instance of me on the model, aBrowser, which looks at a user-defined instance-class. The view has three subviews.  3/11/96 sw"	| browserView  messageCategoryListView messageListView browserCodeView |	browserView _ self new model: aBrowser.	messageCategoryListView _ self buildMessageCategoryListView: aBrowser.	messageListView _ self buildMessageListView: aBrowser.	browserCodeView _ self buildBrowserCodeView: aBrowser editString: nil.	browserView addSubView: messageCategoryListView.	browserView addSubView: messageListView.	browserView addSubView: browserCodeView.	messageListView 		align: messageListView viewport topLeft 		with: messageCategoryListView viewport topRight.	browserCodeView 		window: browserCodeView window 		viewport: (messageCategoryListView viewport bottomLeft 					corner: messageListView viewport bottomRight + (0 @ 110)).	^ browserView! !!ButtonMorph methodsFor: 'as yet unclassified'!acceptScript: aScriptEditorMorph for: ignored	lastAcceptedScript _ aScriptEditorMorph.	self world model class		compile: lastAcceptedScript methodString		classified: 'scripts'		notifying: nil.!buttonUpSelector	^ (self nameInModel, 'ButtonUp') asSymbol!choosePartName	"Override to add null on-ticks script when this morph is named."	| newName |	newName _ super choosePartName.	newName ifNil: [^ self].  "user cancelled or chose a bad part name"	(self world model class)		compile: self buttonUpSelector		classified: 'scripts'		notifying: nil.!choosePartNameSilently	super choosePartNameSilently.	(self world model class)		compile: self buttonUpSelector		classified: 'scripts'		notifying: nil.!copy	^ super copy initScripts!doButtonAction	self nameInModel ~~ nil ifTrue: [		self world model perform: self buttonUpSelector].!initScripts	"Used to remove the scripts from a newly made copy of myself."	lastAcceptedScript _ lastScriptEditor _ nil.!parts	^ #(position)! !!ButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	aCustomMenu add: 'border color' action: #changeBorderColor.	aCustomMenu add: 'border width' action: #changeBorderWidth.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'script' action: #editScript:.!editScript: evt	self nameInModel ifNil: [self choosePartNameSilently].	evt hand attachMorph:		(self scriptEditorFor: 'buttonUp').!scriptEditorFor: ignored	(lastScriptEditor ~= nil and: [lastScriptEditor isInWorld])		ifTrue: [^ lastScriptEditor].	lastAcceptedScript = nil ifTrue: [		^ lastScriptEditor _ ScriptEditorMorph new			setMorph: self			scriptName: 'ButtonUp'.	] ifFalse: [		^ lastScriptEditor _ lastAcceptedScript fullCopy].! !!ByteArray methodsFor: 'accessing'!asString	"Convert to a String with Characters for each byte.	Fast code uses primitive that avoids character conversion"	^ (String new: self size) replaceFrom: 1 to: self size with: self! !Canvas comment:'A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium (such as a window, pixmap, or postscript script).This kind of canvas does no drawing, and may be used as a "null canvas" to factor out drawing time during performance measurements.'!!Canvas methodsFor: 'initialization'!reset	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	shadowDrawing _ false.					"draw translucent shadows when true"! !!Canvas methodsFor: 'copying'!copyClipRect: aRectangle	^ self copyOrigin: origin clipRect: aRectangle!copyForShadowDrawingOffset: aPoint	^ (self copyOrigin: origin + aPoint clipRect: clipRect) setShadowDrawing!copyOffset: aPoint	^ self copyOrigin: origin + aPoint clipRect: clipRect!copyOrigin: aPoint clipRect: aRectangle	"Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."	^ self copy		setOrigin: aPoint		clipRect: (clipRect intersect: aRectangle)! !!Canvas methodsFor: 'accessing'!clipRect	^ clipRect translateBy: origin negated!origin	^ origin! !!Canvas methodsFor: 'testing'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	^ ((aRectangle right + origin x) < clipRect left or:	  [(aRectangle left + origin x) > clipRect right or:	  [(aRectangle bottom + origin y) < clipRect top or:	  [(aRectangle top + origin y) > clipRect bottom]]]) not! !!Canvas methodsFor: 'drawing'!fillColor: c	"Noop here; overridden by non-trivial canvases."!fillOval: r color: c	"Noop here; overridden by non-trivial canvases."!fillPolygon: pointList color: c	"Noop here; overridden by non-trivial canvases."!fillRectangle: r color: c	"Noop here; overridden by non-trivial canvases."!fillWedge: r startDegrees: startDegrees spanning: spanDegrees color: c	"Noop here; overridden by non-trivial canvases."!frameOval: r color: c	self frameOval: r width: 1 color: c.!frameOval: r width: w color: c	"Noop here; overridden by non-trivial canvases."!framePolygon: pointList color: c	self framePolygon: pointList width: 1 color: c.!framePolygon: pointList width: w color: c	"Noop here; overridden by non-trivial canvases."!frameRectangle: r color: c	self frameRectangle: r width: 1 color: c.!frameRectangle: r width: w color: c	"Noop here; overridden by non-trivial canvases."!frameWedge: r startDegrees: startDegrees spanning: spanDegrees color: c	self frameWedge: r startDegrees: startDegrees spanning: spanDegrees width: 1 color: c.!frameWedge: r startDegrees: startDegrees spanning: spanDegrees width: w color: c	"Noop here; overridden by non-trivial canvases."!image: i at: aPoint	"Noop here; overridden by non-trivial canvases."!line: pt1 to: pt2 color: c	self line: pt1 to: pt2 width: 1 color: c.!line: pt1 to: pt2 width: w color: c	"Noop here; overridden by non-trivial canvases."!point: p color: c	"Noop here; overridden by non-trivial canvases."!text: s at: aPoint font: aFontSpecification color: c	"Noop here; overridden by non-trivial canvases."! !!Canvas methodsFor: 'form copy/paste'!copyFormAt: aPoint extent: aRectangle	"Answer a Form containing a rectangular portion of this canvas. This operation may not be supported on all kinds of canvases. (For example, it does not work on a null canvas and may not work on a write-only Postscript canvas.)"	self error: 'This canvas does not support image capture'.!pasteForm: aForm at: p	"Copy the given pixmap onto this canvas at the given point."	self unimplemented.!pasteForm: aForm at: aPoint src: srcPt width: w height: h	"Extract and copy a rectanglar portion of the given Form onto this canvas."	self unimplemented.! !!Canvas methodsFor: 'private'!setOrigin: aPoint clipRect: aRectangle	origin _ aPoint.	clipRect _ aRectangle.!setShadowDrawing	"Put this canvas into 'shadow drawing' mode, which is used to draw translucent shadows. While in this mode, all drawing operations are done in black through a gray mask. The mask allows some of the underlying pixels to show through, providing a crude sense of transparency."	shadowDrawing _ true.! !!CascadeNode methodsFor: 'C translation'!asTranslatorNode	^TStmtListNode new		setArguments: #()		statements: (messages collect:			[ :msg | msg asTranslatorNode receiver: receiver asTranslatorNode ])! !CCodeGenerator comment:'This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: ''InterpTest.c'' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.'!!CCodeGenerator methodsFor: 'public'!addClass: aClass	"Add the variables and methods of the given class to the code base."	| source |	self checkClassForNameConflicts: aClass.	aClass classPool associationsDo: [ :assoc |		constants at: assoc key put: (TConstantNode new setValue: assoc value).	].	variables addAll: aClass instVarNames.'Adding Class ' , aClass name , '...'displayProgressAt: Sensor cursorPointfrom: 0 to: aClass selectors sizeduring: [:bar |	aClass selectors doWithIndex: [ :sel :i | bar value: i.		source _ aClass sourceCodeAt: sel.		self addMethod: ((Compiler new parse: source in: aClass notifying: nil) asTMethodFromClass: aClass).	]].!codeString	"Return a string containing all the C code for the code base. Used for testing."	| stream |	stream _ ReadWriteStream on: (String new: 1000).	self emitCCodeOn: stream doInlining: true.	^stream contents!codeStringForPrimitives: classAndSelectorList	"CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:)	)"	| sel aClass source s verbose meth |	self initialize.	classAndSelectorList do: [ :classAndSelector |		aClass _ Smalltalk at: (classAndSelector at: 1).		sel _ classAndSelector at: 2.		source _ aClass sourceCodeAt: sel.		meth _ ((Compiler new parse: source in: aClass notifying: nil)				asTMethodFromClass: aClass).		meth preparePrimitiveInClass: aClass.		self addMethod: meth.	].	s _ ReadWriteStream on: (String new: 1000).	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderForPrimitivesOn: s.	self emitCVariablesOn: s.	self emitCFunctionPrototypesOn: s.	methods do: [ :m | m emitCCodeOn: s generator: self ].	^ s contents!globalsAsSet	"Used by the inliner to avoid name clashes with global variables."	((variablesSetCache == nil) or:	 [variablesSetCache size ~= variables size]) ifTrue: [		variablesSetCache _ variables asSet.	].	^ variablesSetCache!initialize	translationDict _ Dictionary new.	inlineList _ Array new.	constants _ Dictionary new.	variables _ OrderedCollection new.	variableDeclarations _ Dictionary new.	methods _ Dictionary new.	self initializeCTranslationDictionary.!storeCodeOnFile: fileName doInlining: inlineFlag	"Store C code for this code base on the given file."	| stream |	stream _ FileStream fileNamed: fileName.	self emitCCodeOn: stream doInlining: inlineFlag.	stream close.!var: varName declareC: declarationString	"Record the given C declaration for a global variable."	variableDeclarations at: varName put: declarationString.! !!CCodeGenerator methodsFor: 'error notification'!checkClassForNameConflicts: aClass	"Verify that the given class does not have constant, variable, or method names that conflict with those of previously added classes. Raise an error if a conflict is found, otherwise just return."	"check for constant name collisions"	aClass classPool associationsDo: [ :assoc |		(constants includesKey: assoc key) ifTrue: [			self error: 'Constant was defined in a previously added class: ', assoc key.		].	].	"check for instance variable name collisions"	aClass instVarNames do: [ :varName |		(variables includes: varName) ifTrue: [			self error: 'Instance variable was defined in a previously added class: ', varName.		].	].	"check for method name collisions"	aClass selectors do: [ :sel |		(methods includesKey: sel) ifTrue: [			self error: 'Method was defined in a previously added class: ', sel.		].	].!printUnboundCallWarnings	"Print a warning message for every unbound method call in the code base."	| knownSelectors undefinedCalls |	undefinedCalls _ Dictionary new.	knownSelectors _ translationDict keys asSet.	knownSelectors add: #error:.	methods do: [ :m | knownSelectors add: m selector ].	methods do: [ :m |		m allCalls do: [ :sel |			(knownSelectors includes: sel) ifFalse: [				(undefinedCalls includesKey: sel)					ifTrue: [ (undefinedCalls at: sel) add: m selector ]					ifFalse: [ undefinedCalls at: sel put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedCalls keys asSortedCollection do: [ :undefined |		Transcript show: undefined, ' -- undefined method sent by:'; cr.		(undefinedCalls at: undefined) do: [ :caller |			Transcript tab; show: caller; cr.		].	].!printUnboundVariableReferenceWarnings	"Print a warning message for every unbound variable reference in the code base."	| undefinedRefs globalVars knownVars |	undefinedRefs _ Dictionary new.	globalVars _ Set new: 100.	globalVars addAll: variables.	methods do: [ :m |		knownVars _ globalVars copy.		m args do: [ :var | knownVars add: var ].		m locals do: [ :var | knownVars add: var ].		m freeVariableReferences do: [ :varName |			(knownVars includes: varName) ifFalse: [				(undefinedRefs includesKey: varName)					ifTrue: [ (undefinedRefs at: varName) add: m selector ]					ifFalse: [ undefinedRefs at: varName put: (OrderedCollection with: m selector) ].			].		].	].	Transcript cr.	undefinedRefs keys asSortedCollection do: [ :var |		Transcript show: var, ' -- undefined variable used in:'; cr.		(undefinedRefs at: var) do: [ :sel |			Transcript tab; show: sel; cr.		].	].! !!CCodeGenerator methodsFor: 'inlining'!collectInlineList	"Make a list of methods that should be inlined."	"Details: The method must not include any inline C, since the translator cannot currently map variable names in inlined C code. Methods to be inlined must be small or called from only one place."	| methodsNotToInline callsOf inlineIt hasCCode nodeCount senderCount |	methodsNotToInline _ Set new: methods size.	"build dictionary to record the number of calls to each method"	callsOf _ Dictionary new: methods size * 2.	methods keys do: [ :sel | callsOf at: sel put: 0 ].	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	inlineList _ Set new: methods size * 2.	methods do: [ :m |		inlineIt _ #dontCare.		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					sel _ node selector.					sel = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: sel ifAbsent: [ nil ].					nil = senderCount ifFalse: [						callsOf at: sel put: senderCount + 1.					].				].				nodeCount _ nodeCount + 1.			].			inlineIt _ m extractInlineDirective.  "may be true, false, or #dontCare"		].		(hasCCode or: [inlineIt = false]) ifTrue: [			"don't inline if method has C code and is contains negative inline directive"			methodsNotToInline add: m selector.		] ifFalse: [			((nodeCount < 40) or: [inlineIt = true]) ifTrue: [				"inline if method has no C code and is either small or contains inline directive"				inlineList add: m selector.			].		].	].	callsOf associationsDo: [ :assoc |		((assoc value = 1) and: [(methodsNotToInline includes: assoc key) not]) ifTrue: [			inlineList add: assoc key.		].	].!doInlining	"Inline the bodies of all methods that are suitable for inlining."	"Interpreter translate: 'InterpTest.c' doInlining: true"	| pass progress |	self collectInlineList.	"xxx do we need the following?"	Interpreter primitiveTable do: [ :sel |		inlineList remove: sel ifAbsent: [].	].	pass _ 0.	progress _ true.	[progress] whileTrue: [		"repeatedly attempt to inline methods until no further progress is made"		progress _ false.		('Inlining pass ', (pass _ pass + 1) printString, '...')			displayProgressAt: Sensor cursorPoint			from: 0 to: methods size			during: [ :bar |				methods doWithIndex: [ :m :i |					bar value: i.					(m tryToInlineMethodsIn: self)						ifTrue: [progress _ true]]].	].	'Inlining bytecodes'		displayProgressAt: Sensor cursorPoint		from: 1 to: 2		during: [ :bar |			self inlineDispatchesInMethodNamed: #interpret				localizingVars: #(currentBytecode localIP localSP).			bar value: 1.			self removeMethodsReferingToGlobals: #(currentBytecode localIP localSP)				except: #interpret.			bar value: 2.	].!inlineDispatchesInMethodNamed: selector localizingVars: varsList	"Inline dispatches (case statements) in the method with the given name."	| m |	m _ self methodNamed: selector.	m = nil ifFalse: [		m inlineCaseStatementBranchesIn: self localizingVars: varsList.		m parseTree nodesDo: [ :n |			n isCaseStmt ifTrue: [				n customizeShortCasesForDispatchVar: #currentBytecode.			].		].	].	variables _ variables asOrderedCollection.	varsList do: [ :v |		variables remove: v asString ifAbsent: [].		(variableDeclarations includesKey: v asString) ifTrue: [			m declarations at: v asString put: (variableDeclarations at: v asString).			variableDeclarations removeKey: v asString.		].	].!mayInline: sel	"Answer true if the method with the given selector may be inlined."	^ inlineList includes: sel!methodStatsString	"Return a string describing the size, # of locals, and # of senders of each method. Note methods that have inline C code or C declarations."	| methodsWithCCode sizesOf callsOf hasCCode nodeCount senderCount s calls registers selr |	methodsWithCCode _ Set new: methods size.	sizesOf _ Dictionary new: methods size * 2.  "selector -> nodeCount"	callsOf _ Dictionary new: methods size * 2.  "selector -> senderCount"	"For each method, scan its parse tree once to:		1. determine if the method contains C code or declarations		2. determine how many nodes it has		3. increment the sender counts of the methods it calls		4. determine if it includes any C declarations or code"	methods do: [ :m |		(translationDict includesKey: m selector) ifTrue: [			hasCCode _ true.		] ifFalse: [			hasCCode _ m declarations size > 0.			nodeCount _ 0.			m parseTree nodesDo: [ :node |				node isSend ifTrue: [					selr _ node selector.					selr = #cCode: ifTrue: [ hasCCode _ true ].					senderCount _ callsOf at: selr ifAbsent: [ 0 ].					callsOf at: selr put: senderCount + 1.				].				nodeCount _ nodeCount + 1.			].		].		hasCCode ifTrue: [ methodsWithCCode add: m selector ].		sizesOf at: m selector put: nodeCount.	].	s _ WriteStream on: (String new: 5000).	methods keys asSortedCollection do: [ :sel |		m _ methods at: sel.		registers _ m locals size + m args size.		calls _ callsOf at: sel ifAbsent: [0].		registers > 11 ifTrue: [			s nextPutAll: sel; tab.			s nextPutAll: (sizesOf at: sel) printString; tab.			s nextPutAll: calls printString; tab.			s nextPutAll: registers printString; tab.			(methodsWithCCode includes: sel) ifTrue: [ s nextPutAll: 'CCode' ].		s cr.		].	].	^ s contents!removeMethodsReferingToGlobals: varList except: methodName	"Remove any methods (presumably inlined) that still contain references to the given obsolete global variables."	| varListAsStrings removeIt mVars |	varListAsStrings _ varList collect: [ :sym | sym asString ].	methods keys copy do: [ :sel |		removeIt _ false.		mVars _ (self methodNamed: sel) freeVariableReferences asSet.		varListAsStrings do: [ :v |			(mVars includes: v) ifTrue: [ removeIt _ true ].		].		(removeIt and: [sel ~= methodName]) ifTrue: [			methods removeKey: sel ifAbsent: [].		].	].! !!CCodeGenerator methodsFor: 'utilities'!addMethod: aTMethod	"Add the given method to the code base."	(methods includesKey:  aTMethod selector) ifTrue: [		self error: 'Method name conflict: ', aTMethod selector.	].	methods at: aTMethod selector put: aTMethod.!builtin: sel	"Answer true if the given selector is one of the builtin selectors."	((sel = #longAt:) or: [(sel = #longAt:put:) or: [sel = #error:]]) ifTrue: [ ^true ].	((sel = #byteAt:) or: [sel = #byteAt:put:]) ifTrue: [ ^true ].	^translationDict includesKey: sel!cCodeForMethod: selector	"Answer a string containing the C code for the given method."	"Example:		((CCodeGenerator new initialize addClass: TestCClass1; prepareMethods)			cCodeForMethod: #ifTests)"	| m s |	m _ self methodNamed: selector.	m = nil ifTrue: [ self error: 'method not found in code base: ', selector ].	s _ (ReadWriteStream on: '').	m emitCCodeOn: s generator: self.	^ s contents!emitBuiltinConstructFor: msgNode on: aStream level: level	"If the given selector is in the translation dictionary, translate it into a target code construct and return true. Otherwise, do nothing and return false."	| action |	action _ translationDict at: msgNode selector ifAbsent: [ ^false ].	self perform: action with: msgNode with: aStream with: level.	^true!methodNamed: selector	"Answer the method in the code base with the given selector."	^ methods at: selector ifAbsent: [ nil ]!methodsReferringToGlobal: v	"Return a collection of methods that refer to the given global variable."	| out |	out _ OrderedCollection new.	methods associationsDo: [ :assoc |		(assoc value freeVariableReferences includes: v) ifTrue: [			out add: assoc key.		].	].	^ out!methodsThatCanInvoke: aSelectorList	"Return a set of methods that can invoke one of the given selectors, either directly or via a sequence of intermediate methods."	| out todo sel mSelector |	out _ Set new.	todo _ aSelectorList copy asOrderedCollection.	[todo isEmpty] whileFalse: [		sel _ todo removeFirst.		out add: sel.		methods do: [ :m |			(m allCalls includes: sel) ifTrue: [				mSelector _ m selector.				((out includes: mSelector) or:				 [todo includes: mSelector]) ifFalse: [					todo add: mSelector.				].			].		].	].	^ out	!prepareMethods	"Prepare methods for browsing."	| globals |	globals _ Set new: 200.	globals addAll: variables.	methods do: [ :m |		(m locals, m args) do: [ :var |			(globals includes: var) ifTrue: [				self error: 'Local variable name may mask global when inlining: ', var.			].			(methods includesKey: var) ifTrue: [				self error: 'Local variable name may mask method when inlining: ', var.			].			].		m bindClassVariablesIn: constants.		m prepareMethodIn: self.	].!reportRecursiveMethods	"Report in transcript all methods that can call themselves directly or indirectly or via a chain of N intermediate methods."	| visited calls newCalls sel called |	methods do: [: m |		visited _ translationDict keys asSet.		calls _ m allCalls asOrderedCollection.		5 timesRepeat: [			newCalls _ Set new: 50.			[calls isEmpty] whileFalse: [				sel _ calls removeFirst.				sel = m selector ifTrue: [					Transcript show: m selector, ' is recursive'; cr.				] ifFalse: [					(visited includes: sel) ifFalse: [						called _ self methodNamed: sel.						called = nil ifFalse: [ newCalls addAll: called allCalls ].					].					visited add: sel.				].			].			calls _ newCalls asOrderedCollection.		].	].!unreachableMethods	"Return a collection of methods that are never invoked."	| sent out |	sent _ Set new.	methods do: [ :m |		sent addAll: m allCalls.	].	out _ OrderedCollection new.	methods keys do: [ :sel |		(sent includes: sel) ifFalse: [ out add: sel ].	].	^ out! !!CCodeGenerator methodsFor: 'C code generator'!cFunctionNameFor: aSelector	"Create a C function name from the given selector by omitting colons."	^aSelector copyWithout: $:!cLiteralFor: anObject	"Return a string representing the C literal value for the given object."	| s |	(anObject isKindOf: Integer) ifTrue: [^ anObject printString ].	(anObject isKindOf: String) ifTrue: [^ '"', anObject, '"' ].	(anObject isKindOf: Float) ifTrue: [^ anObject printString ].	anObject == nil ifTrue: [^ 'null' ].	Transcript show:		'Warning: A Smalltalk literal could not be translated into a C constant'; cr.	^'"XXX UNTRANSLATABLE CONSTANT XXX"'!emitCCodeOn: aStream doInlining: inlineFlag	"Emit C code for all methods in the code base onto the given stream. All inlined method calls should already have been expanded."	| verbose |	"method preparation"	verbose _ false.	self prepareMethods.	verbose ifTrue: [		self printUnboundCallWarnings.		self printUnboundVariableReferenceWarnings.		Transcript cr.	].	inlineFlag ifTrue: [ self doInlining ].	"code generation"	methods _ methods asSortedCollection: [ :m1 :m2 | m1 selector < m2 selector ].	self emitCHeaderOn: aStream.	self emitCVariablesOn: aStream.	self emitCFunctionPrototypesOn: aStream.'Writing Translated Code...'displayProgressAt: Sensor cursorPointfrom: 0 to: methods sizeduring: [:bar |	methods doWithIndex: [ :m :i | bar value: i.		m emitCCodeOn: aStream generator: self.]].!emitCExpression: aParseNode on: aStream	"Emit C code for the expression described by the given parse node."	aParseNode isLeaf ifTrue: [		"omit parens"		aParseNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aStream nextPut: $(.		aParseNode emitCCodeOn: aStream level: 0 generator: self.		aStream nextPut: $).	].!emitCFunctionPrototypesOn: aStream	"Store prototype declarations for all non-inlined methods on the given stream."	aStream nextPutAll: '/*** Function Prototypes ***/'; cr.	methods do: [ :m |		m emitCFunctionPrototype: aStream generator: self.		aStream nextPutAll: ';'; cr.	].!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Variables ***/extern int stackPointer;extern int successFlag;'.	aStream cr.!emitCHeaderOn: aStream	"Write a C file header onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* memory access macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)int printCallStack(void);void error(char *s);void error(char *s) {	/* Print an error message and exit. */	static int printingStack = false;	printf("\n%s\n\n", s);	if (!!printingStack) {		/* flag prevents recursive error when trying to print a broken stack */		printingStack = true;		printCallStack();	}	exit(-1);}'.	aStream cr.!emitCTestBlock: aBlockNode on: aStream	"Emit C code for the given block node to be used as a loop test."	aBlockNode statements size > 1 ifTrue: [		aBlockNode emitCCodeOn: aStream level: 0 generator: self.	] ifFalse: [		aBlockNode statements first emitCCodeOn: aStream level: 0 generator: self.	].!emitCVariablesOn: aStream	"Store the global variable declarations on the given stream."	aStream nextPutAll: '/*** Variables ***/'; cr.	variables asSortedCollection do: [ :var |		(variableDeclarations includesKey: var) ifTrue: [			aStream nextPutAll: (variableDeclarations at: var), ';'; cr.		] ifFalse: [			"default variable declaration"			aStream nextPutAll: 'int ', var, ';'; cr.		].	].	aStream cr.! !!CCodeGenerator methodsFor: 'C translation'!generateAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && '.	self emitCExpression: msgNode args first on: aStream.!generateAt: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ']'.!generateAtPut: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '['.	msgNode args first emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: '] = '.	self emitCExpression: msgNode args last on: aStream.!generateBitAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' & '.	self emitCExpression: msgNode args first on: aStream.!generateBitInvert32: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '~'.	self emitCExpression: msgNode receiver on: aStream.!generateBitOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' | '.	self emitCExpression: msgNode args first on: aStream.!generateBitShift: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| arg rcvr |	arg _ msgNode args first.	rcvr _ msgNode receiver.	arg isConstant ifTrue: [		"bit shift amount is a constant"		aStream nextPutAll: '((unsigned) '.		self emitCExpression: rcvr on: aStream.		arg value < 0 ifTrue: [			aStream nextPutAll: ' >> ', arg value negated printString.		] ifFalse: [			aStream nextPutAll: ' << ', arg value printString.		].		aStream nextPutAll: ')'.	] ifFalse: [		"bit shift amount is an expression"		aStream nextPutAll: '(('.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ' < 0) ? ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> -'.		self emitCExpression: arg on: aStream.		aStream nextPutAll: ') : ((unsigned) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' << '.		self emitCExpression: arg on: aStream.		aStream nextPutAll: '))'.	].!generateBitXor: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' ^ '.	self emitCExpression: msgNode args first on: aStream.!generateCCoercion: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	aStream nextPutAll: msgNode args last value.	aStream nextPutAll: ') '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' / '.	self emitCExpression: msgNode args first on: aStream.!generateEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	self emitCExpression: msgNode args first on: aStream.!generateGreaterThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' > '.	self emitCExpression: msgNode args first on: aStream.!generateGreaterThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' >= '.	self emitCExpression: msgNode args first on: aStream.!generateIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for ifFalse:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	aStream nextPutAll: 'if (!!('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ')) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfFalseIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler reverses the argument blocks for ifFalse:ifTrue:,       presumably to help with inlining later. That is, the first argument       is the block to be evaluated if the condition is true."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateIfTrueIfFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'if ('.	msgNode receiver emitCCodeOn: aStream level: level generator: self.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '} else {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateInlineCCode: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: msgNode args first value.!generateInlineDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* inline: '.	aStream nextPutAll: msgNode args first name.	aStream nextPutAll: ' */'.!generateIntegerObjectOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' << 1) | 1)'.!generateIntegerValueOf: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' >> 1)'.!generateIsIntegerObject: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '('.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' & 1)'.!generateIsNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' == '.	aStream nextPutAll: (self cLiteralFor: nil).!generateLessThan: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.!generateLessThanOrEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' <= '.	self emitCExpression: msgNode args first on: aStream.!generateMax: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.!generateMin: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '(('.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' < '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ') ? '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' : '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: ')'.!generateMinus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' - '.	self emitCExpression: msgNode args first on: aStream.!generateModulo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' % '.	self emitCExpression: msgNode args first on: aStream.!generateNot: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '!!'.	self emitCExpression: msgNode receiver on: aStream.!generateNotEqual: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	self emitCExpression: msgNode args first on: aStream.!generateNotNil: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' !!= '.	aStream nextPutAll: (self cLiteralFor: nil).!generateOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || '.	self emitCExpression: msgNode args first on: aStream.!generatePlus: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' + '.	self emitCExpression: msgNode args first on: aStream.!generatePreDecrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preDecrement can only be applied to variables' ].	aStream nextPutAll: '--'.	aStream nextPutAll: varNode name.!generatePreIncrement: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| varNode |	varNode _ msgNode receiver.	varNode isVariable		ifFalse: [ self error: 'preIncrement can only be applied to variables' ].	aStream nextPutAll: '++'.	aStream nextPutAll: varNode name.!generateSequentialAnd: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' && ('.	self emitCTestBlock: msgNode args first on: aStream.	aStream nextPutAll: ')'.!generateSequentialOr: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	"Note: PP 2.3 compiler produces two arguments for or:, presumably	 to help with inlining later. Taking the last agument should do the correct	 thing even if your compiler is different."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' || ('.	self emitCTestBlock: msgNode args last on: aStream.	aStream nextPutAll: ')'.!generateSharedCodeDirective: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '/* common code: '.	aStream nextPutAll: msgNode args first value.	aStream nextPutAll: ' */'.!generateShiftLeft: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' << '.	self emitCExpression: msgNode args first on: aStream.!generateShiftRight: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: '((unsigned) '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ')'.	aStream nextPutAll: ' >> '.	self emitCExpression: msgNode args first on: aStream.!generateTimes: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: ' * '.	self emitCExpression: msgNode args first on: aStream.!generateToByDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, ' += '.	self emitCExpression: (msgNode args at: 2) on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateToDo: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| iterationVar |	(msgNode args last args size = 1) ifFalse: [		self error: 'wrong number of block arguments'.	].	iterationVar _ msgNode args last args first.	aStream nextPutAll: 'for (', iterationVar, ' = '.	self emitCExpression: msgNode receiver on: aStream.	aStream nextPutAll: '; ', iterationVar, ' <= '.	self emitCExpression: msgNode args first on: aStream.	aStream nextPutAll: '; ', iterationVar, '++) {'; cr.	msgNode args last emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateWhileFalse: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while (!!('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ')) {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!generateWhileTrue: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	aStream nextPutAll: 'while ('.	self emitCTestBlock: msgNode receiver on: aStream.	aStream nextPutAll: ') {'; cr.	msgNode args first emitCCodeOn: aStream level: level + 1 generator: self.	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	).	1 to: pairs size by: 2 do: [ :i |		translationDict at: (pairs at: i) put: (pairs at: i + 1).	].! !!CCodeGenerator class methodsFor: 'removing from system'!removeCompilerMethods	"Before removing the C code generator classes from the system, use this method to remove the compiler node methods that support it. This avoids leaving dangling references to C code generator classes in the compiler node classes."	ParseNode withAllSubclasses do: [ :nodeClass |		nodeClass removeCategory: 'C translation'.	].	AbstractSound class removeCategory: 'primitive generation'.! !!ChangedMessageSet methodsFor: 'everything'!changeSet: aChangeSet	changeSet _ aChangeSet!contents: aString notifying: aController	| selectedMessageName selector oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ 		self selectedClassOrMetaClass				compile: aString				classified:  self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[(oldMessageList includes: selector)				ifFalse: [self initializeMessageList: changeSet changedMessageListAugmented.						self changed: #messageListChanged].			self messageListIndex: (self messageList indexOf: selector)].	^ true! !!ChangedMessageSet class methodsFor: 'as yet unclassified'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  3/9/97 sw"	| messageSet |	messageSet _ self messageList: aChangeSet changedMessageListAugmented.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: nil.	ScheduledControllers scheduleActive: 					(self open: messageSet name:  'Methods in Change Set ', aChangeSet name)! !!ChangeList methodsFor: 'scanning'!scanVersionsOf: method class: class meta: meta		category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy |	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		((file == sourceFilesCopy first) not and:		[(preamble at: (preamble findLast: [:c | c isAlphaNumeric]))			isDigit  "Only tokenize if preamble ends with a digit"])			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[prevPos _ tokens at: tokens size-2.				prevPos = 0					ifTrue: [prevPos _ nil] "Zero means no source"					ifFalse: [prevFileIndex _ tokens last.							prevFileIndex = 0 ifTrue: [prevPos _ nil]]].		self addItem:				(ChangeRecord new file: file position: position					type: #method class: class name category: category meta: meta)			text: class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ChangeList class methodsFor: 'public access'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners reversed selections: positions reversed)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !ChangeSet comment:'My instances keep track of the changes made to a system, so the user can make an incremental fileOut. The order in which changes are made is not remembered.11/25/96 sw: added preamble and postscript -- two strings that can serve as prefix and suffix to the fileout of the changeset.'!!ChangeSet methodsFor: 'initialize-release'!clear 	"Reset the receiver to be empty.  11/26/96 sw"	classChanges _ Dictionary new.	methodChanges _ Dictionary new.	classRemoves _ Set new.	preamble _ nil.	postscript _ nil!editPostscript	"edit the receiver's postscript, in a separate window.  11/27/96 sw"	self assurePostscriptExists.	StringHolderView open: postscript label: 'Postscript for ChangeSet named ', name! !!ChangeSet methodsFor: 'fileIn/Out'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  11/27/96 sw"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '']!assurePreambleExists	"Make sure there is a StringHolder holding the preamble.  11/27/96 sw	 12/4/96 sw: if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents size == 0])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time.  1/18/96 sw 2/4/96 sw: show write cursor	5/30/96 sw: put a dot before the date/time stamp"	| file |	Cursor write showWhile:		[file _ FileStream newFileNamed: ((self name, '.', Utilities dateTimeSuffix, '.cs') truncateTo: 27).		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close]!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  11/25/96 sw"	| aString |	((aString _ self postscriptString) size > 0)		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  11/25/96 sw"	| aString |	((aString _ self preambleString) size > 0)		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]!postscriptString	"Answer the string representing the postscript.  11/27/96 sw"	self assurePostscriptExists.	^ postscript contents!postscriptString: aString	"Establish aString as the new contents of the postscript.  11/27/96 sw"	postscript _ StringHolder new contents: aString!preambleString	"Answer the string representing the preamble.  11/27/96 sw"	^ preamble == nil		ifTrue:			[preamble]		ifFalse:			[preamble contents]!preambleString: aString	"Establish aString as the new contents of the preamble.  11/27/96 sw"	preamble _ StringHolder new contents: aString!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.  Just a first stab at what the content should be.12/3/96 sw"	| aStream |	aStream _ ReadWriteStream on: ''.	aStream nextPutAll: '"Change Set:'.	aStream tab;tab; nextPutAll: self name.	aStream cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.	aStream cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: 'Your Name'.	aStream cr; cr; nextPutAll: '<your descriptive text goes here>"'.	^ aStream contents"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'private'!fileOutClassChanges: class on: stream 	"Write out class changes, i.e. new class, definition, comment, renaming.	 10/28/96 sw: put out a rename indicator that won't halt if class of old name not there."	(self atClass: class includes: #add) ifTrue:		[stream cr.		class fileOutOn: stream.		stream cr].	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #change) ifTrue:		[stream emphasis: 5; nextChunkPut: class definition; cr; emphasis: 1].	(self atClass: class includes: #comment) ifTrue:		[class organization putCommentOnFile: stream			numbered: nil moveSource: false.		stream cr].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]!fileOutClassModifications: class on: stream 	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes.  5/15/96 sw	 10/28/96 sw: put out a rename indicator that won't halt if class of old name not there."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #comment) ifTrue:		[class organization putCommentOnFile: stream			numbered: nil moveSource: false.		stream cr].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'accessing'!editPreamble	"edit the receiver's preamble, in a separate window.  11/27/96 sw"	self assurePreambleExists.	StringHolderView open: preamble label: 'Preamble for ChangeSet named ', name! !!ChangeSorter methodsFor: 'creation'!initialize	"Initialize the receiver to look at the current change set.  11/26/96 sw"	self initializeFor: Smalltalk changes!initializeFor: aChangeSet	"Initialize the receiver and have it start out life looking at aChangeSet.  11/26/96 sw"	myChangeSet _ aChangeSet.		classList _ CngsClassList new.	classList parent: self.	messageList _ CngsMsgList new.	messageList parent: self.	MsgListMenu == nil ifTrue: [self class initialize].	classList list: #().	messageList list: #().!open  "ChangeSorter new open"	| topView |	self initialize.	topView _ StandardSystemView new.	topView model: self.	topView label: self label.	topView minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open		"Let the show begin"!openView: topView	"Create change sorter on one changeSet only.  Two of these in a DualChangeSorter."	| classView messageView codeView |	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: (0 @ 0 extent: 360 @ 20).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView."	classView 		align: classView viewport topLeft 			with: buttonView viewport bottomLeft.	messageView 		align: messageView viewport topLeft 			with: classView viewport topRight.	codeView 		align: codeView viewport topLeft 			with: classView viewport bottomLeft."!openView: topView offsetBy: offset	"Create change sorter on one changeSet with 0@0.	Two of these in a DualChangeSorter, right one is offset by 360@0."	| classView messageView codeView |	buttonView _ SwitchView new.	buttonView model: self controller: TriggerController new.	buttonView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	buttonView selector: #whatPolarity.	buttonView controller selector: #cngSetActivity.	buttonView window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	buttonView label: myChangeSet name asParagraph.	classView _ GeneralListView new.	classView controllerClass: GeneralListController.	classView model: classList.	classView window: (0 @ 0 extent: 180 @ 160).	classView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	classView controller yellowButtonMenu: ClassMenu 		yellowButtonMessages: ClassSelectors.	classList controller: classView controller.	messageView _ GeneralListView new.	messageView controllerClass: GeneralListController.	messageView model: messageList.	messageView window: (0 @ 0 extent: 180 @ 160).	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	messageView controller yellowButtonMenu: MsgListMenu 		yellowButtonMessages: MsgListSelectors.	messageList controller: messageView controller.	codeView _ BrowserCodeView new.	codeView model: self.	codeView window: (0 @ 0 extent: 360 @ 180).	codeView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.	topView addSubView: buttonView.	topView addSubView: classView below: buttonView.	topView addSubView: messageView toRightOf: classView.	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'change set menu'!browseChangeSet	"Open a message list browser on the new and changed methods in the current change set.  2/2/96 sw	 3/8/97 sw: launch a ChangedMessageSet"	ChangedMessageSet openFor: myChangeSet!clearChangeSet	"Clear out the current change set, after getting a confirmation.  11/26/96 sw"	| message |	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to forget all the changes in this set?'.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self launch!editPostscript	"Allow the user to edit the receiver's change-set's postscript -- in a separate window at present.  11/27/96 sw"	myChangeSet editPostscript!editPreamble	"Allow the user to edit the receiver's change-set's preamble -- in a separate window at present.  11/27/96 sw"	myChangeSet editPreamble! !!ChangeSorter class methodsFor: 'as yet unclassified'!initialize	"Initialize the class.  1991-tck	Modified 1/12/96 sw: added a bunch of new items, not all of them implemented yet.  2/2/96 sw: added browse change set.  Also made it such that if AllChangeSets already exists, this won't clobber the existing order.  2/5/96 sw: changed wording of some items	5/8/96 sw: added subtractOtherSide	5/29/96 sw: added SingleCngSetMenu, for single change sorter	5/30/96 sw: added fileIntoNewChangeSet	7/23/96 di: removed SingleCngSetMenu, since not used	11/25/96 sw: added cmds to manipulate preamble and postscript	11/26/96 sw: added clear"	AllChangeSets == nil ifTrue:		[AllChangeSets _ OrderedCollection new].	self gatherChangeSets.	CngSetMenu _ PopUpMenu labels: 'make changes go to menew...file into new...show...fileOutbrowserenamecopy all to other sidesubtract other sideedit preamble...edit postscript...clearremove'    lines: #(1 3 7 9 11).	CngSetSelectors  _ 		#(newCurrent newSet fileIntoNewChangeSet chooseCngSet fileOut browseChangeSet rename copyToOther subtractOtherSide editPreamble editPostscript clearChangeSet remove).	ClassMenu _ PopUpMenu labels: 'browse classbrowse fullinst var refsclass varscopy to other sideforget' 			lines: #().	ClassSelectors _ 		#(browse browseFull instVarRefs classVariables copyToOther forget).	MsgListMenu _ PopUpMenu labels: 'fileOutsendersimplementorssenders of...implementors of...implementors of sent msgsversionscopy to other sideforget' 			lines: #(1 6 7).	MsgListSelectors _ 		#(fileOut senders implementors browseSendersOfMessages messages		allImplementorsOf versions copyToOther forget).	false ifTrue: [		"Just so senders will find it here!!!!!!  Never executed."		(CngsMsgList new) fileOut; senders; implementors; messages;  			versions; copyToOther; forget.		(MessageListController new) browseSendersOfMessages; 			allImplementorsOf].	"	ChangeSorter initialize.	GeneralListController allInstancesDo:		[:each  | each model parent class == ChangeSorter ifTrue: [			each yellowButtonMenu: ClassMenu 				yellowButtonMessages: ClassSelectors.			each yellowButtonMenu: MsgListMenu 				yellowButtonMessages: MsgListSelectors]].	"!secondaryChangeSet	"Answer a likely change set to use as the second initial one in a Dual Change Sorter.  11/26/96 sw"	| last |	self gatherChangeSets.	AllChangeSets size == 1 ifTrue: [^ AllChangeSets first].	^ (last _ AllChangeSets last) == Smalltalk changes		ifTrue: 	[AllChangeSets at: (AllChangeSets size - 1)]		ifFalse:	[last]! !!Character methodsFor: 'converting'!asLowercase	"If the receiver is uppercase, answer its matching lowercase Character."		(8r101 <= value and: [value <= 8r132])  "self isUppercase"		ifTrue: [^ Character value: value + 8r40]		ifFalse: [^ self]! !!Character class methodsFor: 'accessing untypeable characters'!linefeed	"Answer the Character representing a linefeed."	^self value: 10! !!CharacterBlockScanner methodsFor: 'scanning'!characterNotInFont 	"This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!CharacterBlockScanner methodsFor: 'stop conditions'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ 					Point						x: ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin])						y: destY.				lastIndex _ lastIndex + 1.				lastCharacterExtent x: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		lastCharacterExtent x: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'private'!buildCharacterBlockIn: aText	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(aText numberOfLines = 0 or: [text size = 0])		ifTrue:	[^CharacterBlock					stringIndex: 1	"like being off end of string"					character: nil					topLeft: ((aText leftMarginForDisplayForLine: 1) @								(aText compositionRectangle) top)					extent: (0 @ textStyle lineGrid)].	"find the line"	lineIndex _ aText lineIndexOfTop: characterPoint y.	destY _ (aText topAtLineIndex: lineIndex).	line _ aText lines at: lineIndex.	rightMargin _ aText rightMarginForDisplay.	(lineIndex = aText numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					characterPoint x: rightMargin]			ifFalse:	[characterPoint y < (aText compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _								(aText compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[characterPoint x: rightMargin]].	destX _ leftMargin _ aText leftMarginForDisplayForLine: lineIndex.	nextLeftMargin_ aText leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions displaying: false.	"see setStopConditions for stopping conditions for character block 	operations."	lastCharacterExtent x: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[^CharacterBlock					stringIndex: lastIndex					character: lastCharacter					topLeft: characterPoint					extent: lastCharacterExtent]]! !!CharacterScanner methodsFor: 'scanning'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display 	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable. If dextX would exceed rightX, then 	return stops at: 258. If displaying is true, then display the character. 	Advance destX by the width of the character. If stopIndex has been 	reached, then return stops at: 257. Fail under the same conditions that 	the Smalltalk code below would cause an error. Optional. See Object 	documentation whatIsAPrimitive."	| ascii nextDestX maxAscii |	<primitive: 103>	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			"ascii > maxAscii ifTrue: [ascii _ maxAscii]."			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue: [self copyBits].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX!setFont: fontNumber	"Set the basal font from the textStyle."	font _ textStyle fontAt: fontNumber!textColor: ignored	"Overridden in DisplayScanner"! !!Class methodsFor: 'initialize-release'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (Smalltalk at: poolName asSymbol)].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	oldPools do: [:pool | found _ false.				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'copying'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary.  6/12/96 sw"	^ methodDict copy! !!Class methodsFor: 'class name'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	newName _ aString asSymbol.	(Smalltalk includesKey: newName)		ifTrue: [^self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [^ SelectionMenu notify: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	Smalltalk renameClass: self as: newName.	name _ newName.	self comment: self comment.	self class comment: self class comment! !!Class methodsFor: 'pool variables'!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	9/12/96 tk: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [sharedPools remove: aDictionary.				sharedPools isEmpty ifTrue: [sharedPools _ nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet _ self subclasses asOrderedCollection.	satisfiedSet _ Set new.	[workingSet isEmpty] whileFalse:		[aSubclass _ workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	sharedPools remove: aDictionary.	sharedPools isEmpty ifTrue: [sharedPools _ nil]! !!Class methodsFor: 'compiling'!scopeHas: varName ifTrue: assocBlock 	"Look up the first argument, varName, in the context of the receiver. If it is there,	pass the association to the second argument, assocBlock, and answer true.	Else answer false.	9/11/96 tk: Allow key in shared pools to be a string for HyperSqueak"	| assoc |	assoc _ self classPool associationAt: varName ifAbsent: [].	assoc == nil		ifFalse: 			[assocBlock value: assoc.			^true].	self sharedPools do: 		[:pool | 		varName = #Textual ifTrue: [self halt].		assoc _ pool associationAt: varName ifAbsent: [			pool associationAt: varName asString ifAbsent: []].		assoc == nil			ifFalse: 				[assocBlock value: assoc.				^true]].	superclass == nil		ifTrue: 			[assoc _ Smalltalk associationAt: varName ifAbsent: [].			assoc == nil				ifFalse: 					[assocBlock value: assoc.					^true].			^false].	^superclass scopeHas: varName ifTrue: assocBlock! !!ClassDescription methodsFor: 'initialize-release'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass removeSubclass: self.			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	| oldInstVarNames map variable new instSize oldInstances |	oldClass someInstance == nil ifTrue: [^self].	"no instances to convert"	oldInstVarNames _ oldClass allInstVarNames.	map _ 		self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].	variable _ self isVariable.	instSize _ self instSize.	"Now perform a bulk mutation of old instances into new ones"	oldInstances _ oldClass allInstances asArray.	oldInstances elementsExchangeIdentityWith:		(oldInstances collect: 		[:old | 		variable			ifTrue: [new _ self basicNew: old basicSize]			ifFalse: [new _ self basicNew].		1 to: instSize do: 			[:offset |  (map at: offset) > 0 ifTrue:				[new instVarAt: offset						put: (old instVarAt: (map at: offset))]].		variable 			ifTrue: [1 to: old basicSize do: 						[:offset |						new basicAt: offset put: (old basicAt: offset)]].		new])!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods 	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [self updateInstancesFrom: oldClass].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods]! !!ClassDescription methodsFor: 'accessing'!comment	"Answer the receiver's comment."	| aString |	aString _ self theNonMetaClass organization classComment.	aString size = 0 ifTrue: [^''].	"get string only of classComment, undoubling quotes"	^ String readFromString: aString!comment: aString 	"Set the receiver's comment to be the argument, aString."	| aStream |	aString size = 0		ifTrue: 			[self theNonMetaClass organization classComment: aString]		ifFalse: 			["double internal quotes of the comment string"			aStream _ WriteStream on: (String new: aString size).			aStream nextPutAll: self name , ' comment:'; cr.			aString storeOn: aStream.			self theNonMetaClass organization classComment: aStream contents.	Smalltalk changes commentClass: self]!commentTemplate	"Answer an expression to edit and evaluate in order to produce the 	receiver's comment."	| aString |	aString _ self theNonMetaClass organization classComment.	aString size = 0		ifTrue: [ ^ self name , ' comment:''This class has not yet been commented''']		ifFalse: [ ^ aString]! !!ClassDescription methodsFor: 'printing'!classVariablesString	"Answer a string of my class variable names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self classPool keys asSortedCollection do: [:key | aStream nextPutAll: key; space].	^aStream contents!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self sharedPools do: [:x | aStream nextPutAll: (Smalltalk keyAtValue: x ifAbsent: ['private']); space].	^ aStream contents! !!ClassDescription methodsFor: 'organization'!zapOrganization	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"	organization _ nil.	self isMeta ifFalse: [self class zapOrganization]! !!ClassDescription methodsFor: 'compiling'!compile: text classified: category notifying: requestor 	| selector priorMethod method methodNode |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[method putSource: text asString				fromParseNode: methodNode				class: self category: category				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'fileIn/Out'!reformatMethodAt: selector 	| newCodeString method | 	newCodeString _ (self compilerClass new)		format: (self sourceCodeAt: selector)		in: self		notifying: nil.	method _ self compiledMethodAt: selector.	method		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2 priorMethod: method! !!ClassDescription methodsFor: 'private'!spaceUsed	"Answer a rough estimate of number of bytes in this class and its metaclass"	| space method |	space _ 0.	self selectorsDo:		[:sel | space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do:			[:lit | ((lit isMemberOf: Symbol) or: [lit isMemberOf: SmallInteger]) ifFalse:				[(lit isMemberOf: String) ifTrue: [space _ space + (lit size+6)].				(lit isMemberOf: Array) ifTrue: [space _ space + (lit size+1*4)]]]].	(self isMemberOf: Metaclass)		ifTrue: [^ space]		ifFalse: [^ space + self class space]! !ClassListBrowser comment:'A browser on an arbitrary list of classes.  It holds on to a classListGenerator, a block which will generate a clean class list when required.  12/6/96 sw'!!ClassListBrowser methodsFor: 'everything'!classListGenerator: generatorBlock	"Initialize the receiver such that it obtains its class list from generatorBlock.  12/6/96 sw"	classListGenerator _ generatorBlock.	classList _ generatorBlock value!updateSystemCategories	"The class categories were changed in another browser. The receiver must 	reorganize its lists based on these changes."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	classList _ classListGenerator value.	self changed: #classListChanged.	self changed: #systemCategoriesChanged! !!ClassListController methodsFor: 'menu messages'!spawnHierarchy        "Request that the receiver's view display the class hierarchy (super- and         subclasses) of the selected class so that it can be edited."        self controlTerminate.        model spawnHierarchy.        self controlInitialize!spawnProtocol        "Request that the receiver's model open a protocol browser."        self controlTerminate.        model spawnProtocol.        self controlInitialize! !!ClassListController class methodsFor: 'class initialization'!initialize        "Initialize the yellow button menu information.         2/1/96 sw: added class vars         7/29/96 sw: added 'find method' feature        11/11/96 stp: added spawn protocol and separated show/spawn hierarchy        11/12/96 stp: added recent classes feature	   11/25/96 sw: recent classes feature moved to system category-list pane"                ClassListYellowButtonMenu :=                PopUpMenu                                 labels: 'browse classprintOutfileOuthierarchydefinitioncommentspawn hierarchyspawn protocolinst var refs..inst var defs..class var refs...class varsclass refsrename...removefind method...'                                 lines: #(3 6 8 10 13 16).        ClassListYellowButtonMessages :=                 #(browse  printOut fileOut                hierarchy definition comment                spawnHierarchy spawnProtocol                browseInstVarRefs browseInstVarDefs browseClassVarRefs classVariables browseClassRefs                rename remove findMethod)        "        ClassListController initialize.        ClassListController allInstancesDo:                [:x | x initializeYellowButtonMenu].        "! !!ClassOrganizer methodsFor: 'accessing'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| scanner oldElements newElements newCategories newStops currentStop anArray |	scanner _ Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(scanner size = 0 and: [elementArray size = 0])		ifTrue: [^self setDefaultList: Array new].	oldElements _ elementArray asSet.	newCategories _ Array new: scanner size.	newStops _ Array new: scanner size.	currentStop _ 0.	newElements _ WriteStream on: (Array new: 16).	1 to: scanner size do: 		[:i | 		anArray _ scanner at: i.		newCategories at: i put: anArray first asSymbol.		anArray allButFirst asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop _ currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements _ oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements _ newElements contents.	categoryArray _ newCategories.	categoryStops _ newStops.	elementArray _ newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!ClassOrganizer methodsFor: 'compiler access'!classify: element under: heading 	"Store the argument, element, in the category named heading."	| catName catIndex elemIndex realHeading |	heading = NullCategory		ifTrue: [realHeading _ Default]		ifFalse: [realHeading _ heading asSymbol].	(catName _ self categoryOfElement: element) = realHeading		ifTrue: [^self].  "done if already under that category"	catName ~~ nil ifTrue: 		[realHeading = Default			ifTrue: [^self].	"return if exists and realHeading is default"		self removeElement: element].	"remove if in another category"	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].	"add realHeading if not there already"	catIndex _ categoryArray indexOf: realHeading.	elemIndex _ 		catIndex > 1			ifTrue: [categoryStops at: catIndex - 1]			ifFalse: [0].	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 		and: [element >= (elementArray at: elemIndex)]] whileTrue.	"elemIndex is now the index for inserting the element. Do the insertion before it."	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1						with: (Array with: element).	"add one to stops for this and later categories"	catIndex to: categoryArray size do: 		[:i | categoryStops at: i put: (categoryStops at: i) + 1].	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !!ClassOrganizer methodsFor: 'method dictionary'!addCategory: catString before: nextCategory	"Add a new category named heading.	If default category exists and is empty, remove it.	If nextCategory is nil, then add the new one at the end,	otherwise, insert it before nextCategory."	| index newCategory |	newCategory _ catString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^self].	"heading already exists, so done"	index _ categoryArray indexOf: nextCategory		ifAbsent: [categoryArray size + 1].	categoryArray _ categoryArray		copyReplaceFrom: index		to: index-1		with: (Array with: newCategory).	categoryStops _ categoryStops		copyReplaceFrom: index		to: index-1		with: (Array with: (index = 1				ifTrue: [0]				ifFalse: [categoryStops at: index-1])).	"remove empty default category"	(newCategory ~= Default			and: [(self listAtCategoryNamed: Default) isEmpty])		ifTrue: [self removeCategory: Default]!removeCategory: cat 	"Remove the category named, cat. Create an error notificiation if the 	category has any elements in it."	| index lastStop |	index _ categoryArray indexOf: cat ifAbsent: [^self].	lastStop _ 		index = 1			ifTrue: [0]			ifFalse: [categoryStops at: index - 1].	(categoryStops at: index) - lastStop > 0 		ifTrue: [^self error: 'cannot remove non-empty category'].	categoryArray _ categoryArray copyReplaceFrom: index to: index with: Array new.	categoryStops _ categoryStops copyReplaceFrom: index to: index with: Array new.	categoryArray size = 0		ifTrue:			[categoryArray _ Array with: Default.			categoryStops _ Array with: 0]! !!ClockMorph methodsFor: 'all'!step	self contents: Time now printString.!stepTime	"Answer the desired time between steps in milliseconds."	^ 1000! !!Color methodsFor: 'examples'!hsvExample	"Shows a palette of hues, varying the saturation and brightness for each one."	"Color new hsvExample.  Modified 6/14/96 tk"	| d c rect |	d _ Display depth.	c _ Color new.		"modified in loop below"	rect _ 0@0 extent: 5@5.	"modified in loop below"	0 to: 179 by: 15 do: [:h |		0 to: 10 do: [:s |			0 to: 10 do: [:v |				c setHue: h saturation: s asFloat / 10.0 brightness: v asFloat / 10.0.				rect left: (h*4) + (s*5); width: 5.				rect top: (v*5); height: 5.				Display fill: rect fillColor: (c bitPatternForDepth: d).				c setHue: h + 180 saturation: s asFloat / 10.0 brightness: v asFloat / 10.0.				rect top: (v*5) + 80; height: 5.				Display fill: rect fillColor: (c bitPatternForDepth: d).			].		].	].!test: depth	"Color new test: 8"	| c |	1 to: (1 << depth) do: [ :i |		c _ IndexedColors at: i.		(Color colorFromPixelValue: (c pixelValueForDepth: depth) value depth: depth) = c			ifFalse: [ self error: 'bad conversion' ].	].! !!Color methodsFor: 'access'!luminance	^299* self privateRed + (587 * self privateGreen) + (114 * self privateBlue) / (1000*ComponentMax)! !!Color methodsFor: 'equality'!= aColor	^ aColor isRealColor and: [aColor rgb = rgb]!hash	^ rgb!isRealColor	^ true! !!Color methodsFor: 'conversions'!bitPatternForDepth: depth	"The raw call on BitBlt needs a Bitmap to represent this color.  Return the color at the destination Form depth as a Bitmap.  Patterns return longer Bitmaps.  6/14/96 tk	For the bits that are in a single pixel, use pixelValueAtDepth:.	For a 32-bit integer of (32/depth) pixels, use pixelWordAtDepth:"	| brightness |	depth == cachedDepth ifTrue: [^ cachedBitPattern].	cachedDepth _ depth.	depth > 1 ifTrue: [^ cachedBitPattern _ Bitmap with: (self pixelWordForDepth: depth)].	"Spatial halftones for depth 1"	brightness _ self luminance.	brightness < 0.2 ifTrue: [		^ cachedBitPattern _ Bitmap with: 16rFFFFFFFF]. "black"	brightness < 0.4 ifTrue: [		^ cachedBitPattern _ Bitmap with: 16rBBBBBBBB with: 16rEEEEEEEE]. "dark gray"	brightness < 0.6 ifTrue: [		^ cachedBitPattern _ Bitmap with: 16r55555555 with: 16rAAAAAAAA]. "medium gray"	brightness < 0.8 ifTrue: [		^ cachedBitPattern _ Bitmap with: 16r44444444 with: 16r11111111]. "light gray"	^ cachedBitPattern _ Bitmap with: 16r0.	"white"!fixTransparent: theDepth	"Make 0 be white or black, depending on the depth.  Leave 0 for transparent.  3/15/97 tk"	"Know we are not the TransparentColor"	(self pixelValueForDepth: theDepth) = 0 ifTrue: [			theDepth = 8 ifTrue: [^ Bitmap with: 16rFFFFFFFF].	"255 white in color cube"			theDepth = 16 ifTrue: [^ Color r: 0 g: 0 b: 1.0/32].	"almost black"			theDepth = 32 ifTrue: [^ Color r: 0 g: 0 b: 1.0/256].	"almost black"			"Shallow depths do not change, for now"].!pixelValueForDepth: d	"Answer bits that appear in ONE pixel of this color in a Bitmap of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32.  Returns an integer.  Contrast with pixelWordForDepth: and bitPatternForDepth:.  Inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index (zero order). For depths of 16 and 32, it is a direct color with 5 or 8 bits per color component.  6/1/96 jm, 6/14/96 tk"	d < 8 ifTrue: [ ^ self closestPixelValueDepth: d ].	d = 8 ifTrue: [ ^ self closestPixelValue8 ].	d = 16 ifTrue: [		"five bits per component; top bits ignored"		^ (((rgb bitShift: Depth16RedShift) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: Depth16GreenShift) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: Depth16BlueShift) bitAnd: 16r001F).	].	d = 32 ifTrue: [		"eight bits per component; top 8 bits ignored"		^ (((rgb bitShift: Depth32RedShift) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: Depth32GreenShift) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: Depth32BlueShift) bitAnd: 16r0000FF).	].	d = 9 ifTrue: ["For use indexing the default color map"		"three bits per component; top bits ignored"		^ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).	].	d = 12 ifTrue: ["For use indexing the default color map"		"four bits per component; top bits ignored"		^ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).	].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'printing'!printOn: aStream	self storeOn: aStream.!storeOn: aStream	aStream		nextPutAll: '(' , self class name;		nextPutAll: ' r: ';		nextPutAll: (self red roundTo: 0.001) printString;		nextPutAll: ' g: ';		nextPutAll: (self green roundTo: 0.001) printString;		nextPutAll: ' b: ';		nextPutAll: (self blue roundTo: 0.001) printString;		nextPutAll: ')'.! !!Color methodsFor: 'private'!closestPixelValue8	"Return the index in the standard 8-bit colormap for the nearest match to this color.  Find the closest color in our 6x6x6 color cube.  See if any of the grays are closer to the real color.  6/14/96 tk"	| r g b rr gg bb diff gray val diffg diffc pvtGray rd gd bd |	rgb = 0 ifTrue: [^ 1].	"Special case for black, very common"	rgb = 16r3FFFFFFF ifTrue: [^ 0 "255"].		"Special case for white, very common"	"Find the closest color in our 6x6x6 color cube. Integers in [0..5]" 	r _ (((self privateRed    * 5) + HalfComponentMask) // ComponentMask).	g _ (((self privateGreen * 5) + HalfComponentMask) // ComponentMask).	b _ (((self privateBlue    * 5) + HalfComponentMask) // ComponentMask).	rr _ self privateRed.  gg _ self privateGreen.  bb _ self privateBlue.	diff _ ((rr-gg)*(rr-gg)) + ((gg-bb)*(gg-bb)) + ((bb-rr)*(bb-rr)).	"least squares"	"If diff is big, r g and b not very close, not very much like a gray.  One 6x6x6 step is 1023.0 / 5.0 = 204.6.  Squared is 204.6 * 204.6 =  41861.2	 Return a color from our cube that starts at index 40." 	diff >= 41861 ifTrue: [^ (r * 36) + (b * 6) + g + 40].	"Consider using a gray"	pvtGray _ rr+gg+bb //3.		"[0..1023]"	gray _ (((pvtGray* 32) + HalfComponentMask) // ComponentMask).		"33 discrete gray levels [0..32]"	val _ pvtGray.	"Do error comparison in 1023 space"	diffg _ ((val - rr)*(val - rr)) + ((val - gg)*(val - gg)) + 			((val - bb)*(val - bb)).	"error in the Gray"	"Color in the cube [0..5], blown back up to [0..1023] with error"	rd _ (r * ComponentMask) // 5.		gd _ (g * ComponentMask) // 5.	bd _ (b * ComponentMask) // 5.	diffc _ ((rd - rr)*(rd - rr)) + ((gd - gg)*(gd - gg)) + ((bd - bb)*(bd - bb)).			"error in the color from the cube"	"self halt."	diffg < diffc		ifTrue: ["33 grays.  eighths starting at index 9, 32nds from 16 to 39"			^ #(1 16 17 18 9 19 20 21 10 22 23 24 11 25 26 27 12 				 28 29 30 13 31 32 33 14 34 35 36 15 37 38 39 0) at: gray+1]		ifFalse: [^ (r * 36) + (b * 6) + g + 40]!closestPixelValueDepth: depth	"Return the nearest approximation to this color for this depth of Form.  Depth can be 1, 2, 4, or 8.  This method is for when we go to L*a*b* color space.  For now use the faster version. 6/14/96 tk"	|  least r g b col rdiff gdiff bdiff diff leastIndex |	depth > 8 ifTrue: [^ self error: 'depth must be 1, 2, 4, or 8'].	least _ ComponentMask*ComponentMask*3 + 100.		"start with max"	r _ self privateRed.  g _ self privateGreen.  b _ self privateBlue.	0 to: (1 bitShift: depth) - 1 do: [:ind |		col _ IndexedColors at: ind+1.		rdiff _ r - col privateRed.		gdiff _ g - col privateGreen.		bdiff _ b - col privateBlue.		diff _ (rdiff*rdiff) + (gdiff*gdiff) + (bdiff*bdiff).		diff < least ifTrue: [			least _ diff.			leastIndex _ ind]].	^ leastIndex!setHue: hue saturation: saturation brightness: brightness	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."	| s v hf i f p q t | 	s _ (saturation asFloat max: 0.0) min: 1.0.	v _ (brightness asFloat max: 0.0) min: 1.0.	"zero saturation yields gray with the given brightness"	s = 0.0 ifTrue: [ ^ self setRed: v green: v blue: v ].	hf _ hue asFloat.	(hf < 0.0 or: [hf >= 360.0])		ifTrue: [hf _ hf - ((hf quo: 360.0) asFloat * 360.0)].	hf _ hf / 60.0.	i _ hf asInteger.  "integer part of hue"	f _ hf fractionPart.         "fractional part of hue"	p _ (1.0 - s) * v.	q _ (1.0 - (s * f)) * v.	t _ (1.0 - (s * (1.0 - f))) * v.	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].	self error: 'implementation error'.! !!Color class methodsFor: 'colors'!brown	^Brown!colorMapIfNeededFrom: sourceDepth to: destDepth	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap).  User must copy the colorMap before changing it.  For better quality, use fourBitColorMapFrom:to:.  To force a map where there would be per color component truncation or zero filling, use defaultBitColorMapFrom:to:.	Cache the maps.  Erase the cache at shutDown.  12/9/96 tk, 3/21/97 tk"	| bitsPerColor colorMap mask |sourceDepth = destDepth ifTrue: [^ nil].	"No map needed"sourceDepth < 16 ifTrue: [		ColorMapCache == nil 			ifTrue: [ColorMapCache _ Dictionary new: 16]			ifFalse: [colorMap _ ColorMapCache at: (sourceDepth*37 + destDepth) ifAbsent: [nil].				colorMap == nil ifFalse: [^ colorMap]].		colorMap _ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap.		ColorMapCache at: (sourceDepth*37 + destDepth) put: colorMap.		^ colorMap		].sourceDepth < destDepth ifTrue: ["16 -> 32" ^ nil].	"Done in BitBlt by zero filling per color"(sourceDepth = 32) & (destDepth = 16) ifTrue: ["32 -> 16" ^ nil].		"Done in BitBlt by truncation per color"	"For RGB, generate the better (4 bits per color) version"	bitsPerColor _ 4.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	mask _ (1 bitShift: bitsPerColor) - 1.	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destDepth)].	"do not cache it, those are 3-bits per color"	^ colorMap!defaultColorMapFrom: sourceDepth to: destDepth	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap).  User must copy the colorMap before changing it.  For better quality, use fourBitColorMapFrom:to:.  Always returns a map, even where per color truncation or zero filling would be correct.	Cache the maps.  Erase the cache at shutDown.  12/9/96 tk, 3/21/97 tk"	| bitsPerColor colorMap mask |ColorMapCache == nil 	ifTrue: [ColorMapCache _ Dictionary new: 16]	ifFalse: [colorMap _ ColorMapCache at: (sourceDepth*37 + destDepth) ifAbsent: [nil].		colorMap == nil ifFalse: [^ colorMap]].sourceDepth < 16 	ifTrue: [		colorMap _ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap]	ifFalse: [		"For RGB, generate the simplest (3 bits per color) version"		bitsPerColor _ 3.		colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).		mask _ (1 bitShift: bitsPerColor) - 1.		0 to: colorMap size - 1 do:			[:i | colorMap at: i+1 put:				((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)					green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)					blue: ((i bitShift: 0) bitAnd: mask)					range: mask)				pixelValueForDepth: destDepth)]].ColorMapCache at: (sourceDepth*37 + destDepth) put: colorMap.^ colorMap!fourBitColorMapFrom: sourceDepth to: destDepth	"Return a colorMap for the depth, suitable for use with BitBlt (ie a BitMap).  Always reutrn a map, not nil.  Use four bits per color component.  No caching for now.  User must copy the colorMap before changing it.  3/16/97 di,tk"	| bitsPerColor colorMap mask |sourceDepth < 16 ifTrue: [		ColorMapCache == nil 			ifTrue: [ColorMapCache _ Dictionary new: 16]			ifFalse: [colorMap _ ColorMapCache at: (sourceDepth*37 + destDepth) ifAbsent: [nil].				colorMap == nil ifFalse: [^ colorMap]].		colorMap _ ((IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))			collect: [:c | c pixelValueForDepth: destDepth]) as: Bitmap.		ColorMapCache at: (sourceDepth*37 + destDepth) put: colorMap.		^ colorMap].	"For RGB, generate the better (4 bits per color) version"	bitsPerColor _ 4.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	mask _ (1 bitShift: bitsPerColor) - 1.	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destDepth)].	"do not cache it, those are 3-bits per color"	^ colorMap!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color names) gives a list of the colors.  6/13/96 tk"	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str _ newName asString.	sym _ str asSymbol.	cap _ str capitalized.	csym _ cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor _ str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	(ColorNames includes: sym) ifFalse: [		ColorNames add: sym].	^ self classPool at: csym put: aColor!names	"Return a list of names of colors.  An OrderedCollection of symbols.  6/14/96 tk""	Color names doWithIndex:		[:name :i | Display fill: (0@(i*22) extent: 100@22) fillColor: (Color perform: name).		name displayAt: 10@(i*22+4)]"	^ ColorNames!noColor	^ Transparent!none	^ Transparent!nullColor	^ Transparent!orange	^Orange!transparent	^Transparent! !!Color class methodsFor: 'instance creation'!colorChartForDepth: depth extent: chartExtent	"Displays a color palette using abstract colors.  fromUser can then save it.  Different for each depth.  6/26/96 tk	Modified to produce a form of variable size instead of being	fixed-size and running on the display 8/20/96 di"	"(Color colorChartForDepth: Display depth extent: 720@100) display"	| c p f nSteps rect w h q |	f _ Form extent: chartExtent depth: depth.	nSteps _ depth>8 ifTrue: [12] ifFalse: [6].	w _ chartExtent x // (nSteps*nSteps).	h _ chartExtent y - 20 // nSteps.	0 to: nSteps-1 do: [:r |		0 to: nSteps-1 do: [:g |			0 to: nSteps-1 do: [:b |				c _ self red: r green: g blue: b range: nSteps-1.				rect _ ((r*nSteps*w) + (b*w)) @ (g*h) extent: w@(h+1).				f fill: rect fillColor: c].			].		].	q _ Quadrangle origin: chartExtent - (75@20) corner: chartExtent.	q displayOn: f.	'Transparent' displayOn: f at: q origin + (3@2).	p _ chartExtent x // 3 @ (chartExtent y - 20).	w _ chartExtent x - p x - 20 - q width / 100.	0 to: 99 do:		[ :v | c _ self red: v green: v blue: v range: 99.		f fill: ((v*w)@0 + p extent: (w+1)@20) fillColor: c].	^ f!fromUser	"Displays a color palette using abstract colors, then waits for a mouse click. Try it at various display depths!!"	"Color fromUser"	| save d c old new s p startPt tr here |	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ self colorChartForDepth: d extent: 720@100].	Sensor cursorPoint y < Display center y 		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt _ 0@0].	save _ Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr _ ColorChart extent - (75@20) corner: ColorChart extent.	tr moveBy: startPt.	old _ 0.	[Sensor anyButtonPressed] whileFalse: [		p _ Display pixelValueAt: (here _ Sensor cursorPoint).		(tr containsPoint: here)			ifFalse: [c _ self colorFromPixelValue: p depth: d.					Display fill: (0@80+startPt extent: 60@20) fillColor: c]			ifTrue: [c _ Color transparent.					Display fill: (0@80+startPt extent: 60@20) fillColor: Color white].		(new _ p) = old ifFalse: [			Display fillWhite: (60@80+startPt extent: 180@20).			(tr containsPoint: here) 				ifFalse: [					s _ c printString.					s _ 'R,G,B = ', (s copyFrom: 7 to: s size - 1)]				ifTrue: [					c _ Color transparent.					s _ c printString].			s displayAt: 63@83+startPt.			old _ new.		].	].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!Color class methodsFor: 'class initialization'!initializeNames	"Set values of the named colors. 6/13/96 tk	Color initializeNames"	ColorNames _ OrderedCollection new.	#(white black gray yellow red green blue cyan		magenta - veryDarkGray darkGray - - lightGray 		veryLightGray )		doWithIndex:		[:colorPut :i | colorPut == #- ifFalse:			[self named: colorPut put: (IndexedColors at: i)]].	self named: #transparent put: (NullColor r: 0 g: 0 b: 0).	#(brown orange lightBlue lightBrown lightCyan lightGreen lightMagenta lightOrange lightRed lightYellow)			with:  "Color fromUser first bitAnd: 255"		#(149 229 219 206 147 207 254 236 248 249)			do: [:colorPut :i | 				self named: colorPut put: (IndexedColors at: i+1)].!shutDown	ColorChart _ nil.	"Samples of colors for user to pick from"	ColorMapCache _ nil.	"Maps between color depths"! !!CommandTilesMorph methodsFor: 'all'!allTiles	| tiles |	tiles _ OrderedCollection new.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue: [tiles add: m]].	^ tiles!initialize	super initialize.	centering _ #center.	borderWidth _ 0.	inset _ 0.	self extent: 5@5.  "will grow to fit"! !!CompiledMethod methodsFor: 'initialize-release'!copyWithTrailerBytes: bytes"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start |	start _ self initialPC.	end _ self endPC.	copy _ CompiledMethod newMethod: end - start + 1 + bytes size				header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	start to: end do: [:i | copy at: i put: (self at: i)].	1 to: bytes size do: [:i | copy at: end + i put: (bytes at: i)].	^ copy! !!CompiledMethod methodsFor: 'accessing'!endPC	"Answer the index of the last bytecode."	| flagByte |	flagByte _ self last.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		1 to: 4 do: [:i | (self at: self size - i) = 0 ifFalse: [^ self size - i]]].	flagByte < 252 ifTrue:		["Magic sources (tempnames encoded in last few bytes)"		^ self size - self last - 1].	"Normal 4-byte source pointer"	^ self size - 4! !!CompiledMethod methodsFor: 'printing'!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' newMethod: '.	aStream store: self size - self initialPC + 1.	aStream nextPutAll: ' header: '.	aStream store: self header.	aStream nextPut: $).	noneYet _ self storeElementsFrom: self initialPC to: self endPC on: aStream.	1 to: self numLiterals do:		[:index |		noneYet			ifTrue: [noneYet _ false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' literalAt: '.		aStream store: index.		aStream nextPutAll: ' put: '.		aStream store: (self literalAt: index)].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!CompiledMethod methodsFor: 'scanning'!readsField: varIndex 	"Answer whether the receiver loads the instance variable indexed by the 	argument."	self isReturnField ifTrue: [^self returnField + 1 = varIndex].	varIndex <= 16 ifTrue: [^ self scanFor: varIndex - 1].	varIndex <= 64 ifTrue: [^ self scanLongLoad: varIndex - 1].	^ self scanVeryLongLoad: 64 offset: varIndex - 1!readsRef: literalAssociation 	"Answer whether the receiver loads the argument."	| lit |	lit _ self literals indexOf: literalAssociation ifAbsent: [^false].	lit <= 32 ifTrue: [^self scanFor: 64 + lit - 1].	lit <= 64 ifTrue: [^self scanLongLoad: 192 + lit - 1].	^ self scanVeryLongLoad: 128 offset: lit - 1!scanFor: byte 	"Answer whether the receiver contains the argument as a bytecode."	^ (InstructionStream on: self) scanFor: [:instr | instr = byte]"Smalltalk browseAllSelect: [:m | m scanFor: 134]"!scanLongStore: extension 	"Answer whether the receiver contains a long store whose extension is 	the argument."	| scanner |	scanner _ InstructionStream on: self.	^scanner scanFor: 		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]!scanVeryLongLoad: extension offset: offset	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])											and: [scanner thirdByte = offset]]!scanVeryLongStore: extension offset: offset	"Answer whether the receiver contains a long load with the given offset.	Note that the constant +32 is the known difference between a	store and a storePop for instVars, and it will always fail on literal variables,	but these only use store (followed by pop) anyway."	| scanner ext |	scanner _ InstructionStream on: self.	^ scanner scanFor:		[:instr | (instr = 132 and: [(ext _ scanner followingByte) = extension											or: [(ext +32) = extension]])							and: [scanner thirdByte = offset]]!sendsToSuper	"Answer whether the receiver sends any message to super."	| scanner |	scanner _ InstructionStream on: self.	^ scanner scanFor: 		[:instr |  instr = 16r85 or: [instr = 16r84						and: [scanner followingByte between: 16r20 and: 16r3F]]]!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^false].	field <= 8 ifTrue: [^ (self scanFor: 96 + field - 1)						or: [self scanLongStore: field - 1]].	field <= 64 ifTrue: [^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1!writesRef: ref 	"Answer whether the receiver stores the argument."	| lit |	lit _ self literals indexOf: ref ifAbsent: [^false].	lit <= 64 ifTrue: [^ self scanLongStore: 192 + lit - 1].	^ self scanVeryLongStore: 224 offset: lit - 1! !!CompiledMethod methodsFor: 'source code management'!copySourceTo: aFileStream 	| position |	(self fileIndex = 0 or: [(SourceFiles at: self fileIndex) == nil]) ifTrue: [^ false].	Cursor read		showWhile: 			[position _ self filePosition.			position ~= 0 ifTrue: [(SourceFiles at: self fileIndex) position: position;				 copyChunkTo: aFileStream]].	^ position ~= 0!copyWithTempNames: tempNames	| tempStr |	tempStr _ String streamContents:		[:strm | tempNames do: [:n | strm nextPutAll: n; space]].	^ self copyWithTrailerBytes: (self qCompress: tempStr)!fileIndex	"Answer the index of the sources file on which this method is stored, as follows:		1:	.sources file		2:	.changes file		3 and 4 are also available for future extension of source code management"	self last < 252 ifTrue: [^ 0  "no source"].	^ self last - 251	!filePosition	"Answer the file position of this method's source code."	| pos |	self last < 252 ifTrue: [^ 0  "no source"].	pos _ 0.	self size - 1 to: self size - 3 by: -1 do: [:i | pos _ pos * 256 + (self at: i)].	^ pos!getSourceFor: selector in: class	"Reconstruct the source code for the receiver."	| source tempNames flagByte |	flagByte _ self last.	flagByte = 0 ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	(Sensor controlKeyPressed or: [(SourceFiles at: self fileIndex) == nil]) ifTrue:		["Emergency or no source file -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: self getSourceFromFile in: class notifying: nil)						tempNames.		^ ((class decompilerClass new withTempNames: tempNames)				decompile: selector				in: class				method: self) decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	| position |	(position _ self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: position)			string!putSource: sourceStr fromParseNode: methodNode class: class category: catName	inFile: fileIndex priorMethod: priorMethod	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble:			[:file | class printCategoryChunk: catName on: file priorMethod: priorMethod.			file cr]!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '; flush.	self setSourcePosition: remoteString position inFile: fileIndex!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"!qDecompress: byteArray	"Decompress strings compressed by qCompress:.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble"	|  charTable extended ext |	charTable _  "Character encoding table must match qCompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ String streamContents:		[:strm | extended _ false.  "Flag for 2-nibble characters"		byteArray do:			[:byte | 			(Array with: byte//16 with: byte\\16)				do:				[:nibble | extended					ifTrue: [strm nextPut: (charTable at: ext*16+nibble + 1). extended _ false]					ifFalse: [nibble < 12 ifTrue: [strm nextPut: (charTable at: nibble + 1)]									ifFalse: [ext _ nibble-12.  extended _ true]]]]]!setSourcePosition: position inFile: fileIndex 	"Store the location of the source code for the receiver in the receiver. The 	location consists of which source file (*.sources or *.changes) and the 	position in that file."	fileIndex > 4 ifTrue: [^ self error: 'invalid file number'].	self at: self size put: 251 + fileIndex.	1 to: 3 do: 		[:i | self at: self size - i put: ((position bitShift: (i-3)*8) bitAnd: 16rFF)].!setTempNamesIfCached: aBlock	"This is a cache used by the debugger, independent of the storage of	temp names when the system is converted to decompilation with temps."	TempNameCache == nil ifTrue: [^self].	TempNameCache key == self		ifTrue: [aBlock value: TempNameCache value]!tempNames	| byteCount bytes |	byteCount _ self at: self size.	byteCount = 0 ifTrue: [^ Array new].	bytes _ (ByteArray new: byteCount)		replaceFrom: 1 to: byteCount with: self 		startingAt: self size - byteCount.	^ (self qDecompress: bytes) findTokens: ' '! !!CompiledMethod class methodsFor: 'class initialization'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame _ 12.	"Context range for temps+stack"	LargeFrame _ 32.! !!CompiledMethod class methodsFor: 'instance creation'!new	"This will not make a meaningful method, but it could be used	to invoke some otherwise useful method in this class."	^ self newMethod: 0 header: 0!newBytes: numberOfBytes nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit |	largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	^ self newMethod: numberOfBytes + 4 	" +4 to store source code ptr" 		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primitiveIndex! !!Compiler methodsFor: 'public access'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ receiver DoIt.				class removeSelectorSimply: #DoIt.				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ receiver DoItIn: context.				class removeSelectorSimply: #DoItIn:.				^value]!format: textOrStream in: aClass notifying: aRequestor	"Compile a parse tree from the argument, textOrStream. Answer a string 	containing the original code, formatted nicely.	If the leftShift key is pressed, then decorate the resulting text with	color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^nil].	Sensor leftShiftDown		ifTrue: [^ aNode decompileText]		ifFalse: [^ aNode decompileString]! !!CompositionScanner methodsFor: 'scanning'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	spaceX _ destX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ super				scanCharactersFrom: lastIndex				to: runStopIndex				in: text string				rightX: rightMargin				stopConditions: stopConditions				displaying: false.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]!setActualFont: aFont        "Keep track of max height and ascent for auto lineheight"        | descent |        super setActualFont: aFont.        descent _ lineHeight - baseline max: font descent.        baseline _ baseline max: font ascent.        lineHeight _ lineHeight max: baseline + descent!setFont: fontNumber        "Keep track of max height and ascent for auto lineheight"        | descent |        super setFont: fontNumber.        descent _ lineHeight - baseline max: font descent.        baseline _ baseline max: font ascent.        lineHeight _ lineHeight max: baseline + descent! !!CompositionScanner methodsFor: 'stop conditions'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	line stop: spaceIndex.	spaceCount > 1			ifTrue:	["The common case. First back off the space at which we wrap."				spaceCount _ spaceCount - 1.				spaceIndex _ spaceIndex - 1.				["Check to see if any spaces preceding the one at which we wrap.					Double space after a period, most likely."				(spaceCount > 1 and: [(text at: spaceIndex) = Space])]					whileTrue:						[spaceCount _ spaceCount - 1.						"Account for backing over a run which might							change width of space."						font _ textStyle fontAt:								(text fontNumberAt: spaceIndex).						spaceIndex _ spaceIndex - 1.						spaceX _ spaceX - (font widthOf: Space)].						line paddingWidth: rightMargin - spaceX.						line internalSpaces: spaceCount]		ifFalse:	[spaceCount = 1					ifTrue:	["wrap at space, but no internal spaces"							line internalSpaces: 0.							line paddingWidth: rightMargin - spaceX]					ifFalse:	["Neither internal nor trailing spaces, almost never happen,								she says confidently."							lastIndex _ lastIndex - 1.							[destX <= rightMargin]							whileFalse:								[destX _ destX - (font widthOf:													(text at: lastIndex)).										"bug --doesn't account for backing over										 run and changing actual width of										characters. Also doesn't account for										backing over a tab.  Happens only										when no spaces in line, presumably rare."								lastIndex _ lastIndex - 1].							spaceX _ destX.							line paddingWidth: rightMargin - destX.							lastIndex < line first								ifTrue:	[line stop: line first]								ifFalse:	[line stop: lastIndex]]].	^true! !ConciseInspector comment:'An Inspector that omits the self and all inst vars lines'!!ContextPart methodsFor: 'debugger access'!mclass 	"Answer the class in which the receiver's method was found."	self receiver class selectorAtMethod: self method setClass: [:mclass].	^mclass!sourceCode	| selector methodClass |	selector _ self receiver class selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^ methodClass sourceCodeAt: selector!tempNames	"Answer an OrderedCollection of the names of the receiver's temporary 	variables, which are strings."	self method setTempNamesIfCached: [:names | ^names].	names _ (self mclass compilerClass new			parse: self sourceCode			in: self mclass			notifying: nil) tempNames.	self method cacheTempNames: names.	^names! !!ContextPart methodsFor: 'printing'!printOn: aStream 	| selector class |	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:mclass].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'private'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| primitiveMethod value t1 t2 t3 |	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	primitiveMethod _ TryPrimitiveMethods at: arguments size + 1.	"slam num into primitive instead of 100 such messages in Object"	primitiveMethod bePrimitive: primitiveIndex.	"Class flushCache."  "in case interp caches primitive #"	value _ receiver perform: (TryPrimitiveSelectors at: arguments size+1)				withArguments: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextPart class methodsFor: 'examples'!tallyInstructions: aBlock	"This method uses the simulator to count the number of occurrences of	each of the Smalltalk instructions executed during evaluation of aBlock.	Results appear in order of the byteCode set."	| tallies |	tallies _ Bag new.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current | tallies add: current nextByte].	^tallies sortedElements	"ContextPart tallyInstructions: [3.14159 printString]"!tallyMethods: aBlock	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. Results are given in order of decreasing counts."	| prev tallies |	tallies _ Bag new.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: "call or return"				[prev sender == nil ifFalse: "call only"					[tallies add: current printString].				prev _ current]].	^tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"!trace: aBlock		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls and returned values in the Transcript."	| prev |	Transcript clear.	prev _ aBlock.	^ thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[prev sender == nil ifTrue:  "returning"						[Transcript space; nextPut: $^; print: current top].					Transcript cr;						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );						print: current receiver; space; nextPutAll: current selector; endEntry.					prev _ current]]!trace: aBlock onFileNamed: fileName		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev f sel |	f _ FileStream fileNamed: fileName.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[f cr;						nextPutAll: (String new: (current depthBelow: aBlock) withAll: $ );						print: current receiver class; space; nextPutAll: (sel _ current selector); flush.					prev _ current.					sel == #error: ifTrue: [self halt]]].	f close! !!ContextStackListController methodsFor: 'menu messages'!fullStack	"Change from displaying the minimal stack to a full one."	model contextStackList size > 15 "Already expanded"		ifTrue:			[view flash]		ifFalse:			[model contextStackIndex = 0				ifFalse: [model toggleContextStackIndex: model contextStackIndex].			self controlTerminate.			model fullyExpandStack.			self controlInitialize]!proceed	"Proceed execution of the receiver's model, starting after the expression at 	which an interruption occurred."	self controlTerminate.	Smalltalk okayToProceedEvenIfSpaceIsLow ifTrue: [		model proceed: view topView controller.	].	self controlInitialize! !!ContextVariablesInspector methodsFor: 'selecting'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	selectionIndex = 1		ifTrue: [^object]		ifFalse: [^object tempAt: selectionIndex - 2 put: anObject]! !!ControlManager methodsFor: 'accessing'!controllersSatisfying: aBlock	"Return a list of scheduled controllers satisfying aBlock.  9/27/96 sw"	^ scheduledControllers select:		[:aController | (aBlock value: aController) == true]!removeAllControllersSatisfying: aBlock	"Unschedule and delete all controllers satisfying aBlock.  May not leave the screen exactly right sometimes. 10/9/96 sw"	(self controllersSatisfying:  aBlock) do:		[:aController | aController closeAndUnschedule]! !!ControlManager methodsFor: 'displaying'!updateGray	"From Georg Gollmann - 11/96.  tell the Screen Controller's model to use the currently-preferred desktop color."	"ScheduledControllers updateGray"	(screenController view model isMemberOf: InfiniteForm)		ifTrue: [screenController view model: (InfiniteForm with:Preferences desktopColor)]! !!CRFillInTheBlankController methodsFor: 'sensor access'!dispatchOnCharacter: char with: typeAheadStream	"Accept and terminate the interation if the user hits a CR or the enter key."	(char = Character cr) | (char = Character enter)		ifTrue:			[sensor keyboard.  "gobble the character"			self accept.			^ true]		ifFalse:			[^ super dispatchOnCharacter: char with: typeAheadStream].! !CustomMenu comment:'I am used to build menus on-the-fly. I maintain lists of menu items, actions (usually symbols to be sent as messages), and menu section dividing lines to which my clients may append new entries and lines by sending me the messages:	add: aString action: anAction	addLineAfter the menu is constructed, it may be invoked with one of the following messages:	invoke: initialSelection	invokeI am a subclass of ActionMenu, so I inherit a number of instance variables. The ones I am particularly concerned with are:	items _ an OrderedCollection of strings to appear in the menu	selectors _ an OrderedCollection of Symbols to be used as message selectors	lineArray _ an OrderedCollection of line positions	lastLine _ used to keep track of the last line to avoid making duplicate entries in lineArray'!!CustomMenu methodsFor: 'initialize-release'!initialize	labels _ OrderedCollection new.	selections _ OrderedCollection new.	dividers _ OrderedCollection new.	lastDivider _ 0.! !!CustomMenu methodsFor: 'construction'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	s _ String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider _ selections size.		dividers addLast: lastDivider].! !!CustomMenu methodsFor: 'invocation'!invokeOn: targetObject defaultSelection: defaultSelection	"Invoke the menu with the given default selection (i.e. one of my 'action' symbols). Answer the 'action' selector associated with the menu item chosen by the user or nil if none is chosen."	| sel |	sel _ self startUp: defaultSelection.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil!startUp	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: nil!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: nil!startUp: initialSelection withCaption: caption	"Build and invoke this menu with the given initial selection and caption. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	self build.	(initialSelection notNil) ifTrue: [self preSelect: initialSelection].	^ super startUpWithCaption: caption! !!CustomMenu methodsFor: 'private'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [: label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	self labels: stream contents		font: (TextStyle default fontAt: 1)		lines: dividers.!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i _ selections indexOf: action ifAbsent: [^ self].	marker _ marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection _ i.! !!CustomMenu class methodsFor: 'instance creation'!new	^ super new initialize! !!CustomMenu class methodsFor: 'example'!example	"CustomMenu example"	| menu |	menu _ CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples! !!DataStream methodsFor: 'as yet unclassified'!beNotTextual	"Satisfy the Mac file system and Eudora by saying we are not a text file.  4/2/97 tk"	MacFileDirectory setMacFileNamed: byteStream fullName type: 'SOBJ' creator: 'FAST'.!checkForPaths: anObject	"After an object is fully internalized, it should have no PathFromHome in it.	The only exception is Array, as pointed to by an IncomingObjects.  8/16/96 tk"	| pfh |	pfh _ Smalltalk at: #PathFromHome ifAbsent: [^ self].	1 to: anObject class instSize do:		[:i | (anObject instVarAt: i) class == pfh ifTrue: [			self error: 'Unresolved Path']].!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  1/8/97 tk"	| instSize aSymbol refPosn anObject newClass |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	aSymbol _ self next.	newClass _ Smalltalk at: aSymbol asSymbol.	anObject _ newClass isVariable 	"Create object here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].	self setCurrentReference: refPosn.  "before readDataFrom:size:"	anObject _ anObject readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject!typeIDFor: anObject	"Return the typeID for anObject's class."	| tt |	tt _ anObject ioType.	tt == #User ifTrue: [^ 13].	"User Object whose class must be reconstructed"	(anObject isKindOf: View) ifTrue: [^ 1 "nil"].	"blocked"	(anObject isKindOf: Controller) ifTrue: [		Transcript cr; show: 'Refused to store a Controller'. ^ 		1 "nil"].	(anObject isKindOf: CompiledMethod) ifTrue: [		Transcript cr; show: 'Refused to store a CompiledMethod'. 		^ 1 "nil"].	(anObject isKindOf: BlockContext) ifTrue: [		Transcript cr; show: 'Refused to store a BlockContext'. 		^ 1 "nil"].		^ TypeMap at: anObject class ifAbsent: [9 "instance"]!writeClass: aClass	"PRIVATE -- For now, no classes may be written.  HyperSqueak user unique classes have not state other than methods and should be reconstructed.  Could put standard fileOut code here if necessary.  7/29/96 tk."	"Just halt for now -- 9/20/96 di."	self error: 'Should not be trying to write a class'"	Obj classPool at: #ErrorHolder put: aClass.	Transcript cr; show: 'The class ', aClass printString,' is trying to be written out.  See Obj class variable ErrorHolder.'."! !!DataStream class methodsFor: 'imported from V'!fileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr _ ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm _  self on: ((FileStream fileNamed: aString) binary).	strm beNotTextual.	"Type and Creator"	^ strm!newFileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr _ ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm _  self on: ((FileStream newFileNamed: aString) binary).	strm beNotTextual.	"Type and Creator"	^ strm! !!Debugger methodsFor: 'initialize-release'!expandStack	"This initialization occurs when the interrupted context is to modelled by 	a DebuggerView, rather than a NotifierView (which can not display 	more than five message-sends.	10/30/96 sw: expand the default number of frames from 7 to 15"	self newStack: (contextStackTop stackOfSize: 15).	contextStackIndex _ 0.	receiverInspector _ Inspector inspect: nil.	contextVariablesInspector _ ContextVariablesInspector inspect: nil.	proceedValue _ nil! !!Debugger methodsFor: 'accessing'!contents: aString notifying: aController 	"The retrieved information has changed and its source must now be 	updated. In this case, the retrieved information is the method of the 	selected context."	| selector classOfMethod category method priorMethod parseNode |	contextStackIndex = 0 ifTrue: [^self].	(self selectedContext isKindOf: MethodContext)		ifFalse:			[(self confirm:'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifTrue: [self resetContext: self selectedContext home]				ifFalse: [^self]].	classOfMethod _ self selectedClass.	category _ self selectedMessageCategoryName.	Cursor execute showWhile:		[method _ classOfMethod		compile: aString		notifying: aController		trailer: #(0 0 0 0)		ifFail: [^ false]		elseSetSelectorAndNode: 			[:sel :methodNode | selector _ sel.			selector == self selectedMessageName				ifFalse: [self notify: 'can''t change selector'. ^ false].			priorMethod _ (classOfMethod includesSelector: selector)				ifTrue: [classOfMethod compiledMethodAt: selector]				ifFalse: [nil].			sourceMap _ methodNode sourceMap.			tempNames _ methodNode tempNames.			parseNode _ methodNode].		method cacheTempNames: tempNames].	category isNil ifFalse: "Skip this for DoIts"		[method putSource: aString asString				fromParseNode: parseNode				class: classOfMethod				category: category				inFile: 2 priorMethod: priorMethod.		classOfMethod organization classify: selector under: category].	contents _ aString copy.	self selectedContext restartWith: method.	contextVariablesInspector object: nil.	self resetContext: self selectedContext.	^true! !!Debugger methodsFor: 'private'!resumeProcess: aScheduledController	aScheduledController view erase.	Smalltalk installLowSpaceWatcher.  "restart low space handler"	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. 	aScheduledController closeAndUnscheduleNoErase.	Processor terminateActive! !!DebuggerView class methodsFor: 'instance creation'!debugger: aDebugger 	"Answer a DebuggerView whose model is aDebugger. It consists of three 	subviews, a ContextStackView (the ContextStackListView and 	ContextStackCodeView), an InspectView of aDebugger's variables, and an 	InspectView of the variables of the currently selected method context."	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	aDebugger expandStack.	topView _ self new model: aDebugger.	stackListView _ ContextStackListView new model: aDebugger.		stackListView window: (0 @ 0 extent: 150 @ 50).		stackListView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackListView.	stackCodeView _ ContextStackCodeView new model: aDebugger.		stackCodeView controller: ContextStackCodeController new.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		stackCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ InspectListView new model: aDebugger receiverInspector.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		rcvrVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ InspectCodeView new model: aDebugger receiverInspector.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		rcvrValView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ InspectListView new model: aDebugger contextVariablesInspector.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		ctxtVarView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ InspectCodeView new model: aDebugger contextVariablesInspector.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		ctxtValView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: ctxtValView toRightOf: ctxtVarView.	^ topView!lowSpaceChoices	"The message at the end of the Debugger window when there is a low space signal. 12/10/96 tk"	^ ' Squeak is almost out of memory. If you detect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.   If you need this computation to finish, then make more space available (read on) and choose "proceed" in this debugger.   There are several ways to make more space available...	> Close any other windows that are not needed.	> Get rid of some large objects (esp images).	> Leave this window on the screen, choose "save as..." from the screen menu, quit, select the Squeak VM in the Finder and choose "Get Info..." to give it more memory space, and then restart your saved image and choose "proceed" in this window. If you need to investigate further, choose "debug" in this widow.  Do not use "fullStack" unless you are certain that the stack is not very deep. Low space detection is now disabled.  It will be restored when you close or proceed.'!openNotifier: aDebugger contents: msgString label: label	"Create and schedule a simple view with a debugger which can be opened later."	| aStringHolderView topView displayPoint nLines msg |	self flag: #developmentNote.	Cursor normal show.	Sensor flushKeyboard.	msg _ msgString.	(label beginsWith: 'Space is low') ifTrue: [		msg _ msg, self lowSpaceChoices].	aStringHolderView _ StringHolderView container:		(StringHolder new contents: msg).	aStringHolderView controller: (NotifyStringHolderController debugger: aDebugger).	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: label.	nLines _ 1 + (msgString occurrencesOf: Character cr).	topView minimumSize: 350 @ (14*nLines + 6).	displayPoint _ 		ScheduledControllers activeController == nil			ifTrue: [Display boundingBox center]			ifFalse: [ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: displayPoint.	^ topView! !!Decompiler methodsFor: 'initialize-release'!initSymbols: aClass	| nTemps namedTemps |	constructor method: method class: aClass literals: method literals.	constTable _ constructor codeConstants.	instVars _ Array new: aClass instSize.	nTemps _ method numTemps.	namedTemps _ tempVars == nil ifTrue: [Array new] ifFalse: [tempVars].	tempVars _ (1 to: nTemps) collect:				[:i | i <= namedTemps size					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]					ifFalse: [constructor codeTemp: i - 1]]!withTempNames: tempNameArray	tempVars _ tempNameArray! !!Decompiler methodsFor: 'control'!checkForBlock: receiver	"We just saw a blockCopy: message. Check for a following block."	| savePc jump args argPos block |	receiver == constructor codeThisContext ifFalse: [^false].	savePc _ pc.	(jump _ self interpretJump) notNil		ifFalse:			[pc _ savePc.  ^nil].	"Definitely a block"	jump _ jump + pc.	argPos _ statements size.	[self willStorePop]		whileTrue:			[stack addLast: ArgumentFlag.  "Flag for doStore:"			self interpretNextInstructionFor: self].	args _ Array new: statements size - argPos.	1 to: args size do:  "Retrieve args"		[:i | args at: i put: statements removeLast.		(args at: i) scope: -1  "flag args as block temps"].	block _ self blockTo: jump.	stack addLast: (constructor codeArguments: args block: block).	^true! !!Decompiler methodsFor: 'instruction decoding'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b |	stack last == CascadeFlag ifTrue: [^self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist]		ifFalse: [pc _ savePc].	ifExpr _ stack removeLast.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue.	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			[elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock]).			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'private'!convertToDoLoop	"If statements contains the pattern		var _ startConst.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startConst to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	statements removeLast; removeLast; addLast: toDoStmt.	initStmt variable scope: -1.  "Flag arg as block temp"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoWithLimit: limitStmt)		== nil ifTrue: [^ self].	statements removeLast; removeLast; addLast: toDoStmt.	limitStmt variable scope: -2.  "Flag limit var as block temp"!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor _ aConstructor.	method _ aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block _ self quickMethod]		ifFalse: 			[stack _ OrderedCollection new: method frameSize.			statements _ OrderedCollection new: 20.			super method: method pc: method initialPC.			block _ self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^constructor		codeMethod: aSelector		block: block		tempVars: (tempVars select: [:t | t scope >=0])		primitive: method primitive		class: aClass! !!DecompilerConstructor methodsFor: 'constructor'!codeConstants	"Answer with an array of the objects representing self, true, false, nil,	-1, 0, 1, 2."	^(Array with: NodeSelf with: NodeTrue with: NodeFalse with: NodeNil)		, ((-1 to: 2) collect: [:i | LiteralNode new key: i code: LdMinus1 + i + 1])!codeTemp: index	^ TempVariableNode new		name: 't' , (index + 1) printString		index: index		type: LdTempType		scope: 0!codeTemp: index named: tempName	^ TempVariableNode new		name: tempName		index: index		type: LdTempType		scope: 0! !!Dictionary methodsFor: 'accessing'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	2/18/97 tk: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast." 	self associationsDo: 		[:association | value = association value ifTrue: [^association key]].	^exceptionBlock value!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ Set new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Dictionary methodsFor: 'removing'!removeUnreferencedKeys   "Undeclared removeUnreferencedKeys"	^ self unreferencedKeys do: [:key | self removeKey: key].!unreferencedKeys		"TextConstants unreferencedKeys"	| n |	^ 'Scanning for references . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar | n _ 0.		self keys select:			[:key | bar value: (n _ n+1).			(Smalltalk allCallsOn: (self associationAt: key)) isEmpty]]! !!Dictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Dictionary methodsFor: 'user interface'!inspect	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  6/28/96 sw"	^ DictionaryInspector openOn: self withEvalPane: false		withLabel: aLabel		valueViewClass: FormInspectView!inspectWithLabel: aLabel	"Open a DictionaryInspector on the receiver.  N.B.: this is	an inspector without trash, since InspectorTrash doesn't do the	obvious thing right now.  Use basicInspect to get a normal	(less useful) type of inspector."	DictionaryInspector openOn: self withEvalPane: false withLabel: aLabel! !!DictionaryListController class methodsFor: 'class initialization'!initialize	DictionaryListYellowButtonMenu _		PopUpMenu labels:'inspectreferencesobjects pointing to this valueadd keyremove'		lines: #( 3 ).	DictionaryListYellowButtonMessages _		#(inspectSelection selectionReferences objectReferencesToSelection addEntry removeSelection )	"DictionaryListController initialize"! !!DiskProxyQ methodsFor: 'as yet unclassified'!xxxQMessage: aMessage    "Enqueue aMessage on the queue of messages that I will send the newly-created     object at internalization time.     IMPLEMENTATION: My instance variable messageQueue holds either nil or an Array        of objects to sendTo: the object I'm internalizing to (generally of class        Message or Symbol). -- 11/9/92 jhm     12/1/92 jhm: Remove the 1-element-array optimization."    messageQueue _ messageQueue == nil        ifTrue:  [Array with: aMessage]        ifFalse: [messageQueue, aMessage]! !!DiskProxyQ class methodsFor: 'imported from V'!readDataFrom: aDataStream size: anInteger    "Create an object based on the contents of aDataStream, which was       generated by the objects storeDataOn: method. Answer it.     NOTE: This implementation for DiskProxyQ deals with a subtle issue in reading a        network of objects. Recursively reading the a DiskProxyQs parts will        internalize them (comeFullyUpOnReload), possibly sending messages to the        nascent DiskProxyQ. I.e. the incomplete object receives (and enqueues)        messages!! When we read the DiskProxyQs message queue, we must combine        it with the accumulated queue.     ASSUMES: Rather than hard-wire the index of the inst var messageQueue, we        assume that any non-nil inst var has an Array to be concatenated with the        filed value.     NOTE: This method must match its corresponding storeDataOn:       method. Also, it must send beginReference: after instantiating       the new object but before reading any objects from aDataStream       that might reference it. -- 12/1/92 jhm"    | anObject cntInstVars cntIndexedVars nextValue var |    cntInstVars _ self instSize.    anObject _ self isVariable        ifTrue:  [cntIndexedVars _ anInteger - cntInstVars.                 self basicNew: cntIndexedVars]        ifFalse: [cntIndexedVars _ 0.                 self basicNew].    aDataStream beginReference: anObject.    "Read in the instance vars, but dont just overwrite vars that get contents     before we get there due to recursive work in aDataStream next."    1 to: cntInstVars do: [:i |        nextValue _ aDataStream next.        (var _ anObject instVarAt: i) == nil            ifTrue:     "the normal case"                [anObject instVarAt: i put: nextValue]            ifFalse:    "Oops!! Recover: Concatenate nextValue and var Arrays."                [nextValue == nil                    ifFalse: [anObject instVarAt: i put: (nextValue, var)]]].    "Read in the indexed vars."    1 to: cntIndexedVars do:        [:i | anObject basicAt: i put: aDataStream next].    ^ anObject! !!DisplayObject methodsFor: 'display box access'!initialExtent	"Included here for when a FormView is being opened	as a window.  (4@4) covers border widths."	^ self extent + (4@4) ! !!DisplayScanner methodsFor: 'scanning'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun |	"leftInRun is the # of characters left to scan in the current run; when 0,		it is time to call 'self setStopConditions'"	leftInRun _ 0.	super initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	paragraph _ aParagraph.	fillBlt _ self copy.  "Blt to fill spaces, tabs, margins"	fillBlt sourceForm: nil; sourceOrigin: 0@0; fillColor: aParagraph backgroundColor.	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		runX _ destX _ leftMargin.		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt destX: visibleRectangle left destY: lineY			width: leftMargin - visibleRectangle left height: lineHeight; copyBits.		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[stopCondition _ self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						displaying: true.				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits.		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'stop conditions'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	self fillLeading.	^ true !endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	self fillLeading.  "Fill any leading above or below the font"	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	(runStopIndex _ lastIndex + (runLength - 1)) > line last 		ifTrue: [runStopIndex _ line last].	self setStopConditions.	^ false!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	| oldX |	spaceCount _ spaceCount + 1.	oldX _ destX.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	fillBlt destX: oldX destY: destY width: destX - oldX height: height; copyBits.	lastIndex _ lastIndex + 1.	^ false!tab	| oldX |	oldX _ destX.	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	fillBlt destX: oldX destY: destY width: destX - oldX height: height;		copyBits.	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'private'!fillLeading	"At the end of every run (really only needed when font size changes),	fill any extra leading above and below the font in the larger line height"	"Fill space above the font"	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;		copyBits.	"Fill space below the font"	fillBlt destY: (destY + height); height: (lineY + lineHeight) - (destY + height);		copyBits.!setFont 	| map |	foregroundColor _ paragraph foregroundColor.	super setFont.  "Sets font and emphasis bits"	lastSourceDepth = sourceForm depth ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		map _ (Color defaultColorMapFrom: sourceForm depth to: destForm depth) copy.		map at: 1 put: ((paragraph backgroundColor bitPatternForDepth: destForm depth) at: 1).		self colorMap: map.		lastSourceDepth _ sourceForm depth].	sourceForm depth = 1 ifTrue:		[(colorMap == nil or: [destForm depth = 1]) ifFalse:			[colorMap at: 2 put: ((foregroundColor bitPatternForDepth: destForm depth) at: 1)]].	destY _ lineY + line baseline - font ascent!textColor: textColor	foregroundColor _ textColor! !!DisplayScreen methodsFor: 'displaying'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map	((BitBlt		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits!flash: aRectangle 	"Flash the area of the screen defined by the given rectangle."	self reverse: aRectangle.	(Delay forMilliseconds: 100) wait.	self reverse: aRectangle.! !!DisplayScreen methodsFor: 'private'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  12/10/96 tk, di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize < depth ifFalse:		["Make sure there is enough space"		area _ Display boundingBox area. "pixels"		ScheduledControllers scheduledWindowControllers do:			[:aController | aController view cacheBitsAsTwoTone ifFalse:				[area _ area + aController view windowBox area]].		need _ (area * pixelSize // 8) - (area * depth // 8)  "new bytes needed"				+ 80000.  "lowSpaceThreshold (should be shared)"		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self halt: 'Insufficient free space']].	self depth: pixelSize.  	self setExtent: self extent.	ScheduledControllers updateGray.	DisplayScreen startUp! !!DisplayText methodsFor: 'converting'!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para _ Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor = Color none ifTrue: [para rule: Form paint].	^ para! !!DisplayText methodsFor: 'color'!backgroundColor	backColor == nil ifTrue: [^ Color none].	^ backColor! !!DisplayText class methodsFor: 'examples'!example	"Continually prints two lines of text wherever you point with the cursor 	and press any mouse button.  Terminate by pressing any key on the 	keyboard."	| tx |	tx _ 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color none.	tx _ tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !!DosFileDirectory methodsFor: 'file creation'!fileClass	^ StandardFileStream! !!DosFileDirectory class methodsFor: 'initialization'!pathNameDelimiter	^ $\! !!DualChangeSorter methodsFor: 'everything'!open	"1991, tk.  Modified 5/16/96 sw: decrease minimum size drastically	 6/18/96 sw: more modest minimum size, and other minor adjustments	 11/26/96 sw: more useful choice for initial cs in second sorter"	| topView |	leftCngSorter _ ChangeSorter new initializeFor: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new initializeFor: ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	topView _ StandardSystemView new.	topView model: self.	topView label: leftCngSorter label.	topView minimumSize: 300 @ 200.	self openView: topView.	topView controller open!openView: topView	"Create views of dual side-by-side change sorter views""	| leftView rightView |	leftView _ View new.	leftView model: leftCngSorter.	leftView window: (0 @ 0 extent: 360 @ 360).	leftView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	leftCngSorter openView: topView offsetBy: 0@0."	rightView _ View new.	rightView model: rightCngSorter.	rightView window: (0 @ 0 extent: 360 @ 360).	rightView borderWidthLeft: 0 right: 0 top: 0 bottom: 0."	rightCngSorter openView: topView offsetBy: 360@0."	topView addSubView: leftView.	topView addSubView: rightView toRightOf: leftView."! !DummyStream comment:'The purpose of this class is to absorb all steam messages and do nothing.  This is so ReferenceStream can pretend to write on it while traversing all objects it would normally write.  We need to know what those object are.  8/17/96 tk'!!EllipseMorph methodsFor: 'all'!containsPoint: aPoint	| radius other delta xOverY |	(bounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	radius _ bounds height asFloat / 2.	other _ bounds width asFloat / 2.	delta _ aPoint - bounds topLeft - (other@radius).	xOverY _ bounds width asFloat / bounds height asFloat.	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared!drawOn: aCanvas 	aCanvas fillOval: bounds color: color		borderWidth: borderWidth@borderWidth borderColor: borderColor"borderWidth > 0	ifTrue:		[borderColor ifNotNil: [aCanvas fillOval: bounds color: borderColor].		color ifNotNil: [aCanvas fillOval: (bounds insetBy: borderWidth) color: color]]	ifFalse: 		[color ifNotNil: [aCanvas fillOval: bounds color: color]]."!initialize	super initialize.	color _ Color yellow.	borderColor _ Color black.	borderWidth _ 1.! !EmphasizedMenu comment:'A selection menu in which individual selections are allowed to have different emphases.  Emphases allowed are: bold, italic, struckThrough, and plain.  Provide an emphasis array, with one element per selection, to use.  Refer to the class method #example.'!!EmphasizedMenu methodsFor: 'display'!startUpWithCaption: captionOrNil	self setEmphasis.	^ super startUpWithCaption: captionOrNil! !!EmphasizedMenu methodsFor: 'emphasis'!emphases: emphasisArray	emphases _ emphasisArray!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  12/11/96 sw"	emphases _ (Array new: selections size) atAllPut: nil.	emphases at: itemNumber put: #bold! !!EmphasizedMenu methodsFor: 'private'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  12/11/96 sw"	| selStart selEnd currEmphasis |	labelString _ labelString asText.	emphases size == 0 ifTrue: [^ self].	selStart _ 1.	1 to: selections size do:		[:line |			selEnd _ selStart + (selections at: line) size - 1.			((currEmphasis _ emphases at: line) size > 0 and: [currEmphasis ~~ #plain]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart _ selEnd + 2]! !!EmphasizedMenu class methodsFor: 'instance creation'!example1	"An example of how to get an EmphasizedMenu to work for you.  12/11/96 sw"	(self selections: 			#('how' 'well' 'does'   'this'   'work?') 		emphases: 			#(bold     0    italic struckOut plain))		startUpWithCaption: 'A Menu with Emphases'"EmphasizedMenu example1"!example2	"EmphasizedMenu example2"	| aMenu |	aMenu _ EmphasizedMenu selections: #('One' 'Two' 'Three' 'Four').	aMenu onlyBoldItem: 3.	aMenu startUpWithCaption: 'Only the Bold'!example3	"An example of how to get an EmphasizedMenu to work for you.  12/11/96 sw"	^ (self selectionAndEmphasisPairs: 		#('how' bold   'well'	0  'does'  italic   'this'  struckOut  'work' plain))		startUpWithCaption: 'A Menu with Emphases'"EmphasizedMenu example3"!selectionAndEmphasisPairs: interleavedList	"An alternative form of call.  12/23/96 sw"	| selList  emphList |	selList _ OrderedCollection new.	emphList _ OrderedCollection new.	interleavedList pairsDo:		[:aSel :anEmph |			selList add: aSel.			emphList add: anEmph].	^ self selections:selList emphases: emphList!selections: selList emphases: emphList	"Answer an instance of the receiver with the given selections and emphases.  12/11/96 sw"	^ (self selections: selList) emphases: emphList"(EmphasizedMenu selections: #('how' 'well' 'does' 'this' 'work?') emphases: #(bold 0 italic struckOut plain)) startUp" ! !!Encoder methodsFor: 'initialize-release'!fillDict: dict with: nodeClass mapping: keys to: codeArray	| codeStream |	codeStream _ ReadStream on: codeArray.	keys do: 		[:key | dict 				at: key				put:  (nodeClass new name: key key: key code: codeStream next)]!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32! !!Encoder methodsFor: 'encoding'!encodeVariable: name ifUnknown: action	| varNode |	varNode _ 		scopeTable 			at: name			ifAbsent: 				[self lookupInPools: name 					ifFound: [:assoc | ^self global: assoc name: name].				^action value].	^varNode!litIndex: literal	| p |	p _ literalStream position.	p = 256 ifTrue:		[self notify: 'More than 256 literals referenced. You must split or otherwise simplify this method.The 257th literal is: ', literal printString. ^nil].		"Would like to show where it is in the source code, 		 but that info is hard to get."	literalStream nextPut: literal.	^ p! !!Encoder methodsFor: 'temps'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node _ scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self notify: 'Name already used in a Pool or Global'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node!bindArg: name 	"Declare an argument."	| node |	node _ self bindTemp: name.	^ node nowHasDef nowHasRef!newTemp: name	nTemps _ nTemps + 1.	^ TempVariableNode new		name: name		index: nTemps - 1		type: LdTempType		scope: 0! !!Encoder methodsFor: 'results'!tempNames 	| tempNodes |	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn | (assn value isMemberOf: TempVariableNode)			ifTrue: [tempNodes add: assn value]].	^ tempNodes collect: [:node | node key]!tempsAndBlockArgs	| tempNodes var |	tempNodes _ OrderedCollection new.	scopeTable associationsDo:		[:assn | var _ assn value.		((var isTemp and: [var isArg not])					and: [var scope = 0 or: [var scope = -1]])			ifTrue: [tempNodes add: var]].	^ tempNodes!unusedTempNames 	| unused |	unused _ OrderedCollection new.	scopeTable associationsDo:		[:assn | (assn value isUnusedTemp)			ifTrue: [unused add: assn value key]].	^ unused! !!Encoder methodsFor: 'source mapping'!sourceMap	"Answer with a sorted set of associations (pc range)."	^ (sourceRanges keys collect: 		[:key |  Association key: key pc value: (sourceRanges at: key)])			asSortedCollection! !!Encoder methodsFor: 'private'!lookupInPools: name ifFound: assocBlock	| |	Symbol 		hasInterned: name 		ifTrue: [:sym | ^class scopeHas: sym ifTrue: assocBlock].	^ class scopeHas: name ifTrue: assocBlock.  "Its a string in the pool"! !!ExternalStream methodsFor: 'accessing'!nextInto: buffer 	"fill buffer from my collection"	(buffer isMemberOf: Bitmap) ifTrue:		[1 to: buffer size do:			[:index | buffer at: index put: (self nextNumber: 4)].		^ buffer].	1 to: buffer size do:		[:index | buffer at: index put: self next].	^ buffer! !!ExternalStream methodsFor: 'nonhomogeneous accessing'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next].	^ s normalize! !FFT comment:'This class implements the Fast Fourier Transform roughly as described on page 367of "Theory and Application of Digital Signal Processing" by Rabiner and Gold.Each instance caches tables used for transforming a given size (n = 2^nu samples) of data.It would have been cleaner using complex numbers, but often the data is all real.'!!FFT methodsFor: 'initialization'!nu: order	"Initialize variables and tables for transforming 2^nu points"	|  j perms k |	nu _ order.	n _ 2 bitShift: nu-1.	"Initialize permutation table (bit-reversed indices)"	j_0.	perms _ WriteStream on: (Array new: n).	0 to: n-2 do:		[:i |		i < j ifTrue: [perms nextPut: i+1; nextPut: j+1].		k _ n // 2.		[k <= j] whileTrue: [j _ j-k.  k _ k//2].		j _ j + k].	permTable _ perms contents.	"Initialize sin table 0..pi/2 in n/4 steps."	sinTable _ (0 to: n/4) collect: [:i | (i asFloat / (n//4) * Float pi / 2.0) sin]!realData: real	realData _ real.	imagData _ real collect: [:i | 0.0]  "imaginary component all zero"!realData: real imagData: imag	realData _ real.	imagData _ imag! !!FFT methodsFor: 'transforming'!permuteData	| i end a b |	i _ 1.	end _ permTable size.	[i <= end] whileTrue:		[a _ permTable at: i.		b _ permTable at: i+1.		realData swap: a with: b.		imagData swap: a with: b.		i _ i + 2]!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	realN _ n asFloat.	1 to: n do:		[:i |		realData at: i put: (realData at: i) / realN.		imagData at: i put: (imagData at: i) / realN]!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	self permuteData.	1 to: nu do:		[:level |		lev _ 1 bitShift: level.		lev1 _ lev // 2.		1 to: lev1 do:			[:j |			theta _ j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU _ sinTable at: sinTable size - theta.					imagU _ sinTable at: theta + 1]				ifFalse:					[realU _ (sinTable at: theta - (n//4) + 1) negated.					imagU _ sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU _ imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i _ j.			[i <= n] whileTrue:				[ip _ i + lev1.				realT _ ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT _ ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i _ i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FFT methodsFor: 'testing'!plot: samples in: rect	"Throw-away code just to check out a couple of examples"	| min max x dx pen y |	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	min _ 1.0e30.  max _ -1.0e30.	samples do:		[:v |		min _ min min: v.		max _ max max: v].	pen _ Pen new.  pen up.	x _ rect left.	dx _ rect width asFloat / samples size.	samples do:		[:v |		y _ (max-v) / (max-min) * rect height asFloat.		pen goto: x asInteger @ (rect top + y asInteger).		pen down.		x _ x + dx].	max printString displayOn: Display at: (x+2) @ (rect top-9).	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)!test  "Display restoreAfter: [(FFT new nu: 8) test].  --  Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self transformForward: true.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	self transformForward: false.	self plot: realData in: (100@260 extent: 256@60)! !FileDirectory comment:'I represent a collection of Files. My instances are uniquely identified by the device or server to which they refer. They may also be found in some other dictionary or FileDirectory, though often this is implicit.  FileDirectories carry a path name, and are capable of a number of file creation and access functions, relating to the directory, or volume indicated by their path name.  A FileDirectory can be thought of as a Dictionary whose keys are the local names of files in that directory, and whose values are directory "entries".A directory "entry" is an array of five items:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>See the comment in lookupEntry:... which provides primitive access to this information.'!!FileDirectory methodsFor: 'file names'!fullNameFor: fileName	pathName isEmpty ifTrue:		[^ self checkName: fileName fixErrors: true].	"Return <explicit or implicit path>,<corrected local name>"	FileDirectory splitName: fileName to:		[:path :localName |		^ (path isEmpty ifTrue: [pathName] ifFalse: [path]) ,			self pathNameDelimiter asString , 			(self checkName: localName fixErrors: true)]! !!FileDirectory methodsFor: 'dictionary access'!includesKey: aString	"Answer whether the receiver includes an element of the given name."	"Note: aString may designate a file local to this directory, or it may be a full path name. Try both."	^ (StandardFileStream isAFileNamed: pathName , self pathNameDelimiter asString , aString) or:		[StandardFileStream isAFileNamed: aString]! !!FileDirectory class methodsFor: 'class initialization'!openSources: sourcesName andChanges: changesName forImage: imageName	"Look for the changes file on the image volume, and make the image volume the default directory.  Then look for the sources in the image volume.   Install results in SourceFiles.  2/13/96 sw.  Look for alias to sources 12/9/96 tk"	| sources changes sourceAlias |	self setDefaultDirectoryFrom: imageName.	sources _ (DefaultDirectory includesKey: sourcesName)		ifTrue: [DefaultDirectory readOnlyFileNamed: sourcesName]		ifFalse: [nil].	sources == nil ifTrue:		["Allow an un-renamed alias of the sources file"		sourceAlias _ sourcesName, ' alias'.		sources _ (DefaultDirectory includesKey: sourceAlias)			ifTrue: [DefaultDirectory readOnlyFileNamed: sourceAlias]			ifFalse: [nil]].	changes _ (DefaultDirectory includesKey: changesName)		ifTrue: [DefaultDirectory oldFileNamed: changesName]		ifFalse: [nil].	SourceFiles _ Array with: sources with: changes! !!FileDirectory class methodsFor: 'name service'!convertName: fileName to: volAndNameBlock	"Convert the fileName to a directory object and a local fileName.  FileName must be of the form: <path><name> where the optional <path> specifies a known directory and <name> is the file name within that directory."	self splitName: fileName to:		[:path :localName |		path isEmpty		ifTrue:			[^ volAndNameBlock value: DefaultDirectory								value: localName]		ifFalse:			[^ volAndNameBlock value: (self newOnPath: path)								value: localName]]! !!FileDirectory class methodsFor: 'primitives'!lookupEntryIn: pathName index: index	"Look up the index-th entry of the directory with the given path (starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty path enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given pathName is bad." 	<primitive: 162>	self primitiveFailed.!pathNameDelimiter	^ self actualPathNameDelimiter!setMacFileNamed: fileName type: typeString creator: creatorString	"Mac specific; noop on other platforms."! !!FileList methodsFor: 'initialization'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #name].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ (Array with: '[]'), directory pathParts.	self changed: #relabel.	self changed: #list.	self newListAndPattern: (pattern == nil ifTrue: ['*']										ifFalse: [pattern]).! !!FileList methodsFor: 'list access'!toggleFileListIndex: anInteger	"Select the file name in the receiver's list whose index is the argument, 	anInteger. If the current selection index is already anInteger, deselect it."	| item name |	listIndex = anInteger	ifTrue:		[listIndex _ 0.		fileName _ nil]	ifFalse: 		[listIndex _ anInteger.		item _ list at: anInteger.		item first = $( ifTrue:  "remove size or date"			[item _ item copyFrom: (item indexOf: $)) + 2 to: item size].		(item endsWith: self folderString)			ifTrue:			["remove [...] folder string and open the folder"			name _ item copyFrom: 1 to: item size - self folderString size.			listIndex _ 0.			^ self directory: (FileDirectory newOnPath:				(directory fullNameFor: name))]			ifFalse:			["open the file selected"			self setFileName: item]].	self changed: #fileListIndex! !!FileList methodsFor: 'menu messages'!copyName	| localName |	listIndex = 0 ifTrue: [^ self].	localName _ FileDirectory default localNameFor: self fullName.	localName size = 0 ifTrue: [localName _ self fullName].	ParagraphEditor new clipboardTextPut: localName asText! !!FileList methodsFor: 'private'!defaultContents	list == nil ifTrue: [^ String new].	^ String streamContents:		[:s | s nextPutAll: 'NO FILE SELECTED'; cr.		s nextPutAll: '  -- Folder Summary --'; cr.		list do: [:item | s nextPutAll: item; cr]]!readContentsBrief: brevity	"Read the contents of the receiver's selected file."	listIndex = 0		ifTrue: [^self defaultContents]		ifFalse: [^ super readContentsBrief: brevity]! !!FileListController methodsFor: 'menu messages'!importHyperSqueakGIF	"Import the selected file as a GIF file, into the HyperSqueak picture library.  8/17/96 sw"	model isLocked ifTrue: [^ view flash].	self controlTerminate.	model importHyperSqueakGIF.	self controlInitialize!openImageInWindow	self controlTerminate.	model openImageInWindow.	self controlInitialize	! !!FileListController class methodsFor: 'class initialization'!initialize   "FileListController initialize"	"Initialize the file list menu.  6/96 di; modified 7/12/96 sw to add the file-into-new-change-set feature"	FileListYellowButtonMenu _ PopUpMenu labels:'fileInfile into new change setbrowse changesspawn this filecopy name to clipboardopen image in a windowimport GIF to GIFImportsimport GIF to HyperSqueakload HyperSqueak stacksort by namesort by sizesort by daterenamedeleteadd new file' lines: # (5 9 12).	FileListYellowButtonMessages _#(fileInSelection fileIntoNewChangeSet browseChanges editFile copyName openImageInWindow importGIF importHyperSqueakGIF loadIntoHyperSqueak sortByName sortBySize sortByDate renameFile deleteFile addNewFile)! !!FileModel methodsFor: 'accessing'!importGIF	"Import the file into a GIF file.  Places the resulting form into the global dictionary GIFImports, at a key which the short filename up to the first period.  7/18/96 sw	 9/18/96 sw: fail gracefully if GIF is missing."	| aKey anImage gifReader |	(gifReader _ Smalltalk gifReaderClass) == nil ifTrue: [^ self inform: 'Sorry, there is no GIF reader available in the current system.'].	aKey _ self fileName sansPeriodSuffix.	anImage _ gifReader imageFrom: (FileStream oldFileNamed: self fullName) depth: 8.		"Could allow 16 and not lose data"	Smalltalk gifImports at: aKey put: anImage!importHyperSqueakGIF	"Import the file into a GIF file, into HyperSqueak. It had better be in the appropriate format, or you'll regret it!!  Places the resulting form into the HyperSqueak picture library, at a key which the short filename up to the first period. 8/17/96 sw	 9/18/96 sw: handle no-gif-reader and no-HyperSqueak cases with Informers	12/6/96 tk: Do force it to be 8-bit image"	| aKey anImage hsq gifReader |	Smalltalk hyperSqueakPresent ifFalse:		[^ self inform: 'Sorry, HyperSqueak is not present in the current system.'].	(gifReader _ Smalltalk gifReaderClass) == nil ifTrue: [^ self inform: 'Sorry, there is no GIF reader available in the current system.'].	aKey _ self fileName sansPeriodSuffix.	anImage _ gifReader imageFrom: (FileStream oldFileNamed: self fullName) depth: 8.	(hsq _ Smalltalk at: #SqueakSupport ifAbsent: [nil]) == nil		ifFalse:			[hsq importPicture: anImage withKey: aKey]!loadIntoHyperSqueak	"Load the currently-selected file in as a HyperSqueak save-file.  8/12/96 sw	 12/96 tk: use SmartRefStream"	| ff this save |	Smalltalk hyperSqueakPresent ifFalse:		[^ self inform: 'Sorry, HyperSqueak is not present in the current system.'].	ff _ SmartRefStream fileNamed: self fullName.	save _ Preferences logUserScripts.	Preferences startLoggingUserScripts.  "for incoming buttons"	this _ ff next.	this class name == DataStream incomingObjectsClass name ifFalse:			[self error: 'Expected an instance of IncomingObjects'].	ff close.	save ifFalse: [Preferences stopLoggingUserScripts]!openImageInWindow	| file fileCode form |	file _ FileStream readOnlyFileNamed: self fullName.	fileCode _ file next asciiValue.	file close.	fileCode = 2		ifTrue: [form _ Form newFromFileNamed: self fullName]		ifFalse: [form _ Smalltalk gifReaderClass imageFrom:					(FileStream oldFileNamed: selffullName) depth: Display depth].	FormView open: form named: fileName!put: aString 	| f |	(aString size >= 5 and:		[#('File ' '16r0 ') includes: (aString copyFrom: 1 to: 5)])		ifTrue: [(self confirm:'Abbreviated and hexadecimal file viewscannot be meaningfully saved at present.Is this REALLY what you want to do?')				ifFalse: [^ self]].	f _ FileStream newFileNamed: self fullName.	Cursor write showWhile: [f nextPutAll: aString; close].!readContentsBrief: brevityFlag	"retrieve the contents from the external file unless it is too long.	9/21/96 tk  Don't create a file here.  Check if exists."	| f size newContents first1000 last1000 |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(brevityFlag and: [(size _ f size) > 30000]) ifFalse: 		[^ f contentsOfEntireFile].	"Don't display long files at first.	Composing the paragraph may take a long time."	first1000 _ f next: 1000.	f position: size - 1000.	last1000 _ f next: 1000.	f close.	^ 'File ''' , fileName , ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 1000 characters:--------------------------------' , first1000 , '... and here are the last 1000 characters:--------------------------------------' , last1000!readContentsHex	"retrieve the contents from the external file unless it is too long.	9/21/96 tk  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ FileStream oldFileOrNoneNamed: self fullName. 	f == nil ifTrue:		[^ 'For some reason, this file cannot be read'].	(size _ f size) > 10000		ifTrue: [data _ f next: 10000. f close]		ifFalse: [data _ f contentsOfEntireFile].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	size > 10000		ifTrue: [^ 'First 10k bytes:------------------' , hexData]		ifFalse: [^ hexData].! !!FileStream methodsFor: 'file status'!close	"Set the receiver's file status to closed."	closed		ifFalse: 			[self writing 				ifTrue: [(rwmode bitAnd: Shorten) = Shorten							ifTrue: [self shorten]							ifFalse: [self flush]].			closed _ true.			readLimit _ writeLimit _ 0.			self file close].! !!FileStream class methodsFor: 'instance creation'!fileNamed: fileName 	^ self concreteStream fileNamed: (self fullName: fileName)!newFileNamed: fileName 	^ self concreteStream newFileNamed: (self fullName: fileName)!oldFileNamed: fileName 	^ self concreteStream oldFileNamed: (self fullName: fileName)!oldFileOrNoneNamed: fileName	"Only open the file if it exists already.  Don't get an error if not there.  9/21/96 tk"| myName |myName _ self fullName: fileName.^ (self concreteStream isAFileNamed: myName) 	ifTrue: [self concreteStream oldFileNamed: myName]	ifFalse: [nil].!readOnlyFileNamed: fileName 	^ self concreteStream readOnlyFileNamed: (self fullName: fileName)! !!FileStream class methodsFor: 'concrete classes'!concreteStream	"Who should we really direct class queries to?  9/21/96 tk"	^ StandardFileStream! !!FlasherMorph methodsFor: 'all'!color: aColor	super color: aColor.	onColor _ aColor.!fullPrintOn: aStream	color _ onColor.	super fullPrintOn: aStream.!initialize	super initialize.	self color: Color red.	self extent: 25@25.	self borderWidth: 2.!step	color = onColor		ifTrue: [super color: (onColor mixed: 0.5 with: Color black)]		ifFalse: [super color: onColor].!stepTime	"Answer the desired time between steps in milliseconds."	^ 500! !!Float methodsFor: 'arithmetic'!abs	"This is faster than using Number abs."	self < 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]!reciprocal	^ 1.0 / self! !!Float methodsFor: 'mathematical functions'!arcCos	"Answer the angle in radians."	^ Halfpi - self arcSin!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta _ (self * Halfpi) / (self + 1.0).	"iterate"	eps _ Halfpi * Epsilon.	step _ theta.	[(step * step) > eps] whileTrue: [		sinTheta _ theta sin.		cosTheta _ theta cos.		step _ (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta _ theta - step].	^ theta!cos	"Answer the cosine of the receiver taken as an angle in radians."	^ (self + Halfpi) sin!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."	^ self degreesToRadians cos!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."	^ self degreesToRadians sin!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base _ E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract _ self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction _ 1.0 + fract.	delta _ fract * fract / 2.0.	div _ 2.0.	[delta > Epsilon] whileTrue: [		correction _ correction + delta.		div _ div + 1.0.		delta _ delta * fract / div].	correction _ correction + delta.	^ base * correction!floorLog: radix 	"Quick computation of (self log: radix) floor."	| x rsq |	self < radix ifTrue: [^0]. 	"self assumed positive"	self < (rsq _ radix * radix) ifTrue: [^1].	x _ 2 * (self floorLog: rsq).	"binary recursion like ipow"	^x + (self / (radix raisedTo: x) floorLog: radix)!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt _ self exponent.	n _ Ln2 * expt.	mant _ self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x _ mant - 1.0.	div _ 1.0.	pow _ delta _ sum _ x.	x _ x negated.  "x <= 0"	eps _ Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta.		"pass two: delta is negative"		div _ div + 1.0.		pow _ pow * x.		delta _ pow / div.		sum _ sum + delta].	^ n + sum	"2.718284 ln 1.0"!log	"Answer the base 10 logarithm of the receiver."	^ self ln / Ln10!raisedTo: power	^ (self ln * power asFloat) exp!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum _ delta _ self.	self2 _ 0.0 - (self * self).	i _ 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta.		"twice"		delta _ (delta * self2) / (i * (i + 1.0)).		i _ i + 2.0.		sum _ sum + delta].	^ sum!sqrt	"Answer the square root of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	"Newton-Raphson"	self <= 0.0 ifTrue: [		self = 0.0			ifTrue: [^ 0.0]			ifFalse: [^ self error: 'sqrt is invalid for x < 0']].	"first guess is half the exponent"	exp _ self exponent // 2.	guess _ self timesTwoPower: (0 - exp).	"get eps value"	eps _ guess * Epsilon.	eps _ eps * eps.	delta _ (self - (guess * guess)) / (guess * 2.0).	[(delta * delta) > eps] whileTrue: [		guess _ guess + delta.		delta _ (self - (guess * guess)) / (guess * 2.0)].	^ guess!tan	"Answer the tangent of the receiver taken as an angle in radians."	^ self sin / self cos! !!Float methodsFor: 'truncation and round off'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value. Essential. See Object documentation 	whatIsAPrimitive. "	<primitive: 51>	^ (self quo: 16383.0) * 16383 + (self rem: 16383.0) truncated! !!Float methodsFor: 'printing'!hex  "If ya really want to know..."	| word nibble |	^ String streamContents:		[:strm |		1 to: 2 do:			[:i | word _ self at: i.			1 to: 8 do: 				[:s | nibble _ (word bitShift: -8+s*4) bitAnd: 16rF.				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]"(-2.0 to: 2.0) collect: [:f | f hex]"!printOn: aStream base: base	"Estimate significant figures and handle sign." 	| digitCount |	digitCount _ 2r1.0e52 floorLog: base asFloat.  "IEEE double -- 52 bits"	self > 0.0		ifTrue: [self absPrintOn: aStream base: base digitCount: digitCount]		ifFalse: [self = 0.0 ifTrue: [^ aStream nextPutAll: '0.0'].				aStream nextPutAll: '-'.				self negated absPrintOn: aStream base: base digitCount: digitCount]! !!Float methodsFor: 'private'!absPrintOn: aStream base: base digitCount: digitCount 	"Print me in the given base, using digitCount significant figures."	| fuzz x exp q fBase |	fBase _ base asFloat.	"x is myself normalized to [1.0, fBase), exp is my exponent"	exp _ 		self < 1.0			ifTrue: [(fBase / self floorLog: fBase) negated]			ifFalse: [self floorLog: fBase].	x _ self / (fBase raisedTo: exp).	fuzz _ fBase raisedTo: 1 - digitCount.	"round the last digit to be printed"	x _ 0.5 * fuzz + x.	x >= fBase		ifTrue: 			["check if rounding has unnormalized x"			x _ x / fBase.			exp _ exp + 1].	(exp < 6 and: [exp > -4])		ifTrue: 			["decimal notation"			q _ 0.			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000' at: i)]]]		ifFalse: 			["scientific notation"			q _ exp.			exp _ 0].	[x >= fuzz]		whileTrue: 			["use fuzz to track significance"			i _ x asInteger.			aStream nextPut: (Character digitValue: i).			x _ x - i asFloat * fBase.			fuzz _ fuzz * fBase.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	[exp >= -1]		whileTrue: 			[aStream nextPut: $0.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	q ~= 0		ifTrue: 			[aStream nextPut: $e.			q printOn: aStream]!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float class methodsFor: 'class initialization'!initialize		"Float initialize. Float pi" 	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288 		Pi/2 = 1.57079632679489661923132169163975144 		Pi/4 = 0.78539816339744830961566084581987572 		Pi*2 = 6.28318530717958647692528676655900576 		Pi/180 = 0.01745329251994329576923690768488612 		2.0 ln = 0.69314718055994530941723212145817657 		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi _ 3.14159265358979323846264338327950288.	Halfpi _ Pi / 2.0.	Fourthpi _ Pi / 4.0.	Twopi _ Pi * 2.0.	RadiansPerDegree _ Pi / 180.0.	Ln2 _ 0.69314718055994530941723212145817657.	Ln10 _ 10.0 ln.	Sqrt2 _ 1.41421356237309504880168872420969808.	E _ 2.718281828459045235360287471353.	Epsilon _ 0.000000000001.  "Defines precision of mathematical functions"	MaxVal _ 1e306.	MinVal _ 1e-306.	MaxValLn _ 704.! !!Float class methodsFor: 'constants'!e	"Answer the constant, E."	^E! !!FMSound methodsFor: 'sound generation'!doControl	super doControl.	modulationDecay ~= 1.0 ifTrue: [		modulation _ (modulationDecay * modulation asFloat) truncated.	].!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"A simple implementation of Chowning's frequency-modulation synthesis technique. The center frequency is varied as the sound plays by changing the increment by which to step through the wave table."	"FMSound majorScale play"	"(FMSound pitch: 440.0 dur: 1.0 loudness: 200) play"	| lastIndex mySample sample channelIndex |	<primitive: 177>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #waveTable declareC: 'short int *waveTable'.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [ :i |		mySample _ (amplitude * (waveTable at: index)) // 1000.		pan > 0 ifTrue: [			channelIndex _ 2 * i.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		pan < 1000 ifTrue: [			channelIndex _ (2 * i) - 1.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		index _ index + increment + ((modulation * (waveTable at: offsetIndex)) // 1000000).		index > waveTableSize ifTrue: [			index _ index - waveTableSize.		].		index < 1 ifTrue: [			index _ index + waveTableSize.		].		offsetIndex _ offsetIndex + offsetIncrement.		offsetIndex > waveTableSize ifTrue: [			offsetIndex _ offsetIndex - waveTableSize.		].	].	count _ count - n.! !!FontSet class methodsFor: 'as yet unclassified'!acceptsLoggingOfCompilation	"Dont log sources for my subclasses, so as not to waste time and space	storing printstring versions of the string literals."	^ self == FontSet!convertFontsNamed: familyName  "FontSet convertFontsNamed: 'Palatino' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and build	a fontset class from them.  If one already exists, the sizes that can be	found will be overwritten."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as this image."	| f allFontNames className fontSet bytes sizeChars header strm fontString tempName |	"Check first for matching file names and usable FontSet class name."	allFontNames _ FileDirectory default fileNamesMatching: familyName , '*.BF'.	allFontNames isEmpty ifTrue: [^ self halt: 'No files found like ' , familyName , 'NN.BF'].	className _ (familyName select: [:c | c isAlphaNumeric]) capitalized asSymbol.	(Smalltalk includesKey: className)		ifTrue: ["Check that this is already a FontSet"				((fontSet _ Smalltalk at: className) inheritsFrom: self)					ifFalse: [self halt: 'The name ' , familyName , ' is already in use']]		ifFalse: [fontSet _ self subclass: className					instanceVariableNames: '' classVariableNames: ''					poolDictionaries: '' category: self category].	tempName _ 'FontTemp.sf2'.	allFontNames do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: fname.		f writeAsStrike2named: tempName.		fontString _ (FileStream oldFileNamed: tempName) contentsOfEntireFile.		sizeChars _ (fname copyFrom: familyName size + 1 to: fname size) copyUpTo: $. .		header _ 'sizeNN	^ self size: NN fromLiteral:' copyReplaceAll: 'NN' with: sizeChars.		fontSet class compile: header , fontString printString			classified: 'font creation' notifying: nil].	FileDirectory default deleteFileNamed: tempName.! !!Form methodsFor: 'accessing'!center	"Note that offset is ignored here.  Are we really going to embrace offset?  3/9/97 tk"	^ (width @ height) // 2!size	"Should no longer be used -- use bitsSize instead.  length of variable part of instance."	^ super size!theForm	"For compatibility with MaskedForm"	^ self! !!Form methodsFor: 'copying'!copy: sourceRectangle from: sourceForm to: destPt rule: rule	^ self copy: (destPt extent: sourceRectangle extent)		from: sourceRectangle topLeft in: sourceForm rule: rule! !!Form methodsFor: 'displaying'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBlt 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Supply a color map from source to destination.  12/8/96 tk"	| map rule |	rule _ ruleInteger.	aDisplayMedium depth ~= depth ifTrue: ["need a map"		map _ Color defaultColorMapFrom: depth to: aDisplayMedium depth.		depth = 1 & (aDisplayMedium depth > 8) & (rule = 26 "erase1bitShape") 			ifTrue: [rule _ 1 "and"]].	"Bug workaround"	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm		map: map!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Graphically, it means nothing to scale a Form by floating point values.  	Because scales and other display parameters are kept in floating point to 	minimize round off errors, we are forced in this routine to round off to the 	nearest integer."	| absolutePoint scale magnifiedForm |	absolutePoint _ displayTransformation applyTo: relativePoint.	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm _ self]		ifFalse: 			[scale _ displayTransformation scale.			scale _ scale x @ scale y.			(1@1 = scale)					ifTrue: [scale _ nil. magnifiedForm _ self]					ifFalse: [magnifiedForm _ self magnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Form methodsFor: 'filling'!colorAt: aPoint	"Return the Color in the pixel at coordinate aPoint.  6/20/96 tk"	^ Color 		colorFromPixelValue: 			((BitBlt bitPeekerFromForm: self) pixelAt: aPoint)		depth: depth!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	9/19/96 sw: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ self newColorMap.  "All non-foreground go to 0's, 512 long."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	(2 raisedTo: ppd) = map size 		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [			color _ Color colorFromPixelValue: interiorPixVal depth: depth.			ind _ color pixelValueForDepth: ppd.			map at: ind+1 put: 1].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	bwForm displayOn: self		at: 0@0		clippingBox: self boundingBox		rule: Form erase1bitShape	"Cut a hole in the picture with my mask"		fillColor: nil.	"(cColor pixelValueForDepth: depth) = 0 ifTrue: [^ bwForm]."	"transparent"	self fillShape: bwForm fillColor: aColor.	^ bwForm!shapeFill: aColor seedBlock: seedBlock	depth > 1 ifTrue: [self error: 'This call only meaningful for B/W forms'].	(self findShapeAroundSeedBlock: seedBlock)		displayOn: self at: 0@0 clippingBox: self boundingBox		rule: Form under fillColor: aColor ! !!Form methodsFor: 'bordering'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt _ (BitBlt toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'scaling, rotation'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ Form extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt toForm: newForm)		sourceForm: self;		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p]"!magnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ Form extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		cellSize: cellSize;		combinationRule: 3;		copyQuad: aRectangle innerCorners toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"!opaqueRotationSet: steps rotationCenter: aPoint	"CAUTION:  this returns the set in counterclockwise order from north-pointing.  For the HyperSqueak work of 6/96, the assumption is that they come in clockwise order, and so a fudging routine, SqueakSupport.reversedFormSetFrom:, is provided.  Someday this should be cleaned up.	8/8/96 sw: this variant has a rotationCenter argument, though at the moment it is not used.  It will come in as nil if there is no special center, in which case the centroid of the form should be used, as it always is in the current implementation."	| drawing  back90 flip quad |	self flag: #noteToTed.  "This at the moment is the same as what you fixed up a couple of months ago, and does not actually use the rotationCenter part.  8/9/96 sw"	drawing _ Array new: steps.	steps \\ 4 = 0 ifFalse: ["Can't pull any symmetry tricks, rotate every one"		1 to: steps do: [:ind |			drawing at: ind put: (self rotateBy: 360 - ((ind-1) * 360 // steps))].			^ drawing].	"Do in four sections"	quad _ steps // 4.	1 to: quad do: [:ind |		"degrees: 360, 330, 300"			drawing at: ind put: (self rotateBy: 360 - ((ind-1)*360//steps))].	1 to: quad do: [:ind |		"degrees: 270, 240, 210"			back90 _ drawing at: ind.			drawing at:  ind + quad put: (back90 rotateBy: #left centerAt: back90 center)].	1 to: quad + quad do: [:ind |	"the entire second half circle is rotated 180"			back90 _ drawing at: ind.			flip _ back90 flipBy: #vertical centerAt: back90 center. 			drawing at: ind + quad + quad put: (flip flipBy: #horizontal centerAt: flip center)]. 	^ drawing collect: [:elem |		elem offset: 0@0. 		MaskedForm form: elem transparentPixelValue: 0]!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5)) display].f display"!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #right, #left, or #pi"	| newForm quad rot |	newForm _ Form extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt toForm: newForm)		sourceForm: self;		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify.  3/26/97 tk"	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	bigSide _ (side * scale) rounded.	rot _ Form extent: bigSide@bigSide depth: self depth.	warp _ (WarpBlt toForm: rot)		sourceForm: self;		cellSize: cellSize;		combinationRule: Form over.	r1 _ (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) magnify: 0.75 smoothing: 2) display].f display"!rotateBy: deg rotationCenter: aPoint	"Rotate the receiver by the indicated number of degrees.  This variant gets a rotation center, but in fact ignores the thing -- awaiting someone's doing the right thing.   8/9/96 sw	Note that rotationCenter should now be easy to include in the offset of the resulting form -- see <Point> rotateBy: angle about: center.  Could be even faster by sharing the sin, cos inside rotateBy:.  This should really be reversed so that this becomes the workhorse, and rotateBy: calls this with rotationCenter: self boundingBox center.  And while we're at it, why not include scaling?  9/19/96 di "	^ self rotateBy: deg smoothing: 1!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt toForm: rot)		sourceForm: self;		cellSize: cellSize;		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"!shrink: aRectangle by: scale 	| scalePt |	scalePt _ scale asPoint.	^ self magnify: aRectangle by: (1.0 / scalePt x asFloat) @ (1.0 / scalePt y asFloat)! !!Form methodsFor: 'private'!initFromArray: array	"Fill the bitmap from array.  If the array is shorter,	then cycle around in its contents until the bitmap is filled."	| ax aSize array32 i j word16 |	ax _ 0.	aSize _ array size.	aSize > bits size ifTrue:		["backward compatibility with old 16-bit bitmaps and their forms"		array32 _ Array new: height * (width + 31 // 32).		i _ j _ 0.		1 to: height do:			[:y | 1 to: width+15//16 do:				[:x16 | word16 _ array at: (i _ i + 1).				x16 odd ifTrue: [array32 at: (j _ j+1) put: (word16 bitShift: 16)]						ifFalse: [array32 at: j put: ((array32 at: j) bitOr: word16)]]].		^ self initFromArray: array32].	1 to: bits size do:		[:index |		(ax _ ax + 1) > aSize ifTrue: [ax _ 1].		bits at: index put: (array at: ax)]! !!Form methodsFor: 'transitions'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) do: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form class methodsFor: 'mode constants'!erase1bitShape	"Answer the integer denoting mode erase."	^ 26!oldErase1bitShape	"Answer the integer denoting mode erase."	^ 17!oldPaint	"Answer the integer denoting the 'paint' combination rule."	^16!paint	"Answer the integer denoting the 'paint' combination rule."	^25! !!FormCanvas methodsFor: 'accessing'!extent	^ form extent!form	^ form! !!FormCanvas methodsFor: 'drawing'!fillColor: c	port fillRect: form boundingBox color: (self drawColor: c)!fillOval: r color: c	self fillOval: r color: c borderWidth: 0 borderColor: nil!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	port combinationRule: (self drawRule: Form over).	port fillOval: (r translateBy: origin) color: (self drawColor: c)		borderWidth: borderWidth borderColor: (self drawColor: borderColor)!fillRectangle: r color: c	port fillRect: (r translateBy: origin) color: (self drawColor: c) rule: (self drawRule: Form over)!frameOval: r width: w color: c	self fillOval: r color: nil borderWidth: w borderColor: (self drawColor: c)!frameRectangle: r width: w color: c	port combinationRule: (self drawRule: Form over);		fillColor: (self drawColor: c);		width: w; height: w;		frameRect: (r translateBy: origin)!frameRectangle: r width: w topColor: top leftColor: left rightColor: right bottomColor: bottom 	| rect |	port combinationRule: (self drawRule: Form over);		width: w; height: w.	rect := r translateBy: origin.	port fillColor: (self drawColor: top);		frameRectTop: rect.	port fillColor: (self drawColor: left);		frameRectLeft: rect.	port fillColor: (self drawColor: right);		frameRectRight: rect.	port fillColor: (self drawColor: bottom);		frameRectBottom: rect.!image: img at: aPoint	"Interim: assume img is a Form."	(img isKindOf: MaskedForm) ifTrue: [  "MaskedForm"		shadowDrawing ifTrue: [			img mask displayOn: port destForm at: aPoint + origin clippingBox: clipRect 				rule: Form paint fillColor: shadowStipple.		] ifFalse: [			port copyForm: img form to: aPoint + origin rule: Form paint].	] ifFalse: [  "regular Form"		shadowDrawing ifTrue: [			self fillRectangle: (aPoint extent: img extent) color: Color black.		] ifFalse: [			port copyForm: img to: aPoint + origin rule: Form paint]].!line: pt1 to: pt2 width: w color: c	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over);		width: w; height: w;		drawFrom: (pt1 + origin) to: (pt2 + origin)!point: pt color: c	form colorAt: (pt + origin) put: c.!text: s at: pt font: aFontSpecification color: c	| para |	para _ s asParagraph.	para foregroundColor:				((shadowDrawing or: [form depth > 8 and: [c = Color black]])					ifTrue: [opaqueBlack]					ifFalse: [c])		backgroundColor: Color none.	para displayOn: form		at: (pt + origin)		clippingBox: clipRect		rule: (self drawRule: Form paint)		fillColor: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect)				font: fontOrNil				color: ((shadowDrawing or: [form depth > 8 and: [c = Color black]])							ifTrue: [opaqueBlack]							ifFalse: [c]).	shadowDrawing ifTrue: [scanner fillColor: (self drawColor: c)].	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'other'!showAt: pt	^ form displayAt: pt!showAt: pt invalidRects: updateRects	| blt |	blt _ (BitBlt toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do:		[:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !!FormCanvas methodsFor: 'private'!drawColor: aColor	^ shadowDrawing		ifTrue: [shadowStipple]		ifFalse: [aColor]!drawRule: normalRule	^ shadowDrawing ifTrue: [Form paint] ifFalse: [normalRule]!setForm: aForm	| d mask blackWord |	self reset.	form _ aForm.	port _ GrafPort newOnForm: form.	shadowDrawing _ false.	"Compute a black that will show in paint mode"	opaqueBlack _ form depth <= 8			ifTrue: [Color black]			ifFalse: ["Very dark, but not = 0"					Color red: 1 green: 1 blue: 1 range: 31].	"Compute a 50% stipple mask for pixel size = form depth."	mask _ (1 bitShift: form depth) -1.	d _ form depth * 2.	[d >= 32] whileFalse:		[mask _ mask bitOr: (mask bitShift: d).		d _ d+d].	blackWord _ opaqueBlack pixelWordForDepth: form depth.	shadowStipple _ Bitmap with: (mask bitAnd: blackWord)							with: (mask bitInvert32 bitAnd: blackWord)."xxx disabled until QuickPrint works	stringPainter _ QuickPrint newOn: form box: form computeBoundingBox.	shadowStringPainter _ QuickPrint newOn: form box: form computeBoundingBox.	shadowStringPainter mask: Form gray.	shadowStringPainter combinationRule: Form under.xxx"!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'copying'!copy	"Make a copy the receiver on the same underlying Form but with its own grafPort."	^ super copy setForm: form! !!FormCanvas class methodsFor: 'creation'!extent: extent	^ self extent: extent depth: Display depth!extent: extent depth: depth	^ self new setForm: (Form extent: extent depth: depth)! !!FormCanvas class methodsFor: 'testing'!test	"FormCanvas test"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color white).	canvas line: 10@10 to: 50@30 width: 1 color: (Color black).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).	canvas point: 90@90 color: (Color black).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color black).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightGray).	canvas showAt: 0@0.!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 90@90 color: (Color black).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: (Color white).		canvas line: 10@10 to: 50@30 width: 1 color: (Color black).		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).		canvas point: 90@90 color: (Color black).		canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).		canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).		canvas fillOval: ((10@80) corner: (31@121)) color: (Color black).		canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightGray).		canvas showAt: 0@0.	].!test4	"Time millisecondsToRun: [FormCanvas test4] 1134"	"3762 mSecs -- ParcPlace Smalltalk on Duo 230"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	100 timesRepeat: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: (Color white).		canvas line: 10@10 to: 50@30 width: 1 color: (Color black).		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color gray).		canvas point: 90@90 color: (Color black).		canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color black).		canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color lightGray).		canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color black).		canvas showAt: 0@0.	].!test5	"FormCanvas test5"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color yellow).	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: (Color blue).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color red).	canvas point: 90@90 color: (Color red).	canvas text: 'Hello, Roxie' at: 40@40 font: nil color: (Color red).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color red).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color red).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color red).	canvas showAt: 0@0.! !!FormEditor methodsFor: 'editing tools'!fileInForm	"Ask the user for a file name and then recalls the Form in that file as 	the current source Form (form). Does not change the tool."	| fileName file |	fileName _ self promptRequest: 'type a name for recalling a source Form . . . '.	file _ FileStream oldFileNamed: fileName.	file binary.	form _ Form new readFrom: file.	file close.	tool _ previousTool.!fileOutForm	"Ask the user for a file name and then save the current source form 	(form) under that name. Does not change the tool."	| fileName file |	fileName _ self promptRequest: 'type a name for saving the source Form . . . '.	file _ FileStream newFileNamed: fileName.	file binary.	form writeOn: file.	file close.	tool _ previousTool.!repeatCopy	"As long as the red button is pressed, copy the source form onto the 	display screen."	[sensor redButtonPressed]		whileTrue: 		[(BitBlt destForm: Display sourceForm: form halftoneForm: color			combinationRule: (Display depth > 1 ifTrue: [Form paint]										ifFalse: [mode])			destOrigin: self cursorPoint sourceOrigin: 0@0 extent: form extent			clipRect: view insetDisplayBox)			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF);			copyBits]! !!FormEditor methodsFor: 'menu messages'!edit	model edit! !!FormEditor methodsFor: 'private'!promptRequest: outputMessage 	"Answers with a string typed by the user on the keyboard. keyboard	input is terminated by a line feed character. Typing feedback happens	in a window that is at least 100 bits wide and 50 bits high."	FillInTheBlank		request: outputMessage		displayAt: view insetDisplayBox topCenter + (0@80)		centered: true		action: [:answer] 		initialAnswer: ''.	^answer! !!FormEditor class methodsFor: 'class initialization'!initialize	FlashCursor _ false.	self setKeyboardMap.	YellowButtonMenu _ PopUpMenu labels: 'acceptcanceleditfile out' lines: #(2).	YellowButtonMessages _ #(accept cancel edit fileOut)	"FormEditor initialize"! !!FormEditor class methodsFor: 'private'!createFullScreenForm	"Create a StandardSystemView for a FormEditor on the form whole screen."	| formView formEditor menuView topView extent aForm |	aForm _ Form extent: (Display extent x @ (Display extent y - 112)) depth: Display depth.	formView _ FormHolderView new model: aForm.	formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: menuView controller.	topView _ ColorSystemView new.	topView backgroundColor: #veryLightGray.	topView model: aForm.	topView addSubView: formView.	topView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	topView window: 		(formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))).	topView label: 'Form Editor'.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder _ 2.	formView _ FormHolderView new model: aForm.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView _ View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	aView window extent > formView viewport extent		ifTrue: [formView borderWidthLeft: 1 right: 1 top: 0 bottom: 1]		ifFalse: [formView borderWidthLeft: 0 right: 0 top: 0 bottom: 1].	topView _ ColorSystemView new.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !FormSetFont comment:'FormSetFonts are designed to capture individual images as character forms for imbedding in normal text.  While most often used to insert an isolated glyph in some text, the code is actually desinged to support an entire user-defined font.  The TextAttribute subclass TextFontReference is specifically designed for such in-line insertion of exceptional fonts in normal text.'!!FormSetFont methodsFor: 'as yet unclassified'!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type _ 2.	name _ 'aFormFont'.	minAscii _ asciiStart.	maxAscii _ minAscii + formArray size - 1.	ascent _ ascentVal.	subscript _ superscript _ emphasis _ 0.	height _ width _ 0.	maxWidth _ 0.	formArray do:		[:f | width _ width + f width.		maxWidth _ maxWidth max: f width.		height _ height max: f height + f offset y].	badChar _ (Form extent: 7@height) borderWidth: 1.	width _ width + badChar width.	descent _ height - ascent.	pointSize _ height.	glyphs _ Form extent: width @ height depth: formArray first depth.	xTable _ Array new: maxAscii + 3 withAll: 0.	x _ 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x _ x + f width)].	badChar displayOn: glyphs at: x@0.	xTable at: maxAscii + 3 put: x + badChar width.	self setStopConditions!reset  "Ignored by FormSetFonts"! !!FormSetFont class methodsFor: 'examples'!copy: charForm toClipBoardAs: char ascent: ascent	ParagraphEditor new clipboardTextPut:		(Text string: char asString			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: char asciiValue					ascent: ascent)))"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f _ TextStyle default fontAt: 4.	oldS _ f characterFormAt: $S.	charForm _ Form extent: oldS extent depth: 8.	oldS displayOn: charForm.	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.	...Then do a paste into the Welcome window"!example    "FormSetFont example"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm _ Form fromUser.	self copy: charForm toClipBoardAs: $A ascent: charForm height! !!FormView methodsFor: 'displaying'!displayOn: aPort	model displayOnPort: aPort at: self displayBox origin!displayView 	"Refer to the comment in View|displayView."	| oldOffset |	super displayView.	insideColor == nil ifFalse: [Display fill: self insetDisplayBox fillColor: insideColor].	oldOffset _ model offset.	model offset: borderWidth origin "0@0".	model		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor.	model offset: oldOffset!updateDisplay	"overridden by subclass"! !!FormView class methodsFor: 'examples'!open: aForm named: aString	"FormView open: (GIFReadWriter imageFromFileNamed: 'TylerCrop.GIF')named: 'Squeak' "	"Answer a scheduled view whose model is aForm and whose label isaString. 12/11/96 tk"	| topView aView |	topView _ ColorSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (0 @ 0 extent: aForm extent + (4@4)).		"compensate for borders.  Should be window:viewport:"	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !!Fraction methodsFor: 'arithmetic'!* aFraction	"Answer the result of multiplying the receiver by aFraction."	(aFraction isMemberOf: Fraction)		ifTrue: [^ (Fraction 					numerator: numerator * aFraction numerator					denominator: denominator * aFraction denominator)					reduced]		ifFalse: [^ self retry: #* coercing: aFraction]!+ aFraction	"Answer the sum of the receiver and aFraction."	| commonDenominator newNumerator |	(aFraction isMemberOf: Fraction)		ifTrue: 			[denominator = aFraction denominator ifTrue: [				^ (Fraction 					numerator: numerator + aFraction numerator					denominator: denominator) reduced].			commonDenominator _ denominator lcm: aFraction denominator.			newNumerator _				(numerator * (commonDenominator / denominator)) +				(aFraction numerator * (commonDenominator / aFraction denominator)).			^ (Fraction 				numerator: newNumerator 				denominator: commonDenominator) reduced]		ifFalse: [^ self retry: #+ coercing: aFraction]!- aFraction	"Answer the difference between the receiver and aFraction."	(aFraction isMemberOf: Fraction)		ifTrue: [^ self + aFraction negated]		ifFalse: [^ self retry: #- coercing: aFraction]!/ aFraction	"Answer the result of dividing the receiver by aFraction."	(aFraction isMemberOf: Fraction)		ifTrue: [^self * aFraction reciprocal]		ifFalse: [^self retry: #/ coercing: aFraction]!negated 	"Refer to the comment in Number|negated."	^ Fraction		numerator: numerator negated		denominator: denominator! !!Fraction methodsFor: 'printing'!printOn: aStream	aStream nextPut: $(.	numerator printOn: aStream.	aStream nextPut: $/.	denominator printOn: aStream.	aStream nextPut: $).! !!FrameRateMorph methodsFor: 'all'!initialize	super initialize.	lastDisplayTime _ 0.	framesSinceLastDisplay _ 0.!step	| now mSecs mSecsPerFrame framesPerSec |	framesSinceLastDisplay _ framesSinceLastDisplay + 1.	now _ Time millisecondClockValue.	mSecs _ now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: [		mSecsPerFrame _ mSecs // framesSinceLastDisplay.		framesPerSec _ (framesSinceLastDisplay * 1000) // mSecs.		self contents: mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frames/sec)'.		lastDisplayTime _ now.		framesSinceLastDisplay _ 0]!stepTime	"Answer the desired time between steps in milliseconds."	^ 1! !!GrafPort methodsFor: 'QuickDraw protocol'!boundingBox	^ destForm boundingBox!copyBits: box from: obj at: loc clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	destForm copyBits: box from: obj at: loc clippingBox: clipRectangle rule: ruleInteger fillColor: aForm!copyBits: box from: obj at: loc clippingBox: clipRectangle rule: ruleInteger fillColor: aForm map: map	destForm copyBits: box from: obj at: loc clippingBox: clipRectangle rule: ruleInteger fillColor: aForm map: map!depth	^ destForm depth!displayForm: aForm	colorMap _ nil.	self copy: (aForm boundingBox translateBy: location)		from: 0@0 in: aForm fillColor: nil rule: Form over!drawChar: char	^ self drawString: char asString!drawString: str	str asDisplayText displayOn: destForm			at: location - (0@(TextStyle default fontAt: 1) height)!eraseRect: rect	self copy: rect from: 0@0 in: nil fillColor: backgroundColor rule: Form over!fillOval: r color: c	^ self fillOval: r color: c borderWidth: 0 borderColor: nil!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| centerX radiusSquared xOverY dx fillTone wp borderTone w prevLeft left dxs centerY centerYBias maxy centerXBias |	"Tends to leave 1-pixel nipples at left and right edges.	Can probably fix by treating dy=0 same as dy=1"	r area <= 0 ifTrue: [^ self].	wp _ borderWidth asPoint.	sourceForm _ nil. 	height _ 1.	c == nil		ifTrue: [fillTone _ nil]		ifFalse: [self fillColor: c.  fillTone _ halftoneForm].	(((w _ wp x) * wp y) = 0 or: [borderColor == nil])		ifTrue: [borderTone _ nil]		ifFalse: [self fillColor: borderColor.  borderTone _ halftoneForm].	centerX _ r center x.	centerY _ r center y.	centerYBias _ r height odd ifTrue: [0] ifFalse: [1].	centerXBias _ r width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (r height asFloat / 2.0) squared - 0.01.	xOverY _ r width asFloat / r height asFloat.	maxy _ r height - 1 // 2.	dxs _ Array new: maxy + 1.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		dxs at: dy+1 put: dx.		fillTone == nil ifFalse:			[halftoneForm _ fillTone.			height _ 1.			width _ dx + dx + centerXBias + 1.			destX _ centerX - centerXBias - dx.			destY _ centerY - centerYBias - dy.			self copyBits.			destY _ centerY + dy.			self copyBits]].	"Now do the border, using the same x values"	borderTone ifNil: [^ self].	prevLeft _ centerX.	maxy to: 0 by: -1 do:		[:dy |		dx _ dxs at: dy+1.		halftoneForm _ borderTone.		height _ wp y.		left _ centerX - centerXBias - dx.		width _ prevLeft - left + w.		destX _ left.		destY _ centerY - centerYBias - dy.		self copyBits.		destX _ centerX + dx + 1 - width.		self copyBits.		destY _ centerY + dy - height + 1.		self copyBits.		destX _ left.		self copyBits.		prevLeft _ left]!fillRect: rect color: color	self copy: rect from: 0@0 in: nil		fillColor: color rule: Form over!fillRect: rect color: color rule: rule	self copy: rect from: 0@0 in: nil		fillColor: color rule: rule!fillRoundRect: rect oval: oval 	| centerX centerY radiusSquared xOverY radius dx w h r dWidth dHeight |	sourceForm _ nil.	width _ height _ 1.	w _ width.  h _ height.	r _ 0@0 extent: (oval min: rect extent).	dWidth _ rect width - r width.	dHeight _ rect height - r height.	centerX _ r center x + rect left.	centerY _ r center y + rect top.	radius _ r height // 2.	radiusSquared _ radius * radius.	xOverY _ r width asFloat / r height asFloat.	radius to: 0 by: -1 do: [: dy |		dx _ ((radiusSquared - (dy * dy)) sqrt * xOverY) rounded.		destX _ centerX - dx.		width _ dx + dx + dWidth.		destY _ centerY - dy.  self copyBits.		destY _ centerY + dy - h + dHeight.  self copyBits].	self destRect: (rect left@centerY extent: rect width@dHeight); copyBits.	width _ w.  height _ h.!font	font == nil ifTrue: [font _ TextStyle default fontAt: 1].	^ font!frameOval: r borderWidth: w borderColor: borderColor	^ self fillOval: r color: nil borderWidth: w borderColor: borderColor!frameRect: rect	| w h |	w _ width.  h _ height.	sourceForm _ nil.	(rect areasOutside: (rect insetBy: width@height)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].	width _ w.  height _ h.!frameRectBottom: rect	| w h |	w _ width.  h _ height.	sourceForm _ nil.	destX := rect left+1.	destY := rect bottom-1.	width := rect width-2.	height := 1.	1 to: h do: [:i |		self copyBits.		destX := destX+1.		destY := destY-1.		width := width-2].	width _ w.  height _ h.!frameRectLeft: rect	| w h |	w _ width.  h _ height.	sourceForm _ nil.	width := 1.	height := rect height.	destX := rect left.	destY := rect top.	1 to: w do: [:i |		self copyBits.		destX := destX+1.		destY := destY+1.		height := height-2].	width _ w.  height _ h.!frameRectRight: rect	| w h |	w _ width.  h _ height.	sourceForm _ nil.	width := 1.	height := rect height-1.	destX := rect right-1.	destY := rect top+1.	1 to: w do: [:i |		self copyBits.		destX := destX-1.		destY := destY+1.		height := height-2].	width _ w.  height _ h.!frameRectTop: rect	| w h |	w _ width.  h _ height.	sourceForm _ nil.	destX := rect left+1.	destY := rect top.	width := rect width-1.	height := 1.	1 to: h do: [:i |		self copyBits.		destX := destX+1.		destY := destY+1.		width := width-2].	width _ w.  height _ h.!frameRoundRect: rect oval: oval	| centerX centerY radiusSquared xOverY radius dx left right prevLeft w h r dWidth dHeight |	sourceForm _ nil.	w _ width.  h _ height.	r _ 0@0 extent: (oval min: rect extent).	dWidth _ rect width - r width.	dHeight _ rect height - r height.	centerX _ r center x + rect left.	centerY _ r center y + rect top.	radius _ r height // 2.	radiusSquared _ radius * radius.	xOverY _ r width asFloat / r height asFloat.	prevLeft _ centerX.	radius to: 0 by: -1 do: [: dy |		dx _ ((radiusSquared - (dy * dy)) sqrt * xOverY) rounded.		left _ centerX - dx.		right _ centerX + dx + dWidth.		width _ prevLeft - left + w.		destY _ centerY - dy.		destX _ left.  self copyBits.		destX _ right - width.  self copyBits.		destY _ centerY + dy - h + dHeight.		destX _ left.  self copyBits.		destX _ right - width.  self copyBits.		prevLeft _ left].	self destRect: (centerX@rect top extent: dWidth@h); copyBits.	self destRect: (centerX@(rect bottom-h) extent: dWidth@h); copyBits.	self destRect: (rect left@centerY extent: w@dHeight); copyBits.	self destRect: ((rect right-w)@centerY extent: w@dHeight); copyBits.	width _ w.  height _ h.!gpInit	backgroundColor _ Color white.	foregroundColor _ Color black.	transformation _ WindowingTransformation identity.	sourceX _ sourceY _ 0.	combinationRule _ Form over.	location _ 0@0.   "--- can't source origin do the job of location??"!line: dx dv: dy	self goto: location + (dx@dy)!lineTo: p	self goto: p!lineTo: x v: y	self goto: x@y!moveBy: delta	location _ location + delta!moveTo: p	location _ p!moveTo: x v: y	location _ x@y!penMode: m	combinationRule _ m!penNormal	self penSize: 1 height: 1!penPat: color	self fillColor: color!penSize: w height: h	width _ w.	height _ h!portRect	^ destForm boundingBox!textFace: ignoredForNow!textFont: ignoredForNow!textSize: ignoredForNow!transformation: t	transformation _ t!txMode: ignoredForNow!widthOfChar: char	^ self widthOfString: char asString!widthOfString: str	^ self font widthOfString: str! !!GrafPort class methodsFor: 'instance creation'!newOnForm: aForm	| port |	port _ self toForm: aForm.	^ port gpInit! !!GraphMorph methodsFor: 'initialization'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	pointerColor _ Color red.	pointer _ 1.0.  "may be fractional"	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing'!color: aColor	super color: aColor.	self flushCachedForm.!data	^ data!data: aCollection	data _ aCollection.	maxVal _ minVal _ 0.	data do: [:x |		x < minVal ifTrue: [minVal _ x].		x > maxVal ifTrue: [maxVal _ x]].	self flushCachedForm.!dataColor	^ dataColor!dataColor: aColor	dataColor _ aColor.	self flushCachedForm.!parts	"Return an array of part names for use in e-toys."	^ #(position pointer startIndex valueAtPointer)!pointer	^ pointer!pointer: aNumber	| truncP |	pointer ~= aNumber ifTrue:  [		pointer _ aNumber.		truncP _ aNumber truncated.		truncP > data size ifTrue: [pointer _ data size].		truncP < 0 ifTrue: [pointer _ 1].		self keepIndexInView: truncP.		self changed].!pointerAtEnd	^ pointer truncated >= data size!pointerColor	^ pointerColor!pointerColor: aColor	pointerColor _ aColor.	self flushCachedForm.!startIndex	^ startIndex!startIndex: aNumber	startIndex ~= aNumber ifTrue:  [		startIndex _ aNumber asInteger.		self flushCachedForm].!valueAtPointer	data isEmpty ifTrue: [^ 0].	^ data at: ((pointer truncated max: 1) min: data size)!valueAtPointer: aPointOrNumber	data isEmpty ifTrue: [^ 0].	^ data		at: ((pointer truncated max: 1) min: data size)		put: (self asNumber: aPointOrNumber).! !!GraphMorph methodsFor: 'drawing'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ FormCanvas extent: bounds extent.		self drawDataOn: (c copyOffset: bounds origin negated).		cachedForm _ c form].	aCanvas image: cachedForm at: bounds origin.	self drawPointerOn: aCanvas.!mouseDown: evt	evt shiftPressed		ifTrue: [evt hand newMouseFocus: self]		ifFalse: [super mouseDown: evt].!mouseMove: evt	self pointer: startIndex + evt cursorPoint x - (bounds left + borderWidth).! !!GraphMorph methodsFor: 'commands'!appendValue: aPointOrNumber	| newVal |	(data isKindOf: OrderedCollection) ifFalse: [data _ data asOrderedCollection].	newVal _ self asNumber: aPointOrNumber.	data addLast: newVal.	newVal < minVal ifTrue: [minVal _ newVal].	newVal > maxVal ifTrue: [maxVal _ newVal].	self pointer: data size.	self flushCachedForm.!clear	self startIndex: 1.	self pointer: 1.	self data: OrderedCollection new.!commandsWithDefaultArgs	"Return a list of (command arg1 arg2 ...) arrays where each command is followed by the default values for is parameters."	| r |	r _ OrderedCollection new.	r add: #(appendValue: 1000).	r add: #(processSamples).	r add: #(play).	r add: #(playOnce).	r add: #(playBach).	r add: #(clear).	r add: #(reverse).	"general parameter setting/updating"	r add: (Array with: #set: with: 20@20).	r add: #(incr: 15).	r add: #(decr: 15).	^ r!loadCoffeeCupClink	SampledSound useCoffeeCupClink.	self data: SampledSound defaultSampleTable.!play	| count |	count _ ((2 * SoundPlayer samplingRate) // data size) max: 1.	SampledSound defaultSamples: data repeated: count.	SampledSound nominalSamplePitch: 250.	Smalltalk garbageCollect.	(SampledSound pitch: 440.0 dur: 1.5 loudness: 500) play.!playBach	Smalltalk garbageCollect.	SampledSound bachFugue play.!playOnce	SampledSound defaultSamples: data repeated: 1.	SampledSound nominalSamplePitch: 250.	Smalltalk garbageCollect.	(SampledSound pitch: 440.0 dur: 1.5 loudness: 500) play.!processSamples	| w sel |	w _ self world.	self nameInModel ifNil: [^ self].	sel _ self processSamplesSelector.	(w model respondsTo: sel) ifFalse: [^ self].	self pointer: 1.	[self pointerAtEnd] whileFalse: [		w model perform: sel.		w runStepMethods.		w displayWorld].	w model perform: sel.  "final sample"!reverse	data _ data reversed.	self flushCachedForm.!stopPlaying	SoundPlayer stopPlayerProcess.! !!GraphMorph methodsFor: 'change reporting'!layoutChanged	super layoutChanged.	cachedForm _ nil.! !!GraphMorph methodsFor: 'script support'!acceptScript: aScriptEditorMorph for: ignored	lastAcceptedScript _ aScriptEditorMorph.	self world model class		compile: lastAcceptedScript methodString		classified: 'scripts'		notifying: nil.!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'read file' action: #readDataFromFile.	aCustomMenu add: 'script' action: #editScript:.!copy	^ super copy initScripts!editScript: evt	self nameInModel ifNil: [self choosePartNameSilently].	evt hand attachMorph:		(self scriptEditorFor: 'processSamples').!initScripts	"Used to remove the scripts from a newly made copy of myself."	lastAcceptedScript _ lastScriptEditor _ nil.!processSamplesSelector	^ (self nameInModel, 'ProcessSamples') asSymbol!readDataFromFile	| fileName |	fileName _ FillInTheBlank		request: 'File name?'		initialAnswer: ''.	fileName isEmpty ifTrue: [^ self].	(StandardFileStream isAFileNamed: fileName) ifFalse: [		^ self inform: 'Sorry, I cannot find that file'].	data _ (SampledSound readTrimmedSamplesFromAIFF: fileName).	self flushCachedForm.!scriptEditorFor: ignored	(lastScriptEditor ~= nil and: [lastScriptEditor isInWorld])		ifTrue: [^ lastScriptEditor].	lastAcceptedScript = nil ifTrue: [		^ lastScriptEditor _ ScriptEditorMorph new			setMorph: self			scriptName: 'ProcessSamples'.	] ifFalse: [		^ lastScriptEditor _ lastAcceptedScript fullCopy].! !!GraphMorph methodsFor: 'private'!drawDataOn: aCanvas	| yScale baseLine r x start end value |	super drawOn: aCanvas.	data isEmpty ifTrue: [^ self].	maxVal = minVal ifTrue: [		yScale _ 1.	] ifFalse: [		yScale _ (bounds height - (2 * borderWidth)) asFloat / (maxVal - minVal)].	baseLine _ bounds bottom - borderWidth + (minVal * yScale) truncated.	r _ 0@0 extent: 10@0.	x _ bounds left + borderWidth.	start _ (startIndex asInteger max: 1) min: data size.	end _ (start + bounds width) min: data size.	start to: end do: [:i |		r left: x truncated; right: x + 1.		r right > (bounds right - borderWidth) ifTrue: [^ self].		value _ (data at: i) asFloat.		value >= 0.0 ifTrue: [			r top: baseLine - (yScale * value) truncated.			r bottom: baseLine.		] ifFalse: [			r top: baseLine.			r bottom: baseLine - (yScale * value) truncated].		aCanvas fillRectangle: r color: dataColor.		x _ x + 1].!drawPointerOn: aCanvas	| ptr x r |	ptr _ (pointer asInteger max: 1) min: data size.	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		r left: x; right: x + 1.		aCanvas fillRectangle: r color: pointerColor].!flushCachedForm	cachedForm _ nil.	self changed.!keepIndexInView: index	| newStart |	index < startIndex ifTrue: [		newStart _ index - (bounds width - (2 * borderWidth)) + 1.		^ self startIndex: (newStart max: 1)].	index > (startIndex + bounds width - (2 * borderWidth)) ifTrue: [		^ self startIndex: (index min: data size)].!registerWaveform	"Store my data as the default sample table for SampledSound."	SampledSound defaultSampleTable: (data collect: [:x | x asInteger]).	SampledSound nominalSamplePitch: 153.! !!HandMorph methodsFor: 'initialization'!initialize	super initialize.	bounds _ 0@0 extent: Cursor normal extent.	eventSubscribers _ Set new.	keyboardFocus _ nil.	mouseFocus _ nil.	userInitials _ ''.	lastEvent _ MorphicEvent new.	eventTransform _ MorphicTransform identity.! !!HandMorph methodsFor: 'classification'!isHandMorph	^ true! !!HandMorph methodsFor: 'accessing'!targetOffset	"Return the offset of the last mouseDown location relative to the origin of the recipient morph. During menu interactions, this is the absolute location of the mouse down event that invoked the menu."	^ targetOffset!userInitials	^ userInitials!userInitials: aString	userInitials _ aString.	bounds _ bounds merge: (bounds right@4 extent: (userInitials asParagraph extent)).! !!HandMorph methodsFor: 'geometry'!fullBounds	"Extend my bounds by the shadow offset when carrying morphs."	| bnds |	bnds _ super fullBounds.	submorphs isEmpty		ifTrue: [^ bnds ]		ifFalse: [^ bnds topLeft corner: bnds  bottomRight + self shadowOffset].!invalidRect: damageRect	"Extend damage to cover drop-shadow when carrying morphs."	| r |	submorphs isEmpty		ifTrue: [r _ damageRect]		ifFalse: [r _ damageRect topLeft extent: damageRect extent + self shadowOffset].	super invalidRect: r.! !!HandMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw the hand itself (i.e., the cursor)."	aCanvas image: Cursor normal at: self position.	userInitials size > 0 ifTrue:		[aCanvas text: userInitials at: (self position + (16@4)) font: nil color: color].!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	| shadowCanvas |	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	submorphs reverseDo: [:m | m fullDrawOn: shadowCanvas].  "draw shadows"	submorphs reverseDo: [:m | m fullDrawOn: aCanvas].  "draw morphs in front of shadows"	self drawOn: aCanvas.  "draw the hand itself in front of morphs"!shadowOffset	^ 6@8! !!HandMorph methodsFor: 'event dispatching'!handleEvent: evt	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	eventSubscribers do: [:m | m handleEvent: evt].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		evt isMouseDown ifTrue: [^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue: [		keyboardFocus ifNotNil: [keyboardFocus keyStroke: evt].		^ self].!handleMouseDown: evt	| m |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	"otherwise, pass this event to a submorph below the hand"	m _ owner mouseRecipientAt: evt cursorPoint.	m ifNil: [m _ owner].  "no recipient; let the world handle it"	m ifNotNil: [		targetOffset _ evt cursorPoint - m position.		eventTransform _ m inputEventTransform.		m mouseDown: (self transformEvent: evt)].!handleMouseMove: evt	mouseFocus ifNotNil: [		mouseFocus mouseMove: (self transformEvent: evt)].!handleMouseUp: evt	mouseFocus = nil ifTrue: [^ self dropMorphsEvent: evt].  "drop morphs being carried, if any"	"ensure that at least one mouseMove: is reported for each mouse focus transaction:"	mouseFocus mouseMove: (self transformEvent: (evt copy setType: #mouseMove)).	mouseFocus mouseUp: (self transformEvent: evt).	mouseFocus _ nil.  "mouse focus transaction ends when mouse goes up"!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	keyboardFocus ifNotNil: [keyboardFocus keyboardFocusChange: false].	keyboardFocus _ aMorphOrNil.	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].!newMouseFocus: aMorphOrNil	"Make the given morph the new mouse focus."	mouseFocus _ aMorphOrNil.!processEvents	"Process user input events from the local input devices."	| origin evt |	origin _ owner viewBox topLeft.	evt _ MorphicEvent new		setMousePoint: Sensor cursorPoint - origin		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	(evt yellowButtonPressed and:	 [lastEvent yellowButtonPressed not]) ifTrue: [		lastEvent _ evt.		^ self invokeMetaMenu: evt].	self handleEvent: evt.	lastEvent _ evt.	Sensor keyboardPressed ifTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: Sensor cursorPoint - origin			buttons: Sensor primMouseButtons			hand: self.		self handleEvent: evt.		lastEvent _ evt].!transformEvent: evt	"Transform the given event by the transform recorded when the mouse went down."	^ evt transformedBy: eventTransform! !!HandMorph methodsFor: 'grabbing/dropping'!attachMorph: m	"Position the center of the given morph under this hand, then grab it. This method is used to grab far away or newly created morphs."	m position: self position - (m fullBounds extent // 2).	self grabMorph: m.!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drop drops into the world."	| targetM |	owner ifNil: [^ self].  "there is no world to drop the morphs into"	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		targetM _ self dropTargetFor: m event: evt.		targetM acceptDroppingMorph: m event: evt.		m justDroppedInto: targetM event: evt.		m owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto. Return the world, if no other morph wants the dropping morph."	| root |	"find front-most composite morph"	root _ nil.	owner submorphsDo: [:m |		(m fullContainsPoint: evt cursorPoint) ifTrue: [root _ m]].	root == nil ifTrue: [^ self world].	(root morphsAt: evt cursorPoint) reverseDo: [:m |		(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ self world!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	self addMorphBack: m.! !!HandMorph methodsFor: 'event reporting'!startReportingEventsTo: subscriber	"Start reporting events to the given object. All input events are reported to every event subscriber, in addition to being sent to the current mouse/keyboard focus morph. This allows one to build things like macro recorders, eyes that follow the mouse, etc."	(eventSubscribers includes: subscriber) ifFalse: [eventSubscribers add: subscriber].!stopReportingEventsTo: subscriber	"Stop reporting events to the given object."	eventSubscribers remove: subscriber ifAbsent: [].! !!HandMorph methodsFor: 'meta menu'!argumentOrNil	"Answer the root of the front-most morph under the cursor. If the cursor is not over any morph, answer nil."	owner submorphsDo:		[:m | (m fullContainsPoint: targetOffset) ifTrue: [^ m]].	^ nil!browseMorphClass	| m mClass newBrowser view |	m _ self chooseTarget.	m ifNil: [^ self].	mClass _ m class.	"Use following for a simple browser:	Browser newOnClass: mClass."	newBrowser _ HierarchyBrowser new		initHierarchyForClass: mClass		meta: false.	view _ BrowserView systemCategoryBrowser: newBrowser editString: nil.	Browser postOpenSuggestion: (Array with: mClass with: nil).	BrowserView openBrowserView: view		label: mClass name, ' hierarchy'!buildMetaMenu	"Build the meta menu. This menu has two sections. The first section contains commands that are interpreted by the hand itself; the second contains commands provided by the morph itself. Each entry contains a string to be presented in the menu and a symbol to be sent to either the hand itself (for commands in the first section) or to the morph provided the menu (for commands in the second section). If a selector takes an argument, the mouse-down event that invoked the menu is provided. This lets the command know which hand invoked it in  order to do things like attaching the result of the command to that hand."	| menu arg |	menu _ CustomMenu new.	arg _ self argumentOrNil.	arg == nil ifTrue: [		menu add: 'new morph' action: #newMorph.		menu add: 'new parts bin' action: #newPartsBin.		menu add: 'new drawing' action: #makeNewDrawing.		menu add: 'change background color' action: #changeBackgroundColor.		menu addLine.		menu add: 'parts bin' action: #partsBin.		menu add: 'run all' action: #startRunningAll.		menu add: 'stop all' action: #stopRunningAll.		menu addLine.		menu add: ' add control variable ' action: #newVariable.		menu add: ' save as model ' action: #saveAsModel.		menu add: 'save as world' action: #saveAsWorld.		menu addLine.		menu add: 'inspect this world' action: #inspectWorld.		lastMetaMenuItem _ menu selections size.		^ menu].	menu add: 'grab' action: #grabMorph.	menu add: 'dismiss' action: #dismissMorph.	menu add: 'go behind' action: #goBehind.	menu add: 'duplicate' action: #duplicateMorph.	((self world rootMorphsAt: targetOffset) size > 1)		ifTrue: [menu add: 'embed' action: #embedMorph].	menu add: 'grab or extract' action: #extractMorph.	menu add: 'inspect' action: #inspectMorph.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	arg isMouseSensor		ifTrue: [menu add: ' desensitize ' action: #desensitizeMorph]		ifFalse: [menu add: ' sensitize ' action: #sensitizeMorph].	arg nameInModel ifNil: [		menu add: 'name me' action: #nameMorph].	menu addLine.	(arg isKindOf: SketchMorph)  ifFalse: [		(arg isKindOf: StringMorph) ifFalse: [			menu add: 'resize' action: #resizeMorph.		].		menu add: 'fill color' action: #changeColor.	].	menu addLine.	lastMetaMenuItem _ menu selections size.	arg addCustomMenuItems: menu hand: self.	^ menu!changeBackgroundColor	| newColor |	newColor _ self chooseColor.	newColor ifNotNil: [owner color: newColor].!changeColor	self argumentOrNil color: self chooseColor.!chooseTarget	| root |	root _ self argumentOrNil.	root == nil ifTrue: [^ nil].	^ self chooseTargetSubmorphOf: root!chooseTargetSubmorphOf: root	| possibleTargets menu |	possibleTargets _ root morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ possibleTargets first].	menu _ CustomMenu new.	possibleTargets do: [:m | menu add: m printString action: m].	^ menu startUp!desensitizeMorph	| m |	m _ self argumentOrNil.	m ifNotNil: [		self position: targetOffset.		self grabMorph: m].!dismissMorph	self argumentOrNil delete.!drawingClass	^ ActorMorph!duplicateMorph	self grabMorph: self argumentOrNil fullCopy.!embedMorph	| rootMorphs morphToEmbed targetRoot targetMorph |	rootMorphs _ self world rootMorphsAt: targetOffset.	rootMorphs size < 2 ifTrue: [^ self].	morphToEmbed _ rootMorphs at: 1.	targetRoot _ rootMorphs at: 2.	targetMorph _ self chooseTargetSubmorphOf: targetRoot.	targetMorph ifNotNil: [		targetMorph addMorphFront: morphToEmbed.		targetMorph changed].!extractMorph	| m |	m _ self chooseTarget.	m ifNotNil: [		self position: targetOffset.		self grabMorph: m].!goBehind	owner addMorphBack: self argumentOrNil.!grabMorph	self grabMorph: self argumentOrNil.!inspectMorph	| m |	m _ self chooseTarget.	m ifNotNil: [m inspect].!inspectWorld	owner inspect.!invokeMetaMenu: evt	| menu item caption |	targetOffset _ self position.	menu _ self buildMetaMenu.	self argumentOrNil == nil		ifTrue: [caption _ 'World']		ifFalse: [caption _ self argumentOrNil class name].	Cursor normal showWhile: [		item _ menu startUp: lastMenuSelection withCaption: caption.		item ifNotNil: [			lastMenuSelection _ item.			(menu selections indexOf: item) <= lastMetaMenuItem ifTrue: [				item isKeyword					ifTrue: [self perform: item with: evt]					ifFalse: [self perform: item].			] ifFalse: [				item isKeyword					ifTrue: [self argumentOrNil perform: item with: evt]					ifFalse: [self argumentOrNil perform: item]]]].!makeNewDrawing	| formAndBounds m |	Cursor normal showWhile: [		"formAndBounds is array of (maskedForm, boundingRectangle) or nil"		formAndBounds _ MPaintWindow getPaintingInRectangle: owner viewBox].	formAndBounds ifNil: [^ self].	m _ self drawingClass new form: (formAndBounds at: 1).	m position: (formAndBounds at: 2) origin.	owner fullRepaintNeeded.	owner addMorph: m.!nameMorph	self argumentOrNil choosePartName.!newMorph	| morphClassList menu morphClass m |	menu _ CustomMenu new.	morphClassList _ Morph withAllSubclasses asSortedCollection:		[:m1 :m2 | m1 class name < m2 class name].	morphClassList remove: WorldMorph;			remove: HandMorph;			remove: MorphicModel;			remove: RemoteHandMorph.	morphClassList do:			[:c | ((c inheritsFrom: MorphicModel) not or:								["Only include Models that have been saved"								c includesSelector: #initMorph]) 					ifTrue: [menu add: c name action: c]].	(morphClass _ menu startUp) ifNil: [^ self].	m _ morphClass new.	m installModelIn: owner.  "A chance to install model pointers"	self attachMorph: m.	owner startSteppingSubmorphsOf: m!newPartsBin	| binName |	binName _ FillInTheBlank		request: 'Parts bin name?'		initialAnswer: ''.	binName = '' ifTrue: [^ self].	self attachMorph: (PartsBinMorph named: binName).!newVariable	| partName |	partName _ owner model addPartNameLike: 'part' withValue: nil.	partName ifNil: [^ self].  "user chose bad part name"	owner model class compileAccessorsFor: partName!partsBin	| binNames menu binName |	binNames _ PartsBinMorph binNames.	binNames isEmpty ifTrue: [^ self].  "no parts bins"	menu _ CustomMenu new.	binNames do: [:n | menu add: n action: n].	(binName _ menu startUp) ifNil: [^ self].	self attachMorph: (PartsBinMorph named: binName).!resizeMorph	| m minExtent p |	m _ self argumentOrNil.	m isLayoutMorph		ifTrue: [minExtent _ m minWidth@m minHeight]		ifFalse: [minExtent _ 1@1].	[Sensor anyButtonPressed] whileFalse: [		p _ self position.		m extent: ((p - m position) max: minExtent).		owner doOneCycle].	Sensor waitNoButton.!rootMorphsAt: aPoint	| mList |	mList _ OrderedCollection new.	owner submorphsDo:		[:m | (m fullContainsPoint: aPoint) ifTrue: [mList addLast: m]].	^ mList!saveAsModel	owner saveAsModel!saveAsWorld	owner saveAsWorld!sensitizeMorph	| m |	m _ self chooseTarget.	m ifNotNil: [m sensitize].!startRunningAll	self world submorphsDo: [:m |		(m isKindOf: ActorMorph) ifTrue: [m startRunning]].!stopRunningAll	self world submorphsDo: [:m |		(m isKindOf: ActorMorph) ifTrue: [m stopRunning; goHome]].!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| m oldClass newClassName newClass newMorph |	m _ self argumentOrNil.	oldClass _ m class.	newClassName _ FillInTheBlank		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass _ oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	newMorph _ m as: newClass.	m become: newMorph.! !!HandMorph methodsFor: 'remote hand support'!stopListening	"For compatibility with RemoteHandMorph; does nothing here."! !!HeadingMorph methodsFor: 'as yet unclassified'!degrees	^ (degrees + 90.0) \\ 360.0!degrees: aNumber	degrees _ (aNumber asFloat + 270.0) \\ 360.0.!drawArrowFrom: p1 to: p2 width: w color: aColor on: aCanvas	| d p |	d _ (p1 - p2) theta radiansToDegrees.	aCanvas line: p1 to: p2 width: w color: aColor.	p _ p2 + (Point r: 5 degrees: d - 50).	aCanvas line: p to: p2 width: w color: aColor.	p _ p2 + (Point r: 5 degrees: d + 50).	aCanvas line: p to: p2 width: w color: aColor.!extent: extent	| d |	d _ extent x min: extent y.	super extent: d@d.!initialize	super initialize.	self color: (Color r:0.6 g: 1.0 b: 1.0).	degrees _ 90.0.	magnitude _ 1.0.	self borderWidth: 1.	self extent: 160@160.!magnitude	^ magnitude!magnitude: aNumber	magnitude _ (aNumber asFloat max: 0.0) min: 1.0.!mouseDown: evt	evt hand newMouseFocus: self.!mouseMove: evt	| v |	self changed.	v _ evt cursorPoint - bounds center.	degrees _ v theta radiansToDegrees.	magnitude _ (v r asFloat / (bounds width asFloat / 2.0)) min: 1.0.! !!HeadingMorph methodsFor: 'drawing'!drawOn: aCanvas	| x y r center box |	super drawOn: aCanvas.	box := self innerBounds.	1 to: 9 do: [:i |		x _ box left + ((box width * i) // 10).		aCanvas line: (x@box top) to: (x@(box bottom - 1)) color: Color black.		y _ box top + ((box height * i) // 10).		aCanvas line: (box left@y) to: ((box right - 1)@y) color: Color black].	r _ ((box width asFloat * magnitude asFloat) / 2.0) - 1.0.	center _ box center.	self drawArrowFrom: center - (1@1)		to: center + ((r * degrees degreesToRadians cos)@0) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (0@(r * degrees degreesToRadians sin)) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (Point r: r degrees: degrees) - (1@1)		width: 3		color: Color black		on: aCanvas.! !!HeaterCoolerMorph methodsFor: 'all'!atomsTouchingMeDo: aBlock	"Collect those of my siblings that are atoms and overlap my bounds."	| r |	r _ self fullBounds.	owner submorphsDo: [ :m |		((m fullBounds intersects: r) and: [m isMemberOf: AtomMorph])			ifTrue: [aBlock value: m]].!initialize	super initialize.	self extent: 50@30.	self velocityDelta: 3.!step	| v r theta newR |	self atomsTouchingMeDo: [ :m |		v _ m velocity.		r _ v r.		theta _ v theta.		newR _ ((r + velocityDelta) max: 3.0).		m velocity: (newR * theta cos) asInteger @ (newR * theta sin) asInteger].!stepTime	^ 0!velocityDelta: delta	"Make color reflect the sign of the velocity delta."	"Note: Since velocity vectors get truncated to integers, small velocity deltas may haveno effect. Delta magnitudes between 2 and 10 work nicely."	velocityDelta _ delta asFloat.	delta > 0.0		ifTrue: [self color: (Color red: 0.8 green: 0 blue: 0.2)]		ifFalse: [self color: (Color red: 0.2 green: 0.6 blue: 0.2)].! !HierarchicalMenu comment:'Created by Dan Ingalls back in 1985-6, but not currently maintained or used.'!!HierarchicalMenu class methodsFor: 'instance creation'!labelList: labelList lines: lines selections: selections	| topLabels topSelections deeperMenus item |	topLabels _ OrderedCollection new.	topSelections _ OrderedCollection new.	deeperMenus _ OrderedCollection new.	1 to: labelList size do:		[:i | item _ labelList at: i.		(item isMemberOf: Array)			ifTrue: [topLabels addLast: item first.					deeperMenus addLast:					(HierarchicalMenu labelList: item allButFirst									selections: (selections at: i))]			ifFalse: [topLabels addLast: item.					deeperMenus addLast: nil].				topSelections addLast: (selections at: i)].	^ (super labelList: topLabels asArray lines: lines selections: topSelections asArray)		deeperMenus: deeperMenus asArray! !!HierarchyBrowser methodsFor: 'initialization'!classList	^ classList!classListIndex: newIndex	"Cause system organization to reflect appropriate category"	| newClassName |	newIndex ~= 0 ifTrue:		[newClassName _ (classList at: newIndex) copyWithout: $ .		systemCategoryListIndex _			systemOrganizer numberOfCategoryOfElement: newClassName.		self changed: #systemCategorySelectionChanged].	^ super classListIndex: newIndex!initAlphabeticListing	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ Smalltalk classNames.!initForClassList: classNames	"Initialize the receiver for use with the provided list of class names.   11/27/96 sw"	self systemOrganizer: SystemOrganization.	metaClassIndicated _ false.	classList _ classNames!initHierarchyForClass: theClass meta: meta	| tab stab index |	self systemOrganizer: SystemOrganization.	metaClassIndicated _ meta.	classList _ OrderedCollection new.	tab _ ''.	theClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab _ tab , '  '].	index _ classList size + 1.	theClass allSubclassesWithLevelDo:		[:aClass :level |		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index!selectClass: classNotMeta	| name |	name _ classNotMeta name.	self classListIndex: (self classList findFirst:			[:each | (each endsWith: name)					and: [each size = name size							or: [(each at: each size - name size) isSeparator]]])!selectedClassName	"Answer the name of the class currently selected.   di	 12/4/96 sw bug fix for the case where name cannot be found -- return nil rather than halt"	| aName |	aName _ super selectedClassName.	^ aName == nil		ifTrue:			[aName]		ifFalse:			[(aName copyWithout: $ ) asSymbol]! !!IdentityDictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element key == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!IdentitySet methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!ImageMorph methodsFor: 'all'!drawOn: aCanvas	aCanvas image: image at: bounds origin!extent	^image extent!extent: aPoint	super extent: image extent!image: anImage	image := anImage.	self extent: anImage extent! !!InfiniteForm methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm class == Pattern) ifTrue:			["Use patternForm as a mask for BitBlt"			aDisplayMedium fill: clipRectangle 				rule: ruleInteger fillColor: patternForm.			^ self].	(patternForm isKindOf: Form) ifFalse:			["A Color-like thing.  Use patternForm as a mask for BitBlt"			aDisplayMedium fill: clipRectangle 				rule: ruleInteger fillColor: patternForm.			^ self].	"Do it iteratively"	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.	patternBox _ patternForm boundingBox.	bb _ BitBlt destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	patternForm depth = aDisplayMedium depth ifFalse:		[bb colorMap: (Color defaultColorMapFrom: patternForm depth							to: aDisplayMedium depth)].	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]!displayOnPort: aPort at: aDisplayPoint	| targetBox patternBox saveMap |	(patternForm class == Pattern) ifTrue:			["Use patternForm as a mask for BitBlt"			aPort fill: aPort clipRect fillColor: patternForm rule: Form over.			^ self].	(patternForm isKindOf: Form) ifFalse:			["A Color-like thing.  Use patternForm as a mask for BitBlt"			aPort fill: aPort clipRect fillColor: patternForm rule: Form over.			^ self].	"Do it iteratively"	targetBox _ aPort clipRect.	patternBox _ patternForm boundingBox.	aPort sourceForm: patternForm;		combinationRule: Form over;		sourceRect: (0@0 extent: patternBox extent).	saveMap _ aPort colorMap.	patternForm depth = aPort destForm depth ifFalse:		[aPort colorMap: (Color defaultColorMapFrom: patternForm depth							to: aPort destForm depth)].	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			aPort destOrigin: x@y; copyBits]].	aPort colorMap: saveMap! !!InputSensor methodsFor: 'joystick'!joystickOn: index	^ (((self primReadJoystick: index) bitShift: -27) bitAnd: 1) ~= 0	! !!InputSensor methodsFor: 'user interrupts'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Smalltalk shutDownSound.		[ScheduledControllers interruptName: 'User Interrupt'] fork.	].! !!InspectListController methodsFor: 'menu messages'!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  9/27/96 sw"	model selectionIndex == 0 ifTrue: [^ view flash].	self controlTerminate.	Smalltalk		browseAllObjectReferencesTo: model selection		except: (Array with: model object)		ifNone: [:obj | view topView flash].! !!InspectListController class methodsFor: 'class initialization'!initialize	"Initialize the menu associated with the upper-left pane of an Inspector.  1/25/96 sw: added references and browse items	 9/27/96 sw: added object refs"	InspectListYellowButtonMenu _ PopUpMenu labels: 'inspectmethod refs to this inst varobjects pointing to this valuebrowse fullbrowse class'	lines: #(1 3).	InspectListYellowButtonMessages _ 		#(inspectSelection referencesToSelection objectReferencesToSelection browseFull browseClass )	"InspectListController initialize"! !!Inspector methodsFor: 'accessing'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  5/22/96 sw"	^ 250 @ 200! !!Inspector class methodsFor: 'instance creation'!openOn: anObject withEvalPane: withEval 	"Create and schedule an instance of me on the model, anInspector. "	^ self openOn: anObject withEvalPane: withEval withLabel: anObject defaultLabelForInspector!openOn: anObject withEvalPane: withEval withLabel: label	^ self openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: InspectCodeView!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	listView _ InspectListView new model: inspector.		(inspector isMemberOf: DictionaryInspector)			ifTrue: [listView controller: DictionaryListController new].		listView window: (0 @ 0 extent: 40 @ 40).		listView borderWidthLeft: 2 right: 0 top: 2 bottom: 2.		topView addSubView: listView.	valueView _ valueViewClass new model: inspector.		valueView window: (0 @ 0 extent: 75 @ 40).		valueView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.		topView addSubView: valueView toRightOf: listView.withEval ifTrue:	[evalView _ StringHolderView new					model: (InspectorTrash for: inspector object).		evalView window: (0 @ 0 extent: 115 @ 20).		evalView borderWidthLeft: 2 right: 2 top: 0 bottom: 2.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!InstructionStream methodsFor: 'scanning'!addSelectorTo: set 	"If this instruction is a send, add its selector to set."	| byte literalNumber byte2 |	byte _ self method at: pc.	byte < 128 ifTrue: [^self].	byte >= 176		ifTrue: 			["special byte or short send"			byte >= 208				ifTrue: [set add: (self method literalAt: (byte bitAnd: 15) + 1)]				ifFalse: [set add: (Smalltalk specialSelectorAt: byte - 176 + 1)]]		ifFalse: 			[(byte between: 131 and: 134)				ifTrue: 					[byte2 _ self method at: pc + 1.					byte = 131 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 132 ifTrue: [byte2 < 64 ifTrue: [set add: (self method literalAt: (self method at: pc + 2) + 1)]].					byte = 133 ifTrue: [set add: (self method literalAt: byte2 \\ 32 + 1)].					byte = 134 ifTrue: [set add: (self method literalAt: byte2 \\ 64 + 1)]]]!scanFor: scanBlock 	"Answer the index of the first bytecode for which scanBlock answer true 	when supplied with that bytecode."	| method end byte type |	method _ self method.	end _ method endPC.	[pc <= end]		whileTrue: 			[(scanBlock value: (byte _ method at: pc)) ifTrue: [^true].			type _ byte // 16.			pc _ 				type = 8					ifTrue: ["extensions"							pc + (#(2 2 2 2 3 2 2 1 1 1 ) at: byte \\ 16 + 1)]					ifFalse: [type = 10								ifTrue: [pc + 2"long jumps"]								ifFalse: [pc + 1]]].	^false!thirdByte	"Answer the next bytecode."	^self method at: pc + 2! !!InstructionStream methodsFor: 'private'!interpretExtension: offset in: method for: client	| type offset2 byte2 byte3 |	offset <=6 ifTrue: 		["Extended op codes 128-134"		byte2 _ method at: pc.		pc _ pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type _ byte2 // 64.			offset2 _ byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^ client pushReceiverVariable: offset2].				type = 1 ifTrue: [^ client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^ client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^ client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^ client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^ client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^ client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^ client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 _ method at: pc.  pc _ pc + 1.			type _ byte2 // 32.			type = 0 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^ client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^ client pushReceiverVariable: byte3].			type = 3 ifTrue: [^ client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^ client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^ client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^ client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^ client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^ client send: (method literalAt: byte2 \\ 32 + 1)					super: true numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^ client send: (method literalAt: byte2 \\ 64 + 1)					super: false numArgs: byte2 // 64]].	offset = 7 ifTrue: [^ client doPop].	offset = 8 ifTrue: [^ client doDup].	offset = 9 ifTrue: [^ client pushActiveContext].	self error: 'unusedBytecode'! !!Integer methodsFor: 'testing'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t | t _ Time millisecondsToRun: [r _ 26 benchFib].			r//t*1000 "	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size _ 8190.    1 to: self do:        [:iter |        count _ 0.        flags _ (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime _ i+1.                k _ i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k _ k + prime].                count _ count + 1]]].    ^ count! !!Integer methodsFor: 'mathematical functions'!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."	^ (90 + self) degreeSin!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."	^ self asFloat degreesToRadians sin! !!Integer methodsFor: 'private'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _		 dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ 					j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ 				a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l put: (lo bitAnd: 255).			a _ (lo bitShift: -8) - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem!digitLogic: arg op: op length: len	| result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 _ self negative.	neg2 _ arg negative.	rneg _ 		((neg1 ifTrue: [-1] ifFalse: [0])			perform: op 			with: (neg2					ifTrue: [-1]					ifFalse: [0])) < 0.	result _ Integer new: len neg: rneg.	rz _ z1 _ z2 _ true.	1 to: result digitLength do: 		[:i | 		b1 _ self digitAt: i.		neg1 			ifTrue: [b1 _ z1						ifTrue: [b1 = 0									ifTrue: [0]									ifFalse: 										[z1 _ false.										256 - b1]]						ifFalse: [255 - b1]].		b2 _ arg digitAt: i.		neg2 			ifTrue: [b2 _ z2						ifTrue: [b2 = 0									ifTrue: [0]									ifFalse: 										[z2 _ false.										256 - b2]]						ifFalse: [255 - b2]].		b _ b1 perform: op with: b2.		b = 0			ifTrue: 				[result digitAt: i put: 0]			ifFalse: 				[result 					digitAt: i 					put: (rneg							ifTrue: [rz ifTrue: 											[rz _ false.											256 - b]										ifFalse: [255 - b]]						ifFalse: [b])]].	^ result normalize!digitMultiply: arg neg: ng	| prod prodLen carry digit k ab |	(arg digitLength = 1 and: [(arg digitAt: 1) = 0]) ifTrue: [^ 0].	prodLen _ self digitLength + arg digitLength.	prod _ Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: 		[:i | 		(digit _ self digitAt: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab _ ((arg digitAt: j) * digit) + carry							+ (prod digitAt: k).					carry _ ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k _ k + 1].				prod digitAt: k put: carry]].	^ prod normalize!digitRshift: anInteger bytes: b lookfirst: a 	 "Shift right 8*b+anInteger bits, 0<=n<8.	Discard all digits beyond a, and all zeroes at or below a."	| n x r f m digit count i |	n _ 0 - anInteger.	x _ 0.	f _ n + 8.	i _ a.	m _ 255 bitShift: 0 - f.	digit _ self digitAt: i.	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:		[x _ digit bitShift: f "Can't exceed 8 bits".		i _ i - 1.		digit _ self digitAt: i].	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"	r _ Integer new: i - b neg: self negative.	count _ i.	x _ (self digitAt: b + 1) bitShift: n.	b + 1 to: count do:		[:j | digit _ self digitAt: j + 1.		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 			"Avoid values > 8 bits".		x _ digit bitShift: n].	^r! !Interpreter comment:'This class is a complete implementation of the Smalltalk-80 virtual machine, derived originally from the Blue Book specification.It has been modernized with 32-bit pointers, better management of Contexts, and attention to variable use that allows the CCodeGenerator (qv) to keep, eg, the instruction pointer and stack pointer in registers.In addition to SmallInteger arithmetic and Floats, it supports logic on 32-bit PositiveLargeIntegers, thus allowing it to simulate itself much more effectively than would otherwise be the case.'!!Interpreter methodsFor: 'initialization'!initializeInterpreter: bytesToShift	"Initialize Interpreter state before starting execution of a new image."	self initializeObjectMemory: bytesToShift.	activeContext	_ nilObj.	theHomeContext	_ nilObj.	method			_ nilObj.	receiver		_ nilObj.	messageSelector	_ nilObj.	newMethod		_ nilObj.	self flushMethodCache.	self loadInitialContext.	interruptCheckCounter _ 0.	nextPollTick _ 0.	nextWakeupTick _ 0.	interruptKeycode _ 2094.  "cmd-."	interruptPending _ false.!loadInitialContext	| sched proc |	sched _ self fetchPointer: ValueIndex ofObject: (self splObj: SchedulerAssociation).	proc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	activeContext _ self fetchPointer: SuspendedContextIndex ofObject: proc.	(activeContext < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	self fetchContextRegisters: activeContext.	reclaimableContextCount _ 0.! !!Interpreter methodsFor: 'utilities'!areIntegers: oop1 and: oop2	^ ((oop1 bitAnd: oop2) bitAnd: 1) ~= 0!arrayValueOf: arrayOop	"Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	self returnTypeC: 'void *'.	((self isIntegerObject: arrayOop) not and:	 [self isWordsOrBytes: arrayOop]) ifTrue: [		^ self cCode: '(void *) (arrayOop + 4)'	].	self primitiveFail.!assertClassOf: oop is: classOop	"Succeed if the given (non-integer) object is an instance of the given class. Fail if the object is an integer."	| ccIndex cl |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ successFlag _ false. ^ nil ].	ccIndex _ ((self baseHeader: oop) >> 12) bitAnd: 16r1F.	ccIndex = 0		ifTrue: [ cl _ ((self classHeader: oop) bitAnd: AllButTypeMask) ]		ifFalse: [			"look up compact class"			cl _ (self fetchPointer: (ccIndex - 1)					ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop))].	self success: cl = classOop.!assertFloat: oop1 and: oop2	"Fail unless both arguments are floats."	| floatClass |	((oop1 bitOr: oop2) bitAnd: 1) ~= 0 ifTrue: [		successFlag _ false.	] ifFalse: [		floatClass _ self splObj: ClassFloat.		self assertClassOf: oop1 is: floatClass.		self assertClassOf: oop2 is: floatClass.	].!booleanCheat: cond	| bytecode offset |	self inline: true.	bytecode _ self fetchByte.  "assume next bytecode is jumpIfFalse (99%)"	self internalPop: 2.	(bytecode < 160 and: [bytecode > 151]) ifTrue: [  "short jumpIfFalse"		cond			ifTrue: [^ nil]			ifFalse: [^ self jump: bytecode - 151]].	bytecode = 172 ifTrue: [  "long jumpIfFalse"		offset _ self fetchByte.		cond			ifTrue: [^ nil]			ifFalse: [^ self jump: offset]].	"not followed by a jumpIfFalse; undo instruction fetch and push boolean result"	localIP _ localIP - 1.	cond		ifTrue: [self internalPush: trueObj]		ifFalse: [self internalPush: falseObj].!booleanValueOf: obj	obj = trueObj ifTrue: [ ^ true ].	obj = falseObj ifTrue: [ ^ false ].	successFlag _ false.	^ nil!checkedIntegerValueOf: intOop	"Note: May be called by translated primitive code."	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]!externalizeIPandSP	"Copy the local instruction and stack pointer to global variables for use in primitives and other functions outside the interpret loop."	instructionPointer _ self cCoerce: localIP to: 'int'.	stackPointer _ self cCoerce: localSP to: 'int'.!fetchArray: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the address of first indexable field of resulting array object, or fail if the instance variable does not contain an indexable bytes or words object."	"Note: May be called by translated primitive code."	| arrayOop |	self returnTypeC: 'void *'.	arrayOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self arrayValueOf: arrayOop!fetchFloat: fieldIndex ofObject: objectPointer	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| floatOop |	self returnTypeC: 'double'.	floatOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	^ self floatValueOf: floatOop!fetchInteger: fieldIndex ofObject: objectPointer	"Note: May be called by translated primitive code."	| intOop |	self inline: false.	intOop _ self fetchPointer: fieldIndex ofObject: objectPointer.	(self isIntegerObject: intOop)		ifTrue: [ ^ self integerValueOf: intOop ]		ifFalse: [ self primitiveFail. ^ 0 ]!floatValueOf: oop	"Fetch the instance variable at the given index of the given object. Return the C double precision floating point value of that instance variable, or fail if it is not a Float."	"Note: May be called by translated primitive code."	| result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	self assertClassOf: oop is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: oop + BaseHeaderSize into: result]		ifFalse: [result _ 0.0].	^ result!internalizeIPandSP	"Copy the local instruction and stack pointer to local variables for rapid access within the interpret loop."	localIP _ self cCoerce: instructionPointer to: 'char *'.	localSP _ self cCoerce: stackPointer to: 'char *'.!makePointwithxValue: xValue yValue: yValue	| pointResult |	pointResult _ self instantiateSmallClass: (self splObj: ClassPoint)							   sizeInBytes: 12									   fill: nilObj.	self storePointer: XIndex ofObject: pointResult withValue: (self integerObjectOf: xValue).	self storePointer: YIndex ofObject: pointResult withValue: (self integerObjectOf: yValue).	^ pointResult!quickFetchInteger: fieldIndex ofObject: objectPointer	"Return the integer value of the field without verifying that it is an integer value!! For use in time-critical places where the integer-ness of the field can be guaranteed."	^ self integerValueOf:		(self fetchPointer: fieldIndex ofObject: objectPointer).!signExtend16: int16	"Convert a signed 16-bit integer into a signed 32-bit integer value. The integer bit is not added here."	(int16 bitAnd: 16r8000) = 0		ifTrue: [ ^ int16 ]		ifFalse: [ ^ int16 - 16r10000 ].!storeInteger: fieldIndex ofObject: objectPointer withValue: integerValue	"Note: May be called by translated primitive code."	(self isIntegerValue: integerValue) ifTrue: [		self storeWord: fieldIndex			ofObject: objectPointer			withValue: (self integerObjectOf: integerValue).	] ifFalse: [		self primitiveFail	].!transfer: count	fromIndex: firstFrom ofObject: fromOop	toIndex: firstTo ofObject: toOop	"Assume: beRootIfOld: will be called on toOop."	| fromIndex toIndex lastFrom |	self inline: true.	fromIndex _ fromOop + (firstFrom * 4).	toIndex _ toOop + (firstTo * 4).	lastFrom _ fromIndex + (count * 4).	[fromIndex < lastFrom] whileTrue: [		fromIndex _ fromIndex + 4.		toIndex _ toIndex + 4.		self longAt: toIndex put: (self longAt: fromIndex).	].! !!Interpreter methodsFor: 'object memory support'!mapInterpreterOops	"Map all oops in the interpreter's state to their new values during garbage collection or a become: operation."	"Assume: All traced variables contain valid oops."	| oop |	nilObj				_ self remap: nilObj.	falseObj				_ self remap: falseObj.	trueObj				_ self remap: trueObj.	specialObjectsOop	_ self remap: specialObjectsOop.	stackPointer 		_ stackPointer - activeContext.	"*rel to active"	activeContext		_ self remap: activeContext.	stackPointer 		_ stackPointer + activeContext.	"*rel to active"	theHomeContext		_ self remap: theHomeContext.	instructionPointer 	_ instructionPointer - method.	"*rel to method"	method				_ self remap: method.	instructionPointer 	_ instructionPointer + method.	"*rel to method"	receiver				_ self remap: receiver.	messageSelector		_ self remap: messageSelector.	newMethod			_ self remap: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			remapBuffer at: i put: (self remap: oop).		].	].	"The method cache uses oops as hashes -- toss the whole thing."	self flushMethodCache.!markAndTraceInterpreterOops	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self markAndTrace: specialObjectsOop.		"also covers nilObj, trueObj, falseObj, and compact classes"	self markAndTrace: activeContext.  "traces entire stack"		"also covers theHomeContext, receiver, method"	self markAndTrace: messageSelector.	self markAndTrace: newMethod.	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self markAndTrace: oop.		].	].!postGCAction	"Mark the active and home contexts as roots if old. This allows the interpreter to use storePointerUnchecked to store into them."	(activeContext    < youngStart) ifTrue: [ self beRootIfOld: activeContext ].	(theHomeContext < youngStart) ifTrue: [ self beRootIfOld: theHomeContext ].! !!Interpreter methodsFor: 'compiled methods'!argumentCountOf: methodPointer	^ ((self headerOf: methodPointer) >> 25) bitAnd: 16r1F!headerOf: methodPointer	^self fetchPointer: HeaderIndex		ofObject: methodPointer!literal: offset	^self literal: offset		ofMethod: method!literal: offset ofMethod: methodPointer	^ self fetchPointer: offset + LiteralStart ofObject: methodPointer!literalCountOf: methodPointer	^self literalCountOfHeader: (self headerOf: methodPointer)!literalCountOfHeader: headerPointer	^ (headerPointer >> 10) bitAnd: 16rFF!methodClassOf: methodPointer	^ self fetchPointer: ValueIndex ofObject:		(self literal: (self literalCountOf: methodPointer) - 1			ofMethod: methodPointer)!primitiveIndexOf: methodPointer	^ ((self headerOf: methodPointer) >> 1) bitAnd: 16r1FF!primitiveNewMethod	| header bytecodeCount class size theMethod literalCount |	header _ self popStack.	bytecodeCount _ self popInteger.	self success: (self isIntegerObject: header).	successFlag ifFalse: [self unPop: 2].	class _ self popStack.	size _ (self literalCountOfHeader: header) + 1 * 4 + bytecodeCount.	theMethod _ self instantiateClass: class indexableSize: size.	self storePointer: HeaderIndex ofObject: theMethod withValue: header.	literalCount _ self literalCountOfHeader: header.	1 to: literalCount do:		[:i | self storePointer: i ofObject: theMethod withValue: nilObj].	self push: theMethod! !!Interpreter methodsFor: 'contexts'!argumentCountOfBlock: blockPointer	| argCount |	argCount _ self fetchPointer: BlockArgumentCountIndex							ofObject: blockPointer.	(self isIntegerObject: argCount)		ifTrue: [ ^ self integerValueOf: argCount ]		ifFalse: [ self primitiveFail. ^0 ].!caller	^self fetchPointer: SenderIndex		ofObject: activeContext!fetchContextRegisters: activeCntx	"Note: internalFetchContextRegisters: should track changes to this method."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	theHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	instructionPointer _ method + tmp + BaseHeaderSize - 2.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	stackPointer _ activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4).!internalFetchContextRegisters: activeCntx	"Inlined into return bytecodes. The only difference between this method and fetchContextRegisters: is that this method sets the local IP and SP."	| tmp |	self inline: true.	tmp _ self fetchPointer: MethodIndex ofObject: activeCntx.	(self isIntegerObject: tmp) ifTrue: [		"if the MethodIndex field is an integer, activeCntx is a block context"		tmp _ self fetchPointer: HomeIndex ofObject: activeCntx.		(tmp < youngStart) ifTrue: [ self beRootIfOld: tmp ].	] ifFalse: [		"otherwise, it is a method context and is its own home context"		tmp _ activeCntx.	].	theHomeContext _ tmp.	receiver _ self fetchPointer: ReceiverIndex ofObject: tmp.	method _ self fetchPointer: MethodIndex ofObject: tmp.	"the instruction pointer is a pointer variable equal to		method oop + ip + BaseHeaderSize		  -1 for 0-based addressing of fetchByte		  -1 because it gets incremented BEFORE fetching currentByte"	tmp _ self quickFetchInteger: InstructionPointerIndex ofObject: activeCntx.	localIP _ self cCoerce: method + tmp + BaseHeaderSize - 2 to: 'char *'.	"the stack pointer is a pointer variable also..."	tmp _ self quickFetchInteger: StackPointerIndex ofObject: activeCntx.	localSP _ self cCoerce: activeCntx + BaseHeaderSize + ((TempFrameStart + tmp - 1) * 4) to: 'char *'.!internalPop: nItems	localSP _ localSP - (nItems * 4).!internalPop: nItems thenPush: oop	self longAt: (localSP _ localSP - ((nItems - 1) * 4)) put: oop.!internalPush: object	self longAt: (localSP _ localSP + 4) put: object.!internalStackTop	^ self longAt: localSP!internalStackValue: offset	^ self longAt: localSP - (offset * 4)!newActiveContext: aContext	self storeContextRegisters: activeContext.	(aContext < youngStart) ifTrue: [ self beRootIfOld: aContext ].	activeContext _ aContext.	self fetchContextRegisters: aContext.!pop: nItems	"Note: May be called by translated primitive code."	stackPointer _ stackPointer - (nItems*4).!pop: nItems thenPush: oop	| sp |	self longAt: (sp _ stackPointer - ((nItems - 1) * 4)) put: oop.	stackPointer _ sp.!popInteger	| integerPointer |	integerPointer _ self popStack.	(self isIntegerObject: integerPointer)		ifTrue: [^ self integerValueOf: integerPointer]		ifFalse: [successFlag _ false.				^ 1  "in case need SOME integer prior to fail"]!popPos32BitInteger	"May set successFlag, and return false if not valid"	| top |	top _ self popStack.	^ self positive32BitValueOf: top!popStack	| top |	top _ self longAt: stackPointer.	stackPointer _ stackPointer - 4.	^ top!push: object	| sp |	self longAt: (sp _ stackPointer + 4) put: object.	stackPointer _ sp.!pushBool: trueOrFalse	trueOrFalse		ifTrue: [ self push: trueObj ]		ifFalse: [ self push: falseObj ].!pushInteger: integerValue	self push: (self integerObjectOf: integerValue).!sender	^ self fetchPointer: SenderIndex ofObject: theHomeContext!stackIntegerValue: offset	| integerPointer |	integerPointer _ self longAt: stackPointer - (offset*4).	(self isIntegerObject: integerPointer)		ifTrue: [ ^self integerValueOf: integerPointer ]		ifFalse: [ self primitiveFail. ^0 ]!stackPointerIndex	"Return the 0-based index rel to the current context.	(This is what stackPointer used to be before conversion to pointer"	^ (stackPointer - activeContext - BaseHeaderSize) >> 2!stackTop	^self longAt: stackPointer!stackValue: offset	^ self longAt: stackPointer - (offset*4)!storeContextRegisters: activeCntx	"InstructionPointer is a pointer variable equal to	method oop + ip + BaseHeaderSize		-1 for 0-based addressing of fetchByte		-1 because it gets incremented BEFORE fetching currentByte"	self inline: true.	self storeWord: InstructionPointerIndex ofObject: activeCntx		withValue: (self integerObjectOf: 			(instructionPointer - method - (BaseHeaderSize - 2))).	self storeWord: StackPointerIndex		  ofObject: activeCntx		withValue: (self integerObjectOf:			(self stackPointerIndex - TempFrameStart + 1)).!storeInstructionPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: InstructionPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).!storeStackPointerValue: value inContext: contextPointer	"Assume: value is an integerValue"	self storeWord: StackPointerIndex		ofObject: contextPointer		withValue: (self integerObjectOf: value).!temporary: offset	^ self fetchPointer: offset + TempFrameStart ofObject: theHomeContext!unPop: nItems	stackPointer _ stackPointer + (nItems*4)! !!Interpreter methodsFor: 'object format'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	self inline: true.	((fmt > 3) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3: mixture of fixed and indexable fields, so must look at class format word"	class _ self fetchClassOf: oop.	classFormat _ self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1!formatOfClass: classPointer	"**should be in-lined**"	"Note that, in Smalltalk, the instSpec will be equal to the inst spec	part of the base header of an instance (without hdr type) shifted left 1.	In this way, apart from the smallInt bit, the bits	are just where you want them for the first header word."	"Callers expect low 2 bits (header type) to be zero!!"	^ (self fetchPointer: InstanceSpecificationIndex ofObject: classPointer) - 1! !!Interpreter methodsFor: 'message sending'!activateNewMethod	| newContext fromIndex toIndex lastIndex methodHeader smallContext initialIP tempCount nilOop |	self inline: false.	self var: #fromIndex declareC: 'char * fromIndex'.	self var: #toIndex declareC: 'char * toIndex'.	self var: #lastIndex declareC: 'char * lastIndex'.	methodHeader _ self headerOf: newMethod.	smallContext _ ((methodHeader >> 18) bitAnd: 1) = 0.	newContext _ self allocateOrRecycleContext: smallContext.	initialIP _		((LiteralStart + (self literalCountOfHeader: methodHeader)) * 4) + 1.	tempCount _		(methodHeader >> 19) bitAnd: 16r3F.	"Assume: newContext will be recorded as a root if necessary by the	 call to newActiveContext: below, so we can use unchecked stores."	self storePointerUnchecked: SenderIndex	ofObject: newContext		withValue: activeContext.	self storeWord: InstructionPointerIndex	ofObject: newContext		withValue: (self integerObjectOf: initialIP).	self storeWord: StackPointerIndex			ofObject: newContext		withValue: (self integerObjectOf: tempCount).	self storePointerUnchecked: MethodIndex ofObject: newContext		withValue: newMethod.	fromIndex _ (self cCoerce: activeContext to: 'char *') + ((self stackPointerIndex - argumentCount) * 4).	toIndex _ (self cCoerce: newContext to: 'char *') + (ReceiverIndex * 4).	lastIndex _ fromIndex + ((argumentCount + 1) * 4).	[fromIndex < lastIndex] whileTrue: [		fromIndex _ fromIndex + 4.		toIndex _ toIndex + 4.		self longAt: toIndex put: (self longAt: fromIndex).	].	"clear remaining context fields to nil in case it has been recycled"	nilOop _ nilObj.	smallContext		ifTrue: [lastIndex _ (self cCoerce: newContext to: 'char *') + SmallContextSize - BaseHeaderSize]		ifFalse: [lastIndex _ (self cCoerce: newContext to: 'char *') + LargeContextSize - BaseHeaderSize].	[toIndex < lastIndex] whileTrue: [		toIndex _ toIndex + 4.		self longAt: toIndex put: nilOop.	].	self pop: argumentCount + 1.	reclaimableContextCount _ reclaimableContextCount + 1.	self newActiveContext: newContext.!argCount	^ argumentCount!createActualMessage	| argumentArray message |	argumentArray _		self instantiateClass: (self splObj: ClassArray) indexableSize: argumentCount.	"remap argumentArray in case GC happens during allocation"	self pushRemappableOop: argumentArray.	message _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	argumentArray _ self popRemappableOop.	(argumentArray < youngStart) ifTrue: [ self beRootIfOld: argumentArray ].	self storePointer: MessageSelectorIndex		ofObject: message		withValue: messageSelector.	self storePointer: MessageArgumentsIndex		ofObject: message		withValue: argumentArray.	self transfer: argumentCount		fromIndex: self stackPointerIndex - (argumentCount - 1)		ofObject: activeContext		toIndex: 0		ofObject: argumentArray.	self pop: argumentCount.	self push: message.	argumentCount _ 1.!executeNewMethod	(primitiveIndex = 0 or: [self primitiveResponse not]) ifTrue: [		"if not primitive, or primitive failed, activate the method"		self activateNewMethod.		"check for possible interrupts at each real send"		self quickCheckForInterrupts.	].!findNewMethodInClass: class	"Find the compiled method to be run when the current messageSelector is sent to the given class, setting the values of 'newMethod' and 'primitiveIndex'."	| ok |	self inline: true.	ok _ self lookupInMethodCacheSel: messageSelector class: class.	ok ifFalse: [		"entry was not found in the cache; look it up the hard way"		self lookupMethodInClass: class.		primitiveIndex _ self primitiveIndexOf: newMethod.		self addToMethodCacheSel: messageSelector			class: class			method: newMethod			primIndex: primitiveIndex.	].!lookupMethodInClass: class	| currentClass dictionary found |	currentClass _ class.	[currentClass ~= nilObj] whileTrue: [		dictionary _ self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		found _ self lookupMethodInDictionary: dictionary.		found ifTrue: [^ currentClass].		currentClass _ self superclassOf: currentClass.	].	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue: [		self error: 'Recursive not understood error encountered'	].	self createActualMessage.	messageSelector _ self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: class!lookupMethodInDictionary: dictionary	"NOTE: This method has been converted to do an exhaustive search,	since hashes will not be the same when we start up the new system.	Unless the method cache is VERY effective, proper hashing will need	to be reinstated here." 	| length index mask wrapAround nextSelector methodArray |	self inline: true.	length _ self fetchWordLengthOf: dictionary.	mask _ length - SelectorStart - 1.	index _ (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart.	wrapAround _ false.	[true] whileTrue:		[nextSelector _ self fetchPointer: index					ofObject: dictionary.		nextSelector=nilObj ifTrue: [^false].		nextSelector=messageSelector			ifTrue: [methodArray _ self fetchPointer: MethodArrayIndex							ofObject: dictionary.				newMethod _ self fetchPointer:  index - SelectorStart							ofObject: methodArray.				primitiveIndex _ self primitiveIndexOf: newMethod.				^true].		index _ index + 1.		index = length			ifTrue: [wrapAround ifTrue: [^false].				wrapAround _ true.				index _ SelectorStart]]!normalSend	"Send a message, starting lookup with the receiver's class."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| rcvrClass |	self inline: true.	self sharedCodeNamed: 'commonSend' inCase: 131.	rcvrClass _ self fetchClassOf: (self internalStackValue: argumentCount).	self externalizeIPandSP.	self sendSelectorToClass: rcvrClass.	self internalizeIPandSP.!sendSelectorToClass: classPointer	"Note: Requires that instructionPointer and stackPointer be externalized."	self inline: true.	self findNewMethodInClass: classPointer.	self executeNewMethod.!specialSelector: index	^ self fetchPointer: (index * 2) ofObject: (self splObj: SpecialSelectors)!superclassOf: classPointer	^ self fetchPointer: SuperclassIndex ofObject: classPointer!superclassSend	"Send a message to self, starting lookup with the superclass of the class containing the currently executing method."	"Assume: messageSelector and argumentCount have been set, and that the receiver and arguments have been pushed onto the stack,"	"Note: This method is inlined into the interpreter dispatch loop."	| superClass |	self inline: true.	self sharedCodeNamed: 'commonSupersend' inCase: 133.	superClass _ self superclassOf: (self methodClassOf: method).	self externalizeIPandSP.	self sendSelectorToClass: superClass.	self internalizeIPandSP.! !!Interpreter methodsFor: 'method lookup cache'!addToMethodCacheSel: selector class: class method: meth primIndex: primIndex	"Add the given entry to the method cache."	| probe |	self inline: false.	"select one of the CacheProbeMax possible entries for replacement..."	mcProbe _ (mcProbe + 1) \\ CacheProbeMax.  "in range 0..CacheProbeMax-1"	probe _ (((selector bitXor: class) >> (mcProbe + 2)) bitAnd: MethodCacheMask) + 1.	"...and replace the entry at that probe addresses"	methodCache at: probe put: selector.	methodCache at: probe + MethodCacheEntries put: class.	methodCache at: probe + (MethodCacheEntries * 2) put: meth.	methodCache at: probe + (MethodCacheEntries * 3) put: primIndex.!flushMethodCache	"Flush the method cache. The method cache is flushed on every programming change and garbage collect."	1 to: MethodCacheSize do: [ :i | methodCache at: i put: 0 ].	mcProbe _ 0.!lookupInMethodCacheSel: selector class: class	"This method implements a simple method lookup cache. If an entry for the given selector and class is found in the cache, set the values of 'newMethod' and 'primitiveIndex' and return true. Otherwise, return false."	"About the re-probe scheme: The hash is the low bits of the XOR of two large addresses, minus their useless lowest two bits. If a probe doesn't get a hit, the hash is shifted right one bit to compute the next probe, introducing a new randomish bit. The cache is probed CacheProbeMax times before giving up."	"WARNING: Since the hash computation is based on the object addresses of the class and selector, we must rehash or flush when compacting storage. We've chosen to flush, since that also saves the trouble of updating the addresses of the objects in the cache."	| hash probe |	self inline: true.	hash _ (selector bitXor: class) >> 2.  "shift drops two low-order zeros from addresses"	probe _ (hash bitAnd: MethodCacheMask) + 1.  "initial probe"	1 to: CacheProbeMax do: [ :p |		(((methodCache at: probe) = selector) and:		 [(methodCache at: probe + MethodCacheEntries) = class]) ifTrue: [			newMethod _ methodCache at: probe + (MethodCacheEntries * 2).			primitiveIndex _ methodCache at: probe + (MethodCacheEntries * 3).			^ true	"found entry in cache; done"		].		probe _ ((hash >> p) bitAnd: MethodCacheMask) + 1	].	^ false! !!Interpreter methodsFor: 'interpreter shell'!fetchByte	"This method uses the preIncrement builtin function which has no Smalltalk equivalent. Thus, it must be overridden in the simulator."	^ self byteAt: localIP preIncrement!getCurrentBytecode	"currentBytecode will be private to the main dispatch loop in the generated code. This method allows the currentBytecode to be retrieved from global variables."	^ self byteAt: instructionPointer!interpret	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.	].	self externalizeIPandSP.!unknownBytecode	"This should never get called; it means that an unimplemented bytecode appears in a CompiledMethod."	self error: 'Unknown bytecode'.! !!Interpreter methodsFor: 'stack bytecodes'!duplicateTopBytecode	self internalPush: self internalStackTop.!experimentalBytecode	"Note: This bytecode is not currently generated by the compiler."	"This range of six bytecodes can replace the pushTemporaryVariable[0..5] bytecode at the beginning of a sequence of either the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		<=		longJumpIfFalseor the form:		pushTemp		pushTemp | pushConstantOne | pushLiteralConstant		+		popIntoTemp (optional)If two values pushed are not small integers, this bytecode acts like the pushTemp bytecode it replaces. However, if they are small integers, then the given arithmetic or comparison operation is performed. The result of that operation is either pushed onto the stack or, if one of the expected bytecodes follows it, then that bytecode is performed immediately. In such cases, the entire four instruction sequence is performed without doing any stack operations."	| arg1 byte2 byte3 byte4 arg1Val arg2Val result offset |	arg1 _ self temporary: currentBytecode - 138.	byte2 _ self byteAt: localIP + 1.  "fetch ahead"	byte3 _ self byteAt: localIP + 2.  "fetch ahead"	byte4 _ self byteAt: localIP + 3.  "fetch ahead"	"check first arg"	(self isIntegerObject: arg1) ifTrue: [		arg1Val _ self integerValueOf: arg1.	] ifFalse: [		^ self internalPush: arg1.  "abort; first arg is not an integer"	].	"get and check second arg"	byte2 < 32 ifTrue: [		arg2Val _ self temporary: (byte2 bitAnd: 16rF).		(self isIntegerObject: arg2Val) ifTrue: [			arg2Val _ self integerValueOf: arg2Val.		] ifFalse: [			^ self internalPush: arg1.  "abort; second arg is not an integer"		].	] ifFalse: [		byte2 > 64 ifTrue: [			arg2Val _ 1.		] ifFalse: [			arg2Val _ self literal: (byte2 bitAnd: 16r1F).			(self isIntegerObject: arg2Val) ifTrue: [				arg2Val _ self integerValueOf: arg2Val.			] ifFalse: [				^ self internalPush: arg1.  "abort; second arg is not an integer"			].		].	].	byte3 < 178 ifTrue: [		"do addition, possibly followed by a storeAndPopTemp"		result _ arg1Val + arg2Val.		(self isIntegerValue: result) ifTrue: [			((byte4 > 103) and: [byte4 < 112]) ifTrue: [				"next instruction is a storeAndPopTemp"				localIP _ localIP + 3.				self storePointerUnchecked: (byte4 bitAnd: 7) + TempFrameStart					ofObject: theHomeContext					withValue: (self integerObjectOf: result).			] ifFalse: [				localIP _ localIP + 2.				self internalPush: (self integerObjectOf: result).			].		] ifFalse: [			^ self internalPush: arg1.  "abort; result is not an integer"		].	] ifFalse: [		"do comparison operation, followed by a longJumpIfFalse"		offset _ self byteAt: localIP + 4.		arg1Val <= arg2Val			ifTrue: [localIP _ localIP + 3 + 1]  "jump not taken; skip extra instruction byte"			ifFalse: [localIP _ localIP + 3 + 1 + offset].	].!extendedPushBytecode	| descriptor variableType variableIndex |	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType=0 ifTrue: [^self pushReceiverVariable: variableIndex].	variableType=1 ifTrue: [^self pushTemporaryVariable: variableIndex].	variableType=2 ifTrue: [^self pushLiteralConstant: variableIndex].	variableType=3 ifTrue: [^self pushLiteralVariable: variableIndex].!extendedStoreAndPopBytecode	self extendedStoreBytecode.	self popStackBytecode.!extendedStoreBytecode	| descriptor variableType variableIndex association |	self inline: true.	descriptor _ self fetchByte.	variableType _ (descriptor >> 6) bitAnd: 16r3.	variableIndex _ descriptor bitAnd: 16r3F.	variableType = 0 ifTrue:		[^self storePointer: variableIndex			ofObject: receiver			withValue: self internalStackTop].	variableType = 1 ifTrue:		[^self storePointerUnchecked: variableIndex + TempFrameStart			ofObject: theHomeContext			withValue: self internalStackTop].	variableType = 2 ifTrue:		[self error: 'illegal store'].	variableType = 3 ifTrue:		[association _ self literal: variableIndex.		^self storePointer: ValueIndex			ofObject: association			withValue: self internalStackTop].!popStackBytecode	self internalPop: 1.!pushActiveContextBytecode	"Puts reclaimability of this context in question."	reclaimableContextCount _ 0.	self internalPush: activeContext.!pushConstantFalseBytecode	self internalPush: falseObj.!pushConstantMinusOneBytecode	self internalPush: ConstMinusOne.!pushConstantNilBytecode	self internalPush: nilObj.!pushConstantOneBytecode	self internalPush: ConstOne.!pushConstantTrueBytecode	self internalPush: trueObj.!pushConstantTwoBytecode	self internalPush: ConstTwo.!pushConstantZeroBytecode	self internalPush: ConstZero.!pushLiteralConstant: literalIndex	self internalPush: (self literal: literalIndex).!pushLiteralConstantBytecode	self pushLiteralConstant: (currentBytecode bitAnd: 16r1F).!pushLiteralVariable: literalIndex	self internalPush:		(self fetchPointer: ValueIndex ofObject: (self literal: literalIndex)).!pushLiteralVariableBytecode	self pushLiteralVariable: (currentBytecode bitAnd: 16r1F).!pushReceiverBytecode	self internalPush: receiver.!pushReceiverVariable: fieldIndex	self internalPush:		(self fetchPointer: fieldIndex ofObject: receiver).!pushReceiverVariableBytecode	self pushReceiverVariable: (currentBytecode bitAnd: 16rF).!pushTemporaryVariable: temporaryIndex	self internalPush: (self temporary: temporaryIndex).!pushTemporaryVariableBytecode	self pushTemporaryVariable: (currentBytecode bitAnd: 16rF).!storeAndPopReceiverVariableBytecode	"Note: This code uses storePointerUnchecked:ofObject:withValue: and does the store check explicitely in order to help the translator produce better code."	| rcvr top |	rcvr _ receiver.	top _ self internalStackTop.	(rcvr < youngStart) ifTrue: [		self possibleRootStoreInto: rcvr value: top.	].	self storePointerUnchecked: (currentBytecode bitAnd: 7)		ofObject: rcvr		withValue: top.	self internalPop: 1.!storeAndPopTemporaryVariableBytecode	self storePointerUnchecked: (currentBytecode bitAnd: 7) + TempFrameStart		ofObject: theHomeContext		withValue: self internalStackTop.	self internalPop: 1.! !!Interpreter methodsFor: 'jump bytecodes'!jump: offset	localIP _ localIP + offset.!jumplfFalseBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = falseObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = trueObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].	].	self internalPop: 1.!jumplfTrueBy: offset	| boolean |	boolean _ self internalStackTop.	boolean = trueObj ifTrue: [		self jump: offset.	] ifFalse: [		boolean = falseObj ifFalse: [			messageSelector _ self splObj: SelectorMustBeBoolean.			argumentCount _ 0.			^ self normalSend		].	].	self internalPop: 1.!longJumpIfFalse	self jumplfFalseBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!longJumpIfTrue	self jumplfTrueBy:		((currentBytecode bitAnd: 3) * 256) + self fetchByte.!longUnconditionalJump	| offset |	offset _ (((currentBytecode bitAnd: 7) - 4) * 256) + self fetchByte.	localIP _ localIP + offset.	offset < 0 ifTrue: [		"backward jump means we're in a loop; check for possible interrupts"		self internalQuickCheckForInterrupts.	].!shortConditionalJump	self jumplfFalseBy: (currentBytecode bitAnd: 7) + 1.!shortUnconditionalJump	self jump: (currentBytecode bitAnd: 7) + 1.! !!Interpreter methodsFor: 'send bytecodes'!doubleExtendedDoAnythingBytecode	"Replaces the Blue Book double-extended send [132], in which	the first byte was wasted on 8 bits of argument count.	Here we use 3 bits for the operation sub-type (opType),	and the remaining 5 bits for argument count where needed.	The last byte give access to 256 instVars or literals.	See also secondExtendedSendBytecode"	| byte2 byte3 opType top |	byte2 _ self fetchByte.	byte3 _ self fetchByte.	opType _ byte2 >> 5.	opType = 0 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self normalSend	].	opType = 1 ifTrue: [		messageSelector _ self literal: byte3.		argumentCount _ byte2 bitAnd: 16r1F.		^ self superclassSend	].	opType = 2 ifTrue: [^ self pushReceiverVariable: byte3].	opType = 3 ifTrue: [^ self pushLiteralConstant: byte3].	opType = 4 ifTrue: [^ self pushLiteralVariable: byte3].	opType = 5 ifTrue: [		top _ self internalStackTop.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 6 ifTrue: [		top _ self internalStackTop.		self internalPop: 1.		^ self storePointer: byte3 ofObject: receiver withValue: top	].	opType = 7 ifTrue: [		top _ self internalStackTop.		^ self storePointer: ValueIndex ofObject: (self literal: byte3) withValue: top	].!secondExtendedSendBytecode	"This replaces the Blue Book double-extended super-send [134],	which is subsumed by the new double-extended do-anything [132].	It offers a 2-byte send of 0-3 args for up to 63 literals, for which 	the Blue Book opcode set requires a 3-byte instruction."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r3F).	argumentCount _ descriptor >> 6.	self normalSend.!sendLiteralSelectorBytecode	"Can use any of the first 16 literals for the selector and pass up to 2 arguments."	messageSelector _ self literal: (currentBytecode bitAnd: 16rF).	argumentCount _ ((currentBytecode >> 4) bitAnd: 3) - 1.	self normalSend.!singleExtendedSendBytecode	"Can use any of the first 32 literals for the selector and pass up to 7 arguments."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r1F).	argumentCount _ descriptor >> 5.	self normalSend.!singleExtendedSuperBytecode	"Can use any of the first 32 literals for the selector and pass up to 7 arguments."	| descriptor |	descriptor _ self fetchByte.	messageSelector _ self literal: (descriptor bitAnd: 16r1F).	argumentCount _ descriptor >> 5.	self superclassSend.! !!Interpreter methodsFor: 'return bytecodes'!returnFalse	| cntx val |	cntx _ self sender.	val _ falseObj.	self returnValue: val to: cntx.!returnNil	| cntx val |	cntx _ self sender.	val _ nilObj.	self returnValue: val to: cntx.!returnReceiver	| cntx val |	cntx _ self sender.	val _ receiver.	self returnValue: val to: cntx.!returnTopFromBlock	"Return to the caller of the method containing the block."	| cntx val |	cntx _ self caller.  "Note: caller, not sender!!"	val _ self internalStackTop.	self returnValue: val to: cntx.!returnTopFromMethod	| cntx val |	cntx _ self sender.	val _ self internalStackTop.	self returnValue: val to: cntx.!returnTrue	| cntx val |	cntx _ self sender.	val _ trueObj.	self returnValue: val to: cntx.!returnValue: resultObj to: returnContext	"Note: Assumed to be inlined into the dispatch loop."	| nilOop thisCntx methodContextClass contextOfCaller |	self inline: true.	self sharedCodeNamed: 'commonReturn' inCase: 120.	nilOop _ nilObj. "keep in a register"	thisCntx _ activeContext.	methodContextClass _ self splObj: ClassMethodContext.	"make sure we can return to the given context"	((returnContext = nilOop) or:	 [(self fetchPointer: InstructionPointerIndex ofObject: returnContext) = nilOop]) ifTrue: [		"error: sender's instruction pointer or context is nil; cannot return"		self internalPush: activeContext.		self internalPush: resultObj.		messageSelector _ self splObj: SelectorCannotReturn.		argumentCount _ 1.		^ self normalSend	].	[thisCntx = returnContext] whileFalse: [		"climb up stack to returnContext"		contextOfCaller _ self fetchPointer: SenderIndex ofObject: thisCntx.		"zap exited contexts so any future attempted use will be caught"		self storePointerUnchecked: SenderIndex ofObject: thisCntx withValue: nilOop.		self storePointerUnchecked: InstructionPointerIndex ofObject: thisCntx withValue: nilOop.		reclaimableContextCount > 0 ifTrue: [			"try to recycle this context"			reclaimableContextCount _ reclaimableContextCount - 1.			self recycleContextIfPossible: thisCntx methodContextClass: methodContextClass.		].		thisCntx _ contextOfCaller.	].	activeContext _ thisCntx.	(thisCntx < youngStart) ifTrue: [ self beRootIfOld: thisCntx ].	self internalFetchContextRegisters: thisCntx.  "updates local IP and SP"	self internalPush: resultObj.	self internalQuickCheckForInterrupts.! !!Interpreter methodsFor: 'common selector sends'!bytecodePrimAdd	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatAdd.	successFlag ifFalse: [		successFlag _ true.		self primitiveAdd.	].	self internalizeIPandSP.!bytecodePrimAt	| index rcvr result rcvrClass stringy |	index _ self internalStackTop.	rcvr _ self internalStackValue: 1.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		rcvrClass _ self fetchClassOf: rcvr.		stringy _ rcvrClass = (self splObj: ClassString).		(stringy or: [self okArrayClass: rcvrClass])			ifFalse: [successFlag _ false]].	successFlag ifTrue: [		index _ self integerValueOf: index.self externalizeIPandSP.		result _ self stObject: rcvr at: index.self internalizeIPandSP.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result]].	successFlag ifTrue: [		self internalPop: 2 thenPush: result.	] ifFalse: [		messageSelector _ self specialSelector: 16.		argumentCount _ 1.		self normalSend.	].!bytecodePrimAtEnd	self externalizeIPandSP.	self primitiveAtEnd.	self internalizeIPandSP.!bytecodePrimAtPut	| value valToStore index rcvr rcvrClass stringy |	value _ valToStore _ self internalStackTop.	index _ self internalStackValue: 1.	rcvr _ self internalStackValue: 2.	successFlag _ self isIntegerObject: index.	successFlag ifTrue: [		rcvrClass _ self fetchClassOf: rcvr.		stringy _ rcvrClass = (self splObj: ClassString).		(stringy or: [self okArrayClass: rcvrClass])			ifFalse: [successFlag _ false]].	successFlag ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	].	successFlag ifTrue: [		self internalPop: 3 thenPush: value.	] ifFalse: [		messageSelector _ self specialSelector: 17.		argumentCount _ 2.		self normalSend.	].!bytecodePrimBitAnd	self externalizeIPandSP.	self primitiveBitAnd.	self internalizeIPandSP.!bytecodePrimBitOr	self externalizeIPandSP.	self primitiveBitOr.	self internalizeIPandSP.!bytecodePrimBitShift	self externalizeIPandSP.	self primitiveBitShift.	self internalizeIPandSP.!bytecodePrimBlockCopy	| rcvrClass |	rcvrClass _ self fetchClassOf: (self internalStackValue: 1).	successFlag _ true.	self success:		((rcvrClass = (self splObj: ClassBlockContext)) or:		 [rcvrClass = (self splObj: ClassMethodContext)]).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveBlockCopy.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 24.		argumentCount _ 1.		^ self normalSend	].!bytecodePrimClass	self externalizeIPandSP.	self primitiveClass.	self internalizeIPandSP.!bytecodePrimDiv	self externalizeIPandSP.	self primitiveDiv.	self internalizeIPandSP.!bytecodePrimDivide	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		((arg ~= 0) and: [(rcvr \\ arg) = 0]) ifTrue: [			result _ rcvr // arg.  "generates C / operation"			(self isIntegerValue: result) ifTrue: [				self longAt: (localSP _ localSP - 4)						put: (self integerObjectOf: result).				^ nil			].		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatDivide.	successFlag ifFalse: [		successFlag _ true.		self primitiveDivide.	].	self internalizeIPandSP.!bytecodePrimDo	messageSelector _ self specialSelector: 27.	argumentCount _ 1.	self normalSend.!bytecodePrimEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr = arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveEqual.	].	self internalizeIPandSP.!bytecodePrimEquivalent	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	self booleanCheat: rcvr = arg.!bytecodePrimGreaterOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr >= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatGreaterOrEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveGreaterOrEqual.	].	self internalizeIPandSP.!bytecodePrimGreaterThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr > arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatGreaterThan.	successFlag ifFalse: [		successFlag _ true.		self primitiveGreaterThan.	].	self internalizeIPandSP.!bytecodePrimLessOrEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr <= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatLessOrEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveLessOrEqual.	].	self internalizeIPandSP.!bytecodePrimLessThan	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr < arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatLessThan.	successFlag ifFalse: [		successFlag _ true.		self primitiveLessThan.	].	self internalizeIPandSP.!bytecodePrimMakePoint	self externalizeIPandSP.	self primitiveMakePoint.	self internalizeIPandSP.!bytecodePrimMod	self externalizeIPandSP.	self primitiveMod.	self internalizeIPandSP.!bytecodePrimMultiply	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		((arg = 0 or: [(result // arg) = rcvr]) and:		 [self isIntegerValue: result]) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatMultiply.	successFlag ifFalse: [		successFlag _ true.		self primitiveMultiply.	].	self internalizeIPandSP.!bytecodePrimNew	messageSelector _ self specialSelector: 28.	argumentCount _ 0.	self normalSend.!bytecodePrimNewWithArg	messageSelector _ self specialSelector: 29.	argumentCount _ 1.	self normalSend.!bytecodePrimNext	self externalizeIPandSP.	self primitiveNext.	self internalizeIPandSP.!bytecodePrimNextPut	self externalizeIPandSP.	self primitiveNextPut.	self internalizeIPandSP.!bytecodePrimNotEqual	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		^ self booleanCheat: rcvr ~= arg	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatNotEqual.	successFlag ifFalse: [		successFlag _ true.		self primitiveNotEqual.	].	self internalizeIPandSP.!bytecodePrimPointX	self externalizeIPandSP.	self primitivePointX.	self internalizeIPandSP.!bytecodePrimPointY	self externalizeIPandSP.	self primitivePointY.	self internalizeIPandSP.!bytecodePrimSize	"See the comment in bytePrimitiveAt"	| arrayClass |	self externalizeIPandSP.	successFlag _ true.	arrayClass _ self fetchClassOf: (self stackValue: 0).	(self okStreamArrayClass: arrayClass)		ifTrue: [self primitiveSize]		ifFalse: [self failSpecialPrim: 0].	self internalizeIPandSP.!bytecodePrimSubtract	| rcvr arg result |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg) ifTrue: [		result _ (self integerValueOf: rcvr) - (self integerValueOf: arg).		(self isIntegerValue: result) ifTrue: [			self longAt: (localSP _ localSP - 4)					put: (self integerObjectOf: result).			^ nil		].	].	self externalizeIPandSP.	successFlag _ true.	self primitiveFloatSubtract.	successFlag ifFalse: [		successFlag _ true.		self primitiveSubtract.	].	self internalizeIPandSP.!bytecodePrimValue	| block |	block _ self internalStackTop.	successFlag _ true.	argumentCount _ 0.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 25.		argumentCount _ 0.		^ self normalSend	].!bytecodePrimValueWithArg	| block |	block _ self internalStackValue: 1.	successFlag _ true.	argumentCount _ 1.	self assertClassOf: block is: (self splObj: ClassBlockContext).	successFlag ifTrue: [		self externalizeIPandSP.		self primitiveValue.		self internalizeIPandSP.	].	successFlag ifFalse: [		messageSelector _ self specialSelector: 26.		argumentCount _ 1.		^ self normalSend	].! !!Interpreter methodsFor: 'primitive support'!failed	^successFlag not!failSpecialPrim: primIndex	"Used only for failing from a primitive that was entered as a special	bytecode.  This routine will look up the real method and, only if its	primitiveIndex is different, then it will run that primitive, otherwise	it will simply activate to run the fail code"	| bytecode selectorIndex newReceiver rcvrClass |	bytecode _ self getCurrentBytecode.	(bytecode < 176 or: [bytecode > 207])		ifTrue: ["Primitive was not running as a special bytecode"				^ self primitiveFail].	selectorIndex _ (bytecode - 176) * 2.	messageSelector _ self fetchPointer: selectorIndex				ofObject: (self splObj: SpecialSelectors).	argumentCount _ self quickFetchInteger: selectorIndex + 1				ofObject: (self splObj: SpecialSelectors)."	self sendSelector: messageSelector argumentCount: count"	"The above line of code must be expanded and altered, because we only	want to run the ST code, not re-run the primitive and get into a loop"	newReceiver _ self stackValue: argumentCount.	rcvrClass _ self fetchClassOf: newReceiver.	self findNewMethodInClass: rcvrClass.	(primitiveIndex > 37 and: [primitiveIndex ~= primIndex])		ifTrue: [self executeNewMethod]		ifFalse: [self activateNewMethod]!positive32BitIntegerFor: integerValue	| newLargeInteger |	"Note - integerValue is interpreted as POSITIVE, eg, as the result of		Bitmap>at:, or integer>bitAnd:."	(integerValue >= 0 and: [self isIntegerValue: integerValue])		ifTrue: [^ self integerObjectOf: integerValue].	newLargeInteger _		self instantiateSmallClass: (self splObj: ClassLargePositiveInteger)				sizeInBytes: 8						 fill: 0.	self storeByte: 3 ofObject: newLargeInteger		withValue: ((integerValue >> 24) bitAnd: 16rFF).	self storeByte: 2 ofObject: newLargeInteger		withValue: ((integerValue >> 16) bitAnd: 16rFF).	self storeByte: 1 ofObject: newLargeInteger		withValue: ((integerValue >> 8) bitAnd: 16rFF).	self storeByte: 0 ofObject: newLargeInteger		withValue: (integerValue bitAnd: 16rFF).	^ newLargeInteger!positive32BitValueOf: oop	"Convert the given object into an integer value.	The object may be either a positive ST integer or a four-byte LargePositiveInteger."	| sz value |	(self isIntegerObject: oop) ifTrue: [		value _ self integerValueOf: oop.		value < 0 ifTrue: [^ self primitiveFail].		^ value].	self assertClassOf: oop is: (self splObj: ClassLargePositiveInteger).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 0 ofObject: oop) +		  ((self fetchByte: 1 ofObject: oop) <<  8) +		  ((self fetchByte: 2 ofObject: oop) << 16) +		  ((self fetchByte: 3 ofObject: oop) << 24) ].!primIndex	^ primitiveIndex!primitiveFail	successFlag _ false.!primitiveResponse	| thisReceiver |	primitiveIndex >= 256		ifTrue:			[thisReceiver _ self popStack.			primitiveIndex < 264				ifTrue: ["Quick return of self or a constant"						primitiveIndex = 256 ifTrue: [self push: thisReceiver].						primitiveIndex = 257 ifTrue: [self push: trueObj].						primitiveIndex = 258 ifTrue: [self push: falseObj].						primitiveIndex = 259 ifTrue: [self push: nilObj].						primitiveIndex = 260 ifTrue: [self push: ConstMinusOne].						primitiveIndex = 261 ifTrue: [self push: ConstZero].						primitiveIndex = 262 ifTrue: [self push: ConstOne].						primitiveIndex = 263 ifTrue: [self push: ConstTwo].						^ true]				ifFalse: ["Quick return of an instance field"							self push: (self fetchPointer: primitiveIndex-264 ofObject: thisReceiver).						^ true]]		ifFalse:			[successFlag _ true.			self dispatchOn: primitiveIndex in: PrimitiveTable.			"check for possible timer interrupts after each primitive"			(successFlag and:			 [(nextWakeupTick ~= 0) and:			 [self ioMSecs >= nextWakeupTick]]) ifTrue: [				interruptCheckCounter _ 1000.				self checkForInterrupts].			^ successFlag]!success: successValue	successFlag _ successValue & successFlag.! !!Interpreter methodsFor: 'arithmetic primitives'!checkBooleanResult: result from: primIndex	successFlag		ifTrue: [self pushBool: result]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!checkIntegerResult: integerResult from: primIndex	(successFlag and: [self isIntegerValue: integerResult])		ifTrue: [self pushInteger: integerResult]		ifFalse: [self unPop: 2.  self failSpecialPrim: primIndex]!compare31or32Bits: obj1 equal: obj2	"May set success to false"	"First compare two ST integers..."	((self isIntegerObject: obj1)		and: [self isIntegerObject: obj2])		ifTrue: [^ obj1 = obj2].	"Now compare, assuming positive integers, but setting fail if not"	^ (self positive32BitValueOf: obj1) = (self positive32BitValueOf: obj2)!primitiveAdd	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		result _ (self integerValueOf: rcvr) + (self integerValueOf: arg).	].	self checkIntegerResult: result from: 1.!primitiveBitAnd	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitAnd: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 14]!primitiveBitOr	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitOr: integerArgument))]		ifFalse: [self unPop: 2.  self failSpecialPrim: 15]!primitiveBitShift 	| integerReceiver integerArgument shifted |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popPos32BitInteger.	successFlag ifTrue: [		integerArgument >= 0 ifTrue: [			"Left shift -- must fail if we lose bits beyond 32"			self success: integerArgument <= 31.			shifted _ integerReceiver << integerArgument.			self success: (shifted >> integerArgument) = integerReceiver.		] ifFalse: [			"Right shift -- OK to lose bits"			self success: integerArgument >= -31.			shifted _ integerReceiver bitShift: integerArgument.		].	].	successFlag		ifTrue: [self push: (self positive32BitIntegerFor: shifted)]		ifFalse: [self unPop: 2.  self failSpecialPrim: 17]!primitiveBitXor	"Note: unlike all the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| integerReceiver integerArgument |	integerArgument _ self popPos32BitInteger.	integerReceiver _ self popPos32BitInteger.	successFlag		ifTrue: [self push: (self positive32BitIntegerFor:					(integerReceiver bitXor: integerArgument))]		ifFalse: [self unPop: 2]!primitiveDiv	"Rounds negative results towards negative infinity, rather than zero."	| rcvr arg result posArg posRcvr |	successFlag _ true.	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				"round negative result toward negative infinity"				posArg _ 0 - arg.				result _ 0 - ((rcvr + (posArg - 1)) // posArg).			].		] ifFalse: [			posRcvr _ 0 - rcvr.			arg > 0 ifTrue: [				"round negative result toward negative infinity"				result _ 0 - ((posRcvr + (arg - 1)) // arg).			] ifFalse: [				posArg _ 0 - arg.				result _ posRcvr // posArg.			].		].		self checkIntegerResult: result from: 12]	ifFalse:		[self checkIntegerResult: 0 from: 12 "will fail"]!primitiveDivide	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	self success: integerReceiver \\ integerArgument = 0.	self checkIntegerResult: integerReceiver // integerArgument from: 10!primitiveEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ self compare31or32Bits: integerReceiver equal: integerArgument.	self checkBooleanResult: result from: 7!primitiveGreaterOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver >= integerArgument from: 6!primitiveGreaterThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver > integerArgument from: 4!primitiveLessOrEqual	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver <= integerArgument from: 5!primitiveLessThan	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkBooleanResult: integerReceiver < integerArgument from: 3!primitiveMakePoint	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	successFlag		ifTrue: [self push: (self makePointwithxValue: integerReceiver yValue: integerArgument)]		ifFalse: [self checkIntegerResult: 0 from: 18  "will fail"]!primitiveMod	| integerReceiver integerArgument integerResult |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self success: integerArgument ~= 0.	successFlag ifFalse: [integerArgument _ 1].  "fall through to fail"	integerResult _ integerReceiver \\ integerArgument.	integerResult < 0 ifTrue: [integerResult _ integerResult + integerArgument].	self checkIntegerResult: integerResult from: 11!primitiveMultiply	| rcvr arg result |	rcvr _ self stackValue: 1.	arg _ self stackValue: 0.	self pop: 2.	self success: (self areIntegers: rcvr and: arg).	successFlag ifTrue: [		rcvr _ self integerValueOf: rcvr.		arg _ self integerValueOf: arg.		result _ rcvr * arg.		"check for C overflow by seeing if computation is reversible"		self success: ((arg = 0) or: [(result // arg) = rcvr]).	].	self checkIntegerResult: result from: 9.!primitiveNotEqual	| integerReceiver integerArgument result |	successFlag _ true.	integerArgument _ self popStack.	integerReceiver _ self popStack.	result _ (self compare31or32Bits: integerReceiver equal: integerArgument) not.	self checkBooleanResult: result from: 8!primitiveQuo	"Rounds negative results towards zero."	"Note: unlike the other arithmetic primitives, this is called as	a real send, not as a special byte.  Thus successFlag has already	been set, and failure is normal, not through failSpecialPrim."	| rcvr arg result |	arg _ self popInteger.	rcvr _ self popInteger.	self success: arg ~= 0.	successFlag ifTrue: [		rcvr > 0 ifTrue: [			arg > 0 ifTrue: [				result _ rcvr // arg.			] ifFalse: [				result _ 0 - (rcvr // (0 - arg)).			].		] ifFalse: [			arg > 0 ifTrue: [				result _ 0 - ((0 - rcvr) // arg).			] ifFalse: [				result _ (0 - rcvr) // (0 - arg).			].		].		self success: (self isIntegerValue: result)].	successFlag		ifTrue: [self pushInteger: result]		ifFalse: [self unPop: 2]!primitiveSubtract	| integerReceiver integerArgument |	successFlag _ true.	integerArgument _ self popInteger.	integerReceiver _ self popInteger.	self checkIntegerResult: integerReceiver - integerArgument from: 2! !!Interpreter methodsFor: 'float primitives'!popFloat	"Note: May be called by translated primitive code."	| top result |	self returnTypeC: 'double'.	self var: #result declareC: 'double result'.	top _ self popStack.	self assertClassOf: top is: (self splObj: ClassFloat).	successFlag		ifTrue: [self fetchFloatAt: top + BaseHeaderSize into: result].	^ result!primitiveArctan	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'atan(rcvr)')]		ifFalse: [self unPop: 1]!primitiveAsFloat	| arg |	arg _ self popInteger.	successFlag		ifTrue: [ self pushFloat: (self cCode: '((double) arg)') ]		ifFalse: [ self unPop: 1 ].!primitiveExp	"Computes E raised to the receiver power."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'exp(rcvr)')]		ifFalse: [self unPop: 1]!primitiveExponent	"Exponent part of this float."	| rcvr frac pwr |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = frexp(rcvr, &pwr)'.  "rcvr = frac * 2^pwr, where frac is in [0.5..1.0)"			(pwr = 0)				ifTrue: [self pushInteger: 0]				ifFalse: [self pushInteger: pwr - 1]]		ifFalse: [self unPop: 1].!primitiveFloatAdd	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr + arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].!primitiveFloatDivide	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self success: arg ~= 0.0.		successFlag ifTrue: [			result _ rcvr // arg.  "generates C / operation"			resultOop _ self clone: rcvrOop.			self storeFloatAt: resultOop + BaseHeaderSize from: result.			self pop: 2 thenPush: resultOop]].!primitiveFloatEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr = arg].!primitiveFloatGreaterOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr >= arg].!primitiveFloatGreaterThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr > arg].!primitiveFloatLessOrEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr <= arg].!primitiveFloatLessThan	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr < arg].!primitiveFloatMultiply	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr * arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].!primitiveFloatNotEqual	| rcvr rcvrOop arg argOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		self pop: 2.		self pushBool: rcvr ~= arg].!primitiveFloatSubtract	| rcvr rcvrOop arg argOop result resultOop |	self var: #rcvr declareC: 'double rcvr'.	self var: #arg declareC: 'double arg'.	self var: #result declareC: 'double result'.	rcvrOop _ self stackValue: 1.	argOop _ self stackTop.	self assertFloat: rcvrOop and: argOop.	successFlag ifTrue: [		self fetchFloatAt: rcvrOop + BaseHeaderSize into: rcvr.		self fetchFloatAt: argOop + BaseHeaderSize into: arg.		result _ rcvr - arg.		resultOop _ self clone: rcvrOop.		self storeFloatAt: resultOop + BaseHeaderSize from: result.		self pop: 2 thenPush: resultOop].!primitiveFractionalPart	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag		ifTrue: [			self cCode: 'frac = modf(rcvr, &trunc)'.			self pushFloat: frac]		ifFalse: [self unPop: 1]!primitiveLogN	"Natural log."	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'log(rcvr)')]		ifFalse: [self unPop: 1]!primitiveSine	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sin(rcvr)')]		ifFalse: [self unPop: 1]!primitiveSquareRoot	| rcvr |	self var: #rcvr declareC: 'double rcvr'.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: (self cCode: 'sqrt(rcvr)')]		ifFalse: [self unPop: 1]!primitiveTimesTwoPower	| rcvr arg |	self var: #rcvr declareC: 'double rcvr'.	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (self cCode: 'ldexp(rcvr, arg)') ]		ifFalse: [ self unPop: 2 ].!primitiveTruncated	| rcvr frac trunc |	self var: #rcvr declareC: 'double rcvr'.	self var: #frac declareC: 'double frac'.	self var: #trunc declareC: 'double trunc'.	rcvr _ self popFloat.	successFlag ifTrue: [		self cCode: 'frac = modf(rcvr, &trunc)'.		self cCode: 'success((-4294967296.0 <= trunc) && (trunc <= 4294967295.0))'.	].	successFlag		ifTrue: [self cCode: 'pushInteger((int) trunc)']		ifFalse: [self unPop: 1]!pushFloat: f	| newFloatObj |	self var: #f declareC: 'double f'.	newFloatObj _ self instantiateSmallClass: (self splObj: ClassFloat) sizeInBytes: 12 fill: 0.	self storeFloatAt: newFloatObj + BaseHeaderSize from: f.	self push: newFloatObj.! !!Interpreter methodsFor: 'array and stream primitives'!asciiOfCharacter: characterObj  "Returns an integer object"	self inline: false.	self assertClassOf: characterObj is: (self splObj: ClassCharacter).	successFlag		ifTrue: [^ self fetchPointer: CharacterValueIndex ofObject: characterObj]		ifFalse: [^ ConstZero]  "in case some code needs an int"!byteLengthOf: oop	"Return the number of indexable bytes in the given object. This is basically a special copy of lengthOf: for BitBlt."	| header sz fmt |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize)]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3)]  "bytes"!characterForAscii: integerObj  "Arg must lie in range 0-255!!"	^ self fetchPointer: (self integerValueOf: integerObj)			ofObject: (self splObj: CharacterTable)!commonAt: stringy	"This version of at: is called from the special byteCode, from	primitiveAt, and from primStringAt.  The boolean 'stringy'	indicates that the result should be converted to a Character."	| index rcvr result |	self inline: true.	index _ self stackTop.	rcvr _ self stackValue: 1.	(self isIntegerObject: index) ifTrue: [		index _ self integerValueOf: index.		result _ self stObject: rcvr at: index.		(stringy and: [successFlag]) ifTrue: [result _ self characterForAscii: result].	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 2 thenPush: result.	] ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 63]			ifFalse: [self failSpecialPrim: 60].	].!commonAtPut: stringy	"See the comment in commonAt:."	| value valToStore index rcvr |	self inline: true.	value _ valToStore _ self stackTop.	index _ self stackValue: 1.	rcvr _ self stackValue: 2.	(self isIntegerObject: index) ifTrue: [		index _ self integerValueOf: index.		stringy ifTrue: [valToStore _ self asciiOfCharacter: value].		self stObject: rcvr at: index put: valToStore.	] ifFalse: [		successFlag _ false.	].	successFlag ifTrue: [		self pop: 3 thenPush: value.	] ifFalse: [		stringy			ifTrue: [self failSpecialPrim: 64]			ifFalse: [self failSpecialPrim: 61].	].!lengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header sz fmt |	self inline: true.	"from ObjectMemory>sizeBitsOf:..."	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ header bitAnd: 16rFC ].	"from ObjectMemory>formatOf:..."	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"!lengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result of this method."	| sz |	self inline: true.	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ sz _ hdr bitAnd: 16rFC ].	fmt < 8		ifTrue: [ ^ (sz - BaseHeaderSize) >> 2 ]  "words"		ifFalse: [ ^ (sz - BaseHeaderSize) - (fmt bitAnd: 3) ]  "bytes"!okArrayClass: cl	^(cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassBitmap) or:	  [cl = (self splObj: ClassByteArray)]])!okStreamArrayClass: cl	^(cl = (self splObj: ClassString) or:	  [cl = (self splObj: ClassArray) or:	  [cl = (self splObj: ClassByteArray) or:	  [cl = (self splObj: ClassBitmap)]]])!primitiveAt	self commonAt: false.!primitiveAtEnd	| stream array index limit arrayClass size |	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		size _ self stSizeOf: array]. 	successFlag		ifTrue: [self pushBool: (index >= limit) | (index >= size)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 67].!primitiveAtPut	self commonAtPut: false.!primitiveNext	| stream array index limit arrayClass stringy result |	stream _ self popStack.	successFlag _		((self isPointers: stream) and:		 [(self lengthOf: stream) >= (StreamReadLimitIndex + 1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamReadLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		stringy _ arrayClass = (self splObj: ClassString).		stringy ifFalse: [			self success: (self okStreamArrayClass: arrayClass)].		self success: index < limit].	successFlag ifTrue: [		index _ index + 1.		self pushRemappableOop: stream.		result _ self stObject: array at: index.  "may cause GC!!"		stream _ self popRemappableOop].	successFlag ifTrue: [		self storeInteger: StreamIndexIndex			ofObject: stream			withValue: index].	successFlag ifTrue: [		stringy			ifTrue: [self push: (self characterForAscii: result)]			ifFalse: [self push: result].	] ifFalse: [		self unPop: 1.		self failSpecialPrim: 65].!primitiveNextPut	| value stream index limit array arrayClass storeVal |	value _ self popStack.	stream _ self popStack.	successFlag _ ((self isPointers: stream)			and: [(self lengthOf: stream) >= (StreamReadLimitIndex+1)]). 	successFlag ifTrue: [		array _ self fetchPointer: StreamArrayIndex ofObject: stream.		index _ self fetchInteger: StreamIndexIndex ofObject: stream.		limit _ self fetchInteger: StreamWriteLimitIndex ofObject: stream.		arrayClass _ self fetchClassOf: array.		self success: (self okStreamArrayClass: arrayClass).		self success: index < limit].	successFlag ifTrue:		[index _ index + 1.		arrayClass = (self splObj: ClassString)			ifTrue: [storeVal _ self asciiOfCharacter: value]			ifFalse: [storeVal _ value].		self stObject: array at: index put: storeVal].	successFlag ifTrue:		[self storeInteger: StreamIndexIndex ofObject: stream			withValue: index].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2. self failSpecialPrim: 66]!primitiveSize	| rcvr sz |	rcvr _ self stackTop.	(self isIntegerObject: rcvr)		ifTrue: [sz _ 0]  "integers have no indexable fields"		ifFalse: [sz _ self stSizeOf: rcvr].	successFlag		ifTrue: [self pop: 1. self pushInteger: sz]		ifFalse: [self failSpecialPrim: 62].!primitiveStringAt	self commonAt: true.!primitiveStringAtPut	self commonAtPut: true.!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 		arrayFmt < 4 ifTrue: [  "pointer type objects"			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl)]		ifFalse: [			arrayFmt < 8 ifTrue: [  "long-word type objects"				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl)]			ifFalse: [  "byte-type objects"				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl)]].		srcIndex _ srcIndex + 1.	].	self pop: 4.  "leave rcvr on stack"!stObject: array at: index	"Return what ST would return for <obj> at: index."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag		ifTrue: [^ self subscript: array with: (index + fixedFields) format: fmt]		ifFalse: [^ 0 ].!stObject: array at: index put: value	"Do what ST would return for <obj> at: index put: value."	| hdr fmt totalLength fixedFields |	self inline: false.	hdr _ self baseHeader: array.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: array format: fmt length: totalLength.	((index >= 1) and: [index <= (totalLength - fixedFields)]) ifFalse: [successFlag _ false].	successFlag ifTrue:		[self subscript: array with: (index + fixedFields) storing: value format: fmt].!stSizeOf: oop	"Return the number of indexable fields in the given object. (i.e., what Smalltalk would return for <obj> size)."	"Note: Assume oop is not a SmallInteger!!"	| hdr fmt totalLength fixedFields |	self inline: true.	hdr _ self baseHeader: oop.	fmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: oop baseHeader: hdr format: fmt.	fixedFields _ self fixedFieldsOf: oop format: fmt length: totalLength.	^ totalLength - fixedFields!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchWord: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].!subscript: array with: index storing: oopToStore format: fmt	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	self inline: true.	fmt < 4 ifTrue: [  "pointer type objects"		self storePointer: index - 1 ofObject: array withValue: oopToStore.	] ifFalse: [		fmt < 8 ifTrue: [  "long-word type objects"			valueToStore _ self positive32BitValueOf: oopToStore.			successFlag ifTrue:				[self storeWord: index - 1 ofObject: array withValue: valueToStore].		] ifFalse: [  "byte-type objects"			(self isIntegerObject: oopToStore) ifFalse: [successFlag _ false].			valueToStore _ self integerValueOf: oopToStore.			((valueToStore >= 0) and: [valueToStore <= 255]) ifFalse: [successFlag _ false].			successFlag ifTrue:				[self storeByte: index - 1 ofObject: array withValue: valueToStore].		].	].! !!Interpreter methodsFor: 'object access primitives'!primitiveArrayBecome	| arg rcvr |	arg _ self popStack.	rcvr _ self stackTop.	self success: (self become: rcvr with: arg).	successFlag ifFalse: [ self unPop: 1 ].!primitiveAsOop	| thisReceiver |	thisReceiver _ self popStack.	self success: (self isIntegerObject: thisReceiver) not.	successFlag		ifTrue: [self pushInteger: (self hashBitsOf: thisReceiver)]		ifFalse: [self unPop: 1]!primitiveClass	| instance |	instance _ self popStack.	self push: (self fetchClassOf: instance)!primitiveClone	"Return a shallow copy of the receiver."	| newCopy |	newCopy _ self clone: (self stackTop).	self pop: 1 thenPush: newCopy.!primitiveEquivalent	| thisObject otherObject |	otherObject _ self popStack.	thisObject _ self popStack.	self pushBool: thisObject = otherObject!primitiveInstVarAt	| index rcvr hdr fmt totalLength fixedFields value |	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [value _ self subscript: rcvr with: index format: fmt].	successFlag		ifTrue: [self push: value]		ifFalse: [self unPop: 2]!primitiveInstVarAtPut	| newValue index rcvr hdr fmt totalLength fixedFields |	newValue _ self popStack.	index _ self popInteger.	rcvr _ self popStack.	successFlag ifTrue: [		hdr _ self baseHeader: rcvr.		fmt _ (hdr >> 8) bitAnd: 16rF.		totalLength _ self lengthOf: rcvr baseHeader: hdr format: fmt.		fixedFields _ self fixedFieldsOf: rcvr format: fmt length: totalLength.		((index >= 1) and: [index <= fixedFields])			ifFalse: [successFlag _ false]].	successFlag		ifTrue: [self subscript: rcvr with: index storing: newValue format: fmt].	successFlag		ifTrue: [self push: newValue]		ifFalse: [self unPop: 3]!primitiveNew	"Allocate a new fixed-size instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| class spaceOkay |	class _ self popStack.	spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: 0.	self success: spaceOkay.	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: 0) ]		ifFalse: [ self unPop: 1 ].!primitiveNewWithArg	"Allocate a new indexable instance. Fail if the allocation would leave less than lowSpaceThreshold bytes free."	| size class spaceOkay |	size _ self popInteger.	class _ self popStack.	self success: size >= 0.	successFlag ifTrue: [		spaceOkay _ self sufficientSpaceToInstantiate: class indexableSize: size.		self success: spaceOkay.	].	successFlag		ifTrue: [ self push: (self instantiateClass: class indexableSize: size) ]		ifFalse: [ self unPop: 2 ].!primitiveNextInstance	| object instance |	object _ self popStack.	instance _ self instanceAfter: object.	instance = nilObj		ifTrue: [self unPop: 1. self primitiveFail]		ifFalse: [self push: instance]!primitiveNextObject	"Return the object following the receiver in the heap. Return the SmallInteger zero when there are no more objects."	| object instance |	object _ self popStack.	instance _ self accessibleObjectAfter: object.	instance = nil		ifTrue: [ self pushInteger: 0 ]		ifFalse: [ self push: instance ].!primitiveObjectAt  "Defined for CompiledMethods only"	| thisReceiver index |	index  _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self push: (self fetchPointer: index - 1					ofObject: thisReceiver)]		ifFalse: [self unPop: 2]!primitiveObjectAtPut  "Defined for CompiledMethods only"	| thisReceiver index newValue |	newValue _ self popStack.	index _ self popInteger.	thisReceiver _ self popStack.	self success: index > 0.	self success: index <= ((self literalCountOf: thisReceiver) + LiteralStart).	successFlag		ifTrue: [self storePointer: index - 1				ofObject: thisReceiver				withValue: newValue.			self push: newValue]		ifFalse: [self unPop: 3]!primitiveObjectPointsTo	| rcvr thang lastField |	thang _ self popStack.	rcvr _ self popStack.	(self isIntegerObject: rcvr) ifTrue: [^ self pushBool: false].	lastField _ self lastPointerOf: rcvr.	BaseHeaderSize to: lastField by: 4 do:		[:i | (self longAt: rcvr + i) = thang			ifTrue: [^ self pushBool: true]].	self pushBool: false.!primitivePointX	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: XIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!primitivePointY	| rcvr | 	successFlag _ true.	rcvr _ self popStack.	self assertClassOf: rcvr is: (self splObj: ClassPoint).	successFlag		ifTrue: [self push: (self fetchPointer: YIndex ofObject: rcvr)]		ifFalse: [self unPop: 1.  self failSpecialPrim: 0  "will fail"]!primitiveSomeInstance	| class instance |	class _ self popStack.	instance _ self initialInstanceOf: class.	instance = nilObj		ifTrue: [self primitiveFail]		ifFalse: [self push: instance]!primitiveSomeObject	"Return the first object in the heap."	self pop: 1.	self push: self firstAccessibleObject.!sufficientSpaceToInstantiate: classOop indexableSize: size	"Return the number of bytes required to allocate an instance of the given class with the given number of indexable fields."	"Details: For speed, over-estimate space needed for fixed fields or literals; the low space threshold is a blurry line."	| format okay |	self inline: true.	format _ ((self formatOfClass: classOop) >> 8) bitAnd: 16rF.	"fail if attempting to call new: on non-indexable class"	(size > 0 and: [format < 2]) ifTrue: [ ^ false ].	format < 8 ifTrue: [		"indexable fields are words or pointers"		okay _ self sufficientSpaceToAllocate: (2500 + (size * 4)).	] ifFalse: [		"indexable fields are bytes"		okay _ self sufficientSpaceToAllocate: (2500 + size).	].	^ okay! !!Interpreter methodsFor: 'control primitives'!primitiveBlockCopy	| context methodContext contextSize newContext initialIP |	context _ self stackValue: 1.	(self isIntegerObject: (self fetchPointer: MethodIndex ofObject: context)) ifTrue: [		"context is a block; get the context of its enclosing method"		methodContext _ self fetchPointer: HomeIndex ofObject: context.	] ifFalse: [		methodContext _ context.	].	contextSize _ self sizeBitsOf: methodContext.  "in bytes, including header"	context _ nil.  "context is no longer needed and is not preserved across allocation"	"remap methodContext in case GC happens during allocation"	self pushRemappableOop: methodContext.	newContext _ self instantiateSmallClass: (self splObj: ClassBlockContext)							   sizeInBytes: contextSize									   fill: nilObj.	methodContext _ self popRemappableOop.	initialIP _ self integerObjectOf: instructionPointer - method.	"Was instructionPointer + 3, but now it's greater by 		methodOop + 4 (headerSize) and less by 1 due to preIncrement"	"Assume: have just allocated a new context; it must be young.	 Thus, can use uncheck stores. See the comment in fetchContextRegisters."	self storeWord: InitialIPIndex					ofObject: newContext		withValue: initialIP.	self storeWord: InstructionPointerIndex		ofObject: newContext		withValue: initialIP.	self storeStackPointerValue: 0				inContext: newContext.	self storePointerUnchecked: BlockArgumentCountIndex	ofObject: newContext		withValue: (self stackValue: 0).	self storePointerUnchecked: HomeIndex		ofObject: newContext		withValue: methodContext.	self pop: 2.  "block argument count, rcvr"	self push: newContext.!primitivePerform	| performSelector newReceiver selectorIndex |	performSelector _ messageSelector.	messageSelector _ self stackValue: argumentCount - 1.	newReceiver _ self stackValue: argumentCount.	self lookupMethodInClass: (self fetchClassOf: newReceiver).	self success: (self argumentCountOf: newMethod) = (argumentCount - 1).	successFlag		ifTrue: [selectorIndex _ self stackPointerIndex - argumentCount + 1.			self transfer: argumentCount - 1				fromIndex: selectorIndex + 1				ofObject: activeContext				toIndex: selectorIndex				ofObject: activeContext.			self pop: 1.			argumentCount _ argumentCount - 1.			self executeNewMethod.  "Recursive xeq affects successFlag"			successFlag _ true]		ifFalse: [messageSelector _ performSelector]!primitivePerformWithArgs	| thisReceiver performSelector argumentArray arraySize index cntxSize |	argumentArray _ self popStack.	arraySize _ self fetchWordLengthOf: argumentArray.	cntxSize _ self fetchWordLengthOf: activeContext.	self success: (self stackPointerIndex + arraySize) < cntxSize.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag		ifTrue: [performSelector _ messageSelector.			messageSelector _ self popStack.			thisReceiver _ self stackTop.			argumentCount _ arraySize.			index _ 1.			[index <= argumentCount]				whileTrue: [self push: (self fetchPointer: index - 1								ofObject: argumentArray).					index _ index + 1].			self lookupMethodInClass:				(self fetchClassOf: thisReceiver).			self success: (self argumentCountOf: newMethod)						= argumentCount.			successFlag				ifTrue: [self executeNewMethod.  "Recursive xeq affects successFlag"						successFlag _ true]				ifFalse: [self unPop: argumentCount.						self push: messageSelector.						self push: argumentArray.						argumentCount _ 2.						messageSelector _ performSelector]]	ifFalse: [self unPop: 1]!primitiveValue	| blockContext blockArgumentCount initialIP |	blockContext _ self stackValue: argumentCount.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self success: argumentCount = blockArgumentCount.	successFlag		ifTrue: [self transfer: argumentCount				fromIndex: self stackPointerIndex - argumentCount + 1				ofObject: activeContext				toIndex: TempFrameStart				ofObject: blockContext.			"Assume: The call to transfer:... makes blockContext a root if necessary,			 allowing use to use unchecked stored in the following code."			self pop: argumentCount + 1.			initialIP _ self fetchPointer: InitialIPIndex	ofObject: blockContext.			self storePointerUnchecked: InstructionPointerIndex ofObject: blockContext				withValue: initialIP.			self storeStackPointerValue: argumentCount	inContext: blockContext.			self storePointerUnchecked: CallerIndex		ofObject: blockContext				withValue: activeContext.			self newActiveContext: blockContext]!primitiveValueWithArgs	| argumentArray blockContext blockArgumentCount arrayArgumentCount initialIP |	argumentArray _ self popStack.	blockContext _ self popStack.	blockArgumentCount _ self argumentCountOfBlock: blockContext.	self assertClassOf: argumentArray is: (self splObj: ClassArray).	successFlag ifTrue: [		arrayArgumentCount _ self fetchWordLengthOf: argumentArray.		self success: arrayArgumentCount = blockArgumentCount].	successFlag ifTrue: [		self transfer: arrayArgumentCount			fromIndex: 0			ofObject: argumentArray			toIndex: TempFrameStart			ofObject: blockContext.		"Assume: The call to transfer:... makes blockContext a root if necessary,		 allowing use to use unchecked stored in the following code."		initialIP _ self fetchPointer: InitialIPIndex			ofObject: blockContext.		self storePointerUnchecked: InstructionPointerIndex	ofObject: blockContext			withValue: initialIP.		self storeStackPointerValue: arrayArgumentCount	inContext: blockContext.		self storePointerUnchecked: CallerIndex				ofObject: blockContext			withValue: activeContext.		self newActiveContext: blockContext.	] ifFalse: [self unPop: 2].! !!Interpreter methodsFor: 'processes'!addLastLink: proc toList: aList	"Add the given process to the given linked list and set the backpointer	of process to its new list."	| lastLink |	(self isEmptyList: aList) ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: proc.	] ifFalse: [		lastLink _ self fetchPointer: LastLinkIndex ofObject: aList.		self storePointer: NextLinkIndex ofObject: lastLink withValue: proc.	].	self storePointer: LastLinkIndex ofObject: aList withValue: proc.	self storePointer: MyListIndex   ofObject:  proc withValue: aList.!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now |	self inline: false.	now _ self ioMSecs.	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500.  "msecs to wait before next call to ioProcessEvents"	].	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [ ^ self synchronousSignal: sema ].	].!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP.	].!isEmptyList: aLinkedList	^ (self fetchPointer: FirstLinkIndex ofObject: aLinkedList) = nilObj!primitiveResume	| proc |	proc _ self stackTop.  "rcvr"	"self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess))."	successFlag ifTrue: [ self resume: proc ].!primitiveSignal	| sema |	sema _ self stackTop.  "rcvr"	self assertClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [ self synchronousSignal: sema ].!primitiveSuspend	| activeProc |	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	self success: self stackTop = activeProc.	successFlag ifTrue: [		self pop: 1.		self push: nilObj.		self transferTo: self wakeHighestPriority.	].!primitiveWait	| sema excessSignals activeProc |	sema _ self stackTop.  "rcvr"	self assertClassOf: sema is: (self splObj: ClassSemaphore).	successFlag ifTrue: [		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: sema.		excessSignals > 0 ifTrue: [			self storeInteger: ExcessSignalsIndex				ofObject: sema withValue: excessSignals - 1.		] ifFalse: [			activeProc _ self fetchPointer: ActiveProcessIndex								 ofObject: self schedulerPointer.			self addLastLink: activeProc toList: sema.			self transferTo: self wakeHighestPriority.		].	].!putToSleep: aProcess	"Save the given process on the scheduler process list for its priority."	| priority processLists processList |	priority _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	processLists _ self fetchPointer: ProcessListsIndex ofObject: self schedulerPointer.	processList _ self fetchPointer: priority - 1 ofObject: processLists.	self addLastLink: aProcess toList: processList.!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients who set signalLowSpace or interruptPending should also set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		interruptCheckCounter _ 1000.		self checkForInterrupts.	].!removeFirstLinkOfList: aList	"Remove the first process from the given linked list."	| first last next |	first _ self fetchPointer: FirstLinkIndex ofObject: aList.	last  _ self fetchPointer: LastLinkIndex ofObject: aList.	first = last ifTrue: [		self storePointer: FirstLinkIndex ofObject: aList withValue: nilObj.		self storePointer:  LastLinkIndex ofObject: aList withValue: nilObj.	] ifFalse: [		next _ self fetchPointer: NextLinkIndex ofObject: first.		self storePointer: FirstLinkIndex ofObject: aList withValue: next.	].	self storePointer: NextLinkIndex ofObject: first withValue: nilObj.	^ first!resume: aProcess	| activeProc activePriority newPriority |	self inline: false.	activeProc _ self fetchPointer: ActiveProcessIndex						 ofObject: self schedulerPointer.	activePriority _ self quickFetchInteger: PriorityIndex ofObject: activeProc.	newPriority   _ self quickFetchInteger: PriorityIndex ofObject: aProcess.	newPriority > activePriority ifTrue: [		self putToSleep: activeProc.		self transferTo: aProcess.	] ifFalse: [		self putToSleep: aProcess.	].!schedulerPointer	^ self fetchPointer: ValueIndex		ofObject: (self splObj: SchedulerAssociation)!synchronousSignal: aSemaphore	"Signal the given semaphore from within the interpreter."	| excessSignals |	self inline: false.	(self isEmptyList: aSemaphore) ifTrue: [		"no process is waiting on this semaphore"		excessSignals _			self fetchInteger: ExcessSignalsIndex ofObject: aSemaphore.		self storeInteger: ExcessSignalsIndex			ofObject: aSemaphore withValue: excessSignals + 1.	] ifFalse: [		self resume: (self removeFirstLinkOfList: aSemaphore).	].!transferTo: newProc	"Record a process to be awoken on the next interpreter cycle."	| sched oldProc |	sched _ self schedulerPointer.	oldProc _ self fetchPointer: ActiveProcessIndex ofObject: sched.	self storePointer: SuspendedContextIndex ofObject: oldProc withValue: activeContext.	self storePointer: ActiveProcessIndex      ofObject:   sched withValue: newProc.	self newActiveContext:		(self fetchPointer: SuspendedContextIndex ofObject: newProc).	reclaimableContextCount _ 0.!wakeHighestPriority	"Return the highest priority process that is ready to run."	"Note: It is a fatal VM error if there is no runnable process."	| schedLists p processList |	schedLists _ self fetchPointer: ProcessListsIndex				ofObject: self schedulerPointer.	p _ self fetchWordLengthOf: schedLists.	p _ p - 1.  "index of last indexable field"	processList _ self fetchPointer: p ofObject: schedLists.	[self isEmptyList: processList] whileTrue: [		p _ p - 1.		p < 0 ifTrue: [ self error: 'scheduler could not find a runnable process' ].		processList _ self fetchPointer: p ofObject: schedLists.	].	^ self removeFirstLinkOfList: processList! !!Interpreter methodsFor: 'I/O primitives'!fullDisplayUpdate	"Repaint the entire smalltalk screen, ignoring the affected rectangle. Used when the Smalltalk window is brought to the front or uncovered."	| displayObj dispBits w h dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]) ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, 0, w, 0, h)'.	].!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj bitsObj extentX extentY offsetObj offsetX offsetY cursorBitsIndex |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	].	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize.	].	successFlag ifTrue: [		self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)'.		self pop: 1.	].!primitiveBeDisplay	"Record the system Display object."	| rcvr |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		"record the display object both in a variable and in the specialObjectsOop"		self storePointer: TheDisplay ofObject: specialObjectsOop withValue: rcvr.		self pop: 1.	].!primitiveBeep	self ioBeep.!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackTop.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].!primitiveDrawLoop	"Invoke the line drawing primitive."	| rcvr xDelta yDelta |	rcvr _ self stackValue: 2.	xDelta _ self stackIntegerValue: 1.	yDelta _ self stackIntegerValue: 0.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self drawLoopX: xDelta Y: yDelta.		self showDisplayBits.		self pop: 2].!primitiveInputSemaphore	"Register the input semaphore. If the argument is not a Semaphore, unregister the current input semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInputSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveInputWord	"Return an integer indicating the reason for the most recent input interrupt."	self pop: 1.	self pushInteger: 0.	"noop for now"!primitiveInterruptSemaphore	"Register the user interrupt semaphore. If the argument is not a Semaphore, unregister the current interrupt semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheInterruptSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveKbdNext	"Return the next keycode and remove it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioGetKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].!primitiveKbdPeek	"Return the next keycode and without removing it from the input buffer. The low byte is the 8-bit ISO character. The next four bits are the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| keystrokeWord |	self pop: 1.	keystrokeWord _ self ioPeekKeystroke.	keystrokeWord >= 0		ifTrue: [self pushInteger: keystrokeWord]		ifFalse: [self push: nilObj].!primitiveMouseButtons	"Return the mouse button state. The low three bits encode the state of the <red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk modifier bits <cmd><option><ctrl><shift>."	| buttonWord |	self pop: 1.	buttonWord _ self ioGetButtonState.	self pushInteger: buttonWord.!primitiveMousePoint	"Return a Point indicating current position of the mouse. Note that mouse coordinates may be negative if the mouse moves above or to the left of the top-left corner of the Smalltalk window."	| pointWord x y |	self pop: 1.	pointWord _ self ioMousePoint.	x _ self signExtend16: ((pointWord >> 16) bitAnd: 16rFFFF).	y _ self signExtend16: (pointWord bitAnd: 16rFFFF).	self push: (self makePointwithxValue: x  yValue: y).!primitiveScanCharacters	"Invoke the scanCharacters primitive."	| rcvr start stop string rightX stopArray displayFlag |	rcvr _ self stackValue: 6.	start _ self stackIntegerValue: 5.	stop _ self stackIntegerValue: 4.	string _ self stackValue: 3.	rightX _ self stackIntegerValue: 2.	stopArray _ self stackValue: 1.	displayFlag _ self booleanValueOf: (self stackValue: 0).	successFlag ifFalse: [^ nil].	self success: (self loadScannerFrom: rcvr					start: start stop: stop string: string rightX: rightX					stopArray: stopArray displayFlag: displayFlag).	successFlag		ifTrue: [self scanCharacters].	successFlag		ifTrue: [			displayFlag ifTrue: [self showDisplayBits].			self pop: 7.			self push: self stopReason].!primitiveScreenSize	"Return a point indicating the current size of the Smalltalk window."	| pointWord |	self pop: 1.	pointWord _ self ioScreenSize.	self push:		(self makePointwithxValue: ((pointWord >>16) bitAnd: 16rFFFF)						   yValue: (pointWord bitAnd: 16rFFFF)).!primitiveSetInterruptKey	"Set the user interrupt keycode. The keycode is an integer whose encoding is described in the comment for primitiveKbdNext."	| keycode |	keycode _ self popInteger.	successFlag		ifTrue: [ interruptKeycode _ keycode ]		ifFalse: [ self unPop: 1 ].!primitiveWarpBits	"Invoke the warpBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: self argCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self warpBits.		self showDisplayBits.	].!showDisplayBits	"Repaint the portion of the Smalltalk screen bounded by the affected rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk Display object."	| displayObj dispBits w h affectedRectL affectedRectR affectedRectT affectedRectB dispBitsIndex d |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ nil].	self success: ((self isPointers: displayObj) and: [(self lengthOf: displayObj) >= 4]).	successFlag ifTrue: [		dispBits _ self fetchPointer: 0 ofObject: displayObj.		w _ self fetchInteger: 1 ofObject: displayObj.		h _ self fetchInteger: 2 ofObject: displayObj.		d _ self fetchInteger: 3 ofObject: displayObj.	].	successFlag ifTrue: [		affectedRectL _ self affectedLeft.		affectedRectR _ self affectedRight.		affectedRectT _ self affectedTop.		affectedRectB _ self affectedBottom.		dispBitsIndex _ dispBits + BaseHeaderSize.  "index in memory byte array"		self cCode: 'ioShowDisplay(dispBitsIndex, w, h, d, affectedRectL, affectedRectR, affectedRectT, affectedRectB)'.	].! !!Interpreter methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ self cCode: 'dir_Delimitor()'!fileRecordSize	"Return the size of a Smalltalk file record in bytes."	^ self cCode: 'sizeof(SQFile)'.!fileValueOf: objectPointer	"Return a pointer to the first byte of of the file record within the given Smalltalk object, or nil if objectPointer is not a file record."	| fileIndex |	self returnTypeC: 'SQFile *'.	self success:		((self isBytes: objectPointer) and:		 [(self lengthOf: objectPointer) = self fileRecordSize]).	successFlag ifTrue: [		fileIndex _ objectPointer + BaseHeaderSize.		^ self cCode: '(SQFile *) fileIndex'	] ifFalse:  [		^ nil	].!makeDirEntryName: entryName size: entryNameSize	createDate: createDate modDate: modifiedDate	isDir: dirFlag fileSize: fileSize	| modDateOop createDateOop nameString results |	self var: 'entryName' declareC: 'char *entryName'.	"allocate storage for results, remapping newly allocated	 oops in case GC happens during allocation"	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassArray) indexableSize: 5).	self pushRemappableOop:		(self instantiateClass: (self splObj: ClassString) indexableSize: entryNameSize)..	self pushRemappableOop: (self positive32BitIntegerFor: createDate).	self pushRemappableOop: (self positive32BitIntegerFor: modifiedDate).	modDateOop   _ self popRemappableOop.	createDateOop _ self popRemappableOop.	nameString    _ self popRemappableOop.	results         _ self popRemappableOop.	"copy name into Smalltalk string"	0 to: entryNameSize - 1 do: [ :i |		self storeByte: i ofObject: nameString withValue: (entryName at: i).	].	self storePointer: 0 ofObject: results withValue: nameString.	self storePointer: 1 ofObject: results withValue: createDateOop.	self storePointer: 2 ofObject: results withValue: modDateOop.	dirFlag		ifTrue: [ self storePointer: 3 ofObject: results withValue: trueObj ]		ifFalse: [ self storePointer: 3 ofObject: results withValue: falseObj ].	self storePointer: 4 ofObject: results		withValue: (self integerObjectOf: fileSize).	^ results!primitiveDirectoryCreate	| dirName dirNameIndex dirNameSize |	dirName _ self stackTop.	self success: (self isBytes: dirName).	successFlag ifTrue: [		dirNameIndex _ dirName + BaseHeaderSize.		dirNameSize _ self lengthOf: dirName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_Create((char *) dirNameIndex, dirNameSize)').	].	successFlag ifTrue: [		self pop: 1.  "pop dirName; leave rcvr on stack"	].!primitiveDirectoryDelimitor	| ascii |	ascii _ self asciiDirectoryDelimiter.	self success: ((ascii >= 0) and: [ascii <= 255]).	successFlag ifTrue: [		self pop: 1.  "pop rcvr"		self push: (self fetchPointer: ascii ofObject: (self splObj: CharacterTable)).	].!primitiveDirectoryLookup	| index pathName pathNameIndex pathNameSize status entryName entryNameSize createDate modifiedDate dirFlag fileSize |	self var: 'entryName' declareC: 'char entryName[256]'.	index _ self stackIntegerValue: 0.	pathName _ self stackValue: 1.	self success: (self isBytes: pathName).	successFlag ifTrue: [		pathNameIndex _ pathName + BaseHeaderSize.		pathNameSize _ self lengthOf: pathName.	].	successFlag ifTrue: [		status _ self cCode:			'dir_Lookup(				(char *) pathNameIndex, pathNameSize, index,				entryName, &entryNameSize, &createDate, &modifiedDate,				&dirFlag, &fileSize)'.		status = DirNoMoreEntries ifTrue: [			"no more entries; return nil"			self pop: 3.  "pop pathName, index, rcvr"			self push: nilObj.			^ nil		].		status = DirBadPath ifTrue: [ ^ self primitiveFail ].  "bad path"	].	successFlag ifTrue: [		self pop: 3.  "pop pathName, index, rcvr"		self push:			(self makeDirEntryName: entryName size: entryNameSize				createDate: createDate modDate: modifiedDate				isDir: dirFlag fileSize: fileSize).	].!primitiveDirectorySetMacTypeAndCreator	| creatorString typeString fileName creatorStringIndex typeStringIndex fileNameIndex fileNameSize |	creatorString _ self stackTop.	typeString _ self stackValue: 1.	fileName _ self stackValue: 2.	self success: ((self isBytes: creatorString) and: [(self lengthOf: creatorString) = 4]).	self success: ((self isBytes: typeString) and: [(self lengthOf: typeString) = 4]).	self success: (self isBytes: fileName).	successFlag ifTrue: [		creatorStringIndex _ creatorString + BaseHeaderSize.		typeStringIndex _ typeString + BaseHeaderSize.		fileNameIndex _ fileName + BaseHeaderSize.		fileNameSize _ self lengthOf: fileName.	].	successFlag ifTrue: [		self success:			(self cCode: 'dir_SetMacFileTypeAndCreator(				(char *) fileNameIndex, fileNameSize,				(char *) typeStringIndex, (char *) creatorStringIndex)').	].	successFlag ifTrue: [		self pop: 3.  "pop filename, type, creator; leave rcvr on stack"	].!primitiveFileAtEnd	| file atEnd |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ atEnd _ self sqFileAtEnd: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushBool: atEnd.	].!primitiveFileClose	| file |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: self stackTop.	successFlag ifTrue: [ self sqFileClose: file ].	successFlag ifTrue: [ self pop: 1  "pop file; leave rcvr on stack" ].!primitiveFileDelete	| namePointer nameIndex nameSize |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self sqFileDeleteName: nameIndex Size: nameSize.	].	successFlag ifTrue: [ self pop: 1. "pop name, leave rcvr on stack" ].!primitiveFileGetPosition	| file position |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ position _ self sqFileGetPosition: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: position.	].!primitiveFileOpen	| writeFlag namePointer filePointer file nameIndex nameSize |	self var: 'file' declareC: 'SQFile *file'.	writeFlag _ self booleanValueOf: (self stackTop).	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue: [		filePointer _ self instantiateClass: (self splObj: ClassByteArray)						   indexableSize: self fileRecordSize.		file _ self fileValueOf: filePointer.		nameIndex _ namePointer + BaseHeaderSize.		nameSize _ self lengthOf: namePointer.	].	successFlag ifTrue: [		self cCode: 'sqFileOpen(file, nameIndex, nameSize, writeFlag)'.	].	successFlag ifTrue: [		self pop: 3.  "rcvr, name, writeFlag"		self push: filePointer.	].!primitiveFileRead	| count startIndex array file byteSize arrayIndex bytesRead |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesRead _ self sqFile: file Read: (count * byteSize)						 Into: arrayIndex						   At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesRead // byteSize.  "push # of elements read"	].!primitiveFileRename	| oldNamePointer newNamePointer oldNameIndex oldNameSize newNameIndex newNameSize |	newNamePointer _ self stackTop.	oldNamePointer _ self stackValue: 1.	self success: (self isBytes: newNamePointer).	self success: (self isBytes: oldNamePointer).	successFlag ifTrue: [		newNameIndex _ newNamePointer + BaseHeaderSize.		newNameSize _ self lengthOf: newNamePointer.		oldNameIndex _ oldNamePointer + BaseHeaderSize.		oldNameSize _ self lengthOf: oldNamePointer.	].	successFlag ifTrue: [		self sqFileRenameOld: oldNameIndex Size: oldNameSize New: newNameIndex Size: newNameSize.	].	successFlag ifTrue: [		self pop: 2.  "pop new and old names, leave rcvr on stack"	].!primitiveFileSetPosition	| newPosition file |	self var: 'file' declareC: 'SQFile *file'.	newPosition _ self stackIntegerValue: 0.	file _ self fileValueOf: (self stackValue: 1).	successFlag ifTrue: [ self sqFile: file SetPosition: newPosition ].	successFlag ifTrue: [ self pop: 2 "pop position, file; leave rcvr on stack" ].!primitiveFileSize	| file size |	self var: 'file' declareC: 'SQFile *file'.	file _ self fileValueOf: (self stackTop).	successFlag ifTrue: [ size _ self sqFileSize: file ].	successFlag ifTrue: [		self pop: 2.  "rcvr, file"		self pushInteger: size.	].!primitiveFileWrite	| count startIndex array file byteSize arrayIndex bytesWritten |	self var: 'file' declareC: 'SQFile *file'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	file			_ self fileValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [ byteSize _ 4 ]		ifFalse: [ byteSize _ 1 ].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= (self lengthOf: array)]).	successFlag ifTrue: [		arrayIndex _ array + BaseHeaderSize.		"Note: adjust startIndex for zero-origin indexing"		bytesWritten _			self sqFile: file				Write: (count * byteSize)				From: arrayIndex At: ((startIndex - 1) * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, file, array, startIndex, count"		self pushInteger: bytesWritten // byteSize.  "push # of elements written"	].! !!Interpreter methodsFor: 'memory space primitives'!primitiveBytesLeft	"Reports bytes available at this moment. For more meaningful results, calls to this primitive should be preceeded by a full or incremental garbage collection."	self pop: 1.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveFullGC	"Do a quick, incremental garbage collection and return the number of bytes available."	self pop: 1.	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveIncrementalGC	"Do a quick, incremental garbage collection and return the number of bytes immediately available. (Note: more space may be made available by doing a full garbage collection."	self pop: 1.	self incrementalGC.	self pushInteger: (self sizeOfFree: freeBlock).!primitiveLowSpaceSemaphore	"Register the low-space semaphore. If the argument is not a Semaphore, unregister the current low-space Semaphore."	| arg |	arg _ self popStack.	((self fetchClassOf: arg) = (self splObj: ClassSemaphore)) ifTrue: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: arg.	] ifFalse: [		self storePointer: TheLowSpaceSemaphore ofObject: specialObjectsOop withValue: nilObj.	].!primitiveSignalAtBytesLeft	"Set the low-water mark for free space. When the free space falls below this level, the new and new: primitives fail and system attempts to allocate space (e.g., to create a method context) cause the low-space semaphore (if one is registered) to be signalled."	| bytes |	bytes _ self popInteger.	successFlag		ifTrue: [ lowSpaceThreshold _ bytes ]		ifFalse: [			lowSpaceThreshold _ 0.			self unPop: 1.		].! !!Interpreter methodsFor: 'socket primitives'!primitiveInitializeNetwork	| resolverSemaIndex err |	resolverSemaIndex _ self integerValueOf: (self stackTop).	successFlag ifTrue: [		err _ self sqNetworkInit: resolverSemaIndex.		self success: err = 0.	].	successFlag ifTrue: [		self pop: 1.  "pop resolverSemaIndex, leave rcvr on stack"	].!primitiveSocketAbortConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketAbortConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].!primitiveSocketCloseConnection	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketCloseConnection: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].!primitiveSocketConnectionStatus	| s status |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		status _ self sqSocketConnectionStatus: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: status).	].!primitiveSocketConnectToPort	| port addr s |	self var: #s declareC: 'SocketPtr s'.	port _ self integerValueOf: (self stackTop).	addr _ self netAddressToInt: (self stackValue: 1).	s _ self socketValueOf: (self stackValue: 2).	successFlag ifTrue: [		self sqSocket: s ConnectTo: addr Port: port.	].	successFlag ifTrue: [		self pop: 3.  "pop s, addr, port; leave rcvr on stack"	].!primitiveSocketCreate	| semaIndex sendBufSize recvBufSize socketType netType socketOop s |	self var: #s declareC: 'SocketPtr s'.	semaIndex	_ self integerValueOf: (self stackTop).	sendBufSize	_ self integerValueOf: (self stackValue: 1).	recvBufSize	_ self integerValueOf: (self stackValue: 2).	socketType	_ self integerValueOf: (self stackValue: 3).	netType		_ self integerValueOf: (self stackValue: 4).	successFlag ifTrue: [		socketOop _ self instantiateClass: (self splObj: ClassByteArray)						indexableSize: self socketRecordSize.		s _ self socketValueOf: socketOop.		self sqSocket: s CreateNetType: netType SocketType: socketType			RecvBytes: recvBufSize SendBytes: sendBufSize SemaID: semaIndex.		successFlag ifTrue: [			self pop: 6  "netType, socketType, recvBufSize, sendBufSize, semaIndex, rcvr"				thenPush: socketOop.		].	].!primitiveSocketDestroy	| s |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		self sqSocketDestroy: s.	].	successFlag ifTrue: [		self pop: 1.  "pop s; leave rcvr on stack"	].!primitiveSocketError	| s err |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		err _ self sqSocketError: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: err).	].!primitiveSocketListenOnPort	| port s |	self var: #s declareC: 'SocketPtr s'.	port _ self integerValueOf: (self stackTop).	s _ self socketValueOf: (self stackValue: 1).	successFlag ifTrue: [		self sqSocket: s ListenOnPort: port.	].	successFlag ifTrue: [		self pop: 2.  "pop s, port; leave rcvr on stack"	].!primitiveSocketLocalAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketLocalAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].!primitiveSocketLocalPort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketLocalPort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].!primitiveSocketReceiveDataAvailable	| s dataIsAvailable |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		dataIsAvailable _ self sqSocketReceiveDataAvailable: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: dataIsAvailable.	].!primitiveSocketReceiveDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesReceived |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesReceived _			self sqSocket: s				ReceiveDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesReceived // byteSize.  "push # of elements"	].!primitiveSocketRemoteAddress	| s addr |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		addr _ self sqSocketRemoteAddress: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self intToNetAddress: addr).	].!primitiveSocketRemotePort	| s port |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		port _ self sqSocketRemotePort: s.	].	successFlag ifTrue: [		self pop: 2 thenPush: (self integerObjectOf: port).	].!primitiveSocketSendDataBufCount	| count startIndex array s byteSize arrayBase bufStart bytesSent |	self var: #s declareC: 'SocketPtr s'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	array		_ self stackValue: 2.	s			_ self socketValueOf: (self stackValue: 3).	"buffer can be any indexable words or bytes object except CompiledMethod"	self success: (self isWordsOrBytes: array).	(self isWords: array)		ifTrue: [byteSize _ 4]		ifFalse: [byteSize _ 1].	self success: (		(startIndex >= 1) and:		[(count >= 0) and:		[(startIndex + count - 1) <= (self lengthOf: array)]]).	successFlag ifTrue: [		"Note: adjust bufStart for zero-origin indexing"		arrayBase _ array + BaseHeaderSize.		bufStart _ arrayBase + ((startIndex - 1) * byteSize).		bytesSent _			self sqSocket: s				SendDataBuf: bufStart				Count: (count * byteSize).	].	successFlag ifTrue: [		self pop: 5.  "pop rcvr, s, array, startIndex, count"		self pushInteger: bytesSent // byteSize.  "push # of elements"	].!primitiveSocketSendDone	| s done |	self var: #s declareC: 'SocketPtr s'.	s _ self socketValueOf: self stackTop.	successFlag ifTrue: [		done _ self sqSocketSendDone: s.	].	successFlag ifTrue: [		self pop: 2.  "pop s, rcvr"		self pushBool: done.	].!socketRecordSize	"Return the size of a Smalltalk socket record in bytes."	^ self cCode: 'sizeof(SQSocket)'.!socketValueOf: socketOop	"Return a pointer to the first byte of of the socket record within the given Smalltalk object, or nil if socketOop is not a socket record."	| socketIndex |	self returnTypeC: 'SQSocket *'.	self success:		((self isBytes: socketOop) and:		 [(self lengthOf: socketOop) = self socketRecordSize]).	successFlag ifTrue: [		socketIndex _ socketOop + BaseHeaderSize.		^ self cCode: '(SQSocket *) socketIndex'	] ifFalse:  [		^ nil	].! !!Interpreter methodsFor: 'resolver primitives'!intToNetAddress: addr	"Convert the given 32-bit integer into an internet network address represented as a four-byte ByteArray."	| netAddressOop |	netAddressOop _		self instantiateSmallClass: (self splObj: ClassByteArray)			sizeInBytes: 8			fill: 0.	self storeByte: 0 ofObject: netAddressOop		withValue: ((addr >> 24) bitAnd: 16rFF).	self storeByte: 1 ofObject: netAddressOop		withValue: ((addr >> 16) bitAnd: 16rFF).	self storeByte: 2 ofObject: netAddressOop		withValue: ((addr >> 8) bitAnd: 16rFF).	self storeByte: 3 ofObject: netAddressOop		withValue: (addr bitAnd: 16rFF).	^ netAddressOop!netAddressToInt: oop	"Convert the given internet network address (represented as a four-byte ByteArray) into a 32-bit integer. Fail if the given oop is not a four-byte ByteArray."	| sz |	self assertClassOf: oop is: (self splObj: ClassByteArray).	successFlag ifTrue: [		sz _ self lengthOf: oop.		sz = 4 ifFalse: [^ self primitiveFail]].	successFlag ifTrue: [		^ (self fetchByte: 3 ofObject: oop) +		  ((self fetchByte: 2 ofObject: oop) << 8) +		  ((self fetchByte: 1 ofObject: oop) << 16) +		  ((self fetchByte: 0 ofObject: oop) << 24) ].!primitiveResolverAbortLookup	self sqResolverAbort.!primitiveResolverAddressLookupResult	| sz s |	sz _ self sqResolverAddrLookupResultSize.	successFlag ifTrue: [		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self sqResolverAddrLookup: (self cCoerce: (s + BaseHeaderSize) to: 'char *')			Result: sz.	].	successFlag ifTrue: [		self pop: 1 thenPush: s.	].!primitiveResolverError	| err |	err _ self sqResolverError.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: err).	].!primitiveResolverLocalAddress	| addr |	addr _ self sqResolverLocalAddress.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].!primitiveResolverNameLookupResult	| addr |	addr _ self sqResolverNameLookupResult.	successFlag ifTrue: [		self pop: 1 thenPush: (self intToNetAddress: addr).	].!primitiveResolverStartAddressLookup	| addr |	addr _ self netAddressToInt: self stackTop.	successFlag ifTrue: [		self sqResolverStartAddrLookup: addr.	].	successFlag ifTrue: [		self pop: 1.  "pop addr, leave rcvr on stack"	].!primitiveResolverStartNameLookup	| name sz |	name _ self stackTop.	self assertClassOf: name is: (self splObj: ClassString).	successFlag ifTrue: [		sz _ self lengthOf: name.		self sqResolverStartName: (self cCoerce: (name + BaseHeaderSize) to: 'char *')			Lookup: sz.	].	successFlag ifTrue: [		self pop: 1.  "pop name, leave rcvr on stack"	].!primitiveResolverStatus	| status |	status _ self sqResolverStatus.	successFlag ifTrue: [		self pop: 1 thenPush: (self integerObjectOf: status).	].! !!Interpreter methodsFor: 'sound primitives'!primitiveConstantFill	"Fill the receiver, which must be an indexable bytes or words objects, with the given integer value."	| fillValue rcvr rcvrIsBytes end i |	fillValue _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: (self isWordsOrBytes: rcvr).	rcvrIsBytes _ self isBytes: rcvr.	rcvrIsBytes ifTrue: [		self success: ((fillValue >= 0) and: [fillValue <= 255]).	].	successFlag ifTrue: [		end _ rcvr + (self sizeBitsOf: rcvr).		i _ rcvr + BaseHeaderSize.		rcvrIsBytes ifTrue: [			[i < end] whileTrue: [				self byteAt: i put: fillValue.				i _ i + 1.			].		] ifFalse: [			[i < end] whileTrue: [				self longAt: i put: fillValue.				i _ i + 4.			].		].		self pop: 1.  "pop fillValue; leave rcvr on stack"	].!primitiveShortAt	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Return the contents of the given index. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	index _ self stackIntegerValue: 0.	rcvr _ self stackValue: 1.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		value _ self cCode: '*((short int *) addr)'.		self pop: 2.  "pop rcvr, index"		self pushInteger: value.  "push element value"	].!primitiveShortAtPut	"Treat the receiver, which can be indexible by either bytes or words, as an array of signed 16-bit values. Set the contents of the given index to the given value. Note that the index specifies the i-th 16-bit entry, not the i-th byte or word."	| index rcvr sz addr value |	value _ self stackIntegerValue: 0.	index _ self stackIntegerValue: 1.	rcvr _ self stackValue: 2.	self success: ((self isIntegerObject: rcvr) not and: [self isWordsOrBytes: rcvr]).	successFlag ifFalse: [ ^ nil ].	sz _ ((self sizeBitsOf: rcvr) - BaseHeaderSize) // 2.  "number of 16-bit fields"	self success: ((index >= 1) and: [index <= sz]).	self success: ((value >= -32768) and: [value <= 32767]).	successFlag ifTrue: [		addr _ rcvr + BaseHeaderSize + (2 * (index - 1)).		self cCode: '*((short int *) addr) = value'.		self pop: 2.  "pop index and value; leave rcvr on stack"	].!primitiveSoundAvailableSpace	"Returns the number of sample frames of available sound output buffer space."	| frames |	frames _ self cCode: 'snd_AvailableSpace()'.  "-1 if sound output not started"	self success: frames >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: frames).	].!primitiveSoundPlaySamples	"Output a buffer's worth of sound samples."	| startIndex buf frameCount framesPlayed |	startIndex _ self stackIntegerValue: 0.	buf _ self stackValue: 1.	frameCount _ self stackIntegerValue: 2.	self success: (self isWords: buf).	self success: (		(startIndex >= 1) and:		[(startIndex + frameCount - 1) <= (self lengthOf: buf)]).	successFlag ifTrue: [		framesPlayed _			self cCode: 'snd_PlaySamplesFromAtLength(frameCount, buf + 4, startIndex - 1)'.		self success: framesPlayed >= 0.	].	successFlag ifTrue: [		self pop: 4.  "pop frameCount, buf, startIndex, rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].!primitiveSoundPlaySilence	"Output a buffer's worth of silence. Returns the number of sample frames played."	| framesPlayed |	framesPlayed _ self cCode: 'snd_PlaySilence()'.  "-1 if sound output not started"	self success: framesPlayed >= 0.	successFlag ifTrue: [		self pop: 1.  "rcvr"		self push: (self positive32BitIntegerFor: framesPlayed).	].!primitiveSoundStart	"Start the double-buffered sound output with the given buffer size and sample rate."	| stereoFlag samplesPerSec bufFrames |	stereoFlag		_ self booleanValueOf: (self stackValue: 0).	samplesPerSec	_ self stackIntegerValue: 1.	bufFrames		_ self stackIntegerValue: 2.	successFlag ifTrue: [		self success: (self cCode: 'snd_Start(bufFrames, samplesPerSec, stereoFlag)').	].	successFlag ifTrue: [		self pop: 3.  "pop bufFrames, samplesPerSec, stereoFlag; leave rcvr on stack"	].!primitiveSoundStop	"Stop double-buffered sound output."	self cCode: 'snd_Stop()'.  "leave rcvr on stack"	! !!Interpreter methodsFor: 'other primitives'!primitiveClipboardText	"When called with a single string argument, post the string to the clipboard. When called with zero arguments, return a string containing the current clipboard contents."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self assertClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self clipboardWrite: sz From: (s + BaseHeaderSize) At: 0.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self clipboardSize.		s _ self instantiateClass: (self splObj: ClassString)					  indexableSize: sz.		self clipboardRead: sz Into: (s + BaseHeaderSize) At: 0.		self pop: 1.  "rcvr"		self push: s.	].!primitiveExitToDebugger	self error: 'Exit to debugger at user request'.!primitiveFlushCache	"Clear the method lookup cache. This must be done after every programming change."	self flushMethodCache.!primitiveImageName	"When called with a single string argument, record the string as the current image file name. When called with zero arguments, return a string containing the current image file name."	| s sz |	argumentCount = 1 ifTrue: [		s _ self stackTop.		self assertClassOf: s is: (self splObj: ClassString).		successFlag ifTrue: [			sz _ self stSizeOf: s.			self imageNamePut: (s + BaseHeaderSize) Length: sz.			self pop: 1.  "pop s, leave rcvr on stack"		].	] ifFalse: [		sz _ self imageNameSize.		s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.		self imageNameGet: (s + BaseHeaderSize) Length: sz.		self pop: 1.  "rcvr"		self push: s.	].!primitiveMillisecondClock	"Return the value of the millisecond clock as an integer. Note that the millisecond clock wraps around every so many days."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioMSecs).!primitiveNoop	"A placeholder for primitives that haven't been implemented or are being withdrawn gradually. Just absorbs any arguments and returns the receiver."	self pop: argumentCount.  "pop args, leave rcvr on stack"!primitiveQuit	self ioExit.!primitiveReadJoystick	"Read an input word from the joystick with the given index."	| index |	index _ self stackIntegerValue: 0.	successFlag ifTrue: [		self pop: 2.  "index, rcvr"		self push: (self positive32BitIntegerFor: (self joystickRead: index)).	].!primitiveSecondsClock	"Return the number of seconds since January 1, 1901 as an integer."	self pop: 1.  "pop rcvr"	self push: (self positive32BitIntegerFor: self ioSeconds).!primitiveSignalAtMilliseconds	"Cause the time semaphore, if one has been registered, to be signalled when the millisecond clock is greater than or equal to the given tick value. A tick value of zero turns off timer interrupts."	| tick sema |	tick _ self popInteger.	sema _ self popStack.	successFlag ifTrue: [		(self fetchClassOf: sema) = (self splObj: ClassSemaphore) ifTrue: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: sema.			nextWakeupTick _ tick.		] ifFalse: [			self storePointer: TheTimerSemaphore ofObject: specialObjectsOop withValue: nilObj.			nextWakeupTick _ 0.		].	] ifFalse: [		self unPop: 2.  "sema, tick"	].!primitiveSnapshot	| activeProc dataSize rcvr |	"save the state of the current process and save it on the scheduler queue"	self storeContextRegisters: activeContext.	activeProc _		self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self storePointer: SuspendedContextIndex		    ofObject: activeProc		  withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self incrementalGC.  "maximimize space for forwarding table"	self fullGC.	dataSize _ freeBlock - (self startOfMemory).	"Assume: all objects are below the start of the free block"	successFlag ifTrue: [		rcvr _ self popStack.  "pop rcvr"		self push: trueObj.		self writeImageFile: dataSize.		self pop: 1.  "pop true"	].	successFlag		ifTrue: [ self push: falseObj ]		ifFalse: [ self push: rcvr ].!primitiveSpecialObjectsOop	"Return the oop of the SpecialObjectsArray."	self pop: 1.	self push: specialObjectsOop.!primitiveVMPath	"Return a string containing the path name of VM's directory."	| s sz |	sz _ self vmPathSize.	s _ self instantiateClass: (self splObj: ClassString) indexableSize: sz.	self vmPathGet: (s + BaseHeaderSize) Length: sz.	self pop: 1.  "rcvr"	self push: s.! !!Interpreter methodsFor: 'debug printing'!cr	"For testing in Smalltalk, this method should be overridden in a subclass."	self printf: '\n'.!print: s	"For testing in Smalltalk, this method should be overridden in a subclass."	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.!printChar: aByte	"For testing in Smalltalk, this method should be overridden in a subclass."	self putchar: aByte.!printNum: n	"For testing in Smalltalk, this method should be overridden in a subclass."	self cCode: 'printf("%ld", (long) n)'.! !!Interpreter methodsFor: 'debug support'!allAccessibleObjectsOkay	"Ensure that all accessible objects in the heap are okay."	| oop |	oop _ self firstAccessibleObject.	[oop = nil] whileFalse: [		self okayFields: oop.		oop _ self accessibleObjectAfter: oop.	].!findClassOfMethod: meth forReceiver: rcvr	| currClass classDict classDictSize methodArray i done |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i < (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [ ^currClass ].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self fetchClassOf: rcvr    "method not found in superclass chain"!findSelectorOfMethod: meth forReceiver: rcvr	| currClass done classDict classDictSize methodArray i |	currClass _ self fetchClassOf: rcvr.	done _ false.	[done] whileFalse: [		classDict _ self fetchPointer: MessageDictionaryIndex ofObject: currClass.		classDictSize _ self fetchWordLengthOf: classDict.		methodArray _ self fetchPointer: MethodArrayIndex ofObject: classDict.		i _ 0.		[i <= (classDictSize - SelectorStart)] whileTrue: [			meth = (self fetchPointer: i ofObject: methodArray) ifTrue: [				^(self fetchPointer: i + SelectorStart ofObject: classDict)			].			i _ i + 1.		].		currClass _ self fetchPointer: SuperclassIndex ofObject: currClass.		done _ currClass = nilObj.	].	^self splObj: SelectorDoesNotUnderstand    "method not found in superclass chain"!okayActiveProcessStack	| cntxt |	cntxt _ activeContext.		[cntxt = nilObj] whileFalse: [		self okayFields: cntxt.		cntxt _ (self fetchPointer: SenderIndex ofObject: cntxt).	].!okayFields: oop	"If this is a pointers object, check that its fields are all okay oops."	| i fieldOop |	(oop = nil or: [oop = 0]) ifTrue: [ ^true ].	(self isIntegerObject: oop) ifTrue: [ ^true ].	self okayOop: oop.	self oopHasOkayClass: oop.	(self isPointers: oop) ifFalse: [ ^true ].	i _ (self lengthOf: oop) - 1.	[i >= 0] whileTrue: [		fieldOop _ self fetchPointer: i ofObject: oop.		(self isIntegerObject: fieldOop) ifFalse: [			self okayOop: fieldOop.			self oopHasOkayClass: fieldOop.		].		i _ i - 1.	].!okayInterpreterObjects	| oopOrZero oop |	self okayFields: nilObj.	self okayFields: falseObj.	self okayFields: trueObj.	self okayFields: specialObjectsOop.	self okayFields: activeContext.	self okayFields: method.	self okayFields: receiver.	self okayFields: theHomeContext.	self okayFields: messageSelector.	self okayFields: newMethod.	1 to: MethodCacheEntries do: [ :i |		oopOrZero _ methodCache at: i.		oopOrZero = 0 ifFalse: [			self okayFields: (methodCache at: i).							"selector"			self okayFields: (methodCache at: i + MethodCacheEntries).		"class"			self okayFields: (methodCache at: i + (2 * MethodCacheEntries)).	"method"		].	].	1 to: remapBufferCount do: [ :i |		oop _ remapBuffer at: i.		(self isIntegerObject: oop) ifFalse: [			self okayFields: oop.		].	].	self okayActiveProcessStack.!okayOop: oop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt |	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((0 < oop) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ 4) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz _ self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type _ self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= 4) and: [(self headerType: oop - 4) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= 8) and:		 [(self headerType: oop - 8) = type and:		 [(self headerType: oop - 4) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt _ self formatOf: oop.	((fmt = 4) | (fmt = 5) | (fmt = 7))		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	((self longAt: oop) bitAnd: 16r20000000) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: RootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true!oopHasOkayClass: oop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oopClass formatMask behaviorFormatBits oopFormatBits |	self okayOop: oop.	oopClass _ self fetchClassOf: oop.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask _ 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask _ 16rF00 ].	behaviorFormatBits _ (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits _ (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true!printCallStack	| ctxt home methodClass methodSel |	ctxt _ activeContext.	[ctxt = nilObj] whileFalse: [		(self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)			ifTrue: [ home _ self fetchPointer: HomeIndex ofObject: ctxt ]			ifFalse: [ home _ ctxt ].		methodClass _			self findClassOfMethod: (self fetchPointer: MethodIndex ofObject: home)					   forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		methodSel _			self findSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)						 forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).		self printNum: ctxt.		self print: ' '.		ctxt = home ifFalse: [ self print: '[] in ' ].		self printNameOfClass: methodClass count: 5.		self print: '>'.		self printStringOf: methodSel.		self cr.		ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt).	].!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = 16r20 ifTrue: [		self printNameOfClass: (self fetchPointer: 6 "thisClass" ofObject: classOop) count: cnt - 1.		self print: ' class'.	] ifFalse: [		self printStringOf: (self fetchPointer: 6 "name" ofObject: classOop).	].!printStringOf: oop	| fmt cnt i |	fmt _ self formatOf: oop.	fmt < 8 ifTrue: [ ^nil ].	cnt _ 100 min: (self lengthOf: oop).	i _ 0.	[i < cnt] whileTrue: [		self printChar: (self fetchByte: i ofObject: oop).		i _ i + 1.	].!reportContexts	| cntxt big small |	big _ 0.	cntxt _ freeLargeContexts.	[cntxt = NilContext] whileFalse: [		big _ big + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	small _ 0.	cntxt _ freeSmallContexts.	[cntxt = NilContext] whileFalse: [		small _ small + 1.		cntxt _ self fetchWord: 0 ofObject: cntxt.	].	self print: 'Recycled contexts: '.	self printNum: small; print: ' small, '.	self printNum: big; print: ' large ('.	self printNum: (big * LargeContextSize) + (small * SmallContextSize).	self print: ' bytes)'.	self cr.! !!Interpreter methodsFor: 'image save/restore'!byteSwapByteObjects	"Byte-swap the words of all bytes objects in the image, including Strings, ByteArrays, and CompiledMethods. This returns these objects to their original byte ordering after blindly byte-swapping the entire image. For compiled methods, byte-swap only their bytecodes part."	| oop fmt wordAddr methodHeader end |	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			fmt _ self formatOf: oop.			fmt >= 8 ifTrue: [  "oop contains bytes"				wordAddr _ oop + BaseHeaderSize.				fmt >= 12 ifTrue: [					"compiled method; start after methodHeader and literals"					methodHeader _ self longAt: oop + BaseHeaderSize.					wordAddr _ wordAddr + 4 + (((methodHeader >> 10) bitAnd: 16rFF) * 4).				].				end _ oop + (self sizeBitsOf: oop).				[wordAddr < end] whileTrue: [					self longAt: wordAddr put: (self byteSwapped: (self longAt: wordAddr)).					wordAddr _ wordAddr + 4.				].			]. 		].		oop _ self objectAfter: oop.	].!byteSwapped: w	"Return the given integer with its bytes in the reverse order."	^ ((w bitShift: -24) bitAnd: 16rFF) +	  ((w bitShift: -8) bitAnd: 16rFF00) +	  ((w bitShift: 8) bitAnd: 16rFF0000) +	  ((w bitShift: 24) bitAnd: 16rFF000000)!checkImageVersionFrom: f	"Read and verify the image file version number and return true if the the given image file needs to be byte-swapped. As a side effect, position the file stream just after the version number of the image header. This code prints a warning and does a hard-exit if it cannot find a valid version number."	"This code is based on C code by Ian Piumarta."	| expectedVersion version firstVersion |	self var: #f declareC: 'FILE *f'.	expectedVersion _ self imageFormatVersion.	"check the version number"	self fileSeek: f position: 0.	version _ firstVersion _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try with byte reversal"	self fileSeek: f position: 0.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"try skipping the first 512 bytes (prepended by certain Mac file transfer utilities)"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: false.	(version = expectedVersion) ifTrue: [^ false].	"try skipping the first 512 bytes with byte reversal"	self fileSeek: f position: 512.	version _ self getLongFromFile: f swap: true.	(version = expectedVersion) ifTrue: [^ true].	"hard failure; abort"	self print: 'This interpreter (vers. '.	self printNum: expectedVersion.	self print: ' cannot read image file (vers. '.	self printNum: firstVersion.	self cr.	self ioExit.!fileSeek: f position: pos	"Position the given file stream to the given offset from the start of the file."	self var: #f declareC: 'FILE *f'.	self cCode: 'fseek(f, pos, SEEK_SET)'.!getLongFromFile: f swap: swapFlag	"Return the next 4-byte word of the given file, byte-swapped according to the given flag."	| w |	self var: #f declareC: 'FILE *f'.	self cCode: 'fread(&w, sizeof(char), 4, f)'.	swapFlag		ifTrue: [^ self byteSwapped: w]		ifFalse: [^ w].!imageFormatVersion	"Return a magic constant that changes when the image format changes. Since the image reading code uses this to detect byte ordering, one must avoid version numbers that are invariant under byte reversal."	^ 6502!positionOfFile: f	"Return the current position of the given file stream."	self var: #f declareC: 'FILE *f'.	^ self cCode: 'ftell(f)'!putLong: n toFile: f	"Append the given 4-byte long word to the given file in this platforms 'natural' byte order. (Bytes will be swapped, if necessary, when the image is read on a different platform.) Set successFlag to false if the write fails."	| wordsWritten |	self var: #f declareC: 'FILE *f'.	wordsWritten _ self cCode: 'fwrite(&n, sizeof(int), 1, f)'.	self success: wordsWritten = 1.!readImageFromFile: f HeapSize: desiredHeapSize	"Read an image from the given file stream, allocating the given amount of memory to its object heap. Fail if the image has an unknown format or requires more than the given amount of memory."	"Details: This method detects when the image was stored on a machine with the opposite byte ordering from this machine and swaps the bytes automatically. Furthermore, it allows the header information to start 512 bytes into the file, since some file transfer programs for the Macintosh apparently prepend a Mac-specific header of this size. Note that this same 512 bytes of prefix area could also be used to store an exec command on Unix systems, allowing one to launch Smalltalk by invoking the image name as a command."	"This code is based on C code by Ian Piumarta and Smalltalk code by Tim Rowledge. Many thanks to both of you!!!!"	| swapBytes headerStart headerSize dataSize oldBaseAddr minimumMemory memStart bytesRead bytesToShift |	self var: #f declareC: 'FILE *f'.	swapBytes _ self checkImageVersionFrom: f.	headerStart _ (self positionOfFile: f) - 4.  "record header start position"	headerSize			_ self getLongFromFile: f swap: swapBytes.	dataSize				_ self getLongFromFile: f swap: swapBytes.	oldBaseAddr			_ self getLongFromFile: f swap: swapBytes.	specialObjectsOop		_ self getLongFromFile: f swap: swapBytes.	lastHash			_ self getLongFromFile: f swap: swapBytes.	savedWindowSize	_ self getLongFromFile: f swap: swapBytes.	lastHash = 0 ifTrue: [		"lastHash wasn't stored (e.g. by the cloner); use 999 as the seed"		lastHash _ 999].	"compare memory requirements with availability".	minimumMemory _ dataSize + 80000.  "need at least 80K of breathing room"	desiredHeapSize < minimumMemory		ifTrue: [ self error: 'Insufficient memory for this image' ].	"allocate a contiguous block of memory for the Squeak heap"	memory _ self cCode: '(unsigned char *) malloc(desiredHeapSize)'.	memory = nil		ifTrue: [ self error: 'Failed to allocate memory for the heap' ].	memStart _ self startOfMemory.	memoryLimit _ (memStart + desiredHeapSize) - 24.  "decrease memoryLimit a tad for safety"	endOfMemory _ memStart + dataSize.	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"read in the image in bulk, then swap the bytes if necessary"	bytesRead _ self cCode: 'fread(memory, sizeof(unsigned char), dataSize, f)'.	bytesRead ~= dataSize		ifTrue: [ self error: 'Read failed or premature end of image file' ].	swapBytes ifTrue: [self reverseBytesInImage].	"compute difference between old and new memory base addresses"	bytesToShift _ memStart - oldBaseAddr.	self initializeInterpreter: bytesToShift.  "adjusts all oops to new location"	^ dataSize!reverseBytesInImage	"Byte-swap all words in memory after reading in the entire image file with bulk read. Contributed by Tim Rowledge."	| addr lastAddr |	"First, byte-swap every word in the image. This fixes objects headers."	addr _ self startOfMemory.	lastAddr _ endOfMemory.	[addr < lastAddr] whileTrue: [		self longAt: addr put: (self byteSwapped: (self longAt: addr)).		addr _ addr + 4.	].	"Second, return the bytes of bytes-type objects to their orginal order."	self byteSwapByteObjects.!writeImageFile: imageBytes	| headerStart headerSize f bytesWritten |	self var: #f declareC: 'FILE *f'.	"local constants"	headerStart _ 0.  "change to 512 to leave room for a Unix exec string"	headerSize _ 64.  "header size in bytes; do not change!!"	f _ self cCode: 'fopen(imageName, "wb")'.	f = nil ifTrue: [		"could not open the image file for writing"		self success: false.		^ nil ].	self cCode: '/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */'.	"position file to start of header"	self fileSeek: f position: headerStart.	self putLong: (self imageFormatVersion) toFile: f.	self putLong: headerSize toFile: f.	self putLong: imageBytes toFile: f.	self putLong: (self startOfMemory) toFile: f.	self putLong: specialObjectsOop toFile: f.	self putLong: lastHash toFile: f.	self putLong: (self ioScreenSize) toFile: f.	successFlag ifFalse: [		"write or seek failure"		self cCode: 'fclose(f)'.		^ nil ].	"position file after the header"	self fileSeek: f position: headerStart + headerSize.	"write the image data"	bytesWritten _ self cCode: 'fwrite(memory, sizeof(unsigned char), imageBytes, f)'.	self success: bytesWritten = imageBytes.	self cCode: 'fclose(f)'.	"set Mac file type and creator; this is a noop on other platforms"	self cCode: 'dir_SetMacFileTypeAndCreator(imageName, strlen(imageName), "STim", "FAST")'.! !!Interpreter class methodsFor: 'initialization'!initialize	"Interpreter initialize"	super initialize.  "initialize ObjectMemory constants"	self initializeAssociationIndex.	self initializeBytecodeTable.	self initializeCharacterIndex.	self initializeClassIndices.	self initializeContextIndices.	self initializeDirectoryLookupResultCodes.	self initializeMessageIndices.	self initializeMethodIndices.	self initializePointIndices.	self initializePrimitiveTable.	self initializeSchedulerIndices.	self initializeSmallIntegers.	self initializeStreamIndices.	MethodCacheEntries _ 512. 	MethodCacheMask _ MethodCacheEntries - 1.	(MethodCacheEntries bitAnd: MethodCacheMask) = 0		ifFalse: [ self error: 'MethodCacheEntries must be a power of two' ].	MethodCacheSize _ MethodCacheEntries * 4.	CacheProbeMax _ 3.!initializeAssociationIndex	ValueIndex _ 1!initializeBytecodeTable	"Interpreter initializeBytecodeTable"	"Note: This table will be used to generate a C switch statement."	BytecodeTable _ Array new: 256.	self table: BytecodeTable from:	#(		(  0  15 pushReceiverVariableBytecode)		( 16  31 pushTemporaryVariableBytecode)		( 32  63 pushLiteralConstantBytecode)		( 64  95 pushLiteralVariableBytecode)		( 96 103 storeAndPopReceiverVariableBytecode)		(104 111 storeAndPopTemporaryVariableBytecode)		(112 pushReceiverBytecode)		(113 pushConstantTrueBytecode)		(114 pushConstantFalseBytecode)		(115 pushConstantNilBytecode)		(116 pushConstantMinusOneBytecode)		(117 pushConstantZeroBytecode)		(118 pushConstantOneBytecode)		(119 pushConstantTwoBytecode)		(120 returnReceiver)		(121 returnTrue)		(122 returnFalse)		(123 returnNil)		(124 returnTopFromMethod)		(125 returnTopFromBlock)		(126 unknownBytecode)		(127 unknownBytecode)		(128 extendedPushBytecode)		(129 extendedStoreBytecode)		(130 extendedStoreAndPopBytecode)		(131 singleExtendedSendBytecode)		(132 doubleExtendedDoAnythingBytecode)		(133 singleExtendedSuperBytecode)		(134 secondExtendedSendBytecode)		(135 popStackBytecode)		(136 duplicateTopBytecode)		(137 pushActiveContextBytecode)		(138 143 experimentalBytecode)		(144 151 shortUnconditionalJump)		(152 159 shortConditionalJump)		(160 167 longUnconditionalJump)		(168 171 longJumpIfTrue)		(172 175 longJumpIfFalse)		"176-191 were sendArithmeticSelectorBytecode"		(176 bytecodePrimAdd)		(177 bytecodePrimSubtract)		(178 bytecodePrimLessThan)		(179 bytecodePrimGreaterThan)		(180 bytecodePrimLessOrEqual)		(181 bytecodePrimGreaterOrEqual)		(182 bytecodePrimEqual)		(183 bytecodePrimNotEqual)		(184 bytecodePrimMultiply)		(185 bytecodePrimDivide)		(186 bytecodePrimMod)		(187 bytecodePrimMakePoint)		(188 bytecodePrimBitShift)		(189 bytecodePrimDiv)		(190 bytecodePrimBitAnd)		(191 bytecodePrimBitOr)			"192-207 were sendCommonSelectorBytecode"		(192 bytecodePrimAt)		(193 bytecodePrimAtPut)		(194 bytecodePrimSize)		(195 bytecodePrimNext)		(196 bytecodePrimNextPut)		(197 bytecodePrimAtEnd)		(198 bytecodePrimEquivalent)		(199 bytecodePrimClass)		(200 bytecodePrimBlockCopy)		(201 bytecodePrimValue)		(202 bytecodePrimValueWithArg)		(203 bytecodePrimDo)		(204 bytecodePrimNew)		(205 bytecodePrimNewWithArg)		(206 bytecodePrimPointX)		(207 bytecodePrimPointY)		(208 255 sendLiteralSelectorBytecode)	).!initializeCharacterIndex	CharacterValueIndex _ 0!initializeClassIndices	"Class Class"	SuperclassIndex _ 0.	MessageDictionaryIndex _ 1.	InstanceSpecificationIndex _ 2.	"Fields of a message dictionary"	MethodArrayIndex _ 1.	SelectorStart _ 2!initializeContextIndices	"Class MethodContext"	SenderIndex _ 0.	InstructionPointerIndex _ 1.	StackPointerIndex _ 2.	MethodIndex _ 3.	ReceiverIndex _ 5.	TempFrameStart _ 6.	"Class BlockContext"	CallerIndex _ 0.	BlockArgumentCountIndex _ 3.	InitialIPIndex _ 4.	HomeIndex _ 5!initializeDirectoryLookupResultCodes	DirEntryFound _ 0.	DirNoMoreEntries _ 1.	DirBadPath _ 2.!initializeMessageIndices	MessageSelectorIndex _ 0.	MessageArgumentsIndex _ 1.	MessageSize _ 2!initializeMethodIndices	"Class CompiledMethod"	HeaderIndex _ 0.	LiteralStart _ 1!initializePointIndices	XIndex _ 0.	YIndex _ 1!initializePrimitiveTable	"Interpreter initializePrimitiveTable"	"Note: This table will be used to generate a C switch statement."	PrimitiveTable _ Array new: 256.	self table: PrimitiveTable from: 	#(		"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveFail)		(119 primitiveFail)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)				"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		(126 primitiveFail)		(127 primitiveFail)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveFail)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveFail)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Unimplemented Primitives (230-249)"		(230 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveFail)		(255 primitiveFail)	).!initializeSchedulerIndices	"Class ProcessorScheduler"	ProcessListsIndex _ 0.	ActiveProcessIndex _ 1.	"Class LinkedList"	FirstLinkIndex _ 0.	LastLinkIndex _ 1.	"Class Semaphore"	ExcessSignalsIndex _ 2.	"Class Link"	NextLinkIndex _ 0.	"Class Process"	SuspendedContextIndex _ 1.	PriorityIndex _ 2.	MyListIndex _ 3!initializeSmallIntegers	"SmallIntegers"	ConstMinusOne _ Interpreter new integerObjectOf: -1.	ConstZero _ Interpreter new integerObjectOf: 0.	ConstOne _ Interpreter new integerObjectOf: 1.	ConstTwo _ Interpreter new integerObjectOf: 2!initializeStreamIndices	StreamArrayIndex _ 0.	StreamIndexIndex _ 1.	StreamReadLimitIndex _ 2.	StreamWriteLimitIndex _ 3.!table: anArray from: specArray	"SpecArray is an array of either (index selector) or (index1 index2 selector)."	| contiguous |	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [ self error: 'Non-contiguous table entry' ].		spec size = 2 ifTrue: [			anArray at: ((spec at: 1) + 1) put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			(spec at: 1) to: (spec at: 2) do: [ :i | anArray at: (i + 1) put: (spec at: 3) ].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].! !!Interpreter class methodsFor: 'constants'!bytecodeTable	^ BytecodeTable!primitiveTable	^ PrimitiveTable! !!Interpreter class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'methodCache'		declareC: 'int methodCache[', (MethodCacheSize + 1) printString, ']'.	aCCodeGenerator var: 'localIP' declareC: 'char * localIP'.	aCCodeGenerator var: 'localSP' declareC: 'char * localSP'.!patchInterp: fileName	"Interpreter patchInterp: 'Squeak VM PPC'"	"This will patch out the unneccesary range check (a compare	 and branch) in the inner interpreter dispatch loop."	"NOTE: You must edit in the Interpeter file name, and the	 number of instructions (delta) to count back to find the compare	 and branch that we want to get rid of."	| delta f code len remnant i |	delta _ 6.	f _ FileStream fileNamed: fileName.	f binary.	code _ Bitmap new: (len _ f size) // 4.	f nextInto: code.	remnant _ f next: len - (code size * 4).	i _ 0.	["Look for a BCTR instruction"	(i _ code indexOf: 16r4E800420 startingAt: i + 1 ifAbsent: [0]) > 0] whileTrue: [		"Look for a CMPLWI FF, 6 instrs back"	       ((code at: i - delta) bitAnd: 16rFFE0FFFF) = 16r280000FF ifTrue: [	       	"Copy dispatch instrs back over the compare"			SelectionMenu notify: 'Patching at ', i hex.			0 to: delta - 2 do: [ :j |				code at: (i - delta) + j put: (code at: (i - delta) + j + 2).			].		].	].	f position: 0; nextPutAll: code; nextPutAll: remnant.	f close.!translate: fileName doInlining: inlineFlag	"Time millisecondsToRun: [		Interpreter translate: 'InterpTest.c' doInlining: true.		Smalltalk beep]"	| cg |	BitBltSimulation initialize.	Interpreter initialize.	ObjectMemory initialize.	cg _ CCodeGenerator new initialize.	cg addClass: BitBltSimulation.	cg addClass: Interpreter.	cg addClass: ObjectMemory.	BitBltSimulation declareCVarsIn: cg.	Interpreter declareCVarsIn: cg.	ObjectMemory declareCVarsIn: cg.	cg storeCodeOnFile: fileName doInlining: inlineFlag.! !InterpreterSimulator comment:'This class defines basic memory access and primitive simulation so that the Interpreter can run simulated in the Squeak environment.  It also defines a number of handy object viewing methods to facilitate pawing around in the object memory.To see the thing actually run, you could (after backing up this image and changes), execute	(InterpreterSimulator new openOn: Smalltalk imageName) testand be patient both to wait for things to happen, and to accept various things that may go wrong depending on how large or unusual your image may be.  We usually do this with a small and simple benchmark image.'!!InterpreterSimulator methodsFor: 'initialization'!close  "close any files that ST may have opened"	filesOpen do: [:f | f setToEnd; close]!initialize	"Initialize the InterpreterSimulator when running the interpreter inside Smalltalk. The primary responsibility of this method is to allocate Smalltalk Arrays for variables that will be declared as statically-allocated global arrays in the translated code."	"initialize class variables"	ObjectMemory initialize.	Interpreter initialize.	methodCache _ Array new: MethodCacheSize.	rootTable _ Array new: RootTableSize.	remapBuffer _ Array new: RemapBufferSize.	"initialize InterpreterSimulator variables used for debugging"	byteCount _ 0.	sendCount _ 0.	traceOn _ true.	myBitBlt _ BitBltSimulation new setInterpreter: self.	displayForm _ nil.  "displayForm is created in response to primitiveBeDisplay"	filesOpen _ OrderedCollection new.!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 4)		byte2: (bytes at: 3)		byte3: (bytes at: 2)		byte4: (bytes at: 1)!openOn: fileName	"(InterpreterSimulator new openOn: 'clonex.image') test"	self openOn: fileName extraMemory: 500000.!openOn: fileName extraMemory: extraBytes	"InterpreterSimulator new openOn: 'clone.im' extraMemory: 100000"	| f version headerSize count oldBaseAddr bytesToShift |	"open image file and read the header"	f _ FileStream oldFileNamed: fileName.	imageName _ f fullName.	f binary; readOnly.	version _ self nextLongFrom: f.  "current version: 6501"	headerSize _ self nextLongFrom: f.	endOfMemory _ self nextLongFrom: f.  "first unused location in heap"	oldBaseAddr _ self nextLongFrom: f.  "object memory base address of image"	specialObjectsOop _ self nextLongFrom: f.	lastHash _ 999.  "Should be loaded from, and saved to the image header"	"allocate interpreter memory"	memoryLimit _ endOfMemory + extraBytes.	"read in the image"	f position: headerSize.	memory _ Bitmap new: memoryLimit // 4.	count _ f readInto: memory startingAt: 1 count: endOfMemory // 4.	count ~= (endOfMemory // 4) ifTrue: [self halt].	f close.	self initialize.	bytesToShift _ 0 - oldBaseAddr.  "adjust pointers for zero base address"	endOfMemory _ endOfMemory.	self initializeInterpreter: bytesToShift.	checkAssertions _ false.!startOfMemory	"Return the start of object memory."	^ 0! !!InterpreterSimulator methodsFor: 'testing'!findNewMethodInClass: class"	| cName |	traceOn ifTrue:		[cName _ (self sizeBitsOf: class) = 16r20			ifTrue: ['class ' , (self nameOfClass: (self fetchPointer: 6 ofObject: class))]			ifFalse: [(self nameOfClass: class)].		self cr; print: cName , '>>' , (self stringOf: messageSelector)].""(self stringOf: messageSelector) = 'raisedToInteger:' ifTrue: [self halt]."	sendCount _ sendCount + 1.	super findNewMethodInClass: class.!profile: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profile: 60000"	Transcript clear.	byteCount _ 0.	MessageTally spyOn: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	].!profileSends: nBytecodes	"(InterpreterSimulator new openOn: 'clonex.image') profileSends: 5000"	Transcript clear.	byteCount _ 0.	MessageTally tallySendsTo: self inBlock: [		self internalizeIPandSP.		[byteCount < nBytecodes] whileTrue: [			currentBytecode _ self fetchByte.			self dispatchOn: currentBytecode in: BytecodeTable.			byteCount _ byteCount + 1.		].		self externalizeIPandSP.	] showTree: true.!test	Transcript clear.	byteCount _ 0.	self internalizeIPandSP.	[true] whileTrue: [		currentBytecode _ self fetchByte.		self dispatchOn: currentBytecode in: BytecodeTable.		byteCount _ byteCount + 1.	].	self externalizeIPandSP.!testBecome	"Become some young things.  AA testBecome    "	| array list1 list2 p1 p2 p3 p4 |	array _ self splObj: ClassArray.	list1 _ self instantiateClass: array indexableSize: 2.	list2 _ self instantiateClass: array indexableSize: 2.	p1 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p1.	self storePointer: 0 ofObject: list1 withValue: p1.	p2 _ self instantiateClass: (self splObj: ClassPoint) indexableSize: 0.	self push: p2.	self storePointer: 1 ofObject: list1 withValue: p2.	p3 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p3.	self storePointer: 0 ofObject: list2 withValue: p3.	p4 _ self instantiateClass: (self splObj: ClassMessage) indexableSize: 0.	self push: p4.	self storePointer: 1 ofObject: list2 withValue: p4.	(self become: list1 with: list2) ifFalse: [self error: 'failed'].	self popStack = p2 ifFalse: [self halt].	self popStack = p1 ifFalse: [self halt].	self popStack = p4 ifFalse: [self halt].	self popStack = p3 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list1) = p3 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list1) = p4 ifFalse: [self halt].	(self fetchPointer: 0 ofObject: list2) = p1 ifFalse: [self halt].	(self fetchPointer: 1 ofObject: list2) = p2 ifFalse: [self halt].!validate	| oop prev |	Transcript show: 'Validating...'.	oop _ self firstObject.	[oop < endOfMemory] whileFalse: [		self validate: oop.		prev _ oop.  "look here if debugging prev obj overlapping this one"		oop _ self objectAfter: oop.	].	Transcript show: 'done.'; cr!validate: oop	| header type cc sz fmt nextChunk | 	header _ self longAt: oop.	type _ header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz _ (header >> 2) bitAnd: 16r3F.	(sz = 1) & (type = 3) ifTrue: [self halt].	"object only 4 bytes long"	(sz = 1) & (type = 0) ifTrue: [self halt].	"object only 4 bytes long"	(self isFreeObject: oop)		ifTrue: [ nextChunk _ oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk _ oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + 8)) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + 4)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt _ (header >> 8) bitAnd: 16rF.	cc _ (header >> 12) bitAnd: 31.	cc > 15 ifTrue: [self halt].	type = 0 ifTrue:		["three-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-8) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-4) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop-4) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt].		sz <= 1 ifTrue: [self halt]].	fmt = 0 ifTrue: [self halt].	fmt = 4 ifTrue: [self halt].	fmt = 5 ifTrue: [self halt].	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + 4)) ifFalse: [self halt]].!validateActiveContext	self validateOopsIn: activeContext.	"debug -- test if messed up"!validateOopsIn: object	| fieldPtr limit former header | 	"for each oop in me see if it is legal"	fieldPtr _ object + BaseHeaderSize.	"first field"	limit _ object + (self lastPointerOf: object).	"a good field"	[fieldPtr > limit] whileFalse: [		former _ self longAt: fieldPtr.		self validOop: former.		fieldPtr _ fieldPtr + 4].	"class"	header _ self baseHeader: object.	(header bitAnd: 16r1F000 "compact class bits") = 0 ifTrue: [			former _ (self classHeader: object) bitAnd: 16rFFFFFFFC.		self validOop: former].!validOop: oop	"halt if invalid active object"	(oop bitAnd: 1) = 1 ifTrue: [^ self].	(oop bitAnd: 3) = 0 ifFalse: [self halt].	oop >= endOfMemory ifTrue: [self halt].	"could test if within the first large freeblock"	(self longAt: oop) = 4 ifTrue: [self halt].	(self headerType: oop) = 2 ifTrue: [self halt].	"free object"! !!InterpreterSimulator methodsFor: 'debug printing'!cr	traceOn ifTrue: [ Transcript cr; endEntry ].!print: s	traceOn ifTrue: [ Transcript show: s ]!printChar: aByte	traceOn ifTrue: [ Transcript nextPut: aByte asCharacter ].!printNum: anInteger	traceOn ifTrue: [ Transcript show: anInteger printString ].! !!InterpreterSimulator methodsFor: 'debug support'!charsOfLong: long	^ (4 to: 1 by: -1) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]!classAndSelectorOfMethod: meth forReceiver: rcvr	| mClass dict length methodArray |	mClass _ self fetchClassOf: rcvr.	[dict _ self fetchPointer: MessageDictionaryIndex ofObject: mClass.	length _ self fetchWordLengthOf: dict.	methodArray _ self fetchPointer: MethodArrayIndex ofObject: dict.	0 to: length-SelectorStart-1 do: 		[:index | 		meth = (self fetchPointer: index ofObject: methodArray) 			ifTrue: [^ Array				with: mClass				with: (self fetchPointer: index + SelectorStart ofObject: dict)]].	mClass _ self fetchPointer: SuperclassIndex ofObject: mClass.	mClass = nilObj]		whileFalse: [].	^ Array		with: (self fetchClassOf: rcvr)		with: (self splObj: SelectorDoesNotUnderstand)!compactClassAt: ccIndex	"Index must be between 1 and compactClassArray size. (A zero compact class index in the base header indicate that the class is in the class header word.)"	| classArray |	classArray _ self fetchPointer: CompactClasses ofObject: specialObjectsOop.	^ self fetchPointer: (ccIndex - 1) ofObject: classArray!dumpHeader: hdr	| cc |	^ String streamContents:		[:strm |		strm nextPutAll: '<cc=', (cc_ (hdr >> 12) bitAnd: 16r1F) hex.			cc > 0 ifTrue:				[strm nextPutAll: ':' , (self nameOfClass: (self compactClassAt: cc))].			strm nextPutAll: '>'.		strm nextPutAll: '<ft=', ((hdr bitShift: -8) bitAnd: 16rF) hex , '>'.		strm nextPutAll: '<sz=', (hdr bitAnd: 16rFC) hex , '>'.		strm nextPutAll: '<hdr=', (#(big class gcMark short) at: (hdr bitAnd: 3) +1) , '>'.		]!dumpMethodHeader: hdr	^ String streamContents:		[:strm |		strm nextPutAll: '<nArgs=', ((hdr >> 25) bitAnd: 16r1F) printString , '>'.		strm nextPutAll: '<nTemps=', ((hdr >> 19) bitAnd: 16r3F) printString , '>'.		strm nextPutAll: '<lgCtxt=', ((hdr >> 18) bitAnd: 16r1) printString , '>'.		strm nextPutAll: '<nLits=', ((hdr >> 10) bitAnd: 16rFF) printString , '>'.		strm nextPutAll: '<prim=', ((hdr >> 1) bitAnd: 16r1FF) printString , '>'.		]!headerStart: oop	^ (self extraHeaderBytes: oop) negated!hexDump100: oop	| byteSize val |	^ String streamContents:		[:strm |		byteSize _ 256.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (oop+a) hex8; space; space; 				nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			strm nextPutAll: (self charsOfLong: val).			strm space; space; nextPutAll: (oop+a) printString]]!hexDump: oop	| byteSize val |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		byteSize _ 256 min: (self sizeBitsOf: oop)-4.		(self headerStart: oop) to: byteSize by: 4 do:			[:a | val _ self longAt: oop+a.			strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8;				space; space.			a=0				ifTrue: [strm nextPutAll: (self dumpHeader: val)]				ifFalse: [strm nextPutAll: (self charsOfLong: val)]]]!longPrint: oop	| lastPtr val lastLong hdrType prevVal |	(self isIntegerObject: oop) ifTrue: [^ self shortPrint: oop].	^ String streamContents:		[:strm |		lastPtr _ 256 min: (self lastPointerOf: oop).		hdrType _ self headerType: oop.		hdrType = 2 ifTrue: [lastPtr _ 0].		prevVal _ 0.		(self headerStart: oop) to: lastPtr by: 4 do:			[:a | val _ self longAt: oop+a.			(a > 0 and: [(val = prevVal) & (a ~= lastPtr)])			ifTrue:			[prevVal = (self longAt: oop+a-8) ifFalse: [strm cr; nextPutAll: '        ...etc...']]			ifFalse:			[strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 				space; space; space; nextPutAll: val hex8; space; space.			a=-8 ifTrue: [strm nextPutAll: 'size = ' , (val - hdrType) hex].			a=-4 ifTrue: [strm nextPutAll: '<' , (self nameOfClass: (val - hdrType)) , '>'].			a=0 ifTrue: [strm cr; tab; nextPutAll: (self dumpHeader: val)].			a>0 ifTrue: [strm nextPutAll: (self shortPrint: val)].			a=4 ifTrue: [(self fetchClassOf: oop) = (self splObj: ClassCompiledMethod) ifTrue:							[strm cr; tab; nextPutAll: (self dumpMethodHeader: val)]]].			prevVal _ val].		lastLong _ 256 min: (self sizeBitsOf: oop) - 4.		hdrType = 2			ifTrue: ["free" strm cr; nextPutAll: (oop+(self longAt: oop)-2) hex;				space; space; nextPutAll: (oop+(self longAt: oop)-2) printString]			ifFalse: [lastPtr+4 to: lastLong by: 4 do:				[:a | val _ self longAt: oop+a.				strm cr; nextPutAll: (a<16 ifTrue: [' ', a hex] ifFalse: [a hex]); 					space; space; space.				strm nextPutAll: val hex8; space; space;						nextPutAll: (self charsOfLong: val)]].	]!nameOfClass: classOop	(self sizeBitsOf: classOop) = 16r20 ifTrue:		[^ (self nameOfClass:				(self fetchPointer: 6 "thisClass" ofObject: classOop)) , ' class'].	^ self stringOf: (self fetchPointer: 6 "name" ofObject: classOop)!printStack	| ctxt classAndSel home |	ctxt _ activeContext.	^ String streamContents:		[:strm |			[home _ (self fetchClassOf: ctxt) = (self splObj: ClassBlockContext)				ifTrue: [self fetchPointer: HomeIndex ofObject: ctxt]				ifFalse: [ctxt].			classAndSel _ self				classAndSelectorOfMethod: (self fetchPointer: MethodIndex ofObject: home)				forReceiver: (self fetchPointer: ReceiverIndex ofObject: home).			strm cr; nextPutAll: ctxt hex8.			ctxt = home ifFalse: [strm nextPutAll: ' [] in'].			strm space; nextPutAll: (self nameOfClass: classAndSel first).			strm nextPutAll: '>>'; nextPutAll: (self shortPrint: classAndSel last).			(ctxt _ (self fetchPointer: SenderIndex ofObject: ctxt)) = nilObj]				whileFalse: [].		]!shortPrint: oop	| name classOop |	(self isIntegerObject: oop) ifTrue: [^ '=' , (self integerValueOf: oop) printString , ' (' , (self integerValueOf: oop) hex , ')'].	classOop _ self fetchClassOf: oop.	(self sizeBitsOf: classOop) =16r20 ifTrue: [^ 'class ' , (self nameOfClass: oop)].	name _ self nameOfClass: classOop.	name size = 0 ifTrue: [name _ '??'].	name = 'String' ifTrue: [^ (self stringOf: oop) printString].	name = 'Symbol' ifTrue: [^ '#' , (self stringOf: oop)].	name = 'Character' ifTrue: [^ '=' ,			(Character value: (self integerValueOf: (self fetchPointer: 0 ofObject: oop))) printString].	name = 'UndefinedObject' ifTrue: [^ 'nil'].	name = 'False' ifTrue: [^ 'false'].	name = 'True' ifTrue: [^ 'true'].	name = 'Float' ifTrue: [^ '=' , (self floatValueOf: oop) printString].	name = 'Association' ifTrue: [^ '(' ,				(self shortPrint: (self longAt: oop + BaseHeaderSize)) ,				' -> ' ,				(self longAt: oop + BaseHeaderSize + 4) hex8 , ')'].	('AEIOU' includes: name first)		ifTrue: [^ 'an ' , name]		ifFalse: [^ 'a ' , name]!stringOf: oop	| size long nLongs chars |	^ String streamContents:		[:strm |		size _ 100 min: (self stSizeOf: oop).		nLongs _ size-1//4+1.		1 to: nLongs do:			[:i | long _ self longAt: oop + BaseHeaderSize + (i-1*4).			chars _ self charsOfLong: long.			strm nextPutAll: (i=nLongs							ifTrue: [chars copyFrom: 1 to: size-1\\4+1]							ifFalse: [chars])]]! !!InterpreterSimulator methodsFor: 'interpreter shell'!dispatchOn: anInteger in: selectorArray	"Simulate a case statement via selector table lookup.	The given integer must be between 0 and selectorArray size-1, inclusive.	For speed, no range test is done, since it is done by the at: operation."	"assert: (anInteger >= 0) | (anInteger < selectorArray size)""Transcript cr; show: anInteger hex , '  ' , (selectorArray at: (anInteger + 1)).Sensor waitButton.Sensor yellowButtonPressed ifTrue: [self halt]."	self perform: (selectorArray at: (anInteger + 1)).!fetchByte	^ self byteAt: (localIP _ localIP + 1).!isIntegerValue: valueWord 	^ valueWord >= 16r-40000000 and: [valueWord <= 16r3FFFFFFF]! !!InterpreterSimulator methodsFor: 'I/O primitives'!ioProcessEvents!primitiveBeCursor	"Take note of the current cursor"	| cursorObj bitsObj offsetObj ourCursor |	cursorObj _ self stackTop.	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 4]).	successFlag ifTrue:		[bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj.		ourCursor _ Cursor			extent: (self fetchInteger: 1 ofObject: cursorObj)@(self fetchInteger: 2 ofObject: cursorObj)			fromArray: ((1 to: 16) collect: [:i |					((self fetchWord: i-1 ofObject: bitsObj) >> 16) bitAnd: 16rFFFF])			offset: (self fetchInteger: 0 ofObject: offsetObj)@(self fetchInteger: 1 ofObject: offsetObj)].	successFlag		ifTrue: [ourCursor show]		ifFalse: [self primitiveFail].!primitiveBeDisplay	"Extended to create a scratch Form for use by showDisplayBits."	| rcvr destWidth destHeight destDepth |	rcvr _ self stackTop.	self success: ((self isPointers: rcvr) and: [(self lengthOf: rcvr) >= 4]).	successFlag ifTrue: [		destWidth _ self fetchInteger: 1 ofObject: rcvr.		destHeight _ self fetchInteger: 2 ofObject: rcvr.		destDepth _ self fetchInteger: 3 ofObject: rcvr.	].	successFlag ifTrue: [		"create a scratch form the same size as Smalltalk displayObj"		displayForm _ Form extent: destWidth @ destHeight							depth: destDepth.	].	super primitiveBeDisplay.!primitiveKbdNext	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]		ifFalse: [self push: nilObj]!primitiveKbdPeek	self pop: 1.	Sensor keyboardPressed		ifTrue: [self pushInteger: Sensor keyboardPeek asciiValue]		ifFalse: [self push: nilObj]!primitiveMouseButtons	| rcvr relPt buttons |	self pop: 1.	buttons _ 0.	Sensor redButtonPressed ifTrue: [buttons _ buttons + 4].	Sensor yellowButtonPressed ifTrue: [buttons _ buttons + 2].	Sensor blueButtonPressed ifTrue: [buttons _ buttons + 1].	self pushInteger: buttons!primitiveMousePoint	| relPt |	self pop: 1.	displayForm == nil		ifTrue: [self push: (self makePointwithxValue: 99 yValue: 66)]		ifFalse: [relPt _ Sensor cursorPoint - (Display extent - displayForm extent - (10@10)).				self push: (self makePointwithxValue: relPt x yValue: relPt y)]!primitiveScreenSize  "Dummied for now"	self pop: 1.	self push: (self makePointwithxValue: 640 yValue: 480).!showDisplayBits	| displayObj destBits sRaster dRaster destDepth pixPerWord srcWord destWord |	displayObj _ self splObj: TheDisplay.	self targetForm = displayObj ifFalse: [^ self].	destBits _ self fetchPointer: 0 ofObject: displayObj.	destDepth _ self fetchInteger: 3 ofObject: displayObj.	pixPerWord _ 32 // destDepth.	sRaster _ displayForm width + (pixPerWord-1) // pixPerWord * 4.	dRaster _ sRaster // 4.	myBitBlt affectedTop to: myBitBlt affectedBottom - 1 do:		[:y | 		srcWord _ destBits + 4 + (y * sRaster).		destWord _ y*dRaster.		1 to: dRaster do: 			[:i | displayForm bits at: destWord + i put: (self longAt: srcWord).			srcWord _ srcWord + 4]].	Display border: ((displayForm boundingBox expandBy: 2)						translateBy: self displayLocation) width: 2.	displayForm displayAt: self displayLocation! !!InterpreterSimulator methodsFor: 'I/O primitives support'!copyBits	^ myBitBlt copyBits!displayLocation	^ Display extent - displayForm extent - (10@10)!drawLoopX: xDelta Y: yDelta	^ myBitBlt drawLoopX: xDelta Y: yDelta!ioMSecs	"Return the value of the millisecond clock."	^ Time millisecondClockValue!ioProcessEventsEveryMSecs: mSecs	"Noop during simulation."!loadBitBltFrom: bbObj	^ myBitBlt loadBitBltFrom: bbObj!loadScannerFrom: bbObj	start: start stop: stop string: string rightX: rightX	stopArray: stopArray displayFlag: displayFlag	^ myBitBlt loadScannerFrom: bbObj		start: start stop: stop string: string rightX: rightX		stopArray: stopArray displayFlag: displayFlag!scanCharacters	^ myBitBlt scanCharacters!stopReason	^ myBitBlt stopReason!targetForm	^ myBitBlt targetForm! !!InterpreterSimulator methodsFor: 'file primitives'!asciiDirectoryDelimiter	^ FileDirectory pathNameDelimiter asciiValue!fileValueOf: integerPointer	"Convert the (integer) fileID to the actual fileStream it uses"	self success: (self isIntegerObject: integerPointer).	successFlag		ifTrue: [^ filesOpen at: (self integerValueOf: integerPointer)]		ifFalse: [^ nil]!primitiveFileDelete	| namePointer |	namePointer _ self stackTop.	self success: (self isBytes: namePointer).	self success: (FileDirectory includesKey: (self stringOf: namePointer)).	successFlag ifTrue: [		FileDirectory removeKey: (self stringOf: namePointer) ifAbsent: [].	].	successFlag ifTrue: [		self pop: 1.  "fileName; leave rcvr on stack"	].!primitiveFileOpen	| namePointer writeFlag fileName |	writeFlag _ self booleanValueOf: self stackTop.	namePointer _ self stackValue: 1.	self success: (self isBytes: namePointer).	successFlag ifTrue:		[fileName _ self stringOf: namePointer.		filesOpen addLast: (writeFlag			ifTrue: [(FileStream fileNamed: fileName) binary]			ifFalse: [(FileDirectory default includesKey: fileName)				ifTrue: [(FileStream oldFileNamed: fileName) readOnly; binary]				ifFalse: [^ self primitiveFail]]).		self pop: 3.  "rcvr, name, write"		self pushInteger: filesOpen size]!primitiveFileRename	| oldNamePointer newNamePointer f |	oldNamePointer _ self stackTop.	newNamePointer _ self stackValue: 1.	self success: (self isBytes: oldNamePointer).	self success: (self isBytes: newNamePointer).	self success: (FileDirectory includesKey: (self stringOf: oldNamePointer)).	self success: (FileDirectory includesKey: (self stringOf: newNamePointer)) not.	successFlag ifTrue: [		f _ FileStream oldFileNamed: (self stringOf: oldNamePointer).		f rename: (self stringOf: newNamePointer).		f close.	].	successFlag ifTrue: [		self pop: 2.  "oldName, newName; leave rcvr on stack"	].!primitiveImageName	"Note: For now, this only implements getting, not setting, the image file name."	| result imageNameSize |	self pop: 1.	imageNameSize _ imageName size.	result _ self instantiateClass: (self splObj: ClassString)				   indexableSize: imageNameSize.	1 to: imageNameSize do:		[:i | self storeByte: i-1 ofObject: result			withValue: (imageName at: i) asciiValue].	self push: result.!sqFile: file Read: count Into: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file atEnd ifTrue: [ ^ i - startIndex ].		self byteAt: byteArrayIndex + i put: file next.	].	^ count!sqFile: file SetPosition: newPosition	file position: newPosition.!sqFile: file Write: count From: byteArrayIndex At: startIndex	startIndex to: (startIndex + count - 1) do: [ :i |		file nextPut: (self byteAt: byteArrayIndex + i).	].	^ count!sqFileAtEnd: file	^ file atEnd!sqFileClose: file	file close.!sqFileGetPosition: file	^ file position!sqFileSize: file	^ file size!vmPathGet: stringBase Length: stringSize	| pathName stringOop |	pathName _ Smalltalk vmPath.	stringOop _ stringBase - BaseHeaderSize. "Due to C call in Interp"	1 to: stringSize do:		[:i | self storeByte: i-1 ofObject: stringOop			withValue: (pathName at: i) asciiValue].!vmPathSize	^ Smalltalk vmPath size! !!InterpreterSimulator methodsFor: 'float primitives'!floatObjectOf: float	| result sign exponent mantissa mantSize long0 long1 |true ifTrue: [	"No conversion needed in Apple ST"	long0 _ float at: 1.	long1 _ float at: 2.] ifFalse: ["Following code useful when porting to different formats"	((float at: 1) = 0 and: [(float at: 2) = 0])		ifTrue: [long0 _ 0. long1 _ 0]		ifFalse: 	["Read from the PPS 32-bit format"	sign _ ((float at: 1) bitAnd: 16r8000) bitShift: -15.				"1-bit sign"	exponent _ (((float at: 1) bitShift: -7) bitAnd: 16rFF) - 16r80. 		"8-bit expt"	mantissa _ (((float at: 1) bitAnd: 16r7F) bitShift: 16) + (float at: 2).	"23 bit mantissa"	mantSize _ 23.	"Convert to first 32 bits of 64-bit IEEE format"	long0 _ (sign bitShift: 31)										"1-bit sign"			+ (exponent + 16r400 bitShift: 20)						"11-bit expt"			+ ((mantissa bitShift: 20 - mantSize) bitAnd: 16rFFFFF).	"20 bit mantissa"	]. ]. "end of porting code"	result _ self instantiateClass: (self splObj: ClassFloat) indexableSize: 2.	self storeWord: 0 ofObject: result withValue: long0.	self storeWord: 1 ofObject: result withValue: long1.	^ result!floatValueOf: objectPointer	| float len long0 long1 sign exponent mantissa mantSize |	(self isIntegerObject: objectPointer)		ifTrue: [^ (self integerValueOf: objectPointer) asFloat].	(self fetchClassOf: objectPointer) = (self splObj: ClassFloat)		ifFalse: [self success: false.  ^0.0].	len _ self fetchWordLengthOf: objectPointer.	(len between: 2 and: 3)		ifFalse: [self success: false.  ^0.0].	"FIRST convert image formats to sign/exponent/mantissa"	len = 2 ifTrue:  		["Normal 64-bit IEEE format"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.true ifTrue: [float _ Float new: 2.  "No conversion needed for AST"			float at: 1 put: long0.			float at: 2 put: long1.			^ float].		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -20) bitAnd: 16r7FF) - 16r400.		"11-bit exponent"		mantissa _ ((long0 bitAnd: 16rFFFFF) bitShift: 32) + long1.		"52-bit mantissa"		mantSize _ 52]		ifFalse:  		["Weird 80-bit Apple format -- will go away soon"		long0 _ self fetchWord: 0 ofObject: objectPointer.		long1 _ self fetchWord: 1 ofObject: objectPointer.		long0 = 0 ifTrue: [^ 0.0].		sign _ (long0 bitAnd: 16r80000000) bitShift: -31.				"1-bit sign"		exponent _ ((long0 bitShift: -16) bitAnd: 16r7FFF) - 16r4000. 	"15-bit exponent"		"Note: drop the (redundant) high bit (16r8000) of mantissa"		mantissa _ ((long0 bitAnd: 16r7FFF) bitShift: 32) + long1.		"47-bit mantissa"		mantSize _ 47].	"THEN convert sign/exponent/mantissa to host format"	float _ Float new: 2.  "PPSST FP uses 2 16-bit words"	float at: 1 put: (sign bitShift: 15)							"1-bit sign"				+ (exponent + 16r80 bitShift: 7)				"8-bit expt"				+ ((mantissa bitShift: 7 - mantSize) bitAnd: 16r7F).	"7 bits of mantissa"	float at: 2 put: ((mantissa bitShift: 16 - (mantSize - 7)) bitAnd: 16rFFFF).  "16 more bits of mantissa"	^ float!popFloat	^ self floatValueOf: (self popStack)!primitiveArctan	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr arcTan]		ifFalse: [self unPop: 1].!primitiveAsFloat	"Use host Smalltalk's native function."	| arg |	arg _ self popInteger.	successFlag		ifTrue: [self pushFloat: arg asFloat]		ifFalse: [self unPop: 1].!primitiveExp	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr exp]		ifFalse: [self unPop: 1].!primitiveExponent	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr exponent]		ifFalse: [self unPop: 1].!primitiveFloatAdd	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr + arg]		ifFalse: [self unPop: 2].!primitiveFloatDivide	"Note: This method overridden here because the translator (intentionally) doesn't translate the / operator (since the semantics of C / are the semantics of Smalltalk //). This allows the version of this method to be translated to express division as //, which translates to the float division operator /."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag ifTrue: [self success: arg ~= 0.0].	successFlag		ifTrue: [self pushFloat: rcvr / arg]		ifFalse: [self unPop: 2].!primitiveFloatEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr = arg]		ifFalse: [self unPop: 2].!primitiveFloatGreaterOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr >= arg]		ifFalse: [self unPop: 2].!primitiveFloatGreaterThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr > arg]		ifFalse: [self unPop: 2].!primitiveFloatLessOrEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr <= arg]		ifFalse: [self unPop: 2].!primitiveFloatLessThan	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr < arg]		ifFalse: [self unPop: 2].!primitiveFloatMultiply	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr * arg]		ifFalse: [self unPop: 2].!primitiveFloatNotEqual	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushBool: rcvr ~= arg]		ifFalse: [self unPop: 2].!primitiveFloatSubtract	"Use host Smalltalk's native function."	| rcvr arg |	arg _ self popFloat.	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr - arg]		ifFalse: [self unPop: 2].!primitiveFractionalPart	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr fractionPart]		ifFalse: [self unPop: 1].!primitiveLogN	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr ln]		ifFalse: [self unPop: 1].!primitiveSine	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sin]		ifFalse: [self unPop: 1].!primitiveSquareRoot	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushFloat: rcvr sqrt]		ifFalse: [self unPop: 1].!primitiveTimesTwoPower	"Use Smalltalk's native function (tho could just fail)"	| rcvr arg |	arg _ self popInteger.	rcvr _ self popFloat.	successFlag		ifTrue: [ self pushFloat: (rcvr timesTwoPower: arg) ]		ifFalse: [ self unPop: 2 ].!primitiveTruncated	"Use host Smalltalk's native function."	| rcvr |	rcvr _ self popFloat.	successFlag		ifTrue: [self pushInteger: rcvr truncated]		ifFalse: [self unPop: 1].!pushFloat: f	self push: (self floatObjectOf: f).! !!InterpreterSimulator methodsFor: 'memory access'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ (3 - lowBits) * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress put: longWord!longAt: byteAddress	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1!longAt: byteAddress put: a32BitValue	"Note: Adjusted for Smalltalk's 1-based array indexing."	^memory at: (byteAddress // 4) + 1 put: a32BitValue! !!InterpreterSimulator methodsFor: 'arithmetic'!bytecodePrimGreaterOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) >= (self integerValueOf: arg)].	^ super bytecodePrimGreaterOrEqual!bytecodePrimGreaterThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) > (self integerValueOf: arg)].	^ super bytecodePrimGreaterThan!bytecodePrimLessOrEqual	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) <= (self integerValueOf: arg)].	^ super bytecodePrimLessOrEqual!bytecodePrimLessThan	"Must be overridden from Interpreter because simulator doesn't have		32-bit signed ints to work with"	| rcvr arg |	rcvr _ self internalStackValue: 1.	arg _ self internalStackValue: 0.	(self areIntegers: rcvr and: arg)		ifTrue: [ ^ self booleanCheat:			(self integerValueOf: rcvr) < (self integerValueOf: arg)].	^ super bytecodePrimLessThan! !InterpreterSupportCode comment:'This class is a shell that includes all the ancillary C code for supporting Squeak in the Macintosh operating environment.  Executing	InterpreterSupportCode writeMacSourceFileswill cause the creation of a number of files in your working directory which, together with the one large interpreter file (see CCodeGenerator) should be adequate to compile a complete running interpreter.'!!InterpreterSupportCode class methodsFor: 'source file exporting'!archiveBinaryFileBytes	"Convert the binary archive date into a ByteArray."	| data b |	data _ self archiveBinaryFile.	b _ ByteArray new: data size.	1 to: data size do: [ :i | b at: i put: (data at: i)].	^ b!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: ''"	(FileStream readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [ self inform: 'File projectArchive.sit differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [ self inform: 'File readme differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [ self inform: 'File sq.h differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode filePrimsFile		ifFalse: [ self inform: 'File sqFilePrims.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [ self inform: 'File sqMacDirectory.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [ self inform: 'File sqMacJoystick.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [ self inform: 'File sqMacNetwork.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [ self inform: 'File sqMacSound.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [ self inform: 'File sqMacWindow.c differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [ self inform: 'File MacTCP.h differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode addressXlationFile		ifFalse: [ self inform: 'File AddressXlation.h differs from the version stored in this image.' ].	(FileStream readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode dnrFile		ifFalse: [ self inform: 'File dnr.c differs from the version stored in this image.' ].!storeProjectArchiveOnFileNamed: fileName	"Store into this image's folder a StuffIt archive file containing the CodeWarrier project files for the virtual machine. You will need to use a StuffIt unpacking utility such as StuffIt Expander to unpack the file. The result will be two project files for CodeWarrier, version 8."	| f |	f _ (FileStream newFileNamed: fileName) binary.	self archiveBinaryFile do: [ :byte | f nextPut: byte ].	f close.	FileDirectory default class setMacFileNamed: fileName type: 'SITD' creator: 'SIT!!'.!storeString: s onFileNamed: fileName	"Store the given string in a file of the given name."	| f |	f _ FileStream newFileNamed: fileName.	f nextPutAll: s.	f close.!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self filePrimsFile		onFileNamed: 'sqFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self addressXlationFile	onFileNamed: 'AddressXlation.h'.	self storeString: self dnrFile				onFileNamed: 'dnr.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.	self storeString: AbstractSound cCodeForSoundPrimitives											onFileNamed: 'sqSoundPrims.c'.	Smalltalk cleanOutUndeclared  "Right now this leaves junk in Undeclared"! !!InterpreterSupportCode class methodsFor: 'source files'!addressXlationFile	^ '/* 	File:		AddressXlation.h  	Contains:	TCP Manager interfaces for dnr.c  	Version:	Use with MacTCP 2.0.6 and Universal Interfaces 2.1b1					in MPW Prerelease on ETO #17  	Copyright:	 1984-1995 by Apple Computer, Inc. 				All rights reserved.  	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __ADDRESSXLATION__#define __ADDRESSXLATION__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __MACTCP__#include <MacTCP.h>#endif/*	#include <AppleTalk.h>										*//*		#include <OSUtils.h>									*//*			#include <MixedMode.h>								*//*			#include <Memory.h>									*/#ifdef __cplusplusextern "C" {#endif#if STRUCTALIGNMENTSUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif/*	Developer Notes:			When the various calls are made to the dnr code, you must set up 			a NewRoutineDescriptor for every non-nil completion routine and/or 			notifyProc parameter.  Otherwise, the 68K dnr code, will not 			correctly call your routine.		1. For the call to EnumCache, use NewEnumResultProc to set up a 			universal procptr to pass as the enumResultProc parameter.		2. For the calls to StrToAddr and AddrToName, use NewResultProc to 			set up a ResultUPP universal procptr to pass as the ResultProc 			parameter.		3. For the calls to HInfo and MXInfo, use NewResultProc2Proc to			set up a ResultProc2UPP universal procptr to pass as the ResultProc			parameter.		4. The DNR selector symbol HINFO has been changed to HXINFO due to			conflict with the same symbol in the AddressXLation.h header*/enum {	NUM_ALT_ADDRS				= 4};struct hostInfo {	long							rtnCode;	char							cname[255];	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned long					addr[NUM_ALT_ADDRS];};typedef struct hostInfo hostInfo;enum {	A							= 1,	NS							= 2,	CNAME						= 5,	HINFO						= 13,	MX							= 15,	lastClass					= 32767};typedef unsigned short AddrClasses;/* Domain Name Resolver code selectors */enum {	OPENRESOLVER				= 1,	CLOSERESOLVER				= 2,	STRTOADDR					= 3,	ADDRTOSTR					= 4,	ENUMCACHE					= 5,	ADDRTONAME					= 6,	HXINFO						= 7,							/* changed from HINFO due to symbol conflict*/	MXINFO						= 8};struct HInfoRec {	char							cpuType[30];	char							osType[30];};typedef struct HInfoRec HInfoRec;struct MXRec {	unsigned short					preference;	char							exchange[255];};typedef struct MXRec MXRec;struct returnRec {	long							rtnCode;	char							cname[255];	SInt8							filler;						/* Filler for proper byte alignment	 */	union {		unsigned long					addr[NUM_ALT_ADDRS];		struct HInfoRec					hinfo;		struct MXRec					mx;	}								rdata;};typedef struct returnRec returnRec;struct cacheEntryRecord {	char							*cname;	unsigned short					ctype;	unsigned short					cacheClass;	unsigned long					ttl;	union {		char							*name;		ip_addr							addr;	}								rdata;};typedef struct cacheEntryRecord cacheEntryRecord;typedef pascal void (*EnumResultProcPtr)(struct cacheEntryRecord *cacheEntryRecordPtr, Ptr userDataPtr);typedef pascal void (*ResultProcPtr)(struct hostInfo *hostInfoPtr, Ptr userDataPtr);typedef pascal void (*ResultProc2ProcPtr)(struct returnRec *returnRecPtr, Ptr userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr EnumResultUPP;typedef UniversalProcPtr ResultUPP;typedef UniversalProcPtr ResultProc2UPP;#elsetypedef EnumResultProcPtr EnumResultUPP;typedef ResultProcPtr ResultUPP;typedef ResultProc2ProcPtr ResultProc2UPP;#endifenum {	uppEnumResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct cacheEntryRecord*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr))),	uppResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr))),	uppResultProc2ProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))};#if GENERATINGCFM#define NewEnumResultProc(userRoutine)		\		(EnumResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppEnumResultProcInfo, GetCurrentArchitecture())#define NewResultProc(userRoutine)		\		(ResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResultProcInfo, GetCurrentArchitecture())#define NewResultProc2Proc(userRoutine)		\		(ResultProc2UPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResultProc2ProcInfo, GetCurrentArchitecture())#else#define NewEnumResultProc(userRoutine)		\		((EnumResultUPP) (userRoutine))#define NewResultProc(userRoutine)		\		((ResultUPP) (userRoutine))#define NewResultProc2Proc(userRoutine)		\		((ResultProc2UPP) (userRoutine))#endif#if GENERATINGCFM#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppEnumResultProcInfo, (cacheEntryRecordPtr), (userDataPtr))#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResultProcInfo, (hostInfoPtr), (userDataPtr))#define CallResultProc2Proc(userRoutine, returnRecPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResultProc2ProcInfo, (returnRecPtr), (userDataPtr))#else#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		(*(userRoutine))((cacheEntryRecordPtr), (userDataPtr))#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		(*(userRoutine))((hostInfoPtr), (userDataPtr))#define CallResultProc2Proc(userRoutine, returnRecPtr, userDataPtr)		\		(*(userRoutine))((returnRecPtr), (userDataPtr))#endifextern OSErr OpenResolver(char *fileName);extern OSErr StrToAddr(char *hostName, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, char *userDataPtr);extern OSErr AddrToStr(unsigned long addr, char *addrStr);extern OSErr EnumCache(EnumResultUPP enumResultProc, Ptr userDataPtr);extern OSErr AddrToName(ip_addr addr, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, Ptr userDataPtr);extern OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);extern OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);extern OSErr CloseResolver(void);/*	Universal ProcPtrs declaration for each of the dnr selector code calls.*/typedef OSErr (*OpenResolverProcPtr)(UInt32 selector, char *filename);typedef OSErr (*CloseResolverProcPtr)(UInt32 selector);typedef OSErr (*StrToAddrProcPtr)(UInt32 selector, char *hostName, struct hostInfo *rtnStruct, ResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*AddrToStrProcPtr)(UInt32 selector, unsigned long addr, char *addrStr);typedef OSErr (*EnumCacheProcPtr)(UInt32 selector, EnumResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*AddrToNameProcPtr)(UInt32 selector, UInt32 addr, struct hostInfo *rtnStruct, ResultUPP resultproc, Ptr userDataPtr);typedef OSErr (*HInfoProcPtr)(UInt32 selector, char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);typedef OSErr (*MXInfoProcPtr)(UInt32 selector, char *hostName, struct returnRec *returnRecPtr, ResultProc2UPP resultProc, Ptr userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr OpenResolverUPP;typedef UniversalProcPtr CloseResolverUPP;typedef UniversalProcPtr StrToAddrUPP;typedef UniversalProcPtr AddrToStrUPP;typedef UniversalProcPtr EnumCacheUPP;typedef UniversalProcPtr AddrToNameUPP;typedef UniversalProcPtr HInfoUPP;typedef UniversalProcPtr MXInfoUPP;#elsetypedef OpenResolverProcPtr OpenResolverUPP;typedef CloseResolverProcPtr CloseResolverUPP;typedef StrToAddrProcPtr StrToAddrUPP;typedef AddrToStrProcPtr AddrToStrUPP;typedef EnumCacheProcPtr EnumCacheUPP;typedef AddrToNameProcPtr AddrToNameUPP;typedef HInfoProcPtr HInfoUPP;typedef MXInfoProcPtr MXInfoUPP;#endifenum {	uppOpenResolverProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*))),	uppCloseResolverProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32))),	uppStrToAddrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultUPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppAddrToStrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(char*))),	uppEnumCacheProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EnumResultUPP)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr))),	uppAddrToNameProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultUPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppHInfoProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultProc2UPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr))),	uppMXInfoProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UInt32)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(ResultProc2UPP)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr)))};#if GENERATINGCFM#define CallOpenResolverProc(userRoutine, selector, filename)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppOpenResolverProcInfo, (selector), (filename))#define CallCloseResolverProc(userRoutine, selector)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppCloseResolverProcInfo, (selector))#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppStrToAddrProcInfo, (selector), (hostName), (rtnStruct), (resultproc), (userDataPtr))#define CallAddrToStrProc(userRoutine, selector, addr, addrStr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAddrToStrProcInfo, (selector), (addr), (addrStr))#define CallEnumCacheProc(userRoutine, selector, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppEnumCacheProcInfo, (selector), (resultproc), (userDataPtr))#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultproc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAddrToNameProcInfo, (selector), (addr), (rtnStruct), (resultproc), (userDataPtr))#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppHInfoProcInfo, (selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppMXInfoProcInfo, (selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#else#define CallOpenResolverProc(userRoutine, selector, filename)		\		(*(userRoutine))((selector), (filename))#define CallCloseResolverProc(userRoutine, selector)		\		(*(userRoutine))((selector))#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (rtnStruct), (resultproc), (userDataPtr))#define CallAddrToStrProc(userRoutine, selector, addr, addrStr)		\		(*(userRoutine))((selector), (addr), (addrStr))#define CallEnumCacheProc(userRoutine, selector, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (resultproc), (userDataPtr))#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultproc, userDataPtr)		\		(*(userRoutine))((selector), (addr), (rtnStruct), (resultproc), (userDataPtr))#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userDataPtr)		\		(*(userRoutine))((selector), (hostName), (returnRecPtr), (resultProc), (userDataPtr))#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if STRUCTALIGNMENTSUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __ADDRESSXLATION__ */'.!archiveBinaryFile	^ #(83 73 84 33 0 2 0 0 31 2 114 76 97 117 2 114 0 0 0 22 2 86 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 116 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 13 168 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 156 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 175 95 5 128 0 0 37 198 0 0 20 244 0 0 7 229 0 0 6 49 85 65 190 192 0 0 0 0 0 0 97 180 13 192 248 235 154 216 181 50 179 149 31 61 62 241 240 236 188 34 172 163 215 202 142 176 200 49 66 9 37 236 162 120 122 114 122 217 43 161 114 106 92 159 19 238 135 167 158 148 175 199 52 61 142 127 202 143 242 243 82 227 132 201 159 112 194 141 80 126 132 17 78 184 17 150 132 70 142 69 88 228 41 167 220 142 240 39 207 7 228 56 225 132 19 78 40 31 16 78 24 225 39 225 3 194 9 229 132 147 227 18 78 152 228 248 19 74 56 97 189 29 225 132 175 192 93 13 226 52 185 228 248 209 6 81 190 242 53 194 9 39 244 8 139 28 63 9 139 204 56 225 79 241 132 3 227 13 8 64 175 179 11 128 1 128 124 30 96 62 158 236 109 156 118 163 196 249 68 193 171 114 173 162 16 228 52 159 160 113 170 212 42 74 65 145 19 3 170 213 125 125 155 40 180 44 43 94 99 151 21 105 163 155 197 236 78 167 171 214 81 191 170 130 129 213 119 29 69 63 15 225 245 209 232 93 127 117 16 192 118 24 96 193 75 34 215 20 16 60 45 156 212 166 5 252 72 144 80 86 117 206 154 207 175 114 120 104 62 145 243 138 205 66 91 64 195 127 181 69 147 100 78 86 252 65 77 84 236 171 234 232 229 145 75 156 71 8 6 37 141 107 66 54 210 13 162 151 147 154 155 35 36 244 60 77 162 71 104 83 69 206 175 17 122 40 8 11 41 88 5 102 90 8 70 48 81 48 89 7 169 192 98 34 19 34 221 248 103 4 80 59 44 178 176 24 8 168 184 154 40 146 237 20 60 92 141 155 91 86 220 194 57 22 59 10 11 237 79 30 205 130 29 15 192 28 249 137 252 95 197 116 51 25 236 166 145 60 118 72 143 32 83 58 103 141 102 178 1 195 108 99 101 246 57 211 27 4 78 19 1 102 28 161 204 82 24 8 135 163 105 194 97 134 4 129 230 232 191 36 118 236 0 40 13 147 47 162 108 70 170 83 10 10 30 105 92 1 51 44 4 11 243 2 27 138 253 143 6 161 55 123 57 164 144 42 161 69 178 134 171 246 7 91 68 229 24 147 72 6 151 203 113 60 67 94 153 203 85 61 93 178 215 226 89 38 203 1 99 0 30 78 103 117 121 50 143 181 218 223 196 173 106 149 37 69 35 210 254 152 195 233 170 174 52 8 224 81 239 184 194 24 64 215 90 119 237 24 193 63 121 212 85 52 212 177 118 79 162 133 57 235 245 174 121 82 85 157 135 217 238 41 44 52 4 224 97 178 123 126 22 228 119 30 178 97 128 174 242 56 145 211 60 196 246 159 5 249 53 244 122 245 253 83 175 217 49 30 9 53 102 32 15 151 160 122 132 192 41 97 117 93 101 65 53 10 224 225 25 87 54 169 43 49 54 132 71 42 225 241 83 39 154 226 193 218 143 249 155 145 48 213 138 55 39 235 181 193 81 51 225 27 178 73 146 202 132 115 240 74 158 182 255 90 7 237 247 138 170 36 154 253 36 15 213 23 104 74 230 177 186 42 126 81 21 121 104 109 6 1 60 72 152 237 88 37 127 235 234 34 181 152 244 192 6 32 14 23 165 253 49 199 25 135 123 146 135 97 128 195 173 41 95 77 102 114 9 61 156 174 250 164 30 70 13 78 249 132 26 103 156 114 130 199 105 167 60 193 99 210 41 79 232 58 233 148 147 60 140 23 156 242 152 30 127 57 229 147 194 254 233 148 147 60 38 157 242 24 141 179 78 57 193 195 24 192 41 27 127 56 220 19 5 123 198 225 158 234 140 134 1 14 183 222 31 188 108 41 215 94 188 236 184 195 181 252 225 116 144 200 241 28 127 56 157 4 143 211 14 101 66 143 73 135 146 228 49 213 129 199 120 156 237 192 9 30 38 123 162 235 165 35 15 44 252 9 43 60 221 97 226 60 2 254 241 182 247 221 36 225 84 165 17 30 82 211 198 113 30 53 77 27 147 60 50 156 39 214 21 98 197 225 116 84 25 2 136 254 219 140 32 29 213 160 21 253 11 15 236 84 129 113 175 56 139 240 8 8 170 202 57 164 86 217 31 248 94 221 104 103 192 138 22 155 13 1 116 157 238 12 113 47 157 240 228 83 60 146 29 56 89 103 241 206 169 141 151 217 100 152 243 232 218 16 3 38 198 130 27 62 37 208 136 248 186 111 119 65 227 165 135 116 12 224 121 128 70 62 244 222 183 120 126 202 135 248 208 192 59 11 214 225 198 207 76 56 128 153 111 197 127 88 75 40 84 243 157 15 190 6 141 139 170 96 221 23 215 66 232 253 253 16 234 106 231 67 15 88 232 157 208 86 108 135 132 137 206 143 203 230 59 73 62 190 115 231 251 112 205 187 119 28 229 130 72 232 246 135 135 5 215 255 15 234 146 81 126 195 193 119 238 155 195 119 62 138 183 35 252 32 103 61 28 192 115 132 79 215 65 104 44 253 0 255 159 162 92 250 41 231 207 96 7 85 58 7 179 34 99 220 40 98 207 47 209 71 169 238 54 153 116 103 130 86 225 54 161 168 168 37 54 107 63 204 218 179 48 70 156 41 210 21 193 172 140 247 145 37 96 187 234 3 60 15 248 194 95 242 136 95 130 247 194 96 59 167 8 177 35 120 102 67 78 103 29 230 127 190 0 204 102 196 185 225 252 128 184 75 199 139 52 166 240 213 30 213 163 248 33 23 7 146 152 159 110 85 121 251 176 14 80 31 154 63 29 243 247 238 7 91 94 124 39 170 224 222 199 249 237 79 104 136 96 17 16 62 125 125 96 155 219 203 92 158 146 141 216 91 200 175 155 214 249 172 61 155 245 252 168 7 201 111 155 23 181 149 121 48 143 108 195 145 26 56 111 180 6 208 244 40 130 226 23 213 18 48 180 168 1 102 197 149 135 13 3 106 32 29 216 220 209 26 136 54 1 128 158 124 24 92 243 34 12 214 182 243 93 183 188 82 67 166 234 38 200 192 15 224 67 198 123 19 225 24 38 183 225 208 222 30 248 244 181 251 129 89 188 149 241 222 140 122 220 212 61 16 9 122 127 80 221 130 76 94 231 183 163 166 52 127 79 62 230 24 42 135 249 229 144 249 102 3 204 46 102 105 15 203 201 212 13 195 161 221 207 38 251 57 242 92 18 133 116 124 83 30 228 12 236 196 179 27 177 38 122 63 103 240 27 176 62 211 31 198 64 156 191 2 107 129 223 157 81 0 71 24 172 215 142 48 48 239 210 73 56 107 193 189 210 76 183 191 85 14 136 92 185 40 78 79 54 13 59 130 1 198 8 166 8 48 108 96 198 133 89 186 212 73 55 60 201 226 52 9 43 164 197 87 69 41 242 34 238 214 194 12 125 207 154 91 235 36 163 65 178 111 61 49 62 24 137 202 50 119 157 190 179 146 43 235 253 252 223 40 197 136 129 63 236 200 66 218 254 209 148 75 81 199 179 123 193 150 88 101 144 122 120 139 110 24 143 54 20 35 160 216 176 65 213 4 133 88 61 3 135 176 81 167 136 197 60 90 207 216 253 140 0 218 85 169 1 132 190 140 141 188 42 96 72 19 79 147 9 83 114 51 159 184 13 221 189 48 100 102 129 39 217 213 111 48 4 240 49 201 178 29 246 57 63 184 28 221 155 88 244 199 2 34 41 241 140 191 159 193 178 214 33 219 16 94 185 144 9 2 43 175 165 243 217 243 101 5 135 177 185 112 177 187 174 54 31 51 142 108 220 229 15 208 225 38 122 62 220 98 249 24 46 194 251 86 130 213 190 12 56 183 97 232 112 123 229 54 40 70 140 190 87 80 229 2 28 231 51 100 226 7 242 27 80 131 172 231 19 172 181 3 54 32 86 71 48 91 7 224 227 0 172 151 96 215 124 6 91 16 219 76 176 185 23 64 23 98 125 4 43 236 131 59 17 251 134 96 238 131 112 15 192 185 203 9 86 244 17 236 66 201 26 8 54 187 3 30 66 41 233 32 185 168 23 30 67 12 185 224 148 213 2 56 75 185 144 204 106 96 229 97 232 7 184 136 230 203 250 26 222 70 236 110 130 173 240 194 71 136 237 164 186 238 133 79 144 253 13 4 19 76 240 21 98 52 199 162 251 240 221 13 224 232 144 113 253 62 38 11 96 30 190 13 130 129 211 21 172 168 165 4 50 13 81 12 107 1 96 166 11 223 28 17 61 26 135 117 165 250 165 96 22 110 24 197 6 225 86 186 233 16 131 51 201 174 139 67 242 138 43 197 160 37 190 247 66 175 69 104 204 140 108 93 69 83 70 241 122 65 9 250 131 215 169 214 40 221 138 118 77 17 212 212 10 175 95 147 20 115 165 20 212 82 235 4 229 58 81 203 42 243 120 68 28 198 187 4 205 135 247 105 154 76 106 214 35 196 227 43 165 244 90 132 144 85 95 238 136 41 167 195 81 218 169 142 74 39 38 203 36 15 46 68 121 196 31 95 72 35 16 110 14 209 235 17 62 255 3 12 192 248 186 60 153 239 117 157 151 121 157 189 205 148 13 214 174 55 51 114 124 64 143 211 188 78 174 178 91 249 173 199 58 74 142 147 99 143 231 235 201 61 60 161 120 170 133 127 218 75 24 57 78 37 252 201 179 158 240 35 140 60 127 194 201 128 93 79 142 79 200 49 237 34 199 159 76 24 153 176 8 35 83 78 56 225 103 18 126 132 147 25 39 156 112 201 113 242 156 28 39 156 28 63 194 8 39 71 129 123 241 113 202 189 245 152 220 232 165 199 228 226 249 19 22 141 48 50 228 100 192 200 132 147 1 199 147 21 248 240 88 192 14 240 69 116 93 3 0 9 127 107 0 42 142 225 239 155 184 11 226 111 62 254 190 10 121 208 0 46 168 43 12 233 253 70 68 49 65 186 112 30 142 66 251 193 209 31 91 160 16 9 236 113 211 204 14 113 9 158 39 32 71 106 187 212 199 13 217 80 145 186 157 243 10 8 98 115 197 195 121 222 214 93 161 206 95 128 131 57 30 48 30 64 227 105 40 218 91 6 210 151 47 1 12 142 74 143 205 185 8 155 33 136 243 187 151 81 236 6 206 179 5 66 253 248 92 255 188 203 11 249 82 164 162 59 125 29 184 238 117 221 63 56 10 223 162 246 80 152 0 47 36 184 198 204 35 99 143 91 141 89 138 17 247 71 50 248 204 179 149 230 210 100 81 249 94 188 98 14 206 251 112 158 75 115 57 206 251 113 174 160 125 25 206 50 206 197 35 43 242 142 227 252 228 213 251 249 198 99 246 117 168 154 18 52 212 94 115 90 4 219 69 119 239 127 17 142 35 189 40 115 127 153 217 135 30 223 166 26 74 196 210 141 129 172 4 182 123 231 37 165 183 94 67 118 101 178 184 250 19 156 239 234 113 18 94 199 107 74 50 122 148 114 61 30 212 7 76 75 141 244 228 28 49 155 102 207 208 210 196 135 200 158 143 243 217 49 61 188 244 158 163 75 201 144 250 195 247 227 250 72 149 82 21 94 183 48 147 23 94 174 207 46 197 58 172 27 55 228 129 69 52 175 33 29 108 157 86 211 188 140 230 21 52 175 164 121 49 205 203 147 151 62 255 122 76 207 165 244 222 42 154 109 125 23 208 188 132 230 218 155 186 251 232 253 140 254 117 244 158 237 131 245 167 206 124 215 128 243 186 83 47 191 119 122 204 183 175 96 155 0 40 206 248 182 132 251 2 235 69 44 250 71 150 218 45 227 122 142 84 13 61 210 58 255 223 60 121 27 88 99 240 100 252 138 249 138 186 60 170 198 162 250 225 105 97 170 111 234 98 251 172 102 232 231 139 79 253 173 207 66 202 163 153 30 128 185 194 205 243 103 17 40 250 175 7 72 5 18 115 96 117 198 39 179 162 49 227 175 18 132 207 218 201 92 187 158 95 91 104 191 145 230 13 52 55 144 63 154 105 223 68 179 157 115 78 190 249 105 222 76 115 35 205 155 104 174 167 217 206 183 76 158 117 192 142 188 111 112 118 93 241 97 101 64 182 14 98 129 109 106 222 89 91 215 168 214 55 71 125 126 92 143 251 128 245 106 246 76 222 49 27 83 103 119 200 175 93 67 167 91 240 244 29 149 113 67 127 2 11 162 209 212 220 83 23 234 149 53 205 55 113 20 182 220 203 119 216 123 187 103 134 58 119 239 233 246 163 172 19 114 94 161 101 239 168 228 13 159 156 81 219 150 61 104 214 175 55 181 224 21 238 19 142 6 201 226 154 99 82 34 16 236 234 96 27 112 113 234 179 142 147 146 197 190 115 54 213 119 14 242 56 245 25 199 55 152 226 103 4 149 109 32 159 83 19 142 251 241 194 150 212 173 45 48 139 83 143 58 158 72 122 60 95 16 21 55 216 228 209 227 158 159 156 230 63 178 252 157 33 41 17 110 239 14 179 13 246 111 78 117 250 250 240 71 151 124 130 202 54 216 51 56 213 105 103 195 234 7 39 136 138 27 236 214 156 234 116 241 225 207 62 126 154 168 184 193 102 194 169 78 147 25 62 191 37 64 84 220 96 147 228 212 124 179 207 127 48 23 75 172 189 144 27 88 143 41 105 193 252 45 188 80 24 30 136 43 102 22 204 179 159 83 249 198 35 168 229 109 122 44 170 90 170 30 147 53 20 216 208 211 23 240 230 32 168 108 227 21 212 226 128 122 68 137 6 244 168 50 113 111 154 90 202 169 207 21 244 98 162 228 148 229 45 142 83 249 166 76 80 11 7 14 201 90 78 87 222 233 108 170 12 115 136 106 90 81 85 159 166 238 75 81 247 193 92 65 117 35 21 147 113 10 155 166 150 167 168 134 26 59 112 131 186 63 69 221 15 21 228 6 75 237 157 180 207 181 91 231 181 96 54 184 223 40 65 147 238 80 228 168 98 76 88 130 55 118 65 101 155 74 65 101 223 46 137 138 129 124 173 55 96 191 79 4 2 109 59 248 102 190 112 249 236 109 138 217 243 64 255 148 247 120 107 181 93 126 22 170 40 135 68 180 102 115 136 125 211 16 84 182 169 78 53 128 233 111 19 35 59 59 238 163 204 195 13 44 32 133 118 135 246 88 106 54 29 210 57 180 208 78 74 116 158 145 83 232 138 174 53 156 250 105 145 221 162 38 193 252 91 136 160 178 205 162 84 3 152 254 70 54 114 143 246 2 233 138 27 88 44 20 114 183 31 82 98 86 54 244 210 186 46 161 84 126 168 31 187 73 212 144 15 223 74 229 90 65 45 77 81 195 202 17 107 156 156 166 46 37 133 2 74 47 235 92 51 10 45 75 37 202 33 21 191 185 207 248 117 57 249 149 117 195 27 13 128 125 93 17 153 199 54 43 236 91 85 89 211 15 220 190 117 165 237 60 195 208 39 179 245 55 234 42 82 40 160 196 178 57 121 149 186 90 80 139 176 123 89 134 62 21 95 105 106 29 233 42 66 242 182 174 62 186 149 153 187 29 155 222 63 183 174 161 68 105 141 199 53 37 44 107 61 183 18 101 45 203 60 111 149 243 253 140 125 125 18 153 199 54 176 78 80 221 152 147 225 182 224 148 137 216 183 42 162 226 6 214 11 106 89 107 52 106 40 166 217 221 37 179 18 123 149 158 190 213 79 186 62 172 152 226 223 31 183 116 173 183 123 131 33 199 239 184 188 65 80 75 182 43 166 37 107 86 123 95 255 239 232 116 219 216 64 46 39 234 140 203 55 18 181 67 215 166 170 225 56 117 19 185 33 140 127 153 201 245 168 52 181 209 166 98 162 220 161 110 166 124 13 69 12 53 62 37 107 134 218 68 29 165 51 102 105 57 207 166 169 91 108 55 168 71 216 71 172 25 55 52 147 203 59 35 122 236 142 203 183 138 158 231 252 119 102 100 239 87 235 168 231 225 70 188 35 225 255 147 192 21 12 41 7 70 71 83 32 124 71 2 246 14 142 224 114 149 189 143 251 197 236 95 59 193 46 211 98 0 124 103 8 59 253 73 252 159 65 65 176 67 51 217 59 255 3 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 116 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 213 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 175 95 5 255 0 0 42 109 0 0 22 40 0 0 9 113 0 0 6 133 38 184 143 33 0 0 0 0 0 0 36 16 13 192 213 101 47 91 187 188 110 221 30 229 110 182 217 173 113 122 77 162 221 202 142 176 34 140 176 77 9 119 51 60 61 251 77 115 83 59 59 235 76 126 126 226 169 39 167 103 173 249 123 253 182 180 237 197 200 90 151 157 145 227 100 211 219 140 48 114 251 88 217 17 74 24 225 100 31 123 194 122 247 17 182 189 142 237 39 155 237 151 236 163 100 219 145 99 228 25 97 219 235 164 156 176 125 132 199 182 17 86 148 75 24 217 186 41 121 218 173 192 87 93 214 249 109 246 110 246 209 86 182 182 143 108 105 132 109 114 91 55 219 100 182 201 38 155 225 201 6 198 27 16 128 94 103 23 0 3 128 89 31 5 152 137 167 230 99 158 240 31 151 60 202 32 124 210 7 243 196 112 47 158 125 117 237 243 205 225 183 149 191 138 116 251 167 90 100 105 157 205 102 49 251 252 222 38 187 0 2 88 173 182 106 75 237 178 98 6 101 79 13 162 239 34 183 225 216 179 166 33 27 224 142 217 0 247 52 231 44 53 135 143 238 122 186 172 248 33 221 242 246 93 47 228 79 71 100 74 169 39 220 57 223 12 25 120 26 240 76 169 216 127 74 87 249 14 100 172 53 44 111 167 187 62 221 238 234 154 202 5 73 229 61 83 123 195 190 138 53 21 45 11 0 146 56 183 36 254 105 99 100 73 220 193 208 38 97 64 197 10 128 210 223 177 172 153 120 67 224 201 181 248 207 239 131 198 248 18 254 55 69 112 188 159 236 147 28 235 164 6 249 188 152 60 38 68 238 155 3 235 155 47 220 79 179 175 15 4 229 102 139 91 10 4 228 192 69 10 185 231 149 186 16 58 16 48 145 6 145 14 252 123 63 231 104 8 200 66 175 2 192 34 26 101 164 72 134 85 114 152 42 237 38 108 17 38 203 124 75 94 158 249 155 131 89 68 165 204 148 159 200 255 114 214 193 82 133 71 206 230 209 3 67 58 120 114 153 9 141 193 102 94 157 212 124 198 131 105 85 1 170 69 29 36 176 161 70 75 98 60 163 97 40 147 17 139 240 107 194 42 225 23 154 205 116 51 25 251 98 90 47 103 150 132 198 33 28 77 19 14 99 193 82 201 2 76 83 126 41 182 111 7 88 26 166 47 210 47 82 117 86 175 71 114 120 71 21 208 194 108 208 179 31 10 161 254 255 225 234 38 89 86 65 18 245 158 72 235 41 119 121 214 201 254 115 76 198 50 76 41 176 217 202 111 23 217 90 60 11 124 62 183 58 0 15 171 181 188 48 145 39 189 220 85 111 90 214 236 243 250 131 36 237 197 28 86 91 121 137 74 0 143 90 75 145 58 128 174 213 246 234 17 130 31 240 168 41 94 89 163 49 215 55 58 186 187 187 129 253 120 27 191 120 108 107 144 126 197 39 154 222 68 187 84 100 40 148 220 110 175 215 99 42 149 221 62 186 56 121 177 0 199 218 247 66 231 172 197 176 43 255 32 93 33 30 130 217 17 111 133 214 90 197 211 92 174 14 133 135 214 236 200 203 83 5 224 161 49 59 174 10 242 15 30 92 118 85 0 93 125 163 68 110 240 144 91 175 10 242 183 80 234 181 241 191 245 154 209 207 35 174 70 26 242 176 73 1 135 228 190 34 172 162 171 79 26 49 248 255 226 225 24 85 54 161 43 25 36 226 161 35 30 239 117 162 235 60 4 243 57 159 116 54 52 213 242 103 222 175 215 192 213 62 173 67 25 10 2 205 188 79 243 251 231 251 244 74 75 229 152 143 201 160 36 37 113 39 227 244 58 90 254 215 130 184 255 240 7 252 113 211 48 206 35 208 232 174 79 228 73 183 21 95 83 21 121 4 91 84 2 120 80 104 205 88 37 255 209 213 70 181 168 56 238 69 139 63 169 94 226 184 81 218 139 57 110 58 238 203 60 84 3 28 119 101 97 153 105 76 15 171 173 54 161 135 218 135 115 191 164 234 77 231 30 231 113 195 185 143 241 24 119 238 99 186 142 59 247 4 15 245 5 231 62 162 199 191 157 251 101 97 63 112 238 9 30 227 206 125 132 198 45 231 30 231 161 30 224 220 181 230 128 220 240 94 159 6 232 156 115 26 167 241 179 161 48 23 251 243 129 193 62 93 194 251 180 250 135 227 190 84 248 55 29 247 149 14 171 26 224 184 107 93 158 123 23 154 90 23 47 250 139 227 214 255 211 49 33 145 171 157 225 186 99 138 243 184 225 116 198 244 24 119 58 9 30 215 59 249 8 143 91 157 60 206 67 99 142 119 189 20 228 129 133 63 102 205 111 119 152 24 15 183 107 180 237 157 153 108 92 169 52 226 225 173 111 26 229 81 89 223 148 224 145 106 189 180 206 209 95 28 86 75 169 42 128 232 127 159 53 164 160 26 188 162 175 241 192 78 229 30 245 156 153 196 131 150 198 76 22 111 179 207 229 30 86 55 218 25 176 162 229 135 84 1 116 189 221 25 98 158 60 238 237 175 243 72 116 224 68 157 197 58 103 112 180 204 198 67 103 226 203 106 2 104 25 237 162 229 67 29 226 171 79 127 5 234 238 121 75 193 0 14 0 212 137 161 95 157 198 179 71 12 137 161 238 87 103 172 198 141 168 137 112 8 51 111 196 127 192 189 67 96 229 98 219 151 127 6 117 243 74 97 245 201 181 16 122 227 32 132 54 183 138 161 167 245 252 78 232 49 108 135 196 68 225 103 202 16 219 40 159 216 246 204 27 176 234 181 45 131 92 16 9 61 177 115 64 112 229 31 61 57 6 230 71 126 3 33 182 237 157 38 182 189 128 183 35 252 96 210 26 56 132 231 89 62 155 223 132 186 165 71 240 255 69 206 165 139 115 62 1 219 185 210 147 48 43 50 102 184 125 40 228 231 111 18 55 189 188 50 66 142 129 102 90 17 243 212 60 142 39 50 77 62 99 194 230 241 4 202 221 103 64 120 231 85 194 77 90 17 243 155 140 226 166 221 202 220 54 117 225 94 214 240 37 69 59 202 87 245 237 86 113 211 206 18 208 23 239 131 190 175 31 102 85 63 233 194 92 27 32 121 221 83 240 228 187 125 172 234 165 14 28 73 240 192 28 71 88 210 231 183 194 169 7 118 138 143 159 168 224 234 195 142 181 52 147 0 246 90 17 171 250 22 8 13 89 119 67 223 207 167 42 236 30 254 30 215 108 52 250 78 81 43 226 197 223 175 49 215 229 251 251 1 54 236 102 175 131 144 155 175 140 183 237 45 62 114 40 249 165 178 228 148 253 129 252 130 10 251 50 156 89 42 32 78 73 190 115 154 78 182 228 149 35 204 185 55 136 231 108 182 132 202 107 242 97 206 200 249 156 173 16 82 12 96 200 49 246 179 55 22 188 158 232 73 236 190 245 111 113 192 25 225 65 56 42 78 124 216 199 39 255 117 26 126 20 2 208 11 93 152 107 27 213 11 115 62 191 133 52 193 252 123 249 125 195 221 91 32 243 11 59 115 33 69 203 245 216 193 50 249 169 68 22 100 99 65 8 83 134 106 0 209 168 242 198 244 46 200 124 22 119 125 163 130 205 141 86 183 192 154 254 176 0 140 203 143 224 121 168 49 252 39 17 241 57 120 47 12 198 15 205 69 172 23 207 12 152 212 86 131 249 15 228 130 86 139 184 105 32 63 32 110 83 240 185 65 150 247 74 103 192 225 119 193 157 56 136 194 252 124 251 176 169 7 251 33 234 195 243 167 96 254 183 15 130 49 43 182 59 152 115 98 163 184 109 31 77 177 176 25 18 159 158 231 193 56 125 15 43 50 216 16 59 140 252 58 120 197 103 62 251 168 146 31 245 160 252 198 236 104 103 67 253 105 23 151 106 224 174 161 26 64 243 235 151 252 46 25 139 95 245 161 6 196 109 87 106 128 173 251 245 119 213 4 106 96 226 80 13 208 46 168 136 156 136 179 58 74 31 64 49 245 145 69 116 181 151 136 172 108 171 192 132 17 103 5 253 37 49 16 233 144 140 37 194 143 200 205 151 201 97 142 109 206 95 139 165 24 202 46 21 11 173 60 183 35 125 43 136 79 63 120 97 67 31 121 14 165 92 136 58 222 170 125 61 186 128 254 101 113 118 88 233 165 131 13 69 13 40 30 124 48 16 148 252 124 105 67 189 33 140 160 17 34 143 58 196 94 4 192 192 238 199 31 133 80 253 208 151 25 85 98 220 223 159 99 63 205 150 210 148 151 99 76 43 172 100 112 232 5 25 124 63 102 32 73 73 129 189 70 113 47 119 162 175 78 166 141 161 78 60 185 39 87 59 40 219 1 159 115 193 229 40 111 140 232 135 159 149 137 189 153 35 8 233 199 141 91 241 202 84 246 34 8 190 21 124 78 63 197 231 199 161 252 71 96 166 189 166 58 7 51 126 238 12 165 212 2 62 228 230 83 197 251 127 4 52 239 72 39 172 234 17 200 199 223 59 8 43 123 18 104 43 246 49 194 90 238 130 7 240 119 15 97 105 53 208 128 191 52 60 132 236 25 128 92 89 25 97 246 185 176 1 177 47 18 182 200 15 237 136 125 149 176 130 111 80 29 177 125 132 173 202 132 231 16 59 74 88 242 113 172 75 16 122 8 251 108 55 252 20 149 228 219 161 198 102 248 37 98 248 166 14 192 28 9 126 143 24 223 156 104 176 193 113 196 248 182 216 244 14 192 167 125 52 93 188 110 247 67 31 142 64 248 108 231 211 191 101 169 248 220 7 233 6 245 199 24 106 108 186 159 48 255 111 24 78 93 77 124 127 97 222 102 54 11 49 174 171 109 7 187 23 85 228 249 154 236 12 183 110 179 55 18 246 225 125 172 10 49 154 187 64 246 86 134 19 230 28 222 42 156 41 204 137 24 207 177 236 7 12 31 13 201 229 218 207 106 103 15 3 204 80 214 81 186 104 238 52 147 94 246 1 205 113 142 113 93 39 218 176 223 200 142 160 9 235 51 224 242 122 178 172 82 131 203 97 178 72 190 161 37 11 180 225 209 139 202 78 73 102 236 66 132 67 58 95 180 233 207 56 129 86 173 44 94 167 252 9 217 163 143 173 93 241 107 145 140 25 180 255 92 228 10 32 81 185 185 158 88 146 203 63 115 193 160 236 190 227 150 161 71 118 27 112 45 175 159 222 196 200 226 225 48 94 43 249 61 46 79 67 32 61 170 108 113 107 208 47 5 116 197 78 87 208 235 215 150 120 61 65 93 141 228 111 144 131 134 2 135 67 70 137 109 82 176 17 239 243 52 19 72 145 168 104 177 237 108 126 45 42 179 178 151 20 229 29 129 163 180 117 150 18 43 38 155 192 199 21 17 30 177 119 85 146 9 194 165 55 126 61 194 231 255 12 0 29 237 215 235 189 6 217 192 203 235 109 208 57 49 179 113 19 122 156 14 56 61 174 178 91 217 41 59 139 12 152 225 217 122 178 19 79 40 158 106 225 63 246 242 35 199 93 249 121 100 192 143 240 39 140 60 159 144 231 54 32 199 237 9 119 189 100 228 56 225 100 194 159 28 55 50 225 228 57 225 132 147 227 3 194 34 199 201 51 114 156 112 194 141 112 242 156 28 39 156 60 37 44 9 167 192 93 192 248 152 87 248 216 19 118 158 159 29 158 27 97 121 73 134 156 12 56 153 240 35 156 112 60 89 129 47 44 96 191 91 253 138 34 19 66 56 248 173 32 100 234 187 240 123 10 122 94 248 157 0 191 31 66 85 67 120 120 171 117 85 50 70 188 252 52 212 132 244 245 111 103 245 165 143 242 22 254 7 2 239 85 62 246 17 124 132 251 217 199 183 151 62 93 251 136 35 68 230 146 99 124 123 241 27 23 104 84 89 202 75 244 191 108 32 228 224 0 183 229 189 78 178 140 124 5 245 249 183 244 59 7 184 187 248 123 14 14 144 239 73 14 33 206 102 82 68 34 240 206 201 38 25 252 156 82 80 23 213 80 181 127 88 166 196 183 1 235 133 177 188 146 157 48 197 98 168 59 160 94 130 117 21 212 187 160 94 138 253 69 80 11 80 47 136 207 207 57 2 245 195 87 231 119 107 61 77 146 44 122 85 169 91 203 138 48 231 223 249 159 34 71 128 158 151 156 191 72 235 241 8 254 6 73 21 253 186 162 246 166 37 160 190 166 95 117 140 59 246 18 76 177 44 150 95 118 6 234 191 245 120 145 188 12 211 184 146 122 20 50 61 238 87 122 53 93 242 119 101 28 113 187 105 224 232 156 200 7 48 69 13 212 39 7 245 200 197 119 182 46 142 168 244 211 143 151 244 225 166 113 165 48 93 121 82 159 2 166 207 38 81 223 175 168 163 242 144 249 88 23 163 14 166 78 171 176 94 142 245 10 172 139 176 206 199 186 48 118 246 212 55 131 122 22 224 187 149 88 155 250 230 97 237 194 218 61 174 251 26 124 159 212 127 53 190 51 125 80 122 252 157 31 106 160 158 126 252 153 183 78 12 250 246 89 242 60 168 154 159 244 133 139 249 162 77 9 7 3 99 89 58 119 60 71 214 70 183 215 77 255 43 79 94 35 116 99 112 95 206 87 208 165 93 10 6 148 253 89 97 110 27 215 197 244 217 250 232 185 51 143 254 174 207 58 204 163 27 123 0 228 10 51 207 111 139 192 188 127 246 0 110 18 231 4 122 89 114 254 137 129 160 122 109 9 130 111 242 112 174 141 228 215 44 236 79 195 122 42 214 101 232 143 217 216 159 137 181 153 115 118 190 149 96 93 129 117 57 214 51 176 158 130 181 153 111 201 60 107 34 205 57 223 66 205 95 216 49 73 65 221 166 182 150 202 250 106 175 183 190 186 85 218 157 246 129 233 159 225 57 220 109 45 155 183 237 184 54 6 153 104 205 1 219 234 208 28 174 22 186 159 238 17 252 226 216 24 137 249 135 231 40 12 169 202 30 88 52 85 170 136 156 25 101 210 216 28 14 143 160 119 142 75 193 62 147 59 60 71 129 167 189 126 107 56 168 75 221 226 152 65 232 253 130 126 144 155 108 14 179 111 230 123 91 79 88 20 186 42 183 123 42 215 172 219 152 209 227 14 179 113 184 129 231 15 79 225 249 67 239 243 124 207 233 46 99 194 26 174 255 68 228 205 95 28 67 196 211 116 90 62 167 165 106 80 57 122 75 120 200 206 136 152 123 227 131 92 196 227 109 109 162 29 112 38 165 62 102 59 57 186 249 88 45 23 209 58 229 221 180 3 76 74 141 216 126 59 254 194 3 148 170 135 119 211 14 104 73 169 79 216 238 138 21 183 78 70 133 160 3 25 68 169 71 237 204 138 229 87 60 135 84 232 64 82 80 234 97 59 89 162 231 190 171 50 168 180 67 28 181 144 120 142 47 28 190 222 144 168 85 119 142 232 202 82 59 226 107 220 225 99 29 167 65 45 169 87 130 1 73 151 148 160 32 195 90 167 42 214 4 44 243 13 42 237 228 26 212 124 143 116 64 12 120 148 128 120 117 94 139 154 103 80 115 55 183 109 211 37 57 165 145 69 205 55 168 206 198 125 98 80 79 11 107 81 93 168 208 150 48 92 59 2 170 176 255 186 66 110 131 90 152 160 250 196 3 250 37 178 69 45 64 133 60 98 55 189 244 220 80 168 16 253 74 175 84 25 191 178 109 143 81 89 167 200 116 131 170 42 234 159 110 40 70 55 212 133 66 178 232 19 228 174 235 110 152 76 119 159 130 82 123 131 165 251 31 199 168 108 19 44 193 89 183 138 154 18 86 253 35 218 90 179 78 49 211 75 21 66 163 233 245 43 117 42 38 202 125 162 166 11 242 101 167 94 161 78 67 106 147 34 7 196 180 137 44 234 116 195 13 78 136 71 95 189 55 37 17 221 130 209 13 116 31 46 53 168 69 117 129 128 42 106 218 142 86 129 134 236 69 186 229 161 50 67 33 23 234 218 216 19 190 50 47 219 244 77 133 78 146 25 232 60 31 28 173 51 9 107 233 90 110 82 33 234 110 81 43 48 135 218 252 170 20 74 25 47 73 157 137 249 10 27 155 156 201 7 139 58 203 244 171 116 128 46 109 55 252 58 27 19 165 197 175 4 111 37 74 37 245 171 187 223 190 222 246 125 124 118 145 225 87 218 129 27 50 163 218 55 231 248 188 215 163 6 149 118 224 98 199 168 246 133 175 79 122 251 40 206 10 29 184 83 49 170 125 215 234 251 108 173 7 169 208 129 171 169 73 205 94 89 227 119 202 79 162 66 208 129 219 157 169 107 246 214 23 223 216 116 55 82 161 3 23 100 70 181 47 206 125 159 127 114 8 21 130 14 89 64 239 23 238 254 9 90 79 218 172 116 86 184 182 225 172 208 33 11 107 97 86 199 227 147 186 51 193 64 183 40 122 211 51 182 40 218 89 100 80 29 189 251 132 244 30 202 168 66 130 42 144 197 72 213 244 128 164 100 169 29 9 106 7 89 98 80 157 64 133 37 62 133 181 168 85 9 170 42 5 247 142 82 119 37 168 187 200 82 116 3 187 79 100 221 48 52 107 117 45 189 55 188 226 2 183 54 139 66 106 37 98 247 91 131 74 59 203 12 170 251 60 21 238 20 151 169 244 218 27 241 120 234 155 89 167 6 179 188 65 212 186 238 13 143 238 94 67 155 205 242 4 117 159 148 218 40 47 102 249 10 147 42 9 178 178 247 38 117 37 238 13 30 49 152 214 231 34 117 149 65 205 131 59 138 174 42 169 80 177 168 171 81 33 35 90 111 42 180 6 103 165 27 91 35 92 109 254 152 117 45 234 106 44 26 105 93 233 191 4 12 42 237 172 51 247 114 72 20 53 235 134 33 191 174 103 212 79 243 204 11 214 136 66 244 226 111 80 105 103 131 177 55 216 255 28 138 239 252 26 238 94 108 3 128 14 220 31 141 29 101 252 94 25 239 152 232 226 34 117 94 111 43 237 24 111 56 248 79 23 225 189 109 226 222 129 129 4 8 222 112 132 190 161 251 8 207 23 193 127 190 184 89 244 159 78 222 86 77 167 0 158 47 134 75 127 238 30 184 33 171 222 38 89 163 111 254 7 0 0 0 ).!dnrFile	^ '/* 		File:		DNR.c 		Contains:	DNR library for MPW  	Copyright:	 1989-1995 by Apple Computer, Inc., all rights reserved	Version:	Technology:			Networking				Package:			Use with MacTCP 2.0.6 and the Universal									Interfaces 2.1b1				Change History (most recent first):		<3>	 1/23/95	rrk  	implemented use of universal procptrs		 						Changed selector name HINFO to HXINFO		 						due to conflict of name in MacTCP header		 						Removed use of TrapAvailable and exchanged		 						for the TrapExists call.								Changed symbol codeHandle to gDNRCodeHndl								Changed symbol dnr to gDNRCodePtr	Further modifications by Steve Falkenburg, Apple MacDTS 8/91	Modifications by Jim Matthews, Dartmouth College, 5/91	*/#ifndef __OSUTILS__#include <OSUtils.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FILES__#include <Files.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TRAPS__#include <Traps.h>#endif#ifndef __GESTALTEQU__#include <GestaltEqu.h>#endif#ifndef __FOLDERS__#include <Folders.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __MACTCP__#include "MacTCP.h"#endif#ifndef __ADDRESSXLATION__#include "AddressXlation.h"#endif// think C compatibility stuff#ifndef	_GestaltDispatch#define	_GestaltDispatch	_Gestalt#endif/* RRK Modification 1/95 - commenting out the following defines as they are	defined in the DNRCalls.h header file*/void GetSystemFolder(short *vRefNumP, long *dirIDP);void GetCPanelFolder(short *vRefNumP, long *dirIDP);short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID);short OpenOurRF(void);short	NumToolboxTraps(void);TrapType	GetTrapType(short theTrap);Boolean TrapExists(short theTrap);static Handle 			gDNRCodeHndl = nil;static ProcPtr			gDNRCodePtr = nil;/*	Check the bits of a trap number to determine its type. *//* InitGraf is always implemented (trap $A86E).  If the trap table is big** enough, trap $AA6E will always point to either Unimplemented or some other** trap, but will never be the same as InitGraf.  Thus, you can check the size** of the trap table by asking if the address of trap $A86E is the same as** $AA6E. */#pragma segment UtilMainshort	NumToolboxTraps(void){	if (NGetTrapAddress(_InitGraf, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))		return(0x200);	else		return(0x400);}#pragma segment UtilMainTrapType	GetTrapType(short theTrap){	/* OS traps start with A0, Tool with A8 or AA. */	if ((theTrap & 0x0800) == 0)					/* per D.A. */		return(OSTrap);	else		return(ToolTrap);}Boolean TrapExists(short theTrap){	TrapType	theTrapType;	theTrapType = GetTrapType(theTrap);	if ((theTrapType == ToolTrap) && ((theTrap &= 0x07FF) >= NumToolboxTraps()))		theTrap = _Unimplemented;	return(NGetTrapAddress(_Unimplemented, ToolTrap) !!= NGetTrapAddress(theTrap, theTrapType));}void GetSystemFolder(short *vRefNumP, long *dirIDP){	SysEnvRec info;	long wdProcID;		SysEnvirons(1, &info);	if (GetWDInfo(info.sysVRefNum, vRefNumP, dirIDP, &wdProcID) !!= noErr) 	{		*vRefNumP = 0;		*dirIDP = 0;	}}void GetCPanelFolder(short *vRefNumP, long *dirIDP){	Boolean hasFolderMgr = false;	long feature;		if (TrapExists(_GestaltDispatch)) if (Gestalt(gestaltFindFolderAttr, &feature) == noErr) hasFolderMgr = true;	if (!!hasFolderMgr) 	{		GetSystemFolder(vRefNumP, dirIDP);		return;	}	else 	{		if (FindFolder(kOnSystemDisk, kControlPanelFolderType, kDontCreateFolder, vRefNumP, dirIDP) !!= noErr) 		{			*vRefNumP = 0;			*dirIDP = 0;		}	}}	/* SearchFolderForDNRP is called to search a folder for files that might 	contain the ''dnrp'' resource */short SearchFolderForDNRP(long targetType, long targetCreator, short vRefNum, long dirID){	HParamBlockRec fi;	Str255 filename;	short refnum;		fi.fileParam.ioCompletion = nil;	fi.fileParam.ioNamePtr = filename;	fi.fileParam.ioVRefNum = vRefNum;	fi.fileParam.ioDirID = dirID;	fi.fileParam.ioFDirIndex = 1;		while (PBHGetFInfo(&fi, false) == noErr) 	{		/* scan system folder for driver resource files of specific type & creator */		if (fi.fileParam.ioFlFndrInfo.fdType == targetType &&			fi.fileParam.ioFlFndrInfo.fdCreator == targetCreator) 		{			/* found the MacTCP driver file? */			refnum = HOpenResFile(vRefNum, dirID, filename, fsRdPerm);			if (GetIndResource(''dnrp'', 1) == NULL)				CloseResFile(refnum);			else				return refnum;		}		/* check next file in system folder */		fi.fileParam.ioFDirIndex++;		fi.fileParam.ioDirID = dirID;	/* PBHGetFInfo() clobbers ioDirID */	}	return(-1);}	/* OpenOurRF is called to open the MacTCP driver resources */short OpenOurRF(void){	short refnum;	short vRefNum;	long dirID;		/* first search Control Panels for MacTCP 1.1 */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''ztcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* next search System Folder for MacTCP 1.0.x */	GetSystemFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			/* finally, search Control Panels for MacTCP 1.0.x */	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP(''cdev'', ''mtcp'', vRefNum, dirID);	if (refnum !!= -1) return(refnum);			return -1;}	OSErr OpenResolver(char *fileName){	short 			refnum;	OSErr 			rc;		if (gDNRCodePtr !!= nil)		/* resolver already loaded in */		return(noErr);			/* open the MacTCP driver to get DNR resources. Search for it based on	   creator & type rather than simply file name */		refnum = OpenOurRF();	/* ignore failures since the resource may have been installed in the 	   System file if running on a Mac 512Ke */	   	/* load in the DNR resource package */	gDNRCodeHndl = GetIndResource(''dnrp'', 1);	if (gDNRCodeHndl == nil)	{		/* can''t open DNR */		return(ResError());	}		DetachResource(gDNRCodeHndl);	if (refnum !!= -1) 	{		CloseResFile(refnum);	}			/* lock the DNR resource since it cannot be reloated while opened */	MoveHHi(gDNRCodeHndl);	HLock(gDNRCodeHndl);		gDNRCodePtr = (ProcPtr)*gDNRCodeHndl;		/* call open resolver */	// RRK modification 1/95 use CallOpenResolverProc define to call UPP		rc = CallOpenResolverProc(gDNRCodePtr, OPENRESOLVER, fileName);	if (rc !!= noErr) 	{		/* problem with open resolver, flush it */		HUnlock(gDNRCodeHndl);		DisposeHandle(gDNRCodeHndl);		gDNRCodePtr = nil;	}	return(rc);}OSErr CloseResolver(void){		if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			/* call close resolver */	// RRK modification 1/95 use CallCloseResolverProc define to call UPP	// (void) (*dnr)(CLOSERESOLVER);	CallCloseResolverProc(gDNRCodePtr, CLOSERESOLVER);		/* release the DNR resource package */	HUnlock(gDNRCodeHndl);	DisposeHandle(gDNRCodeHndl);	gDNRCodePtr = nil;	return(noErr);}	// RRK modification 1/95 declare parameter resultProc to be of type 	// ResultProcUPP instead of a long	OSErr StrToAddr(char *hostName, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallStrToAddrProc define to call UPP	// return((*dnr)(STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));				return (CallStrToAddrProc(gDNRCodePtr, STRTOADDR, hostName, rtnStruct, resultproc, userDataPtr));}	OSErr AddrToStr(unsigned long addr, char *addrStr){	OSErr	err;	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToStrProc define to call UPP	// (*dnr)(ADDRTOSTR, addr, addrStr);		err = CallAddrToStrProc(gDNRCodePtr, ADDRTOSTR, addr, addrStr);	return(noErr);}	OSErr EnumCache(EnumResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallEnumCacheProc define to call UPP	// return((*dnr)(ENUMCACHE, resultproc, userDataPtr));	return (CallEnumCacheProc(gDNRCodePtr, ENUMCACHE, resultproc, userDataPtr));}		OSErr AddrToName(unsigned long addr, struct hostInfo *rtnStruct, 			ResultUPP resultproc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallAddrToNameProc define to call UPP	// return((*dnr)(ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));	return(CallAddrToNameProc(gDNRCodePtr, ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));}extern OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(HINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallHInfoProc(gDNRCodePtr, HXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	extern OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, 			ResultProc2UPP resultProc, Ptr userDataPtr){	if (gDNRCodePtr == nil)		/* resolver not loaded error */		return(notOpenErr);			// RRK modification 1/95 use CallHInfoProc define to call UPP	// return((*dnr)(MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));	return(CallMXInfoProc(gDNRCodePtr, MXINFO, hostName, returnRecPtr, resultProc, userDataPtr));}	/* removed ; (causes syntax err in Think C 5.0 */	'.!filePrimsFile	^ '#include "sq.h"/***	The state of a file is kept in the following structure,	which is stored directly in a Squeak bytes object.	NOTE: The Squeak side is responsible for creating an	object with enough room to store sizeof(SQFile) bytes.	The session ID is used to detect stale file objects--	files that were still open when an image was written.	The file pointer of such files is meaningless.	Files are always opened in binary mode; the higher	level does line-end conversion if needed.	Writeable files are opened read/write. The stdio spec	requires that an fflush or positioning operation be	done when switching between reading and writing. The	lastOp field records whether the last operation was	a read or write operation allowing the fflush to be	done automatically if needed.	typedef struct {		File	*file;		int		sessionID;		int		writable;		int		fileSize;		int		lastOp;  // 0 = uncommitted, 1 = read, 2 = write //	} SQFile;***//*** Constants ***/#define UNCOMMITTED	0#define READ_OP		1#define WRITE_OP	2/*** Variables ***/int thisSession = 0;int sqFileAtEnd(SQFile *f) {	/* Return true if the file''s read/write head is at the end of the file. */	if (!!sqFileValid(f)) return success(false);	return ftell(f->file) == f->fileSize;}int sqFileClose(SQFile *f) {	/* Close the given file. */	if (!!sqFileValid(f)) return success(false);	fclose(f->file);	f->file = NULL;	f->sessionID = 0;	f->writable = false;	f->fileSize = 0;	f->lastOp = UNCOMMITTED;}int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize) {	char cFileName[1000];	int i, err;	if (sqFileNameSize >= 1000) {		return success(false);	}	/* copy the file name into a null-terminated C string */	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	err = remove(cFileName);	if (err) {		return success(false);	}}int sqFileGetPosition(SQFile *f) {	/* Return the current position of the file''s read/write head. */	int position;	if (!!sqFileValid(f)) return success(false);	position = ftell(f->file);	if (position < 0) return success(false);	return position;}int sqFileInit(void) {	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	thisSession = clock() + time(NULL);	if (thisSession == 0) thisSession = 1;	/* don''t use 0 */}int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag) {	/* Opens the given file using the supplied sqFile structure	   to record its state. Fails with no side effects if f is	   already open. Files are always opened in binary mode;	   Squeak must take care of any line-end character mapping.	*/	char cFileName[1001];	int i;	/* don''t open an already open file */	if (sqFileValid(f)) return success(false);	/* copy the file name into a null-terminated C string */	if (sqFileNameSize > 1000) {		return success(false);	}	for (i = 0; i < sqFileNameSize; i++) {		cFileName[i] = *((char *) (sqFileNameIndex + i));	}	cFileName[sqFileNameSize] = 0;	if (writeFlag) {		/* First try to open an existing file read/write: */		f->file = fopen(cFileName, "r+b");		if (f->file == NULL) {			/* Previous call fails if file does not exist. In that case,			   try opening it in write mode to create a new, empty file.			*/			f->file = fopen(cFileName, "w+b");			if (f->file !!= NULL) {				/* set the type and creator of newly created Mac files */				dir_SetMacFileTypeAndCreator(cFileName, strlen(cFileName), "TEXT", "R*ch");				}		}		f->writable = true;	} else {		f->file = fopen(cFileName, "rb");		f->writable = false;	}	if (f->file == NULL) {		f->sessionID = 0;		f->fileSize = 0;		return success(false);	} else {		f->sessionID = thisSession;		/* compute and cache file size */		fseek(f->file, 0, SEEK_END);		f->fileSize = ftell(f->file);		fseek(f->file, 0, SEEK_SET);	}	f->lastOp = UNCOMMITTED;}int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Read count bytes from the given file into byteArray starting at	   startIndex. byteArray is the address of the first byte of a	   Squeak bytes object (e.g. String or ByteArray). startIndex	   is a zero-based index; that is a startIndex of 0 starts writing	   at the first byte of byteArray.	*/	char *dst;	int bytesRead;	if (!!sqFileValid(f)) return success(false);	if (f->writable && (f->lastOp == WRITE_OP)) fflush(f->file);  /* flush between writing and reading */	dst = (char *) (byteArrayIndex + startIndex);	bytesRead = fread(dst, 1, count, f->file);	f->lastOp = READ_OP;	return bytesRead;}int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize) {	char cOldName[1000], cNewName[1000];	int i, err;	if ((oldNameSize >= 1000) || (newNameSize >= 1000)) {		return success(false);	}	/* copy the file names into null-terminated C strings */	for (i = 0; i < oldNameSize; i++) {		cOldName[i] = *((char *) (oldNameIndex + i));	}	cOldName[oldNameSize] = 0;	for (i = 0; i < newNameSize; i++) {		cNewName[i] = *((char *) (newNameIndex + i));	}	cNewName[newNameSize] = 0;	err = rename(cOldName, cNewName);	if (err) {		return success(false);	}}int sqFileSetPosition(SQFile *f, int position) {	/* Set the file''s read/write head to the given position. */	if (!!sqFileValid(f)) return success(false);	fseek(f->file, position, SEEK_SET);	f->lastOp = UNCOMMITTED;}int sqFileSize(SQFile *f) {	/* Return the length of the given file. */	if (!!sqFileValid(f)) return success(false);	return f->fileSize;}int sqFileValid(SQFile *f) {	return (		(f !!= NULL) &&		(f->file !!= NULL) &&		(f->sessionID == thisSession));}int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex) {	/* Write count bytes to the given writable file starting at startIndex	   in the given byteArray. (See comment in sqFileReadIntoAt for interpretation	   of byteArray and startIndex).	*/	char *src;	int bytesWritten, position;	if (!!(sqFileValid(f) && f->writable)) return success(false);	if (f->lastOp == READ_OP) fflush(f->file);  /* flush between reading and writing */	src = (char *) (byteArrayIndex + startIndex);	bytesWritten = fwrite(src, 1, count, f->file);	position = ftell(f->file);	if (position > f->fileSize) {		f->fileSize = position;  /* update file size */	}	if (bytesWritten !!= count) {		success(false);	}	f->lastOp = WRITE_OP;	return bytesWritten;}'.!macDirectoryFile	^ '#include <MacHeaders.h>#include "sq.h"/***	The interface to the directory primitive is path based.	That is, the client supplies a Squeak string describing	the path to the directory on every call. To avoid traversing	this path on every call, a cache is maintained of the last	path seen, along with the Mac volume and folder reference	numbers corresponding to that path.***//*** Constants ***/#define ENTRY_FOUND     0#define NO_MORE_ENTRIES 1#define BAD_PATH        2#define DELIMITOR '':''#define MAX_PATH 2000/*** Variables ***/char lastPath[MAX_PATH + 1];int  lastPathValid = false;int  lastRefNum = 0;int  lastVolNum = 0;/*** Functions ***/int convertToSqueakTime(int macTime);int equalsLastPath(char *pathString, int pathStringLength);int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr);int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr);int lookupVolume(char *volName, int *refNumPtr);int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix);int recordPath(char *pathString, int pathStringLength, int refNum, int volNum);int convertToSqueakTime(int macTime) {	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than Mac one */	return macTime + (3 * 365 * 24 * 60 * 60);}int dir_Create(char *pathString, int pathStringLength) {	/* Create a new directory with the given path. By default, this	   directory is created in the current directory. Use	   a full path name such as "MyDisk:Working:New Folder" to	   create folders elsewhere. */	Str255 name;	HParamBlockRec pb;	int i;	for (i = 0; i < pathStringLength; i++) {		name[i] = pathString[i];	}	name[i] = 0; /* string terminator */	c2pstr((char *) name);	pb.fileParam.ioNamePtr = name;	pb.fileParam.ioVRefNum = 0;	pb.fileParam.ioDirID = 0;	return PBDirCreateSync(&pb) == noErr;}int dir_Delimitor(void) {	return DELIMITOR;}int dir_Lookup(char *pathString, int pathStringLength, int index,  /* outputs: */  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile) {	/* Lookup the index-th entry of the directory with the given path, starting	   at the root of the file system. Set the name, name length, creation date,	   creation time, directory flag, and file size (if the entry is a file).	   Return:	0 	if a entry is found at the given index	   			1	if the directory has fewer than index entries	   			2	if the given path has bad syntax or does not reach a directory	*/	int okay, newRefNum, newVolNum;	HVolumeParam volumeParams;	CInfoPBRec dirParams;	/* default return values */	*name             = 0;	*nameLength       = 0;	*creationDate     = 0;	*modificationDate = 0;	*isDirectory      = false;	*sizeIfFile       = 0;	if ((pathStringLength == 0)) {		/* get volume info */		volumeParams.ioNamePtr = (unsigned char *) name;		volumeParams.ioVRefNum = 0;		volumeParams.ioVolIndex = index;		okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(volumeParams.ioVCrDate);			*modificationDate = convertToSqueakTime(volumeParams.ioVLsMod);			*isDirectory      = true;			*sizeIfFile       = 0;			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	} else {		/* get file or directory info */		if (!!equalsLastPath(pathString, pathStringLength)) {			/* lookup and cache the refNum for this path */			okay = lookupPath(pathString, pathStringLength, &newRefNum, &newVolNum);			if (okay) {				recordPath(pathString, pathStringLength, newRefNum, newVolNum);			} else {				return BAD_PATH;			}		}		dirParams.hFileInfo.ioNamePtr = (unsigned char *) name;		dirParams.hFileInfo.ioFVersNum = 0;		dirParams.hFileInfo.ioFDirIndex = index;		if (lastRefNum < 0) {			dirParams.hFileInfo.ioVRefNum = lastRefNum;			dirParams.hFileInfo.ioDirID = 0;		} else {			dirParams.hFileInfo.ioVRefNum = lastVolNum;			dirParams.hFileInfo.ioDirID = lastRefNum;		}		okay = PBGetCatInfoSync(&dirParams) == noErr;		if (okay) {			p2cstr((unsigned char *) name);			*nameLength       = strlen(name);			*creationDate     = convertToSqueakTime(dirParams.hFileInfo.ioFlCrDat);			*modificationDate = convertToSqueakTime(dirParams.hFileInfo.ioFlMdDat);			if ((dirParams.hFileInfo.ioFlAttrib & 16) !!= 0) {				*isDirectory  = true;				*sizeIfFile   = 0;			} else {				*isDirectory  = false;				*sizeIfFile   = dirParams.hFileInfo.ioFlLgLen;			}			return ENTRY_FOUND;		} else {			return NO_MORE_ENTRIES;		}	}}int dir_PathToWorkingDir(char *pathName, int pathNameMax) {	/* Fill in the given string with the full path from a root volume to	   to current working directory. (At startup time, the working directory	   is set to the application''s directory. Fails if the given string is not	   long enough to hold the entire path. (Use at least 1000 characters to	   be safe.)	*/	char thisName[256];	CInfoPBRec pb;	int nextDirRefNum, pathLen;	/* initialize string copying state */	pathName[0] = 0;	pathLen = 0;	/* get refNum of working directory */	strcpy(thisName, ":");	pb.hFileInfo.ioNamePtr = c2pstr(thisName);	pb.hFileInfo.ioVRefNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID = 0;	if (PBGetCatInfoSync(&pb) !!= noErr) {		nextDirRefNum = 0;	}	nextDirRefNum = pb.hFileInfo.ioDirID;	while (true) {		thisName[0] = 0;		pb.hFileInfo.ioFDirIndex = -1; /* map ioDirID -> name */		pb.hFileInfo.ioVRefNum = 0;		pb.hFileInfo.ioDirID = nextDirRefNum;		if (PBGetCatInfoSync(&pb) !!= noErr) {			break;  /* we''ve reached the root */		}		p2cstr((unsigned char *) thisName);		pathLen = prefixPathWith(pathName, pathLen, pathNameMax, thisName);		nextDirRefNum = pb.dirInfo.ioDrParID;	}	return pathLen;}dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator) {	/* Set the Macintosh type and creator of the given file. */	/* Note: On other platforms, this is just a noop. */	Str255 name;	FInfo finderInfo;	int i;	/* copy file name into a Pascal string */	if (filenameSize > 255) return false;	name[0] = filenameSize;	for (i = 1; i <= filenameSize; i++) {		name[i] = filename[i - 1];	}	if (GetFInfo(name, 0, &finderInfo) !!= noErr) return false;	finderInfo.fdType = *((int *) fType);	finderInfo.fdCreator = *((int *) fCreator);	if (SetFInfo(name, 0, &finderInfo) !!= noErr) return false;	return true;}int equalsLastPath(char *pathString, int pathStringLength) {	/* Return true if the lastPath cache is valid and the	   given Squeak string equals it. */	int i, ch;	if (!!lastPathValid ||		(pathStringLength > MAX_PATH)) {			return false;	}	for (i = 0; i < pathStringLength; i++) {		ch = lastPath[i];		if ((ch == 0) || (ch !!= pathString[i])) return false;	}	return lastPath[i] == 0;}int lookupDirectory(int volRefNum, int folderRefNum, char *name, int *refNumPtr) {	/* Look up the next directory in a path starting from the folder and volume	   with the given reference numbers and setting *refNumPtr to the reference	   number of the resulting folder. Return true if this succeeds. */	CInfoPBRec pb;	c2pstr((char *) name);	pb.hFileInfo.ioNamePtr = (unsigned char *) name;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioVRefNum = volRefNum;	pb.hFileInfo.ioDirID = folderRefNum;	if (PBGetCatInfoSync(&pb) == noErr) {		p2cstr((unsigned char *) name);		*refNumPtr = pb.hFileInfo.ioDirID;		return true;	}	p2cstr((unsigned char *) name);	return false;}int lookupPath(char *pathString, int pathStringLength, int *refNumPtr, int *volNumPtr) {	/* Resolve the given path and return the resulting folder or volume	   reference number in *refNumPtr. Return false if the path is bad. */	char chunk[100];	int stIndex, chunkIndex, ch;	int okay, thisVolNum = 0, thisRefNum = 0;	int firstChunk = true, hasLeadingDelimitors = false;	stIndex = 0;	while (stIndex < pathStringLength) {		chunkIndex = 0;		while ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {			/* copy any leading delimitors */			chunk[chunkIndex++] = pathString[stIndex++];			hasLeadingDelimitors = true;		}		while ((stIndex < pathStringLength) && (pathString[stIndex] !!= DELIMITOR)) {			/* copy up to the next delimitor */			ch = chunk[chunkIndex++] = pathString[stIndex++];		}		if (firstChunk && (chunk[chunkIndex] !!= DELIMITOR)) {			/* Add a trailing delimiter to the first chunk of the			   path to indicate that it is a volume name. If the			   path starts with an initial delimitor, it will be			   interpreted as a path relative to the current working			   directory even with a trailing delimitor, which is			   exactly the behavior we want. */			chunk[chunkIndex++] = DELIMITOR;			if ((stIndex < pathStringLength) && (pathString[stIndex] == DELIMITOR)) {				stIndex++;			}			firstChunk = false;		}		chunk[chunkIndex] = 0;  /* terminate this chunk */		if ((thisVolNum == 0) && !!hasLeadingDelimitors) {			okay = lookupVolume(chunk, &thisVolNum);			thisRefNum = 0;		} else {			okay = lookupDirectory(thisVolNum, thisRefNum, chunk, &thisRefNum);		}		if (!!okay) {			*refNumPtr = 0;			*volNumPtr = 0;			return false;		}	}	*refNumPtr = thisRefNum;	*volNumPtr = thisVolNum;	return true;}int lookupVolume(char *volName, int *refNumPtr) {	/* Look up the volume with the given name and set *refNumPtr	   to the reference number of the resulting volume.	   Return true if this succeeds. */	int okay;	HVolumeParam volumeParams;	volumeParams.ioNamePtr = c2pstr(volName);	volumeParams.ioVRefNum = 0;	volumeParams.ioVolIndex = -1;	okay = PBHGetVInfoSync((HParmBlkPtr) &volumeParams) == noErr;	p2cstr((unsigned char *) volName);	if (okay) {		*refNumPtr = volumeParams.ioVRefNum;		return true;	}	return false;}int prefixPathWith(char *pathName, int pathNameSize, int pathNameMax, char *prefix) {	/* Insert the given prefix C string plus a delimitor character at the	   beginning of the given C string. Return the new pathName size. Fails	   if pathName is does not have sufficient space for the result.	   Assume: pathName is null terminated.	*/	int offset, i;	offset = strlen(prefix) + 1;	if ((pathNameSize + offset) > pathNameMax) {		error("path name to working directory is too long for available space");	}	for (i = pathNameSize; i >= 0; i--) {		/* make room in pathName for prefix (moving string terminator, too) */		pathName[i + offset] = pathName[i];	}	for (i = 0; i < offset; i++) {		/* make room in pathName for prefix */		pathName[i] = prefix[i];	}	pathName[offset - 1] = DELIMITOR;  /* insert delimitor */	return pathNameSize + offset;}int recordPath(char *pathString, int pathStringLength, int refNum, int volNum) {	/* Copy the given Squeak string into the lastPath cache. */	int i;	if (pathStringLength > MAX_PATH) {		lastPath[0] = 0; /* set to empty string */		lastPathValid = false;		lastRefNum = 0;		lastVolNum = 0;		return;	}	for (i = 0; i < pathStringLength; i++) {		lastPath[i] = pathString[i];	}	lastPath[i] = 0; /* string terminator */	lastPathValid = true;	lastRefNum = refNum;	lastVolNum = volNum;}'!macJoystickFile	^ '#include <DeskBus.h>#include "sq.h"#define MOUSESTICK_SIGNATURE 0x4A656666#define MAX_STICKS 4typedef struct {	short			rawX;				/* absolute stick position */	short			rawY;	unsigned char	buttons;	char			private1;	short			cursorX;			/* cursor position */	short			cursorY;	char			oldStickType;	char			private2;	char			stickOn;			/* true if stick is connected */	char			private3;	char			stickControlsCursor;	char			applicationAware;	/* settings change with application changes */	char			private4[152];} MouseStickRec;typedef struct {	long			signature;	char			private1[18];	short			stickCount;	char			private2[22];	MouseStickRec	stick[MAX_STICKS];} MouseStickSetRec, *MouseStickSetPtr;/*** Variables ***/MouseStickSetPtr joySticks = nil;  /* pointer to a joystick set or nil */int joystickInit(void) {	/* If a joystick is plugged in and its control panel is installed,	   initialize the global pointer ''joySticks'' to the joystick set	   data structure. Otherwise, set it to nil.	*/	ADBDataBlock adbGetInfo;	MouseStickSetPtr sticks;	int count, i;	joySticks = nil;  /* set to nil in case we don''t find any joysticks */	count = CountADBs();	for (i = 1; i <= count; i++) {		GetADBInfo(&adbGetInfo, GetIndADB(&adbGetInfo, i));		sticks = (MouseStickSetPtr) adbGetInfo.dbDataAreaAddr;		if ((sticks !!= nil) && (sticks->signature == MOUSESTICK_SIGNATURE)) {			joySticks = sticks;			return;		}	}}int joystickRead(int stickIndex) {	/* Return input word for the joystick with the given index (in range [1..2]	   on the Macintosh; other platforms may vary). This word is encoded as follows:		<onFlag (1 bit)><buttonFlags (5 bits)><x-value (11 bits)><y-value (11 bits)>	   The highest four bits of the input word are zero. If the onFlag bit is zero,	   there is no joystick at the given index. This may be because no joystick	   is connected or the joystick control panel is not installed. In such,	   cases, the entire word will be zero. A maximum of two joysticks are supported	   by Gravis''s current version of the control panel. The x and y values are	   11-bit signed values in the range [-1024..1023] representing the raw (unencoded)	   joystick position. The MouseStick II only uses the approximate range [-650..650].	   The range and center values of poorly adjusted joysticks may vary; the client	   software should provide a way to adjust the center and scaling to correct.	*/	MouseStickRec stickData;	int buttons, xBits, yBits;	if ((joySticks == nil) || (stickIndex < 1) || (stickIndex > 2) ||		(stickIndex > joySticks->stickCount)) {			return 0;  /* no joystick at the given index */	}	stickData = joySticks->stick[stickIndex - 1];  /* 1-based index */	buttons = ~stickData.buttons & 0x1F;	xBits = (0x400 + stickData.rawX) & 0x7FF;	yBits = (0x400 + stickData.rawY) & 0x7FF;	return (1 << 27) | (buttons << 22) | (yBits << 11) | xBits;}'!macNetworkFile	^ '#include "sq.h"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include <Events.h>#include <Devices.h>#include "MacTCP.h"#include "AddressXLation.h"/*** Socket TYpe Constants ***/#define TCPSocketType 0#define UDPSocketType 1/*** Resolver Status Constants ***/#define RESOLVER_UNINITIALIZED	0#define RESOLVER_SUCCESS		1#define RESOLVER_BUSY			2#define RESOLVER_ERROR			3/* Resolver State */typedef struct {	int				semaIndex;	int				status;	int				error;	int				localAddress;	int				remoteAddress;	struct hostInfo	hostInfo;} ResolverStatusRec, *ResolverStatusPtr;/*** TCP Socket Status Constants ***/#define Unconnected				0#define WaitingForConnection	1#define Connected				2#define OtherEndClosed			3#define ThisEndClosed			4/*** TCP Socket State ***/#define SendBufferSize	( 8 * 1024)#define RecvBufferSize	(16 * 1024)typedef struct {	TCPiopb		tcpPB;				/* TCP parameter block for open/send (must be first) */	TCPiopb		closePB;			/* TCP parameter block for close */	StreamPtr	tcpStream;			/* TCP stream */	struct TCPSockRec *next;		/* next socket in a linked list of sockets */	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;//xxx	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} TCPSockRec, *TCPSockPtr;typedef struct {	TCPiopb		tcpPB;	TCPSockPtr	mySocket;	struct wdsEntry wds[2];	char		data[SendBufferSize];} TCPSendBuf, *TCPSendBufPtr;#define SendBufCount 2TCPSendBuf sendBufPool[SendBufCount];int nextSendBuf = 0;/*** UDP Socket Status Constants ***/#define UnknowRemoteAddrAndPort	0#define Ready					1/*** UDP Socket State ***/typedef struct {	struct UDPSockRec *next;		/* next socket in a linked list of sockets */	int			remoteAddress;	int			remotePort;	int			connectStatus;	int			dataAvailable;		/* suggests that data may be available */	int			sendInProgress;	int			lastError;	char		sendBuf[SendBufferSize];	char		rcvBuf[1];			/* must be last; length set when allocated */} UDPSockRec, *UDPSockPtr;/*** Variables ***/short				macTCPRefNum = 0;int					mtuSize = 1024;TCPSockPtr			openTCPSockets = nil;UDPSockPtr			openUDPSockets = nil;ResolverStatusRec 	resolver = {0, 0, 0, 0, 0, 0, 0};ResultUPP			resolverDoneProc = nil;TCPIOCompletionUPP	tcpCloseDoneProc = nil;TCPIOCompletionUPP	tcpConnectDoneProc = nil;TCPNotifyUPP		tcpNotifyProc = nil;TCPIOCompletionUPP	tcpSendDoneProc = nil;UDPNotifyUPP		udpNotifyProc = nil;UDPIOCompletionUPP	udpSendDoneProc = nil;	int					thisNetSession = 0;/*** Private TCP Socket Functions ***/void *		TCPSockCreate(void);void		TCPSockDestroy(TCPSockPtr s);int			TCPSockLocalAddress(TCPSockPtr s);int			TCPSockLocalPort(TCPSockPtr s);int			TCPSockRemoteAddress(TCPSockPtr s);int			TCPSockRemotePort(TCPSockPtr s);void		TCPSockConnectTo(TCPSockPtr s, int addr, int port);void		TCPSockListenOn(TCPSockPtr s, int port);void		TCPSockAbortConnection(TCPSockPtr s);void		TCPSockCloseConnection(TCPSockPtr s);int			TCPSockDataAvailable(TCPSockPtr s);int			TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize);int			TCPSockSendData(TCPSockPtr s, char *buf, int bufSize);/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void);void		UDPSockDestroy(UDPSockPtr s);int			UDPSockLocalAddress(UDPSockPtr s);int			UDPSockLocalPort(UDPSockPtr s);int			UDPSockRemoteAddress(UDPSockPtr s);int			UDPSockRemotePort(UDPSockPtr s);void		UDPSockConnectTo(UDPSockPtr s, int addr, int port);void		UDPSockListenOn(UDPSockPtr s, int port);int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize);int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize);/*** Other Private Functions ***/void		InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr);pascal void	ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr);int			ResolverInitialize(int resolverSemaIndex);void		ResolverTerminate(void);int			SocketValid(SocketPtr s);void		TCPCloseCompletionRoutine(struct TCPiopb *s);void		TCPConnectCompletionRoutine(struct TCPiopb *s);pascal void	TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg);void		TCPSendCompletionRoutine(struct TCPiopb *s);/*** Network Functions ***/int sqNetworkInit(int resolverSemaIndex) {	/* initialize the network and return 0 if successful */	int localAddr;	UDPiopb paramBlock;	OSErr err = noErr;	if (thisNetSession !!= 0) return 0;  /* noop if network is already initialized */	/* Create a session ID that is unlikely to be repeated.	   Zero is never used for a valid session number.	   Should be called once at startup time.	*/	/* open resolver */	err = ResolverInitialize(resolverSemaIndex);	if (err !!= noErr) {		return -1;	}	/* get local address */	localAddr = sqResolverLocalAddress();	if (sqResolverError() !!= noErr) {		ResolverTerminate();		return -1;	}	/* compute MTU (maximum transfer unit) size */	memset(&paramBlock, 0, sizeof(paramBlock));	paramBlock.csCode = UDPMaxMTUSize;	paramBlock.csParam.mtu.remoteHost = localAddr;	paramBlock.ioCRefNum = macTCPRefNum;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err == noErr) {		mtuSize = paramBlock.csParam.mtu.mtuSize;		} else {		mtuSize = 1024;  /* guess */		return -1;	}	resolverDoneProc	= NewResultProc(ResolverCompletionRoutine);	tcpCloseDoneProc 	= NewTCPIOCompletionProc(TCPCloseCompletionRoutine);	tcpConnectDoneProc	= NewTCPIOCompletionProc(TCPConnectCompletionRoutine);	tcpNotifyProc		= NewTCPNotifyProc(TCPNotificationRoutine);	tcpSendDoneProc		= NewTCPIOCompletionProc(TCPSendCompletionRoutine);	/* success!! */  	thisNetSession = clock() + time(NULL);	if (thisNetSession == 0) thisNetSession = 1;  /* don''t use 0 */	return 0;}void sqNetworkShutdown(void) {	/* shut down the network */	if (thisNetSession == 0) return;  /* noop if network is already shut down */	ResolverTerminate();	thisNetSession = 0;}/*** Squeak Generic Socket Functions ***/void sqSocketAbortConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockAbortConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}void sqSocketCloseConnection(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockCloseConnection((TCPSockPtr) s->privateSocketPtr);	} else {		success(false);	}}int sqSocketConnectionStatus(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->connectStatus;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->connectStatus;	}}void sqSocketConnectToPort(SocketPtr s, int addr, int port) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockConnectTo((TCPSockPtr) s->privateSocketPtr, addr, port);	} else {		UDPSockConnectTo((UDPSockPtr) s->privateSocketPtr, addr, port);	}}void sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex) {	TCPSockPtr tcpSock = nil;	UDPSockPtr udpSock = nil;	/* reference args to suppress compiler warnings about unused variables */	s; netType; recvBufSize; sendBufSize; semaIndex;		s->sessionID = 0;	if (socketType == TCPSocketType) {		tcpSock = TCPSockCreate();		if (tcpSock == nil) {			success(false);		} else {			s->sessionID = thisNetSession;			s->socketType = TCPSocketType;			s->privateSocketPtr = tcpSock;		}	} else {		udpSock = UDPSockCreate();		if (udpSock == nil) {			success(false);		} else {			s->sessionID = thisNetSession;			s->socketType = UDPSocketType;			s->privateSocketPtr = udpSock;		}	}}void sqSocketDestroy(SocketPtr s) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockDestroy((TCPSockPtr) s->privateSocketPtr);	} else {		UDPSockDestroy((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketError(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return ((TCPSockPtr) s->privateSocketPtr)->lastError;	} else {		return ((UDPSockPtr) s->privateSocketPtr)->lastError;	}}void sqSocketListenOnPort(SocketPtr s, int port) {	if (!!SocketValid(s)) return;	if (s->socketType == TCPSocketType) {		TCPSockListenOn((TCPSockPtr) s->privateSocketPtr, port);	} else {		UDPSockListenOn((UDPSockPtr) s->privateSocketPtr, port);	}}int sqSocketLocalAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketLocalPort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockLocalPort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockLocalPort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketReceiveDataAvailable(SocketPtr s) {	if (!!SocketValid(s)) return 0;	if (s->socketType == TCPSocketType) {		return TCPSockDataAvailable((TCPSockPtr) s->privateSocketPtr);	} else {		return ((UDPSockPtr) s->privateSocketPtr)->dataAvailable;	}}int sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRecvData((TCPSockPtr) s->privateSocketPtr, (char *) buf, bufSize);	} else {		return UDPSockRecvData((UDPSockPtr) s->privateSocketPtr, (char *) buf, bufSize);	}}int sqSocketRemoteAddress(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemoteAddress((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemoteAddress((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketRemotePort(SocketPtr s) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockRemotePort((TCPSockPtr) s->privateSocketPtr);	} else {		return UDPSockRemotePort((UDPSockPtr) s->privateSocketPtr);	}}int sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize) {	if (!!SocketValid(s)) return -1;	if (s->socketType == TCPSocketType) {		return TCPSockSendData((TCPSockPtr) s->privateSocketPtr, (char *) buf, bufSize);	} else {		return UDPSockSendData((UDPSockPtr) s->privateSocketPtr, (char *) buf, bufSize);	}}int sqSocketSendDone(SocketPtr s) {	if (!!SocketValid(s)) return 1;	if (s->socketType == TCPSocketType) {		return !!((TCPSockPtr) s->privateSocketPtr)->sendInProgress;	} else {		return !!((UDPSockPtr) s->privateSocketPtr)->sendInProgress;	}}/*** Resolver Functions ***/void sqResolverAbort(void) {	int semaIndex;	/* abort the current request */	if (resolver.status == RESOLVER_BUSY) {		semaIndex = resolver.semaIndex;		ResolverTerminate();		ResolverInitialize(semaIndex);	}}void sqResolverAddrLookupResult(char *nameForAddress, int nameSize) {	/* copy the name found by the last address lookup into the given string */	memcpy(nameForAddress, resolver.hostInfo.cname, nameSize);}int sqResolverAddrLookupResultSize(void) {	return strlen(resolver.hostInfo.cname);}int sqResolverError(void) {	return resolver.error;}int sqResolverLocalAddress(void) {	struct GetAddrParamBlock paramBlock;	OSErr err = noErr;	if (resolver.localAddress == 0) {		resolver.remoteAddress = 0;		memset(&paramBlock, 0, sizeof(struct GetAddrParamBlock));		paramBlock.ioResult = 1;		paramBlock.csCode = ipctlGetAddr;		paramBlock.ioCRefNum = macTCPRefNum;		PBControlSync((ParmBlkPtr) &paramBlock);		if (paramBlock.ioResult == noErr) {			resolver.status = RESOLVER_SUCCESS;			resolver.localAddress = paramBlock.ourAddress;			resolver.error = noErr;		} else {			resolver.status = RESOLVER_ERROR;			resolver.error = paramBlock.ioResult;		}	}	return resolver.localAddress;}int sqResolverNameLookupResult(void) {	/* return the result of the last successful lookup */	return resolver.remoteAddress;}void sqResolverStartAddrLookup(int address) {	OSErr err;	resolver.status = RESOLVER_BUSY;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = AddrToName(address, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;	} else {		if (err !!= cacheFault) {			/* unexpected error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}void sqResolverStartNameLookup(char *hostName, int nameSize) {	char name[501];	int len; 	OSErr err;	len = ((nameSize <= 500) ? nameSize : 500);	memcpy(name, hostName, len);	name[len] = ''\0'';	resolver.status = RESOLVER_BUSY;	memset(&resolver.hostInfo, 0, sizeof(hostInfo));	err = StrToAddr(name, &resolver.hostInfo, resolverDoneProc, (char *) &resolver);	if (err == noErr) {		/* address was in cache; lookup is already done */		resolver.status = RESOLVER_SUCCESS;		resolver.remoteAddress = resolver.hostInfo.addr[0];	} else {		if (err !!= cacheFault) {			/* unexpected error */			resolver.status = RESOLVER_ERROR;			resolver.error = err;		}	}}int sqResolverStatus(void) {	return resolver.status;}/*** Private Resolver Functions ***/int ResolverInitialize(int resolverSemaIndex) {	OSErr err = noErr;	if (resolver.status !!= RESOLVER_UNINITIALIZED) {		ResolverTerminate();	}	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;//xxx move to network init:	macTCPRefNum = 0;	err = OpenDriver("\p.IPP", &macTCPRefNum);	if (err !!= noErr) {		resolver.error = err;		resolver.status = RESOLVER_ERROR;		return err;	}	err = OpenResolver(nil);	if (err !!= noErr) {		resolver.error = err;		resolver.status = RESOLVER_ERROR;		return err;	}	resolver.semaIndex = resolverSemaIndex;	resolver.status = RESOLVER_SUCCESS;	return noErr;}static pascal void ResolverCompletionRoutine(struct hostInfo *hostInfoPtr, char *userDataPtr) {	/* completion routine */	if (((ResolverStatusPtr) userDataPtr)->hostInfo.rtnCode == noErr) {		((ResolverStatusPtr) userDataPtr)->status = RESOLVER_SUCCESS;		((ResolverStatusPtr) userDataPtr)->remoteAddress = hostInfoPtr->addr[0];	} else {		((ResolverStatusPtr) userDataPtr)->status = RESOLVER_ERROR;		((ResolverStatusPtr) userDataPtr)->error = hostInfoPtr->rtnCode;	}}void ResolverTerminate(void) {	CloseResolver();	memset(&resolver, 0, sizeof(ResolverStatusRec));	resolver.status = RESOLVER_UNINITIALIZED;}/*** Private TCP Socket Functions ***/void * TCPSockCreate(void) {	TCPiopb paramBlock;	TCPSockPtr s = nil;	int minRcvBufSize, rcvBufSize;	OSErr err = noErr;	rcvBufSize = RecvBufferSize;	minRcvBufSize = (4 * mtuSize) + 1024;	if (rcvBufSize < minRcvBufSize) rcvBufSize = minRcvBufSize;		s = (TCPSockPtr) malloc(sizeof(TCPSockRec) + rcvBufSize);	if (s == nil) return nil;  /* allocation failed */	memset(s, 0, sizeof(TCPSockRec) + rcvBufSize);	InitTCPCmd(TCPCreate, nil, &paramBlock);	paramBlock.csParam.create.rcvBuff = s->rcvBuf;	paramBlock.csParam.create.rcvBuffLen = rcvBufSize;	paramBlock.csParam.create.notifyProc = tcpNotifyProc;	paramBlock.csParam.create.userDataPtr = (Ptr) s;	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		free(s);		return nil;	}	s->tcpStream = paramBlock.tcpStream;	return s;}int TCPSockDataAvailable(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return false;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.amtUnreadData > 0;}void TCPSockDestroy(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return;  /* already destroyed */	}	InitTCPCmd(TCPRelease, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	s->tcpStream = nil;	free(s);}int TCPSockLocalAddress(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localHost;}int TCPSockLocalPort(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.localPort;}int TCPSockRemoteAddress(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remoteHost;}int TCPSockRemotePort(TCPSockPtr s) {	TCPiopb paramBlock;	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) {		return 0;  /* already destroyed */	}	InitTCPCmd(TCPStatus, s->tcpStream, &paramBlock);	err = PBControlSync((ParmBlkPtr) &paramBlock);	if (err !!= noErr) {		return 0;	}	return paramBlock.csParam.status.remotePort;}void TCPSockConnectTo(TCPSockPtr s, int addr, int port) {	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPActiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.remoteHost = addr;	s->tcpPB.csParam.open.remotePort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->connectStatus = Unconnected;		s->lastError = err;	}}void TCPSockListenOn(TCPSockPtr s, int port) {	OSErr err = noErr;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPPassiveOpen, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.open.localPort = port;	s->connectStatus = WaitingForConnection;	s->tcpPB.ioCompletion = tcpConnectDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->connectStatus = Unconnected;		s->lastError = err;	}}void TCPSockCloseConnection(TCPSockPtr s) {	/* Note: This operation uses a dedicated parameter block so that it	   can be invoked even in the previous send is not yet complete.	   It will eventually use a completion routine to delete the	   socket automatically. For now, this is the client''s responsibility.	*/	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPClose, s->tcpStream, &s->closePB);//	s->closePB.ioCompletion = tcpCloseDoneProc;	s->connectStatus = ThisEndClosed; // xxx remove when making this async	s->lastError = PBControlSync((ParmBlkPtr) &s->closePB);}void TCPSockAbortConnection(TCPSockPtr s) {	TCPiopb paramBlock;	if ((s == nil) || (s->tcpStream == nil)) return;  /* socket destroyed */	InitTCPCmd(TCPAbort, s->tcpStream, &paramBlock);	s->lastError = PBControlSync((ParmBlkPtr) &paramBlock);	s->connectStatus = Unconnected;}int TCPSockRecvData(TCPSockPtr s, char *buf, int bufSize) {	TCPiopb paramBlock;  /* use local parameter block since send may be using one in socket */	OSErr err = noErr;	int bytesRead;	if (!!TCPSockDataAvailable(s)) return 0;  /* no data available */	InitTCPCmd(TCPRcv, s->tcpStream, &paramBlock);	paramBlock.csParam.receive.commandTimeoutValue = 1; /* finish in one second, data or not */	paramBlock.csParam.receive.rcvBuff = buf;	paramBlock.csParam.receive.rcvBuffLen = bufSize;	err = PBControlSync((ParmBlkPtr) &paramBlock);  /* synchronous */	if (err == noErr) {		bytesRead = paramBlock.csParam.receive.rcvBuffLen;	} else {		/* if err == commandTimeout, no data was available */		bytesRead = 0;		if (!!((err == commandTimeout) || (err == connectionClosing))) {			s->lastError = err;		}	}	s->dataAvailable = (bytesRead !!= 0);  /* if we got data, there may be more */	return bytesRead;}int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize);int xxxGOODTCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	int sendCount;	OSErr err = noErr;	struct wdsEntry wds[2];	/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;//xxx	memcpy(s->sendBuf, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	wds[0].length = sendCount;//xxx		wds[0].ptr = s->sendBuf;	wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &s->tcpPB);	s->tcpPB.csParam.send.wdsPtr = (Ptr) &wds;	s->tcpPB.csParam.send.pushFlag = true;	s->sendInProgress = true;	s->tcpPB.ioCompletion = tcpSendDoneProc;	err = PBControlAsync((ParmBlkPtr) &s->tcpPB);	if (err !!= noErr) {		s->sendInProgress = false;		s->lastError = err;		return 0;	}	return sendCount;}int TCPSockSendData(TCPSockPtr s, char *buf, int bufSize) {	TCPSendBufPtr sendBuf;	OSErr err = noErr;	int sendCount;	sendBuf = &sendBufPool[nextSendBuf++];	if (nextSendBuf >= SendBufCount) nextSendBuf = 0;	sendBuf->mySocket = s;		/* copy client data into sendBuf to allow asynchronous send */	sendCount = (bufSize <= SendBufferSize) ? bufSize : SendBufferSize;	memcpy(sendBuf->data, buf, sendCount);	/* set up WDS entry; zero length marks end of chunk list */	sendBuf->wds[0].length = sendCount;	sendBuf->wds[0].ptr = sendBuf->data;	sendBuf->wds[1].length = 0;	InitTCPCmd(TCPSend, s->tcpStream, &sendBuf->tcpPB);	sendBuf->tcpPB.csParam.send.wdsPtr = (Ptr) &sendBuf->wds;	sendBuf->tcpPB.csParam.send.pushFlag = true;	sendBuf->tcpPB.ioCompletion = tcpSendDoneProc;	s->sendInProgress = true;	err = PBControlAsync((ParmBlkPtr) &sendBuf->tcpPB);	if (err !!= noErr) {		s->sendInProgress = false;		s->lastError = err;		return 0;	}	return sendCount;}/*** Private TCP Socket Utilities ***/void InitTCPCmd(int cmd, StreamPtr tcpStream, TCPiopb *paramBlkPtr) {	memset(paramBlkPtr, 0, sizeof(TCPiopb));	paramBlkPtr->csCode = cmd;	paramBlkPtr->tcpStream = tcpStream;	paramBlkPtr->ioCRefNum = macTCPRefNum;	paramBlkPtr->ioResult = 1;}int SocketValid(SocketPtr s) {	if ((s !!= NULL) &&		(s->privateSocketPtr !!= NULL) &&		(s->sessionID == thisNetSession)) {		return true;	} else {		success(false);		return false;	}}void TCPCloseCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		if (s->connectStatus == OtherEndClosed) {			s->connectStatus = Unconnected;		} else {			s->connectStatus = ThisEndClosed;		}	} }void TCPConnectCompletionRoutine(struct TCPiopb *pbPtr) {	TCPSockPtr s = (TCPSockPtr) pbPtr;	s->lastError = s->tcpPB.ioResult;	if (s->lastError == noErr) {		s->connectStatus = Connected;	} else {		s->connectStatus = Unconnected;	}}pascal void TCPNotificationRoutine(	StreamPtr s, unsigned short eventCode, Ptr userDataPtr,	unsigned short terminReason, struct ICMPReport *icmpMsg) {	/* called when data arrives or stream status changes */	/* reference args to suppress compiler warnings about unused variables */	s; terminReason; icmpMsg;		if (eventCode == TCPDataArrival) {		((TCPSockPtr) userDataPtr)->dataAvailable = true;		return;	}	if (eventCode == TCPClosing) {		if (((TCPSockPtr) userDataPtr)->connectStatus == ThisEndClosed) {			((TCPSockPtr) userDataPtr)->connectStatus = Unconnected;		} else {			((TCPSockPtr) userDataPtr)->connectStatus = OtherEndClosed;		}		return;	}	if (eventCode == TCPTerminate) {		((TCPSockPtr) userDataPtr)->connectStatus = Unconnected;		return;	}}void TCPSendCompletionRoutine(struct TCPiopb *pbPtr) {//xxx	TCPSockPtr s = (TCPSockPtr) pbPtr;TCPSockPtr s = ((TCPSendBufPtr) pbPtr)->mySocket;		s->lastError = s->tcpPB.ioResult;	s->sendInProgress = false;}/*** Private UDP Socket Functions ***/void *		UDPSockCreate(void) {	// xxx}void		UDPSockDestroy(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockLocalPort(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemoteAddress(UDPSockPtr s) {	// xxx	s;}int			UDPSockRemotePort(UDPSockPtr s) {	// xxx	s;}void		UDPSockConnectTo(UDPSockPtr s, int addr, int port) {	// xxx	s; addr; port;}void		UDPSockListenOn(UDPSockPtr s, int port) {	// xxx	s; port;}int			UDPSockRecvData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}int			UDPSockSendData(UDPSockPtr s, char *buf, int bufSize) {	// xxx	s; buf; bufSize;}'.!macSoundFile	^ '#include <MacHeaders.h>#include <Sound.h>#include "sq.h"/******  Mac Sound Notes:	On Macs that support it (all PPC Macs, I believe), 16-bit sound should	be used. I measured a slight increase in overhead for background sound	generation (5% to 7.5% for 16-bit sound version 2.5% to 5% for 8-bit).	The cost of copying the larger buffer in snd_PlaySamplesFromAtLength	was too small to easily measure in both 8-bit and 16-bits. On the other	hand, 16-bits give far, far superiour sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	Here are the various sound buffer formats from Squeak:		1. mono,    8-bits -- packed array of bytes		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes		3. mono,   16-bits -- array of 32-bit words, samples in low-order 16 bits (high bits ignored)		4. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	-- John Maloney, July 28, 1996******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} BufferStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** variables ***/SndChannelPtr chan;BufferStateRec bufState = {false, false, 0, 0, NULL, NULL, true};SndDoubleBufferHeader dblBufHeader;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	BufferStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (BufferStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	}}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}/*** exported functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, skip every other frame of the source */			while (src < end) {				src++;  /* skip high word */				*dst++ = *src++;			}		}	}	return framesWritten;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0  	= BUF_EMPTY;	bufState.bufState1  	= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}'!macTCPFile	^ '/* 	File:		MacTCP.h  	Contains:	TCP Manager Interfaces.  	Version:	Technology:	MacTCP 2.0.6 				Package:	Universal Interfaces 2.11 in MPW Prerelease on ETO #17  	Copyright:	 1984-1995 by Apple Computer, Inc. 				All rights reserved.  	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter 				stack.  Include the file and version information (from above) 				in the problem description and send to: 					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __MACTCP__#define __MACTCP__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __APPLETALK__#include <AppleTalk.h>#endif/*	#include <OSUtils.h>										*//*		#include <MixedMode.h>									*//*		#include <Memory.h>										*/#ifdef __cplusplusextern "C" {#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif/*Developer Notes:		0. This MacTCP header replaces what used to be defined in the following header files			MacTCPCommonTypes.h			GetMyIPAddr.h			MiscIPPB.h			TCPPB.h			UDPPB.h 						When the various control calls are made to the ip driver, you must set up a 			NewRoutineDescriptor for every non-nil completion routine and/or notifyProc parameter.  			Otherwise, the 68K driver code, will not correctly call your routine.		1. For ipctlGetAddr Control calls, use NewGetIPIOCompletionProc			to set up a GetIPIOCompletionUPP universal procptr to pass as			the ioCompletion parameter.		2. For the ipctlEchoICMP and ipctlLAPStats Control calls, use 			NewIPIOCompletion to set up a IPIOCompletionUPP universal procptr			to pass in the ioCompletion field of the parameter block.		3. For TCPCreatePB Control calls, use NewTCPNotifyProc to set up a			TCPNotifyUPP universal procptr to pass in the notifyProc field			of the parameter block		4. For all of the TCP Control calls using the TCPiopb parameter block,			use NewTCPIOCompletionProc to set up a TCPIOCompletionUPP			universal procptr to pass in the ioCompletion field of the paramter			block.		5. For UDBCreatePB Control calls, use NewUDPNotifyProc to set up a			UDPNotifyUPP universal procptr to pass in the notifyProc field			of the parameter block		6. For all of the UDP Control calls using the UDPiopb parameter block,			use NewUDPIOCompletionProc to set up a UDPIOCompletionUPP			universal procptr to pass in the ioCompletion field of the paramter			block.		7. For all calls implementing a notifyProc or ioCompletion routine			which was set up using a NewTCPRoutineProc call, do not call			DisposeRoutineSDescriptor on the universal procptr until			after the completion or notify proc has completed.*//* MacTCP return Codes in the range -23000 through -23049 */enum {	inProgress					= 1,							/* I/O in progress */	ipBadLapErr					= -23000,						/* bad network configuration */	ipBadCnfgErr				= -23001,						/* bad IP configuration error */	ipNoCnfgErr					= -23002,						/* missing IP or LAP configuration error */	ipLoadErr					= -23003,						/* error in MacTCP load */	ipBadAddr					= -23004,						/* error in getting address */	connectionClosing			= -23005,						/* connection is closing */	invalidLength				= -23006,	connectionExists			= -23007,						/* request conflicts with existing connection */	connectionDoesntExist		= -23008,						/* connection does not exist */	insufficientResources		= -23009,						/* insufficient resources to perform request */	invalidStreamPtr			= -23010,	streamAlreadyOpen			= -23011,	connectionTerminated		= -23012,	invalidBufPtr				= -23013,	invalidRDS					= -23014,	invalidWDS					= -23014,	openFailed					= -23015,	commandTimeout				= -23016,	duplicateSocket				= -23017};/* Error codes from internal IP functions */enum {	ipDontFragErr				= -23032,						/* Packet too large to send w/o fragmenting */	ipDestDeadErr				= -23033,						/* destination not responding */	icmpEchoTimeoutErr			= -23035,						/* ICMP echo timed-out */	ipNoFragMemErr				= -23036,						/* no memory to send fragmented pkt */	ipRouteErr					= -23037,						/* can''t route packet off-net */	nameSyntaxErr				= -23041,	cacheFault					= -23042,	noResultProc				= -23043,	noNameServer				= -23044,	authNameErr					= -23045,	noAnsErr					= -23046,	dnrErr						= -23047,	outOfMemory					= -23048};enum {	BYTES_16WORD				= 2,							/* bytes per = 16, bit ip word */	BYTES_32WORD				= 4,							/* bytes per = 32, bit ip word */	BYTES_64WORD				= 8								/* bytes per = 64, bit ip word */};/* 8-bit quantity */typedef UInt8 b_8;/* 16-bit quantity */typedef UInt16 b_16;/* 32-bit quantity */typedef UInt32 b_32;/* IP address is 32-bits */typedef b_32 ip_addr;struct ip_addrbytes {	union {		b_32							addr;		UInt8							byte[4];	}								a;};typedef struct ip_addrbytes ip_addrbytes;struct wdsEntry {	unsigned short					length;						/* length of buffer */	Ptr								ptr;						/* pointer to buffer */};typedef struct wdsEntry wdsEntry;struct rdsEntry {	unsigned short					length;						/* length of buffer */	Ptr								ptr;						/* pointer to buffer */};typedef struct rdsEntry rdsEntry;typedef unsigned long BufferPtr;typedef unsigned long StreamPtr;enum {	netUnreach					= 0,	hostUnreach					= 1,	protocolUnreach				= 2,	portUnreach					= 3,	fragReqd					= 4,	sourceRouteFailed			= 5,	timeExceeded				= 6,	parmProblem					= 7,	missingOption				= 8,	lastICMPMsgType				= 32767};typedef unsigned short ICMPMsgType;typedef b_16 ip_port;struct ICMPReport {	StreamPtr						streamPtr;	ip_addr							localHost;	ip_port							localPort;	ip_addr							remoteHost;	ip_port							remotePort;	short							reportType;	unsigned short					optionalAddlInfo;	unsigned long					optionalAddlInfoPtr;};typedef struct ICMPReport ICMPReport;/* csCode to get our IP address */enum {	ipctlGetAddr				= 15};typedef void (*GetIPIOCompletionProcPtr)(struct GetAddrParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr GetIPIOCompletionUPP;#elsetypedef GetIPIOCompletionProcPtr GetIPIOCompletionUPP;#endif#define GetIPParamBlockHeader 	\	struct QElem*	qLink; 		\	short	qType; 				\	short	ioTrap; 				\	Ptr	ioCmdAddr; 				\	GetIPIOCompletionUPP	ioCompletion;  \	OSErr	ioResult; 			\	StringPtr	ioNamePtr; 		\	short	ioVRefNum;				\	short	ioCRefNum;				\	short	csCodestruct GetAddrParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	GetIPIOCompletionUPP			ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	ip_addr							ourAddress;					/* our IP address */	long							ourNetMask;					/* our IP net mask */};typedef struct GetAddrParamBlock GetAddrParamBlock;/* control codes */enum {	ipctlEchoICMP				= 17,							/* send icmp echo */	ipctlLAPStats				= 19							/* get lap stats */};typedef void (*IPIOCompletionProcPtr)(struct ICMPParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr IPIOCompletionUPP;#elsetypedef IPIOCompletionProcPtr IPIOCompletionUPP;#endif#define IPParamBlockHeader 		\	struct QElem*	qLink; 		\	short	qType; 				\	short	ioTrap; 				\	Ptr	ioCmdAddr; 				\	IPIOCompletionUPP	ioCompletion;  \	OSErr	ioResult; 			\	StringPtr	ioNamePtr; 		\	short	ioVRefNum;				\	short	ioCRefNum;				\	short	csCodestruct ICMPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	IPIOCompletionUPP				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	short							params[11];	struct {		unsigned long					echoRequestOut;			/* time in ticks of when the echo request went out */		unsigned long					echoReplyIn;			/* time in ticks of when the reply was received */		struct rdsEntry					echoedData;				/* data received in responce */		Ptr								options;		unsigned long					userDataPtr;	}								icmpEchoInfo;};typedef pascal void (*ICMPEchoNotifyProcPtr)(struct ICMPParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr ICMPEchoNotifyUPP;#elsetypedef ICMPEchoNotifyProcPtr ICMPEchoNotifyUPP;#endifstruct IPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	IPIOCompletionUPP				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	union {		struct {			ip_addr							dest;				/* echo to IP address */			wdsEntry						data;			short							timeout;			Ptr								options;			unsigned short					optLength;			ICMPEchoNotifyUPP				icmpCompletion;			unsigned long					userDataPtr;		}								IPEchoPB;		struct {			struct LAPStats					*lapStatsPtr;		}								LAPStatsPB;	}								csParam;};union LAPStatsAddrXlation {	struct arp_entry				*arp_table;	struct nbp_entry				*nbp_table;};struct LAPStats {	short							ifType;	char							*ifString;	short							ifMaxMTU;	long							ifSpeed;	short							ifPhyAddrLength;	char							*ifPhysicalAddress;	union LAPStatsAddrXlation		AddrXlation;	short							slotNumber;};typedef struct LAPStats LAPStats;struct nbp_entry {	ip_addr							ip_address;					/* IP address */	AddrBlock						at_address;					/* matching AppleTalk address */	Boolean							gateway;					/* TRUE if entry for a gateway */	Boolean							valid;						/* TRUE if LAP address is valid */	Boolean							probing;					/* TRUE if NBP lookup pending */	SInt8							afiller;					/* Filler for proper byte alignment	 */	long							age;						/* ticks since cache entry verified */	long							access;						/* ticks since last access */	SInt8							filler[116];				/* for internal use only !!!!!! */};struct Enet_addr {	b_16							en_hi;	b_32							en_lo;};typedef struct Enet_addr Enet_addr;struct arp_entry {	short							age;						/* cache aging field */	b_16							protocol;					/* Protocol type */	ip_addr							ip_address;					/* IP address */	Enet_addr						en_address;					/* matching Ethernet address */};typedef struct arp_entry arp_entry;/* number of ARP table entries */enum {	ARP_TABLE_SIZE				= 20};enum {	NBP_TABLE_SIZE				= 20,							/* number of NBP table entries */	NBP_MAX_NAME_SIZE			= 16 + 10 + 2};/* Command codes */enum {	TCPCreate					= 30,	TCPPassiveOpen				= 31,	TCPActiveOpen				= 32,	TCPSend						= 34,	TCPNoCopyRcv				= 35,	TCPRcvBfrReturn				= 36,	TCPRcv						= 37,	TCPClose					= 38,	TCPAbort					= 39,	TCPStatus					= 40,	TCPExtendedStat				= 41,	TCPRelease					= 42,	TCPGlobalInfo				= 43,	TCPCtlMax					= 49};enum {	TCPClosing					= 1,	TCPULPTimeout				= 2,	TCPTerminate				= 3,	TCPDataArrival				= 4,	TCPUrgent					= 5,	TCPICMPReceived				= 6,	lastEvent					= 32767};typedef unsigned short TCPEventCode;enum {	TCPRemoteAbort				= 2,	TCPNetworkFailure			= 3,	TCPSecPrecMismatch			= 4,	TCPULPTimeoutTerminate		= 5,	TCPULPAbort					= 6,	TCPULPClose					= 7,	TCPServiceError				= 8,	lastReason					= 32767};typedef unsigned short TCPTerminationReason;typedef pascal void (*TCPNotifyProcPtr)(StreamPtr tcpStream, unsigned short eventCode, Ptr userDataPtr, unsigned short terminReason, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr TCPNotifyUPP;#elsetypedef TCPNotifyProcPtr TCPNotifyUPP;#endiftypedef unsigned short tcp_port;/* ValidityFlags */enum {	timeoutValue				= 0x80,	timeoutAction				= 0x40,	typeOfService				= 0x20,	precedence					= 0x10};/* TOSFlags */enum {	lowDelay					= 0x01,	throughPut					= 0x02,	reliability					= 0x04};struct TCPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	TCPNotifyUPP					notifyProc;	Ptr								userDataPtr;};typedef struct TCPCreatePB TCPCreatePB;struct TCPOpenPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	SInt8							commandTimeoutValue;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	Boolean							dontFrag;	SInt8							timeToLive;	SInt8							security;	SInt8							optionCnt;	SInt8							options[40];	Ptr								userDataPtr;};typedef struct TCPOpenPB TCPOpenPB;struct TCPSendPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	Boolean							pushFlag;	Boolean							urgentFlag;	SInt8							filler;						/* Filler for proper byte alignment	 */	Ptr								wdsPtr;	unsigned long					sendFree;	unsigned short					sendLength;	Ptr								userDataPtr;};typedef struct TCPSendPB TCPSendPB;/* for receive and return rcv buff calls *//*   Note: the filler in the following structure is in a different location than *//*         that specified in the Programmer''s Guide.  */struct TCPReceivePB {	SInt8							commandTimeoutValue;	Boolean							markFlag;	Boolean							urgentFlag;	SInt8							filler;						/* Filler for proper byte alignment  */	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	Ptr								rdsPtr;	unsigned short					rdsLength;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;};typedef struct TCPReceivePB TCPReceivePB;struct TCPClosePB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	SInt8							filler;						/* Filler for proper byte alignment	 */	Ptr								userDataPtr;};typedef struct TCPClosePB TCPClosePB;struct HistoBucket {	unsigned short					value;	unsigned long					counter;};typedef struct HistoBucket HistoBucket;enum {	NumOfHistoBuckets			= 7};struct TCPConnectionStats {	unsigned long					dataPktsRcvd;	unsigned long					dataPktsSent;	unsigned long					dataPktsResent;	unsigned long					bytesRcvd;	unsigned long					bytesRcvdDup;	unsigned long					bytesRcvdPastWindow;	unsigned long					bytesSent;	unsigned long					bytesResent;	unsigned short					numHistoBuckets;	struct HistoBucket				sentSizeHisto[NumOfHistoBuckets];	unsigned short					lastRTT;	unsigned short					tmrSRTT;	unsigned short					rttVariance;	unsigned short					tmrRTO;	SInt8							sendTries;	SInt8							sourchQuenchRcvd;};typedef struct TCPConnectionStats TCPConnectionStats;struct TCPStatusPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	long							unused;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	SInt8							connectionState;	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendWindow;	unsigned short					rcvWindow;	unsigned short					amtUnackedData;	unsigned short					amtUnreadData;	Ptr								securityLevelPtr;	unsigned long					sendUnacked;	unsigned long					sendNext;	unsigned long					congestionWindow;	unsigned long					rcvNext;	unsigned long					srtt;	unsigned long					lastRTT;	unsigned long					sendMaxSegSize;	struct TCPConnectionStats		*connStatPtr;	Ptr								userDataPtr;};typedef struct TCPStatusPB TCPStatusPB;struct TCPAbortPB {	Ptr								userDataPtr;};typedef struct TCPAbortPB TCPAbortPB;struct TCPParam {	unsigned long					tcpRtoA;	unsigned long					tcpRtoMin;	unsigned long					tcpRtoMax;	unsigned long					tcpMaxSegSize;	unsigned long					tcpMaxConn;	unsigned long					tcpMaxWindow;};typedef struct TCPParam TCPParam;struct TCPStats {	unsigned long					tcpConnAttempts;	unsigned long					tcpConnOpened;	unsigned long					tcpConnAccepted;	unsigned long					tcpConnClosed;	unsigned long					tcpConnAborted;	unsigned long					tcpOctetsIn;	unsigned long					tcpOctetsOut;	unsigned long					tcpOctetsInDup;	unsigned long					tcpOctetsRetrans;	unsigned long					tcpInputPkts;	unsigned long					tcpOutputPkts;	unsigned long					tcpDupPkts;	unsigned long					tcpRetransPkts;};typedef struct TCPStats TCPStats;typedef StreamPtr *StreamPPtr;struct TCPGlobalInfoPB {	struct TCPParam					*tcpParamPtr;	struct TCPStats					*tcpStatsPtr;	StreamPPtr						tcpCDBTable[1];	Ptr								userDataPtr;	unsigned short					maxTCPConnections;};typedef struct TCPGlobalInfoPB TCPGlobalInfoPB;typedef void (*TCPIOCompletionProcPtr)(struct TCPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr TCPIOCompletionUPP;#elsetypedef TCPIOCompletionProcPtr TCPIOCompletionUPP;#endifstruct TCPiopb {	SInt8							fill12[12];	TCPIOCompletionUPP				ioCompletion;	short							ioResult;	Ptr								ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						tcpStream;	union {		struct TCPCreatePB				create;		struct TCPOpenPB				open;		struct TCPSendPB				send;		struct TCPReceivePB				receive;		struct TCPClosePB				close;		struct TCPAbortPB				abort;		struct TCPStatusPB				status;		struct TCPGlobalInfoPB			globalInfo;	}								csParam;};typedef struct TCPiopb TCPiopb;enum {	UDPCreate					= 20,	UDPRead						= 21,	UDPBfrReturn				= 22,	UDPWrite					= 23,	UDPRelease					= 24,	UDPMaxMTUSize				= 25,	UDPStatus					= 26,	UDPMultiCreate				= 27,	UDPMultiSend				= 28,	UDPMultiRead				= 29,	UDPCtlMax					= 29};enum {	UDPDataArrival				= 1,	UDPICMPReceived				= 2,	lastUDPEvent				= 32767};typedef unsigned short UDPEventCode;typedef pascal void (*UDPNotifyProcPtr)(StreamPtr udpStream, unsigned short eventCode, Ptr userDataPtr, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr UDPNotifyUPP;#elsetypedef UDPNotifyProcPtr UDPNotifyUPP;#endiftypedef unsigned short udp_port;/* for create and release calls */struct UDPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	UDPNotifyUPP					notifyProc;	unsigned short					localPort;	Ptr								userDataPtr;	udp_port						endingPort;};typedef struct UDPCreatePB UDPCreatePB;struct UDPSendPB {	unsigned short					reserved;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								wdsPtr;	Boolean							checkSum;	SInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendLength;	Ptr								userDataPtr;	udp_port						localPort;};typedef struct UDPSendPB UDPSendPB;/* for receive and buffer return calls */struct UDPReceivePB {	unsigned short					timeOut;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;	ip_addr							destHost;					/* only for use with multi rcv */	udp_port						destPort;					/* only for use with multi rcv */};typedef struct UDPReceivePB UDPReceivePB;struct UDPMTUPB {	unsigned short					mtuSize;	ip_addr							remoteHost;	Ptr								userDataPtr;};typedef struct UDPMTUPB UDPMTUPB;typedef void (*UDPIOCompletionProcPtr)(struct UDPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr UDPIOCompletionUPP;#elsetypedef UDPIOCompletionProcPtr UDPIOCompletionUPP;#endifstruct UDPiopb {	SInt8							fill12[12];	UDPIOCompletionUPP				ioCompletion;	short							ioResult;	Ptr								ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						udpStream;	union {		struct UDPCreatePB				create;		struct UDPSendPB				send;		struct UDPReceivePB				receive;		struct UDPMTUPB					mtu;	}								csParam;};typedef struct UDPiopb UDPiopb;#if GENERATINGCFM#else#endifenum {	uppGetIPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct GetAddrParamBlock*))),	uppIPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct ICMPParamBlock*))),	uppICMPEchoNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct ICMPParamBlock*))),	uppTCPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(struct ICMPReport*))),	uppTCPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct TCPiopb*))),	uppUDPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(struct ICMPReport*))),	uppUDPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct UDPiopb*)))};#if GENERATINGCFM#define NewGetIPIOCompletionProc(userRoutine)		\		(GetIPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppGetIPIOCompletionProcInfo, GetCurrentArchitecture())#define NewIPIOCompletionProc(userRoutine)		\		(IPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppIPIOCompletionProcInfo, GetCurrentArchitecture())#define NewICMPEchoNotifyProc(userRoutine)		\		(ICMPEchoNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, GetCurrentArchitecture())#define NewTCPNotifyProc(userRoutine)		\		(TCPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPNotifyProcInfo, GetCurrentArchitecture())#define NewTCPIOCompletionProc(userRoutine)		\		(TCPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, GetCurrentArchitecture())#define NewUDPNotifyProc(userRoutine)		\		(UDPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUDPNotifyProcInfo, GetCurrentArchitecture())#define NewUDPIOCompletionProc(userRoutine)		\		(UDPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUDPIOCompletionProcInfo, GetCurrentArchitecture())#else#define NewGetIPIOCompletionProc(userRoutine)		\		((GetIPIOCompletionUPP) (userRoutine))#define NewIPIOCompletionProc(userRoutine)		\		((IPIOCompletionUPP) (userRoutine))#define NewICMPEchoNotifyProc(userRoutine)		\		((ICMPEchoNotifyUPP) (userRoutine))#define NewTCPNotifyProc(userRoutine)		\		((TCPNotifyUPP) (userRoutine))#define NewTCPIOCompletionProc(userRoutine)		\		((TCPIOCompletionUPP) (userRoutine))#define NewUDPNotifyProc(userRoutine)		\		((UDPNotifyUPP) (userRoutine))#define NewUDPIOCompletionProc(userRoutine)		\		((UDPIOCompletionUPP) (userRoutine))#endif#if GENERATINGCFM#define CallGetIPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppGetIPIOCompletionProcInfo, (iopb))#define CallIPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppIPIOCompletionProcInfo, (iopb))#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, (iopb))#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPNotifyProcInfo, (tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#define CallTCPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, (iopb))#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppUDPNotifyProcInfo, (udpStream), (eventCode), (userDataPtr), (icmpMsg))#define CallUDPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppUDPIOCompletionProcInfo, (iopb))#else#define CallGetIPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallIPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		(*(userRoutine))((tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#define CallTCPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		(*(userRoutine))((udpStream), (eventCode), (userDataPtr), (icmpMsg))#define CallUDPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __MACTCP__ */'.!macWindowFile	^ '#include <MacHeaders.h>#include <OSUtils.h>#include <Timer.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern unsigned char *memory;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 40char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the file name, reported on launch */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;		/* mouse position when window is inactive */int windowActive = true;		/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>   */ char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);void RecordFullPathForImageName(char *localImageName);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowSize(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {			AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "clone.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "clone.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	/* make image directory the default */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetItem(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AddResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 32768, 32768, 32768);	/* 50% gray */	SetColorEntry(3, 65535, 65535,     0);	/* yellow */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535,     0, 65535);	/* magenta */	SetColorEntry( 9,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(10, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(11, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(12, 32768, 32768, 32768);	/* 4/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = { 44, 8, 408, 648 };  /* default window bounds */	Rect screen;	int right, bottom;	if (savedWindowSize !!= 0) {		right  = windowBounds.left + ((unsigned) savedWindowSize >> 16);		bottom = windowBounds.top  + (savedWindowSize & 0xFFFF);	} else {		right  = windowBounds.right;		bottom = windowBounds.bottom;	}	/* minimum size is 64 x 64 */	right  = ( right > (windowBounds.left + 64)) ?  right : (windowBounds.left + 64);	bottom = (bottom > (windowBounds.top  + 64)) ? bottom : (windowBounds.top  + 64);	/* maximum bottom-right is screen bottom-right */	screen = qd.screenBits.bounds;	right  = ( right <= screen.right)  ?  right : (screen.right  - 8);	bottom = (bottom <= screen.bottom) ? bottom : (screen.bottom - 8);	windowBounds.right = right;	windowBounds.bottom = bottom;	stWindow = NewCWindow(0L, &windowBounds, "\pWelcome to Squeak!!", true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowSize(void) {	Rect screen;	int width, height, maxWidth, maxHeight;	if (savedWindowSize !!= 0) {		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;	} else {		width  = 640;		height = 480;	}	/* minimum size is 64 x 64 */	width  = ( width > 64) ?   width : 64;	height = (height > 64) ?  height : 64;	/* maximum size is screen size */	screen = qd.screenBits.bounds;	maxWidth  = (screen.right  - screen.left) - 16;	maxHeight = (screen.bottom - screen.top)  - 52;	width  = ( width <= maxWidth)  ?  width : maxWidth;	height = (height <= maxHeight) ? height : maxHeight;	SizeWindow(stWindow, width, height, true);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	ExitToShell();}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than ioMSecs!!!!) */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	Cursor macCursor;	int i;	for (i = 0; i < 16; i++) {		macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void RecordFullPathForImageName(char *localImageName) {	int offset, localNameSize, i;	offset = dir_PathToWorkingDir(imageName, IMAGE_NAME_SIZE);	/* copy the file name into a null-terminated C string */	localNameSize = strlen(localImageName);	for (i = 0; i <= localNameSize; i++) {		/* append localName, including terminator */		imageName[i + offset] = localImageName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	FILE *f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	RecordFullPathForImageName(shortImageName);	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 300000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = fopen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''clone.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}		readImageFromFileHeapSize(f, availableMemory);	fclose(f);	SetWindowTitle(shortImageName);	SetWindowSize();	/* run Squeak */	interpret();}#endif'.!readmeFile	^ 'Building the Squeak Virtual MachineThe virtual machine is build from one header and eight source files:	sq.h				-- shared definitions included in all .c files	sqFilePrims.c		-- file primitives	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqSoundPrims.c		-- automatically generated sound synthesis primitives	interp.c				-- automatically generated code for the virtual machineThe platform specific files are sqMacWindow.c, sqMacDirectory.c, sqMacJoystick.c, sqMacNetwork.c, and sqMacSound.c, totaling about 1800 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments. When doing the initial port to a new system, the functions in sqMacJoystick.c, sqMacNetwork.c, and sqMacSound.c can be replaced by stub functions that do nothing.The code assumes that C ints are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Floats are always stored in PowerPC byte order (which I believe is the IEEE standard byte ordering); macros in sq.h can be defined to swap bytes into and out of the platform native format if necessary.The files interp.c and sqSoundPrims.c are generated automatically, so changes to these files will be lost when the next interpreter is generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs could probably be worked around if one really wanted to use that environment.The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, March 16, 1997'.!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#ifdef DOUBLE_WORD_ALIGNMENT/* word-based copy for machines that require doubles to be double-word aligned */#define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);#else/* for machines that allow doubles to be on any word boundary */#define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);#define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* millisecond clock */#define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(FILE *f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo);int snd_Stop(void);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);'.! !!JoystickMorph methodsFor: 'accessing'!amount	^ (handleMorph center - self center) r * radiusScale!angle	self center = handleMorph center ifTrue: [^ lastAngle].	^ 360.0 - (handleMorph center - self center) theta radiansToDegrees!leftRight	^ (handleMorph center x - self center x) * xScale!parts	^ #(leftRight upDown angle amount)!upDown	^ (handleMorph center y - self center y) * yScale! !!JoystickMorph methodsFor: 'all'!initialize	super initialize.	xScale _ 1.0.	yScale _ 1.0.	radiusScale _ 1.0.	lastAngle _ 0.0.	self form: (MaskedForm		form: ((Form extent: 80@80 depth: Display depth) fillColor: (Color r: 0.3 g: 0.2 b: 0.2))		transparentColor: Color white).	handleMorph _ EllipseMorph new.	handleMorph color: Color red; extent: 10@10.	self addMorph: handleMorph.	self moveHandleToCenter.!mouseDown: evt	(handleMorph containsPoint: evt cursorPoint)		ifTrue: [evt hand newMouseFocus: self]		ifFalse: [super mouseDown: evt].!mouseMove: evt	| m r center |	m _ handleMorph.	center _ m center.	r _ m owner innerBounds insetBy:		((center - m fullBounds origin) corner: (m fullBounds corner - center)).	m position: (evt cursorPoint adhereTo: r) - (m extent // 2).!mouseRecipientAt: aPoint	"The buck stops here!! This morph catches and handles mouse events and prevents them from being passed to its submorphs."	^ self!mouseUp: evt	lastAngle _ self angle.	self moveHandleToCenter.!moveHandleToCenter	handleMorph position: self center - (handleMorph extent // 2).! !LargeNegativeInteger comment:'Just like LargePositiveInteger, but represents a negative number.'!LargePositiveInteger comment:'I represent a positive large integer, integers greater than 2-to-the-30th (1073741824).  These are beyond the range of SmallInteger, encoded as an array of 8-bit digits.  Care must be taken, when new results are computed, that any value that COULD BE a SmallInteger IS a SmallInteger (see normalize).'!!LargePositiveInteger methodsFor: 'arithmetic'!* anInteger 	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 29>	^super * anInteger!+ anInteger 	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 21>	^super + anInteger!- anInteger 	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 22>	^super - anInteger!/ anInteger 	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is not	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 30>	^super / anInteger!// anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 32>	^super // anInteger!quo: anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 33>	^super quo: anInteger!\\ anInteger 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 31>	^super \\ anInteger! !!LargePositiveInteger methodsFor: 'comparing'!< anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive."	<primitive: 23>	^super < anInteger!<= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger or a LargePositiveInteger less	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 25>	^super <= anInteger!= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	receiver or argument is negative or greater than 32 bits.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 7>	^ super = anInteger!> anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 24>	^super > anInteger!>= anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 26>	^super >= anInteger! !!LayoutMorph methodsFor: 'initialization'!initialize	super initialize.	borderWidth _ 0.	orientation _ #horizontal.	"#horizontal or #vertical"	centering _ #topLeft.		"#topLeft, #center, or #bottomRight"	hResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	vResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	inset _ 2.					"pixels inset within owner's bounds"	minCellSize _ 0.				"minimum space between morphs; useful for tables"	openToDragNDrop _ false.	"objects can be dropped in or dragged out"	color _ Color r: 0.8 g: 1.0 b: 0.8.! !!LayoutMorph methodsFor: 'classification'!isLayoutMorph	^ true! !!LayoutMorph methodsFor: 'accessing'!centering	^ centering!centering: aSymbol	"Set the minor dimension alignment to #topLeft, #center, or #bottomRight."	centering _ aSymbol.!hResizing	^ hResizing!hResizing: aSymbol	"Set the horizontal resizing style to #spaceFill, #shrinkWrap, or #rigid."	hResizing _ aSymbol.!inset	^ inset!inset: anInteger	"Set the amount of padding within my bounds to the given amount."	inset _ anInteger.!minCellSize	^ minCellSize!minCellSize: anInteger	"Set the minium space per submorph to the given size. Useful for making tables."	minCellSize _ anInteger.!openCloseDragNDrop	"Toggle this morph's ability to add and remove morphs via drag-n-drop."	openToDragNDrop _ openToDragNDrop not.!openToDragNDrop	^ openToDragNDrop!openToDragNDrop: aBoolean	"Set this morph's ability to add and remove morphs via drag-n-drop."	openToDragNDrop _ aBoolean.!orientation	^ orientation!orientation: aSymbol	"Set the major layout dimension to #horizontal or #vertical."	orientation _ aSymbol.!vResizing	^ vResizing!vResizing: aSymbol	"Set the vertical resizing style to #spaceFill, #shrinkWrap, or #rigid."	vResizing _ aSymbol.! !!LayoutMorph methodsFor: 'dropping/grabbing'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	self changed.	self layoutChanged.!allowSubmorphExtraction	^ openToDragNDrop!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root = self] whileFalse: [		root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph!wantsDroppedMorph: aMorph event: evt	"Supports adding morphs by dropping."	^ openToDragNDrop! !!LayoutMorph methodsFor: 'layout'!fullBounds	"This is the hook that triggers lazy re-layout of layout morphs. It works because layoutChanged clears the fullBounds cache. Once per cycle, the fullBounds is requested from every morph in the world, and that request gets propagated through the entire submorph hierarchy, causing re-layout where needed. Note that multiple layoutChanges to the same morph can be done with little cost, since the layout is only done when the morph needs to be displayed."	fullBounds ifNil: [		self fixLayout.		self resizeIfNeeded.		"compute fullBounds before calling changed to avoid infinite recursion"		super fullBounds.  "updates cache"		self changed  "report change due to layout"].	^ super fullBounds!minHeight	"Return the minimum height for this morph."	| minH spaceNeeded |	vResizing = #rigid ifTrue: [^ self fullBounds height].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	orientation = #horizontal ifTrue: [		minH _ 0.		submorphs do: [:m | minH _ minH max: m minHeight].		spaceNeeded _ minH + (2 * inset).	] ifFalse: [		spaceNeeded _ 2 * inset.		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize)]].	^ spaceNeeded!minHeightWhenEmpty	^ 5!minWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	orientation = #horizontal ifTrue: [		spaceNeeded _ 2 * inset.		submorphs do: [:m | spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize)].	] ifFalse: [		minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * inset)].	^ spaceNeeded!minWidthWhenEmpty	^ 5! !!LayoutMorph methodsFor: 'private'!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ inset * 2.	orientation = #horizontal ifTrue: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minWidth max: minCellSize).			(m isLayoutMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + (m minHeight max: minCellSize).			(m isLayoutMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra // spaceFillingMorphs!fixLayout	| extraPerMorph nextPlace space |	extraPerMorph _ self extraSpacePerMorph.	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset]		ifFalse: [nextPlace _ bounds top + inset].	submorphs do: [:m |		space _ self placeAndSize: m at: nextPlace padding: extraPerMorph.		nextPlace _ nextPlace + space].!insertionIndexFor: aMorph	"Return the index at which the given morph should be inserted into the submorphs of the receiver."	| newCenter |	newCenter _ aMorph fullBounds center.	orientation = #horizontal ifTrue: [		submorphs doWithIndex: [:m :i |			newCenter x < m fullBounds center x ifTrue: [^ i]].	] ifFalse: [		submorphs doWithIndex: [:m :i |			newCenter y < m fullBounds center y ifTrue: [^ i]]].	^ submorphs size + 1  "insert after the last submorph"!layoutInExtent: aPoint	"Adjust the size of the the receiver in its space-filling dimensions during layout. This message is sent to only to layout submorphs."	| newExtent |	((hResizing = #spaceFill) or:	 [vResizing = #spaceFill])		ifFalse: [^ self].  "rigid or shrinkWrap in both dimensions"	newExtent _ bounds extent.	hResizing = #spaceFill ifTrue: [newExtent x: aPoint x].	vResizing = #spaceFill ifTrue: [newExtent y: aPoint y].	self changed.	bounds _ bounds topLeft extent: newExtent.	self layoutChanged.!placeAndSize: m at: nextPlace padding: padding	| space left top |	orientation = #horizontal ifTrue: [		space _ m minWidth max: minCellSize.		m isLayoutMorph ifTrue: [			(m hResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInExtent: space@(bounds height - (inset * 2))].	] ifFalse: [		space _ m minHeight max: minCellSize.		m isLayoutMorph ifTrue: [			(m vResizing = #spaceFill) ifTrue: [space _ space + padding].			m layoutInExtent: (bounds width - (inset * 2))@space]].	orientation = #horizontal ifTrue: [		left _ nextPlace.		centering = #topLeft			ifTrue: [top _ bounds top + inset].		centering = #bottomRight			ifTrue: [top _ bounds bottom - inset - m fullBounds height].		centering = #center			ifTrue: [top _ bounds top + ((bounds height - m fullBounds height) // 2)].	] ifFalse: [		top _ nextPlace.		centering = #topLeft			ifTrue: [left _ bounds left + inset].		centering = #bottomRight			ifTrue: [left _ bounds right - inset - m fullBounds width].		centering = #center			ifTrue: [left _ bounds left + ((bounds width - m fullBounds width) // 2)]].	m position: (left@top) + (m bounds topLeft - m fullBounds topLeft).	^ space!resizeIfNeeded	"Resize this morph if it is space-filling or shrink-wrap and its owner is not a layout morph."	| newExtent |	newExtent _ bounds extent.	(owner == nil or: [owner isLayoutMorph not]) ifTrue: [		"if spaceFill and not in a LayoutMorph, grow to enclose submorphs"		hResizing = #spaceFill ifTrue: [newExtent x: (self minWidth max: self bounds width)].		vResizing = #spaceFill ifTrue: [newExtent y: (self minHeight max: self bounds height)]].	"if shrinkWrap, adjust size to just fit around submorphs"	hResizing = #shrinkWrap ifTrue: [newExtent x: self minWidth].	vResizing = #shrinkWrap ifTrue: [newExtent y: self minHeight].	newExtent = bounds extent ifFalse: [		"bounds really changed"		bounds _ bounds topLeft extent: newExtent.		self layoutChanged  "flush fullBounds cache"].! !!LayoutMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.! !!LayoutMorph class methodsFor: 'instance creation'!newColumn	^ self new		orientation: #vertical;		hResizing: #spaceFill;		vResizing: #spaceFill!newRow	^ self new		orientation: #horizontal;		hResizing: #spaceFill;		vResizing: #spaceFill;		borderWidth: 0!newRowHeight: h	^ self new		orientation: #horizontal;		hResizing: #spaceFill;		vResizing: #rigid;		extent: (3*h)@h! !LeafNode comment:'I represent a leaf node of the compiler parse tree. I am abstract.	Types (defined in class ParseNode):	1 LdInstType (which uses class VariableNode)	2 LdTempType (which uses class VariableNode)	3 LdLitType (which uses class LiteralNode)	4 LdLitIndType (which uses class VariableNode)	5 SendType (which uses class SelectorNode).Note that Squeak departs slightly from the Blue Book bytecode spec.In order to allow access to more than 63 literals and instance variables,bytecode 132 has been redefined as DoubleExtendedDoAnything:		byte2				byte3			Operation(hi 3 bits)  (lo 5 bits)	0		nargs			lit index			Send Literal Message 0-255	1		nargs			lit index			Super-Send Lit Msg 0-255	2		ignored			rcvr index		Push Receiver Variable 0-255	3		ignored			lit index			Push Literal Constant 0-255	4		ignored			lit index			Push Literal Variable 0-255	5		ignored			rcvr index		Store Receiver Variable 0-255	6		ignored			rcvr index		Store-pop Receiver Variable 0-255	7		ignored			lit index			Store Literal Variable 0-255	This has allowed bytecode 134 also to be redefined as a second extended send	that can access literals up to 64 for nargs up to 3 without needing three bytes.	It is just like 131, except that the extension byte is aallllll instead of aaalllll,	where aaa are bits of argument count, and lll are bits of literal index.'!!LeafNode methodsFor: 'code generation'!emitLong: mode on: aStream 	"Emit extended variable access."	| type index |	code < 256		ifTrue:			[code < 16			ifTrue: [type _ 0.					index _ code]			ifFalse: [code < 32					ifTrue: [type _ 1.							index _ code - 16]					ifFalse: [code < 96							ifTrue: [type _ code // 32 + 1.									index _ code \\ 32]							ifFalse: [self error: 									'Sends should be handled in SelectorNode']]]]		ifFalse: 			[index _ code \\ 256.			type _ code // 256 - 1].	index <= 63 ifTrue:		[aStream nextPut: mode.		^ aStream nextPut: type * 64 + index].	"Compile for Double-exetended Do-anything instruction..."	mode = LoadLong ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"		^ aStream nextPut: index].	mode = Store ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"		^ aStream nextPut: index].	mode = StorePop ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"		^ aStream nextPut: index].!sizeForValue: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 1].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	| viewList |	viewList _ view list.	viewList compositionRectangle height = 0		ifTrue: [^ 0@0 extent: Preferences scrollBarWidth@scrollBar inside height].	^ 0@0 extent: Preferences scrollBarWidth@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !!ListParagraph methodsFor: 'private'!withArray: anArray 	"Modifies self to contain the list of strings in anArray"	| startOfLine endOfLine lineIndex aString |	lines _ Array new: 20.	lastLine _ 0.	startOfLine _ 1.	endOfLine _ 1.	lineIndex _ 0.	anArray do: 		[:item | 		endOfLine _ startOfLine + item size.		"this computation allows for a cr after each line..."												"...but later we will adjust for no cr after last line"		lineIndex _ lineIndex + 1.		self lineAt: lineIndex put:			((TextLineInterval start: startOfLine stop: endOfLine				internalSpaces: 0 paddingWidth: 0)				lineHeight: textStyle lineGrid baseline: textStyle baseline).		startOfLine _ endOfLine + 1].	endOfLine _ endOfLine - 1.		"endOfLine is now the total size of the text"	self trimLinesTo: lineIndex.	aString _ String new: endOfLine.	anArray with: lines do: 		[:item :interval | 		aString			replaceFrom: interval first			to: interval last - 1			with: item			startingAt: 1.		interval last <= endOfLine ifTrue: [aString at: interval last put: Character cr]].	lineIndex > 0 ifTrue: [(lines at: lineIndex) stop: endOfLine].	"adjust for no cr after last line"	self text: aString asText.	self updateCompositionHeight! !!ListParagraph class methodsFor: 'instance creation'!withArray: anArray	"Convert an array of strings into a ListParagraph."	^ (super withText: Text new style: ListStyle) withArray: anArray! !!ListParagraph class methodsFor: 'initialization'!initialize  "ListParagraph initialize"	"Allow different line spacing for lists"	ListStyle _ TextStyle default copy gridForFont: 1 withLead: 1! !!ListView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	topDelimiter _ '------------'.	bottomDelimiter _ '------------'.	isEmpty _ true.	self list: Array new! !!ListView methodsFor: 'list access'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy.	selection _ 0.	self positionList! !!ListView methodsFor: 'displaying'!scrollSelectionIntoView	"Selection is assumed to be on and clipped out of view.	Uses controller scrollView to keep selection right"	| delta |	(delta _ self insetDisplayBox bottom - self selectionBox bottom) < 0		ifTrue: [^ self controller scrollView: delta - (list lineGrid-1)]. "up"	(delta _ self insetDisplayBox top - self selectionBox top) > 0		ifTrue: [^ self controller scrollView: delta + 1] "down"! !!LiteralDictionary methodsFor: 'as yet unclassified'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [(element key class == anObject class) and: [element key = anObject]])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [(element key class == anObject class) and: [element key = anObject]])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!LiteralNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1! !!LiteralNode methodsFor: 'C translation'!asTranslatorNode 	^TConstantNode new setValue: key! !!MaskedForm methodsFor: 'access'!colorMap: anArray 	"Map the pixelValues in theForm through the colors is this array.  Array should be 2^(theForm depth) long.  If shorter, will be padded.  If longer, truncated.  Map is cached in rawColorMap.  6/28/96 tk"	| d mapSize |	anArray == nil ifTrue: ["clear it"		colorMap _ nil.		rawColorMap _ nil.	"uncache"		^ self].	d _ theForm depth.	colorMap _ anArray.	mapSize _ (1 bitShift: d) min: (512 max: anArray size).		"Want 2^^depth, except where huge, except if big map supplied"	rawColorMap _ Bitmap new: mapSize.	colorMap doWithIndex: [:color :ind |		rawColorMap at: ind put: (color pixelWordForDepth: d)].		"Note that we don't supply default colors in the added part of the map.  We assume no pixel values are used outside the supplied map." !colorMap: anArray depth: d	"Set rawColorMap for case when display depth is 16 or 24, and theForm is 8 bits.  256 values, but at higher resolution for each.  GIFs use this.  Pixels unchanged at 8 bits, colorMap of colors, rawColorMap of 16 or 24 bit values.  12/8/96 tk"	| mapSize |	anArray == nil ifTrue: ["clear it"		colorMap _ nil.		^ rawColorMap _ nil].	"uncache"	colorMap _ anArray.	mapSize _ (1 bitShift: theForm depth) min: (512 max: anArray size).		"Want 2^^depth, except where huge, except if big map supplied"	rawColorMap _ Bitmap new: mapSize.	colorMap doWithIndex: [:color :ind |		rawColorMap at: ind put: (color pixelWordForDepth: d)].		"Note that we don't supply default colors in the added part of the map.  We assume no pixel values are used outside the supplied map." !rawColorMap: map	"Map the pixelValues in theForm to the 32-bit raw color pixel-values is this array.  This is what BitBlt wants and is computed for theForm's depth.  12/6/96 tk"	rawColorMap _ map! !!MaskedForm methodsFor: 'pattern'!applyColorMap	"Convert theForm to the best approximation of the colors in colorMap.  Then make the map be nil.  Informaion will be lost.  Converts the arbitrary 256 colors in the picture (via the map) to the standard 256 colors.  When colorMaps are fully supported, stop using this.  7/1/96 tk"	| port |	port _ BitBlt toForm: theForm.	port colorMap: self rawColorMap.	theForm displayOnPort: port at: 0@0.		"Write over self using the transforming color map"	colorMap _ nil.	rawColorMap _ nil.! !!MaskedForm methodsFor: 'displaying'!copyBits: copyRect from: sourceForm at: destPoint clippingBox: clipRect rule: rule fillColor: fillColor map: map 	"copyBits with a color map.  12/12/96 tk"| save |save _ rawColorMap.rawColorMap _ map.self copyBits: copyRect		from: sourceForm		at: destPoint		clippingBox: clipRect		rule: rule		fillColor: fillColor.rawColorMap _ save.!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectanglerule: ruleInteger fillColor: fillColor	"This is the real display message.  Remove the area of the mask,and OR in theForm."	| port doTrans |	(rawColorMap == nil) ifTrue:		[(aDisplayMedium depth > 8) & (theForm depth <= 8) ifTrue:			[doTrans _ true.			rawColorMap _ (Color defaultColorMapFrom: theForm depth					to: aDisplayMedium depth) copy.	"If speed is a problem, we can						establish a cache for transparnt color maps and reuse"			rawColorMap at: 1 "0+1" put: 0]].			"already transparent->0 in theForm (8 bits), map in copyBits 0->32767 (white).				We override with 0->0 for transparent."	(aDisplayMedium isKindOf: MaskedForm)		ifFalse: ["aDisplayMedium is a normal Form"			mask displayOn: aDisplayMedium				at: aDisplayPoint				clippingBox: clipRectangle				rule: Form erase1bitShape				fillColor: nil.	"Cut a hole in the picture with my mask"			rawColorMap == nil ifTrue:					[theForm displayOn: aDisplayMedium						at: aDisplayPoint						clippingBox: clipRectangle						rule: Form under	"OR my picture into the hole"						fillColor: fillColor]				ifFalse:					[port _ BitBlt toForm: aDisplayMedium.					port colorMap: rawColorMap.					port clipRect: clipRectangle.					port copyForm: theForm to: aDisplayPoint rule: Form under]]		ifTrue: ["aDisplayMedium is a MaskedForm"			mask displayOn: aDisplayMedium mask				at: aDisplayPoint				clippingBox: clipRectangle				rule: Form under				fillColor: nil.	"OR my mask into the mask"			mask displayOn: aDisplayMedium form				at: aDisplayPoint				clippingBox: clipRectangle				rule: Form erase1bitShape				fillColor: nil.	"Cut a hole in the picture with my mask"			rawColorMap == nil				ifTrue:					[theForm displayOn: aDisplayMedium form						at: aDisplayPoint						clippingBox: clipRectangle						rule: Form under	"OR my picture into the hole"						fillColor: fillColor]				ifFalse:					[port _ BitBlt toForm: aDisplayMedium form.					port colorMap: rawColorMap.					port clipRect: clipRectangle.					port copyForm: theForm to: aDisplayPoint rule: Form under]].	doTrans == true ifTrue: [rawColorMap _ nil].	"put it back"!displayOn: aDisplayMedium transformation: displayTransformationclippingBox: clipRectangle align: alignmentPoint with: relativePoint rule:ruleInteger fillColor: aForm	"Copied from Form, basically"	| absolutePoint scale magnifiedForm |	absolutePoint _ displayTransformation applyTo: relativePoint.	absolutePoint _ absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm _ self]		ifFalse:			[scale _ displayTransformation scale.			scale = (1@1)					ifTrue: [scale _ nil. magnifiedForm_ self]					ifFalse: [magnifiedForm _ selfmagnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm!displayOnPort: port at: location	"Must map between different form depths.  12/10/96 tk"	| save map |	(rawColorMap == nil) 		ifFalse: [map _ rawColorMap]		ifTrue: [			(port destForm depth > 8) & (theForm depth <= 8) ifTrue: [				map _ (Color defaultColorMapFrom: theForm depth 						to: port destForm depth) copy.	"If speed is a problem, we can 							establish a cache for transparnt color maps and reuse"				map at: 1 "0+1" put: 0]]. 				"already transparent->0 in theForm (8 bits), map in copyBits 0->32767 (white).  					We override with 0->0 for transparent."	port copyForm: mask to: location rule: Form erase1bitShape.	port destForm depth ~= theForm depth 		ifTrue: ["need a map"			save _ port colorMap.			port colorMap: map.			port copyForm: theForm to: location rule: Form under.			port colorMap: save]		ifFalse: [port copyForm: theForm to: location rule: Form under]! !!MaskedForm methodsFor: 'scaling'!magnify: aRectangle by: scale 	"Answer an MaskedForm created as a multiple of the receiver; theresult is smaller. Each bit in the new form corresponds to scale number ofbits in the receiver."	^ (MaskedForm new setForm: (theForm magnify: aRectangle by: scale)		mask: (mask magnify: aRectangle by: scale)		removeOverlap: false transpPixVal: transparentPixelValue)		colorMap: colorMap;		rawColorMap: rawColorMap!shrink: aRectangle by: scale	"Answer an MaskedForm created as a multiple of the receiver; the result is smaller. Each bit in the new form corresponds to scale number of bits in the receiver."	^ (MaskedForm new setForm: (theForm shrink: aRectangle by: scale)		mask: (mask shrink: aRectangle by: scale)		removeOverlap: false transpPixVal: transparentPixelValue)		colorMap: colorMap;		rawColorMap: rawColorMap! !!MaskedForm methodsFor: 'setup'!setForm: aForm transparentColor: aColor	"Create a MaskedForm with transparent where aColor is.  Substitute0 into theForm where the mask is 1.  6/21/96 tk"	| d cMap |	theForm _ aForm.	aColor == nil ifTrue: [		"no transparency, take whole form, don't mask off any of it."		mask _ Form extent: theForm extent offset: theForm offset.		mask fillWithColor: #black.		^ self].	d _ theForm depth.	transparentPixelValue _ aColor pixelValueForDepth: d.	mask _ Form extent: theForm extent offset: theForm offset.	  "Copy the figure"	cMap _ Bitmap new: (1 bitShift: d) withAll: 1.	cMap at: transparentPixelValue+1 put: 0.	mask copyBits: mask boundingBox from: theForm		at: 0@0 colorMap: cMap.	"Erase the color pixelValues where theForm needs to be transparent"	transparentPixelValue = 0 ifFalse: [self removeOverlap].!setForm: aForm transparentPixelValue: pixVal	"Create a MaskedForm with transparent where aColor is.  Substitute0 into theForm where the mask is 1.  6/21/96 tk"	| tColorMap |	theForm _ aForm.	transparentPixelValue _ pixVal.	mask _ Form extent: theForm extent offset: theForm offset.	  "Copy the figure, depth 1"	tColorMap _ Bitmap new: (1 bitShift: theForm depth) withAll: 1.	tColorMap at: transparentPixelValue+1 put: 0.	mask copyBits: mask boundingBox from: theForm		at: 0@0 colorMap: tColorMap.	"Erase the color pixelValues where theForm needs to be transparent"	transparentPixelValue = 0 ifFalse: [self removeOverlap].		! !!MaskedForm class methodsFor: 'instance creation'!makeShip: aScale hd: aHeading	"Make a 'ship' (arrowhead-shaped) facing in the heading given by aHeading.   Use s as scale factor.	 By Alan Kay 2/96.  Simplified and reformatted by 5/30/96 sw"	| sampleForm scaled aPen m n r loc  box | 	scaled _ (80 * aScale) asInteger.	sampleForm _ Form extent: (scaled@scaled) depth: 8.  "Make a form"	sampleForm fillWithColor: Color lightGreen lighter lighter.	aPen _ Pen newOnForm: sampleForm. "make a ship shape"	loc _ 40@40. 			m _ 8. n _ 20. r _ 54.	aPen place: loc. aPen north.		box _ loc corner: loc.	aPen turn: aHeading +180; up.	aPen go: m * aScale; down; turn: 45.		box _ box encompass: aPen location.	aPen go: n * aScale.		box _ box encompass: aPen location.	aPen turn: 150; go: r * aScale.		box _ box encompass: aPen location.	aPen place: loc. aPen north.	aPen turn: aHeading + 180; up.	aPen go: m * aScale; down; turn: -45.		box _ box encompass: aPen location.	aPen go: n* aScale.		box _ box encompass: aPen location.	aPen turn: -150; go: r * aScale.		box _ box encompass: aPen location.	^ Cursor wait showWhile:		"Transparent around the outside"		[self from: sampleForm box: ((box truncated) expandBy: 2)]."Try it.	(MaskedForm makeShip: 1 hd: 0) followCursor"! !!MessageCategoryListView methodsFor: 'updating'!list: anArray 	super list: anArray.	(Preferences browserAutoSelect and: [list numberOfLines = 3]) ifTrue:		[controller isNil ifFalse: [controller changeModelSelection: 1]].! !!MessageListController methodsFor: 'menu messages'!methodHierarchy	"Create and schedule a message browser on the hierarchical implementors."	self controlTerminate.	model methodHierarchy.	self controlInitialize!shiftedYellowButtonMenu	"Answer the menu to be put up when shift key is down.  1/26/96 sw"	^ PopUpMenu labels: 'browse fullbrowse inheritancebrowse methodimplementors of sent messagesinspect instancesinspect subinstancesremove from browsermore...' lines: #(4 6)!shiftedYellowButtonMessages	"Answer the messages corresponding to the shifted-yellow-button menu, to be put up when shift key is down.  1/26/96 sw.  Adjustments, 2/5/96 sw"	^ #(browseFull methodHierarchy browse allImplementorsOf inspectInstances inspectSubInstances removeMessageFromBrowser unshiftedYellowButtonActivity)! !!MessageListView methodsFor: 'updating'!displayView 	"Refer to the comment in View|displayView."	| aClass sel index baseClass |	Browser postOpenSuggestion == nil ifFalse: [		"Set the class and message"		aClass _ Browser postOpenSuggestion first.		sel _ Browser postOpenSuggestion last.		Browser postOpenSuggestion: nil.		baseClass _ aClass theNonMetaClass.		model systemCategoryListIndex:			(SystemOrganization numberOfCategoryOfElement: baseClass name).		model selectClass: baseClass.		model metaClassIndicated: aClass isMeta.		sel notNil ifTrue: [			model messageCategoryListIndex:				(index _ aClass organization numberOfCategoryOfElement: sel).			model messageListIndex: 				((aClass organization listAtCategoryNumber: index) indexOf: sel)			].		self topView deEmphasize.		^ self   "a redisplay has already been done"].	super displayView.!update: aSymbol	"What to do to the message list when Browser changes. If there is only one item, select and show it.	 3/8/97 sw: as part of adding a new feature that was subsequently removed, simplified the code here enough to justify using it"	aSymbol == #messageSelectionChanged		ifTrue: [^ self updateMessageSelection].	(#(systemCategorySelectionChanged editSystemCategories editClass editMessageCategories) includes: aSymbol)		ifTrue: [^ self resetAndDisplayView].	(aSymbol == #messageCategorySelectionChanged) | (aSymbol == #messageListChanged) 		ifTrue: [^ self updateMessageList.].	(aSymbol == #classSelectionChanged) ifTrue:		[model messageCategoryListIndex = 1			ifTrue: ["self updateMessageList."]			ifFalse: [^ self resetAndDisplayView]]! !!MessageNode methodsFor: 'macro transformations'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [initStmt isMemberOf: AssignmentNode])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: MessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ BlockNode new			statements: body allButLast			returns: false.	toDoBlock arguments: (Array with: variable).	^ MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence!toDoWithLimit: limitStmt	"The receiver is a to:do: statement, preceded by a statement	that might be of the form {iLimiT _ expr}.  If so, replace the	limit argument by the given expr and return a new to:do: node.	Otherwise, return nil"	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable = arguments first])		ifFalse: [^ nil].	limitStmt variable key = (arguments last firstArgument key , 'LimiT')		ifFalse: [^ nil].  "Must be a generated temp"	arguments at: 1 put: (limitStmt value)!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				increment isConstantNumber ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	block _ arguments last.	blockVar _ block firstArgument.	initStmt _ AssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ AssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ MessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder.	incStmt _ AssignmentNode new			variable: blockVar			value: (MessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!MessageNode methodsFor: 'code generation'!emitForValue: stack on: strm	special > 0		ifTrue: 			[self perform: (MacroEmitters at: special) with: stack with: strm with: true.			pc _ 0]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper.			pc _ strm position]!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector _ selector copy "only necess for splOops"].	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total _ total + (receiver sizeForValue: encoder)].	sizes _ arguments collect: 					[:arg | 					argSize _ arg sizeForValue: encoder.					total _ total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'printing'!printKeywords: key arguments: args on: aStream indent: level	| keywords prev arg indent thisKey |	args size = 0 		ifTrue: [aStream space.				aStream withAttribute: (TextLinkToImplementors of: key)					do: [aStream nextPutAll: key].				^ self].	keywords _ key keywords.	prev _ receiver.	1 to: keywords size do:		[:part | arg _ args at: part.		thisKey _ keywords at: part.		(prev isMemberOf: BlockNode)		 | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])		 | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])		 | (args size > 2)		 | (key = #ifTrue:ifFalse:)			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		aStream withAttribute: (TextLinkToImplementors of: key) do: 			[aStream nextPutAll: thisKey].  aStream space.		arg  printOn: aStream indent: level + 1 + indent			 precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		prev _ arg]!printToDoOn: aStream indent: level	| limitNode |	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'C translation'!asTranslatorNode	"selector is sometimes a Symbol, sometimes a SelectorNode!!	On top of this, numArgs is needed due to the (truly grody) use of	arguments as a place to store the extra expressions needed to generate	code for in-line to:by:do:, etc.  see below, where it is used."	| sel args |	sel _ (selector isMemberOf: Symbol) ifTrue: [selector] ifFalse: [selector key].	args _ (1 to: sel numArgs) collect:			[:i | (arguments at: i) asTranslatorNode].	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])		ifTrue: ["Restore limit expr that got moved by transformToDo:"				args at: 1 put: (arguments at: 7) value asTranslatorNode].	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformOr:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformIfFalse:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	^ TSendNode new		setSelector: sel		receiver: ((receiver == nil)					ifTrue: [nil]					ifFalse: [receiver asTranslatorNode])		arguments: args! !!MessageSet methodsFor: 'contents'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector notice |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class				compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	notice _ class checkForPerform: selector in: aController.	notice size = 0 ifFalse: ["insert the notice"			aController notify: notice				at: contents size + 1				in: nil.			self lock  "code is dirty"].	^true! !!MessageTally methodsFor: 'initialize-release'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay _ Delay forMilliseconds: millisecs.	Timer _		[[true] whileTrue: 			[startTime _ Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value _ aBlock value.		"cancel the probe and return the value"	Timer terminate.	^value! !!MessageTally methodsFor: 'tallying'!bumpBy: count	tally _ tally + count!tally: context by: count	"Explicitly tally the specified context and its stack."	| root |	context method == method ifTrue: [^self bumpBy: count].	(root _ context home sender) == nil		ifTrue: [^ (self bumpBy: count) tallyPath: context by: count].	^ (self tally: root by: count) tallyPath: context by: count!tallyPath: context by: count	| aMethod path |	aMethod _ context method.	receivers do: 		[:aMessageTally | 		aMessageTally method == aMethod ifTrue: [path _ aMessageTally]].	path == nil ifTrue: 		[path _ MessageTally new class: context receiver class method: aMethod.		receivers _ receivers copyWith: path].	^ path bumpBy: count! !!MessageTally methodsFor: 'printing'!printOn: aStream total: total tallyExact: isExact	| aSelector className myTally |	isExact ifTrue:		[myTally _ tally.		receivers == nil			ifFalse: [receivers do: [:r | myTally _ myTally - r tally]].		aStream print: myTally; space]		ifFalse:		[aStream print: (tally asFloat / total * 100.0 roundTo: 0.1); space].	receivers == nil		ifTrue: [aStream nextPutAll: 'primitives'; cr]		ifFalse: 			[aSelector _ class selectorAtMethod: method setClass: [:aClass].			className _ aClass name contractTo: 30.			aStream nextPutAll: className; space;				nextPutAll: (aSelector contractTo: 60-className size); cr]! !!MessageTally class methodsFor: 'spying'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"MessageTally tallySends: [3.14159 printString]"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies |	tallies _ MessageTally new class: aBlock receiver class							method: aBlock method.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev _ current]].	StringHolderView open: (StringHolder new contents:		(String streamContents:			[:s |			treeOption				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].			tallies close]))		label: 'Spy Results'!time: aBlock	^ Time millisecondsToRun: aBlock! !!Metaclass methodsFor: 'initialize-release'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true.				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'compiling'!scopeHas: name ifTrue: assocBlock  	^thisClass scopeHas: name ifTrue: assocBlock! !!Metaclass methodsFor: 'fileIn/Out'!definition 	"Refer to the comment in ClassDescription|definition."	| aStream names |	aStream _ WriteStream on: (String new: 300).	self printOn: aStream.	names _ self instVarNames."	names isEmpty ifTrue: [^  aStream contents]."	aStream nextPutAll: '	instanceVariableNames: '''.	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].	aStream nextPut: $'.	^ aStream contents! !!MethodDictionary methodsFor: 'private'!rehash 	| newSelf key |	newSelf _ self species new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!MethodDictionary class methodsFor: 'instance creation'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2."	| size |	size _ (nElements max: 1) * 5 // 4.	size isPowerOfTwo ifFalse:		["Size must be a power of 2..."		size _ 1 bitShift: size highBit].	size >= 1 ifFalse: [self error: 'size must be >= 1'].	^ (self basicNew: size) init: size! !!MethodNode methodsFor: 'code generation'!generate: trailer	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	encoder maxTemp > 31		ifTrue: [^self error: 'Too many temporary variables'].		literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in 	me) -> sourceRange (an Interval) in source text."	self generate: #(0 0 0 0).	^encoder sourceMap! !!MethodNode methodsFor: 'converting'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ String streamContents: [:strm | self printOn: strm]!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ Text streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[primitive < 256 ifTrue:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'C translation'!asTMethodFromClass: aClass 	^ TMethod new		setSelector: selectorOrFalse		args: arguments		locals: encoder tempsAndBlockArgs		block: block! !!MixedSound methodsFor: 'sound generation'!samplesRemaining	| remaining r |	remaining _ 0.	1 to: sounds size do: [ :i |		r _ (sounds at: i) samplesRemaining.		r > remaining ifTrue: [ remaining _ r ].	].	^ remaining! !!Model methodsFor: 'dependents'!addDependent: anObject	"Make the given object one of the receiver's dependents."	dependents == nil		ifTrue: [dependents _ Array with: anObject]		ifFalse: [			"done if anObject is already a dependent"			dependents do: [:o | o == anObject ifTrue: [^ self]].			"otherwise, add it"			dependents _ dependents copyWith: anObject].!breakDependents	"Remove all of the receiver's dependents."	dependents _ nil.!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	dependents == nil ifTrue: [^ #()].	^ dependents!removeDependent: anObject	"Remove the given object as one of the receiver's dependents.	10/30/96 sw: if dependents nil on entry, simply exit; workaround for confusing bug encountered in bringing Fabrik up on Squeak."	| newDependents |	dependents == nil ifTrue: [^ self].	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [dependents _ nil]		ifFalse: [dependents _ newDependents]! !Morph comment:'A morph (from the Greek "shape" or "form") is an interactive graphical object.'!!Morph methodsFor: 'initialization'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.	! !!Morph methodsFor: 'classification'!isHandMorph	^ false!isLayoutMorph	^ false!isMorph	^ true!isMouseSensor	^ false!isWorldMorph	^ false!isWorldOrHandMorph	^ self isWorldMorph or: [self isHandMorph]! !!Morph methodsFor: 'accessing'!color	^ color!color: aColor	color _ aColor.	self changed.! !!Morph methodsFor: 'copying'!copy	^ self copyWithoutSubmorphs!fullCopy	| dict new |	dict _ IdentityDictionary new: 1000.	new _ self copyRecordingIn: dict.	new allMorphsDo: [:m | m updateReferencesUsing: dict].	^ new!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that has been copied. For example, if a button refers to morph X in the orginal composite then the copy of that button in the new composite should refer to the copy of X in new composite, not the original X. This default implementation updates the contents of any morph-bearing slot. It may be overridden to avoid this behavior if so desired."	| first old |	first _ Morph instSize + 1.	first to: self class instSize do: [:i |		old _ self instVarAt: i.		old isMorph ifTrue: [			self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].! !!Morph methodsFor: 'structure'!isInWorld	"Return true if this morph is in a world."	^ self world ~= nil!owner	"Returns the owner of this morph, which may be nil."	^ owner!root	"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph."	(owner = nil or: [owner isWorldOrHandMorph]) ifTrue: [^ self].	^ owner root!world	"Return the WorldMorph that contains this morph, or nil if this morph is not in a world."	| o |	o _ self root owner.	o ifNil: [^ nil].	o isWorldMorph ifTrue: [^ o].	o isHandMorph ifTrue: [^ o owner].! !!Morph methodsFor: 'submorphs-accessing'!allMorphs	"Return a collection containing all morphs in this composite morph (including the receiver)."	| all |	all _ OrderedCollection new: 100.	self allMorphsDo: [: m | all add: m].	^ all!allMorphsDo: aBlock	"Evaluate the given block for all morphs in this composite morph (including the receiver)."	submorphs size > 0 ifTrue: [		submorphs do: [:m | m allMorphsDo: aBlock].	].	aBlock value: self.!firstSubmorph	^ submorphs at: 1!hasSubmorphs	^ submorphs size > 0!lastSubmorph	^ submorphs at: submorphs size!morphsAt: aPoint	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself."	| mList |	mList _ OrderedCollection new.	self allMorphsDo: [: m | (m containsPoint: aPoint) ifTrue: [mList addLast: m]].	^ mList!submorphCount	^ submorphs size!submorphs	^ submorphs copy!submorphsDo: aBlock	submorphs do: aBlock.!submorphsReverseDo: aBlock	submorphs reverseDo: aBlock.! !!Morph methodsFor: 'submorphs-add/remove'!addAllMorphs: aCollection	aCollection do: [:m | 		m owner ifNotNil: [m owner privateRemoveMorph: m].		m privateOwner: self].	submorphs _ submorphs , aCollection.	self layoutChanged.!addMorph: aMorph	self addMorphFront: aMorph.!addMorphBack: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	submorphs _ submorphs copyWith: aMorph.	aMorph changed.  "Need to repaint even if no move"	self layoutChanged.!addMorphFront: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	submorphs _ (Array with: aMorph), submorphs.	self layoutChanged.!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	owner ifNotNil: [		owner privateRemoveMorph: self.		owner _ nil].!removeAllMorphs	self changed.	submorphs do: [:m | m privateOwner: nil].	submorphs _ EmptyArray.	self layoutChanged.! !!Morph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color.!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'geometry'!bottom	^ bounds bottom!bounds	^ bounds!bounds: newBounds	self position: newBounds topLeft; extent: newBounds extent!center	^ bounds center!extent	^ bounds extent!extent: extent	self changed.	bounds _ bounds topLeft extent: extent.	self layoutChanged.	self changed.!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		self submorphsDo: [:m | fullBounds _ fullBounds merge: m fullBounds]].	^ fullBounds!height	^ bounds height!innerBounds	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."	^ bounds!left	^ bounds left!position	^ bounds topLeft!position: aPoint	| delta |	delta _ aPoint truncated - bounds topLeft.	delta = (0@0) ifTrue: [^ self].  "no change"	self changed.	self allMorphsDo: [:m | m privateMoveBy: delta].	self changed.!right	^ bounds right!top	^ bounds top!width	^ bounds width! !!Morph methodsFor: 'geometry testing'!containsPoint: aPoint	^ self bounds containsPoint: aPoint!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	self allMorphsDo:		[:m | (m containsPoint: aPoint) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'dropping/grabbing'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation does nothing."!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them. This default implementation returns false."	^ false!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph. This default implementation does nothing."!rootForGrabOf: aMorph	"Like root, but can be overridden by a morph that wants to allow its submorphs to be extracted just by picking them up."	(owner = nil or: [owner isWorldOrHandMorph]) ifTrue: [^ self].	owner allowSubmorphExtraction		ifTrue: [^ self]		ifFalse: [^ owner rootForGrabOf: aMorph].!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped into the world by a hand in response to the given event. This default implementation returns false."	^ false! !!Morph methodsFor: 'events'!inputEventTransform	"Return a transform to be used to map the position of incoming input events into local coordinates. This is used to support morphs that scroll, scale, and/or rotate their submorphs. This default implementation just returns the owner's transform or the identity transform if the owner is nil."	owner == nil		ifTrue: [^ MorphicTransform identity]		ifFalse: [^ owner inputEventTransform].!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing."!keyStroke: anEvent	"Handle a keystroke event. This default implementation does nothing."!mouseDown: evt	"Handle a mouse down event. This default implementation is for the source hand to grab this morph's root."	evt hand grabMorph: (self rootForGrabOf: self).!mouseMove: evt	"Handle a mouse move event. This default implementation does nothing."!mouseRecipientAt: aPoint	"Return the submorph that should handle the mouseDown: event at the given point, or nil of no such submorph can be found. The default behavior is to return the front-most submorph that contains the given point. Subclasses may override this method to implement other behavior."	| recipient |	self submorphsDo: [:m |		(m fullBounds containsPoint: aPoint) ifTrue: [			recipient _ m mouseRecipientAt: aPoint.			recipient ifNotNil: [^ recipient]]].	(self containsPoint: aPoint)		ifTrue: [^ self]		ifFalse: [^ nil].!mouseUp: evt	"Handle a mouse up event. This default implementation does nothing."! !!Morph methodsFor: 'stepping'!startStepping	"Start getting sent the 'step' message."	| w |	self step.  "one to get started!!"	w _ self world.	w ifNotNil: [		w startStepping: self.		self changed].!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. This default implementation does nothing."!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ 1000!stopStepping	"Stop getting sent the 'step' message."	| w |	w _ self world.	w ifNotNil: [		w stopStepping: self.		self changed].!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'viewer' action: #openPartsViewer:.!chooseColor	"Displays a color palette using abstract colors, then waits for a mouse click."	"Copied from Color fromUser, then shrunk."	| loc d save p cp c |	loc _ Sensor cursorPoint.	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ Color colorChartForDepth: d extent: 216@56].	save _ Form fromDisplay: (loc extent: ColorChart extent).	ColorChart displayAt: loc.	Cursor normal showWhile: [		[Sensor anyButtonPressed] whileFalse: [			p _ Display pixelValueAt: (cp _ Sensor cursorPoint).			c _ ((loc extent: ColorChart extent) containsPoint: cp)				ifTrue: [Color colorFromPixelValue: p depth: d]				ifFalse: [nil].			Display fill: (loc + (0@46) extent: 216@10) fillColor: (c ifNil: [Color gray])].		save displayAt: loc.		Sensor waitNoButton.	].	^ c! !!Morph methodsFor: 'layout'!minHeight	"Return the minimum width for this morph. Ordinary morphs just answer their current height."	^ self fullBounds height!minWidth	"Return the minimum width for this morph. Ordinary morphs just answer their current width."	^ self fullBounds width! !!Morph methodsFor: 'change reporting'!changed	"Report that the area occupied by this morph should be redrawn."	self invalidRect: self fullBounds.!invalidRect: damageRect	owner ifNotNil: [owner invalidRect: damageRect].!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds ifNotNil: [		self invalidRect: fullBounds].  "invalidate with old fullBounds in case shrinking"	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].! !!Morph methodsFor: 'printing'!colorString: aColor	aColor == nil ifTrue: [^ 'nil'].	Color names do: [:colorName | aColor = (Color perform: colorName)								ifTrue: [^ 'Color ' , colorName]].	^ aColor storeString!constructorString	^ String streamContents: [:s | self printConstructorOn: s indent: 0].!fullPrintOn: aStream	aStream nextPutAll: self class name , ' newBounds: (';		print: bounds;		nextPutAll: ') color: ' , (self colorString: color)!initString	^ String streamContents: [:s | self fullPrintOn: s]!printConstructorOn: aStream indent: level	^ self printConstructorOn: aStream indent: level nodeDict: IdentityDictionary new!printConstructorOn: aStream indent: level nodeDict: nodeDict	| nodeString |	(nodeString _ nodeDict at: self ifAbsent: [nil])		ifNotNil: [^ aStream nextPutAll: nodeString].	submorphs isEmpty ifFalse: [aStream nextPutAll: '('].	aStream nextPutAll: '('.	self fullPrintOn: aStream.	aStream nextPutAll: ')'.	submorphs isEmpty ifTrue: [^ self].	submorphs size <= 4	ifTrue:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: (Array'.		1 to: submorphs size do:			[:i | aStream crtab: level+1; nextPutAll: 'with: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict].		aStream nextPutAll: '))']	ifFalse:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: ((Array new: ', submorphs size printString, ')'.		1 to: submorphs size do:			[:i |			aStream crtab: level+1; nextPutAll: 'at: ', i printString, ' put: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict.			aStream nextPutAll: ';'].		aStream crtab: level+1; nextPutAll: 'yourself))']!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(';			print: self identityHash;			nextPutAll: ')'.!storeOn: aStream	super storeOn: aStream.! !!Morph methodsFor: 'e-toy commands'!beep	Smalltalk beep.!bounce	| box |	owner ifNil: [^ self].	box _ owner bounds.	(self left < box left) ifTrue: [self headRight].	(self right > box right) ifTrue: [self headLeft].	(self top < box top) ifTrue: [self headDown].	(self bottom > box bottom) ifTrue: [self headUp].!commandsWithDefaultArgs	"Return a list of (command arg1 arg2 ...) arrays where each command is followed by the default values for is parameters."	| r |	r _ OrderedCollection new."	r add: #(beep)."	r add: #(bounce).	r add: #(forward: 15)."	r add: #(hide)."	r add: (Array with: #jumpTo: with: 10@10)."	r add: #(show)."	r add: #(turn: 15)."	r add: #(#wearCostume:)."	r add: #(wrap).	"general parameter setting/updating"	r add: (Array with: #set: with: 20@20).	r add: #(incr: 15).	r add: #(decr: 15).	^ r!decr: aPointOrNumber	"Decrement my position."	self forward: aPointOrNumber negated.!forward: dist	"Let my owner decide how I move."	owner move: self forwardBy: dist heading: self heading.!hide	"Move this morph way, way offstage!!"	self position < (5000@5000) ifTrue: [		self position: self position + (1000000@100000)].!incr: aPointOrNumber	"Increment my position."	self forward: aPointOrNumber.!jumpTo: aPoint	"Let my owner decide how I move."	owner move: self toPosition: aPoint.!set: aPointOrNumber	"Set my position."	self jumpTo: aPointOrNumber.!show	"Make sure this morph is on-stage."	(self fullBounds intersects: self world bounds) ifFalse: [		self position: self position - (1000000@100000).		self wrap].  "be sure I'm on-stage"!turn: degrees	"Note: This command may do nothing for some kinds of morph."	self rotationDegrees:		(self rotationDegrees + (self asAngleInDegrees: degrees)) \\ 360.0.!wearCostume: aMorph	"If the receiver and argument are both kinds of SketchMorph, make the receiver wear the costume of the argument. Otherwise, do nothing. This default implementation does nothing."!wrap	| myBox box newX newY |	owner ifNil: [^ self].	myBox _ self fullBounds.	box _ owner bounds.	newX _ self position x.	newY _ self position y.	((myBox right < box left) or: [myBox left > box right])		ifTrue: [newX _ self position x \\ box width].	((myBox bottom < box top) or: [myBox top > box bottom])		ifTrue: [newY _ self position y \\ box height].	self position: newX@newY.! !!Morph methodsFor: 'e-toy support'!asAngleInDegrees: aPointOrNumber	"Support for e-toy demo."	aPointOrNumber class = Point		ifTrue: [^ aPointOrNumber theta]		ifFalse: [^ aPointOrNumber asFloat].!asNumber: aPointOrNumber	"Support for e-toy demo."	aPointOrNumber class = Point		ifTrue: [^ aPointOrNumber r]		ifFalse: [^ aPointOrNumber].!buttonsForCommands	"Return a list of buttons from my commands."	| cmd args s |	^ self commandsWithDefaultArgs collect: [:entry |		cmd _ entry first asSymbol.		args _ entry allButFirst.		s _ WriteStream on: ''.		s nextPutAll: cmd; space.		args do: [:arg | s nextPutAll: arg printString; space].		s position: s position - 1.  "remove trailing space"		SimpleButtonMorph new			actionSelector: cmd;			arguments: args;			label: s contents;			target: self].!choosePartNameSilently	^ self world model namePartSilently: self!goHome	| w box |	w _ self world.	w ifNotNil: [		box _ w bounds.		self left < box left ifTrue: [self position: box left@self position y].		self right > box right ifTrue: [self position: (box right - self width)@self position y].		self top < box top ifTrue: [self position: self position x@box top].		self bottom > box bottom ifTrue: [self position: self position x@(box bottom - self height)]].!headDown	| radians |	radians _ self rotationDegrees degreesToRadians.	self rotationDegrees:		((radians cos @ radians sin abs negated) theta radiansToDegrees			roundTo: 0.0001).!heading	"Default implementation."	^ 0.0!headLeft	| radians |	radians _ self rotationDegrees degreesToRadians.	self rotationDegrees:		((radians cos abs negated @ radians sin) theta radiansToDegrees			roundTo: 0.0001).!headRight	| radians |	radians _ self rotationDegrees degreesToRadians.	self rotationDegrees:		((radians cos abs @ radians sin) theta radiansToDegrees			roundTo: 0.0001).!headUp	| radians |	radians _ self rotationDegrees degreesToRadians.	self rotationDegrees:		((radians cos @ radians sin abs) theta radiansToDegrees			roundTo: 0.0001).!move: aMorph forwardBy: aPointOrNumber heading: headingInDegrees	"Support for e-toy demo. Move the given submorph the given amount. Allows the morph's owner to determine the policy for motion. For example, moving forward through a table might mean motion only in the x-axis with wrapping modulo the table size."	aMorph position:		aMorph position +		  (Point r: (self asNumber: aPointOrNumber) degrees: headingInDegrees negated) truncated.!move: aMorph toPosition: aPointOrNumber	"Support for e-toy demo. Move the given submorph to the given position. Allows the morph's owner to determine the policy for motion. For example, moving forward through a table might mean motion only in the x-axis with wrapping modulo the table size."	aMorph position: aPointOrNumber asPoint.!nameInModel	"Return the name for this morph in the underlying model."	^ self world model nameFor: self!openPartsViewer: evt	self nameInModel ifNil: [self choosePartNameSilently].	evt hand attachMorph:		(PartsViewerMorph new setMorph: self morphName: self nameInModel).!parts	"Return an array of part names for use in e-toys."	^ #(position)!rotationDegrees	"Default implementation."	^ 0.0!rotationDegrees: ignored	"Default implementation that does nothing to support noop turn: command."!tilesForCommands	"Return a list of buttons from my commands."	| cmd args tiles |	^ self commandsWithDefaultArgs collect: [:entry |		cmd _ entry first asSymbol.		args _ entry allButFirst.		tiles _ CommandTilesMorph new.		tiles addMorphBack: (TileMorph new setObjectRef: self nameInModel).		tiles addMorphBack: (TileMorph new setOperator: cmd).		args isEmpty ifFalse: [			tiles addMorphBack: (TileMorph new setLiteral: args first)].		tiles].! !!Morph methodsFor: 'model access'!choosePartName	"Pick an unused name for this morph."	| className |	className _ self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	^ self world model addPartNameLike: className withValue: self!installModelIn: ignored	"Simple morphs have no model"	"See MorphicApp for other behavior"!sensitize	"Add a MouseSensitive subMorph"	| sensor |	self addMorph: (sensor _ MouseSensorMorph new).	sensor installModelIn: self world! !!Morph methodsFor: 'other'!flash	| w |	w _ self world.	w ifNotNil: [		Display flash: (bounds translateBy: w viewBox origin)].! !!Morph methodsFor: 'private'!copyRecordingIn: dict	"Recursively copy this entire composite morph, recording the correspondence between old and new morphs in the given dictionary. This dictionary will be used to update intra-composite references in the copy."	| new |	new _ self copy.	submorphs size > 0 ifTrue: [		new privateSubmorphs:			(submorphs collect: [:m |				(m copyRecordingIn: dict) privateOwner: new])].	dict at: self put: new.	^ new!copyWithoutSubmorphs	^ self clone		privateOwner: nil;		privateSubmorphs: EmptyArray;		privateBounds: (bounds origin corner: bounds corner)  "deep-copy bounds"!morphAtPath: path	"Private access for setting up model pointers into a copied structure		-- see pathTo: "	^ self morphAtPath: path level: 1!morphAtPath: pathArray level: level	level > pathArray size ifTrue: [^ self].	^ (submorphs at: (pathArray at: level))		morphAtPath: pathArray 		level: level+1!pathTo: aMorph	"Private access for setting up model pointers into a copied structure"	" () is the root, (1) the first subMorph, and (1 3) its third subMorph"	| subPath |	self == aMorph ifTrue: [^ Array new].	submorphs doWithIndex:		[:m :i |		m == aMorph ifTrue: [^ Array with: i].		subPath _ m pathTo: aMorph.		subPath ifNotNil: [^ (Array with: i) , subPath]].	^ nil!privateAddMorph: aMorph atIndex: index	| newSize newSubmorphs |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph privateOwner: self.	newSize _ submorphs size + 1.	newSubmorphs _ Array new: newSize.	newSubmorphs at: index put: aMorph.	index = 1 ifTrue: [		newSubmorphs replaceFrom: 2 to: newSize with: submorphs startingAt: 1.	] ifFalse: [		index = newSize ifTrue: [			newSubmorphs replaceFrom: 1 to: newSize - 1 with: submorphs startingAt: 1.		] ifFalse: [			newSubmorphs replaceFrom: 1 to: index - 1 with: submorphs startingAt: 1.			newSubmorphs replaceFrom: index + 1 to: newSize with: submorphs startingAt: index]].	submorphs _ newSubmorphs.	self layoutChanged.!privateBounds: boundsRect	"Private!! Use position: and/or extent: instead."	fullBounds _ nil.	bounds _ boundsRect.!privateMoveBy: delta	"Private!! Use 'position:' instead."	bounds moveBy: delta.	fullBounds _ nil.!privateOwner: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	owner _ aMorph.!privateRemoveMorph: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	aMorph changed.	submorphs _ submorphs copyWithout: aMorph.	self layoutChanged.!privateSubmorphs	"Private!! Use 'submorphs' instead."	^ submorphs!privateSubmorphs: aCollection	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs _ aCollection.! !!Morph class methodsFor: 'instance creation'!new	^ super new initialize!newBounds: bounds	^ self new privateBounds: bounds!newBounds: bounds color: color	^ (self new privateBounds: bounds) color: color!newExtent: extent	^ self new privateBounds: (0@0 extent: extent)! !!Morph class methodsFor: 'class initialization'!initialize	"Morph initialize"	"this empty array object is shared by all morphs with no submorphs:"	EmptyArray _ Array new.! !!Morph class methodsFor: 'Project status'!diComment" MorphWorldView open.Display newDepth: 1Display newDepth: 8Display newDepth: 16New Features:[2/27] Restore from save inits stepping (I put it in addAllMorphs)[2/27] Ovals now work faster, and support transparent inside[2/27] Ovals no longer have warts on left and right sides[2/27] Flushes bit cache while window active to save space.[2/27] Worlds propagate their color to window color.[2/27] World views save as two-tones by default.[2/27] Line drawing is now somewhat faster.[2/27] Shift-activate for stats now restores cursor when done.[2/27] String morphs now save/restore their contents[3/1] Moved model construction details out of World, Morph into MorphicApp[3/1] Moved targetOffset out of SensorMorph and Events, into hand[3/6] Complete construction of MorphicApps . . .	[done] Add 'add part' to inspector.	[done] Add 'export part' to inspector.	[done] Put change propagation to owner into MorphicApp.	[done] Save App into model class		Need to generate morphic structure		and also the model pointers into it.	[done] Add saved App as a component[3/9] Make MorphicApp a sub of Morph	[done] Make MorphicControl subclassOf: Morph		instanceVariableNames: 'model slotName'		visual no-op when 'installed'	[done] Make MouseSens and MorphicApp be subclasses	[done] Do away with rootMorph[3/20] MorphicApp, Control now named MorphicModel.[3/20] Delete of MorphicModels now removes generated code as well.[3/21] initMorph now builds parts first,	then prints tree with part refs in dictionary.[3/21] MorphicModel and mouseSensor have been cleaned up and commentedBugsToFix:Next to do: [ ] Do away with MVC. . .Build button morphBuild scrollBar morphBuild (clipping) window morphBuild scrolling window - scale, rotate?Build layout morphBuild listView (scrolling window of layout of string morphs)Build browser topBuild paragraph morphBuild full browserIssues:Cleanup:  Let's choose 'all' or 'full' but not both	to mean full tree traversal (no biggy, but easier now than later)."!fileOutProject   "Morph fileOutProject"	"Note: This procedure assumes that all project classes are in system	categories of the form 'Morphic-Category'.  It operates as follows:	1.  It files out each category of the form 'Morphic-Category'.	2.  It removes all changes that are NOT in any of those classes.	3.  It files out the remaining changes as 'Morphic-Changes.st'."	"When you fileIn the project, you should do it as fillows:	1.  FileIn all files of the form 'Morphic-Category.st'.	2.  Clear your changeSet.	3.  FileIn the file 'Morphic-Changes.st'."	(PopUpMenu confirm: 'Did you remember to update the version numberby renaming the Morphic-vNN category??') ifFalse: [^ self].	(SystemOrganization categories select: [:cat | 'Morphic-*' match: cat]) do:		[:cat | SystemOrganization fileOutCategory: cat.		(SystemOrganization superclassOrder: cat) do:			[:cls | cls removeFromChanges]].	(FileStream newFileNamed: 'Morphic-Changes.st') fileOutChanges.!jhmComment"John's Morphic To Do List:[xxx] morph-specific menus[xxx] colorAll (include it in meta menu, too)[xxx] dropping[xxx] scrolling/clipping morph[xxx] automatic layout[xxx] turtles-n-trails[xxx] multiple font support[xxx] all vs. full: choose and make uniform [jhm: really a problem?][done] multiple hands[done] move meta-menu stuff into hand morph[done] make stepping be by subscription[done] remove 'hasChanged' instance variable[done] bug: missed mouseDown, mouseUp if no move[done] as a test of keyboardFocus, make string morph's editable[done] event dispatching and subscribing[done] fix rootOwner (and change its name!!)[done] clean up WorldMorphView[done] remove IdentitySet and FontSpec[done] containsPt: -> containsPoint:[done] review canvas protocolFormCanvas To Do  List:  Faster text drawing  Faster line drawing  Polygons  Wedges (i.e., oval pie chunks)  Image copy/pasteIssues:* May not need 'desensitize' (can just extract and delete sensor morph)* Do we need a copy that preserves intra-morph refs?* MorphWorlds take tons-o-space since they keep both a FormCanvas  and a cachedBits form (in their ColorSystemView). Could they share  a single Form? (In the long run, we may not need cachedBits at all...)"! !!MorphicEvent methodsFor: 'initialization'!initialize	type _ #unknown.	cursorPoint _ 0@0.	buttons _ 0.	keyValue _ 0.	sourceHand _ nil.! !!MorphicEvent methodsFor: 'accessing'!buttons	"Return the a word encoding the mouse and modifier buttons for this event."	^ buttons!hand	"Return the hand that originated this event."	^ sourceHand!type	"Return a symbol indicating the type this event."	^ type! !!MorphicEvent methodsFor: 'classification'!isKeystroke	^ type == #keystroke!isMouse	^ (type == #mouseMove) | (type == #mouseDown) | (type == #mouseUp)!isMouseDown	^ type == #mouseDown!isMouseMove	^ type == #mouseMove!isMouseUp	^ type == #mouseUp! !!MorphicEvent methodsFor: 'mouse'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: 7!blueButtonPressed	"Answer true if the blue mouse button is being pressed."	^ buttons anyMask: 1!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ cursorPoint!redButtonPressed	"Answer true if the red mouse button is being pressed."	^ buttons anyMask: 4!targetPoint	"Answer the location of the cursor's hotspot, adjusted by the offset	of the last mouseDown relative to the recipient morph."	^ cursorPoint - sourceHand targetOffset!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform transform: cursorPoint)!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed."	^ buttons anyMask: 2! !!MorphicEvent methodsFor: 'keyboard'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 64!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 16!keyCharacter	"Answer the character corresponding this keystroke. This is defined only for keystroke events."	^ keyValue asCharacter!keyValue	"Answer the ascii value for this keystroke. This is defined only for keystroke events."	^ keyValue!optionKeyPressed	"Answer whether the option key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 32!shiftPressed	"Answer true if either the left or right shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicEvent methodsFor: 'printing'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self cursorPoint printString; space.	aStream nextPutAll: type.	self isKeystroke ifTrue: [		self controlKeyPressed ifTrue: [			aStream nextPutAll: ' ''^'.			aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.		] ifFalse: [			aStream nextPutAll: ' '''.			aStream nextPut: self keyCharacter.		].		aStream nextPut: $'.	].	aStream nextPut: $].! !!MorphicEvent methodsFor: 'private'!setCursorPoint: aPoint	"Used for transforming events."	cursorPoint _ aPoint.!setKeyValue: keyVal mousePoint: aPoint buttons: anInteger hand: hand	type _ #keystroke.	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ keyVal.	sourceHand _ hand.!setMousePoint: aPoint buttons: anInteger lastEvent: lastEvent hand: hand	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ 0.	sourceHand _ hand.	self redButtonPressed ifTrue: [		lastEvent redButtonPressed			ifTrue: [type _ #mouseMove]			ifFalse: [type _ #mouseDown].	] ifFalse: [		lastEvent redButtonPressed			ifTrue: [type _ #mouseUp]			ifFalse: [type _ #mouseMove]].!setType: newType	type _ newType.! !!MorphicEvent class methodsFor: 'instance creation'!new	^ super new initialize! !MorphicModel comment:'MorphicModels are used to represent structures with state and behavior as well as graphical structure.  A morphicModel is usually the root of a morphic tree depicting its appearance.  The tree is constructed concretely by adding its consituent morphs to a world.When a part is named in a world, it is given a new slot in the model.  When a part is sensitized, it is named, and a set of mouse-driven methods is also generated in the model.  These may be edited to induce particular behavior.  When a variable is added through the morphic world, it is given a slot in the model, along with a set of access methods.In addition for public variables (and this is the default for now), methods are generated and called in any outer model in which this model gets embedded, thus propagating variable changes outward.'!!MorphicModel methodsFor: 'initialization'!delete	model ifNotNil: [(PopUpMenu confirm: 'Shall I remove the slot ' , slotName , 'along with all associated methods?')		ifTrue:		[(model class selectors select: [:s | s beginsWith: slotName])			do: [:s | model class removeSelector: s].		model class removeInstVarName: slotName]		ifFalse:		[(PopUpMenu confirm: '...but should I at least dismiss this morph?[choose no to leave everything unchanged]') ifFalse: [^ self]]].	super delete!initialize	super initialize.	bounds _ 0@0 corner: 20@20.	color _ Color yellow.!installed	^ submorphs size > 0!model: thang slotName: nameOfThisPart	model _ thang.	slotName _ nameOfThisPart! !!MorphicModel methodsFor: 'compilation'!addPartNameLike: className withValue: aMorph	| otherNames i default partName stem |	stem _ className first asLowercase asString , className allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (default _ stem, i printString)]		whileTrue: [i _ i + 1].	partName _ FillInTheBlank		request: 'Please give this part a name'		initialAnswer: default.	(otherNames includes: partName)		ifTrue: [self inform: 'Sorry, that name is already used'. ^ nil].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "Assumes added as last field"	^ partName!compileInitMethods	| s nodeDict varNames |	nodeDict _ IdentityDictionary new.	s _ WriteStream on: (String new: 2000).	varNames _ self class allInstVarNames.	s nextPutAll: 'initMorph'.	3 to: self class instSize do:		[:i | (self instVarAt: i) isMorph ifTrue:			[s cr; tab; nextPutAll: (varNames at: i) , ' _ '.			s nextPutAll: (self instVarAt: i) initString; nextPutAll: '.'.			nodeDict at: (self instVarAt: i) put: (varNames at: i)]].	submorphs do: 		[:m | s cr; tab; nextPutAll: 'self addMorph: '.		m printConstructorOn: s indent: 1 nodeDict: nodeDict.		s nextPutAll: '.'].	self class		compile: s contents		classified: 'initialization'		notifying: nil.!compilePropagationMethods	| varName |	(self class organization listAtCategoryNamed: 'private - propagation' asSymbol)		do: [:sel | varName _ sel allButLast.			model class compilePropagationForVarName: varName slotName: slotName]!installModelIn: aWorld	self initMorph.	slotName _ aWorld model addPartNameLike: self class name withValue: self.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: aWorld model slotName: slotName.	self compilePropagationMethods!nameFor: aMorph	"Return the name of the slot containing the given morph or nil if that morph has not been named."	| allNames start |	allNames _ self class allInstVarNames.	start _ MorphicModel allInstVarNames size + 1.	start to: allNames size do: [:i |		(self instVarAt: i) == aMorph ifTrue: [^ allNames at: i]].	^ nil!namePartSilently: aMorph	| stem otherNames i partName |	stem _ aMorph class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem _ stem copyFrom: 1 to: stem size - 5].	stem _ stem first asLowercase asString, stem allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (partName _ stem, i printString)]		whileTrue: [i _ i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "assumes added as last field"	^ partName!propagate: value as: partStoreSelector	model == nil ifTrue: [^ self]."	Later we can cache this for more speed as follows...	(partName == cachedPartName and: [slotName == cachedSlotName])		ifFalse: [cachedPartName _ partName.				cachedSlotName _ slotName.				cachedStoreSelector _ (slotName , partStoreSelector) asSymbol].	model perform: cachedStoreSelector with: value]."	model perform: (slotName , partStoreSelector) asSymbol with: value!saveWithSubmorphs: morphs	submorphs _ morphs.		"Root morphs will temporarily have two owners.		Thus if we hit an error, they will remain in their world."	self class chooseNewName.	self compileInitMethods.	submorphs _ Array new! !!MorphicModel methodsFor: 'geometry'!bounds: newBoundsRect	submorphs do:		[:m | m bounds: (m bounds scaleFrom: bounds to: newBoundsRect)].	super bounds: newBoundsRect!layoutChanged	super layoutChanged.	self installed ifTrue: [self recomputeBounds]!newBounds: newBounds	self bounds: newBounds!recomputeBounds	bounds _ submorphs first bounds.	fullBounds _ nil.	bounds _ self fullBounds! !!MorphicModel methodsFor: 'drawing'!drawOn: aCanvas	"This morph is normally invisible, but becomes visible if lying naked in the world."	self installed ifFalse:		[bounds extent = (20@20) ifFalse: [self extent: 20@20].		super drawOn: aCanvas].!fullDrawOn: aCanvas	"By removing the comment quotes below, the bounds of any MorphicModel	will appear outlined in yellow.  Remove after testing."	super fullDrawOn: aCanvas."	self installed		ifTrue: [aCanvas frameRectangle: bounds color: color]"! !!MorphicModel methodsFor: 'printing'!initString	^ String streamContents:		[:s | s nextPutAll: self class name;			nextPutAll: ' newBounds: (';			print: bounds;			nextPutAll: ') model: self slotName: ';			print: slotName]! !!MorphicModel methodsFor: 'stepping'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ 1000!stepWorld: aWorldMorph	"Do some periodic activity for the given world. The time between steps is specified by this object's answer to the stepTime message. This default implementation does nothing."! !!MorphicModel class methodsFor: 'instance creation'!newBounds: bounds model: thang slotName: nameOfThisPart	| m |	m _ super new model: thang slotName: nameOfThisPart.	m initMorph.	m newBounds: bounds.	^ m! !!MorphicModel class methodsFor: 'compilation'!chooseNewName	"Rename this class."	| oldName newName |	oldName _ self name.		[newName _ (FillInTheBlank request: 'Please give this Model a name'					initialAnswer: oldName) asSymbol.		newName = oldName ifTrue: [^ self].		Smalltalk includesKey: newName]		whileTrue:		[PopUpMenu notify: 'Sorry, that name is already in use.'].	self rename: newName.!compileAccessorsFor: varName	self compile: ('&var	"Return the value of &var"	^ &var'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&varPut: newValue	"Assign newValue to &var.	Add code below to update related graphics appropriately..."	&var _ newValue.'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&var: newValue	"Assigns newValue to &var and updates owner"	&var _ newValue.	self propagate: &var as: ''&var:'''			copyReplaceAll: '&var' with: varName)		classified: 'private - propagation' notifying: nil.!compilePropagationForVarName: varName slotName: slotName	self compile: (('&slot&var: newValue	"The value of &var in &slot has changed to newValue.	This value can be read elsewhere in code with		&slot &var	and it can be stored into with		&slot &varPut: someValue"	"Add code for appropriate response here..."'			copyReplaceAll: '&var' with: varName)			copyReplaceAll: '&slot' with: slotName)		classified: 'input events' notifying: nil.!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Morphic-Models'! !MorphicTransform comment:'This class implements a simple translation transformation for points. A subclass could be implemented to support scaling and/or rotation transformation as well.'!!MorphicTransform methodsFor: 'accessing'!offset	^ offset! !!MorphicTransform methodsFor: 'other'!composedWith: aTransform	"Return a new transform that has the effect of transforming points first by the receiver and then by the argument."	^ aTransform copy setOffset: offset + aTransform offset!inverseTransform: aPoint	"Transform the given point from local to global coordinates."	^ aPoint - offset!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ (0@0) = offset!transform: aPoint	"Transform the given point from global to local coordinates."	^ aPoint + offset! !!MorphicTransform methodsFor: 'private'!setOffset: aPoint	offset _ aPoint.! !!MorphicTransform class methodsFor: 'instance creation'!new	^ super new setOffset: 0@0!offset: aPoint	^ super new setOffset: aPoint! !!MorphicTransform class methodsFor: 'constants'!identity	^ IdentityTransform! !!MorphicTransform class methodsFor: 'class initialization'!initialize	"MorphicTransform initialize"	IdentityTransform _ self new.! !MorphWorldController comment:'I am a controller for SceneViews. I support gestures for scrolling, click-selection, and area selection of scene glyphs. (See the class comment in GestureController for more details about gestures.) I also support construction operations such as inserting new glyphs and merging glyphs to make them share a common point.The mapping of gestures to actions is as follows (see GestureController comment for more about gestures):  Click:	click on glyph				select glyph	shift-click on glyph			toggle selection of that glyph	click on background			clear selection  Double click:	double-click on glyph			inspect glyph	double-click on background		select all  Hold/Drag/Sweep:	hold (no movement)			yellow-button menu	drag (up/left movement)		scrolling hand	sweep (down/right movement)	select glyphs in region	shift-sweep					toggle selection of glyphs in region'!!MorphWorldController methodsFor: 'control sequence'!controlActivity	"Do one step of the Morphic interaction loop. Called repeatedly while window is active."	model doOneCycle.!controlInitialize	"This window is becoming active."	view displayView.  "initializes the WorldMorph's canvas"	Cursor blank show.	"don't show the hardware cursor, since hands draw themselves"!controlLoop 	"Just remove this method when done with testing."	"hold shift down when activating a Morphic window to take stats"	sensor leftShiftDown ifTrue: [		MessageTally spyOn: [super controlLoop. Cursor normal show].		^ self].	super controlLoop.!controlTerminate	"This window is becoming inactive."	model canvas: nil.  "free model's canvas to save space"	Cursor normal show.  "restore the normal cursor"!isControlActive	^ sensor redButtonPressed or: [self viewHasCursor]!isControlWanted	^ self viewHasCursor! !MorphWorldView comment:'I am a view used to display a Scene. I may be scrolled by adjusting my offset. My default controller is SceneController.SceneViews encapsulate the notion of a changing foreground and a fixed background during interactive updates. During an interaction (such as dragging), some of the glyphs will not change location or appearance. These are part of the "background". All glyphs that may change (the "foreground" glyphs) are painted against this unchanging backdrop during the interaction.Instance Variables:	offset				the current offset of this view (used for scrolling)	enclosingRect 		a rectangle large enough to contain all the objects in the scene, plus a small border (this is a cache that must be recomputed when glyphs are moved, added, or removed from the scene)	backgroundForm		a <Form> containing the fixed background	visibleForeground		the glyphs that are changing but not selected during an interaction	selectedForeground	the selected glyphs that are changing during an interaction'!!MorphWorldView methodsFor: 'all'!deEmphasizeView 	"This window is becoming inactive."	ErrorRecursion ifTrue: [		"No fancy stuff -- there's an error in progress!!"		^ self].	self topView cacheBitsAsTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		model displayWorldAsTwoTone].!defaultControllerClass	^ MorphWorldController!displayView	"This method is called by the system when the top view is framed or moved."	model viewBox: self insetDisplayBox.	self topView == ScheduledControllers scheduledControllers first view		ifTrue: [model displayWorld]		ifFalse: [model displayWorldAsTwoTone "just restoring screen"]!update: symbol	^ symbol == #newColor		ifTrue: [self topView backgroundColor: model color; uncacheBits; display]		ifFalse: [super update: symbol]! !!MorphWorldView class methodsFor: 'instance creation'!openOn: aMorphWorld	"Open a view on the given WorldMorph."	self openOn: aMorphWorld label: 'A Morphic World'.!openOn: aWorldMorph label: aString	"Open a view with the given label on the given WorldMorph."	| topView |	true			"*change to false to preserve full window color*"		ifTrue: [topView _ StandardSystemView new]		ifFalse: [topView _ ColorSystemView new].	topView model: nil;		label: aString;		borderWidth: 1;		addSubView: (self new initialize model: aWorldMorph);		backgroundColor: aWorldMorph color.	topView controller open.! !!MouseMenuController methodsFor: 'menu messages'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(redButtonMessages at: index)]]		ifFalse: [super controlActivity]!shiftedYellowButtonActivity	"Present the alternate (shifted) menu and take action accordingly.  1/17/96 sw.	1/25/96 sw: let #shiftedYellowButtonActivity: do the work"	| index shiftMenu |	(shiftMenu _ self shiftedYellowButtonMenu) == nil ifTrue:		[^ super controlActivity].	self shiftedYellowButtonActivity: shiftMenu!shiftedYellowButtonActivity: shiftMenu	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  1/26/96 sw"	| index  |	(index _ shiftMenu startUp) ~= 0		ifTrue:			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]		ifFalse:			[super controlActivity]!unshiftedYellowButtonActivity	"Put up the regular yellow-button menu and take action as appropriate.  1/24/96 sw"	| index  |	yellowButtonMenu ~~ nil		ifTrue: 			[index _ yellowButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver performMenuMessage:							(yellowButtonMessages at: index)]]		ifFalse:			[super controlActivity]! !MouseSensorMorph comment:'A MouseSensorMorph is a primitive MorphicModel.  It has a model.slot reference and generates mouse event messages to the model whenever they occur in the canvas area occupied by the owner of the mouseSensor.A mouseSensor can be detached from its owner.  When it is by itself in a world or being dragged by a hand, it appears as a yellow rectangle.  If it is later embedded in another morph, that morph will become sensitive, and will be connected to the model through the same slot.name protocol.'!!MouseSensorMorph methodsFor: 'initialization'!initMorph	"nothing extra to do"! !!MouseSensorMorph methodsFor: 'testing'!installed	^ (owner ~= nil) and:	 [(owner isWorldOrHandMorph not) and:	 [model ~= nil]]!isMouseSensor	^ true! !!MouseSensorMorph methodsFor: 'events'!mouseDown: evt	self installed ifFalse: [^ super mouseDown: evt].	evt hand newMouseFocus: self.  "subscribe to mouse until it goes up"	model perform: (self slotNameSelector: 'MouseDown:morph:') with: evt with: owner.!mouseMove: evt	model perform: (self slotNameSelector: 'MouseMove:morph:') with: evt with: owner.!mouseUp: evt	model perform: (self slotNameSelector: 'MouseUp:morph:') with: evt with: owner.! !!MouseSensorMorph methodsFor: 'geometry'!bounds	self installed		ifTrue: [^ owner bounds]  "use owner's bounds"		ifFalse: [^ super bounds].  "use my own bounds"!containsPoint: p	self installed		ifTrue: [^ owner containsPoint: p]  "use owner's containsPoint:"		ifFalse: [^ super containsPoint: p].  "use my own containsPoint:"!fullBounds	self installed		ifTrue: [^ owner fullBounds]  "use owner's fullBounds"		ifFalse: [^ super fullBounds].  "use my own fullBounds"!mouseRecipientAt: aPoint	"When installed, the buck stops here!! This morph catches mouse events and prevents them from being passed to its submorphs."	self installed ifTrue:		[(owner containsPoint: aPoint) ifTrue: [^ self] ifFalse: [^ nil]].	^ super mouseRecipientAt: aPoint!position	self installed		ifTrue: [^ owner position]  "use owner's position"		ifFalse: [^ super position].  "use my own position"!privateMoveBy: delta	self installed		ifTrue: [bounds _ owner bounds]		ifFalse: [super privateMoveBy: delta]!recomputeBounds	bounds _ owner bounds.	fullBounds _ nil! !!MouseSensorMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: self class name , ' new model: self slotName: ' , slotName printString! !!MouseSensorMorph methodsFor: 'compilation'!compilePropagationMethods	"Remove old sels first?"	| code |	#('Down:' 'Move:' 'Up:') do:		[:msg |		code _ String streamContents: 			[:s |			s nextPutAll: (slotName , 'Mouse' , msg , ' evt morph: m').			s cr; tab; nextPutAll: '"Edit this method to add mouse-driven behavior."'.			msg = 'Move:' ifTrue:				[s cr; tab; nextPutAll: 'm position: evt targetPoint']].		model class compile: code classified: 'mouse events' notifying: nil]!slotNameSelector: msgPart	"Later cache this? -- takes about 1ms"	^ (slotName , msgPart) asSymbol! !!MovieMorph methodsFor: 'initialization'!initialize	super initialize.	color _ (Color r: 1 g: 0 b: 1).	playMode _ #stop.  "#stop, #playOnce, or #loop"	msecsPerFrame _ 200.	rotationDegrees _ 0.	frameList _ EmptyArray.	currentFrameIndex _ 1.	dwellCount _ 0.! !!MovieMorph methodsFor: 'accessing'!form	^ self currentFrame form!rotationDegrees	^ rotationDegrees!rotationDegrees: angleInDegrees	| frame |	rotationDegrees ~= angleInDegrees ifTrue: [		self changed.		rotationDegrees _ angleInDegrees.		frame _ self currentFrame.		frame ifNotNil: [frame rotationDegrees: angleInDegrees].		self layoutChanged.		self changed].! !!MovieMorph methodsFor: 'drawing'!drawOn: aCanvas	| frame |	frame _ self currentFrame.	frame ~~ nil		ifTrue: [^ frame drawOn: aCanvas]		ifFalse: [^ super drawOn: aCanvas].! !!MovieMorph methodsFor: 'geometry-testing'!containsPoint: p	| frame |	frame _ self currentFrame.	((frame ~~ nil) and: [playMode = #stop])		ifTrue: [^ frame containsPoint: p]		ifFalse: [^ super containsPoint: p].! !!MovieMorph methodsFor: 'stepping'!step	playMode = #stop ifTrue: [^ self].	dwellCount > 0 ifTrue: [		dwellCount _ dwellCount - 1.		^ self].	currentFrameIndex < frameList size		ifTrue: [^ self setFrame: currentFrameIndex + 1].	playMode = #loop		ifTrue: [self setFrame: 1]		ifFalse: [playMode _ #stop].!stepTime	^ msecsPerFrame! !!MovieMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	frameList size > 1 ifTrue: [		aCustomMenu add: 'edit drawing' action: #editDrawing.		aCustomMenu add: 'set rotation center' action: #setRotationCenter.		aCustomMenu add: 'play once' action: #playOnce.		aCustomMenu add: 'play loop' action: #playLoop.		aCustomMenu add: 'stop playing' action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			aCustomMenu add: 'previous frame' action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			aCustomMenu add: 'next frame' action: #nextFrame]].	aCustomMenu add: 'extract this frame' action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue: [		aCustomMenu add: 'insert into movie' action: #insertIntoMovie:].!editDrawing	| frame |	frame _ self currentFrame.	frame ~~ nil ifTrue: [frame editDrawingInWorld: self world].!extractFrame: evt	| f |	f _ self currentFrame.	f ifNil: [^ self].	frameList _ frameList copyWithout: f.	frameList isEmpty		ifTrue: [self position: f position]		ifFalse: [self setFrame: currentFrameIndex].	evt hand attachMorph: f.!insertIntoMovie: evt	| movies target |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	target _ movies first.	(target isKindOf: SketchMorph) ifTrue: [		target _ target replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.!nextFrame	currentFrameIndex < frameList size		ifTrue: [self setFrame: currentFrameIndex + 1].!playLoop	playMode _ #loop.!playOnce	self setFrame: 1.	playMode _ #playOnce.!previousFrame	currentFrameIndex > 1		ifTrue: [self setFrame: currentFrameIndex - 1].!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.!stopPlaying	playMode _ #stop.	self setFrame: 1.! !!MovieMorph methodsFor: 'private'!currentFrame	frameList isEmpty ifTrue: [^ nil].	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	^ frameList at: currentFrameIndex!insertFrames: newFrames	"Insert the given collection of frames into this movie just after the currentrame."	frameList isEmpty ifTrue: [		frameList _ newFrames asArray copy.		self setFrame: 1.		^ self].	frameList _		frameList			copyReplaceFrom: currentFrameIndex + 1  "insert before"			to: currentFrameIndex			with: newFrames.!setFrame: newFrameIndex	| oldFrame p newFrame |	oldFrame _ self currentFrame.	oldFrame ifNil: [^ self].	self changed.	p _ oldFrame referencePosition.	currentFrameIndex _ newFrameIndex.	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	newFrame _ frameList at: currentFrameIndex.	newFrame rotationDegrees: rotationDegrees.	newFrame referencePosition: p.	bounds _ newFrame bounds.	dwellCount _ newFrame framesToDwell.	self layoutChanged.	self changed.! !!MPaintPalette methodsFor: 'accessing'!colors	^ colors! !!MPaintPalette methodsFor: 'display'!display 	paletteBorder displayOn: Display. 	self displayColors.	self displayNibs.	self displayControlBoxes!displayColors	| currentColor currentColorBox |	currentColorBox _ paintWindow currentColorBox.	colors do: [:aColorBox |		aColorBox display.		aColorBox == currentColorBox ifTrue:			[aColorBox highlight]]!displayControlBoxes	"Draw the various buttons and custom nib boxes.  11/27/96 sw"	self okButtonForm displayAt: okayBox origin.	self cancelButtonForm displayAt: cancelBox origin.	Display fill: dragBox fillColor: Color blue.	Cursor menu displayAt: menuBox origin + (6 @ 3).	"Display fill: replaceNib fillColor: Color gray.	Display fill: eraseNib fillColor: Color blue.	Display fill: customNib fillColor: Color red."	self flag: #deferred. 	"The above three are place-holders for custom painting modes -- selective erase, selective retain, and fuzzy brushes -- or perhaps fill"	Display border: targetColorBox width: 2.	Display fill: (targetColorBox insetBy: 2@2) fillColor: paintWindow targetColor!displayNibs	|  currentNibSize currentNibRounded |	currentNibSize _ paintWindow currentNibSize.	currentNibRounded _ paintWindow currentNibRounded.	nibs do: [:aNibBox |		aNibBox display.		(aNibBox nibSize = currentNibSize and:			[aNibBox isRound = currentNibRounded]) ifTrue:			[aNibBox highlight]]! !!MPaintPalette methodsFor: 'mouse handling'!dragPaletteFrom: aPoint	"Drag the palette, given that the mouse went down at aPoint.  9/20/96 sw"	| aForm offset aLoc savedBits |	aForm _ Form fromDisplay: paletteBorder.	offset _ aPoint - paletteBorder topLeft.	"self restoreBitsBehindPalette."	savedBits _ aForm follow: [aLoc _ Sensor cursorPoint - offset]		while:	[Sensor anyButtonPressed] bitsBehind: bitsBehindPalette startingLoc: paletteBorder topLeft.	bitsBehindPalette _ savedBits.	self setNewOrigin: aLoc; display	!mouseDownAt: aPoint	"Check to see if mouse is down in the palette.  Return		true if mouse was down and we should continue.		false if mouse was NOT down in the palette.		#okay if user clicked in okay box.		#cancel if user clicked in cancel box"	| aBox newColor |	(paletteBorder containsPoint: aPoint) ifFalse: [^ false].	((dragBox containsPoint: aPoint) or:			[(paletteRect containsPoint: aPoint) not])		ifTrue:			[self dragPaletteFrom: aPoint.			^ true].	(menuBox containsPoint: aPoint)		ifTrue:			[self mouseDownInMenuBoxAt: aPoint.			^ true].	(targetColorBox containsPoint: aPoint) ifTrue:		[Sensor waitNoButton.		paintWindow targetColor: Color fromUser.		self display.		^ true].	(okayBox containsPoint: aPoint) ifTrue: 		[Utilities awaitMouseUpIn: okayBox repeating: [] ifSucceed: 					[^ #okay].		^ true].	(cancelBox containsPoint: aPoint) ifTrue: 		[Utilities awaitMouseUpIn: cancelBox repeating: [] ifSucceed: 					[^ #cancel].		^ true].	(aBox _ colors detect: [:aPaintBox | aPaintBox rectangle containsPoint: aPoint] ifNone: [nil]) == nil		ifFalse:			[aBox == paintWindow currentColorBox				ifTrue:					["lazy double-click: rearm the palette"					Sensor waitNoButton.					aBox color: (newColor _ Color fromUser); display.					paintWindow currentColorBox: aBox.					paintWindow currentColor: newColor.					^ true].			paintWindow currentColorBox unHighlight.			paintWindow currentColorBox: aBox.			paintWindow currentColor: aBox color.			aBox highlight]		ifTrue:			[(aBox _ nibs detect: [:aNibBox | aNibBox rectangle containsPoint: aPoint] ifNone: [nil]) == nil				ifFalse:					[self currentNibBox unHighlight.					paintWindow currentNibSize: aBox nibSize round: aBox isRound.					self currentNibBox highlight]].	Sensor waitNoButton.	^ true!mouseDownInMenuBoxAt: aPoint	| aMenu reply |	aMenu _ SelectionMenu labels:'area fillreset palette colorscustom nib...'	lines: #()	selections: #("selectiveErase selectiveRetain" areaFill restoreStandardPaletteColors setCustomNib).	reply _ aMenu startUp.	reply ifNil: [^ self].	paintWindow perform: reply.	false ifTrue:   "This just for the help of Senders feature"		[self selectiveErase; selectiveRetain; areaFill; restoreStandardPaletteColors; setCustomNib].! !!MPaintPalette methodsFor: 'appearance constants'!boxCursor	^ Cursor		extent: 16@16		fromArray: #(			2r1111111111111111			2r1111111111111111			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1100000000000011			2r1111111111111111			2r1111111111111111)		offset: 0@0!cancelButtonForm	^ Form		extent: 71@23		fromArray: #(0 0 0 0 0 0 134217727 4294967295 3221225472 402653184 0 805306368 268435456 0 268435456 536870912 0 134217728 536870912 0 134217728 536932352 768 134217728 536971264 768 134217728 536969457 4041335552 134217728 536969497 2576560896 134217728 536969465 2575512320 134217728 536969625 2575561472 134217728 536969625 2575500032 134217728 536971673 2576552704 134217728 536932601 2564940544 134217728 536870912 0 134217728 536870912 0 134217728 536870912 0 134217728 268435456 0 268435456 402653184 0 805306368 134217727 4294967295 3221225472 0 0 0)		offset: 0@0!maxVerticalNibDelta	^ 36!minVerticalNibDelta	^ 8!nibChipWidth	^ 5!okButtonForm	^ Form		extent: 80@29		fromArray: #(0 0 0 16777215 4294967295 4286578688 67108863 4294967295 4292870144 134217727 4294967295 4293918720 260046848 0 16252928 239075327 4294967295 4265082880 515899392 0 29097984 478150656 0 10223616 486539264 0 6029312 486539264 0 6029312 486539264 1013121024 6029312 486539264 1717960704 6029312 486539264 1718353920 6029312 486539264 1719140352 6029312 486539264 1718616064 6029312 486539264 1719140352 6029312 486539264 1718353920 6029312 486539264 1717960704 6029312 486539264 1013121024 6029312 486539264 0 6029312 486539264 0 6029312 486539264 0 6029312 478150656 0 10223616 515899392 0 29097984 239075327 4294967295 4265082880 260046848 0 16252928 134217727 4294967295 4293918720 67108863 4294967295 4292870144 16777215 4294967295 4286578688)		offset: 0@0!paintChipWidth	^ 10!standardColors	^ (Color names copyWithout: #veryDarkGray) collect:		[:s | Color perform: s]!standardNibWidths	"As specified by Alan Kay, 8/96"	^ #(1 2 3 4 8 15 22 30)! !!MPaintPalette methodsFor: 'private'!currentNibBox	|  currentNibSize currentlyRounded |	currentlyRounded _ paintWindow currentNibRounded.	currentNibSize _ paintWindow currentNibSize.	^ nibs detect: [:aNibBox | aNibBox nibSize = currentNibSize and: [aNibBox isRound == currentlyRounded]] ifNone: [nil]!currentPaintPotColors	SavedColors ifNil: [SavedColors _ self standardColors].	^ SavedColors!exitFormalities	self restoreBitsBehindPalette.	self preservePaintPotChoices.!initializeVerticalFrom: aPaintWindow	"Initialize the palette, laying out its contents in a vertically-organized ('portrait') rectangle.  11/26/96 sw	 12/4/96 sw: code to initialize three custom nib boxes is here, though a small mod will be needed to make space for them -- two comments in the code below pertain"	| aRect aBox displayBB lrRect index aColor colorsPerRow count delta paletteOrigin bRect |	paintWindow _ aPaintWindow.	colorsPerRow _ 5.	colors _ OrderedCollection new.	nibs _ OrderedCollection new.	paletteOrigin _ self paletteOrigin.	aRect _ (paletteOrigin + (12 @ 22)) extent: 10@10.	(1 to: ((count _ self currentPaintPotColors size) + (colorsPerRow - 1)) // colorsPerRow) do:		[:row |			lrRect _ aRect deepCopy.			1 to: colorsPerRow do:				[:column |					index _ (colorsPerRow * (row - 1)) + column.					index <= count ifTrue:						[aColor _ self currentPaintPotColors at: index.						aBox _ MPaintPaletteColor new color:  aColor rectangle: lrRect.						colors add: aBox..						lrRect _ lrRect deepCopy moveBy: ((self paintChipWidth + 6) @ 0)]].				aRect _ aRect deepCopy moveBy: (0 @ (self paintChipWidth + 6))].				aRect _ aRect deepCopy moveBy: (8 @ 6).	self standardNibWidths do:		[:i |			aBox _ MPaintPaletteNib new color: Color darkGray nibSize: i rectangle: aRect rounded: false.			nibs add: aBox.			lrRect _ aRect deepCopy moveBy: (45 @ 0).			aBox _ MPaintPaletteNib new color: Color darkGray nibSize: i rectangle: lrRect rounded: true.			nibs add: aBox.			delta _ (((self nibChipWidth + (2 * i))) min: self maxVerticalNibDelta) max: self minVerticalNibDelta.			i == 15 ifTrue: [delta _ delta - 5].  "a little FUDGE here"			aRect _ aRect deepCopy moveBy: (0 @ delta)]. 	nibs do: [:aNib | aNib adjustBoxToMatchNibSize].	bRect _ aRect translateBy: (0 @ 10).  		"Use 0@50 later to reinstate use of custom nib boxes"	self flag: #deferred.	okayBox _ ((paletteOrigin x + 6) @ (bRect bottom + 10)) extent: self okButtonForm extent.	cancelBox _ (okayBox bottomLeft + (4 @ 4)) extent: self cancelButtonForm extent.	paletteRect _ (paletteOrigin + (4@4)) corner: (cancelBox corner + (8@8)).	paletteBorder _ Quadrangle region: (paletteOrigin corner: (paletteRect corner + (4@4))) borderWidth: 4 borderColor: Color blue insideColor: Color white.	dragBox _ paletteRect deepCopy extent: paletteRect extent x @ 6.	menuBox _ okayBox origin + (6 @ -30) extent: (34 @ 20).	targetColorBox _ menuBox origin + (40 @ 0) extent: (30 @ 20).	"The following three are maintained but not yet used; to incoprporate them, look above under the #deferred flag -- after that change and one to #displayControlBoxes, they'll show, but then of course one has to give them behavior..."	replaceNib _ (aRect origin - (10@0)) extent: (20@20).	eraseNib _ replaceNib translateBy:  (26@0).	customNib _ replaceNib translateBy:  (52@0).		((displayBB _ Display boundingBox) contains: paletteBorder)		ifFalse:			[aBox _ paletteBorder deepCopy forcedWithin: displayBB.			self setNewOrigin: (aBox origin + (4@4))].	bitsBehindPalette _ Form fromDisplay: paletteBorder!paletteOrigin	"Answer the initial origin at which to attempt to position the palette.  8/14/96 sw"	^ paintWindow canvasRectangle topRight + (20@20)!preservePaintPotChoices	SavedColors _ colors collect: [:aColorBox | aColorBox color].!restoreBitsBehindPalette	bitsBehindPalette displayOn: Display at: paletteBorder origin.!restoreStandardPaletteColors	SavedColors _ self standardColors.	colors with: SavedColors do:		[:aPaintBox :aColor | aPaintBox color: aColor].	self display.!setNewOrigin: newOrigin	"Reposition the receiver such that its origin is at newOrigin.  8/8/96 sw	 12/4/96 sw: repositioin the custom nib boxes, though they're not yet used"	| delta |	delta _ newOrigin - paletteBorder origin.	paletteRect moveBy: delta.	paletteBorder moveBy: delta.	colors do:		[:aColor | aColor rectangle moveBy: delta].	nibs do:		[:aNib | aNib rectangle moveBy: delta].	okayBox moveBy: delta.	cancelBox moveBy: delta.	dragBox moveBy: delta.	menuBox moveBy: delta.	targetColorBox moveBy: delta.	"The following three boxes are maintained here against possible future incorporation"	eraseNib moveBy: delta.	replaceNib moveBy: delta.	customNib moveBy: delta.! !!MPaintPaletteColor methodsFor: 'accessing'!color	^ color!color: anObject	color _ anObject!rectangle	^ rectangle! !!MPaintPaletteColor methodsFor: 'display'!display	Display fill: rectangle fillColor: color.	color = Color white ifTrue:		[rectangle display: Color gray]!highlight	(rectangle insetBy: (-2 @ -2)) display: Color black!unHighlight	(rectangle insetBy: (-2 @ -2)) display: Color white! !!MPaintPaletteColor methodsFor: 'private'!color: aColor rectangle: aRectangle	color _ aColor.	rectangle _ aRectangle! !!MPaintPaletteNib methodsFor: 'accessing'!nibSize	^ nibSize!nibSize: aSize	nibSize _ aSize.!rectangle	^ rectangle!roundedNibDots	RoundedNibDots == nil ifTrue: [RoundedNibDots _ self initializeNibDots].	^ RoundedNibDots! !!MPaintPaletteNib methodsFor: 'display'!display	self isRound ifFalse:		[Display fill: self innerRect fillColor: color]	ifTrue:		[(self roundedNibDots at: nibSize) displayOn: Display at: rectangle center]!highlight	(self innerRect insetBy: (-2 @ -2)) display: Color black!innerRect	| demiNib |	demiNib _ 1 + (nibSize //2).	^ (rectangle center corner: rectangle center) insetBy: (demiNib @ demiNib) negated!isRound	^ isRounded == true!unHighlight	(self innerRect insetBy: (-2 @ -2)) display: Color white! !!MPaintPaletteNib methodsFor: 'private'!adjustBoxToMatchNibSize	nibSize > 4 ifTrue:		[rectangle _ (rectangle center corner: rectangle center) insetBy: (nibSize // 2) negated]!color: aColor nibSize: aNibSize rectangle: aRectangle rounded: roundBoolean	color _ aColor.	nibSize _ aNibSize.	rectangle _ aRectangle.	isRounded _ roundBoolean!initializeNibDots	| nibDots |	nibDots _ Dictionary new.	MPaintPalette new standardNibWidths do:		[:n | nibDots at: n put: (Form dotOfSize: n)].	^ nibDots! !!MPaintWindow methodsFor: 'public interface'!editPainting: aForm at: aPoint	"Edit the given form at the given offset within the overall canvas."	| action newBox newForm noColor |	action _ self getPaintingStartingWith: aForm at: (aPoint extent: aForm extent).	action = #cancel ifTrue: [^ nil].	noColor _ Color white pixelValueForDepth: paintingForm depth.	newBox _ paintingForm innerPixelRectFor: noColor orNot: true.	newForm _ MaskedForm form: (paintingForm copy: newBox)				transparentColor: (Color colorFromPixelValue: noColor depth: paintingForm depth).	^ Array with: newForm with: newBox!initializeFor: aRectangle	"Initialize this painter for the given screen rectangle."	canvasRectangle _ aRectangle.	self initializePalette.!newPainting	"Let the user paint from scratch."	| action newBox newForm noColor |	action _ self getPaintingStartingWith: nil at: nil.	action = #cancel ifTrue: [^ nil].	(bMin == nil or: [bMax == nil]) ifTrue: [^ nil].	noColor _ Color white pixelValueForDepth: paintingForm depth.	newBox _ paintingForm innerPixelRectFor: noColor orNot: true.	newForm _ MaskedForm form: (paintingForm copy: newBox)				transparentColor: (Color colorFromPixelValue: noColor depth: paintingForm depth).	^ Array with: newForm with: newBox! !!MPaintWindow methodsFor: 'accessing'!canvasRectangle	^ canvasRectangle!currentColor	^ currentColor!currentColor: aColor	currentColor _ aColor.	self eachPenDo: [:aPen | aPen color: currentColor]!currentColorBox	currentColorBox == nil ifTrue:		[currentColorBox _ palette colors detect: [:aColorBox | aColorBox color = currentColor] ifNone: [palette colors at: 5]].	^ currentColorBox!currentColorBox: aColorBox	currentColorBox _ aColorBox.	currentColor _ aColorBox color.	self eachPenDo: [:aPen | aPen color: currentColor]!currentNibRounded	^ currentNibRounded == true!currentNibSize	^ currentNibSize!currentNibSize: aNibSize round: aBoolean	currentNibSize _ aNibSize.	currentNibRounded _ aBoolean.	self eachPenDo:		[:aPen | aBoolean			ifTrue:				[aPen roundNib: aNibSize]			ifFalse:				[aPen defaultNib: aNibSize].		aPen color: currentColor]!targetColor	"Answer the 'target' color -- the color to be replaced or retained in the 'selective replace' and 'selective retain' painting modes.  11/19/96 sw"	targetColor == nil ifTrue: [targetColor _ Color green].	^ targetColor!targetColor: aColor	targetColor _ aColor.! !!MPaintWindow methodsFor: 'menu commands'!areaFill	"Fill the painting area entirely with the color chosen"		| interiorPoint bwForm |	Cursor crossHair showWhile:			[interiorPoint _ Sensor waitButton.	Cursor execute showWhile:		[bwForm _ paintingFormPen destForm shapeFill: self currentColor interiorPoint: interiorPoint - canvasRectangle origin.		visiblePen destForm fillShape: bwForm fillColor: self currentColor at: canvasRectangle origin]]!restoreStandardPaletteColors	palette restoreStandardPaletteColors!selectiveErase	"Let the user designate a color to erase, and a color to replace it with, then let him happily paint/erase away -- derived from a method of Dan's, 11/15/96 sw"	| depth colorMap eraseColor substColor bb p cc altColorMap visiDepth brushWidth |	brushWidth _ currentNibSize.	depth _ paintingForm depth.	"Set up a color map that leaves everything alone"	colorMap _ (Color defaultColorMapFrom: depth to: depth) copy.	visiDepth _ visiblePen destForm depth.	altColorMap _ (Color defaultColorMapFrom: visiDepth to: visiDepth) copy.	eraseColor _ self targetColor.	substColor _ self currentColor.	"Make the substitution in the color map"	colorMap at: (eraseColor pixelValueForDepth: depth)+1		put: (substColor pixelValueForDepth: depth).	altColorMap at: (eraseColor pixelValueForDepth: visiDepth)+1		put: (substColor pixelValueForDepth: visiDepth).	"Build a BitBlt with that color map."	bb _ (BitBlt toForm: paintingForm)		sourceForm: paintingForm;		combinationRule: Form over;		width: brushWidth; height: brushWidth;		colorMap: colorMap.	cc _ (BitBlt toForm: visiblePen destForm)		sourceForm: visiblePen destForm;		combinationRule: Form over;		width: brushWidth; height: brushWidth;		colorMap: altColorMap.	palette boxCursor show.	[Sensor redButtonPressed] whileFalse: [].	[Sensor redButtonPressed or: [Sensor leftShiftDown]] whileTrue:		[[Sensor redButtonPressed] whileTrue: 		[p _ Sensor cursorPoint.		bMin == nil ifTrue: [bMin _ Sensor cursorPoint].		bMax == nil ifTrue: [bMax _ Sensor cursorPoint].		bb sourceOrigin: (p - canvasRectangle origin); destOrigin: (p - canvasRectangle origin); copyBits.		cc sourceOrigin: p; destOrigin: p; copyBits]].	Cursor normal show!selectiveRetain	"Let the user designate a color to retain, and a color to replace it with, then let him happily paint/erase away -- derived from a method of Dan's, 11/15/96 sw"	|  depth colorMap saveColor substColor bb p cc brushWidth |	brushWidth _ currentNibSize.	depth _ paintingForm depth.	"Set up a color map that leaves everything alone"	colorMap _ (Color defaultColorMapFrom: depth to: depth) copy.	saveColor _ self targetColor.	substColor _ self currentColor.	"Make the substitution in the color map"	colorMap atAllPut: (substColor pixelValueForDepth: depth).	colorMap at: (saveColor pixelValueForDepth: depth) + 1		put: (saveColor pixelValueForDepth: depth).	"Build a BitBlt with that color map."	bb _ (BitBlt toForm: paintingForm)		sourceForm: paintingForm;		combinationRule: Form over;		width: brushWidth; height: brushWidth;		colorMap: colorMap.	cc _ (BitBlt toForm: visiblePen destForm)		sourceForm: visiblePen destForm;		combinationRule: Form over;		width: brushWidth; height: brushWidth;		colorMap: colorMap.	cc clipRect: canvasRectangle.	palette boxCursor show.	[Sensor redButtonPressed] whileFalse: [].	[Sensor redButtonPressed or: [Sensor leftShiftDown]] whileTrue:		[[Sensor redButtonPressed] whileTrue: 			[p _ Sensor cursorPoint.			bMin == nil ifTrue: [bMin _ Sensor cursorPoint].			bMax == nil ifTrue: [bMax _ Sensor cursorPoint].			bb sourceOrigin: (p - canvasRectangle origin); destOrigin: (p - canvasRectangle origin); copyBits.			cc sourceOrigin: p; destOrigin: p; copyBits]].	Cursor normal show!setCustomNib	"Let the user designate a custom nib to use.  11/19/96 sw, derived from code supplied 11/18/96 by di"	| selection brush interiorPoint interiorColor |	selection _ Form fromUser.	"determine color at the middle"	interiorPoint _ selection extent // 2.	interiorColor _ Color colorFromPixelValue:		(selection pixelValueAt: interiorPoint) depth: selection depth.	"make a BW  form with interior color -> black"	brush _ (selection makeBWForm: interiorColor).	"get rid of everything that's not contiguous with the center"	brush _ brush reverse findShapeAroundSeedBlock:				[:f | f pixelValueAt: interiorPoint put: 1].	"trim the result to minimum size"	brush _ brush trimToPixelValue: 1 orNot: false.	self eachPenDo: [:aPen | aPen sourceForm: brush]! !!MPaintWindow methodsFor: 'palette'!displayPalette	palette display!initializePalette	"Call only after canvasRectangle is initialized"	palette _ MPaintPalette new initializeVerticalFrom: self.! !!MPaintWindow methodsFor: 'private'!dimTheWindow	Display fill: canvasRectangle rule: 1 fillColor: 		(Bitmap with: 16rFF00FF with: 16rFF00FF00)!eachPenDo: aBlock	aBlock value: paintingFormPen.	aBlock value: visiblePen!getPaintingStartingWith: initialForm at: aRectangle	| mousePoint mouseInPalette |	paintingForm _ Form extent: canvasRectangle extent depth: Display depth.	self dimTheWindow.	initialForm ~~ nil ifTrue:		[paintingForm copy: aRectangle  from: 0@0 in: initialForm theForm rule: Form over.		Display copy: (aRectangle translateBy: canvasRectangle origin) from: 0@0 in: initialForm theForm rule: Form over].	currentColor  _ self initialColor.	currentNibSize _ self initialNibSize. 	paintingFormPen _ Pen newOnForm: paintingForm.	visiblePen _ Pen new.	visiblePen clipRect: canvasRectangle.	self eachPenDo: [:aPen | aPen defaultNib: currentNibSize.					aPen color: currentColor].	paintingFormPen defaultNib: currentNibSize.	paintingFormPen color: currentColor.	palette display.	[Sensor anyButtonPressed] whileTrue: []. "Wait until mouse is clear "	[true] whileTrue:	[Sensor redButtonPressed ifTrue:		[mouseInPalette _ palette mouseDownAt: (mousePoint _ Sensor mousePoint).		((mouseInPalette == #okay) or: [mouseInPalette == #cancel]) ifTrue:  "This is the only exit!!"			[palette exitFormalities.			^ mouseInPalette "caller will grab the painting and bounds from my inst vars"].		mouseInPalette ifFalse:			[(canvasRectangle containsPoint: mousePoint)				ifFalse:					[Sensor waitNoButton]				ifTrue:					[self layDownPaintStartingAt: mousePoint]]]]!initialColor	^ self currentColorBox color!initialNibSize	^ 4!layDownPaintStartingAt: initialMousePoint	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  mousePoint |	mousePoint _ initialMousePoint.	bMin == nil ifTrue: [bMin _ mousePoint - (currentNibSize@currentNibSize + (1@1))].	bMax == nil ifTrue: [bMax _ mousePoint + (currentNibSize@currentNibSize + (1@1))].	visiblePen place: mousePoint.	paintingFormPen place: (mousePoint - canvasRectangle origin).	[Sensor redButtonPressed] whileTrue:		[mousePoint _ Sensor mousePoint.		visiblePen goto: mousePoint.		paintingFormPen goto: mousePoint - canvasRectangle origin.		bMin _ (mousePoint - (currentNibSize@currentNibSize + (1@1))) min: bMin.		bMax _ (mousePoint + (currentNibSize@currentNibSize + (1@1))) max: bMax]! !!MPaintWindow class methodsFor: 'all'!editPainting: aForm offset: aPoint inRectangle: aRectangle	| aPaintWindow |	aPaintWindow _ MPaintWindow new initializeFor: aRectangle.	^ aPaintWindow editPainting: aForm at: aPoint!getPainting	"MPaintWindow getPainting"	^ MPaintWindow getPaintingInRectangle: Rectangle fromUser!getPaintingInRectangle: aRectangle	| aPaintWindow |	aPaintWindow _ MPaintWindow new initializeFor: aRectangle.	^ aPaintWindow newPainting! !!NetNameResolver class methodsFor: 'class initialization'!initialize	"NetNameResolver initialize"	"Resolver Status Values"	ResolverUninitialized _ 0.	"network not initialized"	ResolverReady _ 1.			"resolver idle, last request succeeded"	ResolverBusy _ 2.			"lookup in progress"	ResolverError _ 3.			"resolver idle, last request failed"! !!NetNameResolver class methodsFor: 'network addresses'!addressByte1: b1 byte2: b2 byte3: b3 byte4: b4	"Return an internet address constructed from the given four bytes."	| newAddr |	newAddr _ ByteArray new: 4.	newAddr at: 1 put: b1.	newAddr at: 2 put: b2.	newAddr at: 3 put: b3.	newAddr at: 4 put: b4.	^ newAddr!addressFromString: addressString	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."	"NetNameResolver addressFromString: '1.2.3.4'"	"NetNameResolver addressFromString: '1,2,3,4'"	"NetNameResolver addressFromString: '1 2 3 4'"	| newAddr s byte delimiter |	newAddr _ ByteArray new: 4.	s _ ReadStream on: addressString.	s skipSeparators.	1 to: 4 do: [: i |		byte _ self readDecimalByteFrom: s.		byte = nil ifTrue: [^ nil].		newAddr at: i put: byte.		i < 4 ifTrue: [			delimiter _ s next.			((delimiter = $.) or: [(delimiter = $,) or: [delimiter = $ ]])				ifFalse: [^ nil].		].	].	^ newAddr! !!NetNameResolver class methodsFor: 'lookups'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	| deadline ready success |	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfName: hostName.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primNameLookupResult]		ifFalse: [^ nil].!localAddressString	"Return a string representing the local host address as four decimal bytes delimited with decimal points."	| addr s |	addr _ self localHostAddress.	s _ WriteStream on: ''.	1 to: 3 do: [ :i | (addr at: i) printOn: s. s nextPut: $.].	(addr at: 4) printOn: s.	^ s contents!localHostAddress	"Return the local address of this host."	^ self primLocalAddress!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	| deadline ready success |	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfAddress: hostAddress.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primAddressLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'primitives'!primAbortLookup	"Abort the current lookup operation, freeing the name resolver for the next query."	<primitive: 205>	self primitiveFailed!primAddressLookupResult	"Return the host name found by the last host address lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 204>	self primitiveFailed!primLocalAddress	"Return the local address of this host."	<primitive: 206>	self primitiveFailed!primNameLookupResult	"Return the host address found by the last host name lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 202>	self primitiveFailed!primNameResolverError	"Return an integer reflecting the error status of the last network name resolver request. Zero means no error."	<primitive: 208>	self primitiveFailed!primNameResolverStatus	"Return an integer reflecting the status of the network name resolver. For a list of possible values, see the comment in the 'initialize' method of this class."	<primitive: 207>	self primitiveFailed!primStartLookupOfAddress: hostAddr	"Look up the given host address in the Domain Name Server to find its name. This call is asynchronous. To get the results, wait for it to complete or time out and then use primAddressLookupResult."	<primitive: 203>	self primitiveFailed!primStartLookupOfName: hostName	"Look up the given host name in the Domain Name Server to find its address. This call is asynchronous. To get the results, wait for it to complete or time out and then use primNameLookupResult."	<primitive: 201>	self primitiveFailed! !!NetNameResolver class methodsFor: 'private'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255."	| digitSeen value digit |	digitSeen _ false.	value _ 0.	[aStream atEnd] whileFalse: [		digit _ aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			digitSeen ifFalse: [^ nil].			^ value].		digitSeen _ true.		value _ (value * 10) + digit].	(digitSeen and: [value <= 255]) ifFalse: [^ nil].	value > 255 ifTrue: [^ nil].  "exceeds the range of a single byte integer"	^ value!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue <= deadline]] whileTrue: [		"wait for resolver to be available"		(Delay forMilliseconds: 50) wait.		status _ self primNameResolverStatus.	].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [self primAbortLookup. ^ false].!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue <= deadline]] whileTrue: [		"wait for resolver to be available"		(Delay forMilliseconds: 50) wait.		status _ self primNameResolverStatus.	].	^ status ~= ResolverBusy! !!NotifyStringHolderController methodsFor: 'menu messages'!debug	"Open a full DebuggerView."	| debuggerTemp topView |	topView _ view topView.	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"	self controlTerminate.	topView deEmphasizeView; erase.	DebuggerView openNoSuspendDebugger: debuggerTemp label: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive!proceed	"Proceed execution of the suspended process."	| debuggerTemp |	Smalltalk okayToProceedEvenIfSpaceIsLow ifFalse: [^ self].	debuggerTemp _ debugger.  debugger _ nil.  "So close wont terminate"	self controlTerminate.	debuggerTemp proceed: view superView controller.	self controlInitialize! !NullColor comment:'An instance of me is the transparent color.  My pixel value is 0 in any depth.  A NullColor is also used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits, or use an off-color black.Transparent _ NullColor r: 0 g: 0 b: 0.Color transparent'!!NullColor methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Color none'.!storeOn: aStream	aStream nextPutAll: 'Color none'.! !!NullColor methodsFor: 'conversions'!pixelWordForDepth: depth	"always 0.  3/7/97 tk"	^ 0! !!NullColor methodsFor: 'private'!setRed: r green: g blue: b	rgb _ 0! !!NullColor methodsFor: 'as yet unclassified'!= aColor	"Not equal to any real color.  3/7/97 tk"	^ self class == aColor class	"don't subclass this"!bitPatternForDepth: depth	"always 0.  3/7/97 tk"	cachedDepth _ depth.	^ cachedBitPattern _ Bitmap with: 16r0.	"everything else"!fixTransparent: theDepth	"We are already a pixelValue of 0, which is correct"	rgb _ 0.	^ self!isRealColor	^ false!pixelValueForDepth: d	"always 0.  3/7/97 tk"	^ 0! !!Number methodsFor: 'arithmetic'!/ aNumber 	"Answer the result of dividing the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'printing'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Object methodsFor: 'accessing'!isDescendedFrom: anObject	"Answer whether the receiver is, from the containment perspective, descended from anObject.  10/9/96 sw"	^ false! !!Object methodsFor: 'testing'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value!isMorph	^ false!isRealColor	^ false!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  9/27/96 sw"	^ self printString! !!Object methodsFor: 'comparing'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'copying'!clone	<primitive: 148>	self primitiveFailed! !!Object methodsFor: 'dependents access'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	dependents do: [:o | o == anObject ifTrue: [^ self]].  "anObject is already a dependent"	DependentsFields at: self put: (dependents copyWith: anObject).!breakDependents	"Remove all of the receiver's dependents."	DependentsFields removeKey: self ifAbsent: [].!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	(DependentsFields includesKey: self)		ifTrue: [^ DependentsFields at: self]		ifFalse: [^ #()].!evaluate: actionBlock wheneverChangeIn: aspectBlock	| viewerThenObject objectThenViewer |	objectThenViewer _ self.	viewerThenObject _ ObjectViewer on: objectThenViewer.	objectThenViewer become: viewerThenObject.	"--- Then ---"	objectThenViewer xxxViewedObject: viewerThenObject			evaluate: actionBlock			wheneverChangeIn: aspectBlock!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents newDependents |	dependents _ self dependents.	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [DependentsFields removeKey: self ifAbsent: []]		ifFalse: [DependentsFields at: self put: newDependents].! !!Object methodsFor: 'error handling'!confirm: queryString 	"Put up a yes/no menu with caption aString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"nil confirm: 'Are you hungry?'"	^ SelectionMenu confirm: queryString!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Unless the receiver has an error handler defined for the active process (this mechanism appears vestigal so it is probably defunct), report to the user that the receiver does not understand the argument, aMessage, as a message."	"Testing: (3 activeProcess)"	| thisProcess errorString |	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	errorString _ 'Message not understood: ', aMessage selector.	(thisProcess _ Processor activeProcess) isErrorHandled		ifTrue: [thisProcess errorHandler value: errorString value: self]		ifFalse: [DebuggerView openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!Object methodsFor: 'user interface'!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	Inspector openOn: self withEvalPane: false!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name!inspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables."	Inspector openOn: self withEvalPane: true!inspectWithLabel: aLabel	Inspector openOn: self withEvalPane: true withLabel: aLabel! !!Object methodsFor: 'flagging'!isThisEverCalled	^ self isThisEverCalled: 'Yes, this *is* called'! !!Object methodsFor: 'translation support'!cCode: codeString	"For translation only; noop when running in Smalltalk."!cCoerce: value to: cType	"Type coercion for translation only; just return the value when running in Smalltalk."	^ value!inline: inlineFlag	"For translation only; noop when running in Smalltalk."!returnTypeC: typeString	"For translation only; noop when running in Smalltalk."!sharedCodeNamed: label inCase: caseNumber	"For translation only; noop when running in Smalltalk."!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'feb97 architecture'!openingIn: aView	"The receiver is about to be opened as the model of a window, whose top view is aView.  This gives the user a chance to execute some code to accompany the opening.  7/12/96 sw"! !!Object methodsFor: 'objects from disk'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was	   generated by the objects storeDataOn: method. Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must match its corresponding storeDataOn:	   method. Also, it must send beginReference: after instantiating	   the new object but before reading any objects from aDataStream	   that might reference it.	1/8/97 tk: allow fewer inst vars, instance does reading, see SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	self class isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars _ 0.				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self!saveOnFile2	"Ask the user for a filename and save myself on a ReferenceStream file.	 Put out structure of non-HyperSqueak object.  8/19/96 tk	 9/19/96 sw: adjustments for case where HyperSqueak is not present, though this code		at present is not reached except from HyperSqueak code	1/6/97 tk: Use SmartRefStream and let it write the version and class structure."	| aFileName aStream bytes sqSupport |	aFileName _ self class name asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name?' initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	sqSupport _ Smalltalk hyperSqueakSupportClass.	sqSupport == nil ifFalse:		[sqSupport preReleaseFileOut: true].	"Force writing of sys objects"	aStream _ SmartRefStream newFileNamed: aFileName.	aStream nextPut: self.	bytes _ aStream close.	sqSupport == nil ifFalse:		[sqSupport preReleaseFileOut: false].	"normal"	Transcript cr; show: 'Successfully saved to ', aFileName, ' with length ', bytes printString.! !!Object class methodsFor: 'class initialization'!initializeOnceOnly 	"Refer to the comment in Class|initialize.  This is the initilaize message for Object class, but if called initialize, then all classes would inherit it as a class message, and clearly this is not the default desired."	self initializeDependentsFields.  "Note this will disconnect views!!"	self initializeErrorRecursion.	"Object initializeOnceOnly"! !!Object class methodsFor: 'objects from disk'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  1/8/97 tk"	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]!readDataFrom: aDataStream size: varsOnDisk	"Create an object based on the contents of aDataStream, which was	   generated by the objects storeDataOn: method. Answer it.	 This implementation reads back the instance-variables written by	   Object>>storeDataOn:.	 NOTE: This method must match its corresponding storeDataOn:	   method. Also, it must send beginReference: after instantiating	   the new object but before reading any objects from aDataStream	   that might reference it.	11/23/92 jhm: Changed to basicNew & basicNew: to match basicSize and because		we then overwrite all instance & indexed vars.	1/3/97 tk: allow fewer inst vars, and total remap for others.  Let object do it."	| anObject cntInstVars cntIndexedVars |	self halt.  "Use same method in the instance side"	cntInstVars _ self instSize.	anObject _ self isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [self error: 'Class needs to be reshaped'].				self basicNew: cntIndexedVars]		ifFalse: [self basicNew].	^ anObject readDataFrom: aDataStream size: varsOnDisk! !ObjectMemory comment:'This class describes a 32-bit direct-pointer object memory for Smalltalk.  The model is very simple in principle:  a pointer is either a SmallInteger or a 32-bit direct object pointer.SmallIntegers are tagged with a low-order bit equal to 1, and an immediate 31-bit 2s-complement signed value in the rest of the word.All object pointers point to a header, which may be followed by a number of data fields.  This object memory achieves considerable compactness by using a variable header size (the one complexity of the design).  The format of the 0th header word is as follows:	3 bits	reserved for gc (mark, old, dirty)	12 bits	object hash (for HashSets)	5 bits	compact class index	4 bits	object format	6 bits	object size in 32-bit words	2 bits	header type (0: 3-word, 1: 2-word, 2: forbidden, 3: 1-word)If a class is in the compact class table, then this is the only header information needed.  If it is not, then it will have another header word at offset -4 bytes with its class in the high 30 bits, and the header type repeated in its low 2 bits.  It the objects size is greater than 255 bytes, then it will have yet another header word at offset -8 bytes with its full word size in the high 30 bits and its header type repeated in the low two bits.The object format field provides the remaining information as given in the formatOf: method (including isPointers, isVariable, isBytes, and the low 2 size bits of byte-sized objects).This implementation includes incremental (2-generation) and full garbage collection, each with compaction and rectification of direct pointers.  It also supports a bulk-become (exchange object identity) feature that allows many objects to be becomed at once, as when all instances of a class must be grown or shrunk.'!!ObjectMemory methodsFor: 'initialization'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	| oop last |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].!adjustFieldsAndClassOf: oop by: offsetBytes	"Adjust all pointers in this object by the given offset."	| fieldAddr fieldOop classHeader newClassOop |	fieldAddr _ oop + (self lastPointerOf: oop).	[fieldAddr > oop] whileTrue: [		fieldOop _ self longAt: fieldAddr.		(self isIntegerObject: fieldOop) ifFalse: [			self longAt: fieldAddr put: (fieldOop + offsetBytes).		].		fieldAddr _ fieldAddr - 4.	].	(self headerType: oop) ~= HeaderTypeShort ifTrue: [		"adjust class header if not a compact class"		classHeader _ self longAt: (oop - 4).		newClassOop _			(classHeader bitAnd: AllButTypeMask) + offsetBytes.		self longAt: (oop - 4) put: (newClassOop bitOr: (classHeader bitAnd: TypeMask)).	].!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	checkAssertions ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	checkAssertions _ false.  "set this early to allow assertions in initialization code to use it"	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeLargeContexts _ NilContext.	freeSmallContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.! !!ObjectMemory methodsFor: 'interpreter access'!fetchByte: byteIndex ofObject: oop	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex!fetchClassOf: oop	| ccIndex |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ (((self baseHeader: oop) >> 12) bitAnd: 16r1F) - 1.	ccIndex < 0		ifTrue: [ ^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [			"look up compact class"			^ self fetchPointer: ccIndex				ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].!fetchPointer: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)!fetchWord: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)!fetchWordLengthOf: objectPointer	| sz |	sz _ self sizeBitsOf: objectPointer.	^ (sz - BaseHeaderSize) >> 2!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format < 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << 17) bitAnd: 16r1FFE0000) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: 16rFC)).	header2 _ classPointer.	(header1 bitAnd: 16r1F000) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue!integerObjectOf: value	value < 0		ifTrue: [^ ((16r80000000 + value) << 1) + 1]		ifFalse: [^ (value << 1) + 1]!integerValueOf: objectPointer	"Translator produces 'objectPointer >> 1'"	((objectPointer bitAnd: 16r80000000) ~= 0)		ifTrue: ["negative"				^ ((objectPointer bitAnd: 16r7FFFFFFF) >> 1)					- 16r3FFFFFFF - 1  "Faster than -16r40000000 (a LgInt)"]		ifFalse: ["positive"				^ objectPointer >> 1]!isIntegerObject: objectPointer	^ (objectPointer bitAnd: 1) > 0!isIntegerValue: intValue	"Return true if the given value can be represented as a Smalltalk integer value."	"Details: This trick is from Tim Rowledge. Use a shift and XOR to set the sign bit if and only if the top two bits of the given value are the same, then test the sign bit. Note that the top two bits are equal for exactly those integers in the range that can be represented in 31-bits."	^ (intValue bitXor: (intValue << 1)) >= 0!nilObject  "For access from BitBlt module"	^ nilObj!popRemappableOop	"Pop and return the possibly remapped object from the remap buffer."	| oop |	oop _ remapBuffer at: remapBufferCount.	remapBufferCount _ remapBufferCount - 1.	^ oop!pushRemappableOop: oop	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."	remapBuffer at: (remapBufferCount _ remapBufferCount + 1) put: oop.!splObj: index	"Return one of the objects in the SpecialObjectsArray"	^ self fetchPointer: index ofObject: specialObjectsOop!storeByte: byteIndex ofObject: oop withValue: valueByte	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex		put: valueByte!storePointer: fieldIndex ofObject: oop withValue: valuePointer	"Note must check here for stores of young objects into old ones."	(oop < youngStart) ifTrue: [		self possibleRootStoreInto: oop value: valuePointer.	].	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valuePointer!storePointerUnchecked: fieldIndex ofObject: oop withValue: valuePointer	"Like storePointer:ofObject:withValue:, but the caller guarantees that the object being stored into is a young object or is already marked as a root."	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)			put: valuePointer!storeWord: fieldIndex ofObject: oop withValue: valueWord	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valueWord! !!ObjectMemory methodsFor: 'memory access'!checkAddress: byteAddress	"Keep this method around for debugging the C code."	byteAddress < (self startOfMemory) ifTrue: [		self error: 'bad address: negative'.	].	byteAddress >= memoryLimit ifTrue: [		self error: 'bad address: past end of heap'.	].!checkedByteAt: byteAddress	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	^ self byteAt: byteAddress!checkedByteAt: byteAddress put: byte	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	self byteAt: byteAddress put: byte.!checkedLongAt: byteAddress	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	^ self longAt: byteAddress!checkedLongAt: byteAddress put: a32BitInteger	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	self longAt: byteAddress put: a32BitInteger.! !!ObjectMemory methodsFor: 'header access'!baseHeader: oop	^ self longAt: oop!classHeader: oop	^ self longAt: oop - 4!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)         4      unused  -- may use for contexts (size = stackPointer for scanning purposes)        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF!hashBitsOf: oop	^ ((self baseHeader: oop) >> 17) bitAnd: 16rFFF!headerType: oop	^ (self longAt: oop) bitAnd: TypeMask!isBytes: oop	"Answer true if the argument contains indexable bytes. See comment in formatOf:"	"Note: Includes CompiledMethods."	^ (self formatOf: oop)  >= 8!isFreeObject: oop	^ (self headerType: oop) = HeaderTypeFree!isPointers: oop	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) <= 4!isWords: oop	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"	^ (self formatOf: oop) = 6!isWordsOrBytes: oop	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"	"Note: Excludes CompiledMethods."	| fmt |	fmt _ self formatOf: oop.	^ fmt = 6 or: [(fmt >= 8) and: [fmt <= 11]]!newObjectHash	"Answer a new 16-bit pseudo-random number for use as an identity hash."	lastHash _ 13849 + (27181 * lastHash) bitAnd: 65535.	^ lastHash!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: 16rFC) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: 16r1F000) = 0  "zero compact class field  in header word"				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].!sizeHeader: oop	^ self longAt: oop - 8!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: FreeSizeMask! !!ObjectMemory methodsFor: 'object enumeration'!accessibleObjectAfter: oop	"Return the accessible object following the given object or free chunk in the heap. Return nil when heap is exhausted."	| obj |	self inline: false.	obj _ self objectAfter: oop.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	^ nil!firstAccessibleObject	"Return the first accessible object in the heap."	| obj |	obj _ self firstObject.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	self error: 'heap is empty'!firstObject	"Return the first object or free chunk in the heap."	^ self oopFromChunk: self startOfMemory!initialInstanceOf: classPointer	"Support for instance enumeration. Return the first instance of the given class, or nilObj if it has no instances."	| thisObj thisClass |	thisObj _ self firstAccessibleObject.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj!instanceAfter: objectPointer	"Support for instance enumeration. Return the next instance of the class of the given object, or nilObj if the enumeration is complete."	| classPointer thisObj thisClass |	classPointer _ (self fetchClassOf: objectPointer).	thisObj _ self accessibleObjectAfter: objectPointer.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	self inline: true.	fmt _ self formatOf: objectPointer.	fmt < 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	self inline: true.	checkAssertions ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)!startOfMemory	"Return the start of object memory."	^ self cCode: '(int) memory'! !!ObjectMemory methodsFor: 'oop/chunk conversion'!chunkFromOop: oop	"Compute the chunk of this oop by subtracting its extra header bytes."	| extra |	extra _ self extraHeaderBytes: oop.	^ oop - extra!extraHeaderBytes: oopOrChunk	"Return the number of extra bytes used by the given object's header."	"Warning: This method should not be used during marking, when the header type bits of an object may be incorrect."	| type extra |	self inline: true.	type _ self headerType: oopOrChunk.	type > 1 ifTrue: [		extra _ 0.  "free chunk (type 2) or 1-word header (type 3); most common"	] ifFalse: [		type = 1			ifTrue: [ extra _ 4.  "2-word header (type 1)" ]			ifFalse: [ extra _ 8.  "3-word header (type 0)" ].	].	^ extra!oopFromChunk: chunk	"Compute the oop of this chunk by adding its extra header bytes."	| extra |	extra _ self extraHeaderBytes: chunk.	^ chunk + extra! !!ObjectMemory methodsFor: 'allocation'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize fill: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	end _ newObj + byteSize.	i _ newObj + 4.	[i < end] whileTrue: [		self longAt: i put: fillWord.		i _ i + 4.	].	checkAssertions ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= AllocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		lowSpaceThreshold _ 0.  "disable additional interrupts until lowSpaceThreshold is reset by image"		interruptCheckCounter _ 0.	].	(self sizeOfFree: freeBlock) < (byteSize + BaseHeaderSize) ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk!allocateOrRecycleContext: smallContextWanted	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.	smallContextWanted ifTrue: [		freeSmallContexts ~= NilContext ifTrue: [			cntxt _ freeSmallContexts.			freeSmallContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								 sizeInBytes: SmallContextSize										 fill: nilObj.		].	] ifFalse: [		freeLargeContexts ~= NilContext ifTrue: [			cntxt _ freeLargeContexts.			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize										fill: nilObj.		].	].	^ cntxt!clone: oop	"Return a shallow copy of the given object."	"Assume: Oop is a real object, not a small integer."	| extraHdrBytes bytes newChunk remappedOop fromIndex toIndex lastFrom newOop header hash |	self inline: false.	extraHdrBytes _ self extraHeaderBytes: oop.	bytes _ self sizeBitsOf: oop.	bytes _ bytes + extraHdrBytes.	"allocate space for the copy, remapping oop in case of a GC"	self pushRemappableOop: oop.	newChunk _ self allocateChunk: bytes.	remappedOop _ self popRemappableOop.	"copy old to new including all header words"	toIndex _ newChunk - 4.  "loop below uses pre-increment"	fromIndex _ (remappedOop - extraHdrBytes) - 4.	lastFrom _ fromIndex + bytes.	[fromIndex < lastFrom] whileTrue: [		self longAt: (toIndex _ toIndex + 4)			put: (self longAt: (fromIndex _ fromIndex + 4)).	].	newOop _ newChunk + extraHdrBytes.  "convert from chunk to oop"	"fix base header: compute new hash and clear Mark and Root bits"	hash _ self newObjectHash.	header _ (self longAt: newOop) bitAnd: 16r1FFFF.		"use old ccIndex, format, size, and header-type fields"	header _ header bitOr: ((hash << 17) bitAnd: 16r1FFE0000).	self longAt: newOop put: header.	^ newOop!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader ccField isMethodCntx |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		ccField _ cntxHeader bitAnd: 16r1F000.		ccField = 0 ifTrue: [			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.		] ifFalse: [			"compare ccField with compact class bits from format word of methodCntxClass"			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: 16r1F000).		].		isMethodCntx ifTrue: [			"Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: 16rFC) = SmallContextSize ifTrue: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.				freeSmallContexts _ cntxOop.				] ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self inline: false.	self incrementalGC.  "try to recover some space"	(self sizeOfFree: freeBlock) < minFree ifTrue: [		signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self sizeOfFree: freeBlock) < (minFree + 15000) ifTrue: [ ^ false ].  "still not enough"	].	^ true!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self sizeOfFree: freeBlock) >= minFree ifTrue: [		^ true.	] ifFalse: [		^ self sufficientSpaceAfterGC: minFree.	].! !!ObjectMemory methodsFor: 'garbage collection'!beRootIfOld: oop	"Record that the given oop in the old object area may point to an object in the young area."	| header |	self inline: false.	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue: [		"oop is in the old object area"		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].!clearRootsTable	"Clear the root bits of the current roots, then empty the roots table."	"Caution: This should only be done when the young object space is empty."	| oop |	"reset the roots table (after this, all objects are old so there are no roots)"	1 to: rootTableCount do: [ :i |		"clear root bits of current root table entries"		oop _ rootTable at: i.		self longAt: oop put: ((self longAt: oop) bitAnd: AllButRootBit).		rootTable at: i put: 0.	].	rootTableCount _ 0.!fullCompaction	"Move all accessible objects down to leave one big free chunk at the end of memory."	"Assume: Incremental GC has just been done to maximimize forwarding table space."	"need not move objects below the first free chunk"	compStart _ self lowestFreeAfter: (self startOfMemory).	compStart = freeBlock ifTrue: [		"memory is already compact; only free chunk is at the end"		^ self initializeMemoryFirstFree: freeBlock	].	"work up through memory until all free space is at the end"	[compStart < freeBlock] whileTrue: [		"free chunk returned by incCompBody becomes start of next compaction"		compStart _ self incCompBody.  "bubble of free space moves up each time"	].!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	self inline: false.	self clearRootsTable.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	self sweepPhase.	self fullCompaction.	allocationCount _ 0.	youngStart _ freeBlock.  "reset the young object boundary"	self postGCAction.!incrementalCompaction	"Move objects down to make one big free chunk. Compact the last N objects (where N = number of forwarding table entries) of the young object area."	"Assume: compStart was set during the sweep phase"	compStart = freeBlock ifTrue: [		"Note: If compStart = freeBlock then either the young space is already compact		 or there are enough forwarding table entries to do a one-pass incr. compaction."		self initializeMemoryFirstFree: freeBlock.	] ifFalse: [		self incCompBody.	].!incrementalGC	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."	| survivorCount |	self inline: false.	rootTableCount >= RootTableSize ifTrue: [		"root table overflow; cannot do an incremental GC (this should be very rare)"		^ self fullGC	].	"incremental GC and compaction"	self markPhase.	survivorCount _ self sweepPhase.	self incrementalCompaction.	allocationCount _ 0.	survivorCount > 2000 ifTrue: [		"move up the young space boundary if there are too many survivors;		 this limits the number of objects that must be processed on future		 incremental GC's"		self clearRootsTable.		youngStart _ freeBlock.  "reset the young object boundary"	].	self postGCAction.!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.!possibleRootStoreInto: oop value: valueObj	"Called when storing the given value object into the given old object. If valueObj is young, record the fact that oldObj is now a root for incremental garbage collection."	"Warning: No young objects should be recorded as roots."	| header |	self inline: false.	((valueObj >= youngStart) and:	 [(self isIntegerObject: valueObj) not]) ifTrue: [		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!aComment	"The mark phase is based on a pointer reversing traversal. This is a little tricky because the class, which is needed by the traversal, may be in either the header (as a compact class index) or in the word above the header. See memo 'Revised object format'.	Compact classes are marked and traced separately.	How do you know that you are returning from having marked a class? Parent pointer has 10 in low bits.Here are the states an object may be in, followed by what to do next in brackets []:  Start Object: parentField is set, [obj _ child]:	obj is pointed at by a field in parent that is being traced now. obj is marked.		[(parent goes up to the next field) field addr _ obj. go to Upward]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has no pointers.		[put 10 into low bits of header. field addr _ obj. go to Start Field (to process class word)]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has pointers.		[put 10 into low bits of header. point to last field. go to Start Field]  Start Field: 	Field ends in 10. It is the header. Short Class is not 0.		[Set low bits to correct value. (have parent pointer) go to Upward]	Field ends in 10. It is the header. Short Class is 0.		[child _ word above header. low bits of child _ 01. class word _ parentField. parentField _ loc of class word. go to Start Obj]	Field is Integer.		[point one word up, go to Start Field]	Field is oop.		[child _ field. field _ parentField. parentField _ loc of field. go to Start Obj]  Upward [restore low bits of header (at field addr)]:	parentField is 3. (bits 11, int 1).		[done!!]	parentField ends in 00.		[child _ field addr. field addr _ parentField. parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr - 4. go to Start Field]	parentField ends in 01. Were tracing the class.		[child _ field addr. field addr _ parentField (loc of class word). parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr + 4 (header). go to Upward]"!markAndTrace: oop	"Mark all objects reachable from the given one. Trace from the given object even if it is old or already marked. Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action |	"record tracing status in object's header"	header _ self longAt: oop.	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField _ GCTopMarker.	child _ oop.	lastFieldOffset _ self lastPointerOf: oop.	field _ oop + lastFieldOffset.	action _ StartField.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		action = StartField	ifTrue: [ action _ self startField ].		action = StartObj		ifTrue: [ action _ self startObj ].		action = Upward		ifTrue: [ action _ self upward ].	].!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeSmallContexts _ NilContext.	freeLargeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: 16r1F000) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		lastFieldOffset _ self lastPointerOf: oop.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [			"object is not marked; free it"			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	^ survivors!upward	"Return from marking an object below. Incoming:		field = oop we just worked on, needs to be put away		parentField = where to put it in our object	NOTE: Type field of object below has already been restored!!!!!!"	| type header |	(parentField bitAnd: 1) = 1 ifTrue: [		parentField = GCTopMarker ifTrue: [			"top of the chain"			header _ (self longAt: field) bitAnd: AllButTypeMask.			type _ self rightType: header.			self longAt: field put: header + type.  "install type on class oop"			^ Done		] ifFalse: [			"was working on the extended class word"			child _ field.	"oop of class"			field _ parentField - 1.  "class word, ** clear the low bit **"			parentField _ self longAt: field.			header _ self longAt: field+4.  "base header word"			type _ self rightType: header.			self longAt: field put: child + type.  "install type on class oop"			field _ field + 4.  "point at header"			"restore type bits"			header _ header bitAnd: AllButTypeMask.			self longAt: field put: (header + type).			^ Upward		].	] ifFalse: [		"normal"		child _ field.  "who we worked on below"		field _ parentField.  "where to put it"		parentField _ self longAt: field.		self longAt: field put: child.		field _ field - 4.  "point at header"		^ StartField	].! !!ObjectMemory methodsFor: 'gc -- compaction'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].!fwdBlockGet	"Return the address of a two-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + 8.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"!fwdBlockValidate: addr	"Raise an error if the given address is not a valid forward table entry."	(( addr > endOfMemory) and:	 [(addr <= fwdTableNext) and:	 [(addr bitAnd: 3) = 0]])		ifFalse: [ self error: 'invalid fwd table entry' ].!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	fwdTableNext _ endOfMemory + BaseHeaderSize.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	self inline: false.	"reserve memory for forwarding table"	self fwdTableInit.	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet.			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	checkAssertions ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk!initForwardBlock: fwdBlock mapping: oop to: newOop	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	checkAssertions ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	self longAt: oop put: (fwdBlock bitOr: (MarkBit bitOr: originalHeaderType)).!isObjectForwarded: oop	"Return true if the given object has a forwarding table entry during a compaction or become operation."	^ (oop bitAnd: 1) = 0 "(isIntegerObject: oop) not" and:	   [ ((self longAt: oop) bitAnd: MarkBit) ~= 0 ]!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| oop |	self inline: false.	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]		ifFalse: [ sz _ realHeader bitAnd: 16rFC ].	^ self oopFromChunk: (oop + sz)!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	self inline: false.	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ (self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ (self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become'!allYoung: array1 and: array2	"Return true if all the oops in both arrays, and the arrays themselves, are in the young object space."	| fieldOffset |	array1 < youngStart ifTrue: [ ^ false ].	array2 < youngStart ifTrue: [ ^ false ].	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self longAt: array1 + fieldOffset) < youngStart ifTrue: [ ^ false ].		(self longAt: array2 + fieldOffset) < youngStart ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true!become: array1 with: array2	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2) ifFalse: [		^ false  "fail; not enough space for forwarding table"	].	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	self restoreHeadersAfterBecoming: array1 with: array2.	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"!containOnlyOops: array1 and: array2	"Return true if neither array contains a small integer. You can't become: integers!!"	| fieldOffset |	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self isIntegerObject: (self longAt: array1 + fieldOffset)) ifTrue: [ ^ false ].		(self isIntegerObject: (self longAt: array2 + fieldOffset)) ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true!exchangeHashBits: oop1 with: oop2	| hdr1 hdr2 |	hdr1 _ self longAt: oop1.	hdr2 _ self longAt: oop2.	self longAt: oop1 put:		((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).	self longAt: oop2 put:		((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).!prepareForwardingTableForBecoming: array1 with: array2	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock |	entriesNeeded _ 2 * ((self lastPointerOf: array1) // 4).  "need enough entries for both directions"	entriesAvailable _ self fwdTableInit.	entriesAvailable < entriesNeeded ifTrue: [		self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false	].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop2 to: oop1.		fieldOffset _ fieldOffset - 4.	].	^ true!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ fwdHeader bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"!restoreHeadersAfterBecoming: list1 with: list2	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."	| fieldOffset oop1 oop2 |	fieldOffset _ self lastPointerOf: list1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: list1 + fieldOffset.		oop2 _ self longAt: list2 + fieldOffset.		self restoreHeaderOf: oop1.		self restoreHeaderOf: oop2.		self exchangeHashBits: oop1 with: oop2.		fieldOffset _ fieldOffset - 4.	].! !!ObjectMemory class methodsFor: 'initialization'!initialize	"ObjectMemory initialize"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	AllocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 1000.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"mask for a free chunk size"	FreeSizeMask _ 16r1FFFFFFC.	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.! !!ObjectMemory class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'memory'		declareC: 'unsigned char *memory'.	aCCodeGenerator var: 'remapBuffer'		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.	aCCodeGenerator var: 'rootTable'		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.! !ObjectTracer class comment:'An ObjectTracer can be wrapped around another object, and then give you a chance to inspect it whenever it receives messages from the outside.  For instance...	(ObjectTracer on: Display) flash: (50@50 extent: 50@50)will give control to a debugger just before the message flash is sent.Obviously this facility can be embellished in many useful ways.See also the even more perverse subclass, ObjectViewer, and its example.'!!ObjectTracer methodsFor: 'very few messages'!doesNotUnderstand: aMessage 	"All external messages (those not caused by the re-send) get trapped here"	"Present a dubugger before proceeding to re-send the message"	DebuggerView openContext: thisContext				label: 'About to perform: ', aMessage selector				contents: thisContext shortStack.	^ aMessage sentTo: tracedObject.!xxxUnTrace	tracedObject become: self!xxxViewedObject	"This message name must not clash with any other (natch)."	^ tracedObject!xxxViewedObject: anObject	"This message name must not clash with any other (natch)."	tracedObject _ anObject! !!ObjectTracer class methodsFor: 'instance creation'!on: anObject	^ self new xxxViewedObject: anObject! !ObjectViewer class comment:'ObjectViewers offers the same kind of interception of messages (via doesnotUnderstand:) as ObjectTracers, but instead of just being wrappers, they actually replace the object being viewed.  This makes them a lot more dangerous to use, but one can do amazing things.  For instance, the example below actually intercepts the InputSensor object, and prints the mouse coordinates asynchronously, every time they change:	Sensor evaluate: [Sensor cursorPoint printString displayAt: 0@0]		wheneverChangeIn: [Sensor cursorPoint].To exit from this example, execute:	Sensor xxxUnTrace'!!ObjectViewer methodsFor: 'very few messages'!doesNotUnderstand: aMessage 	"Check for change after sending aMessage"	| returnValue newValue |	recursionFlag ifTrue: [^ aMessage sentTo: tracedObject].	recursionFlag _ true.	returnValue _ aMessage sentTo: tracedObject.	newValue _ valueBlock value.	newValue = lastValue ifFalse:		[changeBlock value.		lastValue _ newValue].	recursionFlag _ false.	^ returnValue!xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2	"This message name must not clash with any other (natch)."	tracedObject _ viewedObject.	valueBlock _ block2.	changeBlock _ block1.	recursionFlag _ false! !!ObjectViewer class methodsFor: 'instance creation'!on: viewedObject evaluate: block1 wheneverChangeIn: block2	^ self new xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2! !!OrderedCollection methodsFor: 'accessing'!inspect	"Open an OrderedCollectionInspector on the receiver.	Use basicInspect to get a normal type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!OrderedCollection methodsFor: 'copying'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection _ self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection add: (self at: index)].	^ targetCollection!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta _ 0.	startIndex _ start.	stopIndex _ stop.	start < 1		ifTrue: [startIndex _ stopIndex _ 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex _ stopIndex _ self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta _ stopIndex - startIndex + 1]].	newOrderedCollection _ 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any elements equal	to oldElement."	| newCollection |	newCollection _ self species new: self size.	self do: [:each | oldElement = each ifFalse: [newCollection add: each]].	^newCollection!reversed	"Answer a copy of the receiver with element order reversed.  1/26/96 sw"	| newCol |	newCol _ self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'enumerating'!collectWithIndex: aBlock 	"Just like collect: except that an index is supplied along with the object	in the collection.  Be sure to use a block that expects two arguments.  1/30/97 tk		(#(2 4 6 8 10) asOrderedCollection) 			collectWithIndex: [:each :index | each - index].   "	| aStream index length |	aStream _ WriteStream on: (Array new: self size).	index _ 0.	length _ self size.	[(index _ index + 1) <= length]		whileTrue: [aStream nextPut: (aBlock value: (self at: index) value: index)].	^aStream contents asOrderedCollection! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast _ self size.	array size - self size = 0 ifTrue: [self grow].	(delta _ firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex _ 1.	lastIndex _ newLast! !!PackingMorph methodsFor: 'accessing'!openToDragNDrop	^ openToDragNDrop!openToDragNDrop: aBoolean	openToDragNDrop _ aBoolean.!parts	"Return an array of part names for use in e-toys."	^ #(position pointer valueAtPointer)!pointer		^ pointer!pointer: aNumber	"Set the pointer to the given number, modulo the number of items I contain. Fractional pointer values are allowed."	| truncP |	pointer ~= aNumber ifTrue:  [		pointer _ aNumber.		truncP _ aNumber truncated.		truncP > submorphs size ifTrue: [pointer _ 1 "submorphs size"].		truncP < 0 ifTrue: [pointer _ 1].		self changed].!pointerAtEnd	^ pointer truncated >= submorphs size!pointerColor	^ pointerColor!pointerColor: aColor	pointerColor _ aColor.!valueAtPointer	submorphs isEmpty ifTrue: [^ 0].	^ submorphs at: ((pointer truncated max: 1) min: submorphs size)!valueAtPointer: aValue	"Ignored for now. To implement this, we need a way to turn arbitrary Smalltalk objects into Morphs."! !!PackingMorph methodsFor: 'drawing'!drawOn: aCanvas	"Draw a border around the item pointed to by the pointer."	super drawOn: aCanvas.	submorphs size > 0 ifTrue: [		aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PackingMorph methodsFor: 'geometry'!fullBounds	"This is the hook that triggers lazy re-layout. See the comment in LayoutMorph."	fullBounds ifNil: [		self fixLayout.		"compute fullBounds before calling changed to avoid infinite recursion!!"		super fullBounds.  "updates cache"		self changed].	^ super fullBounds! !!PackingMorph methodsFor: 'dropping/grabbing'!acceptDroppingMorph: aMorph event: evt	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	self changed.	self layoutChanged.!allowSubmorphExtraction	^ openToDragNDrop!wantsDroppedMorph: aMorph event: evt	^ openToDragNDrop! !!PackingMorph methodsFor: 'private'!fixLayout	"Pack my submorphs into rows that fit within my width."	| nextY i morphsForThisRow |	nextY _ bounds top + borderWidth.	i _ 1.	[i <= submorphs size] whileTrue: [		morphsForThisRow _ self rowMorphsStartingAt: i.		nextY _ self layoutRow: morphsForThisRow lastRowBase: nextY.		i _ i + morphsForThisRow size].!insertionIndexFor: aMorph	"Find the right place to put the given dropped morph."	"Not yet finished!!"	| mCenter |	mCenter _ aMorph fullBounds center.	submorphs doWithIndex: [:m :i |		mCenter y < m fullBounds center y ifTrue: [^ i]].	^ submorphs size + 1!layoutRow: mList lastRowBase: lastRowBase	| maxH rowBase nextX |	maxH _ 0.	mList do: [:m | maxH _ maxH max: m fullBounds height].	rowBase _ lastRowBase + maxH + padding.	nextX _ bounds left + borderWidth + padding.	mList do: [:m |		m position: nextX @ (rowBase - m fullBounds height).		nextX _ nextX + m fullBounds width + padding].	^ rowBase!rowMorphsStartingAt: startIndex	"Return a collection of morphs for a row starting at the given index. Put at least one morph into the row, even if it sticks out."	| mList nextX lastIndex m |	mList _ OrderedCollection new.	nextX _ bounds left + borderWidth + padding.	lastIndex _ submorphs size.	startIndex to: lastIndex do: [:i |		m _ submorphs at: i.		nextX _ nextX + m fullBounds width + padding.		nextX > bounds right ifTrue: [			mList isEmpty ifTrue: [mList add: m].			^ mList].		mList add: m].	^ mList!selectedRect	"Return a rectangle enclosing the morph at the current pointer. Note that the pointer may be a float and may be out of range, so pick the nearest morph. Assume there is at least one submorph."	| p |	p _ pointer asInteger.	p > submorphs size ifTrue: [p _ submorphs size].	p < 1 ifTrue: [p _ 1].	^ (submorphs at: p) fullBounds expandBy: 2.! !!PackingMorph methodsFor: 'all'!initialize	super initialize.	pointer := 1.	padding _ 3.	openToDragNDrop _ false.	color _ Color r: 0.8 g: 1.0 b: 0.6.	self borderWidth: 1.! !!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle height: textStyle lineGrid * 8196.	"max Vector length"	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor.			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'selecting'!clickAt: clickPoint for: model 	"Give sensitive text a chance to fire"	"NOTE: Should highight on mouseDown, then abort if drag, else act on mouseUp.	This will require first asking, eg, wantToActOnClick, and then using	Utilities awaitMouseUpIn: box, where box is determined by range of attribute."	| startBlock action |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | (att actOnClickFor: model) ifTrue: [action _ true]].	^ action!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ CaretForm  "Use a caret to indicate null selection"				displayOn: destinationForm at: characterBlock1 topLeft + (0 @ baseline)				clippingBox: clippingRectangle				rule: (Display depth>8 ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle _ 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'converting'!asForm	"Answer a Form made up of the bits that represent the receiver's 	displayable text."	| theForm |	((foreColor == nil or: [foreColor = Color black])		and: [backColor == nil or: [backColor = Color white]])		ifTrue: [theForm _ Form extent: compositionRectangle extent]		ifFalse: [theForm _ TwoToneForm extent: compositionRectangle extent.				theForm foregroundColor: (foreColor == nil ifTrue: [Color black]															ifFalse: [foreColor])						backgroundColor: (backColor == nil ifTrue: [Color white]															ifFalse: [backColor])].	self displayOn: theForm		at: 0 @ 0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	theForm offset: offset.	^ theForm! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	rule _ DefaultRule.	mask _ nil.		"was DefaultMask 9/30/96 tk"	marginTabsLevel _ 0.	destinationForm _ Display.	offset _ aPoint.	^self composeAll!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]!leftMarginForDisplayForLine: lineIndex 	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad _ (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad _ 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	textStyle alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	textStyle alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y _ compositionRectangle top.	1 to: lastLine do:		[:i | line _ lines at: i.		(y _ y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded _ Rectangle origin: 0 @ 0 extent: 10000@10000.	compositionWidth _ self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle width: compositionWidth.	clippingRectangle _ compositionRectangle copy.	shrink _ unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y _ y + (otherLines at: i) lineHeight].	^ y!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle height:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph class methodsFor: 'examples'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. 9/30/96 tk"	| para point |	point _ Sensor waitButton.	para _ 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !!ParagraphEditor methodsFor: 'scrolling'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'sensor access'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	| previousStartBlock previousStopBlock selectionBlocks tempBlock clickPoint oldDelta oldInterval |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: nil) ifTrue: [^ self].	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	previousStartBlock _ startBlock.	previousStopBlock _ stopBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionAt: startBlock endBlock: stopBlock.			self closeTypeIn].	selectionShowing _ true.	startBlock _ selectionBlocks at: 1.	stopBlock _ selectionBlocks at: 2.	startBlock > stopBlock		ifTrue: 			[tempBlock _ startBlock.			startBlock _ stopBlock.			stopBlock _ tempBlock].	(startBlock = stopBlock 		and: [previousStartBlock = startBlock and: [previousStopBlock = stopBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'menu messages'!changeStyle	"Let user change styles for the current text pane  8/20/96 tk	 Moved from experimentalCommand to its own method  8/20/96 sw"	| aList reply style |	aList _ (TextConstants select: [:thang | thang isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[style _ TextConstants at: reply ifAbsent: [self beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"		self display.		"paragraph changed"].	^ true!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ Smalltalk clipboardText.	(s isEmpty or: [s = CurrentSelection string])		ifTrue: [^ CurrentSelection]		ifFalse: [^ s asText]!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil.	1/15/96 sw: put here intact from BrowserCodeController.  But there's too many things that still don't work, as the explain code was very tightly bound with properties of code browsers.  So for the moment, in the interest of system integrity, we don't permit.  2/5/96 sw"	| string tiVars cgVars selectors delimitors numbers sorry reply newLine |	true ifTrue:		[self flag: #noteToTed.   "Feel like taking this on?  Plenty of things make sense to explain in any text window, but my efforts to elevate the explain facility to more generic use ran out of steam before success."		^ self inform: 'Sorry, explain is currently availableonly in code panes.  Someday, it may be availablein any text pane.  Maybe.'].	newLine _ String with: Character cr.	Cursor execute		showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.			sorry _ sorry , (model isUnlocked							ifTrue: ['"']							ifFalse: ['  Also, please cancel or accept."']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: 					[string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are 					all  					letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: [])						~~ nil						ifFalse: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model class == Browser])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , newLine].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:symbol | symbol])						ifTrue: 							[cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: 									[cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , newLine].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , newLine].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]!explainGlobal: symbol 	"Is symbol a global variable?	 1/15/96 sw: copied intact from BrowserCodeController"	| reply classes newLine |	self flag: #noteToTed.  "a fumbling piece of the generic-explain attempt."	newLine _ String with: Character cr.	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', newLine, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	reply class == Dictionary		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	startBlock = stopBlock ifTrue: [view flash.  ^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string!specialMenuItems	"Refer to comment under #presentSpecialMenu.  4/29/96 sw.	 9/27/96 sw: added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'editing keys'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept 	characters with the change in emphasis. Emphasis change amounts to a 	font change.  Keeps typeahead."	| keyCode attribute oldAttributes index |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[index _ (PopUpMenu labelArray: #(black magenta red yellow green blue active)							lines: #(6)) startUp.		index = 0 ifTrue: [^ true].		attribute _ index = 7		ifTrue: [TextAction evalString: self selection asString]		ifFalse: [TextColor color: (Color perform: (#(black magenta red yellow green blue cyan) at: index))]].	(keyCode between: 7 and: 11) ifTrue:		[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).		oldAttributes do:			[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray:					oldAttributes.			^ true].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  5/27/96 sw	Use only names of Fonts of this paragraph  8/19/96 tk"	| aList reply |	aList _ paragraph textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] !swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  1/18/96 sw"	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size == 0		ifTrue:			[currentSelection _ startBlock stringIndex]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection _ startBlock stringIndex + 1]].	self selectFrom: currentSelection - 1 to: currentSelection.	aString _ self selection string.	self replaceSelectionWith: (Text fromString: aString reversed).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ stopBlock stringIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [(s at: i+1) ~= $[]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false!cursorDown: characterStream "Private - Move cursor from position in current line to same position innext line. If next line too short, put at end. If shift key down,select."	| shift string right left start position textSize|	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ stopBlock stringIndex - left.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	right _ start _ right + 1.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	shift		ifTrue: 			[			start + position > right				ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]				ifFalse: [self selectFrom: startBlock stringIndex to: start +position - 1]			]		ifFalse: 			[			start + position > right				ifTrue: [self selectFrom: right to: right - 1]				ifFalse: [self selectFrom: start + position to: start + position -1]			].	^true!cursorEnd: characterStream "Private - Move cursor end of current line. If cursor already at end ofline, put cursor at end of text"	| string right stringSize |	sensor keyboard.	string _ paragraph text string.	stringSize _ string size.	right _ stopBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]whileTrue: [right _ right + 1].	stopBlock stringIndex == right		ifTrue: [self selectAt: string size + 1]		ifFalse: [self selectAt: right].	^true!cursorHome: characterStream "Private - Move cursor from position in current line to beginning ofcurrent line. If cursor already at beginning of line, put cursor atbeginning of text"	| string left |	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	startBlock stringIndex == left		ifTrue: [self selectAt: 1]		ifFalse: [self selectAt: left].	^true!cursorLeft: characterStream "Private - Move cursor left one character if nothing selected, otherwisemove cursor to beginning of selection. If the shift key is down, startselecting or extending current selection. Don't allow cursor pastbeginning of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: 			[			startBlock stringIndex > 1				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: stopBlockstringIndex - 1]			]		ifFalse: 			[			(startBlock stringIndex == stopBlock stringIndex and: [startBlockstringIndex > 1])				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: startBlockstringIndex - 2]				ifFalse: [self selectFrom: startBlock stringIndex to: startBlockstringIndex - 1]			].	^true!cursorRight: characterStream "Private - Move cursor right one character if nothing selected,otherwise move cursor to end of selection. If the shift key is down,start selecting characters or extending already selected characters.Don't allow cursor past end of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: [self selectFrom: startBlock stringIndex to: stopBlockstringIndex]		ifFalse: 			[			startBlock stringIndex == stopBlock stringIndex				ifTrue: [self selectFrom: stopBlock stringIndex + 1 to: stopBlockstringIndex]				ifFalse: [self selectFrom: stopBlock stringIndex to: stopBlockstringIndex - 1]			].	^true!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	| shift string left position start |	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ startBlock stringIndex - left.	start _ left.	left _ left - 1.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	left < 1 ifTrue: [left _ 1].	start = 1 ifTrue: [position _ 0].	shift		ifTrue: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: stopBlock stringIndex - 1]				ifFalse: [self selectFrom: left + position to: stopBlock stringIndex- 1]			]		ifFalse: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: start - 2]				ifFalse: [self selectFrom: left + position to: left + position - 1]			].	^true!forwardDelete: characterStream	"Delete forward over the next character.	11/4/96 tk  Make Undo work on the whole type-in, not just the one char."	| startIndex usel upara uinterval ind |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[Sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		"Just like regular Backspace -- delete the selection"		^ self backspace: characterStream].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	Sensor keyboard.	self selectFrom: startIndex to: startIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isKindOf: Text) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing support'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	"enter, backspace, and escape keys (ascii 3, 8, and 27) are command keys"	(sensor commandKeyPressed or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue: [		sensor leftShiftDown ifTrue: [			^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream.		] ifFalse: [			^ self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream.		].	].	"the control key can be used to invoke shift-cmd shortcuts"	sensor controlKeyPressed ifTrue: [		^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream.	].	^ self perform: #normalCharacter: with: typeAheadStream!setEmphasisHere	emphasisHere _ paragraph text attributesAt: startBlock stringIndex! !!ParagraphEditor class methodsFor: 'class initialization'!initialize	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	6/18/96 sw: call initializeTextEditorMenus	other times: marked change to trigger reinit" 	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<'         do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap.!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (127 + 1) put: #forwardDelete:.				"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$w	methodNamesContainingIt:		$v	pasteInitials:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParseNode methodsFor: 'testing'!isUndefTemp	^ false!isUnusedTemp	^ false!nowHasDef  "Ignored in all but VariableNode"!nowHasRef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'printing'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^self].	"Show comments in green"	aStream withAttribute: (TextColor color: Color blue) do: 	[1 to: comment size do: 		[:index | 		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment _ comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'private'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.   	Break the string at word breaks, given the widths in the default font, at 	450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lastChar | lastChar].			wordWidth _ 0.			word do: [:char | wordWidth _ wordWidth + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					aStream nextPutAll: word; space]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !!ParseNode class methodsFor: 'class initialization'!initialize	"ParseNode initialize. VariableNode initialize"	LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4.	SendType _ 5.	CodeBases _ #(0 16 32 64 208 ).	CodeLimits _ #(16 16 32 32 16 ).	LdSelf _ 112.	LdTrue _ 113.	LdFalse _ 114.	LdNil _ 115.	LdMinus1 _ 116.	LoadLong _ 128.	Store _ 129.	StorePop _ 130.	ShortStoP _ 96.	SendLong _ 131.	DblExtDoAll _ 132.	SendLong2 _ 134.	LdSuper _ 133.	Pop _ 135.	Dup _ 136.	LdThisContext _ 137.	EndMethod _ 124.	EndRemote _ 125.	Jmp _ 144.	Bfp _ 152.	JmpLimit _ 8.	JmpLong _ 164.  "code for jmp 0"	BtpLong _ 168.	SendPlus _ 176.	Send _ 208.	SendLimit _ 16! !!Parser methodsFor: 'expression types'!assignment: varNode	" var '_' expression => AssignmentNode."	| loc |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder.	^true!blockExpression	" [ {:var} ( | statements) ] => BlockNode."	| argNodes |	argNodes _ OrderedCollection new.	[self match: #colon	"gather any arguments"]		whileTrue: 			[argNodes addLast: (encoder autoBind: self argumentName)].	(argNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not])		ifTrue: [^self expected: 'Vertical bar'].	self statements: argNodes innerBlock: true.	(self match: #rightBracket)		ifFalse: [^self expected: 'Period or right bracket'].	argNodes do: [:arg | arg scope: -1] "Scope no longer active"!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	prim _ doit ifTrue: [0] ifFalse: [self primitive].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ MethodNode new comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} => 	{selector, arguments, precedence}."	| args selector |	fromDoit 		ifTrue: 			[ctxt == nil				ifTrue: [^Array with: #DoIt with: #() with: 1]				ifFalse: [^Array 							with: #DoItIn: 							with: (Array 									with: (encoder encodeVariable: 'homeContext')) 									with: 3]].	hereType == #word 		ifTrue: [^Array with: self advance asSymbol with: #() with: 1].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^Array with: selector with: args with: 2].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^Array with: selector contents asSymbol with: args with: 3].	^self expected: 'Message pattern'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode _ self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode _ encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode _ encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'temps'!bindArg: name	^ self bindTemp: name! !!Parser methodsFor: 'error correction'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^ correctSelector.!queryUndefined	| varStart varName | 	varName _ parseNode key.	varStart _ self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]!removeUnusedTemps 	| str end start | 	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)								and: [(str at: start-1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[PopUpMenu notify:'You''ll first have to remove thestatement where it''s stored into']]]! !!PartsBinMorph methodsFor: 'accessing'!partsBinName	^ partsBinName!partsBinName: aString	partsBinName _ aString.! !!PartsBinMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'lock' action: #lock.	aCustomMenu add: 'unlock' action: #unlock.	aCustomMenu add: 'save' action: #save.!lock	openToDragNDrop _ false.!save	self class save: self root.!unlock	openToDragNDrop _ true.! !!PartsBinMorph methodsFor: 'extraction support'!mouseDown: evt	| target |	target _ (self morphsAt: evt cursorPoint) first.	target = self ifTrue: [^ super mouseDown: evt].	target = submorphs first ifTrue: [^ super mouseDown: evt].  "ignore label"	[target owner = self] whileFalse: [target _ target owner].	evt hand grabMorph: target fullCopy.!mouseRecipientAt: aPoint	"If locked (i.e., openToDragNDrop = false), then catch mouse events in order to pull out copies of parts."	openToDragNDrop ifFalse: [^ self].	^ super mouseRecipientAt: aPoint! !!PartsBinMorph class methodsFor: 'class initialization'!initialize	"PartsBinMorph initialize"	| ok |	((PartsBins ~~ nil) and: [PartsBins isEmpty not]) ifTrue: [		ok _ self confirm: 'Are you sure you want to delete all existing parts bins?'.		ok ifFalse: [^ self]].	PartsBins _ Dictionary new.! !!PartsBinMorph class methodsFor: 'named parts bins'!binNames	^ PartsBins keys!named: aString	"Return the parts bin last saved with the given name or a new, empty parts bin."	^ PartsBins		at: aString		ifAbsent: [self emptyPartsBinNamed: aString].!save: aPartsBin	"Save the given parts bin."	PartsBins at: aPartsBin partsBinName put: aPartsBin.! !!PartsBinMorph class methodsFor: 'private'!emptyPartsBinNamed: aString	"Return an empty parts bin."	| bin |	bin _ PartsBinMorph new		color: Color lightGray;		borderWidth: 2;		orientation: #vertical;		partsBinName: aString;		inset: 5;		unlock.	bin addMorphBack: (StringMorph new contents: 'Parts for ''', aString, '''').	^ bin! !!PartsViewerMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color r: 0.8 g: 0.8 b: 1.0.	borderWidth _ 1.	orientation _ #vertical.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 8.!setMorph: aMorph morphName: aString	morph _ aMorph.	morphName _ aString.	self removeAllMorphs.	self addMorphBack: self rowForSelf.	self addMorphBack: self buttonRow.	morph parts do: [:partName |		self addMorphBack: (self rowForPart: partName)].	self addMorphBack: self commandTilesPartsBin.! !!PartsViewerMorph methodsFor: 'tiles'!commandTilesPartsBin	| bin |	bin _ PartsBinMorph new		color: self color;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: morph tilesForCommands.	^ bin!tileForAValue	| menu sel |	menu _ CustomMenu new.	menu add: 'number' action: #tileForNumber.	menu add: 'random number' action: #tileForRandom.	menu add: 'location' action: #tileForLocation.	sel _ menu startUp.	sel ifNotNil: [self perform: sel].!tileForLocation	| p |	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	self world hands first attachMorph:		(TileMorph new setLiteral: p).!tileForNumber	self world hands first attachMorph:		(TileMorph new setLiteral: 5).!tileForPart: partName	self world hands first attachMorph:		(TileMorph new setSlotRef: partName in: morphName).!tileForRandom	self world hands first attachMorph:		(TileMorph new			setExpression: '(50 - 100 atRandom)@(50 - 100 atRandom)'			label: 'random').!tileForSelf	self world hands first attachMorph:		(TileMorph new setObjectRef: morphName).!tilesForCommand	| cList menu entry |	cList _ morph commandsWithDefaultArgs asSortedCollection: [:e1 :e2 | e1 first < e2 first].	menu _ CustomMenu new.	cList do: [:c | menu add: c first action: c].	entry _ menu startUp.	entry ifNotNil: [		self world hands first attachMorph:			(ScriptEditorMorph new setMorph: morph tilesFor: entry)].! !!PartsViewerMorph methodsFor: 'other'!viewerForPart: partName	"Create a one-line viewer for the given part of my target morph."	| r viewer |	r _ LayoutMorph newRow color: self color.	r extent: 5@5.  "so it will be minimum size"	r borderWidth: 1.	r addMorphBack:		(SimpleButtonMorph new label: 't';			target: self;			actionSelector: #tileForPart:;			arguments: (Array with: partName)).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	r addMorphBack: (StringMorph new contents: partName).	r addMorphBack: (LayoutMorph new color: self color).  "flexible spacer" 	viewer _ StringCostumeMorph new		target: morph;		getSelector: partName asSymbol;		putSelector: (partName, ':') asSymbol;		useDefaultFormat.		viewer step.	r addMorphBack: viewer.	self world hands first attachMorph: r.! !!PartsViewerMorph methodsFor: 'private'!buttonRow	"Return a row of buttons for this parts viewer."	| r |	r _ LayoutMorph newRow color: self color.	r addMorphBack:		(SimpleButtonMorph new label: 'dismiss';			target: self;			actionSelector: #delete).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	r addMorphBack:		(SimpleButtonMorph new label: 'commands';			target: self;			actionSelector: #tilesForCommand).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	r addMorphBack:		(SimpleButtonMorph new label: 'values';			target: self;			actionSelector: #tileForAValue).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	^ r!rowForPart: partName	"Return a row representing the given part of my target morph."	| r viewer |	r _ LayoutMorph newRow color: self color.	r addMorphBack:		(SimpleButtonMorph new label: 't';			target: self;			actionSelector: #tileForPart:;			arguments: (Array with: partName)).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	r addMorphBack:		(SimpleButtonMorph new label: 'v';			target: self;			actionSelector: #viewerForPart:;			arguments: (Array with: partName)).	r addMorphBack: (Morph new color: self color; extent: 6@6).  "spacer"	r addMorphBack: (StringMorph new contents: partName).	r addMorphBack: (LayoutMorph new color: self color).  "flexible spacer" 	viewer _ StringCostumeMorph new		target: morph;		getSelector: partName asSymbol;		putSelector: (partName, ':') asSymbol;		useDefaultFormat.		viewer step.	r addMorphBack: viewer.	^ r!rowForSelf	"Return a row representing the target morph itself."	| r |	r _ LayoutMorph newRow color: self color.	r addMorphBack: (LayoutMorph new color: self color; extent: 6@6).  "spacer"	r addMorphBack:		(SimpleButtonMorph new label: morphName;			color: self color darker;			target: self;			actionSelector: #tileForSelf).	r addMorphBack: (LayoutMorph new color: self color; extent: 6@6).  "spacer"	^ r! !!Pen methodsFor: 'moving'!goDelta: aPoint 	"Move the receiver by the relative amount in aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change.  2/17/97 tk"	| old |	old _ location.	location _ location + aPoint.	penDown ifTrue: [self drawFrom: old to: location]!goto: aPoint 	"Move the receiver to position aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change."	| old |	old _ location.	location _ aPoint.	penDown ifTrue: [self drawFrom: old asIntegerPoint								to: location asIntegerPoint]	"NOTE:  This should be changed so it does NOT draw the first point, so as	not to overstrike at line junctions.  At the same time, place should draw	a single dot if the pen is down, as should down (put-pen-down) if it	was not down before."! !!Pen methodsFor: 'geometric designs'!mandala: npoints	"Display restoreAfter: [Pen new mandala: 30]"	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."	| l points d |	Display fillWhite.	d _ Display height-50.	l _ 3.14 * d / npoints.	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.	points _ Array new: npoints.	1 to: npoints do: 		[:i | 		points at: i put: location rounded.		self go: l; turn: 360.0 / npoints].	npoints // 2		to: 1		by: -1		do: 			[:i | 			self color: i.			1 to: npoints do: 				[:j | 				self place: (points at: j).				self goto: (points at: j + i - 1 \\ npoints + 1)]]! !!PluckedSound methodsFor: 'sound generation'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. It may be out of tune for higher pitches because the buffer length must be an integral number of samples and the nearest integer may not result in the exact pitch desired."	"(PluckedSound pitch: 220.0 dur: 3.0 loudness: 1000) play"	| lastIndex thisIndex nextIndex mySample channelIndex sample |	<primitive: 178>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	thisIndex _ ringIndx.	startIndex to: lastIndex do: [ :i |		nextIndex _ (thisIndex \\ ringSize) + 1.		mySample _ ((ring at: thisIndex) + (ring at: nextIndex)) // 2.		ring at: thisIndex put: mySample.		thisIndex _ nextIndex.		pan > 0 ifTrue: [			channelIndex _ 2 * i.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		pan < 1000 ifTrue: [			channelIndex _ (2 * i) - 1.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].	].	ringIndx _ nextIndex.	count _ count - n.! !!PluggableListController methodsFor: 'all'!changeModelSelection: anInteger	"Let the view handle this."	view changeModelSelection: anInteger.!controlActivity	"Overridden to handle keystrokes."	sensor keyboardPressed ifTrue: [view handleKeystroke: sensor keyboard].	super controlActivity.!yellowButtonActivity	"Invoke the model's menu."	| menu |	menu _ view getMenu.	menu == nil ifFalse: [menu invokeOn: model].! !!PluggableListView methodsFor: 'initialization'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'itemsList' holds the original list.	 The instance variable 'items' is a paragraph constructed from	 this list."	| s |	items _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	s _ WriteStream on: Array new.	"add top and bottom delimiters"	s nextPut: topDelimiter.	arrayOfStrings do: [:item |		item == nil ifFalse: [s nextPut: item].	].	s nextPut: bottomDelimiter.	list _ ListParagraph withArray: s contents.	selection _ self getCurrentSelectionIndex.	self positionList.!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ~~ nil ifTrue: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [items at: anInteger]).		model perform: setSelectionSelector with: item.		getSelectionSelector == nil ifFalse: [model perform: getSelectionSelector].	].!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item _ model perform: getSelectionSelector.	^ items findFirst: [ :x | x = item]!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst!getMenu	"Answer the menu for this list view."	getMenuSelector == nil ifTrue: [^ nil].	^ model perform: getMenuSelector!handleKeystroke: aCharacter	"Answer the menu for this list view."	keystrokeActionSelector == nil ifTrue: [^ nil].	model perform: keystrokeActionSelector with: aCharacter.! !!PluggableListView methodsFor: 'controller access'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating'!update: aSymbol 	"Refer to the comment in View|update:."	| oldIndex newIndex |	aSymbol == getListSelector ifTrue: [		oldIndex _ self getCurrentSelectionIndex.		self list: self getList.		newIndex _ self getCurrentSelectionIndex.		(oldIndex > 0 and: [newIndex = 0]) ifTrue: [			"new list did not include the old selection; deselecting"			self changeModelSelection: newIndex].		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue: [		self moveSelectionBox: self getCurrentSelectionIndex.		^self].! !!PluggableListView class methodsFor: 'as yet unclassified'!aboutPluggability	"A pluggable list view gets its content from the model. This allows the same kind of view can be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific (or 'yellow-button') menu		keyActionSel	process keystrokes typed to this view (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default, do-nothing behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!! (Such behavior can actually be useful during debugging.)	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song."!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: nil!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: nil!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!PluggableTest methodsFor: 'initialization'!initialize	list1 _ #('reggae' 'early' 'classical').	list2 _ #('marley' 'alpha blondy' 'burning spear' 'ziggy').! !!PluggableTest methodsFor: 'artist pane'!artist	^ selection2!artist: aString	selection2 _ aString.	self changed: #artist.!artistKeystroke: aCharacter	list2 do: [ :artist |		(artist first asLowercase = aCharacter asLowercase) ifTrue: [			self artist: artist]].!artists	selection1 = 'reggae' ifTrue: [^ list2].	selection1 = 'early' ifFalse: [^ #('ziggy' 'marley')].	^ #()! !!PluggableTest methodsFor: 'music type pane'!musicType	^ selection1!musicType: aString	selection1 _ aString.	self changed: #musicType.	self changed: #artists.!musicTypeKeystroke: aCharacter	list1 do: [ :type |		(type first asLowercase = aCharacter asLowercase) ifTrue: [			self musicType: type]].!musicTypeMenu	^ SelectionMenu		labels: 'reggae\grunge\flash' withCRs		lines: #(2)		selections: #(reggaeCmd grungeCmd flashCmd)!musicTypes	^ list1! !!PluggableTest methodsFor: 'menu commands'!flashCmd	Display reverse; reverse.!grungeCmd	SelectionMenu confirm:		'You mean, like those strange bands from Seattle?'!reggaeCmd	self musicType: 'reggae'.! !!PluggableTest class methodsFor: 'as yet unclassified'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypes			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu			keystroke: #musicTypeKeystroke:.	listView2 _		PluggableListView on: model			list: #artists			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView controller open.! !!Point methodsFor: 'arithmetic'!\\ scale 	"Answer a Point that is the mod of the receiver and scale (which is a  Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^ x \\ scalePoint x @ (y \\ scalePoint y)! !!Point methodsFor: 'converting'!asFloat	"Make my values Float in preparation for being divided by a float.  2/19/97 tk"	x _ x asFloat.	y _ y asFloat! !!Point methodsFor: 'transforming'!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p _ self - center.	r _ p r.	theta _ angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width / rect1 width)					@ ((y-rect1 top) * rect2 height / rect1 height))! !!Point methodsFor: 'private'!setR: rho degrees: theta	| radians |	radians _ theta asFloat degreesToRadians.	x _ (rho asFloat * radians cos) asInteger.	y _ (rho asFloat * radians sin) asInteger.! !!Point class methodsFor: 'instance creation'!r: rho degrees: theta	"Answer an instance of me with polar coordinates rho and theta."	^self new setR: rho degrees: theta! !!PopUpMenu methodsFor: 'displaying'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ DisplayText				text: captionOrNil asText				textStyle: TextStyle default copy centered.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame moveBy: delta.	captionOrNil notNil ifTrue:		[captionView _ DisplayTextView new model: captionText.		captionView align: captionView boundingBox bottomCenter					with: frame topCenter + (0@2).		captionView insideColor: Display white.		captionView borderWidth: 2.		captionSave _ Form fromDisplay: captionView displayBox.		captionView unlock; display; release].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionView displayBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				(Display boundingBox containsPoint: pt)					ifTrue: [CacheMenuForms ifFalse: [form _ nil]]					ifFalse: [form == nil ifTrue: [form _ self computeForm].							pt _ pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]!scrollIntoView: cursorLoc	| dy |	dy _ 0.	cursorLoc y < 0 ifTrue: [dy _ font height].	cursorLoc y > Display height ifTrue: [dy _ font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame moveBy: 0@dy.	marker moveBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'private'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm |	borderInset _ 2@2.	paraForm _ self computeLabelParagraph asForm.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm fillBlack.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse: [		lineArray do: [ :line |			menuForm fillBlack:				(0 @ ((line * font height) + borderInset y) extent: (menuForm width @ 1)).		].	].	^ menuForm!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle!labels: aString font: aFont lines: anArray	| style inside |	labelString _ aString.	font _ aFont.	lineArray _ anArray.	frame _ Quadrangle new.	frame region: self menuForm boundingBox.	frame borderWidth: 2.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ self computeLabelParagraph lineGrid).	selection _ 1.!menuForm	"Answer a Form to be displayed for this menu."	"Details: On slower systems, cache the menu Form for speed."	form == nil ifFalse: [^ form].	CacheMenuForms		ifTrue: [^ form _ self computeForm]		ifFalse: [^ self computeForm]!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	form _ nil.	"PopUpMenu withAllSubclasses do: [ :menuClass |		menuClass allInstancesDo: [ :m | m rescan ]]"! !!PopUpMenu class methodsFor: 'instance creation'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^self new		labels: aString		font: (MenuStyle fontAt: 1)		lines: anArray! !!PopUpMenu class methodsFor: 'class initialization'!initialize  "PopUpMenu initialize"	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.	(MenuStyle _ TextStyle default copy)		gridForFont: 1 withLead: 0;		centered.	PopUpMenu withAllSubclasses do:		[:menuClass | menuClass allInstancesDo:			[:m | m rescan]]! !!PositionableStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!PositionableStream methodsFor: 'fileIn/Out'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !Preferences comment:'A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  It is also possible to store non-boolean data in the preference table.  sw 8/91'!!Preferences class methodsFor: 'hard-coded prefs'!startAllWindowTicking	"Execute this to set the system to start the ticking of inactive windows"	"Preferences startAllWindowTicking"	Preferences class compile:'letInactiveWindowsTick	"Set to true if you want inactive windows to tick in HyperSqueak"	^ true' classified: 'HyperSqueak'!startCollisionDetection	"Execute this to set the system to start collision detection"	"Preferences startLoggingUserScripts"	Preferences class compile:'collisionDetection	"Set to true if you want collision detection to take place automatically in HyperSqueak"	^ true' classified: 'HyperSqueak'!startLoggingUserScripts	"Execute this to set the system to start logging user scripts to the changes log.  7/18/96 sw"	"Preferences startLoggingUserScripts"	Preferences class compile:'logUserScripts	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"	^ true' classified: 'HyperSqueak'!stopAllWindowTicking	"Execute this to set the system to stop the ticking of inactive windows"	"Preferences stopAllWindowTicking"	Preferences class compile:'letInactiveWindowsTick	"Set to true if you want inactive windows to tick in HyperSqueak"	^ false' classified: 'HyperSqueak'!stopCollisionDetection	"Execute this to set the system to stop collision detection"	"Preferences startLoggingUserScripts"	Preferences class compile:'collisionDetection	"Set to true if you want automatic collision detection to take place"	^ false' classified: 'HyperSqueak'!stopLoggingUserScripts	"Execute this to set the system to stop logging user scripts to the changes log.  7/18/96 sw"	"Preferences stopLoggingUserScripts"	Preferences class compile:'logUserScripts	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"	^ false' classified: 'HyperSqueak'! !!Preferences class methodsFor: 'general'!chooseInitialSettings	"Set up the initial choices for Preferences.  2/7/96 sw	 5/2/96 sw: added init for uniformWindowColors	 5/22/96 sw: init reverseWindowStagger, clear out old window parms"	"Preferences chooseInitialSettings"	self setPreference: #uniformWindowColors toValue: false.	self setPreference: #reverseWindowStagger toValue: true.	self setPreference: #programmerMode toValue: false.	AutoAccessors _ false.	BrowserAutoSelect _ false.!initialize	"5/22/96 sw: Included within a 22 May96 fileout to trigger reinitialization"	FlagDictionary _ Dictionary new.	self chooseInitialSettings.	"Preferences initialize"! !!Preferences class methodsFor: 'HyperSqueak'!collisionDetection	"Set to true if you want automatic collision detection to take place"	^ false!letInactiveWindowsTick	"Set to true if you want inactive windows to tick in HyperSqueak"	^ false!logUserScripts	"Set to true if you want user scripts logged; later, we will maybe have a better way to specify this, or do something better altogether"	^ true!nestedHalos	"Answer whether nested halos should be used.  1/8/97 sw"	self flag: #scottPrivate.	^ false! !!Preferences class methodsFor: 'ui prefs'!autoAccessors	"Answer the preference; change by: Preferences classPool inspect"		^ AutoAccessors!browserAutoSelect	"Answer the preference; change by: Preferences classPool inspect"		^ BrowserAutoSelect!desktopColor	"Answer the desktop color.  Initialize it if it's never been done.  11/26/96 sw"		DesktopColor == nil ifTrue:		[DesktopColor _ Color gray].	^ DesktopColor!desktopColor: aColor	"Set the desktop color"	DesktopColor _ aColor!scrollBarBackground: viewColor	"Answer the preferred background color for scroll bars."	^ viewColor!scrollBarColor	"Answer the preferred color for scroll bar elevators."	^ Color gray!scrollBarWidth	"Answer the preferred width for scroll bars."	^ 8! !!Project methodsFor: 'menu messages'!exit	"Leave the current project and return to the project	in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	projectHolder enter! !!Project methodsFor: 'release'!okToChange	^ self confirm:'Are you sure you have savedall changes that you care aboutin ', self name printString.! !!ProjectView methodsFor: 'displaying'!displayView	| scale rect topLeft ibox |	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	Display fill: (ibox _ self insetDisplayBox) fillColor: Color lightGray.	scale _ ibox extent / Display extent.	topLeft _ ibox topLeft.	model views reverseDo:		[:v | rect _ ((v displayBox scaleBy: scale) rounded				translateBy: topLeft) intersect: ibox.		Display fill: rect fillColor: v backgroundColor;			border: rect width: 1;			border: (rect topLeft extent: rect width@3) width: 1.		]! !ProtocolBrowser comment:'An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.'!!ProtocolBrowser methodsFor: 'accessing'!classDictionary        "Answer the receiver's class dictionary."        ^classDictionary!classDictionary: aDictionary        "Set the receiver's class dictionary to be the argument."        classDictionary := aDictionary!getList        "Answer the receiver's message list."        ^messageList!list        "Answer the receiver's message list."        ^messageList!selectedClass        "Answer the receiver's selected class."        ^selectedClass!selectedClass: aClass        "Set the receiver's selected class to be the argument."        selectedClass := aClass!selector        "Answer the receiver's selected selector."        ^selectedSelector!selector: aString        "Set the currently selected message selector to be aString."        selectedSelector := aString.        self changed: #selector!selectorList        "Answer the receiver's message list."        ^messageList!selectorList: aList        "Set the receiver's message list to the argument."        messageList := aList!setSelector: aString        "Set the currently selected message selector to be aString."        selectedSelector := aString! !!ProtocolBrowser methodsFor: 'private'!on: aClass         "Create the protocol browser for the class, a Class."        | defClass |        baseClass := aClass.        self selectorList: OrderedCollection new.        self classDictionary: IdentityDictionary new.        aClass allSelectors asSortedCollection do:                 [ :selector |                         defClass := aClass whichClassIncludesSelector: selector.                        defClass == self class                                ifTrue:[self selectorList add: selector asText, '       (' , defClass name asText allBold , ')']                                ifFalse:[self selectorList add: selector, '     (' , defClass name , ')'].                        self classDictionary add: (Association key: selector value: defClass)]!onSubProtocolOf: aClass         "Create the protocol browser for the class, a Class."        | defClass aSet aCollection |        baseClass := aClass.        messageList := OrderedCollection new.        classDictionary := IdentityDictionary new.        selectedClass := aClass.        aSet := Set new.        aCollection := aClass withAllSuperclasses.        aCollection remove: Object.        aCollection do: [:each | aSet addAll: each selectors].        aSet asSortedCollection do:                 [ :selector |                 defClass := aClass whichClassIncludesSelector: selector.                defClass == self selectedClass                        ifTrue:[self selectorList add: selector asText, '       (' , defClass name asText allBold , ')']                        ifFalse:[self selectorList add: selector, '     (' , defClass name , ')'].                self classDictionary add: (Association key: selector value: defClass)]!parse: messageString toClassAndSelector: csBlock        "Decode strings of the form <className> [class] <selectorName>."        | tuple cl |        tuple _ messageString string findTokens: '      '.        cl _ tuple at: 2.        cl _ (cl copyFrom: 2 to: cl size - 1) asSymbol.        cl _ Smalltalk at: cl.        self selectedClass: cl.        self setSelector: tuple first.        tuple size = 2                ifTrue: [^ csBlock value: cl value: tuple first asSymbol]                ifFalse: [^ csBlock value: cl class value: tuple first asSymbol]!setClassAndSelectorIn: csBlock        "Decode strings of the form <className> [class] <selectorName>."        ^ self parse: self selection toClassAndSelector: csBlock! !!ProtocolBrowser class methodsFor: 'instance creation'!openForClass: aClass         "Create and schedule a browser for the protocol of the class."        "ProtocolBrowser openForClass: ProtocolBrowser."        ^self openSubProtocolForClass: aClass!openFullProtocolForClass: aClass         "Create and schedule a browser for the entire protocol of the class."        "ProtocolBrowser openForClass: ProtocolBrowser."        | aPBrowser label |        aPBrowser := ProtocolBrowser new on: aClass.        label := 'Entire protocol of: ', aClass name.        self open: aPBrowser name: label!openSubProtocolForClass: aClass         "Create and schedule a browser for the entire protocol of the class."        "ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."        | aPBrowser label |        aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.        label := 'Sub-protocol of: ', aClass name.        self open: aPBrowser name: label! !QuickPrint comment:'This class supports fast, single-line string display. It is significantly faster than using a Paragraph for the same purpose.'!!QuickPrint methodsFor: 'displaying'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x.	destY _ aPoint y.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: clipX + clipWidth + font maxWidth		stopConditions: stopConditions		displaying: true!lineHeight	"Answer the height of the font used by QuickPrint."	^ font height!stringWidth: aString	"Answer the width of the given string."	destX _ 0.	destY _ 0.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		displaying: false.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!QuickPrint methodsFor: 'private'!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	font _ aStrikeFont ifNil: [TextStyle default fontAt: 1].	self setFont.	destForm _ aForm.	self colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: ((textColor bitPatternForDepth: destForm depth) at: 1)).	combinationRule _ Form paint.	self clipRect: aRectangle.	sourceY _ 0.	"sourceX is set when selecting the character from the font strike bitmap"!setFont	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !!QuickPrint class methodsFor: 'instance creation'!new	"Create an instance to print on the display in the default font."	^ super new newOn: Display box: Display boundingBox font: self defaultFont color: Color black!newOn: aForm box: aRectangle	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: self defaultFont color: Color black!newOn: aForm box: aRectangle font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: aStrikeFont color: Color black!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Create an instance to print on the given form in the given rectangle."	^ (super new) newOn: aForm box: aRectangle font: aStrikeFont color: textColor! !!QuickPrint class methodsFor: 'queries'!defaultFont	^ (TextStyle default) fontArray at: 1! !!QuickPrint class methodsFor: 'example'!example	"This will quickly print all the numbers from 1 to 100 on the display,	and then answer the default width and height of the string 'hello world'."	"QuickPrint example"	| scanner |	scanner _ QuickPrint new.	0 to: 99 do: [: i | scanner drawString: i printString at: (i//10*20) @ (i\\10*12) ].	^ (scanner stringWidth: 'hello world') @ (scanner lineHeight)! !Random comment:'This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG which uses Floats to avoid the need for LargeInteger arithmetic.'!!Random methodsFor: 'all'!initialize	" Set a reasonable Park-Miller starting seed "	seed := Time millisecondClockValue.	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.!next	" This method generates random instances of Float in the interval 0to 1. "	seed := self nextValue.	^ seed / m!nextValue	" This method generates random instances of Integer	in the interval 0 to 16r7FFFFFFF.	This method does NOT update the seed; repeated sends answer thesame value.	The algorithm is described in detail in 'Random Number Generators:	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988). "	| lo hi aLoRHi answer |	hi := (seed quo: q) asFloat.	lo := seed - (hi*q).     " = seed rem: q"  	aLoRHi := (a * lo) - (r * hi).	answer := (aLoRHi > 0.0)		ifTrue:  [ aLoRHi ]		ifFalse: [ aLoRHi + m ].	^ answer!seed: anInteger	 seed := anInteger! !!Random class methodsFor: 'examples'!example	"If you just want a quick random integer, use:		10 atRandom	Every integer interval can give a random number:		(6 to: 12) atRandom	Most Collections can give randomly selected elements:		'pick one of these letters randomly' atRandom	Collections also respond to shuffled, as in:		($A to: $Z) shuffled	The correct way to use class Random is to store one in 	an instance or class variable:		myGenerator _ Random new.	Then use it every time you need another number between 0.0 and 1.0		myGenerator next"! !!Random class methodsFor: 'testing'!bucketTest: randy	"Execute this:   Random bucketTest: Random new"	" A quick-and-dirty bucket test. Prints nbuckets values on theTranscript.	  Each should be 'near' the value of ntries. Any run with any value'far' from ntries	  indicates something is very wrong. Each run generates differentvalues.	  For a slightly better test, try values of nbuckets of 200-1000 ormore; go get coffee.	  This is a poor test; see Knuth.   Some 'OK' runs:		1000 1023 998 969 997 1018 1030 1019 1054 985 1003		1011 987 982 980 982 974 968 1044 976		1029 1011 1025 1016 997 1019 991 954 968 999 991		978 1035 995 988 1038 1009 988 993 976"	| nbuckets buckets ntrys slot |	nbuckets := 20.	buckets := Array new: nbuckets.	buckets atAllPut: 0.	ntrys :=  100.	ntrys*nbuckets timesRepeat: [		slot := (randy next * nbuckets) floor + 1.		buckets at: slot put: (buckets at: slot) + 1 ].	Transcript cr.	1 to: nbuckets do: [ :nb |		Transcript show: (buckets at: nb) printString, ' ' ]!theItsCompletelyBrokenTest	"Random theItsCompletelyBrokenTest"	"The above should print as...	(0.149243269650845 0.331633021743797 0.75619644800024 0.393701540023881 0.941783181364547 0.549929193942775 0.659962596213428 0.991354559078512 0.696074432551896 0.922987899707159 )	If they are not these values (accounting for precision of printing) then something is horribly wrong: DO NOT USE THIS CODE FOR ANYTHING. "	| rng |	rng := Random new.	rng seed: 2345678901.	^ (1 to: 10) collect: [:i | rng next]! !!Random class methodsFor: 'instance creation'!new	^ super new		initialize! !!RealEstateAgent class methodsFor: 'as yet unclassified'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames.	10/24/96 di"	| grid extent allOthers y putativeFrame free |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	extent _ aSSView labelDisplayBox extent.	allOthers _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view collapsedFrame]				thenSelect: [:rect | rect notNil].	y _ 0.	[(y _ y + grid) < (Display height - extent y)]		whileTrue:		[putativeFrame _ 0@y extent: extent.		free _ true.		allOthers do: [:w | free _ free & (w intersects: putativeFrame) not].		free ifTrue: [^ putativeFrame topLeft]].	"If all else fails..."	^ 0 @ 0!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  5/22/96 sw"	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ ScrollBarSetback +   ((anArea width - ScrollBarSetback)  // 2).	midY _ ScreenTopSetback + ((anArea height - ScreenTopSetback) // 2).	aList _ OrderedCollection with: (ScrollBarSetback @ ScreenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ ScreenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (ScrollBarSetback @ (midY+ScreenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+ScreenTopSetback))]].	^ aList!standardWindowExtent	"Answer the standard default extent for new windows.  5/23/96 sw"	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent - (ScrollBarSetback @ ScreenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ ScrollBarSetback @ ScreenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	10/24/96 di"	| allowedArea grid initialFrame allWindows cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ ScrollBarSetback @ ScreenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	allWindows _ ScheduledControllers scheduledWindowControllers				collect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			allWindows do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RecentMessageSet methodsFor: 'as yet unclassified'!accept	^ super accept!contents: c notifying: n	| result |	result _ super contents: c notifying: n.	result == true ifTrue:		[self initializeMessageList: Utilities recentlySubmittedMessages.		self changed: #messageListChanged].	^ result!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"		self messageListIndex: 1! !!Rectangle methodsFor: 'accessing'!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 _ self topLeft corner: self bottomRight - (1@1).	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !!Rectangle methodsFor: 'rectangle functions'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(origin <= aRectangle corner and: [aRectangle origin <= corner])		ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) <= (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) <= (self right min: her right)].	^ false!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!Rectangle methodsFor: 'testing'!containsRect: aRect	"Answer whether aRect is within the receiver (OK to coincide)."	^ aRect origin >= origin and: [aRect corner <= corner]! !!Rectangle methodsFor: 'transforming'!scaleFrom: rect1 to: rect2	"Produce a rectangle stretched according to the stretch from rect1 to rect2"	^ (origin scaleFrom: rect1 to: rect2)		corner: (corner scaleFrom: rect1 to: rect2)! !!Rectangle methodsFor: 'printing'!display: c 	"Display the receiver filling it with the given color; by Alan Kay.  Used by his mini painting system, 1/96.	12/9/96 sw: fixed so it doesn't always draw a square!!"	| p |	p _ Pen new.	p color: c.	p place: self origin.	1 to: 2 do:		[:i | p turn: 90; go: self width.		p turn: 90; go: self height]!displayColor: aColor on: aDisplayMedium	| p |	p _ Pen newOnForm: aDisplayMedium theForm.	p color: aColor.	p place: self origin.	1 to: 2 do:		[:i | p turn: 90; go: self width.		p turn: 90; go: self height]!displayOn: aDisplayMedium color: aColor	"Display the receiver filling it with the given color; by Alan Kay.  Used by his mini painting system, 1/96.	12/9/96 sw: fixed so it doesn't always draw a square!!	1/29/97 sw: this variant with display-medium arg"	| p |	p _ Pen newOnForm: aDisplayMedium theForm.	p color: aColor.	p place: self origin.	1 to: 2 do:		[:i | p turn: 90; go: self width.		p turn: 90; go: self height]! !!Rectangle class methodsFor: 'instance creation'!center: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  3/9/97 tk"	^self new origin: centerPoint - (extentPoint//2) extent: extentPoint! !!RectangleMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color gray.	borderColor _ Color black.	borderWidth _ 3.! !!RectangleMorph methodsFor: 'accessing'!borderColor	^ borderColor!borderColor: colorOrNil	borderColor _ colorOrNil.	self changed.!borderWidth	^ borderWidth!borderWidth: anInteger	borderColor ifNil: [borderColor _ Color black].	borderWidth _ anInteger.	self changed.! !!RectangleMorph methodsFor: 'drawing'!drawOn: aCanvas 	"Draw with inset or raised border if requested.	Note: the raised border color is generated from the Morph's own color,	while the inset border color is generated from its owner.	This behavior is visually more consistent."	| darker lighter |	color ifNotNil: [aCanvas fillRectangle: bounds color: color].	borderColor == nil ifTrue: ["no need to draw" ^self].	borderWidth = 0 ifTrue: ["no border" ^self].	false ifTrue: [(aCanvas clipRect contains: (bounds insetBy: borderWidth))		ifTrue: ["area to display completely inside border" ^self]].	borderColor == #raised ifTrue: [		darker := color darker.		lighter := color lighter.		aCanvas frameRectangle: bounds width: borderWidth			topColor: lighter leftColor: lighter			rightColor: darker bottomColor: darker.		^self].	borderColor == #inset ifTrue: [		darker := owner color darker.		lighter := owner color lighter.		aCanvas frameRectangle: bounds width: borderWidth			topColor: darker leftColor: darker			rightColor: lighter bottomColor: lighter.		^self].	aCanvas frameRectangle: bounds		width: borderWidth color: borderColor! !!RectangleMorph methodsFor: 'geometry'!innerBounds	^ bounds insetBy: borderWidth! !!RectangleMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'border color' action: #changeBorderColor.	aCustomMenu add: 'border width' action: #changeBorderWidth.!changeBorderColor		self borderColor: self chooseColor.!changeBorderWidth	| menu width |	menu _ CustomMenu new.	0 to: 5 do: [:w | menu add: w printString action: w].	width _ menu startUp.	width ifNotNil: [self borderWidth: width].! !!RectangleMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') setBorderWidth: '; print: borderWidth;		nextPutAll: ' borderColor: ' , (self colorString: borderColor)! !!RectangleMorph methodsFor: 'private'!setBorderWidth: w borderColor: bc	self borderWidth: w.	self borderColor: bc.!setColor: c borderWidth: w borderColor: bc	self color: c.	self borderWidth: w.	self borderColor: bc.! !!RemoteHandMorph methodsFor: 'all'!initialize	super initialize.	socket _ nil.	waitingForConnection _ false.	remoteCursorPoint _ 0@0.	remoteButtons _ 0.	waitingForConnection _ false.!processEvents	"Process user input events from the remote input devices."	| evt |	self updateFromSocket ifFalse: [^ self].  "no data has arrived"	evt _ MorphicEvent new		setMousePoint: remoteCursorPoint		buttons: remoteButtons		lastEvent: lastEvent		hand: self.	(evt yellowButtonPressed and:	 [lastEvent yellowButtonPressed not]) ifTrue: [		lastEvent _ evt.		^ self invokeMetaMenu: evt].	self handleEvent: evt.	lastEvent _ evt.!readDataFromSocket: s	"Get the most recent line of cursor information, if any, from the given socket. Return nil if there isn't any."	| buf response bytesRead c lastFullLine |	(s isConnected and: [s dataAvailable]) ifFalse: [^ nil].	buf _ String new: 1000.	response _ WriteStream on: ''.	bytesRead _ 1.	[bytesRead > 0] whileTrue: [		bytesRead _ s receivedDataInto: buf.		1 to: bytesRead do: [ :i |			c _ buf at: i.			c = $. ifTrue: [^ self withdrawFromWorld].			c = Character linefeed				ifTrue: [lastFullLine _ response contents. response _ WriteStream on: '']				ifFalse: [response nextPut: c]].	].	^ lastFullLine!startListening	"Create a socket and start listening for a connection."	self stopListening.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'remote hand ', userInitials, ' waiting for a connection on socket 54323'; cr.	socket _ Socket new.	socket listenOn: 54323.	waitingForConnection _ true.!stopListening	"Destroy the socket, if any, terminating the connection."	socket ifNotNil: [		socket destroy.		socket _ nil].!updateFromSocket	"Update my state if any data has arrived on my socket. Return true if new data has arrived."	| stateString state |	socket ifNotNil: [		socket isConnected ifTrue: [			waitingForConnection ifTrue: [				Transcript show: 'remote hand ', userInitials, ' connected'; cr.				waitingForConnection _ false].			"parse data from the socket, if there is any"			stateString _ self readDataFromSocket: socket.			stateString = nil ifTrue: [				^ false			] ifFalse: [				state _ Socket parseSensorStateString: stateString.				remoteCursorPoint _ state at: 1.				remoteButtons _ state at: 2.				^ true].		] ifFalse: [			"socket exists, but is not connected"			waitingForConnection ifFalse: [				"connection was made, then broken"				self withdrawFromWorld.				^ false].		].	].	^ false  "no socket"!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	self stopListening.	Transcript show: 'remote hand ', userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'private'!fileNumber: fileNumber position: position 	sourceFileNumber _ fileNumber.	filePositionHi _ position!fromFile: aPositionableStream onFileNumber: fileNumber toFile: aFileStream 	"Store the next chunk from aPositionableStream as the receiver's string."	| position |	position _ aFileStream position.	self fileNumber: fileNumber position: position.	aPositionableStream copyChunkTo: aFileStream!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile _ SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]!string: aString onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's string if source files exist."	| position |	position _ aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPut: aString! !!ReturnNode methodsFor: 'C translation'!asTranslatorNode	^TReturnNode new setExpression: expr asTranslatorNode! !!RunArray methodsFor: 'accessing'!at: index	self at: index setRunOffsetAndValue: [:run :offset :value | ^value]!runLengthAt: index 	"Answer the length remaining in run beginning at index."	self at: index 		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !!RunArray methodsFor: 'copying'!copyFrom: start to: stop	| newRuns |	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs printOn: aStream.	aStream nextPutAll: ' values: '.	values printOn: aStream.! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: [:val | mapBlock value: val]! !!SampledSound methodsFor: 'initialization'!setPitch: p dur: d loudness: l	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 500) play"	samples _ DefaultSampleTable.	samplesSize _ samples size.	incrementTimes1000 _ ((p asFloat / NominalSamplePitch asFloat) * 1000.0) asInteger.	initialCount _ (d * self samplingRate asFloat) rounded.	self reset.!setSamples: anArray	"There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSamplesFromAIFF:samplePitch:). You can use the shareware program SoundMachine 2.1 to record an uncompressed AIFF sound file. The headers of such files are 54 bytes."	"Example:		samples _ (AbstractSound convert8bitSignedTo16Bit:			(FileStream oldFileNamed: 'boink.aiff') binary contentsOfEntireFile.		(SampledSound new			setSamples: (samples copyFrom: 55 to: samples size)) play"	self setSamples: anArray increment: 1.!setSamples: anArray increment: aNumber	"Set my samples array to the given array and the amount to increment to the given number. The increment amount is represented as 1000 * the increment value to allow fractional increments without having to do floating point arithmetic in the inner loop."	"Assume: anArray contains signed 16-bit samples."	samples _ SoundBuffer new: anArray size.	1 to: anArray size do: [:i | samples at: i put: (anArray at: i)].	samplesSize _ samples size.	incrementTimes1000 _ (aNumber * 1000.0) asInteger.	initialCount _ samples size.! !!SampledSound methodsFor: 'playing'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The pan parameter determines the left-right balance of the sound, where 0 is left only, 1000 is right only, and 500 is centered."	| lastIndex i thisSample channelIndex sample sampleIndex |	<primitive: 179>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex _ (startIndex + n) - 1.	i _ startIndex.	sampleIndex _ indexTimes1000 // 1000.	[(sampleIndex < samplesSize) and: [i <= lastIndex]] whileTrue: [		thisSample _ samples at: sampleIndex.		pan > 0 ifTrue: [			channelIndex _ 2 * i.			sample _ (aSoundBuffer at: channelIndex) + ((thisSample * pan) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		pan < 1000 ifTrue: [			channelIndex _ (2 * i) - 1.			sample _ (aSoundBuffer at: channelIndex) + ((thisSample * (1000 - pan)) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		indexTimes1000 _ indexTimes1000 + incrementTimes1000.		sampleIndex _ indexTimes1000 // 1000.		i _ i + 1].	count _ count - n.!reset	super reset.	count _ initialCount.	indexTimes1000 _ 1000.!samplesRemaining	^ count! !!SampledSound class methodsFor: 'all'!defaultSamples: anArray repeated: n	| data |	data _ WriteStream on: (SoundBuffer new: anArray size * n).	n timesRepeat: [		anArray do: [:sample | data nextPut: sample truncated]].	DefaultSampleTable _ data contents.!defaultSamplesFromAIFF: fileName samplePitch: aNumber	"Set the sample table to be used as the default waveform from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 8-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The sample pitch is an estimate of the normal pitch of the sampled sound."	"SampledSound defaultSamplesFromAIFF: 'boing.aiff' samplePitch: 200"	| data |	data _ (FileStream oldFileNamed: fileName) binary contentsOfEntireFile.	self defaultSampleTable:		(AbstractSound convert8bitSignedTo16Bit: (data copyFrom: 55 to: data size)).	self nominalSamplePitch: aNumber.!defaultSampleTable	"Return the sample table to be used as the default waveform for playing a score."	^ DefaultSampleTable!defaultSampleTable: anArray	"Set the sample table to be used as the default waveform for playing a score such as the Bach fugue. Array is assumed to contained signed 16-bit samples."	DefaultSampleTable _ SoundBuffer new: anArray size.	1 to: anArray size do: [:i | DefaultSampleTable at: i put: (anArray at: i)].!initialize	"Build a sine wave table."	"SampledSound initialize"	| radiansPerStep scale |	DefaultSampleTable _ SoundBuffer new: 6000.	radiansPerStep _ (2.0 * Float pi) / 100.0.	scale _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: DefaultSampleTable size do: [ :i |		DefaultSampleTable at: i put:			(scale * (radiansPerStep * i) sin) rounded.	].	NominalSamplePitch _ 60.!nominalSamplePitch: aNumber	"Record an estimate of the normal pitch of the sampled sound."	NominalSamplePitch _ aNumber.!readTrimmedSamplesFromAIFF: fileName	"Read samples from the given AIFF file and trim off leading and trailing silence."	| data first last i s |	data _ (FileStream oldFileNamed: fileName) binary contentsOfEntireFile.	first _ last _ nil.	i _ 55.	[(first == nil) and: [i < data size]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [first _ i].		i _ i + 1].	first ifNil: [^ Array new].  "all silence"	i _ data size.	[(last == nil) and: [i > first]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [last _ i].		i _ i - 1].	^ AbstractSound convert8bitSignedTo16Bit: (data copyFrom: first to: last)!useCoffeeCupClink	"Set the sample table to be used as the default waveform to the sound of a coffee cup being tapped with a spoon."	"SampledSound useCoffeeCupClink bachFugue play"	NominalSamplePitch _ 400.	self defaultSampleTable: #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256).! !!Scanner methodsFor: 'multi-character scans'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #_].	"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type = #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Scanner class methodsFor: 'class initialization'!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	newTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.	newTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"Scanner initialize"! !!Scanner class methodsFor: 'testing'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()' includes: (aSymbol at: 1)) ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !!ScreenController methodsFor: 'menu messages'!browseChangedMessages	"Browse all methods in the current change set.  1/18/96 sw, 3/9/97 sw"	ChangedMessageSet openFor: Smalltalk changes!changeWindowPolicy	Preferences setPreference: #reverseWindowStagger		toValue: (Preferences valueOfFlag: #reverseWindowStagger) not!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]!setDesktopColor	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   11/26/96 sw"	Preferences desktopColor: Color fromUser.	ScheduledControllers updateGray; restore! !!ScreenController methodsFor: 'nested menus'!changesMenu	"Answer a menu for changes-related items.  2/4/96 sw	 5/8/96 sw: divided changelist options into two	 5/17/96 sw: added browse recent submissions"	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'browse changed methods'			'browse recent submissions'			'recent change log')		lines: #(1 3)		selections: #(fileOutChanges browseChangedMessages browseRecentSubmissions browseRecentLog)].	^ ChangesMenu"ScreenController new changesMenu startUp"!helpMenu	"Answer the help menu to be put up as a screen submenu.  7/24/96 sw	 11/26/96 sw: added set desktop color"	HelpMenu == nil ifTrue:		[HelpMenu _ SelectionMenu labelList:		#(	'preferences...'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'view GIF imports'			'space left'				)		lines: #(1 4 6)		selections: #(editPreferences  aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor viewGIFImports garbageCollect)].	^ HelpMenu"ScreenController new helpMenu startUpScreenController initialize"!openMenu	"Answer a menu for open-related items.  2/4/96 sw	 5/10/96 sw: useful expressions moved to help menu"	OpenMenu == nil ifTrue:		[OpenMenu _ SelectionMenu labelList:		#(	'open browser'			'open workspace'			'open file list'			'open change sorter'			'open project'			'open transcript'			'open system workspace')		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject openTranscript  openSystemWorkspace)].	^ OpenMenu"ScreenController new openMenu startUp"!projectScreenMenu	"Answer the project screen menu.   7/23/96 sw	 7/24/96 sw: remove misc menu thing"	ProjectScreenMenu == nil ifTrue:		[ProjectScreenMenu _ SelectionMenu labelList:		#(	'exit project'			'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(2 7)		selections: #(exitProject restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ ProjectScreenMenu"ScreenController new projectScreenMenu startUp"!topScreenMenu	"Answer the screen menu for the top project, from whence there is no relevance to the 'exit project' item.  7/24/96 sw"	TopScreenMenu == nil ifTrue:		[TopScreenMenu _ SelectionMenu labelList:		#(	'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(1 6)		selections: #( restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ TopScreenMenu"ScreenController new newScreenMenu startUp"!windowMenu	"Answer a menu for windows-related items.  10/24/96 sw"	^ SelectionMenu labelList:		#(	'find window...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows') ,			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(2 4 5)		selections: #(findWindow indicateWindowsWithUnacceptedInput collapseAll expandAll closeUnchangedWindows fastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 5/8/96 sw: if shift key down, do find window.	 7/23/96 sw: project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[reply _ (self perform: reply) startUp.			reply == nil ifTrue: [^ super controlActivity]].	^ self perform: reply! !!ScreenController class methodsFor: 'class initialization'!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them.  7/24/96 sw	11/4/96 sw: call installHyperSqueakScreenMenu"	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.	Smalltalk hyperSqueakPresent ifTrue: [self installHyperSqueakScreenMenu]!installHyperSqueakScreenMenu	"Install the variant of the screen menu containing the HyperSqueak submenu..  To restore the standard version, just set the TopScreenMenu class variable back to nil, or call ScreenController revertToStandardMenus, which does just that11/4/96 sw"	"ScreenController installHyperSqueakScreenMenu"	TopScreenMenu _ SelectionMenu labelList:		#('HyperSqueak...'			'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(1 2 7)		selections: #(hyperSqueakMenu restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit).	ProjectScreenMenu _ SelectionMenu labelList:		#('HyperSqueak...'			'exit project'			'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'quit...')		lines: #(1 3 8)		selections: #(hyperSqueakMenu exitProject restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs quit)! !!ScriptableMorph methodsFor: 'commands'!forward: dist	self position: self position +		(Point r: dist degrees: 270 - rotationDegrees) truncated!goto: aPoint in: frameCount	"Go to the given point in the given number of frames."	currentTask _ #goto.	startPlace _ self bounds center.	destinationPlace _ aPoint.	framesForTask _ frameCount.	framesLeft _ frameCount.!jumpto: aPoint	"Note: This command happens instantly, not over a number frames as the other commands do."	self setCenterPosition: aPoint.	framesLeft _ 0.!left: degrees	self rotationDegrees: self rotationDegrees + degrees.!repeat	"Start the script from the beginning. Allows looping."	self startOver.	self getNextTask.!right: degrees	self rotationDegrees: self rotationDegrees - degrees.!turn: degrees	self right: degrees.!wait: frameCount	"Pause for the given number of frames."	currentTask _ #wait.	framesForTask _ frameCount.	framesLeft _ frameCount.! !!ScriptableMorph methodsFor: 'accessing'!script	^ script!script: aString	script _ aString.	currentScriptLine _ script lineCount.!setCenterPosition: aPoint	self position: aPoint - (bounds center - bounds topLeft).! !!ScriptableMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'run script' action: #startOver.	aCustomMenu add: 'show script' action: #showScript.	aCustomMenu add: 'show position' action: #showPosition.	aCustomMenu add: 'hide script/position' action: #hideInfoSubmorph.!showPosition	self hideInfoSubmorph.	infoSubmorph _ StringCostumeMorph new		target: self;		getSelector: #center;		useDefaultFormat.	infoSubmorph position:		bounds center + (bounds width @ (infoSubmorph bounds height negated // 2)).	self addMorph: infoSubmorph.	infoSubmorph startStepping.	self layoutChanged.!showScript	self hideInfoSubmorph.	infoSubmorph _ StringCostumeMorph new		target: self;		getSelector: #script;		putSelector: #script:;		useStringFormat;		step.	infoSubmorph position:		bounds center + (bounds width @ (infoSubmorph bounds height negated // 2)).	self addMorph: infoSubmorph.	infoSubmorph startStepping.	self layoutChanged.!startOver	currentScriptLine _ 0.	currentTask _ #idle.! !!ScriptableMorph methodsFor: 'stepping '!step	"This implements a simple state machine to do one frame of the current task."	| deltaP |	super step.	#wait = currentTask ifTrue: [framesLeft _ framesLeft - 1].	#goto = currentTask ifTrue: [		framesLeft _ framesLeft - 1.		deltaP _ (framesLeft asFloat / framesForTask) * (startPlace - destinationPlace).		self setCenterPosition: destinationPlace + deltaP truncated].	framesLeft <= 0 ifTrue: [self getNextTask].!stepTime	^ 50! !!ScriptableMorph methodsFor: 'private'!getNextTask	| action |	action _ ''.	[action isEmpty] whileTrue: [		"skip blank lines"		action _ script lineNumber: currentScriptLine + 1.		action ifNil: [			currentTask _ #idle.			framesLeft _ 0.			^ self].		currentScriptLine _ currentScriptLine + 1].	Compiler evaluate: 'self ', action for: self logged: false.!hideInfoSubmorph	infoSubmorph ifNotNil: [		self changed.		infoSubmorph delete.		infoSubmorph _ nil.		self layoutChanged].!initialize	super initialize.	script _ 'wait: 10'.	currentScriptLine _ 0.	currentTask _ #idle.	framesForTask _ 0.	framesLeft _ 0.	startPlace _ 0@0.	destinationPlace _ 0@0.! !!ScriptEditorMorph methodsFor: 'initialization'!initialize	super initialize.	color _ self defaultColor.	orientation _ #vertical.	hResizing _ #spaceFill.	vResizing _ #shrinkWrap.	borderWidth _ 2.	inset _ 10.	firstTileRow _ 1.  "index of first tile-carrying submorph"	self addNewRow.!setMorph: anActorMorph scriptName: aString	"Create a script editor for editing a named script."	myMorph _ anActorMorph.	scriptName _ aString.	self addMorphFront: self buttonRowForEditor.	self addMorphFront:		(StringMorph new contents:			scriptName, ' script for ', anActorMorph nameInModel).	firstTileRow _ 3.!setMorph: aMorph tilesFor: cmdEntry	"Create a script editor for immediate expression evaluation. It has a tryMe button rather than the accept/revert buttons."	| cmd args r |	myMorph _ aMorph.	cmd _ cmdEntry first asSymbol.	args _ cmdEntry allButFirst.	self addMorphFront: self buttonRowForEvaluator.	r _ submorphs last.	r addMorphBack: (TileMorph new setObjectRef: aMorph nameInModel).	r addMorphBack: (TileMorph new setOperator: cmd).	args isEmpty ifFalse: [		r addMorphBack: (TileMorph new setLiteral: args first)].	firstTileRow _ 2.! !!ScriptEditorMorph methodsFor: 'dropping/grabbing'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	| r |	((aMorph isKindOf: ScriptEditorMorph) or:	 [aMorph isKindOf: CommandTilesMorph]) ifTrue: [		r _ self insertionRowAt: aMorph center.		aMorph allTiles do: [:t | r acceptDroppingMorph: t event: evt].		aMorph delete.	] ifFalse:  [		r _ self targetRowFor: aMorph.		r ifNil: [r _ self addNewRow].		r acceptDroppingMorph: aMorph event: evt].	self scriptEdited.	self layoutChanged.!insertionRowAt: aPoint	"Return a row to be used to insert an entire row of tiles."	| i row |	i _ self rowInsertionIndexFor: aPoint.	row _ submorphs at: i.	(row isLayoutMorph and: [row submorphCount = 0])		ifTrue: [^ row].  "use an existing empty row"	"create a new row for the insertion"	aPoint y > row center y ifTrue: [i _ i + 1].	row _ LayoutMorph newRow		vResizing: #rigid;		extent: (bounds width)@(TileMorph new defaultH + 2);		color: self defaultColor.	self privateAddMorph: row atIndex: i.	self layoutChanged.	^ row!rootForGrabOf: aMorph	"Allow TileMorphs to be extracted, and note that script has changed."	| root |	root _ aMorph.	[root = self] whileFalse: [		(root isKindOf: TileMorph) ifTrue: [			self scriptEdited.			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph!rowInsertionIndexFor: aPoint	"Return the row into which the given morph should be inserted."	| m |	firstTileRow to: submorphs size do: [:i |		m _ submorphs at: i.		((m top <= aPoint y) and: [m bottom >= aPoint y]) ifTrue: [^ i]].	^ submorphs size!targetRowFor: aMorph	"Return the row into which the given morph should be inserted."	| firstRow centerY m |	firstRow _ nil.	centerY _ aMorph fullBounds center y.	firstTileRow to: submorphs size do: [:i |		m _ submorphs at: i.		(m isLayoutMorph and: [m orientation = #horizontal]) ifTrue: [			firstRow ifNil: [firstRow _ m].			((m bounds top <= centerY) and:			 [centerY <= m bounds bottom]) ifTrue: [^ m]]].	firstRow ifNil: [^ self addNewRow].	centerY < firstRow bottom ifTrue: [^ firstRow].	^ nil!wantsDroppedMorph: aMorph event: evt	^ (aMorph isKindOf: TileMorph) or:	   [(aMorph isKindOf: ScriptEditorMorph) or:	   [aMorph isKindOf: CommandTilesMorph]]! !!ScriptEditorMorph methodsFor: 'buttons'!buttonRowForEditor	| r |	r _ LayoutMorph newRow color: self defaultColor.	r addMorphBack:		(SimpleButtonMorph new label: 'install';			target: self;			actionSelector: #install).	r addMorphBack:		(SimpleButtonMorph new label: 'revert';			target: self;			actionSelector: #revert).	r addMorphBack:		(SimpleButtonMorph new label: 'try me!!';			target: self;			actionSelector: #tryMe).	r addMorphBack:		(SimpleButtonMorph new label: 'dismiss';			target: self;			actionSelector: #dismiss).	^ r!buttonRowForEvaluator	| r |	r _ LayoutMorph newRow color: self defaultColor.	r addMorphBack: 		(SimpleButtonMorph new label: 'try me!!';			target: self;			actionSelector: #tryMe).	r addMorphBack:		(SimpleButtonMorph new label: 'dismiss';			target: self;			actionSelector: #dismiss).	^ r!dismiss	self delete.!install	self color: self defaultColor.	self removeEmptyRows.	myMorph acceptScript: self for: 'onTicks'.	self revert.!revert	| w newEditor |	w _ self world.	self delete.	newEditor _ myMorph scriptEditorFor: scriptName.	newEditor position: self position.	w addMorph: newEditor.!tryMe	self removeEmptyRows.	self color: self defaultColor.	Compiler evaluate:		self codeString		for: self world model		logged: false.! !!ScriptEditorMorph methodsFor: 'other'!addNewRow	| row |	row _ LayoutMorph newRow		vResizing: #rigid;		extent: (bounds width)@(TileMorph new defaultH + 2);		color: self defaultColor.	self addMorphBack: row.	^ row!allTiles	| tiles |	tiles _ OrderedCollection new.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue: [tiles add: m]].	^ tiles!codeString	| s lastOwner |	s _ WriteStream on: ''.	lastOwner _ nil.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue: [			((m owner ~= lastOwner) and: [lastOwner ~= nil]) ifTrue: [				s nextPut: $.; cr; tab.				m storeCodeOn: s.			] ifFalse: [				(lastOwner ~= nil) ifTrue: [s space].				m storeCodeOn: s].			lastOwner _ m owner]].	^ s contents!defaultColor	^ Color r: 0.8 g: 1.0 b: 0.8!methodString	| s |	s _ WriteStream on: ''.	s nextPutAll: (myMorph nameInModel, scriptName); cr; cr; tab.	s nextPutAll: self codeString.	^ s contents!removeEmptyRows	submorphs copy do: [:m |		(m isLayoutMorph and: [m submorphCount = 0])			ifTrue: [m delete]].	self fullBounds.	self layoutChanged.!scriptEdited	self color: (Color r: 1.0 g: 0.6 b: 0.6).! !!ScrollBarMarkerMorph methodsFor: 'events'!mouseDown: evt	super mouseDown: evt.	self color: (oldColor mixed: 1/2 with: Color white).	offset := evt cursorPoint-self position!mouseMove: evt	target perform: actionSelector with: evt cursorPoint - offset! !!ScrollBarMarkerMorph class methodsFor: 'as yet unclassified'!new	^ super new actWhen: #whilePressed! !!ScrollBarMorph methodsFor: 'initialize-release'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderColor := #inset.	borderWidth := 2.	topFraction := 0.1.	bottomFraction := 0.5.	self initializeUpButton; initializeDownButton; initializeMarker!initializeDownButton	downButton := SimpleButtonMorph newBounds: (bounds corner- (14@14) extent: 12@12) color: Color lightGray.	downButton target: self; actionSelector: #scrollDown; actWhen: #whilePressed.	downButton removeAllMorphs.	downButton addMorph: (ImageMorph new image: DownArrow; position: 2@2+downButton position).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton!initializeMarker	marker := ScrollBarMarkerMorph newBounds: (bounds origin + (2@16) extent: bounds extent-(4@32)) color: Color lightGray.	marker target: self; actionSelector: #scrollAbsolute:.	marker removeAllMorphs.	marker setBorderWidth: 2 borderColor: #raised.	self computeMarker.	self addMorph: marker!initializeUpButton	upButton := SimpleButtonMorph newBounds: (bounds origin + (2@2) extent: 12@12) color: Color lightGray.	upButton target: self; actionSelector: #scrollUp; actWhen: #whilePressed.	upButton removeAllMorphs.	upButton addMorph: (ImageMorph new image: UpArrow; position: 2@2+ upButton position).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBarMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set scrolled morph' action: #setScrolledMorph! !!ScrollBarMorph methodsFor: 'geometry'!computeMarker	| totalArea scrolled |	totalArea := self totalMarkerArea.	marker bounds: (totalArea left@(totalArea top + (totalArea height * topFraction))rounded corner: totalArea right@(totalArea top + (totalArea height * bottomFraction))rounded).	scrolled := self scrolledMorph.	scrolled ifNotNil: [scrolled scrollOffset: 0@(topFraction negated * scrolled superFullBounds height) rounded].	!extent: aPoint	super extent: 16@(aPoint y max: 48).	downButton position: bounds corner-(14@14).	self computeMarker!minHeight	^48!minWidth	^16!totalMarkerArea	^upButton bounds bottomLeft corner: downButton bounds topRight! !!ScrollBarMorph methodsFor: 'classification'!hResizing	^false!isLayoutMorph	^true!layoutInExtent: aPoint	self extent: aPoint!vResizing	^true! !!ScrollBarMorph methodsFor: 'scrolling'!scrollAbsolute: pt	| area f |	area := self totalMarkerArea.	f := pt y - area top / area height asFloat.	topFraction := (f max: 0) min: 0.9.	bottomFraction := (f + 0.2 max: 0.1) min: 1.	self computeMarker!scrollDown	topFraction := topFraction + 0.05 min: 0.9.	bottomFraction := bottomFraction + 0.05 min: 1.	self computeMarker!scrolledMorph	| sub i scrolled |	owner == nil ifTrue: [^ nil].	sub := owner submorphs.	sub size < 2 ifTrue: [^ nil].	i := sub indexOf: self.	i > 1 ifTrue: [scrolled := sub at: i-1]  "Default is to scroll neighbor on left"		ifFalse: [scrolled := sub at: i+1].	"...but will work on right"	(scrolled isKindOf: ScrollClipTestMorph) ifFalse: [^ nil].	^ scrolled	!scrollUp	| scrolled |	scrolled := self scrolledMorph.	scrolled ifNotNil: [scrolled scrollOffset: scrolled scrollOffset + (0@2)].	topFraction := topFraction - 0.05 max: 0.	bottomFraction := bottomFraction - 0.05 max: 0.1.	self computeMarker! !!ScrollBarMorph class methodsFor: 'class initialization'!initialize	"ScrollBarMorph initialize"	UpArrow := Form	extent: 8@8	fromArray: #( 0 402653184 1006632960 2113929216 402653184 402653184 402653184 0)	offset: 0@0.	DownArrow := UpArrow flipBy: #vertical centerAt: 0@0! !!ScrollClipTestMorph methodsFor: 'initialization'!comment"	This morph is the beginning of a scrolling/clipping viewer of submorphs.It also supports passing mouse events into submorphs with the proper offset,and lets you invoke the meta-menu on submorphs. It doesn't yet do somethingsensible with the scroll offset when embedding.For testing, you can scroll around by shift-mousing on the background (notover a submorph, or the submorph grabs the event) and dragging.You should embed a few submorphs first, so you can see them scroll about.If you embed something mouse sensitive, it should still be mouse sensitive,although it needs a bit more work to map event positions properly.There seems to be a problem with string clippling. Try embedding a stringso that it hangs over the edge, then wave the mouse over it. You'll see itdraw outside the clipping box. I'm not sure where this bug is."!initialize	super initialize.	scrollOffset _ 0@0.! !!ScrollClipTestMorph methodsFor: 'accessing'!scrollOffset	^ scrollOffset!scrollOffset: aPoint	scrollOffset _ aPoint.	self changed! !!ScrollClipTestMorph methodsFor: 'submorphs-accessing'!morphsAt: aPoint	"Overridden to handle offset."	| p mList |	p _ aPoint - scrollOffset.	mList _ OrderedCollection new.	self allMorphsDo: [: m | (m containsPoint: p) ifTrue: [mList addLast: m]].	((self containsPoint: aPoint) and: [(mList includes: self) not])		ifTrue: [mList addLast: self].	^ mList! !!ScrollClipTestMorph methodsFor: 'drawing'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	clippingCanvas _ aCanvas copyOrigin: scrollOffset clipRect: bounds.	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!ScrollClipTestMorph methodsFor: 'geometry'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds!superFullBounds	fullBounds := nil.	^super fullBounds! !!ScrollClipTestMorph methodsFor: 'change reporting'!changed	"Needs to be overridden to call superclass's invalidRect:."	super invalidRect: self fullBounds.!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNotNil:		[owner invalidRect: (damageRect translateBy: scrollOffset)].! !!ScrollClipTestMorph methodsFor: 'events'!inputEventTransform	"Return a transform to be used to transform the position of incoming input events into local coordinates."	| transform |	transform _ MorphicTransform offset: scrollOffset negated.	owner ifNotNil: [transform _ super inputEventTransform composedWith: transform].	^ transform!mouseDown: evt	"For testing; to be replaced by scrollbars."	evt shiftPressed		ifTrue: [evt hand newMouseFocus: self]		ifFalse: [^ super mouseDown: evt].!mouseMove: evt	"For testing; to be replaced by scrollbars."	scrollOffset _ evt cursorPoint - bounds origin.	self changed.!mouseRecipientAt: aPoint	"Adjust the given point by my scroll offset before passing it to my submorphs."	| adjustedPoint recipient |	adjustedPoint _ aPoint - scrollOffset.	self submorphsDo: [:m |		(m fullBounds containsPoint: adjustedPoint) ifTrue: [			recipient _ m mouseRecipientAt: adjustedPoint.			recipient ifNotNil: [^ recipient]]].	(self containsPoint: aPoint)		ifTrue: [^ self]		ifFalse: [^ nil].! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar _ Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker _ Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar _ Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker _ marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea _ Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar _ Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'control defaults'!isControlActive 	view isNil ifTrue: [^ false].	^ (view insetDisplayBox merge: scrollBar inside)		containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'scrolling'!downLine	"if cursor before downLine, display down cursor and scroll down on button down"	^scrollBar left + 6 !upDownLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 12!upLine	"if cursor beyond upLine, display up cursor and scroll up on button down"	^scrollBar left + 12!yellowLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 16! !!ScrollController methodsFor: 'marker adjustment'!computeMarkerRegion	"Answer the rectangular area in which the gray area of the scroll bar 	should be displayed."	^0@0 extent: Preferences scrollBarWidth @			((view window height asFloat /						view boundingBox height *							scrollBar inside height)				 rounded min: scrollBar inside height)!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker _ marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !ScrollThing comment:'This entire class was built by...	Start with WorldMorph new open.	Add a rectangle.	Add an Ellipse.	Embed the ellipse in the rectangle (call it thumber).	Choose save-as-model.	Look at the new class in Morphic-Models category.	Edit the methods for thumberMouseMove: and scrollPosPut:, as here.	Override the default for newBounds:, as here.'!!ScrollThing methodsFor: 'initialization'!initMorph	thumber _ MouseSensorMorph newBounds: (40@41 corner: 90@81) model: self slotName: 'thumber'.	self addMorph: (((RectangleMorph newBounds: (33@37 corner: 407@88) color: Color gray) setBorderWidth: 3 borderColor: Color black)		addAllMorphs: (Array		with: (((EllipseMorph newBounds: (40@41 corner: 90@81) color: Color yellow) setBorderWidth: 1 borderColor: Color black)			addAllMorphs: (Array			with: thumber)))).!newBounds: newBounds	super newBounds: newBounds.	submorphs first bounds: newBounds! !!ScrollThing methodsFor: 'mouse events'!thumberMouseDown: evt morph: m!thumberMouseMove: evt morph: m	| r p |	p _ evt targetPoint adhereTo: (r _ m owner innerBounds insetBy: (0@0 extent: m extent)).	m position: p.	self scrollPos: (r width > r height 		ifTrue: [(m position x - r left) asFloat / r width asFloat]		ifFalse: [(m position y - r top) asFloat / r height asFloat])!thumberMouseUp: evt morph: m! !!ScrollThing methodsFor: 'public access'!scrollPos	"Return the value of scrollPos"	^ scrollPos!scrollPosPut: newValue	"Assign newValue to scrollPos.	Add code below to update related graphics appropriately..."	| m dir |	scrollPos _ newValue.	m _ thumber owner.	dir _ m owner width > m owner height		ifTrue: [1@0]		ifFalse: [0@1].	m position: m owner innerBounds origin + (m owner innerBounds extent - m extent * dir * scrollPos) asIntegerPoint! !!ScrollThing methodsFor: 'private - propagation'!scrollPos: newValue	"Assigns newValue to scrollPos and updates owner"	scrollPos _ newValue.	self propagate: scrollPos as: 'scrollPos:'! !!SelectionMenu methodsFor: 'basic control sequence'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object	 the selector corresponding to the menu item selected by the user. Return	 nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"(SelectionMenu labels:'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'marker management'!manageMarker	"Returns the selected item. If no selection, return nil."	super manageMarker.	(selections = nil or: [(selection between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: selection! !!SelectionMenu class methodsFor: 'instance creation'!confirm: queryString 	"Put up a yes/no menu with caption queryString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"SelectionMenu confirm: 'Are you hungry?'"	| menu choice |	menu _ self selections: #('yes' 'no').	[true] whileTrue: [		choice _ menu startUpWithCaption: queryString.		choice = 'yes' ifTrue: [^ true].		choice = 'no' ifTrue: [^ false]]!labels: aString lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	^ (self labels: aString lines: linesArray) selections: selectionsArray!labels: aString selections: selectionsArray	"Answer an instance of me whose items are in aString, recording	 the given array of selections corresponding to the items in aString."	^ self labels: aString lines: #() selections: selectionsArray!selections: aList	"Answer an instance of me whose labels and selections are identical.  6/27/96 sw"	^ self labelList: aList lines: nil selections: aList!selections: aList lines: lineList	"Answer an instance of me whose labels and selections are identical"	^ self labelList: aList lines: lineList selections: aList! !!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder litIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!SequenceableCollection methodsFor: 'accessing'!allButFirst	^ self copyFrom: 2 to: self size!allButLast	^ self copyFrom: 1 to: self size - 1!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	start to: self size do:		[:i | (self at: i) = anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'copying'!copyAt: anIndex put: anElement	"Answer a copy of the receiver with anElement inserted at anIndex."	^ self copyReplaceFrom: anIndex to: anIndex with: (Array with: anElement)! !!SequenceableCollection methodsFor: 'enumerating'!pairsDo: aBlock 	"March through the receiver two elements at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  12/23/96 sw"	| i |	1 to: self size // 2 do:		[:index |			i _ 2 * index - 1.			 aBlock value: (self at: i) value: (self at: i + 1)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'converting'!reversed	"Answer a copy of the receiver with element order reversed.  1/26/96 sw.	Rewritten to work for more classes.  11/18/96 di"	^ self species streamContents:		[:strm | self reverseDo: [:elem | strm nextPut: elem]]" 'frog' reversed "! !!SequenceableCollection methodsFor: 'private'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth, 12/8/96: startSearch must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isKindOf: String) not])		ifTrue: [self error: 'Token replacement only valid for Strings'].	aString _ self.	startSearch _ 1.	[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex _ currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString _ aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch _ currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch _ currentIndex + 1]					ifFalse: [startSearch _ currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequentialSound methodsFor: 'sound generation'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"Play a collection of sounds in sequence."	"PluckedSound chromaticScale play"	| finalIndex i snd remaining count |	currentIndex = 0 ifTrue: [ ^ self ].  "already done"	finalIndex _ (startIndex + n) - 1.	i _ startIndex.	[i <= finalIndex] whileTrue: [		snd _ (sounds at: currentIndex).		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [			"find next undone sound"			currentIndex < sounds size ifTrue: [				currentIndex _ currentIndex + 1.				snd _ (sounds at: currentIndex).			] ifFalse: [				currentIndex _ 0.				^ self  "no more sounds"			].		].		count _ (finalIndex - i) + 1.		remaining < count ifTrue: [ count _ remaining ].		snd mixSampleCount: count into: aSoundBuffer startingAt: i pan: pan.		i _ i + count.	].! !!Set methodsFor: 'private'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index _ self scanFor: anObject.	index > 0 ifTrue: [ ^ index ].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'accessing'!asArray	"Return an array whose elements are those of the receiver.  12/2/96 sw"	^ self asOrderedCollection asArray!someElement	"Return some element of the Set.  2/14/97 tk"	^ array detect: [:each | each ~~ nil] ifNone: [ nil]! !!Set methodsFor: 'objects from disk'!readDataFrom: aDataStream size: anInteger	"Symbols have new hash in this world.  1/8/97 tk"	| aSet |	aSet _ super readDataFrom: aDataStream size: anInteger.	aSet rehash.	^ aSet! !!Set class methodsFor: 'instance creation'!readDataFrom: aDataStream size: anInteger	"Symbols have new hash in this world.  9/7/96 tk"	| aSet |	self halt.	aSet _ super readDataFrom: aDataStream size: anInteger.	aSet rehash.	^ aSet! !!SimpleButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self borderWidth: 1.	self borderColor: #raised.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	self label: 'Flash'.! !!SimpleButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].!setActionSelector	| newSel |	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed'		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].!setActWhen	actWhen _ (SelectionMenu selections: #(buttonDown buttonUp whilePressed))		startUpWithCaption: 'Choose one of the following conditions'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil. ^ self].! !!SimpleButtonMorph methodsFor: 'accessing'!actionSelector	^ actionSelector!actionSelector: aSymbolOrString	actionSelector _ aSymbolOrString asSymbol.!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen _ condition!arguments	^ arguments!arguments: aCollection	arguments _ aCollection asArray copy.!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s!label: aString	| m |	self removeAllMorphs.	m _ StringMorph new contents: aString.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.!target	^ target!target: anObject	target _ anObject! !!SimpleButtonMorph methodsFor: 'events'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].!mouseDown: evt	oldColor _ color.	evt hand newMouseFocus: self.	actWhen == #buttonDown		ifTrue: [self doButtonAction].!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].!mouseRecipientAt: aPoint	"The buck stops here!! This morph catches and handles mouse events and prevents them from being passed to its submorphs."	^ self!mouseUp: evt	self color: oldColor.	(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!SketchMorph methodsFor: 'initialization'!initialize	super initialize.	originalForm _ Form extent: 6@6.	rotationCenter _ 3@3.		"relative to the top-left corner of the Form"	rotationDegrees _ 0.0.		"counter-clockwise angle of rotation"	framesToDwell _ 1.	rotatedForm _ originalForm.	"cached rotation of originalForm"	offsetWhenRotated _ 0@0.	"offset for rotated form"! !!SketchMorph methodsFor: 'accessing'!form	^ originalForm!form: aMaskedForm	originalForm _ aMaskedForm.	rotationCenter _ aMaskedForm extent // 2.	self layoutChanged.!framesToDwell	^ framesToDwell!framesToDwell:  anInteger	framesToDwell _ anInteger.!referencePosition	^ (bounds origin - offsetWhenRotated) + rotationCenter!referencePosition: aPoint	self position: (aPoint - rotationCenter) + offsetWhenRotated.!rotationCenter	^ rotationCenter!rotationCenter:  aPoint	rotationCenter _ aPoint.	self layoutChanged.!rotationDegrees	^ rotationDegrees!rotationDegrees: angleInDegrees	rotationDegrees ~=  angleInDegrees ifTrue: [		rotationDegrees _ angleInDegrees.		self layoutChanged].! !!SketchMorph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas image: rotatedForm at: bounds origin.! !!SketchMorph methodsFor: 'geometry-testing'!containsPoint: aPoint	^ (rotatedForm mask colorAt: aPoint - bounds origin) = Color black! !!SketchMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'edit drawing' action: #editDrawing.	aCustomMenu add: 'set rotation center' action: #setRotationCenter.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue: [		aCustomMenu add: 'insert into movie' action: #insertIntoMovie:].!editDrawing	self editDrawingInWorld: self world.!editDrawingInWorld: w	| oldRotation formAndBounds |	oldRotation _ rotationDegrees.	self rotationDegrees: 0.	w displayWorld.	formAndBounds _ MPaintWindow editPainting: originalForm		offset: self position inRectangle: w viewBox.	"formAndBounds is array of (maskedForm, boundingRectangle) or nil"	formAndBounds ifNil: [^ self].	w fullRepaintNeeded.	self form: formAndBounds first.	self position: formAndBounds last origin.	self rotationDegrees: oldRotation.!insertIntoMovie: evt	| movies target |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	target _ movies first.	(target isKindOf: SketchMorph) ifTrue: [		target _ target replaceSelfWithMovie].	target insertFrames: (Array with: self).	self delete.!replaceSelfWithMovie	"Replace this SketchMorph in its owner with a MovieMorph containing this sketch as its only frame. This allows a SketchMorph to be turned into a MovieMorph by just insering additional frames."	| movie |	self changed.	movie _ MovieMorph new position: self referencePosition.	movie insertFrames: (Array with: self).	owner ifNil: [^ movie].	owner addMorphFront: movie.	self delete.	^ movie!setRotationCenter	| oldRotation p |	oldRotation _ rotationDegrees.	self rotationDegrees: 0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	self rotationCenter: p - bounds origin.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'change reporting'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin pair |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	"do the actual rotation!!"	pair _ WarpBlt rotate: originalForm degrees: rotationDegrees center: rotationCenter smoothing: 1.	rotatedForm _ pair first.	offsetWhenRotated _ pair last.	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other'!wearCostume: aMorph	"If the receiver and argument are both kinds of SketchMorph, make the receiver wear the costume of the argument. Otherwise, do nothing. This default implementation does nothing."	((aMorph isKindOf: SketchMorph) or:	 [aMorph isKindOf: MovieMorph])		ifTrue: [^ self form: aMorph form].! !!SketchMorph class methodsFor: 'class initialization'!initialize	"SketchMorph initialize"	UpArrow _ Form		extent: 8@8		fromArray: #(0 402653184 1006632960 2113929216 402653184 402653184 402653184 0)		offset: 0@0.	DownArrow _ UpArrow flipBy: #vertical centerAt: 0@0.! !!SmallInteger methodsFor: 'comparing'!hash	^self!identityHash	^self! !!SmallInteger methodsFor: 'printing'!printOn: aStream base: b	"Refer to the comment in Integer|printOn:base:."	"SmallInteger maxVal printStringBase: 2"	| digitsInReverse x i |	self < 0 ifTrue: [		aStream nextPut: $-.		^ self negated printOn: aStream base: b.	].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	digitsInReverse _ Array new: 32.	x _ self.	i _ 0.	[x >= b] whileTrue: [		digitsInReverse at: (i _ i + 1) put: x \\ b.		x _ x // b.	].	digitsInReverse at: (i _ i + 1) put: x.	[i > 0] whileTrue: [		aStream nextPut: (Character digitValue: (digitsInReverse at: i)).		i _ i - 1.	].! !SmartRefStream comment:'Ordinary ReferenceStreams cannot bring in objects whose instance variables have changed.  This class does that.  See SmartRefStream.aComment for details of how to use me.  1/13/97 tk Allows incoming object to have fewer instance variables than the current class. Recognises that conversion to new versions is only done after the fact.  Nothing special needs to be done at object file write time.  Prompts for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written. Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure, which is big.  Writes triplets of (version, class structure dictionary, object) on the file.  Has methods for creating the structure description for file-out. Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset ", so version 2 of it has version tag #bwhdo2. Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.Note that aDictionary has (old inst var name -> value)  There is a dispatch method to avoid N squared conversions when there are lots of old versions.  It can cascade calls on conversion methods. (not yet) Prompts the user to write (or file in) a conversion method when needed. (Does not use DiskProxy, DiskProxyQ, or IOWeakArray)writing		true if writing a file.  To avoid mixing next with nextPut:.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> origin corner)).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except some added on end now.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: coming from the outside.  nil if outside, a Context if 				internal call. '!!SmartRefStream methodsFor: 'object structure'!aComment"SmartRefStream implements the 'Seeds' object storage system.  Please see the class comment.Headlines:	To bring in an instance of a class whose instance variables have changed, you need only define one conversion method.  The method is named	convertxxxxx: aDictionary yyyyyy: aSmartRefStream.Where xxxxxx is the first letters of all the instance variables in the old instance, and yyyyy are the first letters of all instance variables in the current version of the class.  A Form has inst vars 'bits width height depth offset', so version 2 of it has version tag #bwhdo2.  If the old instance had variables 'bitMap extent depth offsetPoint textDescription', its code would be #bedot0.	Form new convertbedot0: aDictionary bwhdo3: aSmartRefStream.All you have to do is to write the method.  aDictionary has entries (old inst var name -> value), so you can fetch the old vars by name.  See SmartRefStream.catalogValues:size:.  aSmartRefStream is available so you can get at 'structures' which tells the inst vars of other old classes in this file.In the Squeak Goodies Folder, we provide an example.	Suppose there once was a file named ArrayTwoDee.  If it like Array2D in this system, but is implemented differently.  ArrayTwoDee was defined like this: (Array variableSubclass: #ArrayTwoDee instanceVariableNames: 'height '...) so it is a variable class with the array values directly in the instance.  	Array2D uses an instance var for 'contents' instead.   It has width varying most quickly, whereas the old ArrayTwoDee had height varying first.  The order of the elements must be changed.	File in the file ConvArrayTwoDee2.st.It defines SmartRefStream.arrayTwoDeeh2 to return Array2D, so we know what class to convert to.It defines Array2D.converth2:wc0: to do the actual conversion.  Look at the method.  The method 'test' has the code for actually doing the conversion:	| new2D ss |	ss _ SmartRefStream fileNamed: 'ArrayTwoDee.test.obj'.	new2D _ ss next.	ss close.	new2D class == Array2D ifFalse: [self error: 'Class conversion failed'].	(new2D atCol: 1) = #(1 2 3 4) ifFalse: [self error: 'not flipped properly'].	^ new2D	The file ArrayTwoDee.test.obj has the object data in it, and is the actual file we converted.  Note that we never had to file in the old class ArrayTwoDee.  It is never needs to be defined in our system.  	If ArrayTwoDee held an instance variable of another old class, say WeirdNumber, what form would it be in when converth2:wc0: gets run?  All objects get assigned instances in the current system before they are put into the value dictionary.  Generally, leaves of the object tree get converted first, so the values in an instance variable should be fully functioning objects in the current system."!catalogValues: instVarList size: varsOnDisk	"Create a dictionary of (name -> value) for the inst vars of this reshaped object.  Indexed vars as (1 -> val) etc.  1/7/97 tk"	| dict sz |	dict _ Dictionary new.	2 to: instVarList size do: [:ind |		dict at: (instVarList at: ind) put: self next].	sz _ varsOnDisk - (instVarList size - 1).	1 to: sz do: [:ii | 		dict at: ii put: self next].	"Total number read MUST be equal to varsOnDisk!!"	sz > 0 ifTrue: [dict at: #SizeOfVariablePart put: sz].	^ dict!fixObjVer1: className	"Temporary bug fix.  Old obj files have no structure entry for Obj and other HyperSqueak classes that have unique instances.  Add the data to structures.  Will also have to read in ObjConvertDec96.st  1/10/97 tk"	| data ind |	Smalltalk at: #Obj ifAbsent: [^ self].	"non HyperSqueak"	data _ #( "Alias" ()  "BooleanObj" ()  "FastObj" ('blitter' 'fastVelocity ') 		"Folder" ('contentsDictionary') "NumberObj" () 		"Obj" (0 'dependents' 'objectContainedIn' 'workingsBackToFront' 'workingsDictionary' 'contents' 'costumes' 'currentCostume' 'parameters' 'canvas' 'canvasValid' 'layoutRectangle' 'windowBounds' 'flags' 'velocity' 'type' 'heading' 'speed' 'pen' )		"StringObj" ()  "TextObj" ('prevTextFrame' 'nextTextFrame' 'suppressDisplay')).	ind _ #(Alias BooleanObj FastObj Folder NumberObj Obj StringObj TextObj) indexOf: className.	ind = 0 ifTrue: [^ self].	structures at: className put: 		(className == #Obj				ifTrue: [data at: ind]				ifFalse: [(data at: 6 "Obj"), (data at: ind)]).	self verifyStructure!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  1/6/97 tk"	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs classes cls |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy nextPut: anObject.	refs _ dummy references.	classes _ Dictionary new.		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		(cls category asString = 'HyperSqueak-UserObjects') 			ifTrue: [classes at: cls officialClass name put: false] 			ifFalse: [classes at: cls name put: false]].	"Save work by only computing inst vars once for each class"	classes keysDo: [:nm | 		cls _ Smalltalk at: nm.		classes at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames))].	^ Array with: 'class structure' with: classes!mapClass: nm	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  1/8/97 tk"	| cls oldVer sel |	cls _ Smalltalk at: nm ifAbsent: [nil].	cls == nil ifFalse: [^ cls]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol.			renamed at: nm put: cls name.			^ cls]].	"This class will take responsibility"	"Never heard of it!!"	self close.	self error: nm,' does not exist.  Please define the method ',					sel,' in class SmartRefStream to return new class'.		"you need to restart the read-in"	"Look around for an existing file-in that has all the conversion methods in it.  If none, pick a class who will take responsibility for converting the instances.  Define a method convertOldVer:newVer: to move instance variables and translate."!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  1/6/97 tk"	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ thisContext.			writing _ false.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			self verifyStructure.			writing _ #Unclassed.	"Pass 1"			object _ super next.	"all the action here"			topCall _ writing _ nil.	"reset it"			object]		ifFalse:			[super next]!nextPut: anObject	"Really write three objects: (version, class structure, object). But only when called from the outside.  1/6/97 tk"	topCall == nil 		ifTrue:			[topCall _ thisContext.  writing _ true.			super nextPut: ReferenceStream versionCode.			super nextPut: (self instVarInfo: anObject).			super nextPut: anObject.			topCall _ writing _ nil]	"reset it"		ifFalse:			[super nextPut: anObject].!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next. jhm.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used in the structures dictionary itself need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	(Smalltalk includesKey: className) ifTrue: [		newClass _ Smalltalk at: className.		(steady includes: newClass) ifTrue: [		 	anObject _ newClass isVariable "Create it here"				ifFalse: [newClass basicNew]				ifTrue: [newClass basicNew: instSize - (newClass instSize)].			anObject _ anObject readDataFrom: self size: instSize.			self setCurrentReference: refPosn.  "before returning to next"			^ anObject]].	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	oldInstVars _ structures at: className ifAbsent: [		self fixObjVer1: className.		structures at: className ifAbsent: [			self error: 'class is not in structures list']].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	anObject perform: (reshaped at: className) with: dict with: self.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject!renamed	^ renamed!setStream: aStream	"Initialize me. 1/9/97 tk"	super setStream: aStream.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped _ Dictionary new.			"(old class name -> method selector to fill in data for version to version)"	renamed _ Dictionary new.		"(old class name symbol -> new class name)"!structures	^ structures!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).  1/6/97 tk"| ext sel newClass oldVer newList newVer |structures keysDo: [:nm "a symbol" |	"For missing classes, there needs to be a method in SmartRefStream like 		#rectangleoc2 that returns the new class."	newClass _ self mapClass: nm.		"does (renamed at: nm put: newClass name)"	oldVer _ self versionSymbol: (structures at: nm).	newList _ (Array with: newClass classVersion), (newClass allInstVarNames).	newVer _ self versionSymbol: newList.	sel _ 'convert',oldVer,':',newVer, ':'.			"method name of conversion routine that is send after the object is created."	Symbol hasInterned: sel ifTrue: [:symb | 		reshaped at: nm put: symb].	(ext _ structures at: nm) = newList			ifTrue: [steady add: newClass]			ifFalse: [(ext size < newList size) & (newClass isVariable not)					ifTrue: [ext = (newList copyFrom: 1 to: ext size) 						ifTrue: ["I just have inst vars added"							steady add: newClass "a class"]]].	"May have to do some fixup"	(steady includes: newClass) ifFalse: [		(reshaped includesKey: nm) 			ifFalse: [				self close.	"If you get the error below, look around for an existing file-in that has all the conversion methods in it.  If you write methods, note that the class may need a version number change.  Beware of other object fileouts already written with the old version number, 2.  Your method must be able to read files that say version 2 but are really 3."				self error: nm,' has changed shape.  Please define the method ',					sel,' in class ', newClass name]]. "you need to restart the read-in"	(reshaped includesKey: nm) ifTrue: ["Does it really exist?"		(newClass canUnderstand: sel asSymbol) ifFalse: [			self close.			self error: nm,' has changed shape.  Please define the method ',				sel,' in class ', newClass name]]. "you need to restart the read-in"	"any other cases to test?"		].!versionSymbol: instVarList	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  1/7/97 tk"	| str |	str _ instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"	2 to: instVarList size do: [:ind |		str _ str, (instVarList at: ind) first asString].	str _ str, instVarList first printString.	"the number"	^ str" | ll | ll _ (Array with: Paragraph classVersion), (Paragraph allInstVarNames).(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: ll"!writing	^ writing! !!Socket methodsFor: 'initialize-destroy'!destroy	"Destroy this socket. Its connection, if any, is aborted."	socketHandle = nil ifFalse: [		self primSocketDestroy: socketHandle.		socketHandle _ nil.	].!initialize	"Create a new socket handle."	socketHandle _		self primSocketCreateNetwork: 0 type: 0			receiveBufferSize: 8000 sendBufSize: 8000 semaphoreID: 0.! !!Socket methodsFor: 'queries'!dataAvailable	"Return true if this socket has unread received data."	^ self primSocketReceiveDataAvailable: socketHandle!isConnected	"Return true if this socket is connected."	^ (self primSocketConnectionStatus: socketHandle) == Connected!isUnconnected	"Return true if this socket is completely disconnected."	^ (self primSocketConnectionStatus: socketHandle) == Unconnected!sendDone	"Return true if the most recent send operation on this socket has completed."	^ self primSocketSendDone: socketHandle!status	"Return the status of this socket; see my class initialization for possible values."	^ self primSocketConnectionStatus: socketHandle! !!Socket methodsFor: 'connection open/close'!close	"Close this connection gracefully."	self primSocketCloseConnection: socketHandle.  "close this end"!closeAndDestroy	"First, try to close this connection gracefully. If it times out, abort. In either case, destroy the socket and nil out its handle.  Do nothing if the socket handle is already nil."	socketHandle = nil ifFalse: [		self close.  "close this end"		(self waitForDisconnectionUntil: (Socket deadlineSecs: 20)) ifFalse: [			"if the other end doesn't close soon, just abort the connection"			self primSocketAbortConnection: socketHandle.		].		self destroy].!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!Socket methodsFor: 'sending-receiving'!discardReceivedData	"Discard any data received up until now."	| buf totalBytesRead |	buf _ String new: 1000.	totalBytesRead _ 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesRead _ totalBytesRead +			self primSocket: socketHandle				receiveDataInto: buf				startingAt: 1				count: buf size].	^ totalBytesRead!receivedDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: 1 count: aStringOrByteArray size!sendData: aStringOrByteArray	"Send some or all of the given data and return the number of bytes actually sent."	| bytesSent |	(self waitForSendDoneUntil: (Socket deadlineSecs: 20)) ifTrue: [		bytesSent _ self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: 1			count: aStringOrByteArray size.	] ifFalse: [		self error: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'other'!displayString: aString	"Display the given string on the Display. Used for testing."	| s |	aString isEmpty ifTrue: [^ self].	s _ aString copyFrom: 1 to: (60 min: aString size).	s asParagraph displayOn: Display.!endsWithSinglePeriodLine: aString	"Return true if the given string ends with a period on a line by itself."	| sz |	sz _ aString size.	^ ((sz > 2) and:	   [(aString at: sz) = CR and:	   [(aString at: sz - 1) = $. and:	   [(aString at: sz - 2) = CR]]])!getAndShowMultilineResponse	"Get a multi-line response to the last command. A multiline response ends with a line containing only a single period (.) character."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		chunk _ self getAndShowResponse.		response nextPutAll: chunk.		done _ self endsWithSinglePeriodLine: chunk.	].	^ response contents!getAndShowResponse	"Get the response to the last command."	| buf response bytesRead c line |	(self waitForDataUntil: (Socket deadlineSecs: 20)) ifFalse: [		self error: 'getResponse timeout'].	buf _ String new: 10000.	response _ WriteStream on: (String new: 10000).	line _ WriteStream on: (String new: 100).	[self dataAvailable] whileTrue: [		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.		1 to: bytesRead do: [ :i |			(c _ buf at: i) = LF				ifTrue: [self displayString: line contents. line _ WriteStream on: (String new: 100)]				ifFalse: [response nextPut: c. line nextPut: c]]].	^ response contents!getMultilineResponse	"Get a multiline response to the last command. A multiline response ends with a line containing only a single period."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		chunk _ self getResponse.		response nextPutAll: chunk.		done _ self endsWithSinglePeriodLine: chunk].	^ response contents!getResponse	"Get the response to the last command."	| buf response bytesRead c |	(self waitForDataUntil: (Socket deadlineSecs: 20)) ifFalse: [		self error: 'getResponse timeout'].	buf _ String new: 1000.	response _ WriteStream on: ''.	[self dataAvailable] whileTrue: [		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.		1 to: bytesRead do: [ :i |			(c _ buf at: i) ~= LF ifTrue: [response nextPut: c]]].	^ response contents!sendCommand: commandString	"Send the given command as a single line followed by a <CR><LF> terminator."	self sendData: commandString, CrLf.! !!Socket methodsFor: 'waiting'!waitForConnectionUntil: deadline	"Wait up to the given millisecond clock time for a connection to be established. Return true if it is established by the deadline."	| status |	status _ self primSocketConnectionStatus: socketHandle.	[(status ~= Connected) and:	 [Time millisecondClockValue <= deadline]] whileTrue: [		"wait for a connection to be established"		(Delay forMilliseconds: 50) wait.		status _ self primSocketConnectionStatus: socketHandle.	].	^ status = Connected!waitForDataUntil: deadline	"Wait up to the given millisecond clock time for data to arrive. Return true if data arrives by the deadline."	| dataArrived |	dataArrived _ self primSocketReceiveDataAvailable: socketHandle.	[dataArrived not and:	 [self isConnected and:	 [Time millisecondClockValue <= deadline]]] whileTrue: [		"wait for data to arrive"		(Delay forMilliseconds: 50) wait.		dataArrived _ self primSocketReceiveDataAvailable: socketHandle.	].	^ dataArrived!waitForDisconnectionUntil: deadline	"Wait up to the given millisecond clock time for the remote side to close the connection. Return true if it is closed by the deadline."	"Note: This end of the connection should be closed before calling this method."	| status extraBytes |	status _ self primSocketConnectionStatus: socketHandle.	extraBytes _ 0.	[(status ~= Unconnected) and:	 [Time millisecondClockValue <= deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		(Delay forMilliseconds: 50) wait.		status _ self primSocketConnectionStatus: socketHandle.	].	extraBytes > 0 ifTrue: [		self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status = Unconnected!waitForOtherEndToCloseUntil: deadline	"Wait up to the given millisecond clock time for the remote side to close the connection. Return true if it is closed by the deadline."	| status extraBytes |	status _ self primSocketConnectionStatus: socketHandle.	extraBytes _ 0.	[(status ~= OtherEndClosed) and:	 [Time millisecondClockValue <= deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		(Delay forMilliseconds: 50) wait.		status _ self primSocketConnectionStatus: socketHandle.	].	extraBytes > 0 ifTrue: [		self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status = Unconnected!waitForSendDoneUntil: deadline	"Wait up to the given millisecond clock time for the current send operation to complete. Return true if it completes by the deadline."	| sendDone |	sendDone _ self primSocketSendDone: socketHandle.	[sendDone not and:	 [self isConnected and:	 [Time millisecondClockValue <= deadline]]] whileTrue: [		"wait for data to arrive"		(Delay forMilliseconds: 50) wait.		sendDone _ self primSocketSendDone: socketHandle.	].	^ sendDone! !!Socket methodsFor: 'primitives'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 217>	self primitiveFailed!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 218>	self primitiveFailed!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 221>	self primitiveFailed!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 223>	self primitiveFailed!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 220>	self primitiveFailed!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 219>	self primitiveFailed!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class."	<primitive: 211>	self primitiveFailed!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaphoreID: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	unreliable datagram socket (UDP if the protocol is IP) [NOTE: UDP is not yet implemented]		1	reliable stream socket (TCP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes.	If non-zero, semaIndex is the index of a VM semaphore associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send complete. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met and respond accordingly. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 209>	self primitiveFailed!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 210>	self primitiveFailed!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 212>	self primitiveFailed!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 213>	self primitiveFailed!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 214>	self primitiveFailed!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 222>	self primitiveFailed!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 215>	self primitiveFailed!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 216>	self primitiveFailed!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 224>	self primitiveFailed! !!Socket class methodsFor: 'instance creation'!new	^ super new initialize! !!Socket class methodsFor: 'class initialization'!initialize	"Socket initialize"	"Socket Status Values"	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.	"Build a <CR><LF> string for command line termination."	CR _ Character cr.	LF _ Character linefeed.	CrLf _ String with: CR with: LF.! !!Socket class methodsFor: 'network initialization'!initializeNetwork: resolverSemaIndex	"Initialize the network drivers."	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [self primInitializeNetwork: resolverSemaIndex].!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 200>	self notify: 'Network initialization failed, perhaps becausethis machine is not connected to a network.'.! !!Socket class methodsFor: 'examples'!clientServerTest	"Socket clientServerTest"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes |	Transcript show: 'starting client/server test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	Transcript show: 'opening connection'; cr.	sock1 _ Socket new. sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				bytesSent _ bytesSent + (sock1 sendData: sendBuf)].			sock2 dataAvailable ifTrue: [				bytesReceived _ bytesReceived +					(sock2 receivedDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].	Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForOtherEndToCloseUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnected) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnected) ifFalse: [self error: 'sock2 not closed'].	sock1 destroy. sock2 destroy.	Transcript show: 'client/server test done; time = ', t printString; cr.	Transcript show: (bytesSent // t) printString, ' kBytes/sec'; cr.!nntpTest	"Socket nntpTest"	| serverName serverAddr s range headers |	Socket initializeNetwork: 0.	serverName _ FillInTheBlank		request: 'What is your net news server?'		initialAnswer: 'louie.disney.com'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: serverAddr port: 119.  "119 is the NNTP port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'group comp.lang.smalltalk'.	Transcript show: s getResponse.range _ FillInTheBlank request: 'Enter message range (e.g. 1400-1500)'.range size > 0 ifTrue: [	s sendCommand: 'xover ', range.	headers _ s getAndShowMultilineResponse.]."xxx	s sendCommand: 'listgroup comp.lang.smalltalk'.	msgs _ self parseNTTPMsgList: s getMultilineResponse.	msgs = nil ifFalse: [		commands _ WriteStream on: ''.		1 to: 10 do: [ :i |			commands nextPutAll: 'head ', (msgs at: i) printString, CrLf.		].		s sendData: commands contents.		1 to: 10 do: [ :i |			header _ s getMultilineResponse.			Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr.		].			].	s sendCommand: 'newgroups 010101 000000'.	Transcript show: (all _ s getMultilineResponse) size printString, ' bytes'; cr.	Transcript show: all; cr.xxx"	Transcript show: 'Sending quit...'; cr.	s sendCommand: 'QUIT'.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr.	StringHolderView		open: (StringHolder new contents: (self parseHeaderList: headers))		label: 'Newsgroup Headers'.!popTest	"Socket popTest"	| serverName serverAddr userName userPassword s msgs header |	Socket initializeNetwork: 0.	serverName _ FillInTheBlank		request: 'What is your POP server?'		initialAnswer: 'bobo.rd.wdi.disney.com'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	userName _ FillInTheBlank		request: 'What is your email name?'		initialAnswer: 'johnm'.	userPassword _ FillInTheBlank		request: 'What is your email password?'.	s _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: serverAddr port: 110.  "110 is the POP3 port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'USER ', userName.	Transcript show: s getResponse.	s sendCommand: 'PASS ', userPassword.	Transcript show: s getResponse.	s sendCommand: 'LIST'."Should be tweaked for case that 0 messages are waiting"	msgs _ self parseNTTPMsgList: s getMultilineResponse.	1 to: (msgs size min: 5) do: [ :i |		s sendCommand: 'TOP ', (msgs at: i) printString, ' 0'.		header _ s getMultilineResponse.		Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr.	].	s sendCommand: 'RETR 1'.	Transcript show: s getMultilineResponse.	s sendCommand: 'QUIT'.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr.!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"Socket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	Transcript show: 'opening connection'; cr.	sock1 _ Socket new.	sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend _ 100.	t _ Time millisecondsToRun: [		samplesSent _ 0.		done _ false.		[done] whileFalse: [			(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [				sock1 sendCommand: self sensorStateString.				samplesSent _ samplesSent + 1].			sock2 dataAvailable ifTrue: [				sock2 getResponse asParagraph displayOn: Display at: 10@10].			done _ samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.!sendTest	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript show: 'starting send test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'bobo.rd.wdi.disney.com'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	Transcript show: 'opening connection'; cr.	sock _ Socket new.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 100000.	sendBuf _ String new: 5000 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendData: sendBuf)]]].	sock destroy.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: (bytesToSend // t) printString, ' kBytes/sec'; cr.! !!Socket class methodsFor: 'remote cursor support'!forkingRemoteCursorSender	"This is the client side of a test that sends samples of the local input sensor state to the server, which may be running on a local or remote host. This method opens the connection, then forks a process to send the cursor data. Data is sent continuously until the user clicks in a 15x15 pixel square at the top-left corner of the display. The server should be started first. Note the server's address, since this method will prompt you for it."	"Socket forkingRemoteCursorSender"	| sock addrString addr stopRect |	Transcript show: 'starting remote cursor sender'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	addrString _ FillInTheBlank request: 'Receiver address?'.	addrString isEmpty ifTrue: [^ self].	addr _ NetNameResolver addressFromString: addrString.	Transcript show: 'opening connection'; cr.	sock _ Socket new.	sock connectTo: addr port: 54323.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	stopRect _ 0@0 corner: 15@15.  "click in this rectangle to stop sending"	Display reverse: stopRect.	["the sending process"		[(stopRect containsPoint: Sensor cursorPoint) and:		 [Sensor anyButtonPressed]] whileFalse: [			sock sendCommand: self sensorStateString.			(Delay forMilliseconds: 20) wait.		].		sock waitForSendDoneUntil: self standardDeadline.		sock destroy.		Transcript show: 'remote cursor sender done'; cr.		Display reverse: stopRect.	] fork.!parseSensorStateString: aString	"Socket parseSensorStateString: Socket sensorStateString"	| pt s buttons |	pt _ Point new.	s _ ReadStream on: aString.	pt x: (Integer readFrom: s).	s skipSeparators.	pt y: (Integer readFrom: s).	s skipSeparators.	buttons _ Integer readFrom: s.	^ Array with: pt with: buttons	!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[Socket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork: 0.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ Socket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	(sock isConnected) ifFalse: [		 sock destroy.		Transcript show:'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.		^ self].	Transcript show: 'connection established'; cr.	[sock isConnected] whileTrue: [		sock dataAvailable ifTrue: [			response _ sock getResponse.			response asParagraph displayOn: Display at: 10@10.		] ifFalse: [			"if no data available, let other processes run for a while"			(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.!sensorStateString	"Socket sensorStateString"	| pt buttons s |	pt _ Sensor cursorPoint.	buttons _ Sensor primMouseButtons.	s _ WriteStream on: (String new: 100).	s nextPutAll: pt x printString.	s space.	s nextPutAll: pt y printString.	s space.	s nextPutAll: buttons printString.	^ s contents! !!Socket class methodsFor: 'utilities'!deadlineSecs: secs	"Return a millisecond clock deadline of the given number of seconds into the future."	^ Time millisecondClockValue + (secs * 1000)!extractDateFromAndSubjectFromHeader: headerString	| date from subject s lineBuf c line i |	date _ from _ subject _ ''.	s _ ReadStream on: headerString.	lineBuf _ WriteStream on: ''.	[s atEnd] whileFalse: [		c _ s next.		c = CR ifTrue: [			line _ lineBuf contents.			(line beginsWith: 'Date: ')	ifTrue: [date _ line copyFrom: 7 to: line size].			(line beginsWith: 'From: ')	ifTrue: [from _ line copyFrom: 7 to: line size].			(line beginsWith: 'Subject: ')	ifTrue: [subject _ line copyFrom: 10 to: line size].			lineBuf _ WriteStream on: ''.		] ifFalse: [			lineBuf nextPut: c.		].	].	i _ date indexOf: $' ifAbsent: [0].	date _ date copyFrom: i + 1 to: date size.	^ (self simpleDateString: date), ', ', from, ':  ', subject!parseHeaderList: aString	| results s lineStart |	results _ WriteStream on: (String new: aString size).	s _ ReadStream on: aString.	[s atEnd] whileFalse: [		lineStart _ s position + 1.		3 timesRepeat: [s skipTo: Character tab].  "find fourth tab"		lineStart to: s position - 1 do: [ :i | results nextPut: (aString at: i)].		results cr.		s skipTo: Character cr.	].	^ results contents!parseNTTPMsgList: aString	| s out |	s _ ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out _ OrderedCollection new.	[s atEnd] whileFalse: [		out addLast: (Integer readFrom: s).s skipTo: Character cr.		"s next"].	^ out asArray!simpleDateString: dateString	| s |	s _ ReadStream on: dateString.	s skipTo: $,.  "scan thru first comma"	s atEnd ifTrue: [s reset].  "no comma found; reset s"	s skipSeparators.	^ (Date readFrom: s) mmddyy!standardDeadline	"Return a millisecond clock deadline thirty seconds into the future."	^ Time millisecondClockValue + (30 * 1000)! !!SoundBuffer class methodsFor: 'instance creation'!new: anInteger	"Return a SoundBuffer large enough to hold the given number of 16-bit values. (That is, an array of 32-bit words half the requested size)."	^ self basicNew: ((anInteger + 1) // 2)! !!SoundPlayer class methodsFor: 'snapshotting'!shutDown	"Stop player process, for example before snapshotting."	self stopPlayerProcess.!startUp	"Start up the player process."	SoundPlayer startPlayerProcessBufferSize: 2000 rate: 11025 stereo: true.! !!SoundPlayer class methodsFor: 'playing'!resumeSound: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	PlayerProcess == nil ifTrue: ["		(self confirm: 'Start the sound player process?') ifFalse: [ ^ self ]."		self startUp.	].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound) ifFalse: [			ActiveSounds add: aSound.		].	].! !!SoundPlayer class methodsFor: 'player process'!stopPlayerProcess	"Stop the sound player process."	"SoundPlayer stopPlayerProcess"	PlayerProcess == nil ifFalse: [PlayerProcess terminate].	self primSoundStop.	PlayerProcess _ nil.	PlayerSemaphore _ nil.	Buffer _ nil.	ActiveSounds _ OrderedCollection new.! !!StandardFileStream methodsFor: 'read, write, position'!next	"Read the next object from the file. 2/12/96 sw"	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^ buffer1 at: 1 ]		ifFalse: [ ^ nil ].!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	pos _ self position.	buffer _ self next: (2000 min: (self size - self position)).	(count _ buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!StandardSystemController methodsFor: 'control defaults'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'basic control sequence'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	sensor waitNoButton.	status _ #active! !!StandardSystemController methodsFor: 'menu messages'!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint!reframe	^ view reframeTo: view getFrame!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view become: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view become: (view as: StandardSystemView)].! !!StandardSystemController methodsFor: 'borders'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side = #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]]]].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]].		]]]!adjustWindowCorners 	| box cornerBox p clicked |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		with: #(topLeft: topRight: bottomRight: bottomLeft:)		do: [:readCorner :writeCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue.				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | f copy perform: writeCorner with: sensor cursorPoint]]]]].	^ clicked!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp _ sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp _ sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box _ view windowBox]		ifFalse: [box _ (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController class methodsFor: 'class initialization'!initialize   "StandardSystemController initialize"	"Set up the menus for standard windows.  	 6/6/96 sw: added fullScreen"	ScheduledBlueButtonMenu _ PopUpMenu labels: 'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7).	ScheduledBlueButtonMessages _ #(label chooseColor toggleTwoTone move reframe fullScreen collapse close)."StandardSystemController initialize.ScheduledControllers scheduledWindowControllers		do: [:c | c initializeBlueButtonMenu]"	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'label access'!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: (TextFontChange fontNumber: 2)											with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin!labelFrame	^labelFrame!labelHeight	^ 19!labelOffset	^ 0 @ (self labelHeight-2)!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)!setLabelRegion	"Always follows view width"	| labelRect |	labelRect _ 0 @ 0 extent: self displayBox width @ self labelHeight.	labelFrame region: labelRect.	^ labelRect! !!StandardSystemView methodsFor: 'framing'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	collapsedViewport isNil ifTrue:		[^ RealEstateAgent assignCollapsePointFor: self].	labelForm slideFrom: self labelDisplayBox origin			to: (pt _ collapsedViewport topLeft) nSteps: 10.	^ pt!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm _ bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid _ false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f _ self getFrame.			bitsValid _ false.			self erase.			^ f topLeft + self labelOffset extent: f extent]!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport _ self viewport.	self displayEmphasized!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			self window: self defaultWindow.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self resizeTo: newFrame.			self displayDeEmphasized]!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  1/22/96 sw"	^ model initialExtent min: maximumSize max: minimumSize!newDisplayBoxFor: subView adjoining: newRect along: side 	side = #left ifTrue: [^ subView displayBox withRight: newRect left].	side = #right ifTrue: [^ subView displayBox withLeft: newRect right].	side = #top ifTrue: [^ subView displayBox withBottom: newRect top].	side = #bottom ifTrue: [^ subView displayBox withTop: newRect bottom].!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim |	newRect _ aDisplayBox.	"First check that this won't make any pane smaller than 8 screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | self newDisplayBoxFor: sub adjoining: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < 8 ifTrue:		[delta _ minDim - 8.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ self newDisplayBoxFor: sub adjoining: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	self window: self window viewport: self viewport.	self uncacheBits; displayEmphasized!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  1/26/96 sw	Repaint difference after the change.  5/8/96 di"	| oldBox newBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self window: self window viewport: portRect.	self setLabelRegion.	newBox _ self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f _ self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)!windowOrigin	^ self isCollapsed		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'displaying'!displayDeEmphasized	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT"	bitsValid		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super display.				CacheBits ifTrue: [self cacheBitsAsIs]]!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor!displayOn: aPort	bitsValid ifFalse: [^ self].	windowBits displayOnPort: aPort at: self windowOrigin!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox _ self labelDisplayBox.	top _ labelDisplayBox top + 3.	bottom _ labelDisplayBox bottom - 3.	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)			with: (Form black pixelWordForDepth: Display depth).	top even ifFalse: [stripes swap: 1 with: 2].	left _ labelDisplayBox left + 3.	box _ self closeBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self labelTextRegion.	right _ box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self growBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	right _ labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.!displayView	"Refer to the comment in View|displayView. "	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText!windowBits	^ windowBits! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented _ false]! !!StandardSystemView methodsFor: 'private'!subviewWithLongestSide: sideBlock near: aPoint 	| region subs max rect side len theSub theSide |	region _ aPoint - (4@4) corner: aPoint + (4@4).	subs _ subViews select: [:sub | sub insetDisplayBox intersects: region].	subs isEmpty ifTrue: [sideBlock value: #none.  ^ nil].	max _ 0.	subs do:		[:sub | rect _ sub insetDisplayBox.		side _ rect sideNearestTo: aPoint.		len _ (side = #left) | (side = #right)			ifTrue: [rect height]			ifFalse: [rect width].		len > max ifTrue: [max _ len.  theSub _ sub.  theSide _ side]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits!initialize		"StandardSystemView initialize"	self doCacheBits.	(LabelStyle _ TextStyle default copy)		gridForFont: 2 withLead: 0! !!StrikeFont methodsFor: 'accessing'!setGlyphs: newGlyphs	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."	glyphs _ newGlyphs!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'emphasis'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs deepCopy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g!makeCondensedGlyphs	"Make an underlined set of glyphs with same widths"	| g newXTable x x1 w |	g _ glyphs deepCopy.	newXTable _ Array new: xTable size.	newXTable at: 1 put: (x _ xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x _ x + w)].	xTable _ newXTable.	glyphs _ g"(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g r bonkForm bc |	g _ glyphs deepCopy.	"BonkForm will have bits where slanted characters overlap their neighbors."	bonkForm _ Form extent: (self height//4+2) @ self height.	bc _ self descent//4 + 1.  "Bonker x-coord corresponding to char boundary."	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color black.	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		g copy: (1@0 extent: g width @ (self ascent - y))			from: 0@0 in: g rule: Form over.		bonkForm copy: (1@0 extent: bonkForm width @ (self ascent - y))			from: 0@0 in: bonkForm rule: Form over].	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color white.	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color black.	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		g copy: (0@y extent: g width @ g height)			from: 1@y in: g rule: Form over.		bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)			from: 1@0 in: bonkForm rule: Form over].	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color white.	"Now use bonkForm to erase at every character boundary in glyphs."	bonkForm offset: (0-bc) @ 0.	self bonk: g with: bonkForm.	glyphs _ g!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 32! !!StrikeFont methodsFor: 'file in/out'!displayChar: ascii form: charForm	"Convenience utility used during conversion of BitFont files"	| m bigForm |	Display fillBlack: (0@0 extent: 20@14).	ascii printString displayAt: 0@2.	charForm width > 0 ifTrue:		[m _ 5.		bigForm _ charForm magnify: charForm boundingBox by: m@m.		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.		bigForm displayAt: 50@2.		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	self setStopConditions !printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name , ')'!readBFHeaderFrom: f	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	pointSize _ (self restOfLine: 'Font size = ' from: f) asNumber.	name _ (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f fLength lastAscii charLine width ascii charForm line missingForm tempGlyphs s nn iRect ptSize |	f _ FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	self restOfLine: 'Extent information for entire font' from: f.	"Parse the foloowing line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	s _ ReadStream on: (self restOfLine: 'Image rect' from: f).	s upTo: $:.	nn _ (1 to: 4) collect:		[:i | s upTo: $=; skipSeparators. Number readFrom: (s upTo: $,)].	iRect _ Rectangle left: (nn at: 1) right: (nn at: 2)				top: (nn at: 3) bottom: (nn at: 4).		"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber.		charLine = 'Missing character' ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: line size+iRect left-1 do:					[:x | (line at: x-iRect left)=$* ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	self setStopConditions!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	file _ FileStream readOnlyFileNamed: fileName.	file binary.	self readFromStrike2Stream: file!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	self setStopConditions!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line _ file upTo: Character cr.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size!setStopConditions	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset!writeAsStrike2named: fileName	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: fileName.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont methodsFor: 'character shapes'!alter: char formBlock: formBlock	self characterFormAt: char 		put: (formBlock value: (self characterFormAt: char))!characterForm: char pixelValueAt: pt put: val	| f |	f _ self characterFormAt: char.	f pixelAt: pt put: val.	self characterFormAt: char put: val!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX characterForm |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	characterForm _ Form extent: (rightX-leftX) @ self height.	characterForm copy: characterForm boundingBox		from: leftX@0 in: glyphs rule: Form over.	^ characterForm!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 corner: rightX @ self height)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm smallRect editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	bitEditor controller blueButtonMenu: nil blueButtonMessages: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm!widen: char by: delta	| newForm |	^ self alter: char formBlock:  "Make a new form, wider or narrower..."		[:charForm | newForm _ Form extent: charForm extent + (delta@0).		charForm displayOn: newForm.  "Copy this image into it"		newForm]    "and substitute it in the font"! !!StrikeFont class methodsFor: 'instance creation'!fromStrike: fileName 	"Read a font from disk in the old ST-80 'strike' format.	Note: this is an old format; use strike2 format instead"	^self new newFromStrike: fileName! !!StrikeFont class methodsFor: 'examples'!convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and then 	write them out in strike2 (*.sf2) format which is much more compact,	and which can be read in again very quickly."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as the image."	| f |	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: fname.		f writeAsStrike2named: f name , '.sf2']!example	"Displays a line of text on the display screen at the location of the cursor.	Example depends on the strike font file, 'TimesRoman10.strike'. existing."	(StrikeFont new readFromStrike2: 'NewYork12.sf2')		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint	 	"StrikeFont example."!size: pointSize fromLiteral: aString	"This method allows a font set to be captured as sourcecode in a subclass.	The string literals will presumably be created by printing, eg,		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,		and then pasting into a browser after a heading like, eg,size24	^ self size: 24 fromLiteral:	'--unreadable binary data--'	See the method hackDefaultStyle to see how this can be used"	^ (StrikeFont new readFromStrike2Stream:		(ExternalStream on: aString asByteArray from: 1 to: aString size))		name: self name , (pointSize < 10 ifTrue: ['0' , pointSize printString]										ifFalse: [pointSize printString])! !!StrikeFont class methodsFor: 'derivative font caching'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allInstancesDo: [:sf | sf reset]! !!String methodsFor: 'accessing'!atWrap: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  6/18/96 tk"	<primitive: 63>	^(super atWrap: index) asCharacter!runs        "Strings don't have runs..."        ^#()!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		delimiters detect: [:delim | delim = (self at: i)]				ifNone: [^ i]].	^ self size + 1! !!String methodsFor: 'comparing'!beginsWith: prefix | prefixSize |	"Answer whether the receiver begins with the given prefix string."	prefixSize _ prefix size.	self size < prefixSize ifTrue: [^false].	1 to: prefixSize do:		[:index | (self at: index) = (prefix at: index) ifFalse: [^false]].	^true! !!String methodsFor: 'converting'!asByteArray	"Convert to a ByteArray with the ascii values of the string.	Fast code uses primitive that avoids character conversion"	^ (ByteArray new: self size) replaceFrom: 1 to: self size with: self!capitalized	"Return a copy with the first letter capitalized"	| cap |	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  11/25/96 sw"	^ $' asString, self, $' asString! !!String methodsFor: 'displaying'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	| delta savedArea captionText textFrame barFrame outerFrame result |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: self asText allBold.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame moveBy: delta.  textFrame moveBy: delta.  outerFrame moveBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal | Display fillGray: (barFrame topLeft + (2@2) extent:					((barFrame width-4) * (barVal-minVal) /(maxVal - minVal)@16))].	savedArea displayOn: Display at: outerFrame topLeft.	^ result! !!String methodsFor: 'private'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take abnother block and enumerate over some list with it."	| choices scoreMin results score |	scoreMin _ self size // 2 min: 3.	oldCollection isNil		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices _ oldCollection ].	wordBlock isNil		ifTrue:			[ results _ OrderedCollection new.			1 to: (5 min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score _ self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= 5) ifTrue: [ scoreMin _ (choices at: 5) value] ] ].			results _ choices ].	^ results! !!String methodsFor: 'Celeste'!includesSubstring: aString caseSensitive: caseSensitive	"Note: Although less general than the 'match:' method, this method was a factor of 10 faster on both successful and unsucessful finds of a short string in a 1116 byte mail message."		| first index i |	self isEmpty ifTrue: [^false].	caseSensitive ifTrue: [		first _ aString first.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) = first ifTrue: [				i _ 1.				[(self at: start + i - 1) = (aString at: i)] whileTrue: [					i = aString size ifTrue: [^true].					i _ i + 1.				].			].		].	] ifFalse: [		first _ aString first asLowercase.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) asLowercase = first ifTrue: [				i _ 1.				[(self at: start + i - 1) asLowercase =				 (aString at: i) asLowercase] whileTrue: [					i = aString size ifTrue: [^ true].					i _ i + 1.				].			].		].	].	^ false!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!StringCostumeMorph methodsFor: 'initialization'!initialize	super initialize.	format _ #default.  "formats: #float, #string, #integer, #default"	target _ getSelector _ putSelector _ nil.! !!StringCostumeMorph methodsFor: 'accessing'!getSelector	^ getSelector!getSelector: aSymbol	getSelector _ aSymbol.!putSelector	^ putSelector!putSelector: aSymbol	putSelector _ aSymbol.!target	^ target!target: anObject	target _ anObject.! !!StringCostumeMorph methodsFor: 'stepping'!step	| s |	hasFocus ifFalse: [		"update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse: [self contents: s]].!stepTime	^ 50! !!StringCostumeMorph methodsFor: 'formats'!useDefaultFormat	"Use the object's own printString format."	format _ #default.!useFloatFormat	format _ #float.!useIntegerFormat	format _ #integer.!useStringFormat	format _ #string.! !!StringCostumeMorph methodsFor: 'target access'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue: [		newValue _ self valueFromContents.		target perform: putSelector with: newValue.		target isMorph ifTrue: [target changed]].!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target perform: getSelector.	lastValue _ v.	format = #string ifTrue: [^ v].	format = #integer ifTrue: [^ v asInteger printString].	format = #float ifTrue: [^ (v roundTo: 0.01) printString].	^ v printString  "default; use object's printString"!valueFromContents	"Return a new value from the current contents string."	format = #string ifTrue: [^ contents].	^ Compiler evaluate: contents! !!StringCostumeMorph methodsFor: 'editing'!acceptContents	self informTarget.!keyStroke: evt	"Handle a keystroke event. Accept change if enter key or Cmd-S is pressed."	((evt keyCharacter = Character enter) or:	 [evt keyCharacter = $s and: [evt commandKeyPressed]]) ifTrue: [		self informTarget.		evt hand newKeyboardFocus: evt hand world.		^ self].	super keyStroke: evt.! !!StringHolderController methodsFor: 'menu messages'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  9/27/96 sw"	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or:	 [result == #failedDoit]) ifFalse: [		Smalltalk			browseAllObjectReferencesTo: result			except: #()			ifNone: [:obj | view topView flash. self controlInitialize]].! !!StringHolderController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages.	 1/12/96 sw: added senders of it, etc.  1/15/96 sw: explain	 1/22/96 sw: cmd keys detailed	 1/24/96 sw: added find; moved many items to shifted side etc.	 1/26/96 sw: made compatible with paragraph editor's version; I'm not clear on when/how this guy gets used (seemingly eg in a workspace) vs when the paragraph editor's does (seemingly in browsers)	 2/29/96 sw: correct cmd-key equivalent for do again, and add set-search-string"	CodeYellowButtonMenu _ 		PopUpMenu 			labels: 'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)do it (d)print it (p)inspect it (i)accept (s)cancel (l)show bytecodesmore...' 		lines: #(3 5 8 11 13 14).	CodeYellowButtonMessages _ 		#(find findAgain setSearchString again undo copySelection cut paste doIt printIt inspectIt accept cancel showBytecodes shiftedYellowButtonActivity)	"StringHolderController initialize"! !!StringMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color black.	font _ nil.	hasFocus _ false.	self contents: 'StringMorph'.! !!StringMorph methodsFor: 'accessing'!contents	^ contents!contents: aString	| scanner |	contents = aString ifTrue: [^ self].  "No substantive change"	contents _ aString.	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	self extent: (scanner stringWidth: aString) @ (scanner lineHeight)!contentsClipped: aString	"Change my text, but do not change my size as a result"	contents = aString ifTrue: [^ self].  "No substantive change"	contents _ aString.	self changed! !!StringMorph methodsFor: 'drawing'!drawOn: aCanvas	hasFocus ifTrue: [aCanvas fillRectangle: self bounds color: Color yellow].	aCanvas text: contents bounds: bounds font: nil color: color.! !!StringMorph methodsFor: 'editing'!acceptContents	"The message is sent when the user hits enter or Cmd-S. Accept the current contents and end editing. This default implementation does nothing."!keyboardFocusChange: aBoolean	hasFocus _ aBoolean.	self changed.!keyStroke: evt	"Handle a keystroke event."	| ch |	ch _ evt keyCharacter.	ch = Character backspace ifTrue: [  "backspace"		contents size > 0 ifTrue: [			self contents: (contents copyFrom: 1 to: contents size - 1)].		^ self].	(ch = $x and: [evt commandKeyPressed]) ifTrue: [  "cut"		Smalltalk clipboardText: contents.		^ self contents: ''].	(ch = $c and: [evt commandKeyPressed]) ifTrue: [  "copy"		Smalltalk clipboardText: contents.		^ self].	(ch = $v and: [evt commandKeyPressed]) ifTrue: [  "paste"		^ self contents: Smalltalk clipboardText].	((ch = Character enter) or:	 [ch = $s and: [evt commandKeyPressed]]) ifTrue: [  "accept"		self acceptContents.		evt hand newKeyboardFocus: evt hand world.		^ self].	self contents: (contents copyWith: ch).  "append the character"!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	evt shiftPressed		ifTrue: [evt hand newKeyboardFocus: self]		ifFalse: [super mouseDown: evt].! !!StringMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') contents: '; print: contents! !!StringMorph class methodsFor: 'as yet unclassified'!test	"Return a morph with lots of strings for testing display speed."	| c |	c _ LayoutMorph newColumn.	SystemOrganization categories do:		[:cat | c addMorph: (StringMorph new contents: cat)].	^ c! !!SwitchView methodsFor: 'label access'!centerLabel	"Align the center of the label with the center of the receiver's window."	label == nil  ifFalse: 		[(label isKindOf: Paragraph)			ifTrue: ["Compensate for leading in default style"					label align: label boundingBox center + (0@1)							with: self getWindow center]			ifFalse: [label align: label boundingBox center 							with: self getWindow center]]! !!SyntaxError methodsFor: 'menu messages'!autoProceed	| someView |	someView _ self dependents first.	self proceed: someView topView controller!proceed: aController 	"The error has presumably been fixed and the file in that created the 	syntax error can now be continued."	debugger proceed: aController! !!SyntaxError methodsFor: 'contents'!contents: aString notifying: aController 	"Compile the code in aString and notify aController of any errors.	If there are no errors, then automatically proceed."	(class compile: aString classified: category notifying: aController)		 == nil ifTrue: [^ false].	self autoProceed! !!SyntaxError class methodsFor: 'instance creation'!errorInClass: aClass withCode: aString 	"Answer a standard system view whose model is an instance of me. The syntax error occurred in typing to add code, aString, to class, aClass. "	self open: (self new setClass: aClass						code: aString						debugger: (Debugger context: thisContext))!open: aSyntaxError	"Answer a standard system view whose model is an instance of me.  TK 15 May 96"	|  topView aListView aCodeView |	topView _ StandardSystemView new.	topView model: aSyntaxError.	topView label: 'Syntax Error'.	topView minimumSize: 380 @ 220.	aListView _ SyntaxErrorListView new.	aListView model: aSyntaxError.	aListView window: (0 @ 0 extent: 380 @ 20).	aListView		borderWidthLeft: 2		right: 2		top: 2		bottom: 0.	topView addSubView: aListView.	aCodeView _ BrowserCodeView new.	aCodeView model: aSyntaxError.	aCodeView window: (0 @ 0 extent: 380 @ 200).	aCodeView		borderWidthLeft: 2		right: 2		top: 2		bottom: 2.	topView		addSubView: aCodeView		align: aCodeView viewport topLeft		with: aListView viewport bottomLeft.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Processor activeProcess suspend! !!SystemBuilder class methodsFor: 'system building'!finalSystemBuildingSteps	"The final steps after all the file-ins, before we can call the system built.  1/18/96 sw"	Symbol rehash.     " Reclaim unused symbols"	self showInTranscript: '** System Built **'.	BuildingSystem _ false.!initializeAfterSystemBuild	"Reinitialize needs to be called manually after filing in the kernel because other support classes need to have been filed in before it can run successfully.  This method copied over from old macPal stuff, 1/27/96 sw, to serve as a template, but the real work needs to be done still."	Text initTextConstants.		"Rebuild snapshot lists"	self showInTranscript: '** SystemBuilder reinitialize  **'.	"self initMenus"! !!SystemCategoryListController methodsFor: 'menu messages'!browseAllClasses	"Create and schedule a browser on all classes alphabetically."	self controlTerminate.	model browseAllClasses.	self controlInitialize!findClass	"modified 4/29/96 sw so that if only 1 class matches the user-supplied string, or if the user-supplied string exactly matches a class name, then the pop-up menu is bypassed"	| pattern foundClass classNames index reply |	self controlTerminate.	model okToChange ifFalse: [^ self classNotFound].	pattern _ (reply _ FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self classNotFound].	(Smalltalk hasClassNamed: reply)		ifTrue:			[foundClass _ Smalltalk at: reply asSymbol]		ifFalse: 			[classNames _ Smalltalk classNames asArray select: 				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].			classNames isEmpty ifTrue: [^ self classNotFound].			index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].			index = 0 ifTrue: [^ self classNotFound].			foundClass _ Smalltalk at: (classNames at: index)]. 	model systemCategoryListIndex: (model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name). 	self controlInitialize!findRecentClass        "Put up a list of recently visited classes and allow the user to select one."        self controlTerminate.        model recent.        self controlInitialize! !!SystemCategoryListController class methodsFor: 'class initialization'!initialize	"SystemCategoryListController initialize"	SystemCategoryListYellowButtonMenu _ 		PopUpMenu 			labels:'find class...recent classes...browse allbrowseprintOutfileOutreorganizeupdateadd item...rename...remove' 			lines: #(2 4 6 8).	SystemCategoryListYellowButtonMessages _		#(findClass findRecentClass browseAllClasses browse		printOut fileOut		edit update		add rename remove )	"	SystemCategoryListController initialize.	SystemCategoryListController allInstancesDo:		[:x | x initializeYellowButtonMenu]	"! !!SystemDictionary methodsFor: 'browsing'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject. If there are none, then evaluate aBlock on anObject.  9/27/96 sw"	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ anObject name.	shortName size > 12 ifTrue: [		shortName _ (shortName truncateTo: 12), '...'.	].	InspectorView		open: (InspectorView inspector: (OrderedCollectionInspector inspect: aList))		withLabel: 'Objects pointing to ', shortName.!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	ChangedMessageSet openFor: SystemChanges!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring.  The search is case-sensitive. This takes a long time right now.  7/23/96 di	 1/16/97 sw: set up the autoSelect: string"	^ self browseMessageList: (self allMethodsWithSourceString: aString)		name: 'Methods containing ' , aString printString autoSelect: aString!browseMethodsWithString: aString	"Launch a browser on all methods which contain string literals that have aString as a substring.  The search is case-sensitive. This takes a long time right now.  2/1/96 sw	1/6/97 sw: get the auto-select string correct"	| aList |	aList _ self allMethodsWithString: aString.	aList size > 0 ifTrue: 		[Cursor normal show.		self browseMessageList: aList  name: 'Methods with string ''', aString, '''' autoSelect: aString]! !!SystemDictionary methodsFor: 'retrieving'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	| sent |	sent _ Set new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:m |					(m isMemberOf: Symbol)  "might be sent"						ifTrue: [sent add: m].					(m isMemberOf: Array)  "might be performed"						ifTrue: [m do: [:x | sent add: x]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	^ sent!allUnSentMessages   "Smalltalk allUnSentMessages"	"Answer the set of selectors that are implemented by some object	in the system but not sent by any."	| sent unsent |	sent _ self allSentMessages.	unsent _ Set new.	self allImplementedMessages do:		[:sel | (sent includes: sel) ifFalse: [unsent add: sel]].	^ unsent" | f cl lastClass |f _ FileStream newFileNamed: 'UnsentMessages.txt'.lastClass _ 'xx'.methods _ SortedCollection new.Smalltalk allUnSentMessages do:	[:sel | methods addAll: (Smalltalk allImplementorsOf: sel)].methods do:	[:m | cl _ m copyUpTo: $ . 	cl = lastClass		ifTrue: [f nextPutAll: (m copyFrom: lastClass size+1 to: m size)]		ifFalse: [f cr; cr; nextPutAll: m.  lastClass _ cl]].f close."!allUnSentMessagesIn: selectorSet	"Answer the subset of selectorSet which are not sent anywhere in the system.	Factored out from#allUnSentMessages 5/8/96 sw"	|  all |	all _ selectorSet copy.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:m |					(m isMemberOf: Symbol)  "might be sent"						ifTrue: [all remove: m ifAbsent: []].					(m isMemberOf: Array)  "might be performed"						ifTrue: [m do: [:x | all remove: x ifAbsent: []]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			all remove: (self specialSelectorAt: index) ifAbsent: []]].	^ all!pointersTo: anObject	"Find all occurrences in the system of pointers to the argument anObject."	"(Smalltalk pointersTo: Browser) inspect."	^ self pointersTo: anObject except: #()!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ objectsToExclude) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]]])				 ifTrue: [ results add: anObj ].		].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray!pointersToItem: index of: anArray	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:	Smalltalk pointersToItem: 2 of: selfin the inspector."	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !!SystemDictionary methodsFor: 'class names'!renameClassNamed: oldName as: newName	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  10/28/96 sw"	| oldClass |	(oldClass _ self at: oldName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.			^ self].	oldClass rename: newName! !!SystemDictionary methodsFor: 'shrinking'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			m _ cl compiledMethodAt: selector.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk allClassesDo: [:c | c comment: ''].	Smalltalk condenseChanges"In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."!lastRemoval  "Smalltalk lastRemoval"	#(abandonSources majorShrink printSpaceAnalysis cleanOutUndeclared obsoleteClasses lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image under 800k in size."	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FormView compile: 'defaultControllerClass 	^  NoController' classified: 'controller access'.	FileModel removeSelector: #loadIntoHyperSqueak.	FileModel removeSelector: #fileIntoNewChangeSet.	Form removeSelector: #edit.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewGIFImports.	WarpBlt compile: 'warpBitsSmoothing: n sourceMap: sourceMap		<primitive: 147>		^ self primitiveFailed' classified: 'primitives'.	"Now delete lots of classes.."	CCodeGenerator removeCompilerMethods.	SystemOrganization removeSystemCategory: 'Squeak Interpreter'.	SystemOrganization removeSystemCategory: 'Translation to C'.	SystemOrganization removeSystemCategory: 'System-Network'.	(SystemOrganization categories select: [:c | 'Morphic*' match: c]) do:		[:c | SystemOrganization removeSystemCategory: c].	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Interface-Pluggable'.	SystemOrganization removeSystemCategory: 'Object Storage'.	SystemOrganization removeSystemCategory: 'System-Sound'.	FormEditor removeFromSystem.	FormEditorView removeFromSystem.	FormMenuView removeFromSystem.	FormMenuController removeFromSystem.	FormButtonCache removeFromSystem.	"Need to do new Oval so don't need Arc"	"Also redo users of Line to use BB primitive"	Curve removeFromSystem.	LinearFit removeFromSystem.	Spline removeFromSystem.	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	CharRecog removeFromSystem.	Pattern removeFromSystem.	Array2D removeFromSystem.	FFT removeFromSystem.	ChangeSorter removeFromSystem.	DualChangeSorter removeFromSystem.	CngsClassList removeFromSystem.	CngsMsgList removeFromSystem.	Project removeFromSystem.	ProjectView removeFromSystem.	ProjectController removeFromSystem.	StringHolder class removeSelector: #originalWorkspaceContents.	StringHolder systemWorkspaceContents: ''.	SequenceableCollection removeSelector: #mappedBy:.	MappedCollection removeFromSystem.	TextConstants removeKey: #ClairVaux.  "Gets rid of a couple of fonts"	FormHolderView removeFromSystem.	FormInspectView removeFromSystem.	GeneralListView removeFromSystem.	GeneralListController removeFromSystem.	HierarchicalMenu removeFromSystem.	EmphasizedMenu removeFromSystem.	ObjectViewer removeFromSystem.	ObjectTracer removeFromSystem.	SystemBuilder removeFromSystem.	HtmlFileStream removeFromSystem.	ColorGenerator removeFromSystem.	ConciseInspector removeFromSystem.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.!printSpaceAnalysis	"Smalltalk garbageCollect; printSpaceAnalysis"	"Note: this all needs to be updated for 32-bit direct pointers"	| f name space scale count instSpace |	f _ FileStream newFileNamed: 'STspace.text'.	f timeStamp.	f nextPutAll: 'class'; tab;			nextPutAll: 'space'; tab;			nextPutAll: '#insts'; tab;			nextPutAll: 'inst space'; tab.	self allClassesDo:		[:cl | name _ cl name forceTo: 30 paddingWith: Character space.		space _ cl space.		count _ cl instanceCount.		instSpace _ (cl instSize+4)*count.		cl isVariable ifTrue:				[scale _ cl isBytes ifTrue: [4] ifFalse: [1].				cl allInstancesDo: [:x | instSpace _ instSpace + (x size//scale)]].		f nextPutAll: name; tab;			print: space; tab;			print: count; tab;			print: instSpace; cr].	f close!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages  Do a Symbol rehash afterwards."	"NOTE: We are still not catching messages that are only sent by themselves"	| sels n |	sels _ self allUnSentMessages.	"The following may want to be preserved for doIts, etc"	#(newDepth: restoreAfter: 		dragon: hilberts: mandala: web toothpaste: test3		printSpaceAnalysis removeAllUnSentMessages abandonSources removeUnreferencedKeys  obsoleteClasses zapOrganization condenseChanges) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space'!lowSpaceThreshold	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	^ 80000!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting"			^ self beep		].	].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	ScheduledControllers interruptName: 'Space is low, scroll for options'.!okayToProceedEvenIfSpaceIsLow	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."	self garbageCollectMost > self lowSpaceThreshold ifTrue: [^ true].  "quick"	self garbageCollect > self lowSpaceThreshold ifTrue: [^ true].  "work harder"	^ self confirm:'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'!useUpMemory	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemory"	| lst |	lst _ nil.	[true] whileTrue: [		lst _ Link new nextLink: lst; yourself.	].! !!SystemDictionary methodsFor: 'special objects'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 39.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "coming soon... Socket Semaphores"	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray!specialNargsAt: anInteger 	"Answer the number of arguments for the special selector at: anInteger."	^ (self specialObjectsArray at: 24) at: anInteger * 2!specialSelectorAt: anInteger 	"Answer the special message selector from the interleaved specialSelectors array."	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1!specialSelectorSize	"Answer the number of special selectors in the system."	^ (self specialObjectsArray at: 24) size // 2! !!SystemDictionary methodsFor: 'image, changes name'!changesName  "Smalltalk changesName"	"Answer the current name for the changes file that matches the image file name"	| imName |	FileDirectory splitName: self imageName		to: [:volName :fileName | imName _ fileName].	#(('.image' '.changes') ('.image.IMA' '.changes.CHA') ('.IMA' '.CHA')) do:		[:ends | (imName endsWith: ends first) ifTrue:				[^ (imName copyFrom: 1 to: imName size - ends first size) , ends last]].	^imName, '.changes'!sourcesName	"Answer the sources file name used in this Smalltalk release."	^ self vmPath, 'SqueakV1.sources'! !!SystemDictionary methodsFor: 'sources, change log'!version	"Answer the version of this release."	^ 'Squeak 1.19d of April 13, 1997'! !!SystemDictionary methodsFor: 'snapshot and quit'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk shutDownSound.	Smalltalk shutDown.	Delay shutDown.	Color shutDown.	ControlManager shutDown.	StrikeFont shutDown.	DisplayScreen shutDown.!processStartUpList	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."	DisplayScreen startUp.	Cursor startUp.	Smalltalk installLowSpaceWatcher.	"OK to do again later"	InputSensor startUp.	ProcessorScheduler hiddenBackgroundProcess.	Delay startUp.	Smalltalk startUp.	ControlManager startUp.  "NOTE: The active process terminates here."!shutDownSound	(self at: #SoundPlayer ifAbsent: [^ self]) shutDown!snapshot: save andQuit: quit	"Mark the changes file and close all files.  If save is true, save the current state of this Smalltalk in the image file.  If quit is true, then exit to the outer shell.  Note: latter part of this method runs when resuming a previously saved image. 	1/17/96 sw: ripped out the disk-library maintenance stuff	5/8/96 sw: report snapshot/quit to transcript as well as chgs log"	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList.	Cursor write show.	save ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Cursor normal show.	self processStartUpList.	!startUp	"Open the files for sources and changes."	self openSourceFiles.! !!SystemDictionary methodsFor: 'housekeeping'!cleanOutUndeclared 	Undeclared removeUnreferencedKeys!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f name oldChanges classCount dir |	dir _ FileDirectory default.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName , '.temp'.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	dir rename: self sourcesName		toBe: self sourcesName , '.old'.	dir rename: self sourcesName , '.temp'		toBe: self sourcesName.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'!makeInternalRelease		"Smalltalk makeInternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	self obsoleteClasses isEmpty ifFalse: [self halt].	Symbol rehash.	self halt: 'Ready to condense changes'.	Smalltalk condenseChanges!recompileAllFrom: firstName 	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	self allClassesDo: 		[:class | class name >= firstName			ifTrue: 				[Transcript show: class name; cr.				class compileAll]]	"Smalltalk recompileAllFrom: 'Aardvark'."!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod |	Smalltalk forgetDoIts.	Smalltalk allBehaviorsDo:		[:cls |  Transcript show: cls name; cr.		cls selectors do:			[:selector |			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod initialPC to: oldMethod endPC do:				[:i | (oldMethod at: i) = (newMethod at: i) ifFalse: [self halt]]]]! !!SystemDictionary methodsFor: 'miscellaneous'!clipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !SystemTracer comment:'NOTE:  The SystemTracer is currently under construction.  A lot of it works now in 32-bit Squeak, but nothing has been checked out carefully.  - Dan I. 3/27/97The system Tracer is the secret weapon of Smalltalk developers. Some people think it is an overnight garbage collector. It is; in fact on a decent machine (heh, heh), it is a coffee-break garbage collector. But the real value of the tracer is that it allows fundamental changes to be made to the system from within.	Basically, the tracer runs through the system tracing every accessible object, and writing a copy of each object onto a disk image. It does this carefully enough that the resulting clone can be started up and run, just like a snapshot. Some care is taken so that objects appear in the same order in the data space as they do in the object table.	The tracer has built-in support for clamping unwanted (or unneeded) categories, classes and messages out of the system. See the subclass ExportTracer for examples of the former two. A considerably more powerful clamping mechanism is the message winnowing feature. It will cull out all unreferenced messages, and then based on THOSE deletions, cull out more and so on. See the comment in winnow.	The handling of Dictionaries is still funky; IdentityDictionaries should be written hashed by the NEW oops of the keys. This is currently only done for dictionaries which contain Symbols (these must of course be remapped, as Symbols hash by their oops). It should be done for all IdentityDictionaries as well. Currently the only such dictionary in the system is the dependents dictionary in class Object, and this is handled right now by the crock of executing: (Object classPool at: #dependentsFields) rehash.	Examples of things we have done with the SystemTracer include changing the instruction set of Smalltalk. For this we define a subclass called Junta which defines a special method for writing CompiledMethods out in the new format. Then we change the virtual machine and fire up the clone. Another example is changing the format of FloatingPoint numbers.'!!SystemTracer methodsFor: 'initialize-release'!doit  "SystemTracer writeClone"	"(StandardFileStream allInstances select:		[:f | f name endsWith: 'clone.image']) do: [:f | f close]."	| time1 time2 ctxt n |	ctxt _ thisContext sender.	ctxt push: nil.	self init: ctxt.	CleaningUp _ false.	"true means rewriting special objects in writeSpecial2"	Transcript show: 'Tracing . . . '.	time1 _ Time millisecondClockValue.	file _ FileStream fileNamed: 'clone.image'.	file binary.	n _ self writeImage: (Array with: Smalltalk).	time2 _ Time millisecondClockValue.	Transcript cr; show: n printString , ' objects written in '			, (time2 - time1 //1000) printString , ' seconds.'.	"ctxt pop" "So we can resume"!init: aContext	initialProcess _ Process forContext: aContext priority: Processor activePriority.	self initOopMap.	holder _ OrderedCollection new: 100.  "Mustn't grow"	hashGenerator _ Random new.	self clamp: self.	self clamp: aContext sender.	self initDict! !!SystemTracer methodsFor: 'image'!initCompactClasses	| c |	CompactClasses _ c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: nil.	"Leave 16 to 31 for user defined compact classes."!writeFileHeader	| dataLen |	dataLen _ file position - Bias.	file position: 0.  "info in header page""This is the only official description of the file format!!!!!!!!!!"	file nextInt32Put: ($A asciiValue *100) + 1.  "version number:  6500+1"	file nextInt32Put: Bias.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	file nextInt32Put: dataLen.  "Length of data segment in words"	file nextInt32Put: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	file nextInt32Put: (self mapAt: specialObjects).	file nextInt32Put: 0.  "unused"	file nextInt32Put: 0.  "unused"	"first free oop?"	file position > Bias ifTrue: [self error: 'Header ran over allotted length'].	file padTo: Bias put: 0.  "Pad header page"	file close.	'DONE!!!!' displayAt: 20@60.	^ Array with: maxOop!writeImage: roots	| dataBase |	Bias _ 64.	"16 longs"	file position: Bias.  "Skip header section"	maxOop _ 0.  "Starting oop"	dataBase _ maxOop.  "base address for data"	addr _ dataBase.	Transcript cr; show: 'writeSpecial1'.	self writeSpecial1.	Transcript cr; show: 'writeSystem'.	self writePointers: specialObjects.		"get array itself mapped"  	roots do: [:root | self trace: root].	Transcript cr; show: 'writeSpecial2'.	self writeSpecial2.	file position: maxOop + Bias.		"End of all our objects"	Transcript cr; show: 'writeHeader'.	^ self writeFileHeader!writeSpecial1	self initCompactClasses.	specialObjects _		"1:" (Array with: nil with: false with: true 			with: (Smalltalk associationAt: #Processor))		, "5:" (Array with: Symbol with: SmallInteger with: String with: Array)		, "9:" (Array with: (Smalltalk associationAt: #Smalltalk) with: Float 				with: MethodContext with: BlockContext)		, "13:" (Array with: Point with: LargePositiveInteger 			with: Display with: Message)		, "17:" (Array with: CompiledMethod with: Rectangle 				with: Semaphore with: Character)		, "21:" (Array with: #doesNotUnderstand: with: #cannotReturn: 				with: #monitor: with: Smalltalk specialSelectors)		, "25:" (Array with: Character characterTable with: #mustBeBoolean				with: ByteArray with: LargeNegativeInteger)		, "29:" (Array with: CompactClasses with: nil 				with: nil).	specialObjects size = 31 ifFalse: [self error: 'try again!!'].	specialObjects do:  "create OT entries"		[:obj | 		self new: obj 			class: obj class 			length: (self sizeInWordsOf: obj)			trace: nil 			write: [].		(self mapAt: obj) = UnassignedOop ifTrue:			[self error: 'a special object didn''t get mapped'].		].	NewNil _ self mapAt: nil.		"how nil was mapped"	self trace: #Smalltalk; trace: #Processor "need to get mapped now"!writeSpecial2	| obj2 |	specialObjects do: 		[:obj |  "make sure parts are written"		self trace: obj class.		obj class isBits 			ifFalse: [1 to: (self sizeInWordsOf: obj) do: 						[:i | self trace: (obj instVarAt: i)]]].	"go back and write data after tracing"	CleaningUp _ true.		"new:class:length:trace:write: would ignore specialObjects because they already have oops.  This time position in file, write class, execute writeBlock to fill in the fields."	specialObjects do: 		[:obj | self perform: (writeDict at: obj class) with: obj].	CleaningUp _ false.! !!SystemTracer methodsFor: 'mapping oops'!initOopMap	"oopMap is an array 4096 long indexed by basicHash.	Each element a subarray of object/newOop/hash triplets.	The subarrrays must be linearly searched.	Access to an object causes it to be promoted in the subarray,		so that frequently accessed objects can be found quickly."	oopMap _ (1 to: 4096) collect: [:i | Array new].!mapAt: obj	"Return the new oop for this object"	| bucket |	bucket _ oopMap at: obj basicHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i)			ifTrue: ["Promote this entry for rapid access"					i > 1 ifTrue: [1 to: 3 do: [:j | bucket swap: j with: i-1+j]].					^ bucket at: 2]].	^ UnassignedOop!mapAt: obj put: oop with: hash	"Assign the new oop for this object"	| bucket |	bucket _ oopMap at: obj basicHash+1.	"Check for multiple writes (debug only)""	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [self halt]]."	oopMap at: obj basicHash+1 put: (Array with: obj with: oop with: hash) , bucket!mapHashAt: obj	"Return the new hash for this object"	| bucket |	bucket _ oopMap at: obj basicHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [^ bucket at: 3]].	self halt! !!SystemTracer methodsFor: 'clamping'!clamp: obj	self mapAt: obj put: Clamped with: nil.	(obj isKindOf: Behavior) ifTrue: 		[writeDict at: obj put: #writeClamped:.		"		Methinks the following should be done AFTER writing the clone...		Smalltalk removeKey: obj name.		SystemOrganization removeElement: obj name		"]!hasClamped: obj	"See if obj will be a SmallInteger in the new system."	obj class == SmallInteger ifTrue: [^ true].	^ (self mapAt: obj) = Clamped!preserve: refs 	"Put into the set 'refs' all the messages considered as roots in the system	to be winnowed. Those given below are a minimal set. See winnow:."	1 to: Smalltalk specialSelectorSize do:  "these at least"		[:i | refs add: (Smalltalk specialSelectorAt: i)].	refs addAll: #(doesNotUnderstand: cannotReturn: monitor: unusedOop51).	refs addAll: #()  "Lots more here for a real trace"!winnow: nPasses	"This method will clamp message out of the cloning process. First it calls 	preserve: to establish a root set of messages which must not be deleted. 	Then it makes a pass through the system figuring out which messages 	are not called from anywhere except in classes which have already been 	clamped. Then it makes another pass, picking up those which are now 	unreferenced due to the preceding deletions. And so on; usually 6 	iterations gets most everything. It is advisable to run just the winnow 	phase of the trace (2 passes, say) and then read the file chaff.st to see 	what got zapped, before doing a full trace. Chances are, you will have 	forgotten to include several messages in preserve: (qv)."	| f refs method first |	f _ FileStream fileNamed: 'chaff.st'.	" 6 iterations gets most everything"	1 to: nPasses do:		[:i | 		Transcript show: 'Winnow pass ' , i printString; cr; endEntry.		refs _ Set new: 4096.		self preserve: refs.		Smalltalk allBehaviorsDo: [:class | "collect all refs"			(self hasClamped: class)				ifFalse: [class selectors do: 						[:sel | 						method _ class compiledMethodAt: sel.						(self hasClamped: method)							ifFalse: [method literals do: [:lit | (lit isMemberOf: Symbol)										ifTrue: [refs add: lit]]]]]].		Smalltalk allBehaviorsDo: [:class | "collect all unrefs"			(self hasClamped: class)				ifFalse: 					[first _ true.					class selectors do: [:sel | (refs includes: sel)							ifFalse: 								[method _ class compiledMethodAt: sel.								(self hasClamped: method)									ifFalse: 										[first ifTrue: 											[first _ false.											f cr; cr; nextPutAll: class name; space].										self clamp: (class compiledMethodAt: sel).										class organization removeElement: sel.										f nextPutAll: sel; space]]]]].		f cr; nextPutAll: '------------'; cr].	f close! !!SystemTracer methodsFor: 'tracing and writing'!new: obj class: class length: length trace: traceBlock write: writeBlock	| oop objpos headers jog type hash |	"We assign file space for an object.	Only does something when object has not been assigned a new oop yet.  	Length is the instance vars and variable portion in longs.	Class is not included in length.	Special objects come here for an oop, and do not tracing or writing.	To trace and write their fields later, do NOT use this method."  	oop_ self mapAt: obj.	oop = UnassignedOop ifFalse:		["Has already been assigned a new oop or clamped."		CleaningUp ifTrue:			["for writeSpecial2"			self rewrite: obj class: class length: length 				trace: traceBlock write: writeBlock].		^ self].	"Write header and remember new oop in map"	hash _ (hashGenerator next * 16rFFF asFloat) asInteger.	headers _ self headersFor: obj withHash: hash.	file position: maxOop + Bias.	jog _ 0.	(headers at: 1) > 0 ifTrue: [		self write4Bytes: (headers at: 1).	"will be garbage if class not mapped yet.  See below."		jog _ jog + 4.].	"optional full length word"	((headers at: 2) > 0) | ((headers at: 1) > 0) ifTrue: [		self write4Bytes: (headers at: 2).		jog _ jog + 4.].	"optional full class word"	self write4Bytes: (headers at: 3).	"object header word"	maxOop _ maxOop + jog.		"point at header word"		"32 bits.  Include right number of header bytes"	objpos _ maxOop + Bias. "file position"	addr _ addr + jog.	self mapAt: obj put: addr with: hash.addr printString displayAt: 0@0.	"Get to the end of the object"	maxOop _ maxOop + (length+1*4).	"ready for next object"	addr _ addr + (length+1*4).	file nextPutAll: (ByteArray new: length*4 withAll: 0).		"reserve the space, header word already written"	traceBlock notNil ifTrue: [self trace: class.  traceBlock value].	file position: objpos.	"before header word"	(headers at: 2) = 0 ifFalse:		["rewrite class word in case not known before"		type _ (headers at: 2) bitAnd: 3.		file skip: -4.		file nextInt32Put: (self mapAt: class) + type].	file skip: 4.	"header word".	writeBlock value.	"No allocation of new oops is allowed in here!!"!rewrite: obj class: class length: length trace: traceBlock write: writeBlock	| newOop type |	"writeSpecial2 comes here to rewrite the guts of objects.	Go to position in file, write the class, and execute writeBlock to fill in the fields."  	newOop _ self mapAt: obj.	file position: newOop+ Bias +3.	type _ file next bitAnd: 3.		"low byte of header, tells type"	type = 3 "type" ifFalse: ["length&class or just class"			"rewrite class word in case not known before"			file skip: -8.			file nextInt32Put: (self mapAt: class) + type.			file skip: 4].		"header word. Get to first data word of object".	writeBlock value.	"No allocation of new oops is allowed in here!!"!trace: obj	(self hasClamped: obj) ifTrue: [^ self].	self perform: (writeDict at: obj class ifAbsent: [#writeClamped:])			"May be some classes not in Smalltalk dict, let them through"		with: obj.!writeBehavior: obj	| length str |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: 2 do: [:i | self writePointerField: (obj instVarAt: i)].			self writePointerField: (self instSpecFor: obj).			4 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]!writeBytes: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: 			[1 to: obj size do: [:i | file nextPut: (obj at: i) asInteger].			file padToNextLongPut: 0]!writeClamped: obj	^false!writeContext: obj	| start |	"Contexts have garbage above the stack pointer.		Nil it out to avoid a crash."	start _ obj stackPtr == nil ifTrue: [obj numArgs] ifFalse: [obj stackPtr].	start+1 to: obj size do: [:ind | obj at: ind put: nil].	^ self writePointers: obj	"Normal Case"!writeIdentityDictionary: obj 	"Elements of an IdentityDict need to be reOrdered owing to new oops.	Here we also support removal of entries for clamped values."	| perm instSize objCopy |	objCopy _ obj copy.	holder addLast: objCopy.	instSize _ objCopy class instSize.	self new: obj		class: objCopy class		length: (self sizeInWordsOf: objCopy)		trace: 			["map the keys first"			1 to: objCopy basicSize do: [:i | self trace: (objCopy basicAt: i)].			perm _ self permutationFor: objCopy.			"and permute the new value vector"			self permute: (objCopy instVarAt: 2) by: perm.			1 to: instSize do: [:i | self trace: (objCopy instVarAt: i)]]		write: 			[1 to: instSize do: [:i | self writePointerField: (objCopy instVarAt: i)].			1 to: objCopy basicSize do:				[:i | self writePointerField:					((perm at: i) == nil						ifTrue: [nil]						ifFalse: [objCopy basicAt: (perm at: i)])]]!writeMethod: obj	| nptrs |	nptrs _ obj numLiterals + 1.	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: [2 to: nptrs do: [:i | self trace: (obj objectAt: i)]]		write: 			[self writePointerField: (self methodHeader: obj).			2 to: nptrs do: [:i | self writePointerField: (obj objectAt: i)].			nptrs * 4 + 1 to: obj size do: [:i | file nextPut: (obj at: i)].			file padToNextLongPut: 0]!writePointers: obj	| length |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]!writeProcess: obj 	"Substitute new initialProcess for current."	| newObj instSize |	newObj _ obj == Processor activeProcess			ifTrue: [initialProcess]			ifFalse: [obj].	self new: obj		class: newObj class		length: (instSize _ newObj class instSize)		trace: [1 to: instSize do:				[:i | self trace: (newObj instVarAt: i)]]		write: [1 to: instSize do:				[:i | self writePointerField: (newObj instVarAt: i)]]!writeSet: obj 	"Elements of a Set need to be reOrdered owing to new oops."	| perm |	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: 			[1 to: obj class instSize do:				[:i | self trace: (obj instVarAt: i)].			"map the elements first"			1 to: obj basicSize do:				[:i | self trace: (obj basicAt: i)].			"Then get permutation based on new oop"			perm _ self permutationFor: obj]		write: 			[1 to: obj class instSize do:				[:i | self writePointerField: (obj instVarAt: i)].			1 to: obj basicSize do: 				[:i | self writePointerField: 					((perm at: i) == nil						ifTrue: [nil]						ifFalse: [obj basicAt: (perm at: i)])]]!writeWords: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: [1 to: obj basicSize do: [:i | self write4Bytes: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'private'!bitmap32For: form 	| f32 |	f32 _ Form extent: (form width+31//32*32)@ form height			offset: form offset.	form displayOn: f32 at: (0@0) - form offset.	(form width = 16 and: [(form isMemberOf: Cursor) not])  		ifTrue: ["Fill right side of halftones"				form displayOn: f32 at: (16@0) - form offset].	^ f32 bits!formatOf: obj	"Make the code that tells what kind of fields we have"	| class |	class _ obj class."       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields         4=      unused        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	^ (class isBits and: [class isBytes])		ifTrue: [^ (self formatOfCls: class)	"bytes, methods"					+ (3 - (obj size+3 bitAnd: 3))					" ** new convention means size = wordSize - lowBits"]		ifFalse: [^ (self formatOfCls: class)]!formatOfCls: class	"Make the code that tells what kind of fields we have.  This version takes a class and produces the format to be part of its instSpec word.""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields         4=      unused        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	^ class isBits 		ifTrue: [class isBytes			ifTrue: [class == CompiledMethod				ifTrue: [12]	"bytes, method"				ifFalse: [8]]	"bytes"			ifFalse: [6]]	"bits, meaning variable words of 32 bits each"		ifFalse: [class isVariable 			ifTrue: [class instSize = 0 				ifTrue: [2]	"variable length only of pointers"				ifFalse: [3]]	"fixed and variable pointer fields"			ifFalse: [class instSize = 0 				ifTrue: [0]	"no fields at all"				ifFalse: [1]]] "pointers, not variable length"!headersFor: obj withHash: hash	"Create three header words for this object.  Length, class, header bits."	"Three possibilities:		Length, class, header bits		0, class, header bits		0,0, header bits"	| header3 header2 header1 cix sizeFld |	"3 gc bits"	header1 _ 0.  "Mark, old, dirty"	header1 _ header1 bitShift: 12.	"next fld is 12 bits"	header1 _ header1 + (hash bitAnd: 16rFFF).	header1 _ header1 bitShift: 5.	sizeFld _ (self sizeInWordsOf: obj) + 1.	"size in long words, incl hdr0"	cix _ CompactClasses indexOf: obj class.	"0 means need full word"	sizeFld <= 1 ifTrue: [cix _ 0 "can't have 1-word objs"].	header2 _ self mapAt: obj class.	header1 _ header1 + (cix bitAnd: 16r1F).	header1 _ header1 bitShift: 4.	header1 _ header1 + (self formatOf: obj).	"Class characteristics"	header1 _ header1 bitShift: 6.	sizeFld > 16r3F		ifTrue: [header3 _ sizeFld bitShift: 2.				sizeFld _ 0]		ifFalse: [header3 _ 0].	header1 _ header1 + sizeFld.	header1 _ header1 bitShift: 2.	header3 > 0 ifTrue:		["3-word: type=0"		^ Array with: header3 "+0" with: header2 "+0" with: header1 "+0"].	cix = 0 ifTrue:		[ "2-word: type=1"		^ Array with: 0 with: header2+1 with: header1+1].	"1-word: type=3"	^ Array with: 0 with: 0 with: header1+3!initDict	writeDict _ Dictionary new: 256.	Smalltalk allBehaviorsDo: 			[:class | 			class isBits 				ifTrue: 					[writeDict at: class put: (class isBytes											ifTrue: [#writeBytes:]											ifFalse: [#writeWords:])]				ifFalse:					[writeDict at: class put: #writePointers:.					(class inheritsFrom: Set) | (class == Set) ifTrue:						[writeDict at: class put: #writeSet:].					(class inheritsFrom: IdentityDictionary) | 						(class == IdentityDictionary) ifTrue:						[writeDict at: class put: #writeIdentityDictionary:]].				].	Smalltalk allBehaviorsDo: 			[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.!instSpecFor: class	"SystemTracer new initCompactClasses instSpecFor: String"	"Create inst spec word for a class.	Same as the third header word for instances this object."	"<5 bits=spl class><4 bits=format><6 bits=instSize>"	| cix header2 header1 sizeFld header3 |	cix _ CompactClasses indexOf: class.	"0 means need full word"	cix = 0 ifTrue: [header2 _ (self mapAt: class) + 1 "header type"]		ifFalse: [header2 _ 0].	header1 _ cix bitAnd: 16r1F.	header1 _ header1 bitShift: 4.	header1 _ header1 + (self formatOfCls: class).	"Class characteristics"	header1 _ header1 bitShift: 6.	sizeFld _ class instSize + 1.	"in long words -- includes base header"	sizeFld > 16r3F		ifTrue: [header3 _ sizeFld bitShift: 2.				sizeFld _ 0]		ifFalse: [header3 _ 0].	header1 _ header1 + sizeFld.	^ header1 bitShift: 1	"NOTE: this will get shifted again by Integer conversion,	leaving 2 low order bits, as in base header of all objects"!methodHeader: obj	"The new header format for this method"	| h val |"  2 bits    Unused  (May later flag native mentods)   5 bits    Argument count   6 bits    Temp count   1 bit     Large context required   8 bits    Number of literals   9 bits    Primitive index                0-255 work like blue book                256-263 are quick returns of constants like bytecodes 112-119                        namely self, true, false, nil, -1, 0, 1, 2                264-... are quick return of named instance fields   1 bit     Integer bit = 1"	h _ 0.	h _ h bitShift: 5.	"next fld is 5 bits"	val _ obj numArgs.	h _ h + (val bitAnd: 16r1F).	h _ h bitShift: 6.	val _ obj numTemps.	h _ h + (val bitAnd: 16r3F).	h _ h bitShift: 1.	val _ (obj header noMask: 64) ifTrue: [0] ifFalse: [1].	h _ h + val.	"LargeContext needed?"	h _ h bitShift: 8.	val _ obj numLiterals.	h _ h + (val bitAnd: 16rFF).	h _ h bitShift: 9.	val _ self methodPrimCode: obj.	h _ h + (val bitAnd: 16r1FF).	^ h	"will be integerized when written"!methodPrimCode: obj	"obj is a CompiledMethod.  generate the primitive index field""                0-255 work like blue book                256-264 are quick returns of constants like bytecodes 112-119                        namely self, true, false, nil, -1, 0, 1, 2                265-... are quick return of named instance fields"	| val |	val _ obj primitive.	val > 0 ifTrue: [^val].	"a true primitive"	obj isReturnSelf ifTrue: [^ 256 "quick ^ self"].		"quick returns of constants like bytecodes 112-119         namely self, true, false, nil, -1, 0, 1, 2.  Add them later"	obj isReturnField ifTrue: [		^ obj returnField + 264].	^ 0	"no primitive"!newHashFor: obj	"If an object has a hash derived from its value, it will override on the way here.	This object can use anything as a hash.  Derive one from its oop."	| newOop |	(newOop _ self mapAt: obj) = UnassignedOop		ifTrue: [self halt]		ifFalse: [^ (newOop bitShift: -2) bitAnd: 16rFFF]!oopOf: obj 	"Return oops in range 1 to 32767. obj must not be an Integer."	| oop |	oop _ obj asOop.	oop >= 0		ifTrue: [^oop]		ifFalse: [self error: 'Why a negative oop?'.			"^map at: oop + 32769"]!permutationFor: array	"Return an inverse permutation for an array to permute it according to	the mapped oop values. The keys in array MUST have been mapped."	| len perm key hash |	len _ array basicSize.  	perm _ Array new: len.	1 to: len do:		[:i | key _ array basicAt: i.		(key == nil or: [self hasClamped: key])		  ifFalse:			[hash _ key hashMappedBy: self.	"Note that depends on Object hash being the same as SystemTracer oopOf: which uses Object asOop."			hash _ hash \\ len + 1.			[(perm at: hash) == nil] 				whileFalse:				[hash _ (hash = len ifTrue: [1] ifFalse: [hash + 1])].			perm at: hash put: i]].	^perm!permute: vec by: perm	| copy j len inverse |	(perm isMemberOf: Interval) ifTrue: [^perm"no-op for 1~n identity"].	len _ vec size.	copy _ Array new: len.	inverse _ Array new: len.	1 to: len do: 		[:i | 		(j _ perm at: i) == nil			ifFalse: 				[copy at: i put: (vec at: j).				inverse at: j put: i]].	1 to: len do: [:i | vec at: i put: (copy at: i)].	^inverse!sizeInWordsOf: anObject"NOTE: This is the new length of the object in LONG WORDS.		Does not include the class (header) word."	| class |	class _ anObject class.	class isBytes ifTrue: [^ anObject basicSize+3 // 4].	class isBits ifTrue: [^ anObject basicSize].	"in two byte chunks"	class isVariable ifTrue: [^ class instSize + anObject basicSize].	^ class instSize!write4Bytes: bits 	"Avoid overhead of large integers and nextWord:put:."	| oop |	bits positive	ifTrue: 		["Just splat those bits out."			file nextPut: (bits digitAt: 4).			file nextPut: (bits digitAt: 3).			file nextPut: (bits digitAt: 2).			file nextPut: (bits digitAt: 1).		]	ifFalse: 		["Change rep to twos complement."			oop _ (bits bitAnd: 16rFFFFFFFF).				"was rep as positive, make it negative by 2s complement"			file nextPut: (oop digitAt: 4).			file nextPut: (oop digitAt: 3).			file nextPut: (oop digitAt: 2).			file nextPut: (oop digitAt: 1).		]!writePointerField: obj 	| newOop |	obj class == SmallInteger ifTrue: 		[obj >= 0 ifTrue: [newOop _ obj * 2 + 1]				ifFalse: [newOop _ (16r80000000 + obj) * 2 + 1].		file nextPut: (newOop digitAt: 4).		file nextPut: (newOop digitAt: 3).		file nextPut: (newOop digitAt: 2).		file nextPut: (newOop digitAt: 1).		^ obj].			"normal pointers"	(newOop _ self mapAt: obj) = Clamped		ifTrue: ["If object in this field is not being traced, put out nil."				file nextInt32Put: NewNil]		ifFalse: [file nextInt32Put: newOop]! !!SystemTracer class methodsFor: 'instance creation'!initialize    "SystemTracer initialize"	Clamped _ -1.  "Flag clamped objects in oopMap"	UnassignedOop _ -2.  "Flag unassigned oops in oopMap"!writeClone  "SystemTracer writeClone"	| tracer |	tracer _ self new.	"Delay shutDown."  "part of Smalltalk processShutDownList."	tracer doit.   " <-- execution in clone resumes after this send"	tracer == nil "will be nil in clone, since it is clamped"		ifTrue: [Smalltalk processStartUpList]! !!TAssignmentNode methodsFor: 'all'!bindVariablesIn: aDictionary	variable _ variable bindVariablesIn: aDictionary.	expression _ expression bindVariablesIn: aDictionary.!copyTree	^self class new		setVariable: variable copyTree		expression: expression copyTree!emitCCodeOn: aStream level: level generator: aCodeGen	| sel |	self isVariableUpdatingAssignment ifTrue: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		sel _ expression selector.		sel = #+			ifTrue: [aStream nextPutAll: ' += ']			ifFalse: [aStream nextPutAll: ' -= '].			expression args first emitCCodeOn: aStream level: level generator: aCodeGen.	] ifFalse: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		aStream nextPutAll: ' = '.		expression emitCCodeOn: aStream level: level generator: aCodeGen.	].!expression	^expression!inlineMethodsUsing: aDictionary	variable inlineMethodsUsing: aDictionary.	expression inlineMethodsUsing: aDictionary.!isAssignment	^true!isVariableUpdatingAssignment	"Return true if this assignment statement is of one of the forms:		var = var + ...		var = var - ...	Such assignments statements can exploit the C updating assignment operators. For example, 'x += 4' can be generated instead of 'x = x + 4'. This produces better code under some C compilers, most notably the CodeWarrior 68K compiler."	| sel |	(expression isSend and: [expression receiver isVariable]) ifFalse: [^ false].	sel _ expression selector.	^ (expression receiver name = variable name) and: [(sel = #+) or: [sel = #-]]!nodesDo: aBlock	variable nodesDo: aBlock.	expression nodesDo: aBlock.	aBlock value: self.!printOn: aStream level: level	variable printOn: aStream level: level.	aStream nextPutAll: ' _ '.	expression printOn: aStream level: level + 2.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		variable _ variable replaceNodesIn: aDictionary.		expression _ expression replaceNodesIn: aDictionary.		self]!setVariable: varNode expression: expressionNode	variable _ varNode.	expression _ expressionNode.!variable	^variable! !!TCaseStmtNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariablesIn: aDictionary ].!cases	^cases!copyTree	^self class new		setExpression: expression copyTree		firsts: firsts copy		lasts: lasts copy		cases: (cases collect: [ :case | case copyTree ])!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariablesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 45 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.!emitCCodeOn: aStream level: level generator: aCodeGen	| indent |	indent _ (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.!expression	^expression!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by brances to that single instance of the code."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection.						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].!inlineMethodsUsing: aDictionary	expression inlineMethodsUsing: aDictionary.	cases do: [ :c | c inlineMethodsUsing: aDictionary ].!isCaseStmt	^true!nodesDo: aBlock	expression nodesDo: aBlock.	cases do: [ :c | c nodesDo: aBlock ].	aBlock value: self.!printOn: aStream level: level	aStream crtab: level.	aStream nextPutAll: 'select '.	expression printOn: aStream level: level.	aStream nextPutAll: ' in'.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream crtab: level.			aStream nextPutAll: 'case ', caseIndex printString, ':'.		].		aStream crtab: level + 1.		(cases at: i) printOn: aStream level: level + 1.	].	aStream crtab: level.	aStream nextPutAll: 'end select'.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		cases _ cases collect: [ :c | c replaceNodesIn: aDictionary ].		self]!setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList	expression _ aNode.	firsts _ firstsList.	lasts _ lastsList.	cases _ caseList.!setExpression: aNode selectors: selectorList	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression _ aNode.	selfNode _ TVariableNode new setName: 'self'.	firsts _ OrderedCollection new: 400.	lasts _ OrderedCollection new: 400.	cases _ OrderedCollection new: 400.	lastSel _ selectorList first.	firstInRun _ 0.	1 to: selectorList size do: [ :i |		sel _ selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel _ sel.			firstInRun _ i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !!TConstantNode methodsFor: 'all'!copyTree	^self class new		setValue: value!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen cLiteralFor: value).!isConstant	^true!isLeaf	^true!printOn: aStream level: level	value storeOn: aStream.!setValue: anObject	value _ anObject.!value	^value! !TempVariableNode comment:'I am a parse tree leaf representing a temporary variable'!!TempVariableNode methodsFor: 'initialize-release'!isArg: aBoolean	isAnArg _ aBoolean.	isAnArg ifTrue: [hasDefs _ true]!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	name _ varName.	self key: varName		index: i		type: type.	isAnArg _ hasDefs _ hasRefs _ false.	scope _ level!nowHasDef	hasDefs _ true!nowHasRef	hasRefs _ true!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope _ level! !!TempVariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	isAnArg ifTrue: [^ location]			ifFalse: [^ -1]!isArg	^ isAnArg!isTemp	^ true!isUndefTemp	^ hasDefs not!isUnusedTemp	^ hasRefs not!scope	^ scope! !!TempVariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color blue)			do: [aStream nextPutAll: name]! !!TestCClass1 methodsFor: 'all'!arg1: a arg2: b	"CCodeGenerator new initialize addClass: TestCClass1"	| i j k |	self var: #i declareC: 'char *i'.	i _ 'abc'.	j _ 2.	k _ 3.!ifTests	true ifTrue: [		self print: 'true case'	].	true ifFalse: [		self print: 'false case'	].	true ifTrue: [		self print: 'true case'	] ifFalse: [		self print: 'false case'	].	true ifFalse: [		self print: 'false case'	] ifTrue: [		self print: 'true case'	].!isIntegerValue: intValue	"Copied from ObjectMemory."	^ (intValue bitXor: (intValue << 1)) >= 0!loopTests	| v |	v _ 0.	[v < 10] whileTrue: [ self printNum: v.  v _ v + 1 ].	self print: ''.	[v < 1] whileFalse: [ self printNum: v.  v _ v - 1 ].	self print: ''.	1 to: 10 do: [ :i | self printNum: i ].	self print: ''.	1 to: 10 by: 2 do: [ :i | self printNum: i ].	self print: ''.!method1	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"	x & y ifTrue: [		x _ 10.		y _ 20.	].	y _ nil + 3.	x = nil ifTrue: [ x _ 18 ].	^nil!method2	self method1; method8: 0; setX: 10 Y: 20.!method3	x > 0 ifTrue: [ ^x ] ifFalse: [ ^y ].!method4	x _ 0.	y _ 0.	[x < 100] whileTrue: [		y _ y + x.		x _ x + 1.	].	^y!method5	self inline: true.	x & y.	x | y.	x and: [y].	x or: [y].	x not.	x + y.	x - y.	x * y.	x // y.	x \\ y.	x min: y.	x max: y.	x bitAnd: y.	x bitOr: y.	x bitXor: y.	x bitInvert32.	x bitShift: y.	x >> y.	x << y.	x < y.	x <= y.	x = y.	x >= y.	x > y.	x ~= y.	x == y.	x isNil.	x notNil.	[x > y] whileTrue: [ x _ x + 1 ].	[x > y] whileFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ].	x > y ifFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ] ifFalse: [ x _ x + 1 ].	x > y ifFalse: [ x _ x + 1 ] ifTrue: [ x _ x - 1 ].	x at: 3.	x at: 3 put: y.	self integerValueOf: x.	self integerObjectOf: x.	(self isIntegerObject: x) ifTrue: [ x _ x - 1 ].	(self isIntegerValue: x) ifTrue: [ x _ x - 1 ].	self cCoerce: x * (y - 1) to: 'int'.	x _ x + 1.	x _ x - 1.	x preDecrement.	y preIncrement > 0 ifTrue: [ x _ x + 1 ].!method6	self dispatchOn: x in: #(f1 f2 f3 f4 f5).!method7	| t1 |	self method1.	self method2.	t1 _ self method3.	self method4.	self method5.!method8: arg	| a |	self returnTypeC: 'float'.	self var: #a    declareC: 'float a = 0'.	self var: #arg declareC: 'float arg'.	self cCode: 'a = arg * 3.14159'.	^a!print: val	self cCode: 'printf("%d\n", val)'.!printNum: i	self cCode: 'printf("%d ", i)'.!setX: newX Y: newY	x _ newX min: newY.	y _ newY.! !!TestCClass2 methodsFor: 'all'!atAllPut	| i |	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: 5.		i _ i - 1.	].	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].!error: s	"Print an error message and exit."	self print: 'Error in %s\n' f: s.	self exit: -1.!incrementAll	| oldVal i |	oldVal _ vect at: 1.	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: ((vect at: i) + 1).		i _ i - 1.	].	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].!initialize	VectSize _ 10000.	vect _ Array new: VectSize.!main	| startTicks ticks |	self printf: 'atAllPut: '.	startTicks _ self clock.	self atAllPut.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'incrementAll: '.	self incrementAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'nestedWhileLoop: '.	self nestedWhileLoop.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sieve: '.	self sieve.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumAll: '.	self sumAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumFromTo: '.	self sumFromTo.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.!nestedWhileLoop	| sum i j |	sum _ 0.	i _ 1000.	[i > 0] whileTrue: [		j _ 100.		[j > 0] whileTrue: [			sum _ sum + 1.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].!sieve	| flagsSize flags primeCount i k |	flagsSize _ 8190.	flags _ Array new: flagsSize.	i _ flagsSize.	[i > 0] whileTrue: [		flags at: i put: true.		i _ i - 1.	].	primeCount _ 0.	i _ 2.	[i <= flagsSize] whileTrue: [		(flags at: i) ifTrue: [			primeCount _ primeCount + 1. "i is a prime"			k _ i + i.			[k <= flagsSize] whileTrue: [				flags at: k put: false. "k is not a prime; it is a multiple of i"				k _ k + i.			].		].		i _ i + 1.	].	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].!sumAll	| elementVal sum i |	elementVal _ vect at: 1.	sum _ 0.	i _ VectSize.	[i > 0] whileTrue: [		sum _ sum + (vect at: i).		i _ i - 1.	].	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].!sumFromTo	| sum i j |	i _ 10.	[i > 0] whileTrue: [		sum _ 0.		j _ 10000.		[j > 0] whileTrue: [			sum _ sum + j.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].! !!TestCClass2 class methodsFor: 'testing'!test	"TestCClass2 test"	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"	| bm |	bm _ self new initialize.	Transcript show: 'atAllPut: '.	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.	Transcript show: 'incrementAll: '.	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.	Transcript show: 'nestedWhileLoop: '.	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.	Transcript show: 'sieve: '.	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.	Transcript show: 'sumAll: '.	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.	Transcript show: 'sumFromTo: '.	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.! !!TestCClass3 methodsFor: 'all'!dispatchOn: currentBytecode in: selectorArray	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (currentBytecode + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."	"Note: Delete this method from the generated code."	"assert: (currentBytecode >= 0) | (currentBytecode < selectorArray size)"	self perform: (selectorArray at: (currentBytecode + 1)).!f1	| local r |	local _ self functionWithLabel: 1.	r _ 7.	self print: 'f1'.!f2	| local i |	local _ 2.	i _ self functionWithLabel: -2.	i > 0 ifTrue: [ ^ -1 ].	self print: 'f2'.!f3	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f3'.!f4	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f4'.!f5	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f5'.!functionWithLabel: arg	arg > 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].!interpret	"TestCClass3 new main"	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"	0 to: 9 do: [ :currentBytecode |		self dispatchOn: currentBytecode in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).	].!print: s	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.! !Text comment:'I represent a String that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set (Array actually) of TextAttributes with each character in its character string.  These attributes include mainly a font number and possibly some other emphasis.  Font numbers are interpreted relative to a TextStyle, which may be a copy of the default, or some other textStyle stored, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.'!!Text methodsFor: 'emphasis'!addAttribute: att 	^ self addAttribute: att from: 1 to: self size!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])!allBold 	"Force this whole text to be bold."	string size = 0 ifTrue: [^self].	self makeBoldFrom: 1 to: string size!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	attributes isNumber		ifTrue: [^ Array with: (TextFontChange new fontNumber: attributes)].  "backward compat"	^ attributes	!emphasizeFrom: start to: stop with: emphasis	"Set the emphasis for characters in the interval start to stop."	runs _ 		runs			copyReplaceFrom: start			to: stop			with: (RunArray new: stop - start + 1 withAll: 					(Array with: (TextFontChange new fontNumber: emphasis)))!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes _ runs at: characterIndex.	attributes isNumber ifTrue: [^ attributes].  "Backward compatibility"	fontNumber _ 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].	^ fontNumber	!makeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'private'!becomeModern	"Text allInstancesDo: [:txt | txt becomeModern]" 	runs mapValues:	[:val | val isNumber		 ifTrue: [val = 0 ifTrue: [Array new]					ifFalse: [val\\3=0							ifTrue: [Array with: (TextFontChange fontNumber: val//3+1)]							ifFalse: [Array with: (TextFontChange fontNumber: val//3+1)										with: (TextEmphasis perform: (#(bold italic) at: val\\3))]]]		ifFalse: [val]]!checkModern	"Text allInstancesDo: [:txt | txt checkModern]" 	runs values do: [:val | val isNumber ifTrue: [self halt]]! !!Text class methodsFor: 'class initialization'!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm put:				(Form extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -3@0).	self initTextConstants! !!Text class methodsFor: 'instance creation'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, 	aString."	^self string: aString attribute: (TextFontChange fontNumber: 1)!fromUser	"Answer an instance of me obtained by requesting the user to type some 	characters into a prompter (a FillInTheBlank object)."	FillInTheBlank		request: 'Type text followed by carriage return'		displayAt: (50@ Display boundingBox height//2)		centered: false		action: [:result]		initialAnswer: ''.	^self fromString: result!streamContents: blockWithArg 	| stream |	stream _ TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents!string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: (Array with: att)!string: aString attributes: atts	"Answer an instance of me whose characters are those of the argument, 	aString. atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)!string: aString emphasis: code	"Answer an instance of me whose characters are those of the argument, 	aString. Use the font whose index into the default TextStyle font array is 	code."	code isNumber ifTrue:		[^ self string: aString runs: (RunArray new: aString size withAll: 			(Array with: (TextFontChange new fontNumber: code)))].	^ self string: aString attributes: code! !!Text class methodsFor: 'private'!addAttribute: att toArray: others 	"Add a new text attribute to an existing set"	| oldEmph |	^ Array streamContents:		[:strm | others do:			[:other | other isNumber				ifTrue: [oldEmph _ TextFontChange new fontNumber: other.						(att dominates: oldEmph) ifFalse: [strm nextPut: oldEmph]]				ifFalse: [(att dominates: other) ifFalse: [strm nextPut: other]]].		att set ifTrue: [strm nextPut: att]]! !!TextAction methodsFor: 'as yet unclassified'!actOnClickFor: anObject	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	Compiler evaluate: evalString for: anObject logged: false.	^ true!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Color cyan!evalString: str	evalString _ str! !!TextAction class methodsFor: 'as yet unclassified'!evalString: str	^ self new evalString: str! !!TextAttribute methodsFor: 'as yet unclassified'!actOnClickFor: model	"Subclasses may override to provide, eg, hot-spot actions"	^ false!dominates: another	"Subclasses may override condense multiple attributes"	^ false!emphasizeScanner: scanner	"Subclasses may override to set, eg, font, color, etc"!oldEmphasisCode: default	"Allows running thorugh possibly multiple attributes	and getting the emphasis out of any that has an emphasis (font number)"	^ default!set	"Respond true to include this attribute (as opposed to, eg, a bold	emphasizer that is clearing the property"	^ true! !!TextCollector methodsFor: 'character writing'!bs	"Backspace the Transcript.  Put in at Alan's request 1/31/96 sw"	"Transcript bs"	contents _ contents allButLast.	self changed: #update! !!TextColor methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other color = color]!color	^ color!color: aColor	color _ aColor!dominates: other	^ other isMemberOf: self class!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: color!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: color! !!TextColor class methodsFor: 'as yet unclassified'!black	^ self new color: Color black!blue	^ self new color: Color blue!color: aColor	^ self new color: aColor!cyan	^ self new color: Color cyan!green	^ self new color: Color green!magenta	^ self new color: Color magenta!red	^ self new color: Color red!yellow	^ self new color: Color yellow! !!TextEmphasis methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other emphasisCode = emphasisCode]!dominates: other	(emphasisCode = 0 and: [other isMemberOf: TextAction]) ifTrue: [^ true].	^ (other isMemberOf: self class)		and: [emphasisCode = 0			or: [emphasisCode = other emphasisCode]]!emphasisCode	^ emphasisCode!emphasisCode: int	emphasisCode _ int.	setMode _ true!emphasizeScanner: scanner	"Set the emphasist for text display"	scanner addEmphasis: emphasisCode!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: emphasisCode!set	^ setMode and: [emphasisCode ~= 0]!turnOff	setMode _ false! !!TextEmphasis class methodsFor: 'as yet unclassified'!bold	^ self new emphasisCode: 1!italic	^ self new emphasisCode: 2!narrow	^ self new emphasisCode: 8!normal	^ self new emphasisCode: 0!struckOut	^ self new emphasisCode: 16!underlined	^ self new emphasisCode: 4! !!TextFontChange methodsFor: 'as yet unclassified'!= other 	^ (other isMemberOf: self class) 		and: [other fontNumber = fontNumber]!dominates: other	^ other isMemberOf: self class!emphasizeScanner: scanner	"Set the font for text display"	scanner setFont: fontNumber!fontNumber	^ fontNumber!fontNumber: int	fontNumber _ int!printOn: strm	super printOn: strm.	strm nextPutAll: ' font: '; print: fontNumber! !!TextFontChange class methodsFor: 'as yet unclassified'!font1	^ self new fontNumber: 1!font2	^ self new fontNumber: 2!font3	^ self new fontNumber: 3!font4	^ self new fontNumber: 4!fontNumber: n	^ self new fontNumber: n! !!TextFontReference methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the actual font for text display"	scanner setActualFont: font!toFont: aFont	font _ aFont! !!TextFontReference class methodsFor: 'as yet unclassified'!toFont: aFont	^ self new toFont: aFont! !!TextLineInterval methodsFor: 'accessing'!baseline	^ baseline!lineHeight	^ lineHeight! !!TextLineInterval methodsFor: 'private'!lineHeight: height baseline: ascent	lineHeight _ height.	baseline _ ascent! !!TextLineInterval class methodsFor: 'instance creation'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| newSelf |	newSelf _ super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !!TextLinkToImplementors methodsFor: 'as yet unclassified'!actOnClickFor: modelIgnored	Smalltalk browseAllImplementorsOf: selector.	^ true!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Color red!selector: sel	selector _ sel! !!TextLinkToImplementors class methodsFor: 'as yet unclassified'!of: selector	^ self new selector: selector! !!TextStream methodsFor: 'as yet unclassified'!applyAttribute: att beginningAt: startPos	collection addAttribute: att from: startPos to: self position!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	((aCollection isMemberOf: String) not or: [position + n > writeLimit])		ifTrue: [^ super nextPutAll: aCollection].	collection string		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n!withAttribute: att do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !!TextStyle methodsFor: 'accessing'!centered	alignment _ 2!justified	alignment _ 3!leading	"Leading (from typographers historical use of extra lead (type metal))	is the extra spacing above and beyond that needed just to accomodate	the various font heights in the set."	^ leading!leading: yDelta	leading _ yDelta!leftFlush	alignment _ 0!rightFlush	alignment _ 1! !!TextStyle methodsFor: 'fonts and font indexes'!collectionFromFileNamed: fileName	"Read the file.  It is an Array of StrikeFonts.  File format is the ReferenceStream version 2 format.  For any fonts with new names, add them to DefaultTextStyle.fontArray.  	To write out fonts: (TextStyle default fontArray saveOnFile2).	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** 8/19/96 tk"	| ff this names |	ff _ SmartRefStream fileNamed: fileName.	this _ ff next.	ff close.	this class == Array ifTrue:			[names _ self fontNames.			this do: [:each | each class == StrikeFont ifTrue:				[(names includes: each name) ifFalse:					[fontArray _ fontArray copyWith: each]]]].! !!TextStyle methodsFor: 'private'!consolidate	"If this style includes any fonts that are also in the default style,	then replace them with references to the default ones.""	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]"	| defFonts font |	defFonts _ TextStyle default fontArray.	1 to: fontArray size do:		[:i | font _ fontArray at: i.		1 to: defFonts size do:			[:j | (font name asUppercase copyWithout: $ )			= ((defFonts at: j) name asUppercase copyWithout: $ )			ifTrue: [fontArray at: i put: (defFonts at: j)]]]!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font _ self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	8/20/96 tk, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"	baseline _ (fontArray at: 1) ascent + leading.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle class methodsFor: 'instance creation'!initDefaultFontsAndStyle	"This provides the system with 10 and 12-pt basal fonts.	Bold and italic versions will be automatically generated as needed"	| fontArray |		fontArray _ Array new: 2.	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: fontArray).	"TextStyle initDefaultFontsAndStyle."!initialize  "TextStyle initialize"	"Just for installing new text changes; then throw away"	TextStyle allInstancesDo: [:s | s leading: 2]!new	^ super new leading: 2! !!TGoToNode methodsFor: 'all'!copyTree	^self class new setLabel: label!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.!isGoTo	^true!label	^label!printOn: aStream level: level	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.!setLabel: aString	label _ aString.! !!TileMorph methodsFor: 'initialization'!initialize	super initialize.	self color: (Color r: 0.8 g: 1.0 b: 0.6).	self borderWidth: 1.	type _ #literal.  "#literal, #slotRef, #objRef, #operator, #expression"	targetName _ ''.	slotName _ ''.	literal _ 1.!setExpression: exprString label: labelString	type _ #expression.	operatorOrExpression _ exprString.	self line1: labelString.!setLiteral: anObject	| m |	type _ #literal.	m _ StringCostumeMorph new.	m target: self; getSelector: #literal; putSelector: #literal:.	self addMorph: m.	self literal: anObject.!setObjectRef: aString	type _ #objRef.	targetName _ aString.	self line1: aString.!setOperator: aString	type _ #operator.	operatorOrExpression _ aString asSymbol. 	self line1: aString.!setSlotRef: aString in: objectName	type _ #slotRef.	targetName _ objectName.	slotName _ aString.	self line1: objectName, '''s' line2: slotName.! !!TileMorph methodsFor: 'accessing'!literal	^ literal!literal: anObject	literal _ anObject.	self updateLiteralLabel.!operatorOrExpression	^ operatorOrExpression!slotName	^ slotName!targetName	^ targetName!type	^ type! !!TileMorph methodsFor: 'code generation'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s.	^ s contents!precedingTileType	"Return the slot reference type of the preceding TileMorph in my owner."	| row i tile |	row _ owner submorphs.	i _ row indexOf: self.	((i > 1) and: [(tile _ row at: i - 1) isKindOf: TileMorph])		ifTrue: [^ tile type]		ifFalse: [^ #unknown].!slotRefType	"Return the slot reference type of this slot reference by looking at the next TileMorph in my owner."	| row i tile |	row _ owner submorphs.	i _ row indexOf: self.	((i < row size) and: [(tile _ row at: i + 1) isKindOf: TileMorph]) ifTrue: [		'set:' = tile operatorOrExpression ifTrue: [^ #set].		(UpdatingOperators includesKey: tile operatorOrExpression)			ifTrue: [^ #update]].	^ #get!storeCodeOn: aStream	| op refType |	type = #expression ifTrue: [		^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue: [		^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type = #objRef ifTrue: [		^ aStream nextPutAll: targetName].	type = #operator ifTrue: [		((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op].		^ self].	type = #slotRef ifTrue: [		refType _ self slotRefType.		refType = #get ifTrue: [			^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName].		refType = #set ifTrue: [			^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPut: $:].		refType = #update ifTrue: [			^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]].! !!TileMorph methodsFor: 'other'!defaultH	^ 25!defaultW	^ 25! !!TileMorph methodsFor: 'private'!line1: line1	| m desiredW |	self removeAllMorphs.	m _ StringMorph new contents: line1.	desiredW _ m width + 6.	self extent: (desiredW max: self defaultW) @ self defaultH.	m position: self center - (m extent // 2).	self addMorph: m.!line1: line1 line2: line2	| m1 m2 desiredW |	self removeAllMorphs.	m1 _ StringMorph new contents: line1.	m2 _ StringMorph new contents: line2.	desiredW _ (m1 width max: m2 width) + 6.	self extent: (desiredW max: self defaultW) @ self defaultH.	m1 position: (bounds center x - (m1 width // 2) + 1)@(bounds top + 1).	m2 position: (bounds center x - (m2 width // 2) + 1)@(m1 bottom - 2).	self addMorph: m1; addMorph: m2.!updateLiteralLabel	| myLabel desiredW |	myLabel _ nil.	submorphs do: [:m | (m isKindOf: StringCostumeMorph) ifTrue: [myLabel _ m]].	myLabel ifNil: [^ self].	myLabel contents: literal printString.	desiredW _ myLabel width + 6.	self extent: (desiredW max: self defaultW) @ self defaultH.	myLabel position: (bounds center x - (myLabel width // 2) + 1)@(bounds top + 6).! !!TileMorph class methodsFor: 'class initialization'!initialize	"TileMorph initialize"	UpdatingOperators _ Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.! !!Time class methodsFor: 'instance creation'!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	| secondsInHour hours secs |	secs _ secondCount asInteger.	hours _ secs // 3600.	secondsInHour _ secs \\ 3600.	^self new hours: hours			   minutes: secondsInHour // 60			   seconds: secondsInHour \\ 60! !!TLabeledCommentNode methodsFor: 'all'!copyTree	^self class new		setLabel: label		comment: comment!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C comment with optional label."	self printOptionalLabelOn: aStream.	aStream nextPutAll: '/* '.	aStream nextPutAll: comment.	aStream nextPutAll: ' */'.!isComment	"Answer true if the receiver is just a comment (i.e., it has no label)."	^label = nil!isLabel	^true!isLeaf	^true!label	^label!printOn: aStream level: level	self printOptionalLabelOn: aStream.	aStream nextPut: $".	aStream nextPutAll: comment.	aStream nextPut: $".!printOptionalLabelOn: aStream	label ~= nil ifTrue: [		self unindentOneTab: aStream.		aStream nextPutAll: label.		aStream nextPut: $:.		aStream tab.		].!setComment: commentString	label _ nil.	comment _ commentString.!setLabel: labelString	label _ labelString.!setLabel: labelString comment: commentString	label _ labelString.	comment _ commentString.!unindentOneTab: aStream	"Remove the last tab from the given stream if possible."	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].	aStream position > 0 ifTrue: [		aStream position: aStream position - 1.		"restore stream position if previous char was not a tab"		aStream peek = Character tab ifFalse: [ aStream next ].	].! !!TMethod methodsFor: 'initialization'!setSelector: sel args: argList locals: localList block: aBlockNode	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [ :arg | arg key ].	locals _ localList asOrderedCollection collect: [ :arg | arg key ].	declarations _ Dictionary new.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.		"set to true when all possible inlining has been done"	self removeFinalSelfReturn.	self recordDeclarations.!setSelector: sel returnType: retType args: argList locals: localList declarations: decls parseTree: aNode labels: labelList complete: completeFlag	"Initialize this method using the given information. Used for copying."	selector _ sel.	returnType _ retType.	args _ argList.	locals _ localList.	declarations _ decls.	parseTree _ aNode.	labels _ labelList.	complete _ completeFlag.! !!TMethod methodsFor: 'accessing'!args	"The arguments of this method."	^args!declarations	"The type declaration dictionary of this method."	^declarations!isComplete	"A method is 'complete' if it does not contain any more inline-able calls."	^complete!labels	^labels!locals	"The local variables of this method."	^locals!parseTree	"The parse tree of this method."	^parseTree!parseTree: aNode	"Set the parse tree of this method."	parseTree _ aNode.!returnType	"The type of the values returned by this method. This string will be used in the C declaration of this function."	^returnType!selector	"The Smalltalk selector of this method."	^selector!selector: newSelector	selector _ newSelector.!statements	parseTree isStmtList		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].	((parseTree args = nil) or: [parseTree args isEmpty])		ifFalse: [ self error: 'expected method parse tree to have no args' ].	^parseTree statements! !!TMethod methodsFor: 'primitive compilation'!argConversionExprFor: varName stackIndex: stackIndex	"Return the parse tree for an expression that fetches and converts the primitive argument at the given stack offset."	| expr decl |	expr _ '(self longAt: stackPointer - ( ', stackIndex printString, ' * 4))'.	(declarations includesKey: varName) ifTrue: [  "array"		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [			expr _ varName, ' _ self arrayValueOf: ', expr.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self floatValueOf: ', expr.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self checkedIntegerValueOf: ', expr.	].	^ self statementsFor: expr varName: varName!checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr _ 'successFlag ifFalse: [^ nil ]'.	^ self statementsFor: expr varName: ''!covertToZeroBasedArrayReferences	"Replace the index expressions in at: and at:put: messages with (<expr> - 1), since C uses zero-based array indexing."	| oldIndexExpr newIndexExpr |	parseTree nodesDo: [ :n |		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [			oldIndexExpr _ n args first.			oldIndexExpr isConstant ifTrue: [				"index expression is a constant: decrement the constant now"				newIndexExpr _ TConstantNode new setValue: (n args first value - 1).			] ifFalse: [				"index expression is complex: build an expression to decrement result at runtime"				newIndexExpr _ TSendNode new					setSelector: #-					receiver: oldIndexExpr					arguments: (Array with: (TConstantNode new setValue: 1)).			].			n args at: 1 put: newIndexExpr.		].	].!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr _ 'rcvr _ self longAt: stackPointer - (', args size printString, ' * 4)'.	^ self statementsFor: expr varName: ''!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| decl expr |	(declarations includesKey: varName) ifTrue: [		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			expr _ varName, ' _ self fetchArray: ', instIndex printString, ' ofObject: rcvr'.		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			expr _ varName, ' _ self fetchFloat: ', instIndex printString, ' ofObject: rcvr'.		].	] ifFalse: [  "undeclared variables are taken to be integer"		expr _ varName, ' _ self fetchInteger: ', instIndex printString, ' ofObject: rcvr'.	].	^ self statementsFor: expr varName: varName!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr _ 'self storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	^ self statementsFor: expr varName: varName!popArgsExpr	"Return the parse tree for an expression that removes the primitive's arguments from the stack."	| expr |	expr _ 'self pop: ', args size printString.	^ self statementsFor: expr varName: ''!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain explicit returns	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o compiled primitives can only return self"	| prolog postlog instVarsUsed varsAssignedTo instVarList varName |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	"add receiver fetch to prolog"	prolog addAll: self fetchRcvrExpr.	"add arg conversions to prolog"	1 to: args size do: [ :argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex).	].	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [ :varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1).			].		].	].	prolog addAll: self checkSuccessExpr.	postlog addAll: self popArgsExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [ self error: 'local name conflicts with instance variable name' ].	self hasReturn		ifTrue: [ self error: 'returns in primitive methods are not yet supported' ].	selector _ 'prim', aClass name, selector.	parseTree setStatements: prolog, parseTree statements, postlog.	self covertToZeroBasedArrayReferences.!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	s nextPutAll: '| rcvr stackPointer successFlag ', varName,' |'; cr.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTMethodFromClass: Object) statements! !!TMethod methodsFor: 'transformations'!bindClassVariablesIn: constantDictionary	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."	parseTree _ parseTree bindVariablesIn: constantDictionary.!buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size = 2) and:	 [aSendNode args last isConstant and:	 [aSendNode args last value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args last value!prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts _ node statements.			1 to: stmts size do: [ :i |				stmt _ stmts at: i.				(stmt isSend and: [stmt selector = #dispatchOn:in:]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].!recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'	 and remove the declarations from the method body."	| newStatements isDeclaration |	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		isDeclaration _ false.		stmt isSend ifTrue: [			stmt selector = #var:declareC: ifTrue: [				isDeclaration _ true.				declarations at: stmt args first value asString put: stmt args last value.			].			stmt selector = #returnTypeC: ifTrue: [				isDeclaration _ true.				returnType _ stmt args last value.			].		].		isDeclaration ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 [lastStmt expression name = 'self']]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TMethod methodsFor: 'utilities'!allCalls	"Answer a collection of selectors for the messages sent by this method."	^parseTree allCalls!copy	"Make a deep copy of this TMethod."	^self class basicNew		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		parseTree: parseTree copyTree		labels: labels copy		complete: complete!freeVariableReferences	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isVariable ifTrue: [ refs add: node name asString ].	].	args do: [ :var | refs remove: var asString ifAbsent: [] ].	locals do: [ :var | refs remove: var asString ifAbsent: [] ].	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].	^ refs asSortedCollection!hasNoCCode	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."	declarations isEmpty ifFalse: [ ^ false ].	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node selector = #cCode: ifTrue: [ ^ false ].		].	].	^ true!nodeCount	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	parseTree nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt!variablesAssignedTo	"Answer a collection of variables assigned to by this method."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [ refs add: node variable name ].	].	^ refs! !!TMethod methodsFor: 'inlining'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList _ OrderedCollection new: 16.	substitutionDict _ Dictionary new.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName asSymbol put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList!checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete _ true.	stmtLists do: [ :stmtList |		stmtList statements do: [ :node |			(self inlineableSend: node in: aCodeGen) ifTrue: [				complete _ false.  "more inlining to do"				^self			].		].	].	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			complete _ false.  "more inlining to do"			^self		].	].!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed |	labelUsed _ false.	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [ :stmt |				(stmt isReturn) ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TAssignmentNode new								setVariable: (TVariableNode new setName: exitVar)								expression: stmt expression).					].					(stmt == parseTree statements last) ifFalse: [						"generate a goto (this return is NOT the last statement in the method)"						newStmts add: (TGoToNode new setLabel: exitLabel).						labelUsed _ true.					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args do: [ :a | (self isSubstitutableNode: a intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp _ 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt _ stmtNode statements first.				stmt isSend ifTrue: [					sel _ stmt selector.					meth _ aCodeGen methodNamed: sel.					((meth ~= nil) and:					 [meth hasNoCCode and:					 [meth args size = 0]]) ifTrue: [						meth _ meth copy.						maxTemp _ maxTemp max: (meth renameVarsForCaseStmt).						meth hasReturn ifTrue: [							exitLabel _ self unusedLabelForInliningInto: self.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel _ nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements _ stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addAllFirst: meth statements.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars _ (locals, args) asSet.	1 to: maxTemp do: [ :i |		v _ ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].!inlineCodeOrNilForStatement: aNode in: aCodeGen	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| stmts |	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			stmts _ self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen.			^stmts		].	].	aNode isAssignment ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen		].	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen		].	].	^nil!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict _ Dictionary new.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName asSymbol put: exprNode.		locals remove: argName.	].	meth parseTree bindVariablesIn: substitutionDict.	^meth statements first expression!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType _ meth returnType.		] ifFalse: [			exitLabel _ self unusedLabelForInliningInto: self.			labelUsed _ meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ labels add: exitLabel ]				ifFalse: [ exitLabel _ nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'int']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts _ OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add:			(TLabeledCommentNode new				setLabel: exitLabel comment: 'end ', meth selector).	].	^inlineStmts!isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	(parseTree statements size = 1 and:	 [parseTree statements last isReturn]) ifFalse: [ ^false ].	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].	^true!isSubstitutableNode: aNode	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	aNode isConstant ifTrue: [ ^true ].	^aNode isVariable and:		[(locals includes: aNode name) or:		[args includes: aNode name]]!isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var _ aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var _ node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists _ OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething _ false.	sendsToInline _ Dictionary new.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething _ true.		parseTree _ parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	stmtLists _ self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements _ OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething _ true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"	].	^didSomething!unusedLabelForInliningInto: targetMethod	| usedLabels |	usedLabels _ labels asSet.	usedLabels addAll: targetMethod labels.	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels! !!TMethod methodsFor: 'inlining support'!addVarsDeclarationsAndLabelsOf: methodToBeInlined	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."	methodToBeInlined args, methodToBeInlined locals do: [ :v |		(locals includes: v) ifFalse: [ locals addLast: v ].	].	methodToBeInlined declarations associationsDo: [ :assoc |		declarations add: assoc.	].	methodToBeInlined labels do: [ :label |		labels add: label.	].!computePossibleSideEffectsIn: aCodeGen	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^true ].		].	].	^ false!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree statements last isReturn!extractInlineDirective	"Scan the top-level statements for an inlining directive of the form:		self inline: <boolean>	 and remove the directive from the method body. Return the argument of the directive or #dontCare if there is no inlining directive."	| result newStatements |	result _ #dontCare.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #inline:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result!hasReturn	"Answer true if this method contains a return statement."	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].	^ false!maySubstituteGlobal: globalVar in: aCodeGen	"Answer true if this method does or may have side effects on the given global variable."	possibleSideEffectsCache = nil ifTrue: [		"see if this calls any other method and record the result"		possibleSideEffectsCache _ self computePossibleSideEffectsIn: aCodeGen.	].	possibleSideEffectsCache ifTrue: [ ^ false ].	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [			node variable name = globalVar ifTrue: [ ^ false ].		].	].	"if we get here, receiver calls no other method	 and does not itself assign to the given global variable"	^ true!renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels _ destMethod labels asSet.	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap _ Dictionary new.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.!renameLabelsUsing: aDictionary	"Rename all labels according to the old->new mappings of the given dictionary."	labels _ labels collect: [ :label |		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].	].	parseTree nodesDo: [ :node |		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].	].!renameVariablesUsing: aDictionary	"Rename all variables according to old->new mappings of the given dictionary."	| newDecls |	"map args and locals"	args _ args collect: [ :arg |		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].	].	locals _ locals collect: [ :v |		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].	].	"map declarations"	newDecls _ declarations species new.	declarations associationsDo: [ :assoc |		(aDictionary includesKey: assoc key)			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]			ifFalse: [ newDecls add: assoc ].	].	declarations _ newDecls.	"map variable names in parse tree"	parseTree nodesDo: [ :node |		(node isVariable and:		 [aDictionary includesKey: node name]) ifTrue: [			node setName: (aDictionary at: node name).		].		(node isStmtList and: [node args size > 0]) ifTrue: [			node setArguments:				(node args collect: [ :arg |					(aDictionary includesKey: arg)						ifTrue: [ aDictionary at: arg ]						ifFalse: [ arg ].				]).		].	].!renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i _ 1.	varMap _ Dictionary new.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i _ i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1!renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars _ aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars _ destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap _ Dictionary new.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.!unusedNamePrefixedBy: aString avoiding: usedNames	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."	| n newVarName |	n _ 1.	newVarName _ aString, n printString.	[usedNames includes: newVarName] whileTrue: [		n _ n + 1.		newVarName _ aString, n printString.	].	usedNames add: newVarName.	^ newVarName! !!TMethod methodsFor: 'C code generation'!emitCCodeOn: aStream generator: aCodeGen	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."	self emitCHeaderOn: aStream generator: aCodeGen.	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.	aStream nextPutAll: '}'; cr.!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.!emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionPrototype: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	locals do: [ :var |		aStream nextPutAll: '    '.		aStream nextPutAll: (declarations at: var ifAbsent: [ 'int ', var]), ';'; cr.	].	locals isEmpty ifFalse: [ aStream cr ].! !!TMethod methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'TMethod(', selector, ')'.! !!TParseNode methodsFor: 'all'!allCalls	"Answer a collection of selectors for the messages sent in this parse tree."	| calls |	calls _ Set new: 100.	self nodesDo: [ :node |		node isSend ifTrue: [ calls add: node selector ].	].	^calls!bindVariablesIn: aDictionary	^self!hasExplicitReturn	self nodesDo: [ :node |		node isReturn ifTrue: [ ^true ].	].	^false!inlineMethodsUsing: aDictionary	self!isAssignment	^false!isCaseStmt	^false!isComment	^false!isConstant	^false!isGoTo	^false!isLabel	^false!isLeaf	"Answer true if the receiver is a variable or a constant node."	^false!isReturn	^false!isSend	^false!isStmtList	^false!isVariable	^false!nodeCount	"Answer the number of nodes in this parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	self nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt!nodesDo: aBlock	aBlock value: self.!printOn: aStream 	"Append a description of the receiver onto the given stream."	self printOn: aStream level: 0.!printOn: aStream level: anInteger 	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."	super printOn: aStream.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [self]! !!TrashCanMorph methodsFor: 'as yet unclassified'!acceptDroppingMorph: aMorph event: evt	aMorph delete.!addLabel	| m |	self removeAllMorphs.	m _ StringMorph new contents: 'Trash'.	self extent: (m width + 6) @ (m height + 10).	m position: self center - (m extent // 2).	self addMorph: m.!initialize	super initialize.	color _ Color red.	self addLabel.!wantsDroppedMorph: aMorph event: evt	^ true! !!TReturnNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.!copyTree	^self class new		setExpression: expression copyTree!emitCCodeOn: aStream level: level generator: aCodeGen	aStream nextPutAll: 'return '.	expression emitCCodeOn: aStream level: level generator: aCodeGen.!expression	^expression!inlineMethodsUsing: aDictionary	expression _ expression inlineMethodsUsing: aDictionary.!isReturn	^true!nodesDo: aBlock	expression nodesDo: aBlock.	aBlock value: self.!printOn: aStream level: level	aStream nextPut: $^.	expression printOn: aStream level: level.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		self]!setExpression: aNode	expression _ aNode.! !!TSendNode methodsFor: 'all'!args	^arguments!bindVariablesIn: aDictionary	receiver _ receiver bindVariablesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariablesIn: aDictionary ].!copyTree	^self class new		setSelector: selector		receiver: receiver copyTree		arguments: (arguments collect: [ :arg | arg copyTree ])		isBuiltInOp: isBuiltinOperator!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.!inlineMethodsUsing: aDictionary	arguments _ arguments collect: [ :arg |		arg inlineMethodsUsing: aDictionary.	].	"xxx inline this message if it is in the dictionary xxx"!isBuiltinOperator	^ isBuiltinOperator!isBuiltinOperator: builtinFlag	isBuiltinOperator _ builtinFlag.!isSend	^true!nodesDo: aBlock	receiver nodesDo: aBlock.	arguments do: [ :arg | arg nodesDo: aBlock ].	aBlock value: self.!printOn: aStream level: level	| keywords |	receiver printOn: aStream level: level.	arguments size = 0 ifTrue: [		aStream space; nextPutAll: selector.		^self	].	keywords _ selector keywords.	1 to: keywords size do: [ :i |		aStream space.		aStream nextPutAll: (keywords at: i); space.		(arguments at: i) printOn: aStream level: level + 1.	].!receiver	^receiver!receiver: aNode	receiver _ aNode.!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		receiver _ receiver replaceNodesIn: aDictionary.		arguments _ arguments collect: [ :a | a replaceNodesIn: aDictionary ].		self]!selector	^selector!setSelector: aSymbol receiver: rcvrNode arguments: argList	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ false.!setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ builtinFlag.! !!TStmtListNode methodsFor: 'all'!args	^arguments!bindVariablesIn: aDictionary	statements _ statements collect: [ :s | s bindVariablesIn: aDictionary ].!copyTree	^self class new		setArguments: arguments copy		statements: (statements collect: [ :s | s copyTree ])!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [ :s |		level timesRepeat: [ aStream tab ].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or: [s isComment]) ifFalse: [ aStream nextPut: $; ].		aStream cr.	].!endsWithCloseBracket: aStream	"Answer true if the given stream ends in with $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next.		aStream position: pos.	].	^ ch = $}" *** There's something wrong with File positioning.  If you execute the following code, it will print '(hello));;' , but it will give an error if you remove the line the says	f position: f position. | f c p1 p2 p3 | f _ FileStream fileNamed: 'test'.f nextPutAll: '(hello))'.f position: (p1 _ f position)-1.p2 _ f position.c _ f next.p3 _ f position.f position: f position.f nextPut: $;; nextPut: $;.f close.(FileStream fileNamed: 'test') contentsOfEntireFile"!inlineMethodsUsing: aDictionary	statements do: [ :s | s inlineMethodsUsing: aDictionary ].!isStmtList	^true!nodesDo: aBlock	statements do: [ :s | s nodesDo: aBlock ].		aBlock value: self.!printOn: aStream level: level	aStream nextPut: $[.	arguments size > 0 ifTrue: [		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].		aStream nextPutAll: ' | '.	].	self printStatementsOn: aStream level: level.	aStream nextPut: $].!printStatementsOn: aStream level: level	statements size > 1 ifTrue: [ aStream crtab: level + 1 ].	1 to: statements size do: [ :i |		(statements at: i) printOn: aStream level: level.		i = statements size ifTrue: [			(statements size > 1) ifTrue: [				aStream crtab: level.			].		] ifFalse: [			aStream nextPut: $.; crtab: level + 1.		].	].!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		statements _ statements collect: [ :s | s replaceNodesIn: aDictionary ].		self]!setArguments: argList	arguments _ argList.!setArguments: argList statements: statementList	"Initialize this method using the given information."	arguments _ argList.	statements _ statementList.!setStatements: stmtList	statements _ stmtList asOrderedCollection.!statements	^statements! !!TVariableNode methodsFor: 'all'!bindVariablesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^newNode copyTree!copyTree	^self class new setName: name!emitCCodeOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen cLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: name ].!isLeaf	^true!isVariable	^true!name	^name!printOn: aStream level: level	aStream nextPutAll: name.!setName: aString	name _ aString.! !!TwoToneForm methodsFor: 'as yet unclassified'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	aDisplayMedium copyBits: self boundingBox		from: self		at: aDisplayPoint + self offset		clippingBox: clipRectangle		rule: (ruleInteger = Form over ifTrue: [self paintRule] ifFalse: [ruleInteger])		fillColor: aForm!displayOnPort: port at: location	port colorMap: (self colorMapForDepth: port destForm depth);		copyForm: self to: location rule: self paintRule;		colorMap: nil!paintRule	backgroundColor = Color none		ifTrue: [^ Form paint]		ifFalse: [^ Form over]! !!UndefinedObject methodsFor: 'testing'!ifNil: aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value!ifNotNil: aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!UndefinedObject methodsFor: 'dependents access'!addDependent: ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !!UndefinedObject methodsFor: 'class hierarchy'!subclass: nameOfClass  "Define root (superclass = nil) of a class hierarchy"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	| newClass |	newClass _ Object subclass: nameOfClass  "First, define as a normal class"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category.	Object removeSubclass: newClass.   "Then remove it from the old hierarchy"	newClass superclass: nil.	^ newClass! !!UnixFileDirectory methodsFor: 'file creation'!fileClass	^ StandardFileStream! !!UnixFileDirectory class methodsFor: 'initialization'!lookupEntryIn: pathName index: index	"Workaround for discrepency between behavior of the Unix enumeration primitive and the spec with respect to empty path names. [Sorry, I didn't comment the primitive precisely enough. -- John Maloney]"	pathName isEmpty		ifTrue: [^ super lookupEntryIn: '/' index: index]		ifFalse: [^ super lookupEntryIn: pathName index: index]!pathNameDelimiter	^ $/! !UnsavableWorkspace comment:'A workspace whose window will happily close without warning when the user so requests.  Used for throwaway windows, for example, to hold help messages..  1/27/96 sw'!!Utilities class methodsFor: 'investigations'!inspectGlobals	"Utilities  inspectGlobals"	| associations aDict |	associations _ ((Smalltalk keys select: [:aKey | ((Smalltalk at: aKey) isKindOf: Class) not]) asSortedArray collect:		[:aKey | Smalltalk associationAt: aKey]).	aDict _ IdentityDictionary new.	associations do: [:as | aDict add: as].	aDict inspectWithLabel: 'The Globals'! !!Utilities class methodsFor: 'support windows'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'W	Selectors containing itV	Paste author's initials<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete character (not currently undo-able)[	Enclose within [ and ], or remove enclosing [ and ](	Enclose within ( and ), or remove enclosing ( and )   NB: use ctrl ({	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	8 point font  (not in base image)6	add color / make active	(nb: to remove the active quality of text, you must select	more than the active part and then use command-0)7	bold8	italic9	narrow0	plain text (resets all emphasis)-	underlined=	struck out"	"Answer a string to be presented in a window at user request as a crib sheet for command-key mappings.  2/7/96 sw5/1/96 sw: modified so that the long string lives in a comment, hence doesn't take up memory.  Also, fixed up some of the actual text, and added help for parentheses-enclosing items and text-style controls.5/10/96 sw: added a bunch of changes at JM's suggestion8/11/96 sw: fixed the font sizes, added align & references to it, and help for cmd-shift-B11/2/96 di: added ctrl-return and shift-delete, and new assignments of cmd 0-911/7/96 di: new assignments of cmd 0-9, with - and = "! !!Utilities class methodsFor: 'user interface'!informUser: aString during: aBlock	"Put a message above (or below if insufficient room) the cursor.	 Like informUser:while:, but end when aBlock ends.  9/1/96 di"	(SelectionMenu labels: '') displayAt: Sensor cursorPoint		withCaption: aString during: [aBlock value]!informUser: aString while: aBlock	"Put a message above (or below if insufficient room) the cursor.	 1/22/96 sw"	"Utilities informUser: 'How do you do' while: [Sensor anyButtonPressed not]"	| cp  |	cp _ Sensor cursorPoint.	(SelectionMenu labels: '') displayAt: cp				withCaption: aString				during: [[aBlock value] whileTrue]! !!Utilities class methodsFor: 'common requests'!commonRequestStrings: aString	"Initialize the common request strings from aString.  12/12/96 sw"	CommonRequestStrings _ StringHolder new contents: aString! !!Utilities class methodsFor: 'recent method submissions'!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw.	5/29/96 sw: fixed so the browser doesn't go all wonkie after you submit more code	1/17/97 sw: reverse the order, have most recent submissions at the top of the list		1/17/97 sw: use RecentMessageList"	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size == 0 ifTrue:		[^ SelectionMenu notify: 'There are no recent submissions'].		recentMessages _ RecentSubmissions copy reversed.	RecentMessageSet openMessageList: recentMessages name: 'Recently submitted methods -- youngest first ' autoSelect: nil!recentlySubmittedMessages	^ RecentSubmissions copy reversed! !!VariableNode methodsFor: 'initialize-release'!name: varName index: i type: type	"Only used for initting instVar refs"	name _ varName.	self key: varName		index: i		type: type!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name _ string.	key _ object.	code _ byte!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	name _ varName.	self key: objRef		index: i		type: type! !!VariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name)		ifTrue: [^ location]		ifFalse: [^ -1]!isTemp	^ false! !!VariableNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!VariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream nextPutAll: name! !!VariableNode methodsFor: 'C translation'!asTranslatorNode	^TVariableNode new setName: name! !!VariableNode class methodsFor: 'class initialization'!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder _ Encoder new.	StdVariables _ Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors _ Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals _ LiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil _ encoder encodeVariable: 'nil'.	NodeTrue _ encoder encodeVariable: 'true'.	NodeFalse _ encoder encodeVariable: 'false'.	NodeSelf _ encoder encodeVariable: 'self'.	NodeThisContext _ encoder encodeVariable: 'thisContext'.	NodeSuper _ encoder encodeVariable: 'super'! !!View methodsFor: 'testing'!bordersOn: otherView along: herSide 	| myBox herBox |	myBox _ self displayBox.	herBox _ otherView displayBox.	(herSide = #right and: [myBox left = herBox right])	| (herSide = #left and: [myBox right = herBox left])		ifTrue:		[^ (myBox top max: herBox top) <= (myBox bottom min: herBox bottom)].	(herSide = #bottom and: [myBox top = herBox bottom])	| (herSide = #top and: [myBox bottom = herBox top])		ifTrue:		[^ (myBox left max: herBox left) <= (myBox right min: herBox right)].	^ false!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'bordering'!backgroundColor	insideColor == nil ifFalse:		[(insideColor isMemberOf: Symbol) ifTrue:			[^ Color perform: insideColor].		^ insideColor].	superView == nil ifFalse: [^ superView backgroundColor].	^ Color white!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor ~= Color none]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor _ Color white]].	insideColor _ aColor! !!View methodsFor: 'miscellaneous'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click |	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click _ false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[Processor yield.		click _ click | Sensor anyButtonPressed.		newFrame _ newFrameBlock value: frame.		newFrame extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame _ newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !!WarpBlt methodsFor: 'setup'!cellSize	^ cellSize!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	cellSize > 3 ifTrue:		[(self confirm:'Do you really want to averagemore than 3x3 pixels?') ifFalse: [self halt]].	(destForm depth < 16 and: [colorMap == nil])		ifTrue: [self setDestMap: 3]!rgbValues	"RGB forms (depth 16 and 32) don't need a source map"	sourceForm depth >= 16 ifTrue: [^ nil].	"All other forms, for now, are assumed to use our	standard color map, so all warps will share it."	SourceMapCache == nil ifTrue:		[SourceMapCache _ "Compute once and save around"			(Color indexedColors collect: [:c | c pixelValueForDepth: 32])					as: Bitmap].	^ SourceMapCache	"Special applications such as external GIF images might want to	supply their own RGB map by directly calling, eg,		self warpBitsSmoothing: cellSize sourceMap: specialRGBmap"!setDestMap: bitsPerColor	"Establish a destination color map to convert from pixel-averaged	RGB values to (presumably non-RGB) destination pixel values"	| mask |	DestMapCache size = (1 bitShift: bitsPerColor*3) ifTrue:		["Just use the last one if same bits per color"		colorMap _ DestMapCache.		^ self].	mask _ (1 bitShift: bitsPerColor) - 1.	colorMap _ Bitmap new: (1 bitShift: bitsPerColor*3).	0 to: colorMap size - 1 do:		[:i | colorMap at: i+1 put:			((Color red: ((i bitShift: 0 - (bitsPerColor*2)) bitAnd: mask)				green: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)				blue: ((i bitShift: 0) bitAnd: mask)				range: mask)			pixelValueForDepth: destForm depth)].	"Cache for possible reuse"	DestMapCache _ colorMap! !!WarpBlt methodsFor: 'smoothing'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix _ pix size.	r _ 0. g _ 0. b _ 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb _ sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [BitBltSimulation new								rgbMap: (pix at: i) from: 5 to: 8]].		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor _ 5].				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].				destMap size = 4096 ifTrue: [bitsPerColor _ 4].				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].	d _ bitsPerColor - 8.	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!WarpBlt methodsFor: 'primitives'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n >= 1"	| fixedPtOne |	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	x2 > x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]!startFrom: x1 to: x2 offset: sumOfDeltas	"Utility routine for computing Warp increments."	x2 >= x1		ifTrue: [^ x1]		ifFalse: [^ x2 - sumOfDeltas]!warpBits	^ self warpBitsSmoothing: cellSize sourceMap: self rgbValues!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 147>	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !!WarpBlt class methodsFor: 'initialization'!toForm: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toForm: destinationForm) cellSize: 1! !!WarpBlt class methodsFor: 'examples'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display) cellSize: 2;		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).		]!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!WarpBlt class methodsFor: 'form rotation'!rotate: aForm degrees: angleInDegrees center: aPoint smoothing: cellSize	"Rotate the given Form the given number of degrees around the given point relative to the top-left corner of the form. Smooth using the given cell size, an integer between 1 and 3 where 1 means no smoothing. Return a pair where the first element is the rotated form and the second is the position offset required to align the center of the rotated form with that of the original. Note that the dimensions of the resulting form generally differ from those of the original."	| oldCenter newCenter pair |	oldCenter _ aForm boundingBox center.	newCenter _ (oldCenter		rotateBy: angleInDegrees degreesToRadians		about: aPoint) truncated.	pair _ self rotate: aForm		degrees: angleInDegrees		smoothing: cellSize.	pair at: 2 put: (pair at: 2) + (newCenter - oldCenter).	^ pair!rotate: srcForm degrees: angleInDegrees smoothing: cellSize	"Rotate the given Form the given number of degrees around its own center. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated form and the second is the position offset required to align the center of the rotated form with that of the original. Note that the dimensions of the resulting form generally differ from those of the original."	| srcRect center dstOrigin radians dstCorner p dstRect quad dstForm |	srcRect _ srcForm boundingBox.	center _ srcRect center.	dstOrigin _ dstCorner _ center.	radians _ angleInDegrees degreesToRadians.	srcRect innerCorners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ (corner rotateBy: radians about: center) truncated.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	quad _ dstRect innerCorners collect: [:corner |		corner rotateBy: radians negated about: center].	"make a form to hold the result and do the rotation"	dstForm _ self rotate: srcForm		destinationExtent: dstRect extent		quad: quad		cellSize: cellSize.	^ Array with: dstForm with: dstRect origin! !!WarpBlt class methodsFor: 'private'!rotate: srcForm destinationExtent: dstExtent quad: quad cellSize: cellSize	"Private!! Rotate the given Form or MaskedForm using the given parameters."	| dstForm dstMask |	(srcForm isKindOf: MaskedForm) ifTrue: [		dstForm _ Form extent: dstExtent depth: srcForm depth.		(WarpBlt toForm: dstForm)			sourceForm: srcForm form;			combinationRule: Form over;			cellSize: cellSize;			copyQuad: quad toRect: dstForm boundingBox.		dstMask _ Form extent: dstExtent depth: 1.		(WarpBlt toForm: dstMask)			sourceForm: srcForm mask;			combinationRule: Form over;			cellSize: cellSize;			copyQuad: quad toRect: dstMask boundingBox.		^ MaskedForm form: dstForm mask: dstMask removeOverlap: false].	"ordinary Forms"	dstForm _ Form extent: dstExtent depth: srcForm depth.	(WarpBlt toForm: dstForm)		sourceForm: srcForm;		combinationRule: Form over;		cellSize: cellSize;		copyQuad: quad toRect: dstForm boundingBox.	^ dstForm.! !!WaveTableSound methodsFor: 'sound generation'!doControl	decayRate ~= 1.0 ifTrue: [		amplitude _ (decayRate * amplitude asFloat) truncated.	].!mixSampleCount: n into: aSoundBuffer startingAt: startIndex pan: pan	"Play samples from a wave table by stepping a fixed amount throught the table on every sample. The decay parameter may be used to make the sound fade away, but its default value of 1.0 produces a sustained sound, like a flute. The abrupt start and stops of this sound result in transient clicks; it would benefit greatly from a simple attack-sustain-decay envelope."	"(WaveTableSound pitch: 440.0 dur: 1.0 loudness: 200) play"	| lastIndex mySample channelIndex sample |	<primitive: 176>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #waveTable declareC: 'short int *waveTable'.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [ :i |		mySample _ (amplitude * (waveTable at: index)) // 1000.		pan > 0 ifTrue: [			channelIndex _ 2 * i.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * pan) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		pan < 1000 ifTrue: [			channelIndex _ (2 * i) - 1.			sample _ (aSoundBuffer at: channelIndex) + ((mySample * (1000 - pan)) // 1000).			sample >  32767 ifTrue: [ sample _  32767 ].  "clipping!!"			sample < -32767 ifTrue: [ sample _ -32767 ].  "clipping!!"			aSoundBuffer at: channelIndex put: sample.		].		index _ index + increment.		index > waveTableSize ifTrue: [			index _ index - waveTableSize.		].	].	count _ count - n.! !!WorldMorph methodsFor: 'initialization'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	invalidAreas _ OrderedCollection new.	totalRepaint _ false.	stepList _ OrderedCollection new.	lastStepTime _ 0.	model _ nil.	self startStepping.!open	"Open a view on this WorldMorph."	MorphWorldView openOn: self.!saveAsWorld	| worldName s |	worldName _ FillInTheBlank		request: 'Please give this world a name'		initialAnswer: 'test'.	((self class class includesSelector: worldName asSymbol) and:		[(PopUpMenu confirm: 'OK to overwrite ' , worldName , '?') not])		ifTrue: [^ self].	s _ WriteStream on: (String new: 1000).	s	nextPutAll: worldName; cr; tab;		nextPutAll: '"' , self class name , ' ' , worldName, ' open"'; cr; cr; tab;		nextPutAll: '^ '.	self printConstructorOn: s indent: 0.	s cr.	self class class		compile: s contents		classified: 'examples'		notifying: nil.! !!WorldMorph methodsFor: 'classification'!isWorldMorph	^ true! !!WorldMorph methodsFor: 'accessing'!canvas	^ canvas!canvas: aCanvas	"Start displaying on the given canvas."	canvas _ aCanvas.	totalRepaint _ true.!color: aColor	"Set the background color of this world."	super color: aColor.	totalRepaint _ true.	"Propagate to view"	self changed: #newColor!viewBox		^ viewBox!viewBox: aRectangle	(viewBox == nil or:	 [viewBox extent ~= aRectangle extent])		ifTrue: [self canvas: nil].	viewBox _ aRectangle.	bounds _ 0@0 extent: viewBox extent.	totalRepaint _ true.! !!WorldMorph methodsFor: 'structure'!addAllMorphs: array	super addAllMorphs: array.	array do: [:m | self startSteppingSubmorphsOf: m]!world	^ self! !!WorldMorph methodsFor: 'submorphs-accessing'!allMorphsDo: aBlock	super allMorphsDo: aBlock.	hands reverseDo: [:h | h allMorphsDo: aBlock].!rootMorphsAt: aPoint	| mList |	mList _ OrderedCollection new.	submorphs do: [:m |		(m fullContainsPoint: aPoint) ifTrue: [mList addLast: m]].	^ mList! !!WorldMorph methodsFor: 'drawing'!blackenDamageOn: aCanvas	"For testing. Flashes the damaged rectangles momentarily so you can see it work."	| c |	invalidAreas do: [:r |		c _ aCanvas copyClipRect: r.		c fillColor: Color black].	^ invalidAreas!displayWorld	"Display the morph world."	| updateRects |	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	submorphs do: [:m | m fullBounds].  "forces re-layout if needed"	totalRepaint ifTrue: [		"force the entire canvas to be redrawn"		invalidAreas _ Array with: (0@0 extent: canvas extent)].	invalidAreas isEmpty ifTrue: [^ self].  "nothing to do""Uncomment the following to flash damaged areas during testing: 	self blackenDamageOn: canvas.	canvas showAt: viewBox origin."	"redraw on offscreen canvas"	updateRects _ self drawInvalidAreasOn: canvas.	"copy redrawn areas to Display"	canvas showAt: viewBox origin invalidRects: updateRects.!displayWorldAsTwoTone	"Display the world as a two-tone form."	self canvas: (FormCanvas new setForm:						((TwoToneForm extent: viewBox extent depth: 1)								foregroundColor: Display black								backgroundColor: color)).	"force the entire canvas to be redrawn"	invalidAreas _ Array with: (0@0 extent: canvas extent).	self drawInvalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: viewBox origin.  "copy redrawn areas to Display"	self canvas: nil!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: canvas].	hands reverseDo: [:h | h fullDrawOn: canvas].	canvas form displayOn: Display at: viewBox origin.	invalidAreas _ OrderedCollection new.	totalRepaint _ true.!drawInvalidAreasOn: aCanvas	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| c validAreas |	invalidAreas do: [:r |		c _ aCanvas copyClipRect: r.		c fillColor: color.		submorphs reverseDo: [:m |			(m fullBounds intersects: r) ifTrue: [m fullDrawOn: c]].		hands reverseDo: [:h | h fullDrawOn: c]].	validAreas _ invalidAreas.	invalidAreas _ OrderedCollection new.	totalRepaint _ false.	^ validAreas! !!WorldMorph methodsFor: 'events'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.! !!WorldMorph methodsFor: 'stepping'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	stepList do:		[:entry | entry at: 2 put: (now + ((entry at: 2) - earliestTime))].!runStepMethods	"Run morph 'step' methods whose time has come."	| now wakeupTime m |	stepList size = 0 ifTrue: [^ self].	self stopSteppingDeletedMorphs.	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 500])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	stepList do: [:entry |		wakeupTime _ entry at: 2.		wakeupTime <= now ifTrue: [			m _ entry first.			m step.			entry at: 2 put: now + m stepTime]].	lastStepTime _ now.!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	stepList add:		(Array			with: aMorph			with: Time millisecondClockValue).!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list. Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [self startStepping: m]].!step	"Step this world's model, if any."	model ifNotNil: [model stepWorld: self].!stepTime	"Step this world's model, if any."	model == nil		ifTrue: [^ 10000]		ifFalse: [^ model stepTime].!stopStepping: aMorph	"Remove the given morph from the step list."	stepList copy do: [:entry |		entry first == aMorph ifTrue: [stepList remove: entry ifAbsent: []]].!stopSteppingDeletedMorphs	"Remove morphs that have been deleted from the step list."	| deleteCount |	deleteCount _ 0.	stepList do: [:entry | entry first isInWorld ifFalse: [deleteCount _ deleteCount + 1]].	deleteCount > 0 ifTrue: [		stepList copy do: [:entry |			entry first isInWorld ifFalse: [stepList remove: entry ifAbsent: []]]].! !!WorldMorph methodsFor: 'hands'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	hands _ hands copyWith: aHandMorph.	aHandMorph privateOwner: self.!addRemoteHandInitials: aString	"Add a remote hand with the given initials. This hand will listen for a connection until either a connection is made or its timeout expires. If no connection is made by the end of the timeout, the hand automatically deletes itself."	| h |	h _ RemoteHandMorph new userInitials: aString.	self addHand: h.	h startListening.!hands	^ hands copy!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		aHandMorph stopListening.		hands _ hands copyWithout: aHandMorph].! !!WorldMorph methodsFor: 'change reporting'!fullRepaintNeeded	totalRepaint _ true.!invalidRect: damageRect	"Record the given rectangle in the damage list, a list of rectagular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidAreas do: [:rect |		(rect intersects: damageRect) ifTrue: [			"merge rectangle in place (see note below) if there is any overlap"			rect origin: (rect origin min: damageRect origin)				corner: (rect corner max: damageRect corner).			^ self]].	invalidAreas size >= 10 ifTrue: [		"if there are too many separate areas, just repaint all"		totalRepaint _ true.		^ self].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,	 since rectangles in this list may be extended in place."	invalidAreas addLast: (damageRect topLeft corner: damageRect bottomRight).!layoutChanged	fullBounds _ nil.! !!WorldMorph methodsFor: 'interaction loop'!doOneCycle	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	self runStepMethods.	self processEvents.	self displayWorld.!processEvents	"Process user input events."	hands do: [:h | h processEvents].! !!WorldMorph methodsFor: 'model access'!initModel	"Create a model object for this world if it does not yet have one. A model object is an initially empty subclass of MorphicApp. As the user names parts and adds behavior, instance variables and methods are added to this class."	model == nil ifFalse: [^ self].  "already has a model"	model _ MorphicModel newSubclass new!model	"Return the model object for this world.	If the world has no model, then create one."	self initModel.	^ model!saveAsModel	^ self model saveWithSubmorphs: submorphs! !!WorldMorph methodsFor: 'dropping'!acceptDroppingMorph: aMorph event: evt	"Add the given morph to this world and make sure it is getting stepped if it wants to be."	self addMorphFront: aMorph.	self startSteppingSubmorphsOf: aMorph.! !!WorldMorph class methodsFor: 'examples'!test	"WorldMorph test open"	^ ((WorldMorph newBounds: (0@0 corner: 50@40) color: (Color r:0.199 g: 1.0 b: 0.8))	addAllMorphs: ((Array new: 7)	at: 1 put: 	((StringMorph newBounds: (318@76 corner: 390@91) color: Color blue) contents: 'StringMorph');	at: 2 put: 	((EllipseMorph newBounds: (91@73 corner: 141@113) color: (Color r:0.199 g: 0.199 b: 1.0)) setBorderWidth: 1 borderColor: Color black);	at: 3 put: 	(((EllipseMorph newBounds: (375@33 corner: 487@137) color: Color yellow) setBorderWidth: 1 borderColor: Color black)		addAllMorphs: ((Array new: 2)		at: 1 put: 		((EllipseMorph newBounds: (365@21 corner: 415@61) color: Color yellow) setBorderWidth: 1 borderColor: Color black);		at: 2 put: 		((EllipseMorph newBounds: (448@23 corner: 498@63) color: Color yellow) setBorderWidth: 1 borderColor: Color black);		yourself));	at: 4 put: 	((FrameRateMorph newBounds: (364@202 corner: 508@217) color: Color black) contents: '22 mSecs (45 frames/sec)');	at: 5 put: 	((ClockMorph newBounds: (301@148 corner: 359@163) color: (Color r:0 g: 0.599 b: 0)) contents: '1:34:02 am');	at: 6 put: 	((FlasherMorph newBounds: (61@151 corner: 297@251) color: Color red) setBorderWidth: 3 borderColor: Color black);	at: 7 put: 	((RectangleMorph newBounds: (81@68 corner: 252@122) color: (Color r:0.656 g: 0.656 b: 0.656)) setBorderWidth: 3 borderColor: (Color r:0.8 g: 0.4 b: 0.199));	yourself))! !!WriteStream methodsFor: 'private'!withAttribute: att do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !Smalltalk condenseChanges!----QUIT----(13 April 1997 11:41:53 pm ) priorSource: 1469951!----QUIT----(13 April 1997 11:46:52 pm ) priorSource: 1469979!----SAVEAS test----(20 May 1997 8:35:21 am )!Float pi!Float pi!Float pi! | r t | t _ Time millisecondsToRun: [r _ 30 benchFib].			r//t*1000 !89000/40000.0*100!