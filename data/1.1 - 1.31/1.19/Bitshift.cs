'From Squeak 1.19d of April 13, 1997 on 28 April 1997 at 4:40:27 pm'!!BitBltSimulation methodsFor: 'inner loop'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord destMask srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap |	self inline: false.	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	"Check for degenerate shift values 4/28/97 ar"	sourcePixSize = 32 		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 bitShift: sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 bitShift: destPixSize) - 1].	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'pixel mapping'!warpSourcePixels: nPix xDeltah: xDeltah yDeltah: yDeltah	xDeltav: xDeltav yDeltav: yDeltav	smoothing: n sourceMap: sourceMapOop	"Pick nPix pixels using these x- and y-incs, and map color if necess."	| destWord sourcePix sourcePixMask destPixMask srcPixPerWord destPix |	"Fix degenerate shift values 4/28/97 ar"	sourcePixSize = 32		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	srcPixPerWord _ 32 // sourcePixSize.	destWord _ 0.	1 to: nPix do:		[:i |		n > 1		ifTrue:			["Average n pixels and compute dest pixel from color map"			destPix _ (self smoothPix: n atXf: sx yf: sy				dxh: xDeltah//n dyh: yDeltah//n dxv: xDeltav//n dyv: yDeltav//n				pixPerWord: srcPixPerWord pixelMask: sourcePixMask				sourceMap: sourceMapOop)					bitAnd: destPixMask]		ifFalse:			["No smoothing -- just pick pixel and map if difft depths or color map supplied"			sourcePix _ (self sourcePixAtX: sx >> BinaryPoint									y: sy >> BinaryPoint									pixPerWord: srcPixPerWord)						bitAnd: sourcePixMask.			colorMap = interpreterProxy nilObject				ifTrue:				[destPixSize = sourcePixSize				ifTrue:					[destPix _ sourcePix]				ifFalse:					[sourcePixSize >= 16 ifTrue:						["Map between RGB pixels"						sourcePixSize = 16							ifTrue: [destPix _ self rgbMap: sourcePix from: 5 to: 8]							ifFalse: [destPix _ self rgbMap: sourcePix from: 8 to: 5]]					ifFalse: [destPix _ sourcePix bitAnd: destPixMask]]]			ifFalse:				[sourcePixSize >= 16 ifTrue:					["RGB pixels first get reduced to cmBitsPerColor"					sourcePixSize = 16						ifTrue: [sourcePix _ self rgbMap: sourcePix from: 5 to: cmBitsPerColor]						ifFalse: [sourcePix _ self rgbMap: sourcePix from: 8 to: cmBitsPerColor]].				"Then look up sourcePix in colorMap"				destPix _ (interpreterProxy fetchWord: sourcePix ofObject: colorMap) bitAnd: destPixMask]].		destWord _ (destWord << destPixSize) bitOr: destPix.		sx _ sx + xDeltah.		sy _ sy + yDeltah.		].	^ destWord! !