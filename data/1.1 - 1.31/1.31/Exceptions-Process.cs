'From Squeak 1.31 of Feb 4, 1998 on 8 April 1998 at 11:12:23 pm'!"Change Set:		Exceptions-ProcessDate:			8 April 1998Author:			Andreas Raab (ar) raab@isg.cs.uni-magdeburg.deThis change set contains a number of modifications to handle the termination of processes correctly. Also, ControlManager>>interruptName: has been replaced by ControlManager>>interruptNameTest: using UserInterrupt to interrupt any running processes (since UserInterrupt can be handled it's easy to have processes not interrupted or to change the interrupt behavior such as in the debugger)"!Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler interruptProtect '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!BlockContext methodsFor: 'scheduling' stamp: 'ar 4/7/98 15:00'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	^Process		forContext:[			[self value.			"Note: terminateActive will just raise ProcessTermination"			Processor terminateActive]				on: ProcessTermination				do:[:ex| ex return].			"And the following will do the actual termination work"			Processor activeProcess terminated]		priority: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 4/7/98 15:00'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	^Process		forContext:[			[self valueWithArguments: anArray.			"Note: terminateActive will just raise ProcessTermination"			Processor terminateActive]				on: ProcessTermination				do:[:ex| ex return].			"And the following will do the actual termination work"			Processor activeProcess terminated]		priority: Processor activePriority! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 4/6/98 19:53'!interruptNameTest: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	UserInterrupt		signal: labelString		with: #userInterrupt		from: nil		process: activeControllerProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 4/5/98 20:41'!maybeForkInterrupt	self cmdDotEnabled ifTrue:		[[self interruptNameTest: 'User Interrupt'] fork]! !!Process methodsFor: 'changing process state' stamp: 'ar 4/6/98 00:55'!interruptWith: aBlock	"Make the receiver executing aBlock regardless of what he's doing at the moment."	| oldList oldContext interruptContext |	Processor activeProcess == self ifTrue:[aBlock value. ^self].	"Note: The remaining stuff is run from within a different process so each reference to 'self' does *not* mean the currently active process"	self interruptProtect critical:[		oldList := myList.		myList ifNotNil:[			"Strange ... how can a process be off its list if myList is not nil?!!"			myList remove: self ifAbsent:[].			self offList].		oldContext := suspendedContext.		interruptContext := [	aBlock value.							self restoreInterruptedProcess: oldContext list: oldList].		"Create a valid sender chain"		interruptContext swapSender: oldContext.		suspendedContext := interruptContext].	self resume.! !!Process methodsFor: 'changing process state' stamp: 'ar 4/7/98 23:50'!killMinus9	"Terminate the receiver without evaluating any termination blocks. This facility is provided in case a process is unable to complete unwind operations. Non-Unix users: the name originates from the unix command 'kill -9' terminating a process the hard way."	"First un-install the buggy exception handlers"	self exceptionHandlers: nil.	"Now give some information to the user"	Notification signal:'*********** Process termination problem *************A process could not be terminated the usual way. It will be killed now but problems may arise from this.'.	"And remove the receiver from the list of processes"	^self terminated! !!Process methodsFor: 'changing process state' stamp: 'ar 4/8/98 00:21'!terminate 	"Stop the process that the receiver represents forever by signaling ProcessTermination such that the appropriate termination blocks can be evaluated"	Processor activeProcess == self ifFalse:[		"Interrupt the process for termination"		^self interruptWith:[self terminate]].	"Make sure that nothing really bad happens upon termination"	[ProcessTermination signal] on: UnhandledException, DebugStop do:[:ex|		"We may have some old processes which are not handled. 		Try to terminate them gracefully"		((UnhandledException handles: ex) 			and:[ProcessTermination handles: ex tag]) 				ifTrue:[ex return].		"If we get a DebugStop for ExceptionCannotReturn 		then something is *really* wrong"		((DebugStop handles: ex)			and:[BlockContext cannotReturnError handles: ex tag])				ifTrue:[self killMinus9].		ex pass].	"Coming here means ProcessTermination was not handled"	self exceptionHandlers terminateAll.	^self terminated! !!Process methodsFor: 'changing process state' stamp: 'ar 4/5/98 20:08'!terminated	"Stop the process that the receiver represents forever."	| context |	Processor activeProcess == self		ifTrue: 			[thisContext sender == nil ifFalse:				[thisContext sender release].			thisContext removeSelf suspend]		ifFalse: 			[myList == nil				ifFalse: 					[myList remove: self ifAbsent: [].					myList _ nil].			context _ suspendedContext.			suspendedContext _ nil.			(context ~~ nil and: [context sender ~~ nil])				ifTrue: [context sender release]]! !!Process methodsFor: 'accessing' stamp: 'ar 4/5/98 19:52'!interruptProtect	^interruptProtect ifNil:[interruptProtect := Semaphore forMutualExclusion]! !!Process methodsFor: 'private' stamp: 'ar 4/7/98 21:38'!restoreInterruptedProcess: oldContext list: oldList	"The receiver has been interrupted and is about to proceed the normal way. Note that we cannot restore the state of the process by returning from the interrupt context because the interrupted context does not expect any return value.	Therefore we create a new process which restores the state of the receiver (this can be done because the new process is different from the receiver and as long as this new process is run the receiver will be suspended). After the original context has been restored we can resume the receiver again." 	[suspendedContext := oldContext.	oldList ifNotNil:[self resume]] forkAt: priority.	self suspend.! !"Recreate the special objects array -- Process is stored in there"Smalltalk recreateSpecialObjectsArray.!