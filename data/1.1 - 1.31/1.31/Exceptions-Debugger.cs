'From Squeak 1.31 of Feb 4, 1998 on 8 April 1998 at 11:11:35 pm'!"Change Set:		Exceptions-DebuggerDate:			8 April 1998Author:			Andreas Raab (ar) raab@isg.cs.uni-magdeburg.deThis change set contains two major modifications for the debugger:* adequate simulation of the exceptions itself* support for easy stepping over/into exception handlersBy using an exception system we do also get rid of the checks for #halt, or #error, or #doesNotUnderstand during simulation. You can now do things like:	ContextPart runSimulated:[ 100 / 0]and similar stuff. Also, the UserInterrupt is handled to allow stopping the simulation if the completion of a method takes to long (however, this requires the Exceptions-Process change set to be installed."!!ContextPart methodsFor: 'instruction decoding' stamp: 'ar 4/5/98 16:21'!send: selector super: superFlag numArgs: numArgs	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments _ Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver _ self pop.	receiver isException ifTrue:[		^self sendToException: receiver				selector: selector				arguments: arguments				superFlag: superFlag].	receiver isExceptionHandler ifTrue:[		^self sendToHandler: receiver				selector: selector				arguments: arguments				superFlag: superFlag].	"Check for exception messages"	(selector == #on:do: or:[		selector == #ifCurtailed: or:[			selector == #ensure: and:[				receiver class == BlockContext]]]) ifTrue:[		^self stepToBasicValue: receiver 				selector: selector 				arguments: arguments 				super: superFlag].	selector == #doPrimitive:receiver:args:		ifTrue: [answer _ receiver 					doPrimitive: (arguments at: 1)					receiver: (arguments at: 2)					args: (arguments at: 3).				self push: answer.				^self].	"Check for Processor activeProcess"	(selector == #activeProcess and:[receiver == Processor]) ifTrue:[		self push: self getActiveProcess.		^self].	^self send: selector to: receiver with: arguments super: superFlag! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 4/5/98 13:54'!shortStackForProcess: aProcess	"Answer a String showing the top four contexts on my sender chain."	| shortStackStream |	shortStackStream _ WriteStream on: (String new: 400).	(self stackOfSize: 5 forProcess: aProcess) do: 		[:item | shortStackStream print: item; cr].	^shortStackStream contents! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 4/5/98 13:54'!stackForProcess: aProcess	"Answer an Array of the contexts on the receiver's sender chain."	^self stackOfSize: 9999 forProcess: aProcess! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 4/5/98 14:29'!stackOfSize: limit 	"Answer an OrderedCollection of the top 'limit' contexts		on the receiver's sender chain."	| a stack |	true ifTrue:[^self stackOfSize: limit forProcess: Processor activeProcess].	stack _ OrderedCollection new.	stack addLast: (a _ self).	[(a _ a sender) ~~ nil and: [stack size < limit]]		whileTrue: [stack addLast: a].	^ stack! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 4/7/98 16:11'!stackOfSize: limit forProcess: aProcess	"Answer an OrderedCollection of the top 'limit' contexts		on the receiver's sender chain.	Modified for wrapping of termination handlers breaking the sender chain ar 4/5/98 13:32"	| ctx stack handlers handler skipStart skipStop |	handlers := aProcess exceptionHandlers terminationHandlers.	skipStart := ExceptionHandler compiledMethodAt: #basicValue:.	skipStop := IdentitySet new.	skipStop add: (BlockContext compiledMethodAt: #on:do:).	skipStop add: (BlockContext compiledMethodAt: #ifCurtailed:).	skipStop add: (BlockContext compiledMethodAt: #ensure:).	stack := OrderedCollection new.	ctx := self.	[stack size < limit] whileTrue: [		stack addLast: ctx.		ctx sender isNil ifTrue:[			handler := handlers at: ctx ifAbsent:[^stack].			ctx := handler actualSender.		] ifFalse:[ctx := ctx sender].		(self debugExceptions not and:[ctx method == skipStart]) ifTrue:[			"Skip the stack until we come to skipStop"			[skipStop includes: ctx method] whileFalse:[				ctx sender isNil ifTrue:[					handler := handlers at: ctx ifAbsent:[^stack].					ctx := handler actualSender.				] ifFalse:[ctx := ctx sender].			].		].	].	^ stack! !!ContextPart methodsFor: 'controlling' stamp: 'ar 4/6/98 00:40'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class _ 		superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	[class == nil]		whileFalse: 			[(class includesSelector: selector)				ifTrue: 					[meth _ class compiledMethodAt: selector.					val _ 						self tryPrimitiveFor: meth							receiver: rcvr							args: args.					val == #simulatorFail ifFalse: [^val].					^self						activateMethod: meth						withArgs: args						receiver: rcvr						class: class].			class _ class superclass].	^self send: #doesNotUnderstand:		to: rcvr		with: (Array with: (Message selector: selector arguments: args))		super: superFlag! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:57'!completeCallee: aContext orUntil: finiBlock	"Simulate the execution of bytecodes until a return to the receiver or until finiBlock evaluates to true."	| ctxt current |	ctxt _ aContext.	[finiBlock value not and:[ctxt == current or: [ctxt hasSender: self]]]		whileTrue: 			[current _ ctxt.			ctxt _ ctxt step].	^ctxt stepToSendOrReturn! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:52'!returnFromBasicValue	"Return through any exception handlers. This is indicated by the methods #basicValue: or #basicValue:with: from ExceptionHandler"	(self method == (ExceptionHandler compiledMethodAt: #basicValue:) or:[		self method == (ExceptionHandler compiledMethodAt: #basicValue:with:)])			ifFalse:[^self].	^self returnToSpecialSelector! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:53'!returnToSpecialSelector	"Return to one of the special selectors #on:do: #ifCurtailed: or #ensure."	| specialMethods ctx |	self debugExceptions ifTrue:[^self].	specialMethods := IdentitySet new.	specialMethods add: (BlockContext compiledMethodAt: #on:do:).	specialMethods add: (BlockContext compiledMethodAt: #ifCurtailed:).	specialMethods add: (BlockContext compiledMethodAt: #ensure:).	ctx := self.	[specialMethods includes: ctx method] whileFalse:[		ctx := ctx step.		ctx ifNil:[^ctx]	].	ctx stepToSendOrReturn.	^ctx willReturn 		ifTrue:[ctx step]		ifFalse:[ctx sender completeCallee: ctx orUntil:[false]].! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:45'!sendToException: receiver selector: selector arguments: arguments superFlag: superFlag	"Simulate a send to an exception. There are two things we catch here: 	* A send of #signal to DebugStop. If this occurs we raise the signal immediately *without* simulating it. This way we can stop if running in a debugger or we raise a debugger on the actual point of execution in the simulation.	* Handler response messages. If one of those is sent we simulate further until reaching a point where something 'more interesting' happens."	| ctx |	(selector == #signal and:[receiver class == DebugStop]) 		ifTrue:[receiver signal].	ctx := self send: selector to: receiver with: arguments super: superFlag.	"Handler response check"	(self debugExceptions not and:[		Exception handlerResponses includes: selector]) ifFalse:[^ctx].	"Have a handler response"	^ctx returnToSpecialSelector! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:42'!sendToHandler: receiver selector: selector arguments: arguments superFlag: superFlag	"Simulate a send to an exception handler. We watch for #basicValue: and #basicValue:with: messages here since these mark the execution of any termination blocks."	(selector == #basicValue: or:[		selector == #basicValue:with: ]) ifTrue:[			"Note: The following will step *inside* the termination block"			^self stepToBasicValue: receiver 					selector: selector 					arguments: arguments 					super: superFlag].	^self send: selector to: receiver with: arguments super: superFlag.! !!ContextPart methodsFor: 'system simulation' stamp: 'ar 4/5/98 16:56'!stepToBasicValue: rcvr selector: sel arguments: args super: superFlag	"This method simulates one of the messages #on:do:, #ifCurtailed:, or #ensure: such that during debug we don't have to step through the entire exception handling system."	| ctx specialMethods |	"Transcript cr; show:'Stepping into ', sel."	ctx := self send: sel to: rcvr with: args super: superFlag.	self debugExceptions ifTrue:[^ctx].	specialMethods := IdentitySet new.	specialMethods add: (ExceptionHandler compiledMethodAt: #basicValue:).	specialMethods add: (ExceptionHandler compiledMethodAt: #basicValue:with:).	[specialMethods includes: ctx sender method] whileFalse:[		ctx := ctx step.		ctx ifNil:[^ctx].	].	"Transcript cr; show:'Returning with ', ctx printString."	"Now notify the debugger (if running in one) that we should stop here"	^(SimulatedException new)		tag: #DebugStop;		action: [ctx];		parameter: ctx;		signal! !!ContextPart methodsFor: 'private' stamp: 'ar 4/5/98 14:08'!debugExceptions	"Return true if exceptions should be debugged as usual"	^false! !!ContextPart methodsFor: 'private' stamp: 'ar 3/31/98 19:00'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value t1 t2 t3 |	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 83 or:[primitiveIndex = 84])		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextPart methodsFor: 'private' stamp: 'ar 4/2/98 17:48'!getActiveProcess	"If we run in a debugger then Processor activeProcess is *not* the simulated process"	^(SimulatedException new)		tag: #Processor;		action: [Processor activeProcess];		parameter: #activeProcess;		signal! !!Debugger methodsFor: 'initialize-release' stamp: 'ar 4/5/98 13:55'!expandStack	"This initialization occurs when the interrupted context is to modelled by 	a DebuggerView, rather than a NotifierView (which can not display 	more than five message-sends.	: expand the default number of frames from 7 to 15"	self newStack: (contextStackTop stackOfSize: 15 forProcess: interruptedProcess).	contextStackIndex _ 0.	receiverInspector _ Inspector inspect: nil.	contextVariablesInspector _ ContextVariablesInspector inspect: nil.	proceedValue _ nil! !!Debugger methodsFor: 'initialize-release' stamp: 'ar 4/5/98 22:28'!release	interruptedProcess ~~ nil ifTrue: [		"Note: must set the suspendedContext first -- ar 4/5/98 22:20"		contextStackTop isNil ifFalse:[			interruptedProcess suspendedContext: contextStackTop].		interruptedProcess terminate].	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"	super release.! !!Debugger methodsFor: 'accessing' stamp: 'ar 4/5/98 22:43'!contents: aText notifying: aController 	"The retrieved information has changed and its source must now be 	updated. In this case, the retrieved information is the method of the 	selected context."	| selector classOfMethod category method priorMethod parseNode |	contextStackIndex = 0 ifTrue: [^self].	(self selectedContext isKindOf: MethodContext) ifFalse:[		(self confirm:'I will have to revert to the method fromwhich this block originated.  Is that OK?')				ifFalse: [^self].		self terminateAllFrom: contextStackTop to: self selectedContext home.		self resetContext: self selectedContext home].	classOfMethod _ self selectedClass.	category _ self selectedMessageCategoryName.	Cursor execute showWhile:		[method _ classOfMethod		compile: aText		notifying: aController		trailer: #(0 0 0 0)		ifFail: [^ false]		elseSetSelectorAndNode: 			[:sel :methodNode | selector _ sel.			selector == self selectedMessageName				ifFalse: [self notify: 'can''t change selector'. ^ false].			priorMethod _ (classOfMethod includesSelector: selector)				ifTrue: [classOfMethod compiledMethodAt: selector]				ifFalse: [nil].			sourceMap _ methodNode sourceMap.			tempNames _ methodNode tempNames.			parseNode _ methodNode].		method cacheTempNames: tempNames].	category isNil ifFalse: "Skip this for DoIts"		[method putSource: aText				fromParseNode: parseNode				class: classOfMethod				category: category				inFile: 2 priorMethod: priorMethod.		classOfMethod organization classify: selector under: category].	contents _ aText copy.	self terminateAllFrom: contextStackTop to: self selectedContext.	self selectedContext restartWith: method.	contextVariablesInspector object: nil.	self resetContext: self selectedContext.	^true! !!Debugger methodsFor: 'context stack' stamp: 'ar 4/5/98 13:56'!fullyExpandStack	"Expand the stack to include all of it, rather than the first four or five	contexts."	self okToChange ifFalse: [^ self].	self newStack: (contextStackTop stackForProcess: interruptedProcess).	self changed: #contextStackList! !!Debugger methodsFor: 'menu messages' stamp: 'ar 4/5/98 22:42'!restart: aScheduledController 	"Proceed from the initial state of the currently selected context. The 	argument is a controller on a view of the receiver. That view is closed."	self okToChange ifFalse: [^ self].	self checkContextSelection.	(self selectedContext isKindOf: MethodContext) ifFalse:[		(self confirm:'I will have to revert to the method fromwhich this block originated.  Is that OK?') ifFalse: [^self].		self terminateAllFrom: contextStackTop to: self selectedContext home.		self resetContext: self selectedContext home].	self terminateAllFrom: contextStackTop to: self selectedContext.	self selectedContext restart.	self resumeProcess: aScheduledController! !!Debugger methodsFor: 'code execution' stamp: 'ar 4/6/98 00:29'!handleForDebug: aBlock	"Catch any exceptions during execution of aBlock. If an exception occurs return the context that raised this exception. If no exception occurs return the value of aBlock (which will be a context also)."	^aBlock on: SimulatedException, DebugStop do:[:ex|		"Transcript cr; show:'Caught ', ex printString, ' with ', ex tag printString."		ex class == DebugStop ifTrue:[			"Simulation stumbled over some error"			proceedValue := nil.			externalInterrupt := false. "Need to push proceed value"			ex return: ex initialContext.		].		ex tag == #Processor ifTrue:[			"Client wants to get some information"			ex parameter == #activeProcess ifTrue:[ex resume: interruptedProcess].			ex pass].		ex tag == #DebugStop ifTrue:[			"Client wants to stop debugging at given point"			ex return: ex parameter stepToSendOrReturn].		"Some unknown exception"		Warning signal:'Unknown simulated exception encountered'.		ex pass].! !!Debugger methodsFor: 'code execution' stamp: 'ar 4/6/98 00:32'!send	"Send the selected message in the accessed method, and take control in 	the method invoked to allow further step or send."	| currentContext |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	currentContext stepToSendOrReturn.	self contextStackIndex > 1 | currentContext willReturn		ifTrue: 			[self changed: #notChanged]		ifFalse: 			[currentContext _ self handleForDebug:[currentContext step].			currentContext stepToSendOrReturn.			self resetContext: currentContext]! !!Debugger methodsFor: 'code execution' stamp: 'ar 4/6/98 00:32'!step	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod oldContext |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext := self handleForDebug:[				self stepFrom: contextStackTop to: currentContext].			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ self handleForDebug:[						currentContext step returnFromBasicValue].					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #pc]]				ifFalse: 					[oldContext := currentContext.					currentContext := self handleForDebug:[						self stepFrom: currentContext step to: currentContext].					oldContext == currentContext 						ifFalse:[self resetContext: currentContext].					self changed: #pc.					self updateInspectors]]! !!Debugger methodsFor: 'code execution' stamp: 'ar 4/6/98 00:30'!stepFrom: startContext to: topContext	"Step from the startContext until topContext is reached. Watch for UserInterrupt in case it takes to long and the user wants to stop simulation somewhere inbetween."	| userInterrupt ctx |	userInterrupt := false.	[ctx := topContext completeCallee: startContext orUntil:[userInterrupt]]		on: UserInterrupt		do:[:ex| userInterrupt := true. ex resume].	^ctx! !!Debugger methodsFor: 'private' stamp: 'ar 4/5/98 15:31'!newStack: stack	| oldStack diff |	oldStack _ contextStack.	contextStack _ stack.	(oldStack == nil or: [oldStack last ~~ stack last])		ifTrue: [contextStackList _ contextStack collect: [:ctx | ctx printString].				^ self].	"May be able to re-use some of previous list"	"ar 3/31/98 15:55 -- check with contextStackIndex"	diff _ (stack size - oldStack size) + (contextStackIndex - 1).	contextStackList _ diff <= 0		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]		ifFalse: [diff > 1				ifTrue: [contextStack collect: [:ctx | ctx printString]]				ifFalse: [(Array with: stack first printString) , contextStackList]]! !!Debugger methodsFor: 'private' stamp: 'ar 4/5/98 23:46'!process: aProcess controller: aController context: aContext	super initialize.	contents _ nil. 	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1 forProcess: interruptedProcess).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true! !!Debugger methodsFor: 'private' stamp: 'ar 4/5/98 13:56'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext _ self selectedContext.	contextStackTop _ aContext.	self newStack: (contextStackTop stackForProcess: interruptedProcess).	self changed: #contextStackList.	self contextStackIndex: 1 oldContextWas: oldContext! !!Debugger methodsFor: 'private' stamp: 'ar 4/5/98 22:52'!terminateAllFrom: firstContext to: lastContext	interruptedProcess exceptionHandlers terminateFrom: firstContext to: lastContext! !!DebuggerView class methodsFor: 'instance creation' stamp: 'ar 4/5/98 13:57'!openInterrupt: aString onProcess: interruptedProcess 	"Create and schedule a simple view with a debugger which can be opened later."	| aDebugger |	aDebugger _ Debugger interruptProcess: interruptedProcess.	^ self openNotifier: aDebugger		contents: (aDebugger interruptedContext shortStackForProcess: interruptedProcess)		label: aString! !