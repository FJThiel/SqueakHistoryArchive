'From Squeak 1.31 of Feb 4, 1998 on 9 April 1998 at 8:35:55 pm'!"Change Set:		Exceptions-ClassesDate:			9 April 1998Author:			Andreas Raab (ar) raab@isg.cs.uni-magdeburg.deThis change set contains the classes in the exception system plus a number of other changes in the following classes:* ContextPart: detect if a context is in a valid caller chain* BlockContext: raise ExceptionCannotReturn upon #cannotReturn:* Debugger/DebuggerView: open a debugger on an Exception* Process: make errorHandler obsolete (it will be used to store the exception handlers)BlockContext>>cannotReturn: is the only method where this change set already installs one of the new exceptions. This is due to fact that the termination handler needs the exception to work properly.After installing this change set you can try to run the examples from Exception class. However, before doing so you should save your image and try the TerminationHandler>>crashVM example."!Object subclass: #Exception	instanceVariableNames: 'tag messageText signaler initialContext handler resumeBlock passBlock '	classVariableNames: 'HandlerResponseMessages '	poolDictionaries: ''	category: 'Exceptions-Kernel'!Exception subclass: #Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!Object subclass: #ExceptionFilter	instanceVariableNames: 'baseException '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Filter'!Link subclass: #ExceptionHandler	instanceVariableNames: 'exception environment context active doBlock handlerBlock retryBlock returnBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!LinkedList subclass: #ExceptionHandlerList	instanceVariableNames: 'terminationInProgress '	classVariableNames: 'ObsoleteHandlersFound '	poolDictionaries: ''	category: 'Exceptions-Kernel'!ExceptionFilter subclass: #ExceptionMessageTextFilter	instanceVariableNames: 'messageText '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Filter'!Object subclass: #ExceptionSet	instanceVariableNames: 'signals '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!ExceptionFilter subclass: #ExceptionSignalerFilter	instanceVariableNames: 'signaler '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Filter'!ExceptionFilter subclass: #ExceptionTagFilter	instanceVariableNames: 'tagValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Filter'!Exception subclass: #Interrupt	instanceVariableNames: 'interruptedProcess interrupted '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!Error subclass: #MessageNotUnderstood	instanceVariableNames: 'receiver message '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!Exception subclass: #Notification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!Error subclass: #ResumableError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!Exception subclass: #SystemException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!SystemException subclass: #DebugStop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!SystemException subclass: #ExceptionCannotReturn	instanceVariableNames: 'context returnValue '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!SystemException subclass: #ProcessTermination	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!SystemException subclass: #SimulatedException	instanceVariableNames: 'defaultAction parameter '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!ExceptionHandler subclass: #TerminationHandler	instanceVariableNames: 'brokenContext actualSender terminationBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!Exception subclass: #UnhandledException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Kernel'!Interrupt subclass: #UserInterrupt	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-System'!Notification subclass: #Warning	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!Error subclass: #ZeroDivide	instanceVariableNames: 'dividend '	classVariableNames: ''	poolDictionaries: ''	category: 'Exceptions-Generic'!!Object methodsFor: 'testing' stamp: 'ar 4/5/98 16:00'!isException	^false! !!Object methodsFor: 'testing' stamp: 'ar 4/2/98 16:25'!isExceptionHandler	^false! !!ContextPart methodsFor: 'testing' stamp: 'ar 3/31/98 16:48'!isActive	"Return true if the receiver is on an active execution chain. Needed by the exception system."	^self sender notNil! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 4/2/98 14:21'!ensure: aBlock	"Evaluate the receiver. Immediately before the receiver block is left to any other context evaluate aBlock"	^ExceptionHandler		evaluate: self		ensure: aBlock! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 4/5/98 15:30'!ifCurtailed: aBlock	"Evaluate the receiver. If an exception occurs evaluate aBlock before returning."	^ExceptionHandler		evaluate: self		ifCurtailed: aBlock.! !!BlockContext methodsFor: 'evaluating' stamp: 'ar 4/2/98 14:22'!on: anExceptionSet do: aBlock	"Evaluate the receiver. If an exception from the exception set occurs evaluate handlerBlock"	^ExceptionHandler		evaluate: self		on: anExceptionSet		do: aBlock! !!BlockContext methodsFor: 'private' stamp: 'ar 4/1/98 17:36'!cannotReturn: result	"The receiver tried to return result to a method context that no longer exists.	Raise ExceptionCannotReturn."	^ExceptionCannotReturn context: self returnValue: result	"DebuggerView		openContext: thisContext		label: 'Block cannot return'		contents: thisContext shortStack."! !!Debugger class methodsFor: 'instance creation' stamp: 'ar 4/6/98 00:12'!context: aContext interrupted: aBoolean	"Answer an instance of me that models the current state of the system. 	The active process has determined that a debugger should be set up 	(often by the user issuing the command debug)."	| aDebugger |	aDebugger _ self new.	aDebugger		process: Processor activeProcess		controller: (ScheduledControllers inActiveControllerProcess					ifTrue: [ScheduledControllers activeController])		context: aContext.	aDebugger externalInterrupt: aBoolean.	^aDebugger! !!DebuggerView class methodsFor: 'instance creation' stamp: 'ar 4/6/98 00:47'!openException: anException	"Create and schedule a simple view on a Debugger on haltContext.	The view is labeled with aString and shows a short sender stack."	ErrorRecursion		ifTrue: 			[ErrorRecursion _ false.			self primitiveError: anException messageText].	ErrorRecursion _ true.	self openNotifier: (Debugger context: anException initialContext interrupted: anException isInterrupt)		contents: anException initialContext shortStack		label: anException messageText.	ErrorRecursion _ false.	Processor activeProcess exceptionHandlers terminateUpTo: anException initialContext.	Processor activeProcess suspend! !!Exception commentStamp: 'ar 4/9/98 20:35' prior: 0!I represent the occurence of any exceptional condition in the Smalltalk system. In general, I am raised by sending the message signal: to one of my subclasses i.e., a new exception is created by something like:	Error signal:'Something is wrong'.Exceptions can be handled by sending on:do: to any block in which the exception might be signaled such as in:	[100 / 0] on: ZeroDivide do:[:ex| ex return: ex dividend].(More or less) public instance variables:	tag 				<Object | nil>		- any object to specify this exception further	messageText 	<String | nil>		- a textual description of the exception	signaler			<Object>			- the object raising the exceptionThe following instance variables are private to the exception system:	initialContext 	<ContextPart>	- the context where the exception occured	handler 		<ExceptionHandler>	- the current exception handler	resumeBlock		<BlockContext>	- a block with the action to take on resume: !!Exception methodsFor: 'accessing' stamp: 'ar 4/2/98 11:36'!environment	"Return the current exception environment"	^Processor activeProcess exceptionHandlers! !!Exception methodsFor: 'accessing' stamp: 'ar 3/30/98 23:21'!messageText	^messageText! !!Exception methodsFor: 'accessing' stamp: 'ar 3/30/98 23:21'!messageText: aString	messageText := aString! !!Exception methodsFor: 'accessing' stamp: 'ar 4/5/98 17:35'!signaler	^signaler! !!Exception methodsFor: 'accessing' stamp: 'ar 4/5/98 17:35'!signaler: anObject	signaler := anObject! !!Exception methodsFor: 'accessing' stamp: 'ar 4/2/98 01:00'!tag	"X3J20 says that we must return the messageText if no tag is given"	^tag isNil		ifTrue:[self messageText]		ifFalse:[tag]! !!Exception methodsFor: 'accessing' stamp: 'ar 3/31/98 01:24'!tag: anObject	tag := anObject! !!Exception methodsFor: 'testing' stamp: 'ar 4/5/98 15:59'!isException	^true! !!Exception methodsFor: 'testing' stamp: 'ar 4/7/98 17:45'!isHandledBy: anExceptionDescription	"Return true if the receiver can be handled by handlers using the given exception description"	^self isKindOf: anExceptionDescription! !!Exception methodsFor: 'testing' stamp: 'ar 4/5/98 23:53'!isInterrupt	^false! !!Exception methodsFor: 'testing' stamp: 'ar 3/31/98 19:22'!isNested	"Return true if there is any outer handler which could handle the receiver"	handler notNil "Search for next handler"		ifTrue:[^(self findNextHandlerFrom: handler) notNil].	initialContext notNil		ifTrue:[^false]. "No more handlers"	"We've not been called from an exception handler. Probably some client wants to know if the exception could be handled at all at the point of excution"	^(self findFirstHandlerFrom: thisContext) notNil! !!Exception methodsFor: 'testing' stamp: 'ar 4/7/98 17:53'!isPrototype	^false! !!Exception methodsFor: 'testing' stamp: 'ar 3/31/98 14:36'!isResumable	"Return true if this exception is resumable"	^resumeBlock notNil! !!Exception methodsFor: 'signaling' stamp: 'ar 4/5/98 16:48'!signal	"Signal the occurence of an exceptional condition"	"Transcript cr; show:'Signaling ', self printString."	self assert:[handler isNil]. "better be sure"	initialContext == nil ifTrue:[initialContext := thisContext sender sender].	(resumeBlock isNil and:[self class isResumable]) ifTrue:[		resumeBlock := [:value| ^value]. "<-- This block will be executed on Exception>>resume:"	].	(passBlock isNil) ifTrue:[		passBlock := [^self handleExceptionWith: (self findNextHandlerFrom: handler)].	].	^self handleExceptionWith: (self findFirstHandlerFrom: initialContext).! !!Exception methodsFor: 'signaling' stamp: 'ar 4/4/98 17:22'!signal: aString	"Signal the occurence of an exceptional condition"	self assert:[handler isNil]. "better be sure"	self messageText: aString.	initialContext == nil ifTrue:[initialContext := thisContext sender sender].	"Note: Using signal helps the debugger to find out that there is an exception"	^self signal! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/2/98 01:03'!outer	"Pass handling of this exception to any handler on the list. If the receiver is resumable and the outer exception handler resumes then return its resumption value to the sender"	| oldBlock |	self assert:[handler notNil]. "better be sure"	self isResumable ifFalse:[^self pass].	handler active: true.	oldBlock := resumeBlock.	resumeBlock := [:value| resumeBlock := oldBlock. ^value].	self pass.! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/9/98 20:24'!pass	"Pass handling of this exception to any handler on the list."	self assert:[handler notNil]. "better be sure"	"Transcript cr; show:'Passing ', self printString."	handler active: true.	passBlock copy value. "Note: use copy to avoid recursive execution"	^self handleExceptionWith: (self findNextHandlerFrom: handler).! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/1/98 20:55'!resignalAs: anException	"Raise a new exception instead of the receiver."	^self resignalAs: anException from: initialContext! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/1/98 20:55'!resignalAs: anException from: aContext	"Raise a new exception instead of the receiver."	self assert:[handler notNil]. "better be sure"	handler active: true.	anException initialContext: aContext.	anException signal.! !!Exception methodsFor: 'handler responses' stamp: 'ar 3/31/98 14:37'!resume	"Resume with nil"	^self resume: nil! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/1/98 16:52'!resume: resumeValue	"If the receiver is resumable (i.e. resumeBlock not nil) then proceed with execution else do defaultAction."	self assert:[handler notNil]. "better be sure"	handler active: true.	^resumeBlock isNil		ifTrue:[self defaultAction]		ifFalse:[resumeBlock value: resumeValue]! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/1/98 16:52'!retry	"Retry the on:do: expression."	self assert:[handler notNil]. "better be sure"	handler active: true.	handler retryBlock value.! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/1/98 16:52'!retryUsing: alternativeBlock	"Retry the on:do: expression with a different receiver."	self assert:[handler notNil]. "better be sure"	handler active: true.	handler doBlock: alternativeBlock.	handler retryBlock value.! !!Exception methodsFor: 'handler responses' stamp: 'ar 3/31/98 14:38'!return	"Return with nil"	^self return: nil! !!Exception methodsFor: 'handler responses' stamp: 'ar 4/4/98 16:57'!return: returnValue	"Return execution to the point past the on:do: expression."	self assert:[handler notNil]. "better be sure"	handler active: true.	handler returnBlock value: returnValue.! !!Exception methodsFor: 'private-handling' stamp: 'ar 3/31/98 17:26'!defaultAction	"Default action for all exceptions -- try to raise UnhandledException.	Note: It is not allowed to call any of the handler responses from the defaultAction so we raise the UnhandledException manually."	| ex |	ex := UnhandledException new.	ex initialContext: initialContext.	ex tag: self.	^ex signal: self messageText.! !!Exception methodsFor: 'private-handling' stamp: 'ar 4/2/98 11:37'!findFirstHandlerFrom: startContext	"Find the first handler in the process' exception handler list starting from the given context"	^self findFirstHandlerFrom: startContext in: self environment! !!Exception methodsFor: 'private-handling' stamp: 'ar 4/2/98 11:37'!findFirstHandlerFrom: startContext in: environment	"Find the first handler in the process' exception handler list starting from the given context"	| handlerList |	handlerList := environment.	handlerList isNil ifTrue:[^nil].	handlerList removeObsoleteHandlers. "Just do a quick check"	handlerList do:[:aHandler|		(aHandler handles: self) ifTrue:[^aHandler].	].	^nil! !!Exception methodsFor: 'private-handling' stamp: 'ar 3/30/98 23:55'!findNextHandlerFrom: prevHandler	"Find the next handler in the process' signal handler list starting with any previous handler (the previous handler has rejected this exception)"	| nextHandler |	prevHandler isNil ifTrue:[^nil].	nextHandler := prevHandler nextLink.	[nextHandler == nil] whileFalse:[		(nextHandler handles: self) ifTrue:[^nextHandler].		nextHandler := nextHandler nextLink.	].	^nil! !!Exception methodsFor: 'private-handling' stamp: 'ar 4/4/98 16:57'!handleExceptionWith: aHandler	"Handle the exception with the given handler"	| result |	handler := aHandler.	handler isNil ifTrue:[^self defaultAction].	"Disable the handler while evaluating the handlerBlock"	"Transcript cr; show: 'Handling ', self printString."	handler active: false.	result := handler handlerBlock value: self.	"If we come here there was no handler action specified. X3J20 says that we have to return the value of the handler block as the value of the receiver of the on:do: message."	^self return: result.! !!Exception methodsFor: 'private-handling' stamp: 'ar 4/6/98 00:22'!raiseDebugger	"Give the system a chance to raise the debugger. This method is provided such that you see how it *should* be done. See also UnhandledException>>defaultAction"	initialContext isNil ifTrue:[initialContext := thisContext].	^DebugStop		signal: self messageText		with: self		from: signaler		context: initialContext! !!Exception methodsFor: 'private-errors' stamp: 'ar 3/31/98 15:06'!assert: aBlock	"For now -- do some assertions as long as we debug this stuff"	aBlock value == true		ifFalse:[self basicError:'Assertion failed' fromContext: thisContext sender].! !!Exception methodsFor: 'private-errors' stamp: 'ar 3/31/98 15:07'!basicError: aString	"For now -- as long as we debug this stuff"	^self basicError: aString fromContext: thisContext sender! !!Exception methodsFor: 'private-errors' stamp: 'ar 4/6/98 00:17'!basicError: aString fromContext: aContextPart	"For now -- as long as we debug this stuff"	DebuggerView		openContext: aContextPart		label: aString		contents: aContextPart shortStack.! !!Exception methodsFor: 'private-accessing' stamp: 'ar 3/31/98 01:26'!initialContext	^initialContext! !!Exception methodsFor: 'private-accessing' stamp: 'ar 3/31/98 01:26'!initialContext: aContextPart	initialContext:= aContextPart! !!Exception class methodsFor: 'instance creation' stamp: 'ar 3/31/98 14:32'!new	"return a new exception with default values initialized"	^(super new)		messageText: self messageText! !!Exception class methodsFor: 'instance creation' stamp: 'ar 4/7/98 19:27'!newException: aString with: anObject from: aSignaler context: aContext	"Create a new exception with the specified values set"	^(self new)		messageText: aString;		tag: anObject;		signaler: aSignaler;		initialContext: aContext;		yourself! !!Exception class methodsFor: 'accessing' stamp: 'ar 3/31/98 14:32'!messageText	"Return a string describing the exception"	^'Unknown Exception'! !!Exception class methodsFor: 'filtering' stamp: 'ar 4/7/98 20:49'!includesFilter: aFilterClass	^false! !!Exception class methodsFor: 'filtering' stamp: 'ar 4/7/98 19:39'!named: aMessageText	^(ExceptionMessageTextFilter on: self)		messageText: aMessageText! !!Exception class methodsFor: 'filtering' stamp: 'ar 4/7/98 19:39'!signaledBy: aSignaler	^(ExceptionSignalerFilter on: self)		signaler: aSignaler! !!Exception class methodsFor: 'filtering' stamp: 'ar 4/7/98 19:38'!tagged: aTagValue	^(ExceptionTagFilter on: self)		tagValue: aTagValue! !!Exception class methodsFor: 'testing' stamp: 'ar 3/31/98 14:32'!handles: anException	"Return true if handlers for the receiver can handle anException"	^anException isKindOf: self! !!Exception class methodsFor: 'testing' stamp: 'ar 3/31/98 14:32'!isResumable	"Return true if instances of the receiver are resumable"	^true! !!Exception class methodsFor: 'signaling' stamp: 'ar 4/5/98 17:38'!signal	"Signal an apropriate exception"	^self 		signal: self messageText 		with: nil 		from: thisContext sender receiver		context: thisContext sender! !!Exception class methodsFor: 'signaling' stamp: 'ar 4/5/98 17:38'!signal: aString	"Signal an apropriate exception with the given message text"	^self 		signal: aString 		with: nil		from: thisContext sender receiver		context: thisContext sender! !!Exception class methodsFor: 'signaling' stamp: 'ar 4/5/98 17:39'!signal: aString with: anObject	"Signal the exception with the given tag and message text"	^self		signal: aString		with: anObject		from: thisContext sender receiver		context: thisContext sender! !!Exception class methodsFor: 'signaling' stamp: 'ar 4/5/98 17:39'!signal: aString with: anObject from: aSignaler 	^self		signal: aString		with: anObject		from: aSignaler		context: thisContext sender! !!Exception class methodsFor: 'signaling' stamp: 'ar 4/5/98 17:40'!signal: aString with: anObject from: aSignaler context: aContext	^(self new)		messageText: aString;		tag: anObject;		signaler: aSignaler;		initialContext: aContext;		signal! !!Exception class methodsFor: 'copying' stamp: 'ar 4/2/98 02:03'!, anExceptionClass	"Create an ExceptionSet from the receiver and the argument"	^ExceptionSet with: self with: anExceptionClass! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 16:44'!debuggerTest	"Exception debuggerTest"	"The debugger will be raised upon the first exception. Then step over the code and see how nicely you stop at any points where another exception occurs"	Error signal:'Stopping for debug'. "<-- first exception; debug from here"	"Just 'step' over the following"	(1 to: 10) do:[:i|		i = 3 ifTrue:[42 / 0]. "<-- debugger will stop in SmallInteger>>/"		i = 7 ifTrue:[self unhandledExceptionTest] "<-- debugger will stop inside"	].! !!Exception class methodsFor: 'examples' stamp: 'ar 4/5/98 17:00'!debuggerTest2	"Exception debuggerTest2"	"Try stepping inside the following"	| value |	self halt.	value := [				[100 / 0] ifCurtailed:[2+2]			] on: ZeroDivide do:[:ex| ex return: 42].	^value! !!Exception class methodsFor: 'examples' stamp: 'ar 4/1/98 21:01'!ensureTest1	"Exception ensureTest1"	[		^Transcript cr; show:'Returning lon-locally ... '	] ensure:[		Transcript show:'Gotcha!!'.	]! !!Exception class methodsFor: 'examples' stamp: 'ar 4/2/98 00:09'!ensureTest2	"Exception ensureTest2"	"Test of a non-local return from a termination block"	[		Transcript cr; show:'Returning lon-locally ... '.		^42	] ensure:[		^Transcript show:'Gotcha!!'.	]! !!Exception class methodsFor: 'examples' stamp: 'ar 4/2/98 00:13'!ensureTest3: n	"Exception ensureTest3: 10"	"Recursively ensure a number of blocks"	[		n = 0 ifTrue:[^42].		(n \\ 2) = 1			ifTrue:[^self ensureTest3: n - 1] "non-local"			ifFalse:[self ensureTest3: n - 1]. "local"		] ensure:[		Transcript cr; show:'Ensuring: ', n printString.	].	Transcript cr; show:'Exiting from ', n printString.	^42! !!Exception class methodsFor: 'examples' stamp: 'ar 4/2/98 00:51'!ensureTest4	"Exception ensureTest4"	"Ensuring an expression with abnormal termination"	| val |	val :=	 [				[42 / 0] ensure:[^Transcript cr; show:'Gotcha!!']			] on: ZeroDivide do:[:ex| ex return: ex dividend].	Transcript cr; show:'Returns from termination blocks are ignored'.	^val! !!Exception class methodsFor: 'examples' stamp: 'ar 4/1/98 22:36'!ifCurtailedTest1	"Exception ifCurtailedTest1"	^[		[42 / 0] ifCurtailed:[Transcript cr; show: 'Abnormal termination']	] on: ZeroDivide do:[:ex| ex return: 117].! !!Exception class methodsFor: 'examples' stamp: 'ar 4/2/98 00:09'!ifCurtailedTest2	"Exception ifCurtailedTest2"	^[		[[42 / 0] ifCurtailed:[			Transcript cr; show: 'First termination'.			[117 / 0] ifCurtailed:[				Transcript cr; show:'Second termination'.			].		]] ifCurtailed:[			Transcript cr; show:'Third termination'.			[297 / 0] ifCurtailed:[				Transcript cr; show:'Fourth termination'.			].		].	] on: ZeroDivide do:[:ex| 		Transcript cr; show:'Division by zero sent by:', ex dividend printString.		ex return: ex dividend].! !!Exception class methodsFor: 'examples' stamp: 'ar 4/1/98 17:02'!notificationTest	"Exception notificationTest"	"Raise a notification which is not caught by any handler"	^Notification signal:'Something is about to happen'! !!Exception class methodsFor: 'examples' stamp: 'ar 4/1/98 20:19'!outerTest	"Exception outerTest"	"Find an outer handler and use its handler value for further operation."	^[[ (42 / 0) + 100]		on: ZeroDivide		do:[:ex| ex resume: ex dividend / ex outer]	] on: ZeroDivide		do:[:ex| ex resume: -1].! !!Exception class methodsFor: 'examples' stamp: 'ar 4/1/98 20:19'!passTest	"Exception passTest"	"Pass handling of this exception to any handler on the list."	^[[ (42 / 0) + 100]		on: ZeroDivide		do:[:ex| ex pass. self error:'Must not get here'.]	] on: ZeroDivide		do:[:ex| ex resume: -1].! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 15:12'!resignalAsTest	"Exception resignalAsTest"	"Raise a new exception instead of the receiver."	^[		[ (100 / 0) + (42 / 0)]			on: ZeroDivide			do:[:ex| ex resignalAs: UnhandledException new]	]	on: UnhandledException		do:[:ex| ex return: 'Unhandled exception caught'].! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 15:13'!resumeTest	"Exception resumeTest"	"If the receiver is resumable then proceed with execution"	^[ (100 / 0) + (42 / 0) ] 		on: ZeroDivide		do:[:ex| ex resume: ex dividend]! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 15:14'!retryTest	"Exception retryTest"	"Retry the on:do: expression."	| div |	div := 0.	^[ (100 / div) + (42 / div) ]		on: ZeroDivide		do:[:ex|  div := div + 2. 				ex retry]! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 15:16'!retryUsingTest	"Exception retryUsingTest"	"Retry the on:do: expression with a different receiver.	Note: The example will give 1000 and *not* 1420 since the receiver of the on:do: message will be executed and not the partial computation."	^[ (100 / 0) + (42 / 0) ]		on: ZeroDivide		do:[:ex| ex retryUsing:[ex dividend / 0.1]].! !!Exception class methodsFor: 'examples' stamp: 'ar 4/4/98 17:08'!retryUsingTest2	"Exception retryUsingTest2"	"Retry the on:do: expression with a different receiver."	^[ [(100 / 0) + (42 / 0)] ifCurtailed:[Transcript cr; show:'Problem']]		on: ZeroDivide		do:[:ex| ex retryUsing:[ex dividend / 0.1]].! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 15:17'!returnTest	"Exception returnTest"	"Return execution to the point past the on:do: expression."	^[ (100 / 0) + (42 / 0) ]		on: ZeroDivide		do:[:ex| ex return: ex dividend]! !!Exception class methodsFor: 'examples' stamp: 'ar 3/31/98 16:44'!unhandledExceptionTest	"Exception unhandledExceptionTest"	"This shows how any errors show up if not handled"	Error signal:'Somethings wrong here'.! !!Exception class methodsFor: 'examples' stamp: 'ar 4/4/98 18:24'!warningTest	"Exception warningTest"	"Raise a warning which is not caught by any handler"	^Warning signal:'Sample warning'! !!Exception class methodsFor: 'debug support' stamp: 'ar 4/5/98 16:47'!handlerResponses	"Return a set of possible handler responses"	^HandlerResponseMessages isNil		ifTrue:[HandlerResponseMessages := (Exception organization					listAtCategoryNamed: 'handler responses' asSymbol) asSet]		ifFalse:[HandlerResponseMessages]! !!DebugStop class methodsFor: 'accessing' stamp: 'ar 4/6/98 00:25'!messageText	^'Stopping for debug'! !!Error class methodsFor: 'accessing' stamp: 'ar 3/31/98 01:55'!messageText	^'Error'! !!Error class methodsFor: 'testing' stamp: 'ar 3/31/98 15:20'!isResumable	"X3J20 says that Errors are by default not resumable"	^false! !!ExceptionCannotReturn class methodsFor: 'accessing' stamp: 'ar 3/31/98 21:30'!messageText	^'Block cannot return'! !!ExceptionCannotReturn class methodsFor: 'signaling' stamp: 'ar 4/1/98 17:36'!context: aContextPart returnValue: anObject	^(self new)		context: aContextPart;		returnValue: anObject;		signal! !!ExceptionFilter commentStamp: 'ar 4/9/98 20:35' prior: 0!I am a filter for general exceptions. My subclasses specify which instance state of an exception is to be filtered. I can be used in a hierarchical manner, so if users want to filter an exception which is based upon an Error has the message text 'Hello world' the tag value 42 and is signaled by Processor than you can simply type	((Error named:'Hello world') tagged: 42) signaledBy: Processorto describe the specific filter. In addition I can be used to signal exceptions which gives a simple way to specify user-defined exceptions of a certain type, i.e.,	| myException |	myException := Error named:'Something is wrong'.	[Transcript cr; show:'Raising myException'.	myException signal] on: myException do:[:ex|		Transcript cr; show:'Caught myException'].!!ExceptionFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:16'!baseException	^baseException! !!ExceptionFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:16'!baseException: anException	baseException := anException! !!ExceptionFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:16'!messageText	^self baseException messageText! !!ExceptionFilter methodsFor: 'filtering' stamp: 'ar 4/7/98 20:20'!named: aMessageText	^(ExceptionMessageTextFilter on: self) messageText: aMessageText! !!ExceptionFilter methodsFor: 'filtering' stamp: 'ar 4/7/98 20:20'!signaledBy: aSignaler	^(ExceptionSignalerFilter on: self) signaler: aSignaler! !!ExceptionFilter methodsFor: 'filtering' stamp: 'ar 4/7/98 20:20'!tagged: aTagValue	^(ExceptionTagFilter on: self) tagValue: aTagValue! !!ExceptionFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:53'!filters: anException	"Return true if the exception passes the receiver's filter"	^self subclassResponsibility! !!ExceptionFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:52'!handles: anException	^(self baseException handles: anException) 		and:[self filters: anException]! !!ExceptionFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:49'!includesFilter: aFilterClass	^self class == aFilterClass		ifTrue:[true]		ifFalse:[self baseException includesFilter: aFilterClass]! !!ExceptionFilter methodsFor: 'testing' stamp: 'ar 4/7/98 19:18'!isResumable	^self baseException isResumable! !!ExceptionFilter methodsFor: 'signaling' stamp: 'ar 4/7/98 19:30'!signal	"Signal an apropriate exception"	^self 		signal: self messageText 		with: nil 		from: thisContext sender receiver		context: thisContext sender! !!ExceptionFilter methodsFor: 'signaling' stamp: 'ar 4/7/98 19:30'!signal: aString	"Signal an apropriate exception with the given message text"	^self 		signal: aString 		with: nil		from: thisContext sender receiver		context: thisContext sender! !!ExceptionFilter methodsFor: 'signaling' stamp: 'ar 4/7/98 19:31'!signal: aString with: anObject	"Signal the exception with the given tag and message text"	^self		signal: aString		with: anObject		from: thisContext sender receiver		context: thisContext sender! !!ExceptionFilter methodsFor: 'signaling' stamp: 'ar 4/7/98 19:31'!signal: aString with: anObject from: aSignaler 	^self		signal: aString		with: anObject		from: aSignaler		context: thisContext sender! !!ExceptionFilter methodsFor: 'signaling' stamp: 'ar 4/7/98 19:31'!signal: aString with: anObject from: aSignaler context: aContext	| exception |	exception := self baseException 					newException: aString					with: anObject					from: aSignaler					context: aContext.	self setFilterValue: exception.	exception signal.! !!ExceptionFilter methodsFor: 'copying' stamp: 'ar 4/7/98 19:20'!, anExceptionClass	"Create an ExceptionSet from the receiver and the argument"	^ExceptionSet with: self with: anExceptionClass! !!ExceptionFilter methodsFor: 'private' stamp: 'ar 4/7/98 19:33'!setFilterValue: anException	"Set the value to be filtered in anException"	^self subclassResponsibility! !!ExceptionFilter methodsFor: 'instance creation' stamp: 'ar 4/7/98 21:19'!new	"Create a new exception with the default values set"	| ex |	ex := self baseException new.	self setFilterValue: ex.	^ex! !!ExceptionFilter methodsFor: 'instance creation' stamp: 'ar 4/7/98 21:18'!newException: aString with: anObject from: aSignaler context: aContext	"Create a new exception with the specified values set"	| ex |	ex := self baseException 			newException: aString 			with: anObject 			from: aSignaler			context: aContext.	self setFilterValue: ex.	^ex! !!ExceptionFilter class reorganize!('instance creation' on:)('private' cannotChainError)!!ExceptionFilter class methodsFor: 'instance creation' stamp: 'ar 4/7/98 20:51'!on: aBaseException	^(aBaseException includesFilter: self)		ifTrue:[self cannotChainError]		ifFalse:[self new baseException: aBaseException]! !!ExceptionFilter class methodsFor: 'private' stamp: 'ar 4/7/98 20:51'!cannotChainError	Error 		signal:'Cannot add new filter to the exception'		with: #cannotChainFilter		from: self! !!ExceptionHandler commentStamp: 'ar 4/9/98 20:35' prior: 0!Instances of me handle the occurence of exceptions. I am only created indirectly from BlockContext and no class besides Exception and BlockContext should rely on any implementation details of me.Implementation note: All of the handler responses are put in blocks which are installed at appropriate locations. At the moment the only exception is the block used for Exception>>resume: which is contained in class Exception itself. This was necessary since the resume block has to be installed before it is known if any handler exists at all.Instance variables:	exception		<Exception | ExceptionSet>		- the exceptions I can handle	active			<Boolean>		- whether or not I am currently active	context			<BlockContext>	- internal marker for valid handlers	doBlock			<BlockContext>	- the block to watch for any exceptions	handlerBlock	<BlockContext>	- the block to evaluate to handle exceptions	retryBlock		<BlockContext>	- the block to evaluate on Exception>>retry	returnBlock		<BlockContext>	- the block to evaluate on Exception>>return !!ExceptionHandler reorganize!('accessing' active active: environment environment:)('testing' handles: isEnabled isExceptionHandler isTerminationHandler isValid)('handling' evaluate:on:do:)('private-blocks' doBlock doBlock: handlerBlock handlerBlock: retryBlock retryBlock: returnBlock returnBlock:)('private-handling' basicValue: basicValue:with: evaluateWithoutProtection:on:do: executeBlock:marker:)('printing' printOn:)!!ExceptionHandler methodsFor: 'accessing' stamp: 'ar 4/1/98 16:50'!active	^active! !!ExceptionHandler methodsFor: 'accessing' stamp: 'ar 4/1/98 16:50'!active: aBoolean	active := aBoolean! !!ExceptionHandler methodsFor: 'accessing' stamp: 'ar 4/2/98 01:48'!environment	"Return the current exception environment"	^environment isNil		ifTrue:[Processor activeProcess exceptionHandlers]		ifFalse:[environment]! !!ExceptionHandler methodsFor: 'accessing' stamp: 'ar 4/2/98 01:49'!environment: anExceptionHandlerList	environment:= anExceptionHandlerList! !!ExceptionHandler methodsFor: 'testing' stamp: 'ar 4/2/98 01:07'!handles: anException	(self isValid and:[self isEnabled]) ifFalse:[^false].	^(exception handles: anException)! !!ExceptionHandler methodsFor: 'testing' stamp: 'ar 4/1/98 16:50'!isEnabled	^active == true! !!ExceptionHandler methodsFor: 'testing' stamp: 'ar 4/2/98 16:25'!isExceptionHandler	^true! !!ExceptionHandler methodsFor: 'testing' stamp: 'ar 4/5/98 13:22'!isTerminationHandler	^false! !!ExceptionHandler methodsFor: 'testing' stamp: 'ar 3/31/98 00:06'!isValid	"Return true if the receiver is a valid signal handler (i.e., the context is still in a valid caller chain)"	^context isActive! !!ExceptionHandler methodsFor: 'handling' stamp: 'ar 4/9/98 20:26'!evaluate: aBlock on: anExceptionSet do: aHandlerBlock	"Evaluate aBlock. If any of the exceptions in anExceptionSet occur evaluate aHandlerBlock."	| returnValue |	doBlock := aBlock. "<-- only initial block; may change on #retryUsing:"	"Once this is really running we might get rid of the termination handler"	TerminationHandler new guard:[		returnValue := self 						evaluateWithoutProtection: [self basicValue: doBlock]						on: anExceptionSet 						do: [:ex| self basicValue: aHandlerBlock copy with: ex].		"Coming here means that no abnormal termination outside the receiver occured"		self environment terminationInProgress: false.	] with:[:ex| "Do nothing. The termination handler does the rest"].	^returnValue! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 4/9/98 20:29'!doBlock	^doBlock copy "Note: use copy here to avoid recursive execution"! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 3/30/98 23:13'!doBlock: aBlock	doBlock := aBlock! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 4/9/98 20:27'!handlerBlock	^handlerBlock copy "Note: use copy here to avoid recursive execution"! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 3/30/98 23:14'!handlerBlock: aBlock	handlerBlock := aBlock! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 4/9/98 20:30'!retryBlock	^retryBlock copy "Note: use copy here to avoid recursive execution"! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 3/30/98 23:15'!retryBlock: aBlock	retryBlock := aBlock! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 4/9/98 20:29'!returnBlock	^returnBlock copy "Note: use copy here to avoid recursive execution"! !!ExceptionHandler methodsFor: 'private-blocks' stamp: 'ar 3/31/98 02:15'!returnBlock: aBlock	returnBlock := aBlock.! !!ExceptionHandler methodsFor: 'private-handling' stamp: 'ar 4/5/98 14:35'!basicValue: aBlock	"Evaluate aBlock. This method is caught by the simulation to allow easy stepping over the exception handlers."	^aBlock value! !!ExceptionHandler methodsFor: 'private-handling' stamp: 'ar 4/5/98 15:47'!basicValue: aBlock with: anArgument	"Evaluate aBlock. This method is caught by the simulation to allow easy stepping over the exception handlers."	^aBlock value: anArgument! !!ExceptionHandler methodsFor: 'private-handling' stamp: 'ar 4/5/98 16:10'!evaluateWithoutProtection: aBlock on: anExceptionSet do: aHandlerBlock	"Excecute aBlock. If any of the exceptions in anExceptionSet occurs evaluate handlerBlock and take the appropriate action."	| returnValue |	"Initialize the exception handler"	active := true.	exception := anExceptionSet.	context := thisContext.	handlerBlock := aHandlerBlock.	returnBlock := [:value| 		self environment terminationInProgress: true.		^value]. "<-- This block will be executed on Exception>>return:"	self environment addHandler: self.	"As long as the return value is the handler we have to retry the on:do: expression"	[returnValue := self executeBlock: aBlock marker: self.	returnValue == self] whileTrue.	self environment removeHandler: self.	^returnValue! !!ExceptionHandler methodsFor: 'private-handling' stamp: 'ar 4/5/98 14:56'!executeBlock: aBlock marker: markerObject	"Assumption: The doBlock cannot return the markerObject so we can use it to decide whether or not we have to restart the on:do: expression.	The retryBlock has been put in this location to avoid recursive execution of the doBlock. If the exception is restarted, the non-local return will nil the doBlock's sender - and that's exactly what we need"	retryBlock := [^markerObject].	^aBlock value! !!ExceptionHandler methodsFor: 'printing' stamp: 'ar 4/1/98 22:00'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		print: exception;		space;		print: context;		nextPut: $).! !!ExceptionHandler class methodsFor: 'instance creation' stamp: 'ar 4/5/98 17:42'!evaluate: guardedBlock ensure: terminationBlock	(terminationBlock class == BlockContext and:[		terminationBlock numArgs = 0]) ifFalse:[			^Error				signal:'Wrong argument for termination block'				with: #wrongTerminationArgument].	^TerminationHandler new		evaluate: guardedBlock		ensure: terminationBlock! !!ExceptionHandler class methodsFor: 'instance creation' stamp: 'ar 4/5/98 17:05'!evaluate: guardedBlock ifCurtailed: terminationBlock	(terminationBlock class == BlockContext and:[		terminationBlock numArgs = 0]) ifFalse:[			^Error				signal:'Wrong argument for termination block'				with: #wrongTerminationArgument].	^TerminationHandler new		evaluate: guardedBlock		ifCurtailed: terminationBlock! !!ExceptionHandler class methodsFor: 'instance creation' stamp: 'ar 4/5/98 17:05'!evaluate: guardedBlock on: exceptions do: exceptionBlock	(exceptionBlock class == BlockContext and:[		exceptionBlock numArgs = 1]) ifFalse:[			^Error				signal:'Wrong argument for termination block'				with: #wrongTerminationArgument].	^ExceptionHandler new		evaluate: guardedBlock		on: exceptions		do: exceptionBlock! !!ExceptionHandlerList commentStamp: 'ar 4/9/98 20:35' prior: 0!I keep a list of exception handlers for any process. I am basically a LinkedList with very little additional behavior.!!ExceptionHandlerList reorganize!('initialize-release' initialize)('accessing' removeObsoleteHandlers terminationHandlers terminationInProgress terminationInProgress:)('adding' addHandler:)('removing' removeHandler:)('testing' handles:)('unwinding' terminateAll terminateFrom:to: terminateUpTo:)!!ExceptionHandlerList methodsFor: 'initialize-release' stamp: 'ar 4/1/98 21:52'!initialize	terminationInProgress := 0.! !!ExceptionHandlerList methodsFor: 'accessing' stamp: 'ar 4/7/98 16:01'!removeObsoleteHandlers	"Remove any obsolete exception handlers (i.e., handlers with a context not on the active caller chain). Note: Due to the termination wrappers this should no longer happen."	[self isEmpty or:[self first isValid]] whileFalse:[		ObsoleteHandlersFound := ObsoleteHandlersFound + 1.		self removeFirst].! !!ExceptionHandlerList methodsFor: 'accessing' stamp: 'ar 4/7/98 16:05'!terminationHandlers	"Return a Dictionary with brokenContext  -> hander associations. This is used to detect handlers for a given (broken) context"	| dict |	dict := IdentityDictionary new: self size. "a bit more than needed"	self do:[:handler|		(handler isValid and:[handler isTerminationHandler]) ifTrue:[			dict at: handler brokenContext put: handler.		].	].	^dict! !!ExceptionHandlerList methodsFor: 'accessing' stamp: 'ar 4/1/98 21:53'!terminationInProgress	^terminationInProgress ~= 0! !!ExceptionHandlerList methodsFor: 'accessing' stamp: 'ar 4/2/98 00:07'!terminationInProgress: aBoolean	terminationInProgress := terminationInProgress + (aBoolean ifTrue:[1] ifFalse:[-1]).! !!ExceptionHandlerList methodsFor: 'adding' stamp: 'ar 4/5/98 17:26'!addHandler: anExceptionHandler	"Add a new exception handler to the process' exception handler list"	self removeObsoleteHandlers.	^self addFirst: anExceptionHandler.! !!ExceptionHandlerList methodsFor: 'removing' stamp: 'ar 4/5/98 20:37'!removeHandler: anExceptionHandler	"Remove all exception handlers up to anExceptionHandler -- we will get rid of the obsolete handlers too."	[self removeFirst == anExceptionHandler] whileFalse.	^anExceptionHandler! !!ExceptionHandlerList methodsFor: 'testing' stamp: 'ar 4/5/98 17:26'!handles: anException	"Look if any handler in the list can handle anException"	self do:[:each| (each handles: anException) ifTrue:[^true]].	^false! !!ExceptionHandlerList methodsFor: 'unwinding' stamp: 'ar 4/8/98 00:17'!terminateAll	"Evaluate all existing termination handlers in the receiver"	| handler |	handler := firstLink.	[handler isNil] whileFalse:[		handler isTerminationHandler			ifTrue:[handler evaluateTerminationBlock].		handler nextLink isNil			ifTrue:[handler := firstLink]			ifFalse:[handler := handler nextLink]]! !!ExceptionHandlerList methodsFor: 'unwinding' stamp: 'ar 4/8/98 00:17'!terminateFrom: firstContext to: lastContext	"Excecute all termination actions from firstContext to lastContext"	| theContext theHandlers theHandler |	"Transcript cr; show:'Unwinding from ', firstContext printString,'to ', lastContext printString."	theHandlers := self terminationHandlers.	theContext := firstContext.	[theContext == nil or:[theContext == lastContext]] whileFalse:[		theContext sender == nil ifTrue:[			theHandler := theHandlers at: theContext ifAbsent:[nil].			theHandler isNil 				ifFalse:[theHandler evaluateTerminationBlock]].		"Note: theContext sender will be restored by evaluateTerminationBlock"		theContext := theContext sender].! !!ExceptionHandlerList methodsFor: 'unwinding' stamp: 'ar 4/8/98 00:17'!terminateUpTo: aContext	"Excecute all termination actions up to aContext"	self terminateFrom: thisContext to: aContext! !!ExceptionHandlerList class methodsFor: 'class initialization' stamp: 'ar 4/4/98 17:00'!initialize	"ExceptionHandlerList initialize"	ObsoleteHandlersFound := 0.! !!ExceptionHandlerList class methodsFor: 'instance creation' stamp: 'ar 4/1/98 21:51'!new	^super new initialize! !!ExceptionMessageTextFilter commentStamp: 'ar 4/9/98 20:35' prior: 0!I am an ExceptionFilter filtering the message text of the associated exception.!]style[(8 15 56)f1,f1LExceptionFilter Comment;,f1!!ExceptionMessageTextFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:35'!messageText	^messageText! !!ExceptionMessageTextFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:35'!messageText: aString	messageText := aString! !!ExceptionMessageTextFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:52'!filters: anException	^anException messageText = self messageText! !!ExceptionMessageTextFilter methodsFor: 'private' stamp: 'ar 4/7/98 19:36'!setFilterValue: anException	anException messageText: self messageText! !!ExceptionMessageTextFilter methodsFor: 'printing' stamp: 'ar 4/7/98 19:52'!printOn: aStream	aStream		print: self baseException;		nextPutAll:' named: ';		print: self messageText.! !!ExceptionSet commentStamp: 'ar 4/9/98 20:35' prior: 0!I represent a specification for arbitrary numbers of exceptions. I am mainly used in cases where clients want to watch a number of exceptions simultaneously, such as in:	[ ... some actions ...]		on: ZeroDivide, NegativeRoot, FloatOverflow	do:[:ex| ... the handler action ...]!!ExceptionSet methodsFor: 'initialize' stamp: 'ar 3/31/98 01:14'!with: firstSignal with: secondSignal	signals := Set new.	signals add: firstSignal.	signals add: secondSignal.! !!ExceptionSet methodsFor: 'testing' stamp: 'ar 3/31/98 01:43'!handles: anException	^(signals detect:[:any| any handles: anException] ifNone:[nil]) notNil! !!ExceptionSet methodsFor: 'copying' stamp: 'ar 3/31/98 01:14'!, aSignal	signals add: aSignal! !!ExceptionSet class methodsFor: 'instance creation' stamp: 'ar 3/31/98 01:15'!with: firstSignal with: secondSignal	^self new with: firstSignal with: secondSignal! !!ExceptionSignalerFilter commentStamp: 'ar 4/9/98 20:35' prior: 0!I am an ExceptionFilter filtering the signaler of the associated exception.!]style[(8 15 52)f1,f1LExceptionFilter Comment;,f1!!ExceptionSignalerFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:33'!signaler	^signaler! !!ExceptionSignalerFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:34'!signaler: anObject	signaler := anObject! !!ExceptionSignalerFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:52'!filters: anException	^self signaler = anException signaler! !!ExceptionSignalerFilter methodsFor: 'private' stamp: 'ar 4/7/98 19:34'!setFilterValue: anException	anException signaler: self signaler! !!ExceptionSignalerFilter methodsFor: 'printing' stamp: 'ar 4/7/98 19:52'!printOn: aStream	aStream		print: self baseException;		nextPutAll:' signaledBy: ';		print: self signaler.! !!ExceptionTagFilter commentStamp: 'ar 4/9/98 20:35' prior: 0!I am an ExceptionFilter filtering the tag value of the associated exception.!]style[(8 15 53)f1,f1LExceptionFilter Comment;,f1!!ExceptionTagFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:22'!tagValue	^tagValue! !!ExceptionTagFilter methodsFor: 'accessing' stamp: 'ar 4/7/98 19:22'!tagValue: anObject	tagValue := anObject! !!ExceptionTagFilter methodsFor: 'testing' stamp: 'ar 4/7/98 20:52'!filters: anException	^self tagValue = anException tag! !!ExceptionTagFilter methodsFor: 'private' stamp: 'ar 4/7/98 19:33'!setFilterValue: anException	"Set the value to be filtered in anException"	anException tag: self tagValue! !!ExceptionTagFilter methodsFor: 'printing' stamp: 'ar 4/7/98 19:52'!printOn: aStream	aStream		print: self baseException;		nextPutAll:' tagged: ';		print: self tagValue! !!Interrupt commentStamp: 'ar 4/9/98 20:35' prior: 0!My subclasses signal exceptional conditions to any other process.!!Interrupt methodsFor: 'accessing' stamp: 'ar 4/6/98 19:48'!interrupted	^interrupted! !!Interrupt methodsFor: 'accessing' stamp: 'ar 4/6/98 19:48'!interrupted: aBoolean	interrupted := aBoolean! !!Interrupt methodsFor: 'accessing' stamp: 'ar 4/6/98 18:45'!process	^interruptedProcess! !!Interrupt methodsFor: 'accessing' stamp: 'ar 4/6/98 18:45'!process: aProcess	interruptedProcess := aProcess.! !!Interrupt methodsFor: 'testing' stamp: 'ar 4/6/98 19:50'!isInterrupt	"Note: Only return true if really interrupted, else we might confuse the debugger"	^interrupted == true! !!Interrupt class methodsFor: 'signaling' stamp: 'ar 4/6/98 18:36'!signal: messageText with: aParameter from: aSignaler context: aContext	"Note: aContext is ignored with interrupts."	^self 		signal: messageText		with: aParameter		from: aSignaler		process: Processor activeProcess! !!Interrupt class methodsFor: 'signaling' stamp: 'ar 4/6/98 19:48'!signal: messageText with: aParameter from: aSignaler process: aProcess	^self 		signal: messageText		with: aParameter		from: aSignaler		process: aProcess		interrupted: (Processor activeProcess == aProcess) not! !!Interrupt class methodsFor: 'signaling' stamp: 'ar 4/6/98 19:53'!signal: messageText with: aParameter from: aSignaler process: aProcess interrupted: aBoolean	aProcess interruptWith:[		(self new)			messageText: messageText;			tag: aParameter;			signaler: aSignaler;			process: aProcess;			initialContext: thisContext sender sender;			interrupted: aBoolean;			signal].! !!MessageNotUnderstood methodsFor: 'accessing' stamp: 'ar 3/31/98 17:02'!message	^message! !!MessageNotUnderstood methodsFor: 'accessing' stamp: 'ar 3/31/98 17:03'!message: aMessage	message := aMessage! !!MessageNotUnderstood methodsFor: 'accessing' stamp: 'ar 3/31/98 17:05'!receiver	^receiver! !!MessageNotUnderstood methodsFor: 'accessing' stamp: 'ar 3/31/98 17:05'!receiver: anObject	receiver := anObject! !!MessageNotUnderstood methodsFor: 'printing' stamp: 'ar 4/2/98 13:41'!printOn: aStream	super printOn: aStream.	message printOn: aStream.! !!MessageNotUnderstood class methodsFor: 'testing' stamp: 'ar 3/31/98 17:03'!isResumable	^true! !!MessageNotUnderstood class methodsFor: 'accessing' stamp: 'ar 3/31/98 17:07'!messageText	^'Message not understood: '! !!MessageNotUnderstood class methodsFor: 'signaling' stamp: 'ar 3/31/98 17:08'!receiver: anObject message: aMessage	^(self new)		receiver: anObject;		message: aMessage;		signal: self messageText, aMessage selector! !!Notification reorganize!('private-handling' defaultAction)!!Notification methodsFor: 'private-handling' stamp: 'ar 4/7/98 23:47'!defaultAction	"X3J20 says that notifications just return nil as default"	[((PopUpMenu labels: '  OK  ') startUpWithCaption: self messageText) =0] whileTrue.	^nil! !!Notification class methodsFor: 'accessing' stamp: 'ar 3/31/98 01:54'!messageText	^'Notification'! !!Notification class methodsFor: 'testing' stamp: 'ar 3/31/98 15:21'!isResumable	"X3J20 says that notifications are resumable by default"	^true! !!Process methodsFor: 'error handling' stamp: 'ar 3/31/98 16:49'!errorHandler	"Obsolete - for compatibility only"    ^ nil! !!Process methodsFor: 'error handling' stamp: 'ar 4/5/98 17:30'!errorHandler: aBlock	"Obsolete - for compatibility only"! !!Process methodsFor: 'error handling' stamp: 'ar 4/1/98 01:54'!exceptionHandlers	"Return the exception handler list for this process"	^errorHandler ifNil:[errorHandler := ExceptionHandlerList new]! !!Process methodsFor: 'error handling' stamp: 'ar 4/5/98 18:01'!exceptionHandlers: aHandlerList	"Set the exception handler list for this process"	errorHandler := aHandlerList! !!ProcessTermination class methodsFor: 'accessing' stamp: 'ar 4/5/98 20:03'!messageText	^'Process will be terminated'! !!ProcessTermination class methodsFor: 'testing' stamp: 'ar 4/5/98 20:02'!isResumable	^false! !!ResumableError class methodsFor: 'testing' stamp: 'ar 3/31/98 19:09'!isResumable	^true! !!SystemException commentStamp: 'ar 4/9/98 20:35' prior: 0!My subclasses are used internally by Squeak for a number of purposes.!!DebugStop commentStamp: 'ar 4/9/98 20:35' prior: 0!Instances of me are raised to invoke a debugger. When I am signaled during system simulation (i.e., the simulated process runs about an error) then the debugger already running gets a chance to catch me. Even if the simulation is run without a debugger (i.e., from ContextPart>>runSimulated:) a debugger will pop up on the point of simulation.If I am not signaled in a simulation environment, then I just raise a debugger as usual.!!DebugStop methodsFor: 'testing' stamp: 'ar 4/6/98 00:14'!isInterrupt	^tag isNil		ifTrue:[false]		ifFalse:[tag isInterrupt]! !!DebugStop methodsFor: 'private-handling' stamp: 'ar 4/6/98 00:13'!defaultAction	"Raise the debugger"	initialContext isNil ifTrue:[initialContext := thisContext].	DebuggerView openException: self! !!ExceptionCannotReturn commentStamp: 'ar 4/9/98 20:35' prior: 0!Instances of me are raised whenever the VM finds a broken sender chain from a BlockContext. I am used for termination blocks where the sender chain is deliberately broken to prevent any non-local returns through the guarding expression.Instance variables:	context			<BlockContext>	- the context where the non-local return was executed	returnValue		<Object>			- return value of the block!!ExceptionCannotReturn methodsFor: 'accessing' stamp: 'ar 3/31/98 21:28'!context	^context! !!ExceptionCannotReturn methodsFor: 'accessing' stamp: 'ar 3/31/98 21:28'!context: aContextPart	context := aContextPart! !!ExceptionCannotReturn methodsFor: 'accessing' stamp: 'ar 4/1/98 17:37'!returnValue	^returnValue! !!ExceptionCannotReturn methodsFor: 'accessing' stamp: 'ar 4/1/98 17:37'!returnValue: anObject	returnValue := anObject! !!ExceptionCannotReturn methodsFor: 'private-handling' stamp: 'ar 4/7/98 23:32'!defaultAction	"If an the receiver has not been handled (i.e., not been used for termination), raise an error exception"	^Error		signal:'Block cannot return'		with: #cannotReturn		from: signaler		context: initialContext! !!ProcessTermination commentStamp: 'ar 4/9/98 20:35' prior: 0!My whole purpose is to allow processes to evaluate any associated termination blocks before being terminated. Whenever a process is about to be terminated it will be interrupted with a ProcessTermination exception. This exception is itself being handled in BlockContext>>newProcess and will lead to the evaluation of any pending termination blocks. !!SimulatedException commentStamp: 'ar 4/9/98 20:35' prior: 0!I am an Exception raised only when simulating Smalltalk code. I am used to signal an associated debugger a number of things.Instance variables:	defaultAction	<BlockContext>	- the action to perfom if no handler is found	parameter		<Object>			- parameters to describe the exception furtherThe tag and the parameter usually represent a pair of information. The currently used tag/parameter pairs include:	tag				parameter			meaning	#Processor		#activeProcess		return the debugged process	#DebugStop		ContextPart			try to stop simulation at the given context!!SimulatedException methodsFor: 'accessing' stamp: 'ar 4/2/98 17:36'!action	^defaultAction! !!SimulatedException methodsFor: 'accessing' stamp: 'ar 4/2/98 17:37'!action: aBlock	defaultAction := aBlock! !!SimulatedException methodsFor: 'accessing' stamp: 'ar 4/2/98 17:36'!defaultAction	^defaultAction value! !!SimulatedException methodsFor: 'accessing' stamp: 'ar 4/2/98 17:37'!parameter	^parameter! !!SimulatedException methodsFor: 'accessing' stamp: 'ar 4/2/98 17:37'!parameter: anObject	parameter := anObject! !!TerminationHandler commentStamp: 'ar 4/9/98 20:35' prior: 0!I ensure the execution of termination blocks by deliberately breaking the sender chain of BlockContexts. Whenever a block tries to return non-local an ExceptionCannotReturn will be raised and I will evaluate the termination block. Note that I am needed by exception system to work properly -- on the other hand I need the exception system myself to work properly. Or as Ian put it:	> You take this week's prize for Gdelian programming.  ;)
Instance variables:	brokenContext		<BlockContext>	- this context's sender is broken	actualSender		<ContextPart>	- the broken context's sender	terminationBlock	<BlockContext>	- the termination action !!TerminationHandler reorganize!('testing' handles: isTerminationHandler isValid)('handling' evaluate:ensure: evaluate:ifCurtailed: evaluate:on:do:)('private-handling' evaluateTerminationBlock evaluateTerminationBlock: guard:with: returnValue:from:)('private-accessing' actualSender brokenContext)!!TerminationHandler methodsFor: 'testing' stamp: 'ar 4/1/98 22:58'!handles: anException	| ctx |	(super handles: anException) ifFalse:[^false].	"Need to check the context chain"	ctx := anException context.	[ctx sender notNil] whileTrue:[ctx := ctx sender].	^ctx notNil and:[ctx == brokenContext]! !!TerminationHandler methodsFor: 'testing' stamp: 'ar 4/5/98 13:22'!isTerminationHandler	^true! !!TerminationHandler methodsFor: 'testing' stamp: 'ar 4/5/98 13:39'!isValid	^super isValid and:[brokenContext notNil]! !!TerminationHandler methodsFor: 'handling' stamp: 'ar 4/5/98 21:58'!evaluate: aBlock ensure: aTerminationBlock	"Evaluate aBlock and ensure the evaluation of terminationBlock when aBlock is about to return."	| retVal |	terminationBlock := aTerminationBlock.	retVal := self 				guard: [self basicValue: aBlock]				with:	[:ex| self evaluateTerminationBlock:[			terminationBlock ifNotNil:[self basicValue: terminationBlock].			terminationBlock := nil]].	"Not tried to leave via non-local return"	self evaluateTerminationBlock:[		terminationBlock ifNotNil:[self basicValue: terminationBlock].		terminationBlock := nil].	^retVal! !!TerminationHandler methodsFor: 'handling' stamp: 'ar 4/6/98 20:38'!evaluate: aBlock ifCurtailed: aTerminationBlock	"Evaluate aBlock and ensure the evaluation of terminationBlock when aBlock is about to return"	| retVal |	terminationBlock := aTerminationBlock.	retVal := self 				guard: [self basicValue: aBlock]				with:		[:ex| "Evaluate the termination block"			self evaluateTerminationBlock:[				terminationBlock ifNotNil:[self basicValue: terminationBlock].				terminationBlock := nil]].	"Not tried to leave via non-local return"	(self environment terminationInProgress)		 ifTrue:[self evaluateTerminationBlock:[					terminationBlock ifNotNil:[self basicValue: terminationBlock].					terminationBlock := nil]].	^retVal! !!TerminationHandler methodsFor: 'handling' stamp: 'ar 4/1/98 19:12'!evaluate: aBlock on: anExceptionSet do: aHandlerBlock	"TerminationHandlers should not be used in this way"	^self shouldNotImplement! !!TerminationHandler methodsFor: 'private-handling' stamp: 'ar 4/6/98 01:01'!evaluateTerminationBlock	"Somebody wants us to evaluate the termination block right now.	Restore the broken context, remove the receiver from the exception handler list and then do what requested"	"Transcript cr; show:'Terminating a handler'."	brokenContext isNil ifFalse:[		brokenContext swapSender: actualSender.		actualSender := brokenContext := nil.		self environment removeHandler: self].	self evaluateTerminationBlock: terminationBlock.	terminationBlock := nil.! !!TerminationHandler methodsFor: 'private-handling' stamp: 'ar 4/5/98 14:55'!evaluateTerminationBlock: aBlock	"Evaluate the terminaton block. To avoid nasty non-local returns we guard this block also but we will just return on attempt to leave it. Note that we cannot raise any signal here since in nested termination blocks the returnValue:from: might be interpreted as returning non-locally through the receiver"	aBlock isNil ifTrue:[^self].	self 		guard: aBlock		with:[:ex| ex return].! !!TerminationHandler methodsFor: 'private-handling' stamp: 'ar 4/7/98 16:23'!guard: aBlock with: exceptionBlock	"Evaluate aBlock such that any non-local returns through this caller will be caught. To achieve this, we replace one of the senders between a (possible) non-local return and its home context with nil. The VM will detect this and raise an ExceptionCannotReturn. Upon the occurrence of that exception we do know that somebody tried to get out of the block and can execute exceptionBlock"	| retVal |	self evaluateWithoutProtection:	["Put in a block to get around (possibly) cached thisContext in the VM"	[[brokenContext := thisContext sender.	"Break the caller chain"	actualSender := brokenContext swapSender: nil.	"Evaluate the block -- if a return through 	the broken context happens we will handle it"	retVal := aBlock value.	"Everything's fine -- restore the broken context"	brokenContext swapSender: actualSender.	actualSender := brokenContext := nil] value] value] 		on: ExceptionCannotReturn		do:[:ex|			"Somebody tried to return through the guard; 			restore the broken sender"			brokenContext swapSender: actualSender.			actualSender := brokenContext := nil.			"Remove the receiver from the handler list"			self environment removeHandler: self.			"Evaluate the guard block"			exceptionBlock value: ex.			"If no handler action was specified return the value"			self returnValue: ex returnValue from: ex context].	^retVal! !!TerminationHandler methodsFor: 'private-handling' stamp: 'ar 4/7/98 16:20'!returnValue: aValue from: originalContext	"Return aValue as if we would return from originalContext. This requires two operations:	1) Install the context we want to return to (i.e., originalContext home sender)	2) Install the originalContext in the sender chain (else we might bypass other handlers).	BTW, according to a friends opinion the following is:		''... the closest to GOTO you can get in Smalltalk I guess ;-)		
But far more sophisticated and brain twisting...''"	[[thisContext sender home swapSender: originalContext home sender.	thisContext sender swapSender: originalContext] value.	^aValue] value! !!TerminationHandler methodsFor: 'private-accessing' stamp: 'ar 4/5/98 13:37'!actualSender	^actualSender! !!TerminationHandler methodsFor: 'private-accessing' stamp: 'ar 4/5/98 13:37'!brokenContext	^brokenContext! !!TerminationHandler class methodsFor: 'private-examples' stamp: 'ar 4/8/98 22:59'!crashVM	"TerminationHandler crashVM"	"Test if the VM handles broken sender chains correctly"	(self confirm:'WARNING: The following test may crash your VM.If this happens, install the Exception-InterpreterFix.st and compile a new VM.Do you wish to continue?') ifFalse:[^false].	Transcript cr; show:'Testing broken sender chains ... '.	self crashVmWith:[^42].	^true! !!TerminationHandler class methodsFor: 'private-examples' stamp: 'ar 4/1/98 17:16'!crashVmWith: aNonLocalReturnBlock	"Break the sender chain between my sender and aNonLocalReturnBlock. Then evaluate aNonLocalReturnBlock. This should raise an ExceptionCannotReturn and not crash the VM but we have to find out somehow"	| brokenContext actualSender |	[[[brokenContext := thisContext sender.	actualSender := brokenContext swapSender: nil.	aNonLocalReturnBlock value.	] value] value	] on: ExceptionCannotReturn		do:[:ex| 			brokenContext swapSender: actualSender.			Transcript show:'ok'.			ex return]! !!TerminationHandler class methodsFor: 'private-examples' stamp: 'ar 4/1/98 00:20'!example1	"TerminationHandler example1"	| result |	result := self guardedValueWith: 42.	"Check if execution proceeds correctly"	Transcript show: 'with: ', result printString.! !!TerminationHandler class methodsFor: 'private-examples' stamp: 'ar 4/1/98 21:29'!guardedValue: aBlock	aBlock ensure:[		^Transcript cr; show:'Gotcha ... '.	].	"Check if execution proceeds correctly"	Transcript show: '*** Must not come here*** '! !!TerminationHandler class methodsFor: 'private-examples' stamp: 'ar 4/1/98 02:06'!guardedValueWith: anObject	self guardedValue:[^anObject].! !!UnhandledException commentStamp: 'ar 4/9/98 20:35' prior: 0!As my name says, I represent unhandled exceptions. If any exception occurs it can be handled by any (first chance) exception handler accepting the signaled exception. If this is not the case the signaled exception raises an instance of me to indicate that it is not handled. This gives clients an easy way to catch any (second chance) exceptions which are not handled otherwise. BTW, when I am not handled I will just raise the debugger to show where the unhandled exception took place.The tag value of my instances will contain the actual exception not handled before. That way clients can determine what exception was not handled and take the appropriate action.!!UnhandledException methodsFor: 'testing' stamp: 'ar 4/6/98 00:14'!isInterrupt	^tag isNil		ifTrue:[false]		ifFalse:[tag isInterrupt]! !!UnhandledException methodsFor: 'private-handling' stamp: 'ar 4/6/98 00:21'!defaultAction	"The default action for unhandled exceptions is to raise a debugger. However, rather than doing this manually we signal a DebugStop. This is done because the DebugStop exception is handled separately during system simulation from a debugger. This way, we stop at the exception point when running in a debugger, and, if not run from a debugger we raise a new one"	^DebugStop		signal: self messageText		with: self		from: signaler		context: initialContext! !!UnhandledException class methodsFor: 'accessing' stamp: 'ar 3/31/98 17:25'!messageText	^'Unhandled exception: '! !!UserInterrupt commentStamp: 'ar 4/9/98 20:35' prior: 0!I am an exception which is raised whenever a user hits the interrupt key. Note that I should *only* be issued by ControlManager interruptName: since my instances are expected to interrupt a running process.!!UserInterrupt class methodsFor: 'accessing' stamp: 'ar 4/5/98 20:22'!messageText	^'User interrupt'! !!UserInterrupt class methodsFor: 'testing' stamp: 'ar 4/5/98 20:22'!isResumable	^true! !!Warning methodsFor: 'handler responses' stamp: 'ar 4/7/98 21:15'!defaultAction	"Give the user a chance to react on the warning"	| menu choice |	menu := SelectionMenu selections: #('proceed' 'stop').	[choice := menu startUpWithCaption:'Warning: ', self messageText.	choice isNil] whileTrue.	^choice = 'proceed' 		ifTrue:[nil]		ifFalse:[DebugStop signal: self messageText with: tag from: signaler context: initialContext].! !!ZeroDivide methodsFor: 'accessing' stamp: 'ar 3/31/98 01:57'!dividend	^dividend! !!ZeroDivide methodsFor: 'accessing' stamp: 'ar 3/31/98 01:57'!dividend: aNumber	dividend := aNumber! !!ZeroDivide class methodsFor: 'accessing' stamp: 'ar 3/31/98 02:01'!messageText	^'Attempt to divide a number by zero'! !!ZeroDivide class methodsFor: 'testing' stamp: 'ar 3/31/98 02:01'!isResumable	^true! !!ZeroDivide class methodsFor: 'signaling' stamp: 'ar 3/31/98 01:59'!dividend: aNumber	^(self new)		dividend: aNumber;		signal! !ExceptionHandlerList initialize!