'From Squeak 1.31 of Feb 4, 1998 on 21 March 1998 at 11:17:26 pm'!"Change Set:		Behavior-WeakClassesDate:			21 March 1998Author:			Andreas RaabThis change set contains the necessary modifications for declaring a weakSubclass of any other class. A weakSubclass contains a number of fixed and indexable fields which are not traced during GC meaning that if an object is only referenced by an instance of a weak class then it will be garbage collected.Weak classes have an own format having the number 4 such that the current interpretation of the class format is now as follows:        0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields         4=      both fixed and indexable weak pointer fields (was unused before)        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bitsNOTE: Before you create any weakSubclass you have to build a new interpreter containing the Interpreter-WeakClasses changes.""Make sure we really have the necessary patches installed"(ObjectMemory canUnderstand: #isWeak:) ifFalse:[	(self confirm: 'You have not installed the Interpreter-WeakClasses change set which is required for this change set.Continue anyways?') ifFalse:[self halt].].!!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/21/98 02:36'!kindOfSubclass 	"Answer a String that is the keyword that describes the receiver's kind of 	subclass, either a regular subclass, a variableSubclass, a 	variableByteSubclass, a variableWordSubclass, or a weakSubclass"	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Behavior methodsFor: 'private' stamp: 'ar 3/21/98 02:21'!format: nInstVars variable: isVar words: isWords pointers: isPointers 	"Set the format for the receiver (a Class)."	self flag: #obsolete.	^self format: nInstVars variable: isVar words: isWords pointers: isPointers weak: false! !!Behavior methodsFor: 'private' stamp: 'ar 3/21/98 02:36'!format: nInstVars variable: isVar words: isWords pointers: isPointers  weak: isWeak	"Set the format for the receiver (a Class)."	| cClass instSpec sizeHiBits |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	format _ sizeHiBits.	format _ (format bitShift: 5) + cClass.	format _ (format bitShift: 4) + instSpec.	format _ (format bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	format _ (format bitShift: 1) "This shift plus integer bit lets wordSize work like byteSize"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/21/98 02:23'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	^self		subclassOf: newSuper 		oldClass: oldClass 		instanceVariableNames: newInstVarString 		variable: v 		words: w 		pointers: p 		weak: false		ifBad: badBlock ! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/21/98 02:37'!subclassOf: newSuper oldClass: oldClass instanceVariableNames: newInstVarString variable: v words: w pointers: p weak: beWeak ifBad: badBlock 	"Basic initialization message for creating classes using the information 	provided as arguments. Answer whether old instances will be 	invalidated."	| oldNames newNames usedNames invalid oldSuperMeta newInstVarArray oldSpec |	oldNames _ self allInstVarNames.	usedNames _ #(self super thisContext true false nil ) asSet.	newInstVarArray _ Scanner new scanFieldNames: newInstVarString.	newNames _ newSuper allInstVarNames , newInstVarArray.	newNames size > 254 ifTrue:		[self error: 'A class cannot have more than 254 instance variables'.		^ badBlock value].	newNames do: 		[:fieldName | 		(usedNames includes: fieldName)			ifTrue: 				[self error: fieldName , ' is reserved (maybe in a superclass)'.				^ badBlock value].		usedNames add: fieldName].	(invalid _ superclass ~~ newSuper)		ifTrue: 			["superclass changed"			oldSuperMeta _ superclass class.			superclass ifNotNil: [superclass removeSubclass: self].			superclass _ newSuper.			superclass addSubclass: self.			self class superclass == oldSuperMeta 				ifTrue: ["Only false when self is a metaclass"						self class superclass: newSuper class]].	instanceVariables _ newInstVarArray size = 0 ifFalse: [newInstVarArray].	invalid _ invalid | (newNames  ~= oldNames).   "field names changed"	oldSpec _ self instSpec.	self format: newNames size		variable: v		words: w		pointers: p		weak: beWeak.	invalid _ invalid | (self instSpec ~= oldSpec).  "format changed"	^invalid! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 3/21/98 02:36'!kindOfSubclass	"Answer a string that describes what kind of subclass the receiver is, i.e.,	weak, variable, variable byte, variable word, or not variable."	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Class methodsFor: 'subclass creation' stamp: 'ar 3/21/98 02:36'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	self isBits 		ifTrue: 			[^self error: 				'cannot make a pointer subclass of a class with non-pointer fields'].	^self class name: t 		inEnvironment: Smalltalk		subclassOf: self 		instanceVariableNames: f		variable: true 		words: true 		pointers: true		weak: true		classVariableNames: d 		poolDictionaries: s 		category: cat 		comment: nil		changed: false! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 3/21/98 02:24'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	^self 		name: newName 		inEnvironment: environ 		subclassOf: sup 		instanceVariableNames: instVarString 		variable: v 		words: w 		pointers: p 		weak: false		classVariableNames: classVarString 		poolDictionaries: poolString 		category: categoryName 		comment: commentString 		changed: changed ! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 3/21/98 02:38'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p weak: beWeak classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ 		changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					weak: beWeak					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | (newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	wasPresent | true		ifTrue: [Smalltalk changes changeClass: newClass]		ifFalse: [Smalltalk changes addClass: newClass].	^ newClass! !