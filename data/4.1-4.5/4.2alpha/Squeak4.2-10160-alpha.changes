'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 17 April 2010 at 5:22:05 pm'!----STARTUP----{17 April 2010 . 5:21:54 pm} as C:\Squeak\4.0\4.1-final\Squeak4.1.image!Smalltalk appendChangesTo: 'SqueakV41.sources'.!----QUIT----{17 April 2010 . 5:22:11 pm} Squeak4.1.image priorSource: 89!----STARTUP----{24 May 2010 . 8:07:26 pm} as C:\Squeak\4.2\Squeak4.1.image!----SNAPSHOT----{24 May 2010 . 8:08:14 pm} Squeak4.2.image priorSource: 229!!HashedCollection commentStamp: 'ul 4/12/2010 22:37' prior: 0!I am an abstract collection of objects that implement hash and equality in a consitent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.Instance Variables	array:		<ArrayedCollection> (typically Array or WeakArray)	tally:		<Integer> (non-negative)array	- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my "load" at 75% or less so that hashing will work well.tally	- The number of elements in the collection. The array size is always greater than this.Implementation details:I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink.!!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Collection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:33' prior: 18816249!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAll	"HashedCollection compactAll"				self allSubclassesDo: #compactAllInstances! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAllInstances	"Do not use #allInstancesDo: because compact may create new instances."	self allInstances do: #compact! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 4/7/2010 00:17' prior: 55063414!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(		5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731		17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397		35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969		70589 76091 80347 85843 90697 95791 101051 106261 111143 115777 120691 126311		140863 150523 160969 170557 181243 190717 201653 211891 221251 232591 242873 251443		282089 300869 321949 341227 362353 383681 401411 422927 443231 464951 482033 504011		562621 605779 647659 681607 723623 763307 808261 844709 886163 926623 967229 1014617		1121987 1201469 1268789 1345651 1429531 1492177 1577839 1651547 1722601 1800377 1878623 1942141 2028401		2242727 2399581 2559173 2686813 2836357 3005579 3144971 3283993 3460133 3582923 3757093 3903769 4061261		4455361 4783837 5068529 5418079 5680243 6000023 6292981 6611497 6884641 7211599 7514189 7798313 8077189		9031853 9612721 10226107 10745291 11338417 11939203 12567671 13212697 13816333 14337529 14938571 15595673 16147291		17851577 18993941 20180239 21228533 22375079 23450491 24635579 25683871 26850101 27921689 29090911 30153841 31292507 32467307		35817611 37983761 40234253 42457253 44750177 46957969 49175831 51442639 53726417 55954637 58126987 60365939 62666977 64826669		71582779 76039231 80534381 84995153 89500331 93956777 98470819 102879613 107400389 111856841 116365721 120819287 125246581 129732203		143163379 152076289 161031319 169981667 179000669 187913573 196826447 205826729 214748357 223713691 232679021 241591901 250504801 259470131		285162679 301939921 318717121 335494331 352271573 369148753 385926017 402603193 419480419 436157621 453034849 469712051 486589307 503366497 520043707 		570475349 603929813 637584271 671138659 704693081 738247541 771801929 805356457 838910803 872365267 905919671 939574117 973128521 1006682977 1040137411 		1073741833)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details.""The above primes also try to map the values of ((0 to: 4095) collect: [ :each | each << 18 \\ prime ]) sort to an equidistant sequence of numbers. This helps to avoid the collision of chains in identity-based hashed collections. To do that  they were chosen to return a low value when the following block is evaluated with them as argument: [ :prime |	| slots cost optimalDistance previous |	slots := Array new: 4097.	0 to: 4095 do: [ :ea | slots at: ea + 1 put: ea *  262144 \\ prime ].	slots at: 4097 put: prime.	slots sort.	cost := 0.	optimalDistance := prime // 4096.	2 to: 4097 do: [ :index |		| newCost |		newCost := optimalDistance - ((slots at: index) - (slots at: index - 1)).		newCost > cost ifTrue: [ cost := newCost ] ].	cost ]."! !!HashedCollection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:38' prior: 53647096!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."		anInteger < 1 ifTrue: [ ^newObject ].	^self add: newObject "I can only store an object once."	! !!HashedCollection methodsFor: 'private' stamp: 'ul 4/12/2010 22:53'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: tally * 4 // 3.	self growTo: newCapacity! !!WeakSet methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 4/13/2010 00:00' prior: 30357901!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols with 25% free space."	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable capacity.	SymbolTable compact.	^(oldSize - SymbolTable capacity) printString, ' slot(s) reclaimed'! !KeyedIdentitySet class removeSelector: #goodPrimes!WeakIdentityKeyDictionary class removeSelector: #goodPrimes!IdentitySet class removeSelector: #goodPrimes!IdentityDictionary class removeSelector: #goodPrimes!"Collections"!!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 4/7/2010 00:18' prior: 58761579!testPrimes: primes	| badPrimes |	badPrimes := #(3 5 71 139 479 5861 277421). "These primes are less than the hashMultiply constant (1664525) and 1664525 \\ prime is close to 0 (mod prime). The following snippet reproduces these numbers: 	| hashMultiplyConstant |	hashMultiplyConstant := 1 hashMultiply.	(Integer primesUpTo: hashMultiplyConstant) select: [ :each |		| remainder |		remainder := hashMultiplyConstant \\ each.		remainder <= 1 or: [ remainder + 1 = each ] ]."	self assert: primes isSorted.	primes do: [ :each |		self assert: each isPrime.		self deny: (each > 2069 and: [ badPrimes includes: each ]) ].	self assert: (		primes select: [ :p |			| result |			result := false.			p > 2069 ifTrue: [			1 to: 8 do: [ :k |				1 to: 32 do: [ :a |					(p gcd: (256 raisedTo: k) + a) = 1 ifFalse: [						result := true ].					(p gcd: (256 raisedTo: k) - a) = 1 ifFalse: [						result := true ] ] ] ].			result ]) isEmpty.! !HashedCollectionTest removeSelector: #testGoodPrimesForIdentityBasedHashedCollections!"CollectionsTests"!!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38' prior: 22938947!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39' prior: 23215403!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25' prior: 23175569!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !"Monticello"!!BlockContextTest methodsFor: 'running' stamp: 'md 9/6/2005 19:56' prior: 50431957!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BehaviorTest methodsFor: 'tests' stamp: 'md 2/18/2006 16:42' prior: 17365994!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key = nil.! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53956757!testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #EmbeddedSourceQCompress ).	self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).	code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer sourceCode: code.	self assert: (trailer kind == #EmbeddedSourceZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53957691!testEmbeddingTempNames	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer tempNames: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #TempsNamesQCompress ).	self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).		code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer tempNames: code.	self assert: (trailer kind == #TempsNamesZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:17' prior: 53958613!testEncodingNoTrailer	| trailer |		trailer := CompiledMethodTrailer new.		"by default it should be a no-trailer"		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:14' prior: 53959109!testEncodingSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.		CompiledMethod allInstancesDo: [:method | | ptr |		trailer method: method.		self assert: ( (ptr := method sourcePointer) == trailer sourcePointer).		"the last bytecode index must be at 0"		ptr ~= 0 ifTrue: [			self assert: (method endPC = trailer endPC) ].	 ].! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53959564!testEncodingVarLengthSourcePointer	| trailer newTrailer |		trailer := CompiledMethodTrailer new.		trailer sourcePointer: 1.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourcePointer = 1).		trailer sourcePointer: 16r100000000000000.	newTrailer := trailer testEncoding.	self assert: (newTrailer sourcePointer = 16r100000000000000).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53960108!testSourceByIdentifierEncoding	| trailer id |		trailer := CompiledMethodTrailer new.		id := UUID new asString.	trailer sourceIdentifier: id.		self assert: (trailer kind == #SourceByStringIdentifier ).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceByStringIdentifier ).	self assert: (trailer sourceIdentifier = id).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:49' prior: 53960643!testSourceBySelectorEncoding	| trailer |		trailer := CompiledMethodTrailer new.		trailer setSourceBySelector.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CategorizerTest methodsFor: 'running' stamp: 'mtf 9/10/2007 10:10' prior: 18074036!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074267!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:18' prior: 18074541!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074806!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:54' prior: 18075078!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:22' prior: 18075341!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 15:15' prior: 18075669!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18076194!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:55' prior: 18076430!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076673!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076950!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18077203!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 14:49' prior: 18077451!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:14' prior: 18077736!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !"KernelTests"!!SmalltalkImage methodsFor: 'accessing' stamp: 'ul 4/18/2010 22:22'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	^globals at: key ifPresentAndInMemory: aBlock! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:45'!image	"Answer the object to query about the current object memory and execution environment."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:47'!imageFormatVersion	"Answer an integer identifying the type of image. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."	"Smalltalk image imageFormatVersion"	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:38'!interpreterSourceVersion	"Answer a string corresponding to the version of the interpreter source.	This represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator, as distinct	from the external platform source code, typically written in C and managed	separately for each platform. An optional primitive is invoked that may not	be available on all virtual machines."	"Smalltalk vm interpreterSourceVersion"	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!platformSourceVersion	"Answer a string corresponding to the version of the external platform source	code, typically written in C and managed separately for each platform. This	invokes an optional primitive that may not be available on all virtual machines."	"Smalltalk vm platformSourceVersion"	<primitive: 'primitivePlatformSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitivePlatformSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'image' stamp: 'md 5/16/2006 12:34' prior: 58536670!version	"Answer the version of this release."	^SystemVersion current version! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!versionLabel	"Answer a string corresponding to the version of virtual machine. This	represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator,  in	addition to the external platform source code, typically written in C and	managed separately for each platform.		This invokes an optional primitive that may not be available on all virtual	machines. See also vmVersion, which answers a string identifying the image	from which virtual machine sources were generated."	"Smalltalk vm versionLabel"	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:15'!vm	"Answer the object to query about virtual machine."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 1/4/2010 21:40' prior: 58537225!wordSize	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."	"Smalltalk wordSize"	^ WordSize ifNil: [WordSize := [SmalltalkImage current vmParameterAt: 40] on: Error do: [4]]! !"System"!!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderCategoricalPlus commentStamp: 'btr 12/4/2006 15:47' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategoricalPlus open!!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 27913009!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:50'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: builder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:55'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)));				add: ((self buildPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide));				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1)); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:55'!defaultLabel	^ 'Categorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18'!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);		name: #buttonBar;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 name: #categoriesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; name: #packagePane; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 name: #packagesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; name: #search; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:54'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new						add: ((self buildButtonBarWith: builder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight));						add: ((self buildSearchPaneWith: builder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2)));						add: ((self buildPackagesListWith: builder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide));						add: ((self buildCategoriesListWith: builder)							frame: (0 @ vertDivide corner: horizDivide @ 1));						add: ((self buildPackagePaneWith: builder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 05:28'!initialExtent	^500@400! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25' prior: 27998626!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54' prior: 27998778!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58' prior: 27998902!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25' prior: 27999070!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22' prior: 27999192!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849043!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53' prior: 27849195!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35' prior: 27849301!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02' prior: 27849402!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849700!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30' prior: 27997393!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 27944626!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 27945298!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08' prior: 54331069!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15' prior: 27927912!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04' prior: 27928394!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22' prior: 27929139!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05' prior: 27929686!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08' prior: 27930070!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11' prior: 27936393!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 27933585!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 27913226!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30' prior: 27930584!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14' prior: 27931214!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14' prior: 27917579!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14' prior: 27923782!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27' prior: 27918212!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions := self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05' prior: 27937041!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48' prior: 27931447!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13' prior: 27918874!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'actions' stamp: 'mist 8/17/2005 13:56'!installPackageWithDependents: package	| myRelease |	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		package installWithDependencies.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17' prior: 27932588!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 27934165!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30' prior: 27937451!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56' prior: 27913703!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43' prior: 27932888!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 27941030!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17' prior: 27913904!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51' prior: 27914233!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13' prior: 27914590!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10' prior: 27941340!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02' prior: 27935346!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03' prior: 27921197!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03' prior: 27941568!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!defaultLabel	^ 'SqueakMap Categorical Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !SMLoader removeSelector: #paneColorOld!SMLoader removeSelector: #addPackagesTo:at:plus:!"SMLoader"!!HashedCollectionIntegrityTest methodsFor: 'as yet unclassified' stamp: 'ul 4/13/2010 00:19'!testCapacity	| inconsistentCollections |	inconsistentCollections := HashedCollection allSubInstances reject: [ :each |		each class == MethodDictionary "MethodDictionary is the only HashedCollection which doesn't have prime array size"			ifTrue: [ each capacity isPowerOfTwo ]			ifFalse: [ each capacity isPrime ] ].	self assert: inconsistentCollections isEmpty! !"Tests"!HashedCollection class removeSelector: #goodPrimesForIdentityBasedHashedCollections!"Collections"!!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50' prior: 33397485!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !"Compression"!!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07' prior: 23076302!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !"Monticello"!!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:48' prior: 58240485!compactAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #compactWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:49' prior: 55067225!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #rehashWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:04'!compact	"Make sure that I have the highest possible load factor (at least 50%)."		self become: self compactWithoutBecome! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:05'!compactWithoutBecome	"Return a copy of self which has the highest possible load factor (at least 50%)."		| newSelf |	newSelf := self class new: self size.	self keysAndValuesDo: [ :key :value |		newSelf at: key put: value ].	^newSelf! !!Duration class methodsFor: 'squeak protocol' stamp: 'ul 4/28/2010 09:44' prior: 59189810!milliSeconds: milliCount 		^self		seconds: (milliCount quo: 1000)		nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53' prior: 54905196!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!CompiledMethod methodsFor: 'decompiling' stamp: 'hmm 4/16/2010 10:48' prior: 50758861!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48' prior: 53338498!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[significand ~= 16r10000000000000				ifTrue:					[r := significand bitShift: 1 + exp.					s := 2.					mPlus := mMinus := 1 bitShift: exp]				ifFalse:					[r := significand bitShift: 2 + exp.					s := 4.					mPlus := 2 * (mMinus := 1 bitShift: exp)]]		ifFalse:			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])				ifTrue:					[r := significand bitShift: 1.					s := 1 bitShift: 1 - exp.					mPlus := mMinus := 1]				ifFalse:					[r := significand bitShift: 2.					s := 1 bitShift: 2 - exp.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	slowbit := 1 - s lowBit .	shead := s bitShift: slowbit.	[d := (r bitShift: slowbit) // shead.	r := r - (d * s).	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:32' prior: 51138013!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/28/2010 12:29' prior: 54648421!compress	"Compact the method dictionary of the receiver."	self methodDict compact! !MethodDictionary removeSelector: #compactCopyFrom:!"Kernel"!!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!BlockNode commentStamp: '<historical>' prior: 59231160!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51562187!accept: aVisitor	^aVisitor visitLiteralNode: self! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52462316!accept: aVisitor	^aVisitor visitSelectorNode: self! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 53106854!accept: aVisitor	^aVisitor visitVariableNode: self! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51430081!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51111193!accept: aVisitor	^aVisitor visitFieldNode: self! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 33548097!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52334181!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51566588!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51916378!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50736685!accept: aVisitor	^aVisitor visitCommentNode: self! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50569061!accept: aVisitor	^aVisitor visitCascadeNode: self! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50443783!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23' prior: 50444587!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:05' prior: 17572883!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForBlockValue: stack on: aStream.! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:04' prior: 17574191!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForBlockValue: encoder)! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 52065009!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:57'!emitForBlockValue: stack on: aStream	"Generate code for evaluating the last statement in a block"	^self emitForValue: stack on: aStream! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:56'!sizeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeForValue: encoder! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51659869!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33' prior: 51636522!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32' prior: 51668475!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51637527!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51658193!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51642266!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51676424!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51679950!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51630388!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51678537!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51632638!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31' prior: 51669258!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17' prior: 51635034!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 52349447!accept: aVisitor	^aVisitor visitReturnNode: self! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51730971!accept: aVisitor	^aVisitor visitMethodNode: self! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50521748!accept: aVisitor	^aVisitor visitBraceNode: self! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52840973!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!Encoder methodsFor: 'encoding' stamp: 'eem 9/3/2009 10:50' prior: 50998649!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode := self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !BlockNode removeSelector: #noteOptimized!"Compiler"!!StandardViewer methodsFor: 'initialization' stamp: 'ar 4/23/2010 16:53' prior: 29917444!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer isPlayerLike and: [scriptedPlayer costume isMemberOf: KedamaMorph]) ifTrue: [self addCategoryViewer].		].! !"EToys"!!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:13' prior: 57366653!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:14' prior: 53809967!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !"Files"!!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 4/28/2010 11:22' prior: 52007447!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * form width * bitsPerChannel // 32 + 1.	bits := form bits.	0 to: thisScanline size - 1 // 4 do: [ :i |		| ii word |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].			"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'jmv 4/15/2010 10:19' prior: 52000090!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^  palette		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jmv 4/15/2010 10:18' prior: 52016987!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		palette at: transparentPixelValue put: Color transparent.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !"Graphics"!!RectangleTest methodsFor: 'tests' stamp: 'wiz 4/29/2010 02:10'!testRoundingAfterHalfPixelTranslation	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| trouble noTrouble |	trouble := 10 negated asPoint rect: 10 asPoint.	noTrouble := trouble translateBy: 15.		10 timesRepeat: [trouble := (trouble translateBy: 0.5) rounded].	10 timesRepeat: [noTrouble := (noTrouble translateBy: 0.5) rounded].		self assert: trouble extent = noTrouble extent! !"GraphicsTests"!!DurationTest methodsFor: 'testing' stamp: 'ul 4/28/2010 09:57' prior: 19913678!testMilliSeconds	#(		"argument (milliseconds)	seconds	nanoseconds"		(5							0			5000000)		(1005						1			5000000)		(-5							0			-5000000)		(-1005						-1			-5000000)		(1234567					1234		567000000)		(-1234567					-1234		-567000000)			) do: [ :each |		| duration |		duration := Duration milliSeconds: each first.		self assert: duration asSeconds = each second.		self assert: duration nanoSeconds = each third ]! !"KernelTests"!!ObjectFinalizer commentStamp: 'jcg 4/27/2010 01:01' prior: 0!Represents an action that is to be taken when a target object (not referenced by the ObjectFinalizer) is garbage-collected.!!CodeLoader commentStamp: 'hjh 4/22/2010 12:58' prior: 59244840!CodeLoader provides a simple facility for loading code from the network.CodeLoader has a very specific purpose, primarily for loading Etoys projects. It is not meant to be used for anything else. Use Installer for general purposes.Examples:	| loader |	loader := CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 4/28/2010 11:38'!keyAtValue: value	"Answer the key that is the external name for the argument, value. If	there is none, answer nil."	self deprecated: 'Use Smalltalk globals'.	^globals keyAtValue: value! !!ProjectLoading class methodsFor: 'loading' stamp: 'ul 4/28/2010 12:35' prior: 55884567!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!Preferences class methodsFor: 'standard queries' stamp: 'sbw 4/24/2010 10:16' prior: 0!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!browserWindowColor	^ self		valueOfFlag: #browserWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeListWindowColor	^ self		valueOfFlag: #changeListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeSorterWindowColor	^ self		valueOfFlag: #changeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!classCommentVersionsBrowserWindowColor	^ self		valueOfFlag: #classCommentVersionsBrowserWindowColor		ifAbsent: [Color				r: 0.769				g: 0.653				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!debuggerWindowColor	^ self		valueOfFlag: #debuggerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.8]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!defaultWindowColor	^ self		valueOfFlag: #defaultWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!dualChangeSorterWindowColor	^ self		valueOfFlag: #dualChangeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileContentsBrowserWindowColor	^ self		valueOfFlag: #fileContentsBrowserWindowColor		ifAbsent: [Color				r: 0.8				g: 0.8				b: 0.5]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileListWindowColor	^ self		valueOfFlag: #fileListWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 1.0]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22' prior: 59046404!installUniformWindowColors	"Install the factory-provided uniform window colors for all tools"	"Preferences installUniformWindowColors"	self installWindowColorsVia: [:aQuad | self uniformWindowColor]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!instanceBrowserWindowColor	^ self		valueOfFlag: #instanceBrowserWindowColor		ifAbsent: [Color				r: 0.806				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!lexiconWindowColor	^ self		valueOfFlag: #lexiconWindowColor		ifAbsent: [Color				r: 0.878				g: 1.0				b: 0.878]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageListWindowColor	^ self		valueOfFlag: #messageListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageNamesWindowColor	^ self		valueOfFlag: #messageNamesWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 0.452]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!methodFinderWindowColor	^ self		valueOfFlag: #methodFinderWindowColor		ifAbsent: [Color				r: 0.4				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!monticelloToolWindowColor	^ self		valueOfFlag: #monticelloToolWindowColor		ifAbsent: [Color				r: 0.627				g: 0.69				b: 0.976]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageBrowserWindowColor	^ self		valueOfFlag: #packageBrowserWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageLoaderWindowColor	^ self		valueOfFlag: #packageLoaderWindowColor		ifAbsent: [Color				r: 0.9				g: 0.9				b: 0.781]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!preferenceBrowserWindowColor	^ self		valueOfFlag: #preferenceBrowserWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!testRunnerWindowColor	^ self		valueOfFlag: #testRunnerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.6				b: 0.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!transcriptWindowColor	^ self		valueOfFlag: #transcriptWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.4]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!uniformWindowColor	^Color veryVeryLightGray! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!versionsBrowserWindowColor	^ self		valueOfFlag: #versionsBrowserWindowColor		ifAbsent: [Color				r: 0.869				g: 0.753				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!workspaceWindowColor	^ self		valueOfFlag: #workspaceWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.8]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:32' prior: 51385600!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: #rehash. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:33' prior: 51365564!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: #rehash.	"our purpose"	^ receiverClasses	"our secondary job"! !!SystemDictionary methodsFor: 'compatibility' stamp: 'ul 4/28/2010 11:45'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	self deprecated: 'Use Smalltalk'.	^Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: aBlock! !"System"!!Editor commentStamp: '<historical>' prior: 59290227!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor. This class is no longer a Controller!!SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like most cell phones do.!!TheWorldMainDockingBar methodsFor: 'private' stamp: 'laza 4/26/2010 10:31' prior: 53724739!colorIcon: aColor	"Guess if 'uniform window colors' are used and avoid all icons to be just gray"	(aColor = Preferences uniformWindowColor or: [Preferences tinyDisplay]) ifTrue: [ ^nil ].	^(aColor iconOrThumbnailOfSize: 14)		borderWidth: 3 color: Preferences menuColor muchDarker;		borderWidth: 2 color: Color transparent! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 4/26/2010 12:23'!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''Morphic-Kernel'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."HelpSystem: http://www.squeaksource.com/HelpSystem.html"(Installer squeaksource project: ''HelpSystem'')	install: ''HelpSystem-Core'';	install: ''HelpSystem-Tests'';	install: ''Metacello-Help'';	install: ''Pharo-Project-Help'';	install: ''Squeak-Project-Help''.(Smalltalk at: #HelpBrowser) open."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(194 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 12 1 8 1 12 3 8 1 17 3 8 1 18 3 8 1 16 3 8 1 20 3 8 1 21 13 3 1 12 2 4 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mha 5/2/2010 16:00' prior: 59194233!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk at: #HelpBrowser) ifNotNil: [					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: (Smalltalk at: #HelpBrowser);							selector: #open ] ].			]].! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 4/26/2010 10:57' prior: 58412388!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each model defaultBackgroundColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'hjh 4/21/2010 18:40' prior: 59197577!showWelcomeText: aSelector label: labelString in: bounds	"Show a welcome text. Linked in here so that the text can be edited	by changing the acceptBlock below."	| acceptBlock window |	"Change the following to allow editing the text"	true ifTrue:[		acceptBlock := [:text|			self class				compile: aSelector,'	^', (String streamContents:[:s| s nextChunkPutWithStyle: text]) storeString, ' readStream nextChunkText'				classified: (self class organization categoryOfElement: aSelector).		].	].	window := UIManager default 		edit: (self perform: aSelector)		label: labelString		accept: acceptBlock.	window bounds: bounds.! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/19/2010 20:58'!blinkingCursor	<preference: 'Blinking Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor will blink.'		type: #Boolean>	^ BlinkingCursor ifNil: [ true ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 15:57'!blinkingCursor: aBoolean	BlinkingCursor := aBoolean! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor	<preference: 'Dumbbell-shaped Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor assumes the shape of a dumbbell, otherwise a vertical bar..'		type: #Boolean>	^ DumbbellCursor ifNil: [ false ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor: aBoolean	DumbbellCursor := aBoolean! !!TextMorph methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52937182!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			Editor blinkingCursor ifTrue: [ self startBlinking ].	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!LazyListMorph methodsFor: 'drawing' stamp: 'mha 4/27/2010 09:33' prior: 59214813!drawBackgroundForMulti: row on: aCanvas 	"shade the background paler, if this row is selected, but not the current selected row"	| selectionDrawBounds thisColor |	thisColor := selectedRow = row		ifTrue: [ self class listSelectionColor twiceDarker ]		ifFalse: [ self class listSelectionColor ].	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: thisColor! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:38' prior: 58964342!bottomBoundary	"Answert the bottommost x position the receiver could be moved."	| splitter morphs |	splitter := self splitterBelow.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect bottom]				ifFalse: [owner innerBounds bottom]]		ifNotNil: [splitter top])		- (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:37' prior: 58961894!topBoundary	"Answer the topmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterAbove.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect top]				ifFalse: [owner innerBounds top]]		ifNotNil: [splitter bottom])		+ (self minimumHeightOf: morphs)! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'tfel 4/16/2010 09:34' prior: 58988661!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self class roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52961433!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		Editor blinkingCursor ifTrue: [self startBlinking].	] ifFalse:[		self stopBlinking.	].	self changed.! !!NewParagraph methodsFor: 'access' stamp: 'cmm 4/5/2010 16:24' prior: 51924537!caretWidth	^ Editor dumbbellCursor		ifTrue: [ 2 ]		ifFalse: [ 0 ]! !!SmalltalkEditor methodsFor: 'private' stamp: 'cmm 4/4/2010 20:41' prior: 58007098!methodArgument: anInteger 	^ (ReadStream on: self text asString) nextLine		ifNil: [ String empty ]		ifNotNilDo:			[ : line | 			line substrings				at: 2 * anInteger				ifAbsent: [ String empty ] ]! !"Morphic"!!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08' prior: 57724509!basicUpTo: delim	^ super upTo: delim.! !"Multilingual"!!TestURI methodsFor: 'running file' stamp: 'ar 4/12/2010 21:38'!testDirWithHash	"Tests proper escaping of directories with hash mark"	| uriDir origPath origDir dirURI |	origPath := FileDirectory default pathName, '#123'.	origDir := FileDirectory on: origPath.	self assert: origDir pathName = origPath.	dirURI := origDir uri.	uriDir := FileDirectory uri: dirURI.	self assert: origDir fullName = uriDir fullName.! !"NetworkTests"!!PackageInfo methodsFor: 'testing' stamp: 'bf 4/19/2010 02:54' prior: 54301517!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !"PackageInfo-Base"!!String methodsFor: '*sound-synthesis' stamp: 'wiz 4/28/2010 16:01'!asSound	"Return a sound. Either from the sound library via SampleSound or	else the Beeper default"	^ SampledSound		soundNamed: self		ifAbsent: [Beeper default]! !"Sound"!!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ul 5/2/2010 12:32' prior: 24591721!findWindowInWorldLabeled: aLabel	^World submorphs		detect: [ :each |			(each isKindOf: SystemWindow)				and: [ each label = aLabel ] ]		ifNone: nil.! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'jcg 4/15/2010 16:27'!testFileTruncation	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file |	file := nil.	[			file := FileDirectory default forceNewFileNamed: 'TruncationTest.txt'.		file nextPutAll: '1234567890'.	] ensure: [file close].	[		file := FileDirectory default oldFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234567890'].		file truncate: 4.	] ensure: [file close].	[		file := FileDirectory default readOnlyFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234'].	] ensure: [		file close.		FileDirectory default deleteFileNamed: file name ifAbsent:[]	].! !"Tests"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 5/2/2010 12:34' prior: 59218373!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 59304739!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 4/21/2010 21:23'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:47' prior: 51626697!buildSearchPaneWith: builder	| buttonFrame buttonSpec textFrame textSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttonFrame := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.3 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	textFrame := LayoutFrame new		leftFraction: 0.3 offset: 1;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec 		model: self;		label: 'Search';		action: [self doSearchFrom: searchPane];		frame: buttonFrame.	top children add: buttonSpec.		textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		name: #search;		getText: #searchString; 		setText: #searchString:notifying:;		frame: textFrame.	top children add: textSpec.	^top! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/23/2010 10:29' prior: 51627142!buildWith: builder	"ToolBuilder open: MessageNames new"	| searchPaneHeight windowSpec max result |	searchPaneHeight := self buttonHeight.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(self topConstantHeightFrame: searchPaneHeight fromLeft: 0 width: 0.5) -> [self buildSearchPaneWith: builder].		(self selectorListFrame: max fromTop: searchPaneHeight) -> [self buildSelectorListWith: builder].		(0.5@0.0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	searchPane := builder widgetAt: #search.	^result! !!MessageNames methodsFor: 'class list' stamp: 'fbs 3/31/2010 22:46'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex > 0 ifTrue: [		^ self setClassAndSelectorIn: [:c :s | ^c]].	(selectorListIndex isNil not and: [selectorListIndex > 0]) ifTrue: [^Smalltalk classNamed: (self selectorList at: selectorListIndex)].		^ nil.	! !!MessageNames methodsFor: 'selection' stamp: 'fbs 3/31/2010 16:31' prior: 23706644!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageListIndex = 0		ifTrue: [self selectorList at: selectorListIndex ifAbsent: [nil]]		ifFalse: [self messageList at: messageListIndex ifAbsent: [nil]].! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:44'!selectorListFrame: max fromTop: topOffset	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: topOffset;		rightFraction: 0.5 offset: 0;		bottomFraction: max offset: 0.! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:58'!availableGraphicsExtent	self dependents do: [:each |		((each isKindOf: PluggableTextMorph) and: [each getTextSelector == #contents]) ifTrue: [^each innerBounds extent - (6@22)]].	^nil! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 12:47' prior: 57782322!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #graphic ifTrue: [^ contents].	brevityState == #needToGetGraphic ifTrue: [^self readGraphicContents].		brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'file list menu' stamp: 'cao 4/26/2010 09:36' prior: 57911104!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines |	shifted ifTrue:		[^ aMenu addList: StringHolder shiftedYellowButtonMenuItems].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'file list' stamp: 'hmm 4/27/2010 13:09' prior: 57786840!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 13:08'!isGraphicsFileSelected	^fileName notNil and: [((self itemsForFile: self fullName) detect: [:each | each provider == Form and: [each selector == #importImage:]] ifNone: []) notNil]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 20:45'!readGraphicContents	| form maxExtent ext |	form := Form fromFileNamed: self fullName.	maxExtent := lastGraphicsExtent := self availableGraphicsExtent.	ext := form extent.	(maxExtent notNil and: [form extent <= maxExtent]) ifFalse: [		form := form magnify: form boundingBox by: (maxExtent x / form width min: maxExtent y / form height) asPoint smoothing: 3].	contents :=  ('Image extent: ', ext printString) asText,				(String with: Character cr),				(Text string: ' '					attribute: (TextFontReference toFont: 						(FormSetFont new							fromFormArray: (Array with: form)							asciiStart: Character space asInteger							ascent: form height))).	brevityState := #graphic.	^contents! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:02'!step	| ext |	brevityState = #graphic ifTrue: [		ext := self availableGraphicsExtent.		ext = lastGraphicsExtent ifFalse: [			lastGraphicsExtent := ext.			brevityState := #needToGetGraphic.			self changed: #contents]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:03'!stepTimeIn: aWindow	^500! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:56'!wantsSteps	^true! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:29' prior: 50538558!buildClassListSingletonWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classListSingleton; 		getIndex: #indexIsOne; 		setIndex: #indexIsOne:; 		menu: #classListMenu:shifted; 		keyPress: #classListKey:from:.	^listSpec! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:30' prior: 50530267!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:shifted:; 		keyPress: #classListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromClassList:].	^listSpec! !!Browser methodsFor: 'class functions' stamp: 'cmm 4/23/2010 17:03' prior: 54374919!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass |	(aClass := self selectedClassOrMetaClass) ifNotNil:		[aClass instVarNames do: 			[:aName |				| newMessage setter |				(aClass canUnderstand: aName asSymbol)					ifFalse:						[newMessage := aName, '	^', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter := aName, ':') asSymbol)					ifFalse:						[newMessage := setter, ' anObject	', aName, ' := anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:53'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 15:50' prior: 50535675!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0 width: 0.5 bottomFraction: max) -> [self buildMessageCategoryListWith: builder].		(self topConstantHeightFrame: self buttonHeight fromLeft: 0.5 width: 0.5) -> [self buildSwitchesWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0.5 width: 0.5 bottomFraction: max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:52'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !"Tools"!!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:07'!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner prefAllowUnderscoreAssignments]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:04'!allowUnderscoreSelectors	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreSelectors])		ifNil: [Scanner prefAllowUnderscoreSelectors]! !!SHParserST80 methodsFor: 'token testing' stamp: 'laza 4/28/2010 17:51' prior: 52377778!isAssignment	^self isAnsiAssignment or: [self allowUnderscoreAssignments and: [currentToken = '_']]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:15' prior: 52364496!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: $ ! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52371083!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges		ifNil: [ranges := OrderedCollection new: 100]		ifNotNil: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52383846!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[(Symbol lookup: binary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil)						ifNil: [#undefinedBinary]						ifNotNil:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 54459800!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[(Symbol lookup: keyword) notNil])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil)					ifNil: [#undefinedKeyword]					ifNotNil:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 22:50' prior: 52379595!parsePrimitive	self scanNext.	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: [			currentTokenFirst == $'				ifTrue: [ self parseString ]				ifFalse: [					currentTokenFirst == $#						ifTrue: [ self parseSymbol ]						ifFalse: [ self error ] ].			currentToken = 'module:' 				ifTrue: [					self scanPast: #module.					currentTokenFirst == $'						ifTrue: [ self parseString ]						ifFalse: [							currentTokenFirst == $#								ifTrue: [ self parseSymbol ]								ifFalse: [ self error ] ] ] ].	self failUnless: currentTokenFirst == $>.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:24' prior: 52389009!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar)		ifNil: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c == $' 			ifFalse: [answer := answer copyWith: c. true] 		ifTrue: [false]	) or: [		self peekChar == $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'laza 4/29/2010 16:18' prior: 52362002!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]] whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52378939!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~~ $' or: [		self peekChar == $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52387010!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[(Symbol lookup: unary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil)						ifNil: [#undefinedUnary]						ifNotNil:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 19:29' prior: 52385928!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric or: [c == $_ and: [self allowUnderscoreSelectors]]] whileTrue.	(c == $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:27' prior: 52374752!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	currentTokenFirst isLetter ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHTextStyler methodsFor: 'private' stamp: 'ul 4/28/2010 20:27' prior: 52391465!monitor	^monitor ifNil: [monitor := Monitor new]! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreAssignments	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreSelectors	^nil! !"ShoutCore"!!HelpTopicListItemWrapper commentStamp: 'tbn 3/8/2010 09:30' prior: 0!This class implements a list item wrapper for help topics.Instance Variables!!CustomHelp commentStamp: 'tbn 3/29/2010 13:23' prior: 0!This is a common superclass for custom help. Subclasses of this class are automatically included into the system help.By default the informations provided on the receiver class are converted into help topics by a specific builder - here the CustomHelpHelpBuilder. Note that you can provide an own custom builder by overriding the #builder method!!HelpOnHelp commentStamp: 'tbn 2/12/2010 14:27' prior: 0!Welcome to Pharo Smalltalk Help System!!HelpAPIDocumentation commentStamp: 'tbn 4/30/2010 15:12' prior: 0!This class represents the browsable package API help for the help system.Instance Variables!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 0!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBuilder commentStamp: 'tbn 2/12/2010 14:54' prior: 0!This is an utility class that builds the books for a help system.Instance Variables	rootTopics:		<OrderedCollection>rootTopics	- a collection of books !!ClassAPIHelpBuilder commentStamp: 'tbn 4/30/2010 15:37' prior: 0!A builder to build the API Help for a classInstance Variables	addMethods:		<Boolean>	addSubclasses:		<Boolean>	subclassesAsSeparateTopic:		<Boolean>addMethods	- When true the builder will include method helpaddSubclasses	- When true the builder will recursively go through and add subclassessubclassesAsSeparateTopic	- xxxxx!!CustomHelpHelpBuilder commentStamp: 'tbn 3/29/2010 13:30' prior: 0!This builder builds help topics from a help topic description (which is typically storedin a class). The help topic description object has to understand the following messages:  #bookName - should return the name of the help book  #icon - should return the icon of the help book  #key - should return a unique key to identify the book  #pages - should return an array of method selectors to call to get the books pages!!HelpIcons commentStamp: 'tbn 3/8/2010 09:29' prior: 0!This class is used to store help icons for the help browser. Typically one implements a method returning a 12x12 Form instance whichshould not be called directly.Since the class provides an internal icon cache (so the icons can be reused without creating too many new instances) the icons should be accessed using the #iconNamed: message with the method selector as argument.To create a form from an icon file stored on disk you can use the following code:   | image stream |	image := ColorForm fromFileNamed: '/path/to/icon.png'.	stream := WriteStream with: String new.	image storeOn: stream.	stream contents inspect.!!HelpTopic commentStamp: 'tbn 3/29/2010 14:53' prior: 0!A HelpTopic provides content information that can be used as a help to the user.It can be labeled with a title, identified using an (optional) unique key and marked with an (optional) icon.Help topics form a hierarchy since any topic is able to have zero or moresubtopics. Instance Variables	contents:		<Object>      The help topic contents	icon:			<Form|nil>	   An optional icon for the topic	key:			<String|nil>    An optional unique key	subtopics:	      <Collection>  A collection of subtopics	title:			<String>        The titlecontents	- The help topic contents - typically containing the help topics informationicon	- An optional icon for the topickey	- An optional unique key which can be used to identify the topic. subtopics	- A collection of subtopics. 	  By default the subtopics are not sorted, so the insertion order is used. 	  If necessary it is possible to sort the subtopics by title.title	- A meaninful title for the help topic!!SystemHelp commentStamp: 'tbn 4/30/2010 15:33' prior: 0!This class defines Help for the system in front of you.It defines the default contents when you open a help browser.So "HelpBrowser open" is the same as "HelpBrowser openOn: SystemHelp".!!SystemReference commentStamp: 'tbn 4/30/2010 15:35' prior: 0!This class defines the full reference help for the system.(contents for the full API Help).Just run "HelpBrowser openOn: SystemReference".!!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:25'!asString	"Returns a string used as a label"		^item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!balloonText	"Returns a string used for fly by help"		^self item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!contents	"Returns subnodes (if any)"	 	item hasSubtopics ifFalse: [^#()].		^(item subtopics) collect: [ :each | 		HelpTopicListItemWrapper with: each	].! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:27'!highlightingColor	"Returns the text color when the receiver is selected in a list."	^Color blue  ! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:55'!icon	"Either return the icon for the given topic"		| symbol |	item icon notNil ifTrue: [^item icon].	symbol := item hasSubtopics 					 ifTrue: [#bookIcon] 			  		 ifFalse: [#pageIcon].	^HelpIcons iconNamed: symbol! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:26'!accept: aSelector title: title contents: text	"Accept edited text. Compile it into a HelpTopic"	| code |	code := String streamContents:[:s|		s nextPutAll: aSelector.		s crtab; nextPutAll: '"This method was automatically generated. Edit it using:"'.		s crtab; nextPutAll: '"', self name,' edit: ', aSelector storeString,'"'.		s crtab; nextPutAll: '^HelpTopic'.		s crtab: 2; nextPutAll: 'title: ', title storeString.		s crtab: 2; nextPutAll: 'contents: '.		s cr; nextPutAll: (String streamContents:[:c| c nextChunkPutWithStyle: text]) storeString.		s nextPutAll:' readStream nextChunkText'.	].	self class 		compile: code		classified: ((self class organization categoryOfElement: aSelector) ifNil:['pages']).! !!CustomHelp class methodsFor: 'converting' stamp: 'tbn 3/29/2010 13:17'!asHelpTopic	"Convert the receiver to a help topic"		^self builder buildHelpTopicFrom: self! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!bookName	"Returns the name of the custom help book"		^'Help'! !!CustomHelp class methodsFor: 'defaults' stamp: 'tbn 3/29/2010 13:24'!builder	"Returns the builder that is used to build the given help book from the receiver. You can override this method	 in a subclass to provide an own builder".		^CustomHelpHelpBuilder! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:24'!edit: aSelector	"Open a Workspace on the text in the given selector.	When accepted, compile the result as a help topic."	| topic window |	topic := (self respondsTo: aSelector) 			ifTrue:[self perform: aSelector]			ifFalse:[HelpTopic title: 'Untitled' contents: 'Please edit this topic. To change the topic title, edit the window label.'].	window := UIManager default		edit: topic contents		label: topic title		accept: [:text| self accept: aSelector title: window label contents: text].! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!icon	"Returns an icon used for displaying the custom help book"		^HelpIcons iconNamed: #bookIcon! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:18'!key	"Returns a unique key identifying the receiver in the help system"		^''! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!pages 	"Returns a collection of method selectors to return the pages of the custom help book"			^#()! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:50'!bookName	^'API Documentation'! !!HelpAPIDocumentation class methodsFor: 'defaults' stamp: 'tbn 3/11/2010 23:57'!builder	^PackageAPIHelpBuilder! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/11/2010 23:55'!packages	^#('HelpSystem-Core-Model' 'HelpSystem-Core-Utilities' 'HelpSystem-Core-UI')! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:47'!bookName	^'Implementation'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:59'!overview	^HelpTopic 		title: 'Overview'		contents:		'THE IMPLEMENTATIONThe help system typically consists of help books including one or more pages. A book or page is therefore a "topic of interest"  providing contents for help to a user. A topic has a title and an icon and is able to have subtopics forming a hierarchy of topics. This simple model is reflected in the class HelpTopic.Since this model forms a hierarchical structure of help topics there is a browser with a tree to display the help contents. This browser is implemented in class HelpBrowser.You can open this browser programmatically using:   HelpBrowser open' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page1	^HelpTopic 		title: '1. Simple help topics'		contents: 'The help browser usually operates on a hierarchy of help topics with one help topic at the root level. Evaluate the following expression in a workspace to contruct a simple help topic and open it as a root topic in the help browser.				|root|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.									HelpBrowser openOn: root				Note that the help browser displays the contents of our topic in the right page and uses the topics title as the title for the help browser window.			'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page2	^HelpTopic 		title: '2. Forming a hierarchy'		contents: 'To form a hierarchy we just have to add new subtopics on our root topic.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 			title: ''My second subtopic''			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:10'!page3	^HelpTopic 		title: '3. Adding icons'		contents: 'If you dont like the default icon you can add own custom icons to the topics. See the class HelpIcons for more details.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 		     			title: ''My second subtopic''			 icon: (HelpIcons iconNamed: #packageIcon)			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 15:01'!page4	^HelpTopic 		title: '4. Own help objects'		contents:		'You can open this help browser directly on an instance of HelpTopic, but it is more common to open it on any object that understands the message #asHelpTopic.So you can write for instance:   HelpBrowser openOn: Integeropening a short API help/system reference on the Integer class.The above expression is the short form for:   HelpBrowser openOn: (SystemReference forClass: Integer)If you want you can include the subclasses:   HelpBrowser openOn: (SystemReference hierarchyFor: Integer)or even methods   HelpBrowser openOn: (SystemReference hierarchyWithMethodsFor: Integer)You can browse the whole system reference documentation using:    HelpBrowser openOn: SystemReferenceBut these are only a few examples what we can extract from the system. However - the major goal is NOT an API browser, the idea is to provide a simple architecture to provide browsable help contents depending on the context. For instance it should also be possibleto use the help system to provide end user help on any commercialapplication that is written with the Smalltalk system.' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 19:23'!page5	^HelpTopic 		title: '5. Help sources'		contents:		'Since the underlying model is very simple you can easily fill it with nearly any information from different sources. Try this:|topic day url sub|topic := HelpTopic named: ''Last week on Squeak IRC''.0 to: 7 do: [:index |	day := (Date today subtractDays: index) printFormat: #(3 2 1 $. 1 2 2).	url := ''http://tunes.org/~nef/logs/squeak/'' , day.	sub := HelpTopic 			title: day contents: (HTTPLoader default retrieveContentsFor: url) contents.	topic addSubtopic: sub.].HelpBrowser openOn: topic  ' ! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 19:21'!pages	^#(overview page1 page2 page3 page4 page5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:06'!bookName	^'Custom help from code'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:52'!overview	^HelpTopic		title: 'Overview'		contents:		'OVERVIEW	The help system allows you to provide own books and help texts. You can open the help browser on any object that is able to understand #asHelpTopic.This method returns the root node of the displayed topic hierarchy:      HelpBrowser openOn: myObjectTypically the object does not convert itself to a help topic structure, usually it dispatches to a builder (see HelpBuilder and subclasses) who does all this. 	A much more convenient and reproducable way is to implement custom help classes. This allows you to implement and manage your help texts using the standard development and code management tools. These custom help classes are subclasses of "CustomHelp" and are automatically included into the standard help browser. '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 23:57'!pages	^#(overview step1 step2 step3 step4 step5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step1	^HelpTopic 		title: 'Step 1 - Create a class for the book'		contents:		'STEP 1 - CREATE A CLASS FOR THE BOOK		There is a predefined class CustomHelp which you have to subclass for a custom help book to show up as a book in the Help browser:	  CustomHelp subclass: #MyAppHelp    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' Class methods on this class can reflect pages and if you want to provide nested help books just subclass your own help class to form a hierarchy. Any new subclass of MyAppHelp will then be a new book in your hierarchy.The class category used should end with "-Help" so it is easy to recognize that it includes the help support of your project.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step2	^HelpTopic		title: 'Step 2 - Provide a book name'		contents:	'STEP 2 - PROVIDE A BOOK NAME	Now implement the class method #bookName to return the name of your help book.   bookName	    ^''My App help''	By implementing this method the system knows how you would like to name your book and uses the given string as a label in the HelpBrowser later.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:41'!step3	^HelpTopic		title: 'Step 3 - Implement pages using methods'		contents:	'STEP 3 - IMPLEMENT PAGES USING METHODS Implement a page by defining a method that returns an instance of HelpPage defining a page title and a help text displayed in the help browser.      firstPage     	    ^HelpTopic	           title: ''First Page''                  contents: ''Hello world''Define a new method for each page of your book. Please group the pages in a method category called "pages".You can also define an icon for the specific page:     secondPage     	    ^HelpTopic	           title: ''Second Page''     	           icon: (HelpIcons iconNamed: #packageIcon)                 contents: ''More to come''Note: =====Later we may add support for better help contents than just plain text (markup descriptions, active morphs, ...)  '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:41'!step4	^HelpTopic		title: 'Step 4 - Defining the page order'		contents:	'STEP 4 - DEFINING THE PAGE ORDER By implementing the class method #pages you return a collection of method selectors to define the order in which the pages appear in your book:      pages     	    ^#(firstPage secondPage)'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/28/2010 22:56'!step5	^HelpTopic		title: 'Step 5 - Test your help'		contents:	'STEP 5 - TEST YOUR HELP	By using              HelpBrowser open '! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:21'!bookName	^'Help on Help'! !!HelpOnHelp class methodsFor: 'pages' stamp: 'hjh 4/21/2010 16:59'!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows to manage the help texts using the standard development tools. But this is only one possible representation.Yes, this is a good solution.!!' readStream nextChunkText! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:56'!key	^'HelpOnHelp'! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:48'!pages	^#(introduction)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'hjh 4/21/2010 11:06'!defaultHelpBrowser	^self ! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'mha 5/2/2010 15:51'!initialize	"Initializes the receiver class" 	self isPharo11		ifFalse: [ TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ].			"self open"! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:32'!isPharo11	"Return true if we are in Pharo 1.1."		^(SystemVersion current version includesSubString: '1.1')! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:46'!isSqueak	"Return true if we are in Squeak"		^(SystemVersion current version includesSubString: 'Squeak')! !!HelpBrowser class methodsFor: 'world menu' stamp: 'tbn 3/28/2010 21:12'!menuCommandOn: aBuilder 	<worldMenu> 	(aBuilder item: #'Help Browser')		parent: #Tools;		action:[self open]; 		icon: (HelpIcons iconNamed: #bookIcon)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 4/22/2010 17:01'!open	^self defaultHelpBrowser openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 3/8/2010 08:50'!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 2/12/2010 12:57'!close	window notNil ifTrue: [window delete]! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 3/5/2010 22:27'!defaultRoot	^CustomHelp! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 4/30/2010 12:39'!defaultViewerClass	 	^PluggableTextMorph! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/29/2010 12:42'!initWindow		self class isSqueak 		ifTrue: [self initWindowInSqueak ]		ifFalse: [self initWindowInPharo ]! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:40'!initWindowInPharo	| toolbar dock|	window := (Smalltalk at: #StandardWindow) new.	window model: self.		window title: 'Help Browser'.	toolbar := window newToolbar: {window			newButtonFor: self			getState: nil			action: #refresh			arguments: nil			getEnabled: nil			labelForm: (HelpIcons iconNamed: #refreshIcon)			help: 'Refresh' translated.			}.				dock := window newToolDockingBar.		dock addMorphBack: toolbar.	window			addMorph: dock			fullFrame: (LayoutFrame fractions: (0@0 corner: 1@0) offsets: (0@0 corner: 0 @ dock minExtent y)).	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window 		addMorph: treeMorph 		fullFrame: (LayoutFrame fractions: (0@0 corner: 0.3@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph fullFrame: (LayoutFrame fractions: (0.3@0 corner: 1@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	 	 ! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:39'!initWindowInSqueak	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:39'!initialize 	super initialize. 	self initWindow. ! !!HelpBrowser methodsFor: 'events' stamp: 'tbn 3/8/2010 15:17'!onItemClicked: anItem	anItem isNil ifTrue: [^contentMorph setText: rootTopic contents].	contentMorph setText: anItem contents! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 3/3/2010 23:32'!open	 	"Open the receivers window" 	self refresh.		window openInWorld.	 ! !!HelpBrowser methodsFor: 'actions' stamp: 'tbn 3/29/2010 12:44'!refresh	|items|	window setLabel: rootTopic title.	items := rootTopic subtopics collect: [:each | HelpTopicListItemWrapper with: each ].	treeMorph list: items.	contentMorph setText: rootTopic contents! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:56'!rootTopic	^rootTopic! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:11'!rootTopic: aHelpTopic	rootTopic := aHelpTopic. 	self refresh ! !!ClassAPIHelpBuilder class methodsFor: 'building' stamp: 'tbn 3/11/2010 23:39'!buildHierarchicalHelpTopicFrom: aClass withSubclasses: aBoolean withMethods: anotherBoolean	"Start building from the given class"		^(self new)		addSubclasses: aBoolean;		addMethods: anotherBoolean;		rootToBuildFrom: aClass;		build;		topicToBuild ! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods	^ addMethods! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods: anObject	addMethods := anObject! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses	^ addSubclasses! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses: anObject	addSubclasses := anObject! !!ClassAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:39'!build	| instanceSide classSide |	topicToBuild := (HelpTopic named: rootToBuildFrom name).	topicToBuild icon: (HelpIcons iconNamed: #pageIcon).	topicToBuild contents: rootToBuildFrom comment.		addMethods ifTrue: [ self buildSubnodesForMethods ].	addSubclasses	 ifTrue: [ self buildSubnodesForSubclasses ].	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 4/22/2010 09:26'!buildMethodTopicsOn: topic for: aClass	|stream comments methodComment|	stream := String new writeStream.	aClass selectors asSortedCollection do:			[:selector | 					  stream 				 nextPutAll: aClass name;			    nextPutAll: '>>';			  	 nextPutAll: selector asString;				 cr.					  comments := aClass commentsAt: selector.			  methodComment := (comments size = 0)									ifTrue: [ 'Method has no comment.' ]									ifFalse: [ comments first ].												  stream nextPutAll: methodComment;cr;cr.	].	topic contents: stream contents.		! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/8/2010 16:56'!buildSubclassTopicFor: aSubclass	 	^(self class new) 			rootToBuildFrom: aSubclass;			addSubclasses: addSubclasses;			addMethods: addMethods;			subclassesAsSeparateTopic: subclassesAsSeparateTopic;			build;			topicToBuild 	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForMethods	| instanceSide classSide |	instanceSide := HelpTopic named: 'Instance side'.	classSide := HelpTopic named: 'Class side'.	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topicToBuild 		addSubtopic: instanceSide;		addSubtopic: classSide.	self buildMethodTopicsOn: instanceSide for: rootToBuildFrom.		self buildMethodTopicsOn: classSide for: rootToBuildFrom class.	! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForSubclasses	| topic |	rootToBuildFrom subclasses isEmpty ifTrue: [^self].	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topic := subclassesAsSeparateTopic 				ifTrue: [topicToBuild addSubtopic: (HelpTopic named: 'Subclasses')]				ifFalse: [topicToBuild ].	rootToBuildFrom subclasses 		do: [:subclass | topic addSubtopic: (self buildSubclassTopicFor: subclass)].	topic sortSubtopicsByTitle.	! !!ClassAPIHelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 16:37'!initialize	"Initializes the receiver"		super initialize.	addSubclasses := false.	addMethods := true.	subclassesAsSeparateTopic := true.! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic	^ subclassesAsSeparateTopic! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic: anObject	subclassesAsSeparateTopic := anObject! !!CustomHelpHelpBuilder methodsFor: 'building' stamp: 'tbn 3/6/2010 00:28'!build	"Start building a help topic from a code description"		topicToBuild := self createTopicFrom: rootToBuildFrom ! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'tbn 3/8/2010 09:17'!createTopicFrom: aDescription	"Create a topic from a description stored on a class"		|topic page method pragma   |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.		aDescription pages do: [:pageSelector|		page := aDescription perform: pageSelector.	 		topic addSubtopic: page.	].		aDescription subclasses do: [:subclass |		topic subtopics add: subclass asHelpTopic ].	^topic! !!HelpBuilder class methodsFor: 'building' stamp: 'tbn 3/5/2010 23:25'!buildHelpTopicFrom: aHelpTopicDescription	"Start building from the given help topic description"		^(self new)		rootToBuildFrom: aHelpTopicDescription;		build;		topicToBuild ! !!HelpBuilder methodsFor: 'building' stamp: 'tbn 3/3/2010 22:55'!build	self subclassResponsibility ! !!HelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:12'!initialize 	"Initializes the receiver"		super initialize.	topicToBuild := self topicClass new.	 ! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:53'!rootToBuildFrom: anObject	rootToBuildFrom := anObject! !!HelpBuilder methodsFor: 'private accessing' stamp: 'tbn 3/5/2010 23:13'!topicClass	^HelpTopic! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:15'!topicToBuild	^topicToBuild! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!build 	|pTopic|	topicToBuild := (HelpTopic named: rootToBuildFrom bookName).	rootToBuildFrom packages do: [:package|		pTopic := HelpTopic named: package.		topicToBuild addSubtopic: pTopic.		self buildPackageTopic: pTopic.			]! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!buildPackageTopic: pTopic 	| classTopic classes |	classes := (PackageInfo named: pTopic title) classes asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].	classes	   do: [:aClass| 		classTopic := ClassAPIHelpBuilder buildHierarchicalHelpTopicFrom: aClass withSubclasses: false withMethods: true.		pTopic addSubtopic: classTopic	]! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 23:53'!blankIcon	^Form extent: 12 @ 1 depth:8! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:17'!bookIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 284817913 552924404 0 0 0 0 0 0 0 0 0 817149108 3747766882 4287730065 2679749049 549766340 0 0 0 0 0 0 1086110908 4016202338 4287137928 4288914339 4288914339 4289111718 3216290996 1086505666 0 0 0 816754350 4014952271 4287137928 4289309097 4289769648 4289111718 4288453788 4288453788 4288453788 2947658161 0 814846353 4283782485 4287072135 4288059030 4288059030 4288387995 4289243304 4289309097 4287927444 4287598479 2411050421 1081900156 4283585106 4286611584 4287532686 4287532686 4287466893 4287466893 4287401100 4287401100 4287401100 4288716960 2946868645 3211290728 4288651167 4287269514 4287006342 4287006342 4287006342 4286940549 4286940549 4287203721 4289177511 3483213213 281725642 2677183122 4293190884 4292861919 4289177511 4286874756 4286611584 4286611584 4287006342 4289638062 4020084125 549042617 0 282054607 2677643673 4289572269 4293256677 4292796126 4288980132 4287137928 4290164406 4020215711 816754350 0 0 0 0 551082200 2677643673 4289572269 4293256677 4292401368 4289177511 1085584564 0 0 0 0 0 0 0 551213786 2677643673 4288651167 1623244992 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:54'!iconNamed: aSymbol	^self icons at: aSymbol ifAbsentPut: [self perform: aSymbol]! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:55'!icons	Icons isNil ifTrue: [Icons := Dictionary new].	^Icons! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/6/2010 01:23'!packageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 1075649821 3744937783 3208395836 807016986 0 0 0 0 0 0 537857807 2939368243 4283256141 4284045657 4284572001 4284111450 2671524924 269488144 0 0 0 2150575919 4014820685 4284111450 4284374622 4284769380 4285098345 4285295724 4286216826 4017057647 1883456323 0 1076505130 4283848278 4284769380 4284966759 4285624689 4285690482 4285887861 4286611584 4287269514 4287861651 4287269514 1074597133 1076965681 4283914071 4283848278 4285953654 4286216826 4286414205 4286940549 4287466893 4287335307 4286808963 4286743170 1074399754 1077163060 4284637794 4284045657 4284835173 4285887861 4287269514 4287335307 4286282619 4286216826 4286874756 4287006342 1074465547 1077294646 4284835173 4284703587 4285361517 4285624689 4286414205 4285624689 4286085240 4286677377 4287269514 4287401100 1074465547 1077426232 4285098345 4285032552 4286019447 4285822068 4286743170 4286348412 4286677377 4287203721 4287730065 4287795858 1074531340 1077492025 4285229931 4285427310 4286808963 4286216826 4287137928 4287072135 4287401100 4287795858 4288256409 4288190616 1074531340 269356558 2672051268 4285493103 4287598479 4286940549 4287532686 4287795858 4287993237 4288387995 4287006342 2404668500 268501249 0 0 1075912993 3479726184 4287598479 4287927444 4288453788 4287993237 2943118444 539371046 0 0 0 0 0 0 1615086660 4017781370 3749148535 1078347334 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:18'!pageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 221196079 1366981242 1366915449 1366915449 1366849656 1366783863 1128876361 33554432 0 0 0 0 726552142 4294309365 4294243572 4294111986 4294046193 4293914607 4292861919 2843705215 319885585 0 0 0 726551886 4294177779 4294111986 4293980400 4293914607 4293848814 4293717228 4292138196 3734147730 269619730 0 0 726486349 4294046193 4293980400 4293914607 4293783021 4293717228 4293585642 4293454056 4291085508 639705377 0 0 726420557 4293980400 4293848814 4293783021 4293651435 4293585642 4293519849 4293388263 4292993505 640034342 0 0 726420556 4293848814 4293717228 4293651435 4293585642 4293454056 4293388263 4293256677 4293190884 623322919 0 0 726354764 4293717228 4293651435 4293519849 4293454056 4293322470 4293256677 4293125091 4293059298 623257126 0 0 726354507 4293585642 4293519849 4293388263 4293322470 4293190884 4293125091 4293059298 4292993505 623191333 0 0 726288970 4293454056 4293388263 4293256677 4293190884 4293125091 4292993505 4292993505 4292993505 623191333 0 0 726223178 4293322470 4293256677 4293190884 4293059298 4292993505 4292993505 4292993505 4292993505 623191333 0 0 726223177 4293256677 4293125091 4293059298 4292993505 4292993505 4292993505 4292993505 4292993505 623191333 0 0 490092087 3080033685 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 454629657 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 00:47'!refreshIcon	^(Form		extent: 16@16		depth: 32		fromArray: #( 0 0 0 0 0 0 0 895969127 526080859 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1884706390 4168710521 2288675434 271330348 0 0 0 0 0 0 0 0 0 828465505 2609087363 3615917702 4269439610 4285887861 4285624689 3899156584 1766607948 67569415 0 0 0 0 0 50529027 2306242166 4237069452 4286940549 4286611584 4286282619 4285887861 4285558896 4285229931 4268189543 2235514687 0 0 0 0 0 2590862701 4287598479 4287269514 4270097540 3329652342 3312217196 4285887861 4285558896 3345179491 1011567435 0 0 0 0 0 1263423054 4287532686 4287532686 3867378563 1096835168 0 1885166941 3681579120 1549227863 50923785 0 0 0 0 0 0 3061545851 4287795858 4236937866 811951461 0 0 641547581 137441585 0 0 0 0 0 0 0 34936085 4102720138 4287795858 3011016824 0 0 0 0 0 0 0 0 0 0 0 0 272317243 4287861651 4287795858 2489607268 0 0 0 0 0 0 0 0 68095759 0 0 0 204682035 4287730065 4287795858 2658432116 0 0 0 0 0 0 0 34014983 3965146967 4283979864 3125694030 0 0 3767044232 4287795858 3884287365 137244206 0 0 0 0 0 0 1129863256 4284769380 4284506208 2739423304 0 0 2189459584 4287795858 4287532686 2541123190 16843009 0 0 0 0 305805882 3597166696 4284703587 4250885983 910114623 0 0 273698896 3834218889 4287532686 4287335307 3094442353 1094532413 101255433 286199567 1582124365 3731318631 4284966759 4284703587 2689946965 0 0 0 0 879126118 3985082247 4287269514 4286940549 4286611584 4285624689 4285558896 4285624689 4285229931 4284966759 3227212635 220998700 0 0 0 0 0 509698401 2977659771 4286743170 4286545791 4286282619 4285887861 4285558896 4100417383 2170116441 103295016 0 0 0 0 0 0 0 0 575820370 1734895720 2121298032 2037017194 1448564567 255013683 0 0 0 0 0)	offset: 0@0)! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!named: aString	"Create a new instance with given title and empty contents"		^(self new)		title: aString;		yourself! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle contents: aText	"Create a new instance with given title and content"		^(self new)		title: aTitle;		contents: aText;		yourself.		! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle icon: anIcon contents: aText	"Create a new instance with given title, icon and content"		^(self new)		title: aTitle;		icon: anIcon;		contents: aText;		yourself.		! !!HelpTopic methodsFor: 'comparing' stamp: 'tbn 3/8/2010 09:11'!<= anotherHelpTopic	"Use sorting by title as the default sort order"		^self title <= anotherHelpTopic title ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:40'!addSubtopic: aTopic	"Adds the given topic to the receivers collection of subtopics"		self subtopics add: aTopic.	^aTopic! !!HelpTopic methodsFor: 'conversion' stamp: 'tbn 3/8/2010 09:09'!asHelpTopic 	"Converts the receiver to a help topic"		^self! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents	"Returns the receivers contents"		^ contents! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents: anObject	"Sets the receivers contents to the given object" 			contents := anObject! !!HelpTopic methodsFor: 'defaults' stamp: 'tbn 3/5/2010 21:31'!defaultTitle	"Returns the receivers default title"		^'Unnamed Topic'	! !!HelpTopic methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:23'!hasSubtopics 	"Returns true if the receiver has subtopics, false otherwise"		^self subtopics notEmpty ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!icon  	"Returns the receivers icon"		^icon! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!icon: aSymbol	"Sets the receivers icon"		icon := aSymbol ! !!HelpTopic methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 08:44'!initialize 	"Initializes the receiver"		super initialize.	self title: self defaultTitle.	self contents: ''.	self key: '' ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key 		"Returns a unique key identifying the receiver in the help system"				^key! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key: aUniqueKey	"Sets a unique key identifying the receiver in the help system"				key := aUniqueKey ! !!HelpTopic methodsFor: 'operating' stamp: 'tbn 3/8/2010 09:12'!sortSubtopicsByTitle	"Sort the subtopics by title"		subtopics := SortedCollection withAll: self subtopics  ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:21'!subtopics 	"Returns the receivers list of subtopics"		subtopics isNil ifTrue: [subtopics := OrderedCollection new].	^subtopics! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!subtopics: aCollection 	"Sets the receivers subtopics"		subtopics := aCollection ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title	"Returns the receivers title"		^ title! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title: anObject	"Sets the receivers title"		title := anObject! !!SystemHelp class methodsFor: 'conversion' stamp: 'tbn 3/8/2010 08:52'!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := CustomHelp asHelpTopic.	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t key = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:01'!all	"HelpBrowser openOn: self all "		^(ClassAPIHelpBuilder new)		rootToBuildFrom: ProtoObject;		addSubclasses: true;		addMethods: true;		subclassesAsSeparateTopic: false;		build;		topicToBuild 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:04'!asHelpTopic 	"HelpBrowser openOn: SystemReference"		^self hierarchyFor: ProtoObject 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/11/2010 23:41'!forClass: aClass	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := ClassAPIHelpBuilder buildHelpTopicFrom: aClass.	root addSubtopic: topic.	^root! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:21'!hierarchyFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: false;					subclassesAsSeparateTopic: false;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:23'!hierarchyWithMethodsFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: true;					subclassesAsSeparateTopic: true;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!Class methodsFor: '*HelpSystem-Core' stamp: 'tbn 3/11/2010 23:42'!asHelpTopic	^SystemReference forClass: self! !"HelpSystem-Core"!!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:33'!testDefaultBuilding	|topic|	topic := ClassAPIHelpBuilder 				buildHelpTopicFrom: Integer.				 	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:32'!testMethodsButNoSubclasses	|topic|	topic := ClassAPIHelpBuilder 				buildHierarchicalHelpTopicFrom: Integer 				withSubclasses: false 				withMethods: true.	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 3/2/2010 23:21'!defaulTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 3/2/2010 23:20'!testOpen	|block|	block := [		|browser|		browser := self defaulTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 4/8/2010 12:05'!testRegistration	"there is no world menu in 1.1."      HelpBrowser isPharo11 ifTrue: [^self].	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !!HelpIconsTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:23'!defaultTestClass 	^HelpIcons! !!HelpIconsTest methodsFor: 'testing' stamp: 'tbn 3/3/2010 00:50'!testIconCaching	 	| first second |	#(bookIcon pageIcon refreshIcon) do: [:iconSymbol |		first := self defaultTestClass iconNamed: iconSymbol.		second := self defaultTestClass iconNamed: iconSymbol.			self assert: first notNil.		self assert: first == second.	]	! !!HelpTopicListItemWrapperTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 13:16'!defaultTestClass 	^HelpTopicListItemWrapper 	! !!HelpTopicListItemWrapperTest methodsFor: 'testing' stamp: 'tbn 3/5/2010 21:46'!testDisplayLabel	|instance|	instance := self defaultTestClass with: (HelpTopic named: 'My Topic').	self assert: instance asString = 'My Topic'	! !!HelpTopicTest methodsFor: 'accessing' stamp: 'tbn 3/5/2010 21:47'!defaultTestClass	^HelpTopic ! !!HelpTopicTest methodsFor: 'running' stamp: 'tbn 3/5/2010 21:49'!setUp	super setUp.	topic := self defaultTestClass new.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:44'!testAddingSubtopic	|subtopic returned|	subtopic := self defaultTestClass named: 'Subtopic'.	returned := topic addSubtopic: subtopic.	self assert: returned == subtopic.	self assert: (topic subtopics includes: subtopic) ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:07'!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic key isEmpty.	self assert: topic contents isEmpty ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testInstanceCreation	|instance|	instance := self defaultTestClass named: 'My Topic'.	self assert: instance title = 'My Topic'.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testSortOrder	|a b c sorted |	a := self defaultTestClass named: 'A'.	b := self defaultTestClass named: 'B'.	c := self defaultTestClass named: 'C'.	sorted := (OrderedCollection with: b with: c with: a) asSortedCollection.	self assert: sorted first = a.	self assert: sorted last = c.	! !"HelpSystem-Tests"!!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:11'!bookName 	^'Squeak'! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:30'!icon	(self name = #SqueakHelp) ifTrue: [^HelpIcons iconNamed: #squeakIcon].	^nil! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:16'!bookName 	^'License'! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'hjh 4/29/2010 16:48'!licenseChange	^HelpTopic 		title: 'License has changed with 4.0'		contents: 'On 23 September 1996, Apple Computer Inc. released Squeak V1.1 under the "Squeak License" (SqL).On May 8, 2006 Apple agreed to relicense original Squeak V1.1 under the Apple Public Source License.On October 12, 2006 Apple granted permission to relicense under Apache license 2.0.In 2006, VPRI began to collect "Distribution Agreements" for all contributors to Squeak since V1.1 up to V3.8, asking them to relicense their contributions, which were originally licensed under SqL, to the MIT license. This was a great effort on behalf of many and VPRI has 100s of signed documents agreeing to this.Do you want to contribute source to Squeak?All new contributions since 4.0 must be under the MIT license. When you make your code available, please state explicitly in some form such as the description on a web site or email announcement that your contribution is under the MIT license. (It doesn''t have to be exclusive; you can release it under difference licenses at the same time.)Have you contributed source to Squeak? If you believe you have, but have not sent in an agreement to allow your submission(s) to be licensed under the MIT license then please see http://netjam.org/squeak/contributors. There you can find a list of known contributors and a PDF of the agreement with instructions. The snail mail address is found in the agreement PDF file.Also there are a few people for which we are lacking full contact information. If you think you can help please also visit the link above and see if you can identify any of the unknown developer initials or any of the developers for whom we do not have a current email address.' ! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'mha 5/2/2010 17:35'!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'mha 5/2/2010 17:26'!pages	^#(licenseChange officialLicense)! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:13'!bookName 	^'Squeak Project'! !!SqueakProjectHelp class methodsFor: 'pages' stamp: 'tbn 3/5/2010 22:01'!introduction	^HelpTopic		title: 'Welcome'		icon: (HelpIcons iconNamed: #squeakIcon)		contents:'WELCOMESqueak is a modern, open source, full-featured implementation of the powerful Smalltalk programming language and environment. Squeak is highly-portable - even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change. Squeak is the vehicle for a wide range of projects from multimedia applications, educational platforms to commercial web application development.'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:15'!pages	^#(introduction )! !!HelpIcons class methodsFor: '*help-squeak-project' stamp: 'mha 5/2/2010 20:58'!squeakIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 75398782 26843545 0 0 1159996452 1378823983 338044454 0 0 0 0 455682345 1295266868 1126376227 0 0 1040582150 0 1328097577 0 0 0 23488102 1277502757 0 1076834095 0 0 1075781407 0 287647013 472854319 0 0 471472666 204089898 0 1092756002 0 0 1041963803 36909875 0 1880232466 454761243 287515427 1342572038 0 104939841 974460181 0 0 270080281 354690084 86846765 3674539269 1394219546 1611599631 3557427722 86123042 388244516 204287277 0 26843545 605558808 1025055001 1008014613 1159141143 522264865 739710743 1159141143 571083274 570820102 188891714 0 942550574 1411391520 1143021857 1312241463 1428563494 3205040393 3708159494 1663576104 1511067921 1579887403 1629758500 958472481 656679972 439563059 1294608938 839913488 739644950 172246084 221459251 840900383 1075978786 1209933342 724512559 707077413 0 0 0 0 0 0 0 0 0 0 38488907 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !"Help-Squeak-Project"!!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := Array new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := Array new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258393!makeRoomAtFirst	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= array size ifTrue: [ ^self growAtFirst ].	tally = 0 ifTrue: [ ^self resetTo: array size + 1 ].	newFirstIndex := array size // 2 + 1.	newLastIndex := newFirstIndex - firstIndex + lastIndex.	0 to: tally - 1 do: [ :offset |		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].	array from: firstIndex to: newFirstIndex - 1 put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258899!makeRoomAtLast	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].	tally = 0 ifTrue: [ ^self resetTo: 1 ].	newLastIndex := lastIndex // 2.	newFirstIndex := newLastIndex - lastIndex + firstIndex.	array 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array from: newLastIndex + 1 to: lastIndex put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:20' prior: 25259891!reset	self resetTo: 1! !!Collection methodsFor: 'enumerating' stamp: 'ar 5/4/2010 08:40'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	self emptyCheck.	first := true.	self do:[:each|		first ifTrue:[nextValue := each. first := false]			ifFalse:[nextValue := binaryBlock value: nextValue value: each]].	^nextValue! !!Collection methodsFor: 'math functions' stamp: 'ar 5/4/2010 08:38' prior: 18835941!sum	"Compute the sum of all the elements in the receiver"	^self reduce:[:a :b| a + b]! !OrderedCollection removeSelector: #growSize!OrderedCollection removeSelector: #grow!"Collections"!!WeakSetTest methodsFor: 'tests' stamp: 'ul 5/3/2010 20:13'!testDoAfter	| input weakSet array |	input := (1 to: 11) collect: [ :each | each asString asSymbol ]. "Some symbols might be garbage collected without this variable"	weakSet := WeakSet withAll: input.	array := weakSet asArray. "Assume that the elements will have the same order as the internal array of the weakset"	0 to: array size do: [ :index |		| element result |		element := array at: index ifAbsent: nil.		result := Array new: weakSet size - index streamContents: [ :stream |			weakSet				do: [ :each | stream nextPut: each ]				after: element ].		self assert: result sort = (array allButFirst: index) sort ]! !!WeakSetTest methodsFor: 'tests' stamp: 'ul 11/20/2009 22:53' prior: 53697582!testIncludes	| weakSet transientFakeNilObject |	weakSet := WeakSet new.	#(true nil 1) do: [ :each |		self deny: (weakSet includes: each) ].	weakSet add: true.	self assert: (weakSet includes: true).	weakSet remove: true.	self deny: (weakSet includes: true).	transientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\ weakSet capacity = 0 ]) asString. "this string will occupy the same slot as nil would"	weakSet add: transientFakeNilObject.	transientFakeNilObject := transientFakeNilObject copy.	Smalltalk garbageCollect. "get rid of transientFakeNilObject"	self deny: (weakSet includes: transientFakeNilObject).	self deny: (weakSet includes: nil)			! !!CollectionTest methodsFor: 'tests' stamp: 'ar 5/4/2010 08:52'!testReduce	"self run: #testReduce"	| array set bag |	array := Array with: 1 with: 2 with: 3.	self assert: (array reduce:[:a :b| a + b]) = 6.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = 6.	array := Array with: Color red with: Color green with: Color blue.	self assert: (array reduce:[:a :b| a + b]) = Color white.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = Color white.	array := Array with: 1 with: 1 with: 1.	self assert: (array reduce:[:a :b| a + b]) = 3.	bag := array asBag.	self assert: (bag reduce:[:a :b| a + b]) = 3.! !!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 22:15'!testNewFinalizationSupported	| list item |	list := WeakFinalizationList new.			item := WeakFinalizerItem new list: list object: Object new executor: nil.		self assert: (list first isNil).	self assert: (item object notNil).		Smalltalk garbageCollect.		self assert: (item object isNil).	self assert: (list first == item).	self assert: (list first next == nil).! !"CollectionsTests"!!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'topa 5/3/2010 11:26' prior: 54545818!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:32'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33' prior: 22807306!source	^ self definitionAndCommentString! !"Monticello"!!Categorizer commentStamp: 'nice 5/6/2010 21:10' prior: 0!A Categorizer goal is to classify the elements of a collection into categories.It is typically used to classify methods of class into categories (also named protocols in this case).Instance Variables	categoryArray:		<SequenceableCollection of: Object>	categoryStops:		<SequenceableCollection of: Integer>	elementArray:		<SequenceableCollection of: Object>categoryArray	- holds the list of categories.	A category could be any Object but is generally a String or Symbol.	Categories should be unique (categoryArray asSet size = categoryArray size)categoryStops	- holds the index of last element belonging to each category.	There should be a category stop for each category (categoryStops size = categoryArray size).	The categoryStops should be sorted (categoryStops sorted = categoryStops).	A category stop equal to its predecessor (= 0 for the first category stop) denotes an empty category.elementArray	- holds the elements to be classified. The elements are sorted by category.Class variables	Default is the default category used to classify yet unclassified methods of a class	NullCategory is the category to be displayed in a Browser for a class having no method.!!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25' prior: 57942725!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 3/1/2007 20:17'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver."	^(self/aNumber) floor * aNumber! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/24/2010 02:51' prior: 57953109!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !"Kernel"!!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33' prior: 33688294!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2010 08:55' prior: 51566743!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !"Compiler"!!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!isolatedCodePaneForClass: aClass selector: aSelector	"Answer a MethodMorph on the given class and selector"	| aCodePane aMethodHolder |	aMethodHolder := self new.	aMethodHolder methodClass: aClass methodSelector: aSelector.	aCodePane := MethodMorph on: aMethodHolder text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aMethodHolder addDependent: aCodePane.	aCodePane borderWidth: 2; color: Color white.	aCodePane scrollBarOnLeft: false.	aCodePane width: 300.	^ aCodePane! !!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !"EToys"!!CharacterBlock commentStamp: 'mtf 5/15/2010 12:44' prior: 18447774!I describe the location of one character displayed on the screen. My instances are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the information I store stale.text (Text): The text where my character is fromstringIndex (Integer): The index of my character in the text, starting from 1textLine (TextLine): The displayed line my character is onorigin (Point): The top-left corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0corner (Point): The bottom-right corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0!"Graphics"!!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCMcmUpdater commentStamp: 'dtl 5/10/2010 23:22' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository, MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration. !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11' prior: 22854648!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56' prior: 22856503!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !"MonticelloConfigurations"!!Project commentStamp: 'tk 12/2/2004 12:38' prior: 59386593!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at, are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:---------Isolation (not used any more)When you accept a method, the entire system feels the change, exceptprojects that are "isolated".  In an isolated project, all new globalvariables (including new classes) arestored in the project-localenvironment, and all changes to preexisting classes are revoked whenyou leave the project.  When you enter another project, thatproject's changes are invoked.  Invocation and revocation are handledefficiently by swapping pointers.  To make a project be isolated,choose 'isolate changes of this project' from the 'changes...'section of the screen menu.  You can use an isolated project formaking dangerous change to a system, and you can get out if itcrashes.  A foreign application can have the separate environment itwants.  Also, you can freeze part of the system for a demo that youdon't want to disturb.  An isolated project shares methods with allsubprojects inside it, unless they are isolated themselves.   Eachisolated project is the head of a tree of projects with which itshares all methods.You may 'assert' all changes ever made in the current project to takeeffect above this project.  This amounts to exporting all the globalsin the current environment, and zapping the revocation lists to thatthe current state of the world will remain in force upon exit fromthis project.[Later: A project may be 'frozen'.  Asserts do not apply to it afterthat.  (Great for demos.)  You should be informed when an assert wasblocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You areonly allowed to change the shape of a class in projects that liewithin its isolation scope.  All versions of the methods arerecompiled, in all projects.  If you remove an inst var that is inuse in an isolated project, it will become an Undeclared global.  Itis best not to remove an inst var when it is being used in anotherisolated project. [If we recompile them all, why can't we diagnosethe problem before allowing the change??]Senders and Implementors do not see versions of a method in isolatedprojects.  [again, we might want to make this possible at a cost].When you ask for versions of a method, you will not get the historyin other isolated projects.Moving methods and classes between changeSets, and merging changeSetshas no effect on which methods are in force.  But, when you look at achangeSet from a different isolated project, the methods will containcode that is not in force.  A changeSet is just a list of methodnames, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProjectassertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store itsMethodDictionary object.  Keep parallel arrays of associations toClasses and MethodDictionaries.  Traverse these and install them whenyou enter an "ioslated project".  When you leave, store thisproject's own MethodDictionaries there.	To do an assert, we must discover which methods changed here,and which changed only in the project we are asserting into.  Thereis one copy of the 'virgin' method dictionaries in the system.  It isalways being temporarily stored by the currently inForce isolatedproject.isolatedHead - true for the top project, and for each isolatedproject.  false or nil for any subproject that shares all methodswith its parent project.inForce -  true if my methods are installed now.  false if I amdormant. [is this equivalent to self == Project Current?]classArray - list of associations to classesmethodDictArray - the method dictionaries of those classes before westarted changing methods.  They hang onto the originalcompiledMethods.  (If this project is dormant, it contains the methoddictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.When you want to save a project in export format from within thatvery project, it gets tricky.  We set two flags in parentProject,exit to it, and let parentProject write the project.ProjectViewMorph in parentProject checks in its step method, does thestore, clears the flags, and reenters the subProject.!!Utilities class methodsFor: 'support windows' stamp: 'spd 5/24/2010 20:23' prior: 32903560!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Flaps reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[SystemNavigation default allCallsOn: #asOop].MessageTally spyOn: [SystemNavigation default allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 5/7/2010 20:50' prior: 59191674!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Unable to retrieve updates from remote repository.' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.Current update number: ' translated, SystemVersion current highestUpdate).! !!Project methodsFor: 'menu messages' stamp: 'cbr 5/1/2010 01:53'!toggleFullScreen	"Toggle between full screen and windowed mode."	self lastScreenModeSelected		ifTrue: [ self fullScreenOff ]		ifFalse: [ self fullScreenOn ]! !!Project methodsFor: 'accessing' stamp: 'dtl 5/2/2010 19:09'!uiManager	"Answer the manager that provides user interface services for this project "	^ uiManager		ifNil: [uiManager := Smalltalk						at: #UIManager						ifPresent: [:mgr | uiManager := mgr getDefault]]! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34' prior: 26889133!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33' prior: 26916280!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!SystemOrganizer class methodsFor: 'class initialization' stamp: 'spd 5/19/2010 15:54'!default	"I have a global instance, SystemOrganization.  In case someone stumbles upon my class, and does not know about the global, it can be accessed from here, too."  ^ SystemOrganization.! !Preferences class removeSelector: #useFormsInPaintBox!"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dcorking 5/6/2010 13:59' prior: 33713033!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'cbr 5/1/2010 01:47' prior: 53728504!projectsMenuOn: aDockingBar	aDockingBar addItem: [ :item |		item			contents: 'Projects' translated;			addSubMenu: [ :menu | 				self					newProjectMenuItemOn: menu;					saveProjectMenuItemOn: menu;					loadProjectMenuItemOn: menu;					previousProjectMenuItemOn: menu;					jumpToProjectMenuItemOn: menu;					toggleFullScreenMenuItemOn: menu ] ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'spd 5/24/2010 19:19' prior: 59199720!squeakUserInterface	^'The Squeak UI has some unusual elements that you may not have seen before.  Here is a brief introduction to those elements:ProjectsA project is an entire Squeak desktop full of windows.  Projects can be used to change quickly from one task to another.  An inactive project is represented by a project window, which shows a thumbnail of its state.  Project windows are actually more like doors than windows, since you can enter the project just by clicking on them.  You can create a new project by choosing ''open...project'' from the screen menu.  To exit a project (and return to its parent project), choose ''previous project'' from the screen menu.  Each project maintains its own set of windows and other information.Morphic HalosIn a morphic project, pressing cmd-click (Mac) or alt-click (Windows) on a graphical object (e.g. a window) will surround it with a constellation of colored circles.  These are called "halo handles."  Additional clicks will cycle through the halos for the other graphical objects in the nesting structure.  If you hold down the Shift key while cmd/alt-clicking, the nested morphs will be traversed from innermost outward.  Clicking without the cmd/alt key will dismiss the halo.  While the halo is up, letting the cursor linger over one of the halo handles for a few seconds will cause a balloon to pop up with the name of that handle.  Three useful handles are the top-left "X" handle (delete), the bottom-right yellow handle (resize), and the brown handle (slide the object within its containing object).  Halos allow complex graphical objects to be explored - or even disassembled (using the black halo handle).  Usually no harm results from taking apart an object; you can just discard the pieces and create a new one.FlapsTo enable Flaps, click on the desktop to show the world menu, choose the "Flaps..." menu and "show shared tags". Tabs labeled "Squeak", "Tools", "Supplies", etc., will appear along the edges of the Squeak desktop.  Click on any tab to open the corresponding flap.  Drag a tab to resize the flap and to relocate the tab.  Bring up the halo on any tab and click on its menu handle to be presented with many options relating to the flap.  Use the "Flaps..." menu, reached via the desktop menu, to control which flaps are visible and for other flap-related options and assistance.Parts BinsYou can obtain new objects in many ways.  The "Objects Catalog" (choose "objects'' from the world menu or open the objects flap) and several of the standard flaps (e.g. "Tools" and "Supplies") serve as "Parts Bins" the for new objects.  Drag any icon you see in a Parts Bin and a fresh copy of the kind of object it represents will appear "in your hand"; click to deposit the new object anywhere you wish.  You can also add your own objects to any of the flaps - just drag your object over the tab, wait for the flap to pop open, then drop the object at the desired position in the flap.!!]style[(123 9 663 13 991 5 579 10 589),bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'cbr 5/1/2010 01:42'!toggleFullScreenMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Toggle Full Screen' translated;			help: 'Switch back and forth from full screen mode' translated;			icon: MenuIcons smallFullScreenIcon;			target: Project current;			selector: #toggleFullScreen ]! !"Morphic"!!HierarchicalUrl methodsFor: 'printing' stamp: 'topa 5/5/2010 13:47' prior: 21557419!printOn: aStream	aStream nextPutAll: self schemeName.	aStream nextPutAll: '://'.	self username ifNotNil: [		aStream nextPutAll: self username encodeForHTTP.		self password ifNotNil: [			aStream nextPutAll: ':'.			aStream nextPutAll: self password encodeForHTTP].		aStream nextPutAll: '@' ].	aStream nextPutAll: self authority.	port ifNotNil: [aStream nextPut: $:; print: port].	path do: [ :pathElem |		aStream nextPut: $/.		aStream nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		aStream nextPut: $?.		aStream nextPutAll: self query. ].	self fragment isNil ifFalse: [		aStream nextPut: $#.		aStream nextPutAll: self fragment encodeForHTTP. ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'topa 5/4/2010 14:30' prior: 51344189!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := (username copyFrom: (username indexOf: $:) + 1 to: username size) unescapePercents.					username := username copyUpTo: $:].			username := username unescapePercents].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !"Network"!!UrlTest methodsFor: 'tests' stamp: 'topa 5/4/2010 14:33'!testUsernamePasswordEncoded	"Sometimes, weird usernames or passwords are necessary in 	applications, and, thus, we might receive them in a Url.	The @ and the : ar the kind of critical ones.	"	#(	"('user' 'pword' 'host' port 'path')"		('Frst Pckler' 'leckerEis' 'cottbus.brandenburg' 80 'mein/Zuhause')		('Jeannde.d''Arc' 'jaiunescret' 'orleans' 8080 'une/deux/trois')		('HaXor@roxor:fnac' 'my~Pa$wert' 'cbase' 42 'do/not_try')	) do: [:urlParts | |theUrl|		theUrl := ('http://{1}:{2}@{3}:{4}/{5}' format: {			(urlParts at: 1) encodeForHTTP. 	(urlParts at: 2) encodeForHTTP.			urlParts at: 3. urlParts at: 4. urlParts at: 5.		}) asUrl.		self 			should: [theUrl schemeName = 'http'];			should: [theUrl username = (urlParts at: 1)];			should: [theUrl password = (urlParts at: 2)];			should: [theUrl authority = (urlParts at: 3)];			should: [theUrl port = (urlParts at: 4)];			should: [theUrl path first = ((urlParts at: 5) copyUpTo: $/)]].! !!UrlTest methodsFor: 'tests' stamp: 'topa 5/5/2010 13:50'!testUsernamePasswordPrintingEncoded	#(	'http://F%C3%BCrst%20P%C3%BCckler:leckerEis@cottbus.brandenburg:80/mein/Zuhause'		'http://Jeannde.d%27Arc:jaiunes%C3%A9cret@orleans:8080/une/deux/trois' 		'http://HaXor%40roxor%3Afnac:my%7EPa%24%C2%A7wert@cbase:42/do/not_try'	) do: [ :urlText |		self should: [ urlText = urlText asUrl asString ] ].! !"NetworkTests"!!SMLoader class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 27945877!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[self new createWindow; applyModelExtent; yourself]		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 33589283!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[(ToolBuilder open: self new) applyModelExtent; yourself] 		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !"SMLoader"!!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:43'!testTestTimeoutLoop	<timeout: 1>	self should:[[true] whileTrue.] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'running' stamp: 'ar 5/11/2010 19:58' prior: 31103806!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout:[		self setUp.		self performTest	] after: self timeoutForTest] ensure:[self tearDown].! !!TestCase methodsFor: 'running' stamp: 'ar 5/12/2010 19:33'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:44'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !"SUnit"!!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingColors	"self run: #testSummingColors"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each) sum = each) 	].! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingToTen	"self run: #testSummingToTen"	| cases |	cases :={ 		{ 1 . 2 . 3 . 4 }.		{ 2.0 . 2.0 . 2.0 . 2.0 . 2.0  }.		{ 2/5 . 5/2 . 5/2 . 3/5 . 4 } 	} .	cases do: [ :each |		self assert: (each  sum = 10 )	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:43'!testSummingToWhite	"self run: #testSummingToWhite"	| cases |	cases := { 		{ Color black . Color white }.		{ Color red . Color green. Color blue }.		{ Color gray . Color gray }.		{ Color cyan. Color magenta. Color yellow }.		{ Color cyan. Color magenta.  }.		{  Color magenta. Color yellow }.		{ Color cyan.  Color yellow }.		{ Color cyan. Color red }.		{ Color green .Color magenta.  }.		{ Color blue. Color yellow }.	} .	cases do: [ :each |		self assert: (each  sum = Color white) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:44'!testSummingWithBlack	"self run: #testSummingWithBlack"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each with: Color black) sum = each) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:45'!testSummingWithWhite	"self run: #testSummingWithWhite"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	} .	cases do: [ :each |		self assert: ((Array with: Color white with: each ) sum = Color white) 	] .! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalDirectly	"	SystemOrganizerTest run: #testAccessGlobalDirectly	"		self assert: (SystemOrganization isKindOf: SystemOrganizer).					"It really lives in Smalltalk (another global)"	self assert: ((Smalltalk at: #SystemOrganization) == SystemOrganization).! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalThroughClass	"	SystemOrganizerTest run: #testAccessGlobalThroughClass	"			"In case someone stumbles upon the SystemOrganizer class, and does not know	about the SystemNavigation global, it can be accessed from there, too."	self assert: (SystemOrganizer default == SystemOrganization).! !!ClosureTests methodsFor: 'testing-while' stamp: 'eem 5/22/2010 09:35'!testWhileWithTempIsNil	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		collection add: temp.		temp := index := index + 1. 		collection add: temp].	self assertValues: #(nil 1 nil 2 nil 3 nil 4 nil 5)! !!LocaleTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:24' prior: 57142788!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	<timeout: 60> "takes quite a while"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:54' prior: 57220949!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	<timeout: 30> "takes a little longer"	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:53' prior: 57223286!testRepeatedMerge	| base mother1 mother2 inst |	<timeout: 30> "takes a little longer"	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!DecompilerTests methodsFor: 'utilities' stamp: 'ar 5/10/2010 20:17'!defaultTimeout	"Decompiler takes a long time"	^30 "seconds"! !!MCFileInTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:53' prior: 57160248!testStWriter	<timeout: 30> "takes a little longer"	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !"Tests"!!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 26547561!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 59370783!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 59375756!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 32533887!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:54' prior: 32541199!default	^ Project current uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:52'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNilDo: [:mgrClass | mgrClass new]! !PluggableTextSpec removeSelector: #color:!PluggableTextSpec removeSelector: #color!PluggableButtonSpec removeSelector: #color:!PluggableButtonSpec removeSelector: #color!UIManager class removeSelector: #default:!"ToolBuilder-Kernel"!!MVCUIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 23337692!MVCUIManager is a UIManager that implements user interface requests for an MVC user interface.!"ToolBuilder-MVC"!!MorphicUIManager commentStamp: 'dtl 5/2/2010 16:07' prior: 24593982!MorphicUIManager is a UIManager that implements user interface requests for a Morphic user interface.!!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'fbs 5/2/2010 15:31' prior: 58753986!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	widget keystrokePreviewSelector: aSpec keystrokePreview.	aSpec color isNil ifFalse: [widget color: aSpec color].	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 5/4/2010 12:55' prior: 33732384!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 20:48' prior: 57780504!buildFileListWith: builder	| buttons listSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttons := self buildButtonPaneWith: builder.	buttons frame: (self topConstantHeightFrame: self buttonHeight fromLeft: 0 width: 1).	top children add: buttons.		listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil;		frame: (self frameOffsetFromTop: self buttonHeight + 4 fromLeft: 0 width: 1 bottomFraction: 1);		color: Color white.	top children add: listSpec.	^top.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 16:20' prior: 57781075!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.5) -> [self buildFileListWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 4/30/2010 14:53'!buttonHeight	^Preferences standardButtonFont height + 12! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 23:00'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 22:56'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50' prior: 18762661!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'eem 5/18/2010 14:11'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new									parse: method getSourceFromFile asString									in: class									notifying: nil)										generate: CompiledMethodTrailer defaultMethodTrailer;										schematicTempNamesString.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !"Tools"!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 33755727!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:37' prior: 33773237!defaultHelpBrowser	DefaultHelpBrowser isNil ifTrue: [DefaultHelpBrowser := self].	^DefaultHelpBrowser	! !!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:42'!defaultHelpBrowser: aClass	"Use a new help browser implementation"		DefaultHelpBrowser := aClass	! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'tbn 5/2/2010 22:20' prior: 33773350!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:37' prior: 33774194!open	^self openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:36' prior: 33774327!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self defaultHelpBrowser new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 5/2/2010 22:20' prior: 33774942!initWindow	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !HelpBrowser removeSelector: #initWindowInSqueak!HelpBrowser removeSelector: #initWindowInPharo!HelpBrowser class removeSelector: #menuCommandOn:!HelpBrowser class removeSelector: #isSqueak!HelpBrowser class removeSelector: #isPharo11!"HelpSystem-Core"!!AdvancedHelpBrowserDummy commentStamp: 'tbn 5/3/2010 19:30' prior: 0!This is a dummy for a custom Help browser that can be registered as a replacement for the HelpBrowser class.Instance Variables	rootTopic:		<HelpTopic>rootTopic	- The root help topic!!AdvancedHelpBrowserDummy methodsFor: 'initialize-release' stamp: 'tbn 5/3/2010 19:34'!initialize	isOpen := false! !!AdvancedHelpBrowserDummy methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:32'!isOpen	^isOpen! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:32'!open	isOpen := true! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic	^rootTopic! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic: aTopic	rootTopic := aTopic! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 5/3/2010 19:35'!defaultTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 20:22'!testDefaultHelpBrowser		| current replacement instance |	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement. 	  instance := self defaultTestClass open.	  self assert: instance rootTopic notNil.	  self assert: instance isOpen.	] ensure: [ self defaultTestClass defaultHelpBrowser: current ]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:28'!testDefaultHelpBrowserIsReplacable		| current replacement instance |	"save the one that is registered"	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement.	  	  instance := self defaultTestClass open.	  	] ensure: [		self defaultTestClass defaultHelpBrowser: current	]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 18:43'!testLazyDefaultHelpBrowser		self assert: self defaultTestClass defaultHelpBrowser notNil! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:35' prior: 33796513!testOpen	|block|	block := [		|browser|		browser := self defaultTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/2/2010 22:20' prior: 33796755!testRegistration	        	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !HelpBrowserTest removeSelector: #defaulTestClass!"HelpSystem-Tests"!!SqueakToolsHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:08'!basicDevelopmentTools	^HelpTopic 		title: 'Basic Development Tools'		contents: 'Smalltalk environments have some of the best user interfaces for programmers ever devised. Those who have programmed in Lisp under Emacs have some idea, but Smalltalk is even better.		You should learn these basic tools thoroughly:- Workspace- Transcript- Browser- Inspector- File List- Change Sorter- Debugger- Method Finder		'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 22:59'!bookName 	^'Tools'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:08'!pages	^#(basicDevelopmentTools)! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:14'!bookName	^'Transcript'! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:16'!pages	^# (transcript)! !!SqueakToolsTranscriptHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:16'!transcript	^HelpTopic 		title: 'The Transcript window'		contents: 'The Transcript window is often used for logging or printing results from text only code. To open the Transcript use TheWorldMenu and choose ''open...''. Then choose ''Transcript''.You can also type   Transcript openin a Workspace and doIt.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:06'!bookName 	^'Workspace'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:10'!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window, by doing any one of the following:		- Using a keyboard while pointing at an empty part of the Squeak wind, alt-k (in Windows, cmd-k in Mac)- Open up a World Menu, select "open..." action. From the open menu, select "workspace (k)- Click on the Tools Flap. When it comes out, click on the Workspace icon and drag it out. (Click on the Tools Flap to close it back up.).'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:11'!pages	^#(workspace openWorkspace saveWorkspace)! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:13'!saveWorkspace	^HelpTopic 		title: 'Saving Workspace to a File'		contents: 'You can save the text content of a Workspace to a file by choosing the workspace menu (from within the workspace), then ''more...'', then ''save contents to file...''.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:09'!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated. To open a workspace window in Squeak, one possibility is to bring up the World menu, select "open...", and then select "workspace". You can then type in any Smalltalk code inside the workspace window and execute it or inspect it.'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:33'!bookName 	^'Tutorials'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:34'!bookName 	^'XML'! !!SqueakTutorialsOnXML class methodsFor: 'pages' stamp: 'it 5/4/2010 20:12'!dataRetrieval	^HelpTopic 		title: 'Retrieving XML data'		contents: 'Retrieving data from XML documents is simple and easy in Squeak Smalltalk. This tutorial demonstrates the fundamentals with a straightforward approach where code can be tested right away either here or in a Workspace window. The beauty of Squeak Smalltalk resides in the possibility to evaluate, inspect, print and debug code anywhere and this window is no different. This tutorial demonstrates how to...	* retrieve an XML document from the World Wide Web	* instantiate an XML document class	* inspect and understand the content of an XML document	* retrieve and display values from specific XML tagsRetrieve an XML document from the World Wide WebThere are many manners to retrieve data from the World Wide Web in Squeak Smalltalk. HTTPClient is among them and allows to download files in all simplicity. Select the following code snippet and inspect it (press alt-i). An Inspect window will open with the document loaded in memory. The result is a MIMEDocument object.	HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.TIP: Select HTTPClient and browse it (press alt-b) to open a System Browser window on its class. HTTPClient does not have instance methods but it has class methods. Click on class to see class methods.Instantiate an XML DocumentAn instance of MIMEDocument will not allow to retrieve XML data in a comprehensive manner because it does not understand the nature of XML. For this reason, it is necessary to parse the content of MIMEDocument using XMLDOMParser. XMLDOMParser>>parseDocumentFrom: requires a stream as a parameter and ReadStream will be used for this purpose. The following code snippet instantiates an XMLDocument using the content of the downloaded file.	| doc |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).Inspect and understand the content of an XML documentXML is a flexible document format and it is necessary to understand how each given XML file is structured in order to properly search, retrieve and manipulate data. Inspecting values is critical in a dynamic programming language and environment, such as Squeak Smalltalk. Select the previous code snippet and inspect it (press alt-i).Unfortunately, the Inspect window does not reveal a lot about the XML structure of the downloaded file. Select the previous code snippet once again and explore it (press alt and the capital letter i). An Explorer window will open with a tree outline on the instance of XMLDocument.The Inspect and Explorer windows tell a lot about an XMLDocument. The sections are instance variables and their values are displayed aside. In the Explorer window, unfold elementsAndContents. Unfold other sections as deemed necessary to understand the XML format and the data available.The gibberish coding is about to become clear. Open a Browser window from the world menu and right click in the first pane, select find class (press alt-f) and type XMLDocument to search for its class, or select the class name and browse it (press alt-b). However, it is suggested to read more about XMLParser and XMLParserTest first. Retrieve and display values from specific XML tagsThe downloaded XML file contains a list of items which are denoted by the tag name "item". The Explorer window revealed the content of interest is located at the array index 1 of the elementsAndContents, which can be accessed through XMLDocument>>root.TIP: Some XML documents have additional components contained within its file, such as XMLPI (XML Processing Instructions). For this reason, the root may lead to this rather than the data which will be indexed at 2 or more. It is necessary to use XMLNodeWithElements>>elements, e.g. (xml elements at: 2), in order to access subsequent data.The following code snippet will display items in a Transcript window. Open a Transcript window using the world menu before selecting and executing the code. Select the code snippet and execute it (press alt-d).	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript show: (e asString); cr.		].An XML item looks like this:	<item>	<title>HelpSystem-Core-tbn.46.mcz</title>	<link>http://source.squeak.org/trunk.html</link>	<description>throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)</description>	<pubDate>Sun, 02 May 2010 20:23:49 +0000</pubDate>	<author>Torsten Bergmann &lt;Torsten.Bergmann@astares.de&gt;</author>	<category>The Trunk</category>	<enclosure length="27288" type="application/x-monticello" url="http://source.squeak.org/trunk/HelpSystem-Core-tbn.46.mcz"/> 	<guid isPermaLink="false"/> </item>The following code snippet uses information learned, retrieves each comment and displays them in a Transcript window. Notice an author can have a nil value and is handled accordingly.	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript 			show: ''Date: '', ((e firstTagNamed: #pubDate) contentString); cr;			show: ''Title: '', ((e firstTagNamed: #title) contentString); cr;			show: ''Author: '', 				(((e firstTagNamed: #author) notNil)					ifTrue: [(e firstTagNamed: #author) contentString]					ifFalse: ['''']); cr;			show: ''Description: '', ((e firstTagNamed: #description) contentString); cr; cr.			].An item will now look like:	Date: Sun, 02 May 2010 20:23:49 +0000	Title: HelpSystem-Core-tbn.46.mcz	Author: Torsten Bergmann <Torsten.Bergmann@astares.de>	Description: throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:35'!pages	^# (dataRetrieval)! !"Help-Squeak-Project"!!ContextPart methodsFor: 'private' stamp: 'eem 5/23/2010 14:13' prior: 50837502!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	theMethod flushCache.	selector flushCache.	^aReceiver perform: selector withArguments: arguments! !"Kernel"!!Parser methodsFor: 'primitives' stamp: 'ar 5/24/2010 20:41' prior: 54010073!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(args position = self properties selector numArgs) ifFalse:[		^self expected: 'Matching number of arguments'	].	(self matchToken:#')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn| | fn |		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !"Compiler"!SystemVersion setVersion!Smalltalk cleanUp: true.!----SNAPSHOT----{24 May 2010 . 8:51:58 pm} Squeak4.2-10160-alpha.image priorSource: 382!Smalltalk cleanUp: true!----SNAPSHOT----{24 May 2010 . 8:52:41 pm} Squeak4.2-10160-alpha.image priorSource: 326247!----QUIT/NOSAVE----{24 May 2010 . 8:52:46 pm} Squeak4.2-10160-alpha.image priorSource: 326363!