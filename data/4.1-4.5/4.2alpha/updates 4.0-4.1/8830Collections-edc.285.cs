"Change Set:		8830Collections-edc.285Collections-edc.285:-enh Add String > beginsWithAnyOf:Collections-nice.273:Simplify asLegalSelectorCollections-nice.274:Simplify asLegalSelectorCollections-ar.275:Preserve findElementOrNil: for compatibility with external packages (i.e., extension methods in Dictionary etc).Collections-dtl.276:Preserve #fullCheck for compatibility with external packages (i.e., extension methods in Dictionary etc). Important for SystemTracing package loading.Collections-ul.277:- code criticsCollections-ar.278:Fix for withNoLineLongerThan: bug.Collections-nice.279:remove a useless fixTempsfast-up #withInternetLineEndings a bitfast-up #withSqueakLineEndings substantiallyadd a fast #withUnixLineEndingsCollections-nice.280:Fast-up linesDo: & coSame idea than withSqueakLineEndingsCollections-nice.281:Remove alternate-syntax remnants #dialect and #withStyleFor:do:It's useless to provide a backward hook since so many things lack in current image.No sender, single implementors, not maintained for years, no use to deprecate either.Collections-ul.282:In the HashedCollection hierarchy:- cosmetic changes: use #ifNotNil: if possible- use unary symbols instead of blocks with a single unary send- removed unnecessary line from #atRandom- restored correct compatibility method for #fullCheckIn Dictionary:- make sure that #associationsSelect: works with PluggableDictionary by using #copyEmpty instead of #species + #new- deprecated #keyForIdentity:, because it's similar to #keyAtIdentityValue:ifAbsent:In WeakKeyDictionary:- #rehash throws away nil keys, so we don't have to iterate twice over array- don't let the key go away in #noCheckNoGrowFillFrom:In WeakKeyToCollectionDictionary:- don't let the key go away in #noCheckNoGrowFillFrom:- removed #finalizeValues because it became same as superIn WeakSet:- #do:after: doesn't skip the first element if anElement is nil- speed up #slowSize- don't rehash twice in #grow, just count the occupied slots first with #slowSizeOther:- simplified a few KeyedSet's  methods- added #collect: to PluggableDictionary (super doesn't copy the blocks)Collections-ul.284:- fix: ignore Byte Order Mark in ByteString >> #utf8ToSqueak"!!IdentityDictionary methodsFor: 'accessing' stamp: 'ul 1/25/2010 19:02'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	^super keyAtIdentityValue: value ifAbsent: exceptionBlock! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 23:36'!withUnixLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single LF."	| cr lf inPos outPos outString newOutPos indexLF indexCR |	cr := Character cr.	indexCR := self indexOf: cr startingAt: 1.	indexCR = 0 ifTrue: [^self].		lf := Character linefeed.	indexLF := self indexOf: lf startingAt: 1.	indexLF = 0 ifTrue: [^self copy replaceAll: cr with: lf].	inPos := outPos := 1.	outString := String new: self size.	["check if next CR is before next LF or if there are no more LF"	(indexLF = 0 or: [indexCR < indexLF])		ifTrue: [			newOutPos := outPos + 1 + indexCR - inPos.			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos - 1 put: lf.			outPos := newOutPos.			1 + indexCR = indexLF				ifTrue: ["Caught a CR-LF pair"					inPos := 1 + indexLF.					indexLF := self  indexOf: lf startingAt: inPos]				ifFalse: [inPos := 1 + indexCR].			indexCR := self indexOf: cr startingAt: inPos]		ifFalse: [			newOutPos := outPos + 1 + indexLF - inPos.			outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.			outPos := newOutPos.			inPos := 1 + indexLF.			indexLF := self indexOf: lf startingAt: inPos].	indexCR = 0]		whileFalse.	"no more CR line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos - 1! !!Set methodsFor: 'private' stamp: 'ul 1/25/2010 19:57'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			array				at: (self scanForEmptySlotFor: object)				put: object ] ]! !!WeakSet methodsFor: 'private' stamp: 'ul 1/25/2010 22:31'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			object == flag ifFalse: [ 				array					at: (self scanForEmptySlotFor: object)					put: object.				tally := tally + 1 ] ] ]! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 1/25/2010 20:06'!finalizeValues: finiObjects	"Remove all associations with key == nil and value is in finiObjects.	This method is folded with #rehash for efficiency."		| oldArray |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do: [ :index |		(oldArray at: index) ifNotNil: [ :association |			association key ifNotNil: [ :key | "Don't let the key go away"				(finiObjects includes: association value) ifFalse: [					array 						at: (self scanForEmptySlotFor: key) 						put: association.					tally := tally + 1 ] ] ] ]! !!WeakSet methodsFor: 'private' stamp: 'ul 1/25/2010 22:30'!grow	"Grow the elements array if needed.	Since WeakSets just nil their slots, a lot of the occupied (in the eyes of the set) slots are usually empty. Doubling size if unneeded can lead to BAD performance, therefore we see if reassigning the <live> elements to a Set of similiar size leads to a sufficiently (50% used here) empty set first"		tally // 2 < self slowSize		ifTrue: [ super grow ]		ifFalse: [ self rehash ]! !!WeakSet methodsFor: 'private' stamp: 'ul 1/25/2010 22:31'!growTo: anInteger	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements := array.	array := WeakArray new: anInteger withAll: flag.	self noCheckNoGrowFillFrom: oldElements! !!HashedCollection methodsFor: 'accessing' stamp: 'ul 1/25/2010 18:14'!atRandom: aGenerator	"Answer a random element of the receiver. Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."		| rand |	self emptyCheck.	rand := aGenerator nextInt: self size.	self doWithIndex: [ :each :index |		index = rand ifTrue: [ ^each ] ]! !!KeyedSet methodsFor: 'adding' stamp: 'ul 1/25/2010 22:10'!member: newObject	"Include newObject as one of the receiver's elements, if already exists just return it"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: (keyBlock value: newObject).	(array at: index) ifNotNil: [ :element | ^element ].	self atNewIndex: index put: newObject.	^ newObject! !!WeakSet methodsFor: 'adding' stamp: 'ul 11/20/2009 17:47'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index element |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: newObject.	((element := array at: index) == flag or: [ element == nil ])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!ByteString methodsFor: 'converting' stamp: 'ul 1/29/2010 00:48'!utf8ToSqueak	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	Latin1ToUtf8Map ifNil:[^super utf8ToSqueak]. "installation guard"	lastIndex := 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self].	outStream := (String new: self size) writeStream.	[outStream next: nextIndex-lastIndex putAll: self startingAt: lastIndex.	byte1 := self byteAt: nextIndex.	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte3 := self byteAt: (nextIndex := nextIndex+1).		(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)			+ (byte3 bitAnd: 63)].	(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte3 := self byteAt: (nextIndex := nextIndex+1).		(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte4 := self byteAt: (nextIndex := nextIndex+1).		(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +						((byte2 bitAnd: 63) bitShift: 12) + 						((byte3 bitAnd: 63) bitShift: 6) +						(byte4 bitAnd: 63)].	unicode ifNil:[^self]. "invalid UTF-8; presume Latin-1"	unicode = 16rFEFF ifFalse: [ "Skip byte order mark"		outStream nextPut: (Unicode value: unicode) ].	lastIndex := nextIndex + 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0] whileFalse.	outStream next: self size-lastIndex+1 putAll: self startingAt: lastIndex.	^outStream contents! !!KeyedSet methodsFor: 'accessing' stamp: 'ul 1/25/2010 21:03'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	^(array at: (self scanFor: key)) ifNil: [ aBlock value ]! !!WeakSet methodsFor: 'testing' stamp: 'ul 1/25/2010 22:24'!includes: anObject 		^(array at: (self scanFor: anObject))		ifNil: [ false ]		ifNotNil: [ :object | object ~~ flag ]! !!Dictionary methodsFor: 'private' stamp: 'ul 1/25/2010 18:58'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			array				at: (self scanForEmptySlotFor: association key)				put: association ] ]! !!KeyedSet methodsFor: 'private' stamp: 'ul 1/25/2010 22:11'!initialize: n	super initialize: n.	keyBlock := #key! !!Collection methodsFor: 'enumerating' stamp: 'nice 1/1/2010 18:00'!do: aBlock displayingProgress: aStringOrBlock every: msecs	"Enumerate aBlock displaying progress information. 	If the argument is a string, use a static label for the process. 	If the argument is a block, evaluate it with the element to retrieve the label.	The msecs argument ensures that updates happen at most every msecs.	Example:		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress:[:aClass| 'Processing ', aClass name]			every: 0.		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress:[:aClass| 'Processing ', aClass name]			every: 100.	"	| size labelBlock count oldLabel lastUpdate |	labelBlock := aStringOrBlock isString 		ifTrue:[[:item| aStringOrBlock]] 		ifFalse:[aStringOrBlock].	oldLabel := nil.	count := lastUpdate := 0.	size := self size.	'' displayProgressAt: Sensor cursorPoint from: 0 to: size during:[:bar |		self do:[:each| | newLabel |			"Special handling for first and last element"			(count = 0 or:[count+1 = size 				or:[(Time millisecondsSince: lastUpdate) >= msecs]]) ifTrue:[					bar value: count.					oldLabel = (newLabel := labelBlock value: each) ifFalse:[					ProgressNotification signal: '' extra: (oldLabel := newLabel).				].				lastUpdate := Time millisecondClockValue.			].			aBlock value: each.			count := count + 1.	]]! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 1/25/2010 20:02'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."		self associationsDo: [ :association |		(association key) ifNotNil: [ :key | "Don't let the key go away"			aBlock value: key ] ].! !!Dictionary methodsFor: 'adding' stamp: 'ul 1/25/2010 18:26'!add: anAssociation	| index |	index := self scanFor: anAssociation key.	(array at: index)		ifNil: [ self atNewIndex: index put: anAssociation ]		ifNotNil: [ :element |	element value: anAssociation value ].	^anAssociation! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'nice 1/11/2010 20:56'!limitingBlock: aBlock	"The limitingBlock is evaluated with a line to check if this line terminates the stream"	limitingBlock := aBlock.	self updatePosition! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 23:37'!withSqueakLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single CR."	| cr lf inPos outPos outString newOutPos indexLF indexCR |	lf := Character linefeed.	indexLF := self indexOf: lf startingAt: 1.	indexLF = 0 ifTrue: [^self].		cr := Character cr.	indexCR := self indexOf: cr startingAt: 1.	indexCR = 0 ifTrue: [^self copy replaceAll: lf with: cr].	inPos := outPos := 1.	outString := String new: self size.	["check if next CR (if any) is before next LF"	(indexCR > 0 and: [indexCR < indexLF])		ifTrue: [			newOutPos := outPos + 1 + indexCR - inPos.			outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.			outPos := newOutPos.			1 + indexCR = indexLF				ifTrue: ["Caught a CR-LF pair"					inPos := 1 + indexLF.					indexLF := self  indexOf: lf startingAt: inPos]				ifFalse: [inPos := 1 + indexCR].			indexCR := self indexOf: cr startingAt: inPos]		ifFalse: [			newOutPos := outPos + 1 + indexLF - inPos.			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos - 1 put: cr.			outPos := newOutPos.			inPos := 1 + indexLF.			indexLF := self indexOf: lf startingAt: inPos].	indexLF = 0]		whileFalse.	"no more LF line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos - 1! !!Text methodsFor: 'emphasis' stamp: 'nice 1/10/2010 17:55'!emphasisAt: characterIndex	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes |	self size = 0 ifTrue: [^ 0].	"null text tolerates access"	attributes := runs at: characterIndex.	^attributes inject: 0 into: 		[:emph :att | emph bitOr: att emphasisCode].	! !!WeakSet methodsFor: 'public' stamp: 'ul 1/25/2010 22:20'!do: aBlock after: anElement	| startIndex |	tally = 0 ifTrue: [ ^self ].	startIndex := anElement		ifNil: [ 0 ]		ifNotNil: [ self scanFor: anElement ].	startIndex + 1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				aBlock value: object ] ] ]! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 22:43'!withInternetLineEndings	"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self class		new: self size * 16 // 15 "provisions for CR-LF pairs"		streamContents: [ :stream |			self lineIndicesDo: [:start :endWithoutDelimiters :end |				stream next: 1 + endWithoutDelimiters - start putAll: self startingAt: start.				endWithoutDelimiters = end ifFalse: [					stream crlf ] ] ]! !!WeakSet methodsFor: 'removing' stamp: 'ul 9/23/2009 21:14'!remove: oldObject ifAbsent: aBlock	| index |	index := self scanFor: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally := tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!String methodsFor: 'comparing' stamp: 'edc 1/29/2010 06:55'!beginsWithAnyOf: aCollection	aCollection do:[:suffix|		(self beginsWith: suffix) ifTrue:[^true].	].	^false! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 1/25/2010 20:08'!finalizeValues	"remove all nil keys and rehash the receiver afterwards"		self rehash! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 1/25/2010 22:45'!goodPrimeAtLeast: lowerLimit	"Answer the next good prime >= lowerlimit.	If lowerLimit is larger than the largest known good prime,	just make it odd."		| primes low mid high prime |	primes := self goodPrimes.	low := 1.	high := primes size.	lowerLimit > (primes at: high) ifTrue: [		^lowerLimit bitOr: 1 ].	[ high - low <= 1 ] whileFalse: [		mid := high + low // 2.		prime := primes at: mid.		prime = lowerLimit ifTrue: [ ^prime ].		prime < lowerLimit			ifTrue: [ low := mid ]			ifFalse: [ high := mid ] ].	(primes at: low) >= lowerLimit ifTrue: [ ^primes at: low ].	^primes at: high! !!Dictionary methodsFor: 'accessing' stamp: 'ul 1/25/2010 18:24'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index |	index := self scanFor: key.	(array at: index)		ifNil: [ self atNewIndex: index put: (Association key: key value: anObject) ]		ifNotNil: [ :association | association value: anObject ].	^anObject! !!Collection methodsFor: 'enumerating' stamp: 'ul 1/11/2010 07:42'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result |	result := PluggableDictionary integerDictionary.	self do: 		[:e | 		| key |		key := keyBlock value: e.		(result includesKey: key)			ifFalse: [result at: key put: OrderedCollection new].		(result at: key)			add: e].	^result select: selectBlock! !!KeyedSet methodsFor: 'accessing' stamp: 'ul 1/25/2010 21:04'!keysSorted	^self keys sort! !!String methodsFor: 'accessing' stamp: 'nice 1/19/2010 00:29'!lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	nextCR := self indexOf: cr startingAt: 1.	lf := Character lf.	nextLF := self indexOf: lf startingAt: 1.	[ start <= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					nextLF := self indexOf: lf startingAt: start ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					nextCR := self indexOf: cr startingAt: start.					nextLF := self indexOf: lf startingAt: start ]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					nextCR := self indexOf: cr startingAt: start ]]]! !!WeakSet methodsFor: 'public' stamp: 'ul 1/25/2010 22:25'!slowSize	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	| count |	count := 0.	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				count := count + 1 ] ] ].	^tally := count! !!HashedCollection methodsFor: 'compatibility' stamp: 'ar 1/8/2010 09:02'!findElementOrNil: anObject	"This method has been superseeded by #scanFor:	It is here for compatibility with external packages only."	^self scanFor: anObject! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 1/25/2010 19:59'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do:[ :index |		(anArray at: index) ifNotNil: [ :association |			association key ifNotNil: [ :key | "Don't let the key go away"				array					at: (self scanForEmptySlotFor: key)					put: association.				tally := tally + 1 ] ] ]! !!WeakKeyToCollectionDictionary methodsFor: 'as yet unclassified' stamp: 'ul 1/25/2010 20:01'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association key ifNotNil: [ :key | "Don't let the key go away"				| cleanedValue |				(cleanedValue := association value copyWithout: nil) isEmpty 					ifFalse: [						association value: cleanedValue.						array							at: (self scanForEmptySlotFor: key)							put: association.						tally := tally + 1 ] ] ] ]! !!HashedCollection class methodsFor: 'initialization' stamp: 'ul 1/25/2010 19:55'!rehashAll	"HashedCollection rehashAll"				self allSubclassesDo: #rehashAllInstances! !!HashedCollection methodsFor: 'compatibility' stamp: 'ul 1/25/2010 18:07'!fullCheck	"This is a private method, formerly implemented in Set, that is no longer required.	It is here for compatibility with external packages only."	"Keep array at least 1/4 free for decent hash behavior"		array size * 3 < (tally * 4) ifTrue: [ self grow ]! !!KeyedSet methodsFor: 'private' stamp: 'ul 1/25/2010 19:57'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			array				at: (self scanForEmptySlotFor: (keyBlock value: object))				put: object ] ]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 1/25/2010 18:27'!associationsSelect: aBlock 	"Evaluate aBlock with each of my associations as the argument. Collect	into a new dictionary, only those associations for which aBlock evaluates	to true."	| newCollection |	newCollection := self copyEmpty.	self associationsDo: [ :each | 		(aBlock value: each) ifTrue: [ newCollection add: each ] ].	^newCollection! !!String methodsFor: 'converting' stamp: 'ar 1/11/2010 19:55'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				[spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [lineStart + aNumber + 1].				spacePosition - lineStart <= (aNumber min: endWithoutDelimiters - lineStart)]						whileTrue: [lineEnd := spacePosition].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 1/25/2010 18:22'!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."	tally = 0 ifTrue: [ ^self].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :element |			aBlock value: element ] ]! !!Set methodsFor: 'enumerating' stamp: 'ul 1/25/2010 21:00'!do: aBlock 	tally = 0 ifTrue: [ ^self ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :element |			aBlock value: element ] ]! !!Dictionary methodsFor: 'accessing' stamp: 'ul 1/25/2010 18:56'!keyForIdentity: anObject	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"	self deprecated: 'Use #keyAtIdentityValue:ifAbsent:'.	^self keyAtIdentityValue: anObject ifAbsent: nil! !!WeakSet methodsFor: 'enumerating' stamp: 'ul 1/25/2010 22:16'!do: aBlock	tally = 0 ifTrue: [ ^self ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object  == flag ifFalse: [				aBlock value: object ] ] ]! !!String methodsFor: 'converting' stamp: 'nice 1/5/2010 18:31'!asLegalSelector	| toUse |	toUse := self select: [:char | char isAlphaNumeric].	(toUse size == 0 or: [toUse first isLetter not])		ifTrue:		[toUse := 'v', toUse].	^ toUse withFirstCharacterDownshifted! !!WeakSet methodsFor: 'accessing' stamp: 'ul 10/1/2009 03:20'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| element |	^(element  := array at: (self scanFor: anObject)) == flag		ifFalse: [ element ]! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 1/25/2010 20:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."		| index |	key ifNil: [ ^anObject ].	index := self scanFor: key.	(array at: index)		ifNil: [ self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject) ]		ifNotNil: [ :association | association value: anObject ].	^anObject! !!WeakSet methodsFor: 'enumerating' stamp: 'ul 1/25/2010 22:14'!collect: aBlock	| newSet |	newSet := self species new: self size.	tally = 0 ifTrue: [ ^newSet ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				newSet add: (aBlock value: object) ] ] ].	^newSet! !!HashedCollection class methodsFor: 'initialization' stamp: 'ul 1/25/2010 19:54'!rehashAllInstances	"Do not use #allInstancesDo: because rehash may create new instances."	self allInstances do: #rehash! !!WeakSet methodsFor: 'accessing' stamp: 'SqR 8/23/2000 15:12'!size	"Careful!! Answer the maximum amount	of elements in the receiver, not the	exact amount"	^tally! !!PluggableDictionary methodsFor: 'enumerating' stamp: 'ul 1/25/2010 18:40'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."		| newCollection |	newCollection := (self species new: self size)		hashBlock: hashBlock;		equalBlock: equalBlock;		yourself.	self associationsDo: [ :each |		newCollection at: each key put: (aBlock value: each value) ].	^newCollection! !Stream removeSelector: #dialect!Stream removeSelector: #withStyleFor:do:!WeakKeyToCollectionDictionary removeSelector: #finalizeValues!