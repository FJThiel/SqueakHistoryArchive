"Change Set:		8642Morphic-nice.276Morphic-nice.276:Cosmetic: move or remove a few temps inside closures"!!PolygonMorph methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:11'!drawBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas."	"NOTE: Much of this code is also copied in  	drawDashedBorderOn:  	(should be factored)"	| bigClipRect style |	borderDashSpec		ifNotNil: [^ self drawDashedBorderOn: aCanvas usingEnds: anArray].	style := self borderStyle.	bigClipRect := aCanvas clipRect expandBy: self borderWidth + 1 // 2.	self		lineSegmentsDo: [:p1 :p2 | | p2i p1i | 			p1i := p1 asIntegerPoint.			p2i := p2 asIntegerPoint.			self hasArrows				ifTrue: ["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back								or: [arrows == #both])							and: [p1 = vertices first])						ifTrue: [p1i := anArray first asIntegerPoint].					((arrows == #forward								or: [arrows == #both])							and: [p2 = vertices last])						ifTrue: [p2i := anArray last asIntegerPoint]].			(closed					or: ["bigClipRect intersects: (p1i rect: p2i)  						optimized:"						((p1i min: p2i)							max: bigClipRect origin)							<= ((p1i max: p2i)									min: bigClipRect corner)])				ifTrue: [style						drawLineFrom: p1i						to: p2i						on: aCanvas]]! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!withProgressDo: aBlock	| safetyFactor totals trialRect delta targetOwner |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject := Project current.	formerWorld := World.	formerProcess := Processor activeProcess.	targetMorph		ifNil: [targetMorph := ProgressTargetRequestNotification signal].	targetMorph ifNil: [		trialRect := Rectangle center: Sensor cursorPoint extent: 80@80.		delta := trialRect amountToTranslateWithin: formerWorld bounds.		trialRect := trialRect translateBy: delta.		translucentMorph := TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		targetOwner := targetMorph owner.		translucentMorph := TranslucentProgessMorph new			setProperty: #morphicLayerNumber toValue: targetMorph morphicLayerNumber - 0.1;			bounds: targetMorph boundsInWorld;			openInWorld: targetMorph world.	].	stageCompleted := 0.	safetyFactor := 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	translucentMorph hide.	targetOwner ifNotNil: [targetOwner hide].	totals := self loadingHistoryDataForKey: 'total'.	newRatio := 1.0.	estimate := totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start := Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note | | stageCompletedString |		translucentMorph show.		targetOwner ifNotNil: [targetOwner show].		note extraParam ifNotNil:[self addProgressDecoration: note extraParam].		stageCompletedString := (note messageText findTokens: ' ') first.		stageCompleted := (stageCompletedString copyUpTo: $:) asNumber.		cumulativeStageTime := Time millisecondClockValue - start max: 1.		prevData := self loadingHistoryDataForKey: stageCompletedString.		prevData isEmpty ifFalse: [			newRatio := (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self 			loadingHistoryAt: stageCompletedString 			add: cumulativeStageTime.		translucentMorph 			setProperty: #progressStageNumber 			toValue: stageCompleted + 1.		note resume.	].	stageCompleted := 999.	"we may or may not get here"! !!TheWorldMenu class methodsFor: 'open-menu registry' stamp: 'nice 12/27/2009 03:11'!loadSqueakMap	"Load the externally-maintained SqueakMap package if it is not already loaded.  Based on code by GÃ¶ran Hultgren"	| server |	Socket initializeNetwork.	server := #('map1.squeakfoundation.org' 'map2.squeakfoundation.org' 'map.squeak.org' 'map.bluefish.se' 'marvin.bluefish.se:8000')		detect: [:srv | | addr answer |			addr := NetNameResolver addressForName: (srv upTo: $:) timeout: 5.			addr notNil and: [				answer := HTTPSocket httpGet: ('http://', srv, '/sm/ping').				answer isString not and: [answer contents = 'pong']]]		ifNone: [^ self inform: 'Sorry, no SqueakMap master server responding.'].	server ifNotNil: ["Ok, found an SqueakMap server"		ChangeSet newChangesFromStream:			((('http://', server, '/sm/packagebyname/squeakmap/downloadurl')			asUrl retrieveContents content) asUrl retrieveContents content unzipped			readStream)		named: 'SqueakMap']! !!MorphicModel methodsFor: 'compilation' stamp: 'nice 12/27/2009 20:13'!compilePropagationMethods		(self class organization listAtCategoryNamed: 'private - propagation' asSymbol)		do: [:sel | | varName |			varName := sel allButLast.			model class compilePropagationForVarName: varName slotName: slotName]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nice 12/27/2009 20:14'!findAPreferencesPanel: evt	"Locate a Preferences Panel, open it, and bring it to the front.  Create one if necessary"	self findAWindowSatisfying:		[:aWindow | aWindow model isKindOf: PreferenceBrowser] orMakeOneUsing:			[ | aPanel |			aPanel := PreferenceBrowserMorph withModel: PreferenceBrowser new.			"Note -- we don't really want the openInHand -- but owing to some annoying			difficulty, if we don't, we get the wrong width.  Somebody please clean this up"			^ aPanel openInHand]! !!TheWorldMenu methodsFor: 'construction' stamp: 'nice 12/27/2009 03:11'!fillIn: aMenu from: dataForMenu	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:			nil							Indicates to add a line			first element is symbol		Add updating item with the symbol as the wording selector			second element is a list		second element has the receiver and selector			first element is a string		Add menu item with the string as its wording			second element is a list		second element has the receiver and selector			a third element exists		Use it as the balloon text			a fourth element exists		Use it as the enablement selector (updating case only)"		dataForMenu do: [ :itemData | | item |		itemData ifNil: [aMenu addLine] ifNotNil:			[item := (itemData first isKindOf: Symbol)				ifTrue: 					[aMenu 						addUpdating: itemData first 						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}]				 ifFalse:					[aMenu 						add: itemData first translated						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}].			itemData size >= 3 ifTrue:				[aMenu balloonTextForLastItem: itemData third translated.			itemData size >= 4 ifTrue:				[item enablementSelector: itemData fourth]]]].	^ aMenu! !!EventHandler methodsFor: 'printing' stamp: 'nice 12/27/2009 03:11'!printOn: aStream 	| recipients |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'doubleClickSelector' 'keyStrokeSelector') 		do: 			[:aName | | aVal | 			(aVal := self instVarNamed: aName) notNil 				ifTrue: [aStream nextPutAll: '; ' , aName , '=' , aVal]].	(recipients := self allRecipients) notEmpty 		ifTrue: 			[aStream nextPutAll: ' recipients: '.			recipients printOn: aStream]! !!SketchMorph methodsFor: 'menu' stamp: 'nice 12/27/2009 03:11'!editDrawingIn: aPasteUpMorph forBackground: forBackground	"Edit an existing sketch."	| w bnds sketchEditor rotCenter aPaintTab aWorld aPaintBox |	self world assureNotPaintingElse: [^self].	w := aPasteUpMorph world.	w prepareToPaint.	w displayWorld.	self visible: false.	bnds := forBackground 				ifTrue: [aPasteUpMorph boundsInWorld]				ifFalse: 					[bnds := self boundsInWorld expandBy: 60 @ 60.					(aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds]. 	sketchEditor := SketchEditorMorph new.	forBackground 		ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor 		initializeFor: self		inBounds: bnds		pasteUpMorph: aPasteUpMorph.	rotCenter := self rotationCenter.	sketchEditor afterNewPicDo: 			[:aForm :aRect | | tfx | 			self visible: true.			self form: aForm.			tfx := aPasteUpMorph transformFrom: aPasteUpMorph world.			self topRendererOrSelf position: (tfx globalPointToLocal: aRect origin).			self rotationStyle: sketchEditor rotationStyle.			self forwardDirection: sketchEditor forwardDirection.			(rotCenter notNil and: [(rotCenter = (0.5 @ 0.5)) not]) ifTrue:				[self rotationCenter: rotCenter].			(aPaintTab := (aWorld := self world) paintingFlapTab) 				ifNotNil: [aPaintTab hideFlap]				ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]].			self presenter drawingJustCompleted: self.			forBackground ifTrue: [self goBehind	"shouldn't be necessary"]]		ifNoBits: 			[ | pal |"If no bits drawn.  Must keep old pic.  Can't have no picture"			self visible: true.			aWorld := self currentWorld.			"sometimes by now I'm no longer in a world myself, but we still need				 to get ahold of the world so that we can deal with the palette"			((pal := aPasteUpMorph standardPalette) notNil and: [pal isInWorld]) 				ifTrue: 					[(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete].					pal viewMorph: self]				ifFalse: 					[(aPaintTab := (aWorld := self world) paintingFlapTab) 						ifNotNil: [aPaintTab hideFlap]						ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]]]]! !!MenuItemMorph methodsFor: 'events' stamp: 'nice 12/27/2009 03:10'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| w |	self isEnabled ifFalse: [^ self].	target class == HandMorph ifTrue: [(self notObsolete) ifFalse: [^ self]].	owner ifNotNil:[self isStayUpItem ifFalse:[		self flag: #workAround. "The tile system invokes menus straightforwardly so the menu might not be in the world."		(w := self world) ifNotNil:[			owner deleteIfPopUp: evt.			"Repair damage before invoking the action for better feedback"			w displayWorldSafely]]].	selector ifNil:[^self].	Cursor normal showWhile: [ | selArgCount |  "show cursor in case item opens a new MVC window"		(selArgCount := selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]].! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!initialDirectoryList	| dirList |	dirList := (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList := Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList := dirList,(		ServerDirectory serverNames collect: [ :n | | nameToShow dir | 			dir := ServerDirectory serverNamed: n.			nameToShow := n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!WorldState methodsFor: 'initialization' stamp: 'nice 12/27/2009 01:33'!stepListSortBlock	^[ :stepMsg1 :stepMsg2 | 		stepMsg1 scheduledTime <= stepMsg2 scheduledTime.	]! !!PolygonMorph methodsFor: 'geometry' stamp: 'nice 12/27/2009 03:11'!closestPointTo: aPoint 	| closestPoint minDist |	closestPoint := minDist := nil.	self lineSegmentsDo: 			[:p1 :p2 | | dist curvePoint | 			curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.			dist := curvePoint dist: aPoint.			(closestPoint isNil or: [dist < minDist]) 				ifTrue: 					[closestPoint := curvePoint.					minDist := dist]].	^closestPoint! !!SimpleHierarchicalListMorph methodsFor: 'scrolling' stamp: 'nice 12/27/2009 03:10'!hUnadjustedScrollRange"Return the width of the widest item in the list"	| max count |	max := 0.	count := 0.	scroller submorphsDo: [ :each | | stringW right |		stringW := each font widthOfStringOrText: each contents.		right := (each toggleRectangle right + stringW + 10).		max := max max: right.		"NOTE: need to optimize this method by caching list item morph widths (can init that cache most efficiently in the #list: method before the item widths are reset to 9999).  For now, just punt on really long lists"		((count := count + 1) > 200) ifTrue:[ ^max * 3].	].	^max ! !!Morph methodsFor: 'submorphs-accessing' stamp: 'nice 12/27/2009 03:10'!submorphNamed: aName ifNone: aBlock 	"Find the first submorph with this name, or a button with an action selector of that name"		self submorphs do: [:p | p knownName = aName ifTrue: [^p]].	self submorphs do: 			[:button | | sub args | 			(button respondsTo: #actionSelector) 				ifTrue: [button actionSelector == aName ifTrue: [^button]].			((button respondsTo: #arguments) and: [(args := button arguments) notNil]) 				ifTrue: [(args at: 2 ifAbsent: [nil]) == aName ifTrue: [^button]].			(button isAlignmentMorph) 				ifTrue: [(sub := button submorphNamed: aName ifNone: [nil]) ifNotNil: [^sub]]].	^aBlock value! !!Morph methodsFor: 'submorphs-accessing' stamp: 'nice 12/27/2009 03:10'!morphsAt: aPoint behind: aMorph unlocked: aBool 	"Return all morphs at aPoint that are behind frontMorph; if aBool is true return only unlocked, visible morphs."	| isBack all tfm |	all := (aMorph isNil or: [owner isNil]) 				ifTrue: 					["Traverse down"					(self fullBounds containsPoint: aPoint) ifFalse: [^#()].					(aBool and: [self isLocked or: [self visible not]]) ifTrue: [^#()].					nil]				ifFalse: 					["Traverse up"					tfm := self transformedFrom: owner.					all := owner 								morphsAt: (tfm localPointToGlobal: aPoint)								behind: self								unlocked: aBool.					WriteStream with: all].	isBack := aMorph isNil.	self submorphsDo: 			[:m | | found | 			isBack 				ifTrue: 					[tfm := m transformedFrom: self.					found := m 								morphsAt: (tfm globalPointToLocal: aPoint)								behind: nil								unlocked: aBool.					found notEmpty 						ifTrue: 							[all ifNil: [all := WriteStream on: #()].							all nextPutAll: found]].			m == aMorph ifTrue: [isBack := true]].	(isBack and: [self containsPoint: aPoint]) 		ifTrue: 			[all ifNil: [^Array with: self].			all nextPut: self].	^all ifNil: [#()] ifNotNil: [all contents]! !!Morph methodsFor: 'object fileIn' stamp: 'nice 12/27/2009 03:10'!convertAugust1998: varDict using: smartRefStrm 	"These variables are automatically stored into the new instance 	('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ). 	This method is for additional changes. Use statements like (foo := 	varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information 	in ('eventHandler' 'properties' 'costumee' )"	"This method moves all property variables as well as 	eventHandler, and costumee into a morphicExtension."	"Move refs to eventhandler and costumee into extension"		(varDict at: 'eventHandler') isNil 		ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') isNil 		ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') isNil 		ifFalse: 			[(varDict at: 'properties') keys do: 					[:key | | propVal | 					"Move property extensions into extension"					propVal := (varDict at: 'properties') at: key.					propVal ifNotNil: 							[key == #possessive 								ifTrue: [propVal == true ifTrue: [self bePossessive]]								ifFalse: 									[key ifNotNil: [self assureExtension convertProperty: key toValue: propVal]]]]]! !!ProportionalLayout methodsFor: 'layout' stamp: 'nice 12/27/2009 03:11'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	| min |	min := 0@0.	aMorph submorphsDo:[:m| | extent frame |		"Map the minimal size of the child through the layout frame.		Note: This is done here and not in the child because its specific		for proportional layouts. Perhaps we'll generalize this for table		layouts but I'm not sure how and when."		extent := m minExtent.		frame := m layoutFrame.		frame ifNotNil:[extent := frame minExtentFrom: extent].		min := min max: extent].	^min! !!WorldState methodsFor: 'object fileIn' stamp: 'nice 12/27/2009 03:11'!convertStepList	"Convert the old-style step list (an Array of Arrays) into the new-style StepMessage heap"	| newList |	(stepList isKindOf: Heap) 		ifTrue: 			[^stepList sortBlock: self stepListSortBlock	"ensure that we have a cleaner block"].	newList := Heap sortBlock: self stepListSortBlock.	stepList do: 			[:entry | | wakeupTime morphToStep | 			wakeupTime := entry second.			morphToStep := entry first.			newList add: (StepMessage 						scheduledAt: wakeupTime						stepTime: nil						receiver: morphToStep						selector: #stepAt:						arguments: nil)].	stepList := newList! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'nice 12/27/2009 03:10'!doButtonAction: evt		"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	target ifNil: [^self].	actionSelector ifNil: [^self].	Cursor normal showWhile: [ | moreArgs |		moreArgs := actionSelector numArgs > arguments size ifTrue: [			arguments copyWith: evt		] ifFalse: [			arguments		].		target perform: actionSelector withArguments: moreArgs	]! !!PasteUpMorph methodsFor: 'project' stamp: 'nice 12/27/2009 20:16'!releaseSqueakPages		"If this world has a book with SqueakPages, then clear the SqueakPageCache"	submorphs do: [:sub | | uu |		(sub isKindOf: BookMorph) ifTrue: [		uu := sub valueOfProperty: #url ifAbsent: [nil].		uu ifNotNil: [(SqueakPageCache pageCache includesKey: uu) ifTrue: [				SqueakPageCache initialize]]]].	"wipe the cache"! !!SystemProgressMorph methodsFor: 'private' stamp: 'nice 12/27/2009 03:11'!label: shortDescription min: minValue max: maxValue	| slot range barSize lastRefresh |	((range := maxValue - minValue) < 0 or: [(slot := self nextSlotFor: shortDescription) = 0])		ifTrue: [^[:barVal| 0 ]].	range <= 0 ifTrue: [self removeMorph: (bars at: slot)].	self recenter.	self openInWorld.	barSize := -1. "Enforces a inital draw of the morph"	lastRefresh := 0.	^[:barVal | | newBarSize |		barVal isString ifTrue: [			self setLabel: barVal at: slot.			self currentWorld displayWorld].		(barVal isNumber and: [range >= 1 and: [barVal between: minValue and: maxValue]]) ifTrue: [			newBarSize := (barVal - minValue / range * BarWidth) truncated.			newBarSize = barSize ifFalse: [				barSize := newBarSize.				(bars at: slot) barSize: barSize.				Time primMillisecondClock - lastRefresh > 25 ifTrue: [					self currentWorld displayWorld.					lastRefresh := Time primMillisecondClock]]].		slot]! !!FileList methodsFor: 'own services' stamp: 'nice 12/27/2009 03:10'!servicesFromSelectorSpecs: symbolArray	"Answer an array of services represented by the incoming symbols, eliminating any that do not have a currently-registered service.  Pass the symbol #- along unchanged to serve as a separator between services"	"FileList new servicesFromSelectorSpecs: #(fileIn: fileIntoNewChangeSet: browseChangesFile:)"	| services col | 	col := OrderedCollection new.	services := self class allRegisteredServices, (self myServicesForFile: #dummy suffix: '*').	symbolArray do: 		[:sel | | res | 			sel == #-				ifTrue:					[col add: sel]				ifFalse:					[res := services							detect: [:each | each selector = sel] ifNone: [nil].					res notNil							ifTrue: [col add: res]]].	^ col! !!TransformationMorph methodsFor: 'menu' stamp: 'nice 12/27/2009 20:21'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed pensDown myWorld refPos aPosition |	refPos := self referencePosition.	myWorld := self world.	oldHalo := self halo.	submorphs isEmpty ifTrue: [^ self delete].	aPosition := (owner submorphIndexOf: self) ifNil: [1].	unflexed := self firstSubmorph.	pensDown := OrderedCollection new.	self allMorphsDo:  "Note any pens down -- must not be down during the move"		[:m | | player |		((player := m player) notNil and: [player getPenDown]) ifTrue:			[m == player costume ifTrue:				[pensDown add: player.				player setPenDown: false]]].	self submorphs do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m asElementNumber: aPosition].	unflexed absorbStateFromRenderer: self.	pensDown do: [:p | p setPenDown: true].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	myWorld ifNotNil: [myWorld startSteppingSubmorphsOf: unflexed].	self delete.	unflexed referencePosition: refPos.	^ unflexed! !!TextEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 03:12'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName |	stringToSave := paragraph text string.	stringToSave size = 0 ifTrue: [^self inform: 'nothing to save.'].	parentWindow := model dependents 				detect: [:dep | dep isKindOf: SystemWindow]				ifNone: [nil].	labelToUse := parentWindow ifNil: ['Untitled']				ifNotNil: [parentWindow label].	suggestedName := nil.	#(#('Decompressed contents of: ' '.gz')) do: 			[:leaderTrailer | | lastIndex | 			"can add more here..."			(labelToUse beginsWith: leaderTrailer first) 				ifTrue: 					[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1								to: labelToUse size.					(labelToUse endsWith: leaderTrailer last) 						ifTrue: 							[suggestedName := suggestedName copyFrom: 1										to: suggestedName size - leaderTrailer last size]						ifFalse: 							[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].							(lastIndex = 0 or: [lastIndex = 1]) 								ifFalse: [suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil: [suggestedName := labelToUse , '.text'].	fileName := UIManager default request: 'File name?'				initialAnswer: suggestedName.	fileName isEmptyOrNil 		ifFalse: 			[(FileStream newFileNamed: fileName)				nextPutAll: stringToSave;				close]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 20:18'!inspectIt		self handleEdit:		[ | result |		result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [result inspect]]! !!TableLayout methodsFor: 'layout' stamp: 'nice 12/27/2009 03:11'!computeCellSizes: aMorph in: newBounds horizontal: aBool	"Step 1: Compute the minimum extent for all the children of aMorph"	| cells block minSize maxSize maxCell |	cells := WriteStream on: (Array new: aMorph submorphCount).	minSize := properties minCellSize asPoint.	maxSize := properties maxCellSize asPoint.	aBool ifTrue:[		minSize := minSize transposed.		maxSize := maxSize transposed].	maxCell := 0@0.	block := [:m| | size cell |		m disableTableLayout ifFalse:[			size := m minExtent asIntegerPoint.			cell := LayoutCell new target: m.			aBool ifTrue:[				cell hSpaceFill: m hResizing == #spaceFill.				cell vSpaceFill: m vResizing == #spaceFill.			] ifFalse:[				cell hSpaceFill: m vResizing == #spaceFill.				cell vSpaceFill: m hResizing == #spaceFill.				size := size transposed.			].			size := (size min: maxSize) max: minSize.			cell cellSize: size.			maxCell := maxCell max: size.			cells nextPut: cell]].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	^maxCell -> cells contents! !!Morph methodsFor: 'debug and other' stamp: 'nice 12/27/2009 03:10'!allStringsAfter: aSubmorph 	"return an OrderedCollection of strings of text in my submorphs.  If aSubmorph is non-nil, begin with that container."	| list ok |	list := OrderedCollection new.	ok := aSubmorph isNil.	self allMorphsDo: 			[:sub | | string | 			ok ifFalse: [ok := sub == aSubmorph].	"and do this one too"			ok 				ifTrue: 					[(string := sub userString) ifNotNil: 							[string isString ifTrue: [list add: string] ifFalse: [list addAll: string]]]].	^list! !!FileList2 class methodsFor: 'blue ui' stamp: 'nice 12/27/2009 03:11'!enableTypeButtons: typeButtons info: fileTypeInfo forDir: aDirectory	| foundSuffixes firstEnabled |	firstEnabled := nil.	foundSuffixes := (aDirectory ifNil: [ #()] ifNotNil: [ aDirectory fileNames]) collect: [ :each | (each findTokens: '.') last asLowercase].	foundSuffixes := foundSuffixes asSet.	fileTypeInfo with: typeButtons do: [ :info :button | | enableIt fileSuffixes |		fileSuffixes := info second.		enableIt := fileSuffixes anySatisfy: [ :patt | foundSuffixes includes: patt].		button 			setProperty: #enabled 			toValue: enableIt.		enableIt ifTrue: [firstEnabled ifNil: [firstEnabled := button]].	].	firstEnabled ifNotNil: [^firstEnabled mouseUp: nil].	typeButtons do: [ :each | each color: Color gray].! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!limitedSuperSwikiDirectoryList	| dirList localDirName localDir |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | | dir nameToShow | 		dir := ServerDirectory serverNamed: n.		dir isProjectSwiki ifTrue: [			nameToShow := n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	ServerDirectory localProjectDirectories do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)	].	"Make sure the following are always shown, but not twice"	localDirName := SecurityManager default untrustedUserDirectory.	localDir := FileDirectory on: localDirName.	((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)			ifFalse: [dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self)].	FileDirectory default pathName = localDirName			ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	(dirList anySatisfy: [:each | each withoutListWrapper acceptsUploads])		ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	^dirList! !!FileList2 class methodsFor: 'blue ui' stamp: 'nice 12/27/2009 03:11'!endingSpecs	"Answer a collection of specs to build the selective 'find anything' tool called by the Navigator. This version uses the services registry to do so."	"FileList2 morphicViewGeneralLoaderInWorld: World"	| categories specs rejects |	rejects := #(addFileToNewZip: compressFile: openInZipViewer: extractAllFrom: openOn:).	categories := #(		('Art' ('bmp' 'gif' 'jpg' 'jpeg' 'form' 'png' 'pcx' 'xbm' 'xpm' 'ppm' 'pbm'))		('Morphs' ('morph' 'morphs' 'sp'))		('Projects' ('extseg' 'project' 'pr'))		('MIDI' ('mid' 'midi'))		('Music' ('mp3'))		('Movies' ('movie' 'mpg' 'mpeg' 'qt' 'mov'))		('Flash' ('swf'))	).		"('Books' ('bo'))"		"('Code' ('st' 'cs'))"		"('TrueType' ('ttf'))"		"('3ds' ('3ds'))"		"('Tape' ('tape'))"		"('Wonderland' ('wrl'))"		"('HTML' ('htm' 'html'))"	categories first at: 2 put: ImageReadWriter allTypicalFileExtensions.	specs := OrderedCollection new.	categories do: [ :cat | | catSpecs catServices okExtensions services |		services := Dictionary new.		catSpecs := Array new: 3.		catServices := OrderedCollection new.		okExtensions := Set new.		cat second do: [ :ext | (FileList itemsForFile: 'fred.',ext) do: [ :i |			(rejects includes: i selector) ifFalse: [				okExtensions add: ext.				services at: i label put: i ]]].		services do: [ :svc | catServices add: svc ].		services isEmpty ifFalse: [ 			catSpecs at: 1 put: cat first;				at: 2 put: okExtensions;				at: 3 put: catServices.			specs add: catSpecs ]	].	^specs! !!Morph methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!privateAddAllMorphs: aCollection atIndex: index	"Private. Add aCollection of morphs to the receiver"	| myWorld otherSubmorphs |	myWorld := self world.	otherSubmorphs := submorphs copyWithoutAll: aCollection.	(index between: 0 and: otherSubmorphs size)		ifFalse: [^ self error: 'index out of range'].	index = 0		ifTrue:[	submorphs := aCollection asArray, otherSubmorphs]		ifFalse:[	index = otherSubmorphs size			ifTrue:[	submorphs := otherSubmorphs, aCollection]			ifFalse:[	submorphs := otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].	aCollection do: [:m | | itsOwner itsWorld |		itsOwner := m owner.		itsOwner ifNotNil: [			itsWorld := m world.			(itsWorld == myWorld) ifFalse: [				itsWorld ifNotNil: [self privateInvalidateMorph: m].				m outOfWorld: itsWorld].			(itsOwner ~~ self) ifTrue: [				m owner privateRemove: m.				m owner removedMorph: m ]].		m privateOwner: self.		myWorld ifNotNil: [self privateInvalidateMorph: m].		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].		itsOwner == self ifFalse: [			self addedMorph: m.			m noteNewOwner: self ].	].	self layoutChanged.! !!PasteUpMorph methodsFor: 'options' stamp: 'nice 12/27/2009 20:16'!updateSubmorphThumbnails	| thumbsUp heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	thumbsUp := self alwaysShowThumbnail.	heightForThumbnails := self heightForThumbnails.	maxHeightToAvoidThumbnailing := self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails := self maximumThumbnailWidth.	self submorphs do:		[:aMorph | | itsThumbnail |		thumbsUp			ifTrue:				[itsThumbnail := aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!TableLayout methodsFor: 'optimized' stamp: 'nice 12/27/2009 03:11'!layoutLeftToRight: aMorph in: newBounds 	"An optimized left-to-right list layout"	| inset extent block posX posY centering extraPerCell amount minX minY maxX maxY n width extra last cell size height sum vFill first |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint x.	extent := newBounds extent.	n := 0.	vFill := false.	sum := 0.	width := height := 0.	first := last := nil.	block := 			[:m | | sizeX props sizeY | 			props := m layoutProperties ifNil: [m].			props disableTableLayout 				ifFalse: 					[n := n + 1.					cell := LayoutCell new target: m.					props hResizing == #spaceFill 						ifTrue: 							[cell hSpaceFill: true.							extra := m spaceFillWeight.							cell extraSpace: extra.							sum := sum + extra]						ifFalse: [cell hSpaceFill: false].					props vResizing == #spaceFill ifTrue: [vFill := true].					size := m minExtent.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX ifTrue: [sizeX := minX] ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY ifTrue: [sizeY := minY] ifFalse: [sizeY := sizeY min: maxY].					cell cellSize: sizeX.					last ifNil: [first := cell] ifNotNil: [last nextCell: cell].					last := cell.					width := width + sizeX.					sizeY > height ifTrue: [height := sizeY]]].	properties reverseTableCells 		ifTrue: [aMorph submorphsReverseDo: block]		ifFalse: [aMorph submorphsDo: block].	n > 1 ifTrue: [width := width + ((n - 1) * inset)].	(properties hResizing == #shrinkWrap 		and: [properties rubberBandCells or: [sum isZero]]) 			ifTrue: [extent := width @ (extent y max: height)].	(properties vResizing == #shrinkWrap 		and: [properties rubberBandCells or: [vFill not]]) 			ifTrue: [extent := (extent x max: width) @ height].	posX := newBounds left.	posY := newBounds top.	"Compute extra vertical space"	extra := extent y - height.	extra := extra max: 0.	extra > 0 		ifTrue: 			[vFill 				ifTrue: [height := extent y]				ifFalse: 					[centering := properties wrapCentering.					centering == #bottomRight ifTrue: [posY := posY + extra].					centering == #center ifTrue: [posY := posY + (extra // 2)]]].	"Compute extra horizontal space"	extra := extent x - width.	extra := extra max: 0.	extraPerCell := 0.	extra > 0 		ifTrue: 			[sum isZero 				ifTrue: 					["extra space but no #spaceFillers"					centering := properties listCentering.					centering == #bottomRight ifTrue: [posX := posX + extra].					centering == #center ifTrue: [posX := posX + (extra // 2)]]				ifFalse: [extraPerCell := extra asFloat / sum asFloat]].	n := 0.	extra := last := 0.	cell := first.	[cell isNil] whileFalse: 			[n := n + 1.			width := cell cellSize.			(extraPerCell > 0 and: [cell hSpaceFill]) 				ifTrue: 					[extra := (last := extra) + (extraPerCell * cell extraSpace).					amount := extra truncated - last truncated.					width := width + amount].			cell target layoutInBounds: (posX @ posY extent: width @ height).			posX := posX + width + inset.			cell := cell nextCell]! !!PluggableListMorph methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!list: listOfStrings  	"lex doesn't think this is used any longer, but is not yet brave enough to remove it.  It should be removed eventually"			"Set the receiver's list as specified"	| morphList h index converter aSelector textColor font loc |	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	font ifNil: [font := Preferences standardListFont].	converter := self valueOfProperty: #itemConversionMethod.	converter ifNil: [converter := #asStringOrText].	textColor := self valueOfProperty: #textColor.	morphList := list collect: [:each | | stringMorph item |		item := each.		item := item perform: converter.		stringMorph := item isText			ifTrue: [StringMorph contents: item font: font emphasis: (item emphasisAt: 1)]			ifFalse: [StringMorph contents: item font: font].		textColor ifNotNil: [ stringMorph color: textColor ].		stringMorph	].		(aSelector := self valueOfProperty: #balloonTextSelectorForSubMorphs)		ifNotNil:			[morphList do: [:m | m balloonTextSelector: aSelector]].	self highlightSelector ifNotNil:		[model perform: self highlightSelector with: list with: morphList].	"Lay items out vertically and install them in the scroller"	h := morphList first height "self listItemHeight".	loc := 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc := loc + (0@h)].	scroller addAllMorphs: morphList.	index := self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!FileList methodsFor: 'directory tree' stamp: 'nice 12/27/2009 03:10'!selectedPath	| top here |	top := FileDirectory root.	here := directory.	^(Array streamContents:[:s| | next |		s nextPut: here.		[next := here containingDirectory.		top pathName = next pathName] whileFalse:[			s nextPut: next.			here := next.		]]) reversed.! !!PasteUpMorph methodsFor: 'scripting' stamp: 'nice 12/27/2009 03:11'!relaunchAllViewers	"Relaunch all the viewers in the project"		(self submorphs select: [:m | m isKindOf: ViewerFlapTab]) do: 			[:aTab | | aViewer | 			aViewer := aTab referent submorphs 						detect: [:sm | sm isStandardViewer]						ifNone: [nil].			aViewer ifNotNil: [aViewer relaunchViewer]			"ActiveWorld relaunchAllViewers"]! !!Morph methodsFor: 'WiW support' stamp: 'nice 12/27/2009 03:10'!addMorphInFrontOfLayer: aMorph	| targetLayer |	targetLayer := aMorph morphicLayerNumberWithin: self.	submorphs do: [ :each | | layerHere |		each == aMorph ifTrue: [^self].		layerHere := each morphicLayerNumberWithin: self.		"the <= is the difference - it insures we go to the front of our layer"		targetLayer <= layerHere ifTrue: [			^self addMorph: aMorph inFrontOf: each		].	].	self addMorphBack: aMorph.! !!WorldState methodsFor: 'update cycle' stamp: 'nice 12/27/2009 03:11'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!Morph methodsFor: 'meta-actions' stamp: 'nice 12/27/2009 03:10'!makeSiblings: count	"Make multiple sibling, and return the list"	| listOfNewborns aPosition |	aPosition := self position.	listOfNewborns := (1 to: count asInteger) asArray collect: 		[:anIndex | | anInstance |			anInstance := self usableSiblingInstance.			owner addMorphFront: anInstance.			aPosition := aPosition + (10@10).			anInstance position: aPosition.			anInstance].	self currentWorld startSteppingSubmorphsOf: self topRendererOrSelf owner.	^ listOfNewborns! !!Morph class methodsFor: 'misc' stamp: 'nice 12/27/2009 20:10'!morphsUnknownToTheirOwners	"Return a list of all morphs (other than HandMorphs) whose owners do not contain them in their submorph lists"	"Morph morphsUnknownToTheirOwners"	| problemMorphs |	problemMorphs := OrderedCollection new.	self allSubInstances do:		[:m | | itsOwner |		(m isHandMorph not and: [((itsOwner := m owner) ~~ nil and: [(itsOwner submorphs includes: m) not])])			ifTrue:				[problemMorphs add: m]].	^ problemMorphs! !!Morph methodsFor: 'halos and balloon help' stamp: 'nice 12/27/2009 03:10'!addHandlesTo: aHaloMorph box: box	"Add halo handles to the halo.  Apply the halo filter if appropriate"		aHaloMorph haloBox: box.	Preferences haloSpecifications  do:		[:aSpec | | wantsIt aSelector | 			aSelector :=  aSpec addHandleSelector.			wantsIt := Preferences selectiveHalos				ifTrue:					[self wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph]				ifFalse:					[true].			wantsIt ifTrue:				[(#(addMakeSiblingHandle: addDupHandle:) includes: aSelector) ifTrue:					[wantsIt := self preferredDuplicationHandleSelector = aSelector].			wantsIt ifTrue:				[aHaloMorph perform: aSelector with: aSpec]]].	aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!adjustSubmorphPositions	| p |	p := 0@0.	scroller submorphsDo: [ :each | | h |		h := each height.		each privateBounds: (p extent: 9999@h).		p := p + (0@h)	].	self 		changed;		layoutChanged;		setScrollDeltas.! !!MenuMorph methodsFor: 'control' stamp: 'nice 12/27/2009 03:11'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem 	"Present this menu at the given point under control of the given  	hand."	| tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner := sourceItem.	self fullBounds.self updateColor.	"ensure layout is current"	selectedOffset := (selectedItem				ifNil: [self items first]) position - self position.	tryToPlace := [:where :mustFit | | delta | 			self position: where - selectedOffset.			delta := self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.			(delta x = 0					or: [mustFit])				ifTrue: [delta = (0 @ 0)						ifFalse: [self position: self position + delta].					sourceItem owner owner addMorphFront: self.					^ self]].	tryToPlace value: rightOrLeftPoint first value: false;		 value: rightOrLeftPoint last - (self width @ 0) value: false;		 value: rightOrLeftPoint first value: true! !!SystemProgressMorph methodsFor: 'private' stamp: 'nice 12/27/2009 03:11'!nextSlotFor: shortDescription		lock critical: [ | label bar slots |		slots := labels size.		activeSlots = slots ifTrue: [^0].		activeSlots := activeSlots + 1.		1 to: slots do: [:index |			label := (labels at: index).			label ifNil: [				bar := bars at: index put: (SystemProgressBarMorph new extent: BarWidth@BarHeight).				label := labels at: index put: (StringMorph contents: shortDescription font: font).				self					addMorphBack: label;					addMorphBack: bar.				^index].			label owner ifNil: [				bar := bars at: index.				label := labels at: index.				self					addMorphBack: (label contents: shortDescription);					addMorphBack: (bar barSize: 0).				^index]]]		! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'nice 12/27/2009 03:12'!handleEmphasisExtra: index with: characterStream	"Handle an extra emphasis menu item"	| action attribute thisSel |	action := {		[attribute := TextDoIt new.		thisSel := attribute analyze: self selection asString].		[attribute := TextPrintIt new.		thisSel := attribute analyze: self selection asString].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Comment'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Definition'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString with: 'Hierarchy'].		[attribute := TextLink new.		thisSel := attribute analyze: self selection asString].		[attribute := TextURL new.		thisSel := attribute analyze: self selection asString].		["Edit hidden info"		thisSel := self hiddenInfo.	"includes selection"		attribute := TextEmphasis normal].		["Copy hidden info"		self copyHiddenInfo.		^true].	"no other action"	} at: index.	action value.	thisSel ifNil: [^true].	"Could not figure out what to link to"	attribute ifNotNil: [		thisSel ifEmpty:[ | oldAttributes |			"only change emphasisHere while typing"			oldAttributes := paragraph text attributesAt: self pointIndex.			self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.		] ifNotEmpty: [			self replaceSelectionWith: (thisSel asText addAttribute: attribute).		]	].	^true! !!PasteUpMorph methodsFor: 'pen' stamp: 'nice 12/27/2009 03:11'!updateTrailsForm	"Update the turtle-trails form using the current positions of all pens.	Only used in conjunction with Preferences batchPenTrails."	"Details: The positions of all morphs with their pens down are recorded each time the draw method is called. If the list from the previous display cycle isn't empty, then trails are drawn from the old to the new positions of those morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| removals |	self flag: #bob.	"transformations WRONG here"	(lastTurtlePositions isNil or: [lastTurtlePositions isEmpty]) 		ifTrue: [^self].	removals := OrderedCollection new.	lastTurtlePositions associationsDo: 			[:assoc | | player oldPoint newPoint morph tfm | 			player := assoc key.			morph := player costume.			(player getPenDown and: [morph trailMorph == self]) 				ifTrue: 					[oldPoint := assoc value.					tfm := morph owner transformFrom: self.					newPoint := tfm localPointToGlobal: morph referencePosition.					newPoint = oldPoint 						ifFalse: 							[assoc value: newPoint.							self 								drawPenTrailFor: morph								from: oldPoint								to: newPoint]]				ifFalse: [removals add: player]].	removals do: [:key | lastTurtlePositions removeKey: key ifAbsent: []]! !!PasteUpMorph methodsFor: 'viewing' stamp: 'nice 12/27/2009 03:11'!imposeListViewSortingBy: sortOrderSymbol retrieving: fieldListSelectors	"Establish a list view of the receiver's contents, sorting the contents by the criterion represented by sortOrderSymbol, and displaying readouts as indicated by the list of field selectors."		self setProperty: #sortOrder toValue: sortOrderSymbol.	self setProperty: #fieldListSelectors toValue: fieldListSelectors.	self showingListView ifFalse:		[self autoLineLayout ifFalse: [self saveBoundsOfSubmorphs].		self setProperty: #showingListView toValue: true.		self layoutPolicy: TableLayout new.		self layoutInset: 2; cellInset: 2.		self listDirection: #topToBottom.		self wrapDirection: #none].	self submorphs "important that it be a copy" do:		[:aMorph | | rep | 			rep := aMorph listViewLineForFieldList: fieldListSelectors.			rep hResizing: #spaceFill.			self replaceSubmorph: aMorph by: rep].	self sortSubmorphsBy: (self valueOfProperty: #sortOrder).! !!TableLayout methodsFor: 'optimized' stamp: 'nice 12/27/2009 03:11'!minExtentHorizontal: aMorph 	"Return the minimal size aMorph's children would require given the new bounds"	| inset minX minY maxX maxY n size width height |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint.	n := 0.	width := height := 0.	aMorph submorphsDo: 			[:m | | sizeX sizeY | 			m disableTableLayout 				ifFalse: 					[n := n + 1.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX 						ifTrue: [sizeX := minX]						ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY 						ifTrue: [sizeY := minY]						ifFalse: [sizeY := sizeY min: maxY].					width := width + sizeX.					sizeY > height ifTrue: [height := sizeY]]].	n > 1 ifTrue: [width := width + ((n - 1) * inset x)].	^minExtentCache := width @ height! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:11'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| typeString |	typeString := String streamContents:		[:s | | c |   [(c := aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove' ifTrue:[^MouseMoveEvent type: #mouseMove readFrom: aStream].	typeString = 'mouseDown' ifTrue:[^MouseButtonEvent type: #mouseDown readFrom: aStream].	typeString = 'mouseUp' ifTrue:[^MouseButtonEvent type: #mouseUp readFrom: aStream].	typeString = 'keystroke' ifTrue:[^KeyboardEvent type: #keystroke readFrom: aStream].	typeString = 'keyDown' ifTrue:[^KeyboardEvent type: #keyDown readFrom: aStream].	typeString = 'keyUp' ifTrue:[^KeyboardEvent type: #keyUp readFrom: aStream].	typeString = 'mouseOver' ifTrue:[^MouseEvent type: #mouseOver readFrom: aStream].	typeString = 'mouseEnter' ifTrue:[^MouseEvent type: #mouseEnter readFrom: aStream].	typeString = 'mouseLeave' ifTrue:[^MouseEvent type: #mouseLeave readFrom: aStream].	typeString = 'unknown' ifTrue:[^MorphicUnknownEvent type: #unknown readFrom: aStream].	^nil! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!projectOnlySelectionMethod: incomingEntries	| versionsAccepted |	"this shows only the latest version of each project"	versionsAccepted := Dictionary new.	incomingEntries do: [ :entry | | basicInfoTuple basicVersion basicName |		entry isDirectory ifFalse: [			(#('*.pr' '*.pr.gz' '*.project') anySatisfy: [ :each | each match: entry name]) ifTrue: [				basicInfoTuple := Project parseProjectFileName: entry name.				basicName := basicInfoTuple first.				basicVersion := basicInfoTuple second.				((versionsAccepted includesKey: basicName) and: 						[(versionsAccepted at: basicName) first > basicVersion]) ifFalse: [					versionsAccepted at: basicName put: {basicVersion. entry}				].			]		]	].	^versionsAccepted asArray collect: [ :each | each second]! !!TTSampleStringMorph methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:10'!drawOn: aCanvas	| xStart |	(font isNil or:[string isNil or:[string isEmpty]]) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	xStart := 0.	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		balloonCanvas aaLevel: self smoothing.		string do:[:char| | glyph |			glyph := font at: char.			balloonCanvas preserveStateDuring:[:subCanvas|				subCanvas transformBy: (MatrixTransform2x3 withOffset: xStart@0).				subCanvas 					drawGeneralBezierShape: glyph contours					color: color 					borderWidth: borderWidth 					borderColor: borderColor].			xStart := xStart + glyph advanceWidth.		].	].! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'nice 12/27/2009 03:10'!selectionOneOf: aListOfItems	"Set the selection to the first item in the list which is represented by one of my submorphs"		aListOfItems do: [ :item | | index |		index := scroller submorphs findFirst: [:m | 			m withoutListWrapper = item withoutListWrapper		].		index > 0 ifTrue: [^self selectionIndex: index].	].	self selectionIndex: 0.! !!Morph methodsFor: 'testing' stamp: 'nice 12/27/2009 03:10'!completeModificationHash"World completeModificationHash"	| resultSize result |	resultSize := 10.	result := ByteArray new: resultSize.	self allMorphsDo: [ :each | | here | 		here := each modificationHash.		here withIndexDo: [ :ch :index | | i |			i := index \\ resultSize + 1.			result at: i put: ((result at: i) bitXor: ch asciiValue)		].	].	^result! !!MorphicEvent methodsFor: 'objects from disk' stamp: 'nice 12/27/2009 03:11'!convertToCurrentVersion: varDict refStream: smartRefStrm			"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	varDict at: 'cursorPoint' ifPresent: [ :x | | answer | 		answer := self convertOctober2000: varDict using: smartRefStrm.		varDict removeKey: 'cursorPoint'.	"avoid doing this again"		^answer	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'nice 12/27/2009 03:11'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock |	handy := self primaryHand.	posBlock := 			[:z | | tempPos | 			tempPos := handy position 						- ((handy targetOffset - aMorph formerPosition) 								* (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail 		ifTrue: 			[aNail := aMorph 						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph 				ifFalse: 					[aMorph formerPosition: aMorph position.					aNail position: (posBlock value: aNail)].			^aNail].	((aMorph isKindOf: MorphThumbnail) 		and: [(representee := aMorph morphRepresented) owner isNil]) 			ifTrue: 				[representee position: (posBlock value: representee).				^representee].	self showingListView 		ifTrue: 			[^aMorph 				listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	(aMorph hasProperty: #newPermanentScript) 		ifTrue: [^aMorph asEmptyPermanentScriptor].	((aMorph isKindOf: PhraseTileMorph) or: [aMorph isSyntaxMorph]) 		ifFalse: [^aMorph].	aMorph userScriptSelector isEmptyOrNil 		ifTrue: 			["non-user"			self automaticPhraseExpansion ifFalse: [^aMorph]].	^aMorph morphToDropInPasteUp: self! !!Morph methodsFor: 'card in a stack' stamp: 'nice 12/27/2009 03:10'!showDesignationsOfObjects	"Momentarily show the designations of objects on the receiver"	| colorToUse |	self isStackBackground ifFalse: [^self].	self submorphsDo: 			[:aMorph | | aLabel | 			aLabel :=aMorph renderedMorph holdsSeparateDataForEachInstance 				ifTrue: 					[colorToUse := Color orange.					 aMorph externalName]				ifFalse: 					[colorToUse := aMorph isShared ifFalse: [Color red] ifTrue: [Color green].					 nil].			Display 				border: (aMorph fullBoundsInWorld insetBy: -6)				width: 6				rule: Form over				fillColor: colorToUse.			aLabel ifNotNil: 					[aLabel asString 						displayOn: Display						at: aMorph fullBoundsInWorld bottomLeft + (0 @ 5)						textColor: Color blue]].	Sensor anyButtonPressed 		ifTrue: [Sensor waitNoButton]		ifFalse: [Sensor waitButton].	World fullRepaintNeeded! !!Morph class methodsFor: 'testing' stamp: 'nice 12/27/2009 20:10'!allSketchMorphForms	"Answer a Set of forms of SketchMorph (sub) instances, except those 	used as button images, ones being edited, and those with 0 extent."	| reasonableForms |	reasonableForms := Set new.	Morph allSketchMorphClasses do:		[:cls | cls allInstances do:			[:m | | form |			(m owner isKindOf: SketchEditorMorph orOf: IconicButton)				ifFalse:					[form := m form.					((form width > 0) and: [form height > 0]) ifTrue: [reasonableForms add: form]]]].	^ reasonableForms! !!PasteUpMorph methodsFor: 'world state' stamp: 'nice 12/27/2009 03:11'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt |	blt := (BitBlt current toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r | | screenRect |		screenRect := r translateBy: self viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 03:10'!exploreIt		self handleEdit: [ | result |		result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [result explore]].! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 20:09'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString findTokens: String cr.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | | emphasis |			j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!PolygonMorph methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:11'!drawDashedBorderOn: aCanvas usingEnds: anArray 	"Display my border on the canvas. NOTE: mostly copied from  	drawBorderOn:"	| bevel topLeftColor bottomRightColor bigClipRect lineColor segmentOffset |	(borderColor isNil			or: [borderColor isColor					and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor := borderColor.	bevel := false.	"Border colors for bevelled effects depend on CW ordering of  	vertices"	borderColor == #raised		ifTrue: [topLeftColor := color lighter.			bottomRightColor := color darker.			bevel := true].	borderColor == #inset		ifTrue: [topLeftColor := owner colorForInsets darker.			bottomRightColor := owner colorForInsets lighter.			bevel := true].	bigClipRect := aCanvas clipRect expandBy: self borderWidth + 1 // 2.	segmentOffset := self borderDashOffset.	self		lineSegmentsDo: [:p1 :p2 | | p1i p2i | 			p1i := p1 asIntegerPoint.			p2i := p2 asIntegerPoint.			self hasArrows				ifTrue: ["Shorten line ends so as not to interfere with tip  					of arrow."					((arrows == #back								or: [arrows == #both])							and: [p1 = vertices first])						ifTrue: [p1i := anArray first asIntegerPoint].					((arrows == #forward								or: [arrows == #both])							and: [p2 = vertices last])						ifTrue: [p2i := anArray last asIntegerPoint]].			(closed					or: ["bigClipRect intersects: (p1i rect: p2i)  						optimized:"						((p1i min: p2i)							max: bigClipRect origin)							<= ((p1i max: p2i)									min: bigClipRect corner)])				ifTrue: [bevel						ifTrue: [lineColor := (p1i quadrantOf: p2i)											> 2										ifTrue: [topLeftColor]										ifFalse: [bottomRightColor]].					segmentOffset := aCanvas								line: p1i								to: p2i								width: borderWidth								color: lineColor								dashLength: borderDashSpec first								secondColor: borderDashSpec third								secondDashLength: borderDashSpec second								startingOffset: segmentOffset]]! !!TransformationMorph methodsFor: 'geometry' stamp: 'nice 12/27/2009 20:21'!extent: newExtent		self adjustAfter:		[ | scaleFactor |		scaleFactor := (self scale * newExtent r / self fullBounds extent r) max: 0.1.		self scale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false)]! !!WorldState methodsFor: 'alarms' stamp: 'nice 12/27/2009 01:32'!alarmSortBlock	^[ :alarm1 :alarm2 | 		alarm1 scheduledTime < alarm2 scheduledTime.	]! !!PasteUpMorph methodsFor: 'flaps' stamp: 'nice 12/27/2009 20:14'!localFlapTabs	"Answer a list of local flap tabs in the current project"	| globalList aList |	globalList := Flaps globalFlapTabsIfAny.	aList := OrderedCollection new.	submorphs do:		[:m | | aFlapTab |		((m isFlapTab) and: [(globalList includes: m) not])			ifTrue:				[aList add: m]			ifFalse:				[((m isFlap) and:					[(aFlapTab := m submorphs detect: [:n | n isFlapTab] ifNone: [nil]) notNil])						ifTrue:							[aList add: aFlapTab]]].	^ aList! !!SystemWindow methodsFor: 'geometry' stamp: 'nice 12/27/2009 03:10'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| layoutBounds |	layoutBounds := self layoutBounds.	paneMorphs do:[:m| | box left bottom top frame right |		frame := m layoutFrame.		box := m bounds.		frame ifNotNil:[			left := box left - layoutBounds left - (frame leftOffset ifNil:[0]).			right := box right - layoutBounds left - (frame rightOffset ifNil:[0]).			top := box top - layoutBounds top - (frame topOffset ifNil:[0]).			bottom := box bottom - layoutBounds top - (frame bottomOffset ifNil:[0]).			frame leftFraction: (left / layoutBounds width asFloat).			frame rightFraction: (right / layoutBounds width asFloat).			frame topFraction: (top / layoutBounds height asFloat).			frame bottomFraction: (bottom / layoutBounds height asFloat).		].	].! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nice 12/27/2009 03:11'!makeNewDrawing: evt at: aPoint	"make a new drawing, triggered by the given event, with the painting area centered around the given point"	| w newSketch newPlayer sketchEditor aPalette rect aPaintBox aPaintTab aWorld |	w := self world.	w assureNotPaintingElse: [^ self].	rect := self paintingBoundsAround: aPoint.	aPalette := self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w prepareToPaint.	newSketch := self drawingClass new player: (newPlayer := UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch nominalForm: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor := SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect | | tfx ownerBeforeHack whereToPresent |			whereToPresent := self presenter.			newSketch form: aForm.			tfx := self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			ownerBeforeHack := newSketch owner.	"about to break the invariant!!!!"			newSketch privateOwner: self. "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			newSketch privateOwner: ownerBeforeHack. "probably nil, but let's be certain"			self addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:[			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			aPalette ifNotNil: [aPalette showNoPalette].]! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'nice 12/27/2009 20:17'!startDrag: evt 		evt hand hasSubmorphs		ifTrue: [^ self].	[ | draggedItem draggedItemMorph passenger ddm |	(self dragEnabled and: [model okToChange])		ifFalse: [^ self].	(draggedItem := self selection)		ifNil: [^ self].	draggedItemMorph := StringMorph contents: draggedItem asStringOrText.	passenger := self model dragPassengerFor: draggedItemMorph inMorph: self.	passenger		ifNil: [^ self].	ddm := TransferMorph withPassenger: passenger from: self.	ddm		dragTransferType: (self model dragTransferTypeForMorph: self).	Preferences dragNDropWithAnimation		ifTrue: [self model dragAnimationFor: draggedItemMorph transferMorph: ddm].	evt hand grabMorph: ddm]		ensure: [Cursor normal show.			evt hand releaseMouseFocus: self]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'nice 12/27/2009 03:10'!morphsAt: aPoint unlocked: aBool do: aBlock	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."		(self fullBounds containsPoint: aPoint) ifFalse:[^self].	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].	self submorphsDo:[:m| | tfm |		tfm := m transformedFrom: self.		m morphsAt: (tfm globalPointToLocal: aPoint) unlocked: aBool do: aBlock].	(self containsPoint: aPoint) ifTrue:[aBlock value: self].! !!ColorPickerMorph class methodsFor: 'class initialization' stamp: 'nice 12/27/2009 03:11'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| startHue palette transHt vSteps transCaption grayWidth hSteps y c x |	palette := Form extent: chartExtent depth: depth.	transCaption := "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt := transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth := 10.	startHue := 338.0.	vSteps := palette height - transHt // 2.	hSteps := palette width - grayWidth.	x := 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h | | basicHue |		basicHue := Color h: h asFloat s: 1.0 v: 1.0.		y := transHt+1.		0 to: vSteps do: [:n | 			c := basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		1 to: vSteps do: [:n | 			c := Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		x := x + 1].	y := transHt + 1.	1 to: vSteps * 2 do: [:n | 		c := Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y := y + 1].	^ palette! !!PasteUpMorph methodsFor: 'options' stamp: 'nice 12/27/2009 03:11'!replaceTallSubmorphsByThumbnails	"Any submorphs that seem to tall get replaced by thumbnails; their balloon text is copied over to the thumbnail"	| heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	heightForThumbnails := self heightForThumbnails.	maxHeightToAvoidThumbnailing := self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails := self maximumThumbnailWidth.	self submorphs do:		[:aMorph | | existingHelp itsThumbnail |			itsThumbnail := aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[existingHelp := aMorph balloonText.					self replaceSubmorph: aMorph by: itsThumbnail.					existingHelp ifNotNil:						[itsThumbnail setBalloonText: existingHelp]]]! !!SystemWindow class methodsFor: 'top window' stamp: 'nice 12/27/2009 03:11'!windowsIn: aWorld satisfying: windowBlock	| windows |	windows := OrderedCollection new.	aWorld ifNil: [^windows].	"opening MVC in Morphic - WOW!!"	aWorld submorphs do:		[:m | | s |		((m isSystemWindow) and: [windowBlock value: m])			ifTrue: [windows addLast: m]			ifFalse: [((m isKindOf: TransformationMorph) and: [m submorphs size = 1])					ifTrue: [s := m firstSubmorph.							((s isSystemWindow) and: [windowBlock value: s])								ifTrue: [windows addLast: s]]]].	^ windows! !!FontChooserTool methodsFor: 'toolbuilder' stamp: 'nice 12/27/2009 03:10'!buildWindowWith: builder specs: specs	| windowSpec |	windowSpec := self buildWindowWith: builder.	specs do:[:assoc| | action widgetSpec rect |		rect := assoc key.		action := assoc value.		widgetSpec := action value.		widgetSpec ifNotNil:[			widgetSpec frame: rect.			windowSpec children add: widgetSpec]].	^windowSpec! !!ComplexProgressIndicator class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:15'!historyReport"ComplexProgressIndicator historyReport"	| answer |	History ifNil: [^Beeper beep].	answer := String streamContents: [ :strm |		(History keys asArray sort: [ :a :b | a asString <= b asString]) do: [ :k |			| data |			strm nextPutAll: k printString; cr.			data := History at: k.			(data keys asArray sort: [ :a :b | a asString <= b asString]) do: [ :dataKey |				strm tab; nextPutAll: dataKey printString,'  ',					(data at: dataKey) asArray printString; cr.			].			strm cr.		].	].	StringHolder new		contents: answer contents;		openLabel: 'Progress History'! !!MatrixTransformMorph methodsFor: 'layout' stamp: 'nice 12/27/2009 03:10'!fullBounds		fullBounds ifNil:[		fullBounds := self bounds.		submorphs do:[:m| | subBounds |			subBounds := (self transform localBoundsToGlobal: m fullBounds).			fullBounds := fullBounds quickMerge: subBounds.		].	].	^fullBounds! !!Morph methodsFor: 'card in a stack' stamp: 'nice 12/27/2009 20:11'!installAsCurrent: anInstance	"Install anInstance as the one currently viewed in the receiver.  Dock up all the morphs in the receiver which contain data rooted in the player instance to the instance data.  Run any 'opening' scripts that pertain."	| fieldList |	self player == anInstance ifTrue: [^ self].	fieldList := self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	self currentWorld hands do:		[:aHand | | itsFocus |		(itsFocus := aHand keyboardFocus) notNil ifTrue:			[(fieldList includes: itsFocus) ifTrue: [aHand newKeyboardFocus: nil]]].	self player uninstallFrom: self.  "out with the old"	anInstance installPrivateMorphsInto: self.	self changed.	anInstance costume: self.	self player: anInstance.	self player class variableDocks do:		[:aVariableDock | aVariableDock dockMorphUpToInstance: anInstance].	self currentWorld startSteppingSubmorphsOf: self! !!TheWorldMenu methodsFor: 'commands' stamp: 'nice 12/27/2009 20:20'!worldMenuHelp	| explanation aList |	"self currentWorld primaryHand worldMenuHelp"	aList := OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu projectMenu scriptingMenu windowsMenu playfieldMenu appearanceMenu flapsMenu) 		with:	#('help' 'changes' 'open' 'debug' 'projects' 'authoring tools' 'windows' 'playfield options' 'appearance' 'flaps') do:		[:sel :title | | aMenu |		aMenu := self perform: sel.			aMenu items do:				[:it | | cnts |				(((cnts := it contents) = 'keep this menu up') or: [cnts isEmpty])					ifFalse: [aList add: (cnts, ' - ', title translated)]]].	aList := aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation := String streamContents: [:aStream | aList do:		[:anItem | aStream nextPutAll: anItem; cr]].	(StringHolder new contents: explanation)		openLabel: 'Where in the world menu is...' translated! !!NewParagraph methodsFor: 'editing' stamp: 'nice 12/27/2009 20:13'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | | range target box boxes |			att mayActOnClick ifTrue:				[(target := model) ifNil: [target := editor morph].				range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint] ifNone: [nil].				box ifNotNil:					[ box := (editor transformFrom: nil) invertBoundsRect: box.					editor morph allOwnersDo: [ :m | box := box intersect: (m boundsInWorld) ].					Utilities awaitMouseUpIn: box						repeating: []						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action := true]].					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].				]]].	^ action! !!WorldState methodsFor: 'update cycle' stamp: 'nice 12/27/2009 03:11'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList n morphs rects validList |	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].	damageRecorder reset.	n := submorphs size.	morphs := OrderedCollection new: n * 2.	rects := OrderedCollection new: n * 2.	validList := OrderedCollection new: n * 2.	rectList do: 			[:dirtyRect | 			dirtyRect allAreasOutsideList: validList				do: 					[:r | | mm rectToFill remnants c rect i | 					"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."					rectToFill := r.					i := 1.					[rectToFill isNil or: [i > n]] whileFalse: 							[mm := submorphs at: i.							((mm fullBounds intersects: r) and: [mm visible]) 								ifTrue: 									[morphs addLast: mm.									rects addLast: rectToFill.									remnants := mm areasRemainingToFill: rectToFill.									remnants size = 1 ifTrue: [rectToFill := remnants first].									remnants isEmpty ifTrue: [rectToFill := nil]].							i := i + 1].					"Now paint from bottom to top, but using the reduced rectangles."					rectToFill 						ifNotNil: [aWorld drawOn: (c := aCanvas copyClipRect: rectToFill)].					[morphs isEmpty] whileFalse: 							[(rect := rects removeLast) == rectToFill 								ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].							c fullDrawMorph: morphs removeLast].					morphs reset.					rects reset.					validList add: r]].	^validList! !!Morph methodsFor: 'layout' stamp: 'nice 12/27/2009 03:10'!submorphBounds	"Private. Compute the actual full bounds of the receiver"	| box |	submorphs do: [:m | | subBox | 		(m visible) ifTrue: [			subBox := m fullBounds.			box 				ifNil:[box := subBox copy]				ifNotNil:[box := box quickMerge: subBox]]].	box ifNil:[^self bounds]. "e.g., having submorphs but not visible"	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!PolygonMorph methodsFor: 'geometry' stamp: 'nice 12/27/2009 03:11'!closestSegmentTo: aPoint	"Answer the starting index of my (big) segment nearest to aPoint"	| closestPoint minDist vertexIndex closestVertexIndex |	vertexIndex := 0.	closestVertexIndex := 0.	closestPoint := minDist := nil.	self lineSegmentsDo:		[:p1 :p2 | | dist curvePoint | 		(p1 = (self vertices at: vertexIndex + 1))			ifTrue: [ vertexIndex := vertexIndex + 1 ].		curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.		dist := curvePoint dist: aPoint.		(closestPoint == nil or: [dist < minDist])			ifTrue: [closestPoint := curvePoint.					minDist := dist.					closestVertexIndex := vertexIndex. ]].	^ closestVertexIndex! !!PolygonMorph methodsFor: 'editing' stamp: 'nice 12/27/2009 03:11'!updateHandles	| newVert |	self isCurvy		ifTrue: [handles first center: vertices first.			handles last center: vertices last.			self midVertices				withIndexDo: [:midPt :vertIndex | (closed							or: [vertIndex < vertices size])						ifTrue: [newVert := handles atWrap: vertIndex * 2.							newVert position: midPt - (newVert extent // 2)]]]		ifFalse: [vertices				withIndexDo: [:vertPt :vertIndex | | oldVert | 					oldVert := handles at: vertIndex * 2 - 1.					oldVert position: vertPt - (oldVert extent // 2).					(closed							or: [vertIndex < vertices size])						ifTrue: [newVert := handles at: vertIndex * 2.							newVert position: vertPt									+ (vertices atWrap: vertIndex + 1) - newVert extent // 2 + (1 @ -1)]]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 03:10'!toggleAnnotationPaneSize	| handle origin aHand siblings |	self flag: #bob.		"CRUDE HACK to enable changing the size of the annotations pane"	owner ifNil: [^self].	siblings := owner submorphs.	siblings size > 3 ifTrue: [^self].	siblings size < 2 ifTrue: [^self].	aHand := self primaryHand.	origin := aHand position.	(handle := HandleMorph new)		forEachPointDo: [:newPoint | | lf ht prevBottom newHeight m |			handle removeAllMorphs.			newHeight := (newPoint - origin) y asInteger min: owner height - 50 max: 16.			lf := siblings last layoutFrame.			lf bottomOffset: newHeight.			prevBottom := newHeight.			siblings size - 1 to: 1 by: -1 do: [ :index |				m := siblings at: index.				lf := m layoutFrame.				ht := lf bottomOffset - lf topOffset.				lf topOffset: prevBottom.				lf bottomOffset = 0 ifFalse: [					lf bottomOffset: (prevBottom + ht).				].				prevBottom := prevBottom + ht.			].			owner layoutChanged.		]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNil: [:halo | halo addHandles].		].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase pane.Click when done.' hand: aHand.	handle startStepping! !!MenuMorph methodsFor: 'keyboard control' stamp: 'nice 12/27/2009 03:11'!displayFiltered: evt	| matchStr allItems matches feedbackMorph |	matchStr := self valueOfProperty: #matchString.	allItems := self submorphs select: [:m | m isKindOf: MenuItemMorph].	matches :=  allItems select: [:m | | isMatch | 		isMatch := 			matchStr isEmpty or: [				m contents includesSubstring: matchStr caseSensitive: false].		m isEnabled: isMatch.		isMatch].	feedbackMorph := self valueOfProperty: #feedbackMorph.	feedbackMorph ifNil: [		feedbackMorph := 			TextMorph new 				autoFit: true;				color: Color darkGray.		self			addLine;			addMorphBack: feedbackMorph lock.		self setProperty: #feedbackMorph toValue: feedbackMorph.		self fullBounds.  "Lay out for submorph adjacency"].	feedbackMorph contents: '<', matchStr, '>'.	matchStr isEmpty ifTrue: [		feedbackMorph delete.		self submorphs last delete.		self removeProperty: #feedbackMorph].	"matches size >= 1 ifTrue: [		self selectItem: matches first event: evt]"! !!PasteUpMorph methodsFor: 'world state' stamp: 'nice 12/27/2009 03:11'!repairEmbeddedWorlds	| toDoList |	toDoList := OrderedCollection new.	self allMorphsDo: [ :each | | transform eWorld |		(each isKindOf: EmbeddedWorldBorderMorph) ifTrue: [			transform := each submorphs at: 1 ifAbsent: [nil].			transform ifNotNil: [				eWorld := transform submorphs at: 1 ifAbsent: [nil].				eWorld ifNotNil: [					toDoList add: {transform. eWorld}.				].			].			"Smalltalk at: #Q put: {self. each. transform. eWorld}."		].	].	toDoList do: [ :each |		each first addMorph: each second.	].! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!updateFromEvent: anEvent 	| delta selfTop selfBottom selfLeft selfRight |	delta := splitsTopAndBottom				ifTrue: [0 @ ((self normalizedY: anEvent cursorPoint y) - lastMouse y)]				ifFalse: [(self normalizedX: anEvent cursorPoint x) - lastMouse x @ 0].					splitsTopAndBottom		ifTrue: [lastMouse := lastMouse x @ (self normalizedY: anEvent cursorPoint y)]		ifFalse: [lastMouse := (self normalizedX: anEvent cursorPoint x) @ lastMouse y].	leftOrTop				do: [:each | | firstRight firstBottom | 					firstRight := each layoutFrame rightOffset								ifNil: [0].					firstBottom := each layoutFrame bottomOffset								ifNil: [0].					each layoutFrame rightOffset: firstRight + delta x.					each layoutFrame bottomOffset: firstBottom + delta y].			rightOrBottom				do: [:each | | secondLeft secondTop | 					secondLeft := each layoutFrame leftOffset								ifNil: [0].					secondTop := each layoutFrame topOffset								ifNil: [0].					each layoutFrame leftOffset: secondLeft + delta x.					each layoutFrame topOffset: secondTop + delta y].	selfTop := self layoutFrame topOffset				ifNil: [0].	selfBottom := self layoutFrame bottomOffset				ifNil: [0].	selfLeft := self layoutFrame leftOffset				ifNil: [0].	selfRight := self layoutFrame rightOffset				ifNil: [0].	self layoutFrame topOffset: selfTop + delta y.	self layoutFrame bottomOffset: selfBottom + delta y.	self layoutFrame leftOffset: selfLeft + delta x.	self layoutFrame rightOffset: selfRight + delta x.	self owner layoutChanged! !!TextContainer methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!computeShadow	| canvas bounds theText |	bounds := self bounds.	theText := textMorph.	canvas := (Display defaultCanvasClass extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas| | back |		self fillsOwner			ifTrue: [tempCanvas fullDrawMorph: (theText owner copyWithoutSubmorph: theText)]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back := tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [tempCanvas fullDrawMorph: m]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm := canvas form offset: bounds topLeft.	vertProfile := shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache := Dictionary new.	^ shadowForm! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'nice 12/27/2009 20:13'!acceptDroppingMorph: dropped event: evt	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| aMorph |	aMorph := self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:["Add the given morph to this world and start stepping it if it wants to be."				self addMorphFront: aMorph.				(aMorph fullBounds intersects: self viewBox) ifFalse:					[Beeper beep.  aMorph position: self bounds center]]		ifFalse:[super acceptDroppingMorph: aMorph event: evt].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | | tfm mm |		m player ifNotNil:			[m player getPenDown ifTrue:				[((mm := m player costume) notNil and: [(tfm := mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	self showingListView ifTrue:		[self sortSubmorphsBy: (self valueOfProperty: #sortOrder).		self currentWorld abandonAllHalos].	self bringTopmostsToFront.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 20:18'!tileForIt	"Return a tile referring to the object resulting form evaluating my current selection.  Not currently threaded in, but useful in earlier demos and possibly still of value."		self handleEdit:		[ | result |		result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [self currentHand attachMorph: result tileToRefer]]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'nice 12/27/2009 03:10'!computeBounds	| box |	(submorphs isNil or:[submorphs isEmpty]) ifTrue:[^self].	box := nil.	submorphs do:[:m| | subBounds |		subBounds := self transform localBoundsToGlobal: m bounds.		box 			ifNil:[box := subBounds]			ifNotNil:[box := box quickMerge: subBounds].	].	box ifNil:[box := 0@0 corner: 20@20].	fullBounds := bounds := box! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:11'!readFromObsolete: aStream	"Read one of those old and now obsolete events from the stream"	| type x y buttons keyValue typeString |	typeString := String streamContents:		[:s | | c |   [(c := aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove'		ifTrue: [type := #mouseMove  "fast treatment of common case"]		ifFalse: [type := typeString asSymbol].	x := Integer readFrom: aStream.	aStream skip: 1.	y := Integer readFrom: aStream.	aStream skip: 1.	buttons := Integer readFrom: aStream.	aStream skip: 1.	keyValue := Integer readFrom: aStream.	typeString = 'mouseMove' ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: x@y 			endPoint: x@y 			trail: #() 			buttons: buttons 			hand: nil 			stamp: nil].	(typeString = 'mouseDown') | (typeString = 'mouseUp') ifTrue:[			^MouseButtonEvent new				setType: type				position: x@y				which: 0				buttons: buttons				hand: nil				stamp: nil].	(typeString = 'keystroke') | (typeString = 'keyDown') | (typeString = 'keyUp') ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: x@y			keyValue: keyValue			hand: nil			stamp: nil].	^nil! !!PasteUpMorph methodsFor: 'world state' stamp: 'nice 12/27/2009 03:11'!optimumExtentFromAuthor		^self 		valueOfProperty: #optimumExtentFromAuthor 		ifAbsent: [ | opt |			opt := bounds extent.			self setProperty: #optimumExtentFromAuthor toValue: opt.			^opt		]! !!MorphicModel class methodsFor: 'housekeeping' stamp: 'nice 12/27/2009 03:11'!removeUninstantiatedModels	"With the user's permission, remove the classes of any models that have neither instances nor subclasses."	"MorphicModel removeUninstantiatedModels"	| candidatesForRemoval |	Smalltalk garbageCollect.	candidatesForRemoval :=		MorphicModel subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | | ok |		ok := self confirm: 'Are you certain that youwant to delete the class ', c name, '?'.		ok ifTrue: [c removeFromSystem]].! !!MenuMorph methodsFor: 'keyboard control' stamp: 'nice 12/27/2009 20:09'!moveSelectionDown: direction event: evt	"Move the current selection up or down by one, presumably under keyboard control.	direction = +/-1"	| index |	index := (submorphs indexOf: selectedItem ifAbsent: [1-direction]) + direction.	submorphs do: "Ensure finite"		[:unused | | m |		m := submorphs atWrap: index.		((m isKindOf: MenuItemMorph) and: [m isEnabled]) ifTrue:			[^ self selectItem: m event: evt].		"Keep looking for an enabled item"		index := index + direction sign].	^ self selectItem: nil event: evt! !!PasteUpMorph methodsFor: 'world state' stamp: 'nice 12/27/2009 03:11'!pauseEventRecorder	"Suspend any event recorder, and return it if found"		worldState handsDo: [:h | | er | (er := h pauseEventRecorderIn: self) ifNotNil: [^ er]].	^ nil! !!HandMorph methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:11'!nonCachingFullDrawOn: aCanvas		"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas| | shadowForm |		"Note: We use a shadow form here to prevent drawing		overlapping morphs multiple times using the transparent		shadow color."		shadowForm := self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."		shadowCanvas paintImage: shadowForm at: shadowForm offset.  "draw shadows"	].	"draw morphs in front of shadows"	self drawSubmorphsOn: aCanvas.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!Morph methodsFor: 'card in a stack' stamp: 'nice 12/27/2009 03:10'!abstractAModel	"Find data-containing fields in me.  Make a new class, whose instance variables are named for my fields, and whose values are the values I am showing.  Use a CardPlayer for now.  Force the user to name the fields.  Make slots for text, Number Watchers, SketchMorphs, and ImageMorphs."	| unnamed ans player twoListsOfMorphs holdsSepData docks oldPlayer instVarNames |	(oldPlayer := self player) ifNotNil: 			[oldPlayer belongsToUniClass 				ifTrue: 					["Player"					oldPlayer class instVarNames notEmpty 						ifTrue: 							[self 								inform: 'I already have a regular Player, so I can''t have a CardPlayer'.							^true]]].	twoListsOfMorphs := StackMorph discoverSlots: self.	holdsSepData := twoListsOfMorphs first.	instVarNames := ''.	holdsSepData do: 			[:ea | | iVarName | 			iVarName := Scanner wellFormedInstanceVariableNameFrom: ea knownName.			iVarName = ea knownName ifFalse: [ea name: iVarName].			instVarNames := instVarNames , iVarName , ' '].	unnamed := twoListsOfMorphs second.	"have default names"	instVarNames isEmpty 		ifTrue: 			[self 				inform: 'No named fields were found.Please get a halo on each field and give it a name.Labels or non-data fields should be named "shared xxx".'.			^false].	unnamed notEmpty 		ifTrue: 			[ans := (UIManager default					chooseFrom: #(						 'All other fields are non-data fields'.						'Stop.  Let me give a name to some more fields'.					) title: 'Data fields are ' , instVarNames printString 								, ('\Some fields are not named.  Are they labels or non-data fields?' 										, '\Please get a halo on each data field and give it a name.') withCRs) = 1.			ans ifFalse: [^false]].	unnamed 		withIndexDo: [:mm :ind | mm setName: 'shared label ' , ind printString].	"Make a Player with instVarNames.  Make me be the costume"	player := CardPlayer instanceOfUniqueClassWithInstVarString: instVarNames				andClassInstVarString: ''.	self player: player.	player costume: self.	"Fill in the instance values.  Make docks first."	docks := OrderedCollection new.	holdsSepData do: 			[:morph | 			morph setProperty: #shared toValue: true.	"in case it is deeply embedded"			morph setProperty: #holdsSeparateDataForEachInstance toValue: true.			player class compileInstVarAccessorsFor: morph knownName.			morph isSyntaxMorph ifTrue: [morph setTarget: player].	"hookup the UpdatingString!!"			docks addAll: morph variableDocks].	player class newVariableDocks: docks.	docks do: [:dd | dd storeMorphDataInInstance: player].	"oldPlayer class mdict do: [:assoc | move to player].	move methods to new class?"	"oldPlayer become: player."	^true	"success"! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nice 12/27/2009 03:11'!findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock 	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"		submorphs do: 			[:aMorph | | aWindow | 			(((aWindow := aMorph renderedMorph) isSystemWindow) 				and: [qualifyingBlock value: aWindow]) 					ifTrue: 						[aWindow isCollapsed ifTrue: [aWindow expand].						aWindow activateAndForceLabelToShow.						^self]].	"None found, so create one"	makeBlock value! !!TableLayout methodsFor: 'optimized' stamp: 'nice 12/27/2009 03:11'!minExtentVertical: aMorph 	"Return the minimal size aMorph's children would require given the new bounds"	| inset minX minY maxX maxY n size width height |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint.	n := 0.	width := height := 0.	aMorph submorphsDo: 			[:m | | sizeY sizeX | 			m disableTableLayout 				ifFalse: 					[n := n + 1.					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX 						ifTrue: [sizeX := minX]						ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY 						ifTrue: [sizeY := minY]						ifFalse: [sizeY := sizeY min: maxY].					height := height + sizeY.					sizeX > width ifTrue: [width := sizeX]]].	n > 1 ifTrue: [height := height + ((n - 1) * inset y)].	^minExtentCache := width @ height! !!MenuMorph methodsFor: 'accessing' stamp: 'nice 12/27/2009 03:11'!itemWithWording: wording	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."		self items do:[:anItem | | found |		found := anItem itemWithWording: wording.		found ifNotNil:[^found]].	^ nil! !!Morph methodsFor: 'card in a stack' stamp: 'nice 12/27/2009 03:10'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"	| requestedName |	self isStackBackground ifFalse: [^Beeper beep].	"bulletproof against deconstruction"	Cursor wait showWhile: 			[ | variableDocks takenNames sepDataMorphs sorted existing |variableDocks := OrderedCollection new.	"This will be stored in the uniclass's 			class-side inst var #variableDocks"			takenNames := OrderedCollection new.			sepDataMorphs := OrderedCollection new.	"fields, holders of per-card data"			self submorphs do: 					[:aMorph | 					aMorph renderedMorph holdsSeparateDataForEachInstance 						ifTrue: [sepDataMorphs add: aMorph renderedMorph]						ifFalse: 							["look for buried fields, inside a frame"							aMorph renderedMorph isShared 								ifTrue: 									[aMorph allMorphs do: 											[:mm | 											mm renderedMorph holdsSeparateDataForEachInstance 												ifTrue: [sepDataMorphs add: mm renderedMorph]]]]].			sorted := SortedCollection new 						sortBlock: [:a :b | (a valueOfProperty: #cardInstance) notNil].	"puts existing ones first"			sorted addAll: sepDataMorphs.			sorted do: 					[:aMorph | | docks | 					docks := aMorph variableDocks.					"Each morph can request multiple variables.  	This complicates matters somewhat but creates a generality for Fabrk-like uses.	Each spec is an instance of VariableDock, and it provides a point of departure	for the negotiation between the PasteUp and its constitutent morphs"					docks do: 							[:aVariableDock | | uniqueName | 							uniqueName := self player 										uniqueInstanceVariableNameLike: (requestedName := aVariableDock 														variableName)										excluding: takenNames.							uniqueName ~= requestedName 								ifTrue: 									[aVariableDock variableName: uniqueName.									aMorph noteNegotiatedName: uniqueName for: requestedName].							takenNames add: uniqueName].					variableDocks addAll: docks].			existing := self player class instVarNames.			variableDocks := (variableDocks asSortedCollection: 							[:dock1 :dock2 | | name2 name1 | 							name1 := dock1 variableName.							name2 := dock2 variableName.							(existing indexOf: name1 ifAbsent: [0]) 								< (existing indexOf: name2 ifAbsent: [variableDocks size])]) 						asOrderedCollection.			self player class setNewInstVarNames: (variableDocks 						collect: [:info | info variableName asString]).			"NB: sets up accessors, and removes obsolete ones"			self player class newVariableDocks: variableDocks]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'nice 12/27/2009 20:19'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen |	theLen := 0.	paneMorphs do:		[:pane | | box |		box := pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane := pane.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ thePane! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'nice 12/27/2009 03:11'!locationIndicator		^self valueOfProperty: #locationIndicator ifAbsent:[ | loc |		loc := EllipseMorph new.		loc color: Color transparent; 			borderWidth: 1; 			borderColor: Color red; 			extent: 6@6.		self setProperty: #locationIndicator toValue: loc.		self addMorphFront: loc.		loc]! !!FileList2 class methodsFor: 'utility' stamp: 'nice 12/27/2009 03:11'!addFullPanesTo: window from: aCollection		aCollection do: [ :each | | frame |		frame := LayoutFrame 			fractions: each second 			offsets: each third.		window addMorph: each first fullFrame: frame.	]! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!publishingServers	| dirList |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | | dir nameToShow | 		dir := ServerDirectory serverNamed: n.		(dir isProjectSwiki and: [dir acceptsUploads])			 ifTrue: [				nameToShow := n.				dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)					balloonText: dir realUrl)]].	^dirList! !!PolygonMorph methodsFor: 'smoothing' stamp: 'nice 12/27/2009 03:11'!lineSegmentsDo: endPointsBlock 	"Emit a sequence of segment endpoints into endPointsBlock."	"Unlike the method this one replaces we expect the curve 	coefficents not the dirivatives"	"Also unlike the replaced method the smooth closed curve	does 	not need an extra vertex. 	We take care of the extra endpoint here. Just like for 	segmented curves."	| cs x y beginPoint |	vertices size < 1		ifTrue: [^ self].	"test too few vertices first"	self isCurvy		ifFalse: [beginPoint := nil.			"smoothCurve 			ifTrue: [cs := self coefficients]."			"some things still depend on smoothCurves having 			curveState"			vertices				do: [:vert | 					beginPoint						ifNotNil: [endPointsBlock value: beginPoint value: vert].					beginPoint := vert].			(closed					or: [vertices size = 1])				ifTrue: [endPointsBlock value: beginPoint value: vertices first].			^ self].	"For curves we include all the interpolated sub segments."	"self assert: [(vertices size > 2 )].	"	cs := self coefficients.	beginPoint := (x := cs first first) @ (y := cs fifth first).	(closed		ifTrue: [1 to: cs first size]		ifFalse: [1 to: cs first size - 1])		do: [:i | | x1 y1 endPoint n y2 t x3 y3 x2 | 			"taylor series coefficients"			x1 := cs second at: i.			y1 := cs sixth at: i.			x2 := cs third at: i.			y2 := cs seventh at: i.			x3 := cs fourth at: i.			y3 := cs eighth at: i.			n := cs ninth at: i.			"guess n 			n := 5 max: (x2 abs + y2 abs * 2.0 + (cs third atWrap:			i 			+ 1) abs + (cs seventh atWrap: i + 1) abs / 100.0) 			rounded."			1				to: n - 1				do: [:j | 					t := j asFloat / n asFloat.					endPoint := x3 * t + x2 * t + x1 * t + x @ (y3 * t + y2 * t + y1 * t + y).					endPointsBlock value: beginPoint value: endPoint.					beginPoint := endPoint].			endPoint := (x := cs first atWrap: i + 1) @ (y := cs fifth atWrap: i + 1).			endPointsBlock value: beginPoint value: endPoint.			beginPoint := endPoint]! !!SystemWindow methodsFor: 'panes' stamp: 'nice 12/27/2009 03:10'!setUpdatablePanesFrom: getSelectors	| aList possibles |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList := OrderedCollection new.	possibles := OrderedCollection new.	self allMorphsDo: [ :pane | 		(pane isKindOf: PluggableListMorph) ifTrue: [			possibles add: pane.		].	].	getSelectors do: [:sel | | aPane | 		aPane := possibles detect: [ :pane | pane getListSelector == sel] ifNone: [nil].		aPane			ifNotNil:				[aList add: aPane]			ifNil:				[Transcript cr; show: 'Warning: pane ', sel, ' not found.']].	updatablePanes := aList asArray! !!TableLayout methodsFor: 'utilities' stamp: 'nice 12/27/2009 03:11'!indexForInserting: aPoint inList: morphList horizontal: aBool target: aMorph 	| cmp1 cmp2 cmp3 noWrap |	properties := aMorph layoutProperties.	noWrap := properties wrapDirection == #none.	aBool 		ifTrue: 			["horizontal"			properties listDirection == #rightToLeft 				ifTrue: [cmp1 := [:rect | aPoint x > rect left]]				ifFalse: [cmp1 := [:rect | aPoint x < rect right]].			properties wrapDirection == #bottomToTop 				ifTrue: 					[cmp2 := [:rect | aPoint y > rect top].					cmp3 := [:rect | aPoint y > rect bottom]]				ifFalse: 					[cmp2 := [:rect | aPoint y < rect bottom].					cmp3 := [:rect | aPoint y < rect top]]]		ifFalse: 			["vertical"			properties listDirection == #bottomToTop 				ifTrue: [cmp1 := [:rect | aPoint y > rect top]]				ifFalse: [cmp1 := [:rect | aPoint y < rect bottom]].			properties wrapDirection == #rightToLeft 				ifTrue: 					[cmp2 := [:rect | aPoint x > rect left].					cmp3 := [:rect | aPoint x > rect right]]				ifFalse: 					[cmp2 := [:rect | aPoint x < rect right].					cmp3 := [:rect | aPoint x < rect left]]]. 	morphList keysAndValuesDo: 			[:index :m | | box | 			self flag: #arNote.	"it is not quite clear if we can really use #fullBounds here..."			box := m fullBounds.			noWrap 				ifTrue: 					["Only in one direction"					(cmp1 value: box) ifTrue: [^index]]				ifFalse: 					["Check for inserting before current row"					(cmp3 value: box) ifTrue: [^index].					"Check for inserting before current cell"					((cmp1 value: box) and: [cmp2 value: box]) ifTrue: [^index]]].	^morphList size + 1! !!TableLayout methodsFor: 'optimized' stamp: 'nice 12/27/2009 03:11'!layoutTopToBottom: aMorph in: newBounds 	"An optimized top-to-bottom list layout"	| inset extent block posX posY centering extraPerCell amount minX minY maxX maxY n height extra last cell size width sum vFill first |	size := properties minCellSize asPoint.	minX := size x.	minY := size y.	size := properties maxCellSize asPoint.	maxX := size x.	maxY := size y.	inset := properties cellInset asPoint y.	extent := newBounds extent.	n := 0.	vFill := false.	sum := 0.	width := height := 0.	first := last := nil.	block := 			[:m | | sizeY sizeX props | 			props := m layoutProperties ifNil: [m].			props disableTableLayout 				ifFalse: 					[n := n + 1.					cell := LayoutCell new target: m.					props vResizing == #spaceFill 						ifTrue: 							[cell vSpaceFill: true.							extra := m spaceFillWeight.							cell extraSpace: extra.							sum := sum + extra]						ifFalse: [cell vSpaceFill: false].					props hResizing == #spaceFill ifTrue: [vFill := true].					size := m minExtent.					sizeX := size x.					sizeY := size y.					sizeX < minX ifTrue: [sizeX := minX] ifFalse: [sizeX := sizeX min: maxX].					sizeY < minY ifTrue: [sizeY := minY] ifFalse: [sizeY := sizeY min: maxY].					cell cellSize: sizeY.					first ifNil: [first := cell] ifNotNil: [last nextCell: cell].					last := cell.					height := height + sizeY.					sizeX > width ifTrue: [width := sizeX]]].	properties reverseTableCells 		ifTrue: [aMorph submorphsReverseDo: block]		ifFalse: [aMorph submorphsDo: block].	n > 1 ifTrue: [height := height + ((n - 1) * inset)].	(properties vResizing == #shrinkWrap 		and: [properties rubberBandCells or: [sum isZero]]) 			ifTrue: [extent := (extent x max: width) @ height].	(properties hResizing == #shrinkWrap 		and: [properties rubberBandCells or: [vFill not]]) 			ifTrue: [extent := width @ (extent y max: height)].	posX := newBounds left.	posY := newBounds top.	"Compute extra horizontal space"	extra := extent x - width.	extra := extra max: 0.	extra > 0 		ifTrue: 			[vFill 				ifTrue: [width := extent x]				ifFalse: 					[centering := properties wrapCentering.					centering == #bottomRight ifTrue: [posX := posX + extra].					centering == #center ifTrue: [posX := posX + (extra // 2)]]].	"Compute extra vertical space"	extra := extent y - height.	extra := extra max: 0.	extraPerCell := 0.	extra > 0 		ifTrue: 			[sum isZero 				ifTrue: 					["extra space but no #spaceFillers"					centering := properties listCentering.					centering == #bottomRight ifTrue: [posY := posY + extra].					centering == #center ifTrue: [posY := posY + (extra // 2)]]				ifFalse: [extraPerCell := extra asFloat / sum asFloat]].	n := 0.	extra := last := 0.	cell := first.	[cell isNil] whileFalse: 			[n := n + 1.			height := cell cellSize.			(extraPerCell > 0 and: [cell vSpaceFill]) 				ifTrue: 					[extra := (last := extra) + (extraPerCell * cell extraSpace).					amount := extra truncated - last truncated.					height := height + amount].			cell target layoutInBounds: (posX @ posY extent: width @ height).			posY := posY + height + inset.			cell := cell nextCell]! !!PolygonMorph methodsFor: 'attachments' stamp: 'nice 12/27/2009 03:17'!nudgeForLabel: aRectangle	"Try to move the label off me. Prefer labels on the top and right."	| i flags nudge |	(self bounds intersects: aRectangle) ifFalse: [^ 0@0 ].	flags := 0.	nudge := 0@0.	i := 1.	aRectangle lineSegmentsDo: [ :rp1 :rp2 | | rectSeg |		rectSeg := LineSegment from: rp1 to: rp2.		self straightLineSegmentsDo: [ :lp1 :lp2 | | polySeg int |			polySeg := LineSegment from: lp1 to: lp2.			int := polySeg intersectionWith: rectSeg.			int ifNotNil: [ flags := flags bitOr: i ].		].		i := i * 2.	].	"Now flags has bitflags for which sides"	nudge := flags caseOf: {"no intersection"		[ 0 ] -> [ 0@0 ]."2 adjacent sides only" 		[ 9 ] -> [ 1@1 ].		[ 3 ] -> [ -1@1 ].		[ 12 ] -> [ 1@-1 ].		[ 6 ] -> [ -1@-1 ]."2 opposite sides only" 		[ 10 ] -> [ 0@-1 ].		[ 5 ] -> [ 1@0 ]."only 1 side" 		[ 8 ] -> [ -1@0 ].		[ 1 ] -> [ 0@-1 ].		[ 2 ] -> [ 1@0 ].		[ 4 ] -> [ 0@1 ]."3 sides" 		[ 11 ] -> [ 0@1 ].		[ 13 ] -> [ 1@0 ].		[ 14 ] -> [ 0@-1 ].		[ 7 ] -> [ -1@0 ]. "all sides" 		[ 15 ] -> [ 1@-1 "move up and to the right" ].	}.	^nudge! !!MorphicProject methodsFor: 'utilities' stamp: 'nice 12/27/2009 03:10'!findProjectView: projectDescription	"In this world, find the morph that holds onto the project described by projectDescription.	projectDescription can be a project, or the name of a project.  The project may be	represented by a DiskProxy. The holder morph may be at any depth in the world.."	| pName |	pName := (projectDescription isString) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	world allMorphsDo: [:pvm | | dpName |	pvm class == ProjectViewMorph ifTrue: [		(pvm project class == Project and: 			[pvm project name = pName]) ifTrue: [^ pvm].			pvm project class == DiskProxy ifTrue: [ 			dpName := pvm project constructorArgs first.			dpName := (dpName findTokens: '/') last.			dpName := (Project parseProjectFileName: dpName unescapePercents) first.			dpName = pName ifTrue: [^ pvm]]]].	^ nil! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 03:11'!createThreadShowing	| vertices |	self deleteThreadShowing.	vertices := OrderedCollection new.	self tileRows do: [:row | | b |		row first isTurtleRow ifTrue: [			b := row first bounds.			vertices add: ((b topLeft + (4@0)) + ((0 * 0.1 * b width)@0)).			0 to: 9 do: [:i |				vertices add: ((b topLeft + (4@4))+ ((i * 0.1 * b width )@0)).				vertices add: ((b bottomLeft + (4@-4)) + ((i * 0.1 * b width)@0)).			].				vertices add: ((b bottomLeft + (4@0)) + ((9 * 0.1 * b width)@0)).		] ifFalse: [			b := row first bounds.			vertices add: ((b origin x + b corner x)//2)@(b origin y).			vertices add: ((b origin x + b corner x)//2)@(b origin y + 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y - 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y).		].	].	threadPolygon := PolygonMorph vertices: vertices color: Color black borderWidth: 2 borderColor: Color black.	threadPolygon makeOpen.	threadPolygon openInWorld.! !!TextEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 20:20'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	Cursor execute showWhile: 			[ | string numbers delimitors cgVars reply selectors tiVars symbol sorry |			sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (morph canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nice 12/27/2009 03:11'!initializeDesktopCommandKeySelectors	"Provide the starting settings for desktop command key selectors.  Answer the dictionary."	"ActiveWorld initializeDesktopCommandKeySelectors"	| dict |	dict := IdentityDictionary new.	self defaultDesktopCommandKeyTriplets do:		[:trip | | messageSend |			messageSend := MessageSend receiver: trip second selector: trip third.			dict at: trip first put: messageSend].	self setProperty: #commandKeySelectors toValue: dict.	^ dict! !!SmalltalkEditor methodsFor: 'do-its' stamp: 'nice 12/27/2009 03:12'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt valueAsString v |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [ | cm |		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: (Array with: ctxt)].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !