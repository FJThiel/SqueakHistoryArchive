"Change Set:		7331Graphics-ar.47Graphics-ar.47:Fix Cursor>>makeCursorsWithMask so that Cursor>>initialize will work properly.Graphics-ar.46:Underscore removal."!!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!parseDecoderRestartInterval	| length |	length := self nextWord.	length = 4 ifFalse: [self error: 'DRI length incorrect'].	restartInterval := self nextWord.! !!TextStyle methodsFor: 'accessing' stamp: ''!centered	alignment := 2! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!dominantColor	| tally max maxi |	self depth > 16 ifTrue:		[^(self asFormOfDepth: 16) dominantColor].	tally := self tallyPixelValues.	max := maxi := 0.	tally withIndexDo: [:n :i | n > max ifTrue: [max := n. maxi := i]].	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:30'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	| pv32 a b g r |	pv32 := super scaledPixelValue32.	a := (self alpha * 255.0) rounded.	b := (pv32 bitAnd: 255) * a // 256.	g := ((pv32 bitShift: -8) bitAnd: 255) * a // 256.	r := ((pv32 bitShift: -16) bitAnd: 255) * a // 256.	^b + (g bitShift: 8) + (r bitShift: 16) + (a bitShift: 24)! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:17'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream := currentComponents at: 1.	ySampleStream resetSampleStream.	bits := mcuImageBuffer bits.	1 to: bits size do:		[:i |		y := (ySampleStream nextSample) + (residuals at: 2).		y > MaxSample ifTrue: [y := MaxSample].		residuals at: 2 put: (y bitAnd: ditherMask).		y := y bitAnd: MaxSample - ditherMask.		y < 1 ifTrue: [y := 1].		bits at: i put: 16rFF000000 + (y<<16) + (y<<8) + y].	! !!Point methodsFor: 'point functions' stamp: ''!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise."	| n |	n := y negated @ x.	^n / (n x * n x + (n y * n y)) sqrt! !!PNMReadWriter methodsFor: 'testing' stamp: 'jdr 10/11/2003 14:52'!understandsImageFormat	"P1 to P7"	| p  |	p := stream next asCharacter.	type := stream next - 48.	^(p = $P and:[type > 0 and:[type < 8]])	! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	^true! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'KLC 1/25/2004 14:04'!readBody	"Read the GIF blocks. Modified to return a form.  "	| form extype block blocksize packedFields delay1 |	form := nil.	[stream atEnd] whileFalse: [		block := self next.		block = Terminator ifTrue: [^ form].		block = ImageSeparator ifTrue: [			form isNil				ifTrue: [form := self readBitData]				ifFalse: [self skipBitData].		] ifFalse: [			block = Extension				ifFalse: [^ form "^ self error: 'Unknown block type'"].			"Extension block"			extype := self next.	"extension type"			extype = 16rF9 ifTrue: [  "graphics control"				self next = 4 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].				"====				Reserved                      3 Bits				Disposal Method               3 Bits				User Input Flag               1 Bit				Transparent Color Flag        1 Bit				===" 				packedFields := self next.				delay1 := self next.	"delay time 1"				delay := (self next*256 + delay1) *10.	 "delay time 2"				transparentIndex := self next.				(packedFields bitAnd: 1) = 0 ifTrue: [transparentIndex := nil].				self next = 0 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].			] ifFalse: [				"Skip blocks"				[(blocksize := self next) > 0]					whileTrue: [						"Read the block and ignore it and eat the block terminator"						self next: blocksize]]]]! !!CornerRounder class methodsFor: 'all' stamp: 'ar 1/5/2002 17:24'!roundCornersOf: aMorph on: aCanvas in: bounds displayBlock: displayBlock borderWidth: w corners: aList	| rounder |	rounder := CR0.	w = 1 ifTrue: [rounder := CR1].	w = 2 ifTrue: [rounder := CR2].	rounder := rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: aList.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: aList! !!DisplayText methodsFor: 'accessing' stamp: ''!alignedTo: alignPointSelector	"Return a copy with offset according to alignPointSelector which is one of...	#(topLeft, topCenter, topRight, leftCenter, center, etc)"	| boundingBox |	boundingBox := 0@0 corner: self form extent.	^ self shallowCopy offset: (0@0) - (boundingBox perform: alignPointSelector)! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/12/1999 12:51'!testMouseTracking	"A very simple example of drawing using the mouse. Compare the tracking speed of this example with that of testTabletTracking. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testMouseTracking"	| pen p |	pen := Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p := Sensor cursorPoint.		     Sensor anyButtonPressed				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/10/2003 18:04'!stream: s	stream := s! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!readAttributes	| str a |	"I don't handle double-quotes correctly, but it works"	file reset.	[file atEnd] whileFalse: [		str := self getLine.		(str beginsWith: 'STARTCHAR') ifTrue: [file skip: (0 - str size - 1). ^self].		a := str substrings.		properties at: a first asSymbol put: a allButFirst.	].	self error: 'file seems corrupted'.! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/15/2001 23:28'!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/4/2001 15:45'!colorMap: map	"See last part of BitBlt comment. 6/18/96 tk"	colorMap := map.! !!Form methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:41'!bitsSize	| pixPerWord |	depth == nil ifTrue: [depth := 1].	pixPerWord := 32 // self depth.	^ width + pixPerWord - 1 // pixPerWord * height! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 3/27/98 16:54'!readFromOldFormat: aBinaryStream	"Read a Form in the original ST-80 format."	| w h offsetX offsetY newForm theBits pos |	self error: 'this method must be updated to read into 32-bit word bitmaps'.	w := aBinaryStream nextWord.	h := aBinaryStream nextWord.	offsetX  := aBinaryStream nextWord.	offsetY := aBinaryStream nextWord.	offsetX > 32767 ifTrue: [offsetX := offsetX - 65536].	offsetY > 32767 ifTrue: [offsetY := offsetY - 65536].	newForm := Form extent: w @ h offset: offsetX @ offsetY.	theBits := newForm bits.	pos := 0.	1 to: w + 15 // 16 do: [:j |		1 to: h do: [:i |			theBits at: (pos := pos+1) put: aBinaryStream nextWord]].	newForm bits: theBits.	^ newForm! !!CharacterScanner class methodsFor: 'class initialization' stamp: 'yo 12/18/2002 14:09'!initialize"	CharacterScanner initialize"	| a |	a := Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition := a copy.	DefaultStopConditions := a copy.	PaddedSpaceCondition := a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition := a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'tk 9/14/97 16:25'!readPixelFrom: bits	"Since bits is a Bitmap with 32 bit values, watch out for thepadding at the end of each row.  But, GIF format already wants padding to32 bit boundary!!  OK as is.  tk 9/14/97"	| pixel |	ypos >= height ifTrue: [^nil].	pixel := bits byteAt: (ypos * rowByteSize + xpos + 1).	self updatePixelPosition.	^pixel! !!DisplayObject methodsFor: 'fileIn/Out' stamp: ''!writeOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file := FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeOn: file.	file close" | f |[(f := Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!Point methodsFor: 'point functions' stamp: ''!grid: aPoint 	"Answer a Point to the nearest rounded grid modules specified by aPoint."	| newX newY |	newX := x + (aPoint x // 2) truncateTo: aPoint x.	newY := y + (aPoint y // 2) truncateTo: aPoint y.	^newX @ newY! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/28/1999 09:10'!invert: aPoint	"Transform the given point from local to global coordinates."	| p3 p2 |	self isPureTranslation ifTrue: [^ aPoint - offset].	p3 :=  aPoint * scale.	p2 := ((p3 x * angle cos) + (p3 y * angle sin))		@ ((p3 y * angle cos) - (p3 x * angle sin)).	^ (p2 - offset)! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:41'!integerAt: index	"Return the integer at the given index"	| word |	<primitive: 165>	word := self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!Pen methodsFor: 'operations' stamp: ''!north	"Set the receiver's direction to facing toward the top of the display screen."	direction := 270! !!Pen methodsFor: 'operations' stamp: ''!down	"Set the state of the receiver's pen to down (drawing)."	penDown := true! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGray: y at: startX by: incX	"Handle interlaced grayscale color mode (colorType = 0)"	| b offset bits w pixel mask blitter pixelNumber pixPerByte rawByteshifts |	bitsPerChannel = 16		ifTrue: [			b := BitBlt current bitPokerToForm: form.			startX to: width-1 by: incX do: [ :x |				b pixelAt: x@y put: 255 - (thisScanline at: (x//incX<<1)+1).				].			^ self			].	offset := y*rowSize+1.	bits := form bits.	bitsPerChannel = 8 ifTrue: [		startX to: width-1 by: incX do: [ :x |			w := offset + (x>>2).			b := 3- (x \\ 4) * 8.			pixel := (thisScanline at: x // incX + 1)<<b.			mask := (255<<b) bitInvert32.			bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)		].		^ self	].	bitsPerChannel = 1 ifTrue: [		pixPerByte := 8.		mask := 1.		shifts := #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte := 4.		mask := 3.		shifts := #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte := 2.		mask := 15.		shifts := #(4 0).	].	blitter := BitBlt current bitPokerToForm: form.	pixelNumber := 0.	startX to: width-1 by: incX do: [ :x |		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber := pixelNumber + 1.	].! !!MatrixTransform2x3 methodsFor: 'objects from disk' stamp: 'yo 3/6/2004 15:33'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| w b1 b2 b3 b4 |	SmalltalkImage current  isLittleEndian ifTrue: [		1 to: self basicSize do: [:i |			w := self basicAt: i.			b1 := w digitAt: 1.			b2 := w digitAt: 2.			b3 := w digitAt: 3.			b4 := w digitAt: 4.			w := (b1 << 24) + (b2 << 16) + (b3 << 8) + b4.			self basicAt: i put: w.		]	].! !!TextStyle methodsFor: 'accessing' stamp: ''!restIndent: anInteger 	"Set the indent for all but the first line of a paragraph in the style of the 	receiver to be the argument, anInteger."	restIndent := anInteger! !!CharacterScanner methodsFor: 'private' stamp: 'yo 10/7/2002 14:33'!setConditionArray: aSymbol	aSymbol == #paddedSpace ifTrue: [^stopConditions := PaddedSpaceCondition copy].	aSymbol == #space ifTrue: [^stopConditions := SpaceCondition copy].	aSymbol == nil ifTrue: [^stopConditions := NilCondition copy].	self error: 'undefined stopcondition for space character'.! !!Pen class methodsFor: 'examples' stamp: 'jm 5/6/1998 22:28'!example	"Draw a spiral with a pen that is 2 pixels wide."	"Display restoreAfter: [Pen example]"	| bic |	bic := self new.	bic defaultNib: 2.	bic color: Color blue.	bic combinationRule: Form over.	1 to: 100 do: [:i | bic go: i*4. bic turn: 89].! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!copyFrom: sourceRectangle in: srcForm to: destPt	| sourceOrigin |	sourceForm := srcForm.	halftoneForm := nil.	combinationRule := 3.  "store"	destX := destPt x.	destY := destPt y.	sourceOrigin := sourceRectangle origin.	sourceX := sourceOrigin x.	sourceY := sourceOrigin y.	width := sourceRectangle width.	height := sourceRectangle height.	colorMap := srcForm colormapIfNeededFor: destForm.	self copyBits! !!ColorMap methodsFor: 'private' stamp: 'ar 2/22/2000 16:47'!setShifts: shiftArray masks: maskArray colors: colorArray	shiftArray ifNotNil:[shifts := shiftArray asIntegerArray].	maskArray ifNotNil:[masks := maskArray asWordArray].	colorArray ifNotNil:[colors := colorArray asWordArray].! !!Form methodsFor: 'bordering' stamp: ''!shapeBorder: aColor width: borderWidth interiorPoint: interiorPoint	sharpCorners: sharpen internal: internal	"Identify the shape (region of identical color) at interiorPoint,	and then add an outline of width=borderWidth and color=aColor.	If sharpen is true, then cause right angles to be outlined by	right angles.  If internal is true, then produce a border that lies	within the identified shape.  Thus one can put an internal border	around the whole background, thus effecting a normal border	around every other foreground image."	| shapeForm borderForm interiorColor |	"First identify the shape in question as a B/W form"	interiorColor := self colorAt: interiorPoint.	shapeForm := (self makeBWForm: interiorColor) reverse				findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Reverse the image to grow the outline inward"	internal ifTrue: [shapeForm reverse].	"Now find the border fo that shape"	borderForm := shapeForm borderFormOfWidth: borderWidth sharpCorners: sharpen.	"Finally use that shape as a mask to paint the border with color"	self fillShape: borderForm fillColor: aColor! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 4/18/98 20:34'!colorsUsed	"Return a list of the colors actually used by this ColorForm."	| myColor list |	myColor := self colors.	list := OrderedCollection new.	self tallyPixelValues doWithIndex: [:count :i |		count > 0 ifTrue: [list add: (myColor at: i)]].	^ list asArray! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/24/2001 23:49'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old upTo: Character cr.		newLine := new upTo: Character cr.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!WarpBlt class methodsFor: 'examples' stamp: ''!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp := (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!Cursor class methodsFor: 'class initialization' stamp: ''!initDown	DownCursor  :=		     (Cursor	extent: 16@16	fromArray: #(		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r1111110000000000		2r111100000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!parseStartOfScan	| length n id value dcNum acNum comp |	length := self nextWord.	n := self next.	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].	currentComponents := Array new: n.	1 to: n do: [:i |		id := self next.		value := self next.		dcNum := (value >> 4) bitAnd: 16r0F.		acNum := value bitAnd: 16r0F.		comp := components detect: [:c | c id = id].		comp			dcTableIndex: dcNum+1;			acTableIndex: acNum+1.		currentComponents at: i put: comp].	ss := self next.	se := self next.	value := self next.	ah := (value >> 4) bitAnd: 16r0F.	al := value bitAnd: 16r0F.	self initialSOSSetup.	self perScanSetup.	sosSeen := true! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:20'!inkBrush	"Similar to simplePressurePen, but this example uses the average of the recent pen pressure values. The effect is that of a Japanese ink brush that comes up gradually off the paper as the brush is lifted, causing end (and beginning) of each stroke to taper. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen inkBrush"	| tabletScale historyMSecs pressureHistory pen now currentPressure sum averagePressure p |	tabletScale := self tabletScaleFactor.	historyMSecs := 120.	pressureHistory := OrderedCollection new.	pen := Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			"compute the average pressure over last historyMSecs milliseconds"			now := Time millisecondClockValue.			currentPressure := (20.0 * Sensor tabletPressure) rounded.			pressureHistory addLast: (Array with: now with: currentPressure).			[pressureHistory size > 0 and:			 [(pressureHistory first first + historyMSecs) < now]]				whileTrue: [pressureHistory removeFirst].  "prune old entries"			sum := pressureHistory inject: 0 into: [:t :e | t + e last].			averagePressure := sum // pressureHistory size.			p := (Sensor tabletPoint * tabletScale) rounded.		     averagePressure > 0				ifTrue: [					pen roundNib: averagePressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!Color methodsFor: 'conversions' stamp: ''!closestPixelValue2	"Return the nearest approximation to this color for a 2-bit deep Form."	| lum |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	lum := self luminance.	lum < 0.2 ifTrue: [^ 1].  "black"	lum > 0.6 ifTrue: [^ 2].  "opaque white"	^ 3  "50% gray"! !!CursorWithMask methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form := StaticForm extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'ar 3/15/1999 14:28'!flipBy: direction centerAt: aPoint	| oldColors newForm |	oldColors := colors.	self colors: nil.	newForm := super flipBy: direction centerAt: aPoint.	self colors: oldColors.	newForm colors: oldColors.	^newForm ! !!Cursor class methodsFor: 'constants' stamp: 'ar 9/26/2001 22:37'!webLink	"Return a cursor that can be used for emphasizing web links"	"Cursor webLink showWhile: [Sensor waitButton]"	^WebLinkCursor ifNil:[		WebLinkCursor :=  (CursorWithMask extent: 16@16			fromArray: #(3072 4608 4608 4608 4608 5046 4681 29257 37449 37449 32769 32769 49155 16386 24582 16380 )			offset: -5@0) setMaskForm:		(Form extent: 16@16 			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])			offset: 0@0)].! !!StrikeFont methodsFor: 'emphasis' stamp: 'tak 3/11/2005 17:09'!reset	"Reset the cache of derivative emphasized fonts"	| style font |	fallbackFont class = FixedFaceFont		ifTrue: [fallbackFont := nil].	derivativeFonts := Array new: 32.	#('B' 'I' 'BI') doWithIndex:		[:tag :index | 		(style := TextStyle named: self familyName) ifNotNil:			[(font := style fontArray				detect: [:each | each name = (self name , tag)]				ifNone: [nil]) ifNotNil: [derivativeFonts at: index put: font]]]! !!BitBlt methodsFor: 'accessing' stamp: ''!sourceRect: aRectangle 	"Set the receiver's source form top left x and y, width and height to be 	the top left coordinate and extent of the argument, aRectangle."	sourceX := aRectangle left.	sourceY := aRectangle top.	width := aRectangle width.	height := aRectangle height! !!Cursor class methodsFor: 'class initialization' stamp: ''!initNormal	NormalCursor :=   		(Cursor			extent: 16@16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1111111000000000		2r1111100000000000		2r1111100000000000		2r1001100000000000		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0@0).		! !!BitBlt methodsFor: 'line drawing' stamp: '6/8/97 15:41 di'!drawFrom: startPoint to: stopPoint withFirstPoint: drawFirstPoint	"Draw a line whose end points are startPoint and stopPoint.	The line is formed by repeatedly calling copyBits at every	point along the line.  If drawFirstPoint is false, then omit	the first point so as not to overstrike at line junctions."	| offset point1 point2 forwards |	"Always draw down, or at least left-to-right"	forwards := (startPoint y = stopPoint y and: [startPoint x < stopPoint x])				or: [startPoint y < stopPoint y].	forwards		ifTrue: [point1 := startPoint. point2 := stopPoint]		ifFalse: [point1 := stopPoint. point2 := startPoint].	sourceForm == nil ifTrue:		[destX := point1 x.		destY := point1 y]		ifFalse:		[width := sourceForm width.		height := sourceForm height.		offset := sourceForm offset.		destX := (point1 x + offset x) rounded.		destY := (point1 y + offset y) rounded].	"Note that if not forwards, then the first point is the last and vice versa.	We agree to always paint stopPoint, and to optionally paint startPoint."	(drawFirstPoint or: [forwards == false  "ie this is stopPoint"])		ifTrue: [self copyBits].	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded.	(drawFirstPoint or: [forwards  "ie this is stopPoint"])		ifTrue: [self copyBits].! !!Pen methodsFor: 'geometric designs' stamp: ''!mandala: npoints	"Display restoreAfter: [Pen new mandala: 30]"	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."	| l points d |	Display fillWhite.	d := Display height-50.	l := 3.14 * d / npoints.	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.	points := Array new: npoints.	1 to: npoints do: 		[:i | 		points at: i put: location rounded.		self go: l; turn: 360.0 / npoints].	npoints // 2		to: 1		by: -1		do: 			[:i | 			self color: i.			1 to: npoints do: 				[:j | 				self place: (points at: j).				self goto: (points at: j + i - 1 \\ npoints + 1)]]! !!Quadrangle methodsFor: 'displaying-generic' stamp: ''!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle := 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	borderWidth ~~ 0 & (insideColor ~~ nil)		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addKern: kernDelta	"Set the current kern amount."	kern := kern + kernDelta! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!widthInBlocks: anInteger	widthInBlocks := anInteger! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:37'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm := Bitmap new: (1 bitShift: (self depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice := Form extent: width@1 depth: 1.	copyBlt := (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt := (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top := (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom := (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH := bottom - top + 1.	slice := Form extent: 1@newH depth: 1.	copyBlt := (BitBlt current toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt := (BitBlt current toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left := (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right := (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!plainTab	| oldX |	oldX := destX.	super plainTab.	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits]! !!WarpBlt methodsFor: 'primitives' stamp: ''!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n >= 1"	| fixedPtOne |	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	x2 > x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight := lineHeightAtSpace.		baseline := baselineAtSpace.		spaceCount := spaceCount - 1.		spaceIndex := spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount := spaceCount - 1.				"Account for backing over a run which might					change width of space."				font := text fontAt: spaceIndex withStyle: textStyle.				spaceIndex := spaceIndex - 1.				spaceX := spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex := lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX := destX - (font widthOf: (text at: lastIndex)).				lastIndex := lastIndex - 1].		spaceX := destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'tk 2/19/1999 07:20'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file := FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f := Form fromUser) boundingBox area>25] whileTrue:	[f writeUncompressedOnFileNamed: 'test.form'.	(Form fromBinaryStream: (FileStream oldFileNamed: 'test.form')) display]."! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!characterPointSetX: xVal	characterPoint := xVal @ characterPoint y! !!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:31'!clipBy: aRectangle	| aPoint right bottom |	right := clipX + clipWidth.	bottom := clipY + clipHeight.	aPoint := aRectangle origin.	aPoint x > clipX ifTrue:[clipX := aPoint x].	aPoint y > clipY ifTrue:[clipY := aPoint y].	aPoint := aRectangle corner.	aPoint x < right ifTrue:[right := aPoint x].	aPoint y < bottom ifTrue:[bottom := aPoint y].	clipWidth := right - clipX.	clipHeight := bottom - clipY.	clipWidth < 0 ifTrue:[clipWidth := 0].	clipHeight < 0 ifTrue:[clipHeight := 0].! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:43'!readBitsFrom: aBinaryStream		bits := Bitmap newFromStream: aBinaryStream.	bits size = self bitsSize ifFalse: [self error: 'wrong bitmap size; bad Form file?'].	^ self! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'RAA 2/25/2001 14:55'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				lastIndex := lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 1/19/2005 11:22'!readEFontBDFFromFile: fileName name: aString ranges: ranges	| fontReader stream |	fontReader := EFontBDFFontReaderForRanges readOnlyFileNamed: fileName.	stream := ReadStream on: (fontReader readRanges: ranges).	xTable := stream next.	glyphs := stream next.	minAscii := stream next.	maxAscii := stream next.	maxWidth := stream next.	ascent := stream next.	descent := stream next.	pointSize := stream next.	name := aString.	type := 0. "no one see this"	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	self reset.! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			spaceX := destX.			line paddingWidth: rightMargin - destX.			^true]	ifFalse:	[runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).			runStopIndex := lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!InfiniteForm methodsFor: 'displaying' stamp: 'nk 4/17/2004 19:48'!displayOnPort: aPort offsetBy: offset	| targetBox patternBox savedMap top left |	"this version tries to get the form aligned where the user wants it and not just aligned with the cliprect"	(patternForm isForm) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox := aPort clipRect.	patternBox := patternForm boundingBox.	savedMap := aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededFor: aPort destForm).	top := (targetBox top truncateTo: patternBox height) + offset y.	left :=  (targetBox left truncateTo: patternBox width) + offset x.	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!BitBlt methodsFor: 'accessing' stamp: ''!destOrigin: aPoint 	"Set the receiver's destination top left coordinates to be those of the 	argument, aPoint."	destX := aPoint x.	destY := aPoint y! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!readOneCharacter	| str a encoding bbx form bits hi low pos |	((str := self getLine) beginsWith: 'ENDFONT') ifTrue: [^ {nil. nil. nil}].	(str beginsWith: 'STARTCHAR') ifFalse: [self errorFileFormat].	((str := self getLine) beginsWith: 'ENCODING') ifFalse: [self errorFileFormat].	encoding := Integer readFromString: str substrings second.	(self getLine beginsWith: 'SWIDTH') ifFalse: [self errorFileFormat].	(self getLine beginsWith: 'DWIDTH') ifFalse: [self errorFileFormat].		((str := self getLine) beginsWith: 'BBX') ifFalse: [self errorFileFormat].	a := str substrings.	bbx := (2 to: 5) collect: [:i | Integer readFromString: (a at: i)].	((str := self getLine) beginsWith: 'ATTRIBUTES') ifTrue: [str := self getLine].	(str beginsWith: 'BITMAP') ifFalse: [self errorFileFormat].	form := Form extent: (bbx at: 1)@(bbx at: 2).	bits := form bits.	pos := 0.	1 to: (bbx at: 2) do: [:t |		1 to: (((bbx at: 1) - 1) // 8 + 1) do: [:i |			hi := (('0123456789ABCDEF' indexOf: (file next asUppercase)) - 1) bitShift: 4.			low := ('0123456789ABCDEF' indexOf: (file next asUppercase)) - 1.						bits byteAt: (pos+i) put: (hi+low).		].		file next ~= Character cr ifTrue: [self errorFileFormat].		pos := pos + ((((bbx at: 1) // 32) + 1) * 4).	].	(self getLine beginsWith: 'ENDCHAR') ifFalse: [self errorFileFormat].	encoding < 0 ifTrue: [^{nil. nil. nil}].	^{form. encoding. bbx}.			! !!Form methodsFor: 'copying' stamp: 'ar 5/28/2000 12:08'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f := Form fromUser. f2 := Form fromDisplay: (0@0 extent: f extent). f3 := f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 20:55'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte := stream decodeValueFrom: huffmanDC.	byte ~= 0 ifTrue: [byte := self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte := aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i := 2.	[i <= DCTSize2] whileTrue:		[byte := stream decodeValueFrom: huffmanAC.		zeroCount := byte >> 4.		byte := byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i := i + zeroCount.				byte := self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i := i + zeroCount] ifFalse: [^ self]].		i := i + 1]		! !!InfiniteForm methodsFor: 'displaying' stamp: 'nk 4/17/2004 19:48'!displayOnPort: aPort at: offset	| targetBox patternBox savedMap top left |	self flag: #bob.	"this *may* not get called at the moment. I have been trying to figure out the right way for this to work and am using #displayOnPort:offsetBy: as my current offering - Bob"	(patternForm isForm) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aPort fill: aPort clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox := aPort clipRect.	patternBox := patternForm boundingBox.	savedMap := aPort colorMap.	aPort sourceForm: patternForm;		fillColor: nil;		combinationRule: Form paint;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededFor: aPort destForm).	top := (targetBox top truncateTo: patternBox height) "- (offset y \\ patternBox height)".	left :=  (targetBox left truncateTo: patternBox width) "- (offset x \\ patternBox width)".	left to: (targetBox right - 1) by: patternBox width do:		[:x | top to: (targetBox bottom - 1) by: patternBox height do:			[:y | aPort destOrigin: x@y; copyBits]].	aPort colorMap: savedMap.! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 22:52'!initWrite	WriteCursor := (Cursor	extent: 16@16	fromArray: #(		2r0000000000011000		2r0000000000111100		2r0000000001001000		2r0000000010010000		2r0000000100100000		2r0000001001000100		2r0000010010000100		2r0000100100001100		2r0001001000010000		2r0010010000010000		2r0111100000001000		2r0101000011111000		2r1110000110000000		2r0111111100000000		2r0		2r0)	offset: 0@0).! !!StrikeFont methodsFor: 'character shapes' stamp: 'ar 5/23/2000 12:48'!extendMaxAsciiTo: newMax	"Extend the range of this font so that it can display glyphs up to newMax."	(newMax+3) <= xTable size ifTrue: [^ self].  "No need to extend."	xTable size = (maxAscii+3) ifFalse:		[^ self error: 'This font is not well-formed.'].	"Insert a bunch of zero-width characters..."	xTable := (xTable copyFrom: 1 to: maxAscii+2) ,			((maxAscii+1 to: newMax) collect: [:i | xTable at: maxAscii+2]) ,			{ xTable at: maxAscii+3 }.	maxAscii := newMax.	self fillZeroWidthSlots.	characterToGlyphMap := nil.! !!CharacterScanner methodsFor: 'scanning' stamp: 'yo 9/23/2002 16:13'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex := startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX := destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX := nextDestX + kernDelta.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops at: EndOfRun! !!Pen methodsFor: 'operations' stamp: 'sw 10/5/2002 02:29'!arrowHeadForArrowSpec: anArrowSpec	"Put an arrowhead on the previous pen stroke""	 | pen aPoint |	aPoint := Point fromUser.	pen := Pen new.	20 timesRepeat: [pen turn: 360//20; go: 20; arrowHeadForArrowSpec: aPoint]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: anArrowSpec]! !!Form methodsFor: 'fileIn/Out' stamp: 'nk 12/31/2003 16:06'!store15To24HexBitsOn:aStream	| buf i lineWidth |	"write data for 16-bit form, optimized for encoders writing directly to files to do one single file write rather than 12. I'm not sure I understand the significance of the shifting pattern, but I think I faithfully translated it from the original"	lineWidth := 0.	buf := String new: 12.	bits do: [:word | 		i := 0.		"upper pixel"		buf at: (i := i + 1) put: ((word bitShift: -27) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -32) bitAnd: 8) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -22) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -27) bitAnd: 8) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -17) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -22) bitAnd: 8) asHexDigit.		"lower pixel"		buf at: (i := i + 1) put: ((word bitShift: -11) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -16) bitAnd: 8) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -6) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -11) bitAnd: 8) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -1) bitAnd: 15) asHexDigit.		buf at: (i := i + 1) put: ((word bitShift: -6) bitAnd: 8) asHexDigit.		aStream nextPutAll: buf.		lineWidth := lineWidth + 12.		lineWidth > 100 ifTrue: [ aStream cr. lineWidth := 0 ].		"#( 31 26 21 15 10 5 )  do:[:startBit | ]"	].! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'hmm 7/16/2000 08:23'!tab	self plainTab.	lastIndex := lastIndex + 1.	^ false! !!AbstractFont methodsFor: 'measuring' stamp: 'ar 12/31/2001 00:54'!widthOfString: aString from: startIndex to: stopIndex	"Measure the length of the given string between start and stop index"	| character resultX |	resultX := 0.	startIndex to: stopIndex do:[:i | 		character := aString at: i.		resultX := resultX + (self widthOf: character)].	^resultX! !!Cursor class methodsFor: 'class initialization' stamp: ''!initCorner	CornerCursor := 		(Cursor 			extent: 16@16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16@-16).! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:44'!readPlainGray	"plain gray"	| val form poker aux tokens |	form := Form extent: cols@rows depth: depth.	poker := BitBlt current bitPokerToForm: form.	tokens := OrderedCollection new.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			aux := self getTokenPbm: tokens.			val := aux at: 1. tokens := aux at: 2.			poker pixelAt: x@y put: val.		]	].	^form! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt current destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f := Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 := Form fromDisplay: (0@0 extent: f extent). f3 := f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 := f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'analyzing' stamp: ''!cgForPixelValue: pv orNot: not	"Return the center of gravity for all pixels of value pv.	Note:  If orNot is true, then produce the center of gravity for all pixels	that are DIFFERENT from the supplied (background) value"	| pixCount weighted xAndY |	xAndY := (Array with: (self xTallyPixelValue: pv orNot: not)					with: (self yTallyPixelValue: pv orNot: not)) collect:		[:profile |	"For both x and y profiles..."		pixCount := 0.  weighted := 0.		profile doWithIndex:			[:t :i | pixCount := pixCount + t.			weighted := weighted + (t*i)].		pixCount = 0  "Produce average of nPixels weighted by coordinate"			ifTrue: [0.0]			ifFalse: [weighted asFloat / pixCount asFloat - 1.0]].	^ xAndY first @ xAndY last"| f cg |[Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: (Sensor cursorPoint extent: 50@50).	cg := f cgForPixelValue: (Color black pixelValueForDepth: f depth) orNot: false.	f displayAt: 0@0.	Display fill: (cg extent: 2@2) fillColor: Color red].	ScheduledControllers restore"! !!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:08'!alphaBlendDemo	"To run this demo, use...		Display restoreAfter: [BitBlt alphaBlendDemo]		Displays 10 alphas, then lets you paint.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 := Color cachedColormapFrom: Display depth to: 32.		map32toD := Color cachedColormapFrom: 32 to: Display depth].	"display 10 different alphas, across top of screen"	buff := Form extent: 500@50 depth: 32.	dispToBuff := BitBlt toForm: buff.	dispToBuff colorMap: mapDto32.	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)						fillColor: (Color red alpha: i/10)						rule: Form blend].	buffToDisplay := BitBlt toForm: Display.	buffToDisplay colorMap: map32toD.	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.	"Create a brush with radially varying alpha"	brush := Form extent: 30@30 depth: 32.	1 to: 5 do: 		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)				fillColor: (Color red alpha: 0.02 * i - 0.01)				at: brush extent // 2].	"Now paint with the brush using alpha blending."	buffSize := 100.	buff := Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"	dispToBuff := BitBlt toForm: buff.  "This is from Display to buff"	dispToBuff colorMap: mapDto32.	brushToBuff := BitBlt toForm: buff.  "This is from brush to buff"	brushToBuff sourceForm: brush; sourceOrigin: 0@0.	brushToBuff combinationRule: Form blend.	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP := nil.		buffRect := Sensor cursorPoint - (buffSize // 2) extent: buff extent.		dispToBuff copyFrom: buffRect in: Display to: 0@0.		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p := Sensor cursorPoint - (brush extent // 2).			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP := p].				(p dist: prevP) > buffSize ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta := (p-prevP) theta.					p := ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].				brushRect := p extent: brush extent.				(buffRect containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta := brushRect amountToTranslateWithin: buffRect.					buffToBuff copyFrom: buff boundingBox in: buff to: delta.					newBuffRect := buffRect translateBy: delta negated.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin].					buffRect := newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP - buffRect origin									to: p - buffRect origin									withFirstPoint: false.				"Update (only) the altered pixels of the destination"				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.				prevP := p]]]! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'ar 5/28/2000 12:06'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location := loc.   rect1 := location extent: self extent.   save1 := initialBitsBehind.   save1Blt := BitBlt current toForm: save1.   buffer := Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt := BitBlt current toForm: buffer.   Display deferUpdates: true.   self displayOn: Display at: location rule: Form paint.   Display deferUpdates: false; forceToScreen: (location extent: self extent).   [durationBlock value] whileTrue: [		newLoc := locationBlock value.		newLoc ~= location ifTrue: [			rect2 := newLoc extent: self extent.			bothRects := rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					self displayOnPort: bufferBlt at: rect2 origin - bothRects origin rule: Form paint.					Display deferUpdates: true.					Display copy: bothRects from: 0@0 in: buffer rule: Form over.					Display deferUpdates: false; forceToScreen: bothRects]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display deferUpdates: true.					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint.					Display deferUpdates: false; 						forceToScreen: (location extent: save1 extent); 						forceToScreen: (newLoc extent: self extent)].			location := newLoc.			rect1 := rect2]].	^ save1 displayOn: Display at: location! !!Cursor class methodsFor: 'class initialization' stamp: ''!initXeq	XeqCursor := 		(Cursor			extent: 16@16			fromArray: #(		2r1000000000010000		2r1100000000010000		2r1110000000111000		2r1111000111111111		2r1111100011000110		2r1111110001000100		2r1111111001111100		2r1111000001101100		2r1101100011000110		2r1001100010000010		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0@0).! !!BitBlt methodsFor: 'accessing' stamp: ''!destRect: aRectangle 	"Set the receiver's destination form top left coordinates to be the origin of 	the argument, aRectangle, and set the width and height of the receiver's 	destination form to be the width and height of aRectangle."	destX := aRectangle left.	destY := aRectangle top.	width := aRectangle width.	height := aRectangle height! !!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!atLeastAsLuminentAs: aFloat	| revisedColor |	revisedColor := self.	[revisedColor luminance < aFloat] whileTrue: [revisedColor := revisedColor slightlyLighter].	^revisedColor! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 5/20/2004 11:01'!fallbackFont: aFontSetOrNil	fallbackFont := aFontSetOrNil.! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint := aPoint.	^self buildCharacterBlockIn: aParagraph! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 3/1/2006 23:04'!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify. scale can be a Point to make for interesting 3D effects "	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side := 1 + self extent r asInteger.	bigSide := (side asPoint * scale) rounded.	rot := self blankCopyOf: self boundingBox scaledBy: ( bigSide / self extent ).	warp := (WarpBlt current toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededFor: rot);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint.	r1 := (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts := r1 innerCorners collect:		[:pt | p := pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f := Form fromDisplay: (0@0 extent: 200@200).  a := 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a := a+5) magnify: 0.75@2 smoothing: 2) display].f display"! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 11/16/97 11:18'!ensureTransparentColor	"Ensure that the receiver (a) includes Color transparent in its color map and (b) that the entry for Color transparent is the first entry in its color map."	| i |self error: 'not yet implemented'.	(colors includes: Color transparent)		ifTrue: [			(colors indexOf: Color transparent) = 1 ifTrue: [^ self].			"shift the entry for color transparent"]		ifFalse: [			i := self unusedColormapEntry.			i = 0 ifTrue: [self error: 'no color map entry is available'].			colors at: i put: Color transparent.			"shift the entry for color transparent"].! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 3/18/2004 00:10'!fixAccuISO8859From: aStrikeFont	| f |	self reset.	xTable := aStrikeFont xTable copy.	glyphs := Form extent: aStrikeFont glyphs extent.	maxAscii := 255.	minAscii := 0.	"stopConditions := nil."	0 to: 127 do: [:i |		f := aStrikeFont characterFormAt: (Character value: i) isoToSqueak.		f width  = 0 ifTrue: [f := Form extent: 1@f height].				self characterFormAt: (Character value: i) put: f.	].	128 to: 159 do: [:i |		f := Form extent: 1@f height.		self characterFormAt: (Character value: i) put: f.	].	160 to: 255 do: [:i |		f := aStrikeFont characterFormAt: (Character value: i) isoToSqueak.		f width  = 0 ifTrue: [f := Form extent: 1@f height].				self characterFormAt: (Character value: i) put: f.	].			^ self.	! !!FormSetFont class methodsFor: 'examples' stamp: ''!example    "FormSetFont example"	"Lets the user select a (small) area of the screen to represent the	character A, then copies 'A' to the clipboard with that as the letter form.	Thereafter, a paste operation will imbed that character in any text."	| charForm |	charForm := Form fromUser.	self copy: charForm toClipBoardAs: $A ascent: charForm height! !!Form methodsFor: 'analyzing' stamp: 'jm 6/18/1999 18:41'!tallyPixelValues	"Answer a Bitmap whose elements contain the number of pixels in this Form with the pixel value corresponding to their index. Note that the pixels of multiple Forms can be tallied together using tallyPixelValuesInRect:into:."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r := Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies := (Display copy: r) tallyPixelValues.	nonZero := (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'mir 11/18/2003 17:00'!formsFromStream: stream 	| reader |	reader := self new on: stream reset.	Cursor read		showWhile: [reader allImages.			reader close].	^reader! !!CornerRounder methodsFor: 'all' stamp: 'ar 1/5/2002 17:26'!saveBitsUnderCornersOf: aMorph on: aCanvas in: bounds corners: cornerList	| offset corner mask form corners rect |	underBits := Array new: 4.	corners := bounds corners.	cornerList do:[:i|		mask := cornerMasks at: i.		corner := corners at: i.		i = 1 ifTrue: [offset := 0@0].		i = 2 ifTrue: [offset := 0@mask height negated].		i = 3 ifTrue: [offset := mask extent negated].		i = 4 ifTrue: [offset := mask width negated@0].		rect := corner + offset extent: mask extent.		(aCanvas isVisible: rect) ifTrue:[			form := aCanvas contentsOfArea: rect.			form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0).			underBits at: i put: form]].! !!GIFReadWriter methodsFor: 'private' stamp: ''!updatePixelPosition	(xpos := xpos + 1) >= width ifFalse: [^self].	xpos := 0.	interlace		ifFalse: [ypos := ypos + 1. ^self].	pass = 0 ifTrue:		[(ypos := ypos + 8) >= height			ifTrue:				[pass := pass + 1.				ypos := 4].		^self].	pass = 1 ifTrue:		[(ypos := ypos + 8) >= height			ifTrue:				[pass := pass + 1.				ypos := 2].		^self].	pass = 2 ifTrue:		[(ypos := ypos + 4) >= height			ifTrue:				[pass := pass + 1.				ypos := 1].		^self].	pass = 3 ifTrue:		[ypos := ypos + 2.		^self].	^self error: 'can''t happen'! !!Form methodsFor: 'private' stamp: 'tk 3/13/2000 15:21'!hackBits: bitThing	"This method provides an initialization so that BitBlt may be used, eg, to 	copy ByteArrays and other non-pointer objects efficiently.	The resulting form looks 4 wide, 8 deep, and bitThing-size-in-words high."	width := 4.	depth := 8.	bitThing class isBits ifFalse: [self error: 'bitThing must be a non-pointer object'].	bitThing class isBytes		ifTrue: [height := bitThing basicSize // 4]		ifFalse: [height := bitThing basicSize].	bits := bitThing! !!CharacterBlockScanner methodsFor: 'private' stamp: 'tlk 5/7/2006 16:42'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1 alignment: (alignment ifNil:[textStyle alignment]))								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex := para lineIndexOfTop: characterPoint y.	destY := para topAtLineIndex: lineIndex.	line := para lines at: lineIndex.	lastIndex := line first.	rightMargin := para rightMarginForDisplay.     self setStopConditions.  " also loads the font and loads all emphasis attributes "	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint := (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX := (leftMargin := para leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment])).	nextLeftMargin:= para leftMarginForDisplayForLine: lineIndex+1 alignment: (alignment ifNil:[textStyle alignment]).	lastIndex := line first.	self setStopConditions.		"also sets font"	runLength := (text runLengthFor: line first).	characterIndex == nil		ifTrue:	[lineStop := line last  "characterBlockAtPoint"]		ifFalse:	[lineStop := characterIndex  "characterBlockForIndex"].	(runStopIndex := lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex := lineStop].	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0. done  := false.	self handleIndentation.	[done]	whileFalse:	[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition) ifTrue:		[characterIndex == nil			ifTrue: ["characterBlockAtPoint"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + (font descentKern @ 0)						extent: lastCharacterExtent]			ifFalse: ["characterBlockForIndex"					^ CharacterBlock new stringIndex: lastIndex text: text						topLeft: characterPoint + ((font descentKern) - kern @ 0)						extent: lastCharacterExtent]]]! !!Rectangle methodsFor: 'transforming' stamp: 'JMM 10/21/2003 17:28'!newRectFrom: newRectBlock	"Track the outline of a new rectangle until mouse button changes.	newFrameBlock produces each new rectangle from the previous"	| rect newRect buttonStart buttonNow aHand delay |	delay := Delay forMilliseconds: 10.	buttonStart := buttonNow := Sensor anyButtonPressed.	rect := self.	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	[buttonNow == buttonStart] whileTrue: 		[delay wait.		buttonNow := Sensor anyButtonPressed.		newRect := newRectBlock value: rect.		newRect = rect ifFalse:			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.			rect := newRect]].	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	" pay the price for reading the sensor directly ; get this party started "	Smalltalk isMorphic		ifTrue: [aHand := World activeHand.			aHand newMouseFocus: nil;				 showTemporaryCursor: nil;				 flushEvents].	Sensor processEvent: Sensor createMouseEvent.	^ rect! !!Point methodsFor: 'private' stamp: 'ar 4/4/1999 00:40'!bitShiftPoint: bits	x := x bitShift: bits.	y := y bitShift: bits.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 16:22'!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !!StrikeFont class methodsFor: 'instance creation' stamp: 'nop 1/23/2000 19:21'!newFromBDFFile: aFileName name: aString  "StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'"	"Read a font from disk in the X11 Bitmap Distribution Format."	| n |	n := self new.	n readBDFFromFile: aFileName name: aString.	^n.	"TextConstants at: #Helvetica put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'})"	"TextConstants at: #Lucida put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'luRS12.bdf' name: 'Lucida'})"	"TextStyle default fontAt: 5 put: (StrikeFont new readFromStrike2: 'helv12.sf2')."! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:24'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt := self qTable at: (aColorComponent qTableIndex).	ws := Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 := (anArray at: i) * (qt at: i).		t1 := (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 := (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 := (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 := t0 + t2.		t11 := t0 - t2.		t13 := t1 + t3.		t12 := (t1 - t3) * DCTK1 - t13.		t0 := t10 + t13.		t3 := t10 - t13.		t1 := t11 + t12.		t2 := t11 - t12.		t4 := (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 := (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 := (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 := (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 := t6 + t5.		z10 := t6 - t5.		z11 := t4 + t7.		z12 := t4 - t7.		t7 := z11 + z13.		t11 := (z11 - z13) * DCTK1.		z5 := (z10 + z12) * DCTK2.		t10 := DCTK3 * z12 - z5.		t12 := DCTK4 * z10 + z5.		t6 := t12 - t7.		t5 := t11 - t6.		t4 := t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |		t10 := (ws at: (i+1)) + (ws at: (i+5)).		t11 := (ws at: (i+1)) - (ws at: (i+5)).		t13 := (ws at: (i+3)) + (ws at: (i+7)).		t12 := ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 := t10 + t13.		t3 := t10 - t13.		t1 := t11 + t12.		t2 := t11 - t12.		z13 := (ws at: (i+6)) + (ws at: (i+4)).		z10 := (ws at: (i+6)) - (ws at: (i+4)).		z11 := (ws at: (i+2)) + (ws at: (i+8)).		z12 := (ws at: (i+2)) - (ws at: (i+8)).		t7 := z11 + z13.		t11 := (z11 - z13) * DCTK1.		z5 := (z10 + z12) * DCTK2.		t10 := DCTK3 * z12 - z5.		t12 := DCTK4 * z10 + z5.		t6 := t12 - t7.		t5 := t11 - t6.		t4 := t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!Form methodsFor: 'bordering' stamp: 'ar 5/17/2001 15:42'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm := self deepCopy.	all := bigForm boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt current toForm: smearForm.	sharpen ifTrue:		[cornerForm := Form extent: self extent.		cornerPort := BitBlt current toForm: cornerForm].	nbrs := (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:44'!readGray	"gray form"	| val form poker |	maxValue > 255 ifTrue:[self error:'Gray value > 8 bits not supported in Squeak'].	stream binary.	form := Form extent: cols@rows depth: depth.	poker := BitBlt current bitPokerToForm: form.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val := stream next.			poker pixelAt: x@y put: val.		]	].	^form! !!BDFFontReader methodsFor: 'initialize' stamp: 'nop 1/18/2000 19:44'!initialize	properties := Dictionary new.! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/28/1999 09:05'!transform: aPoint	"Transform the given point from global to local coordinates."	| p2 p3 |	self isPureTranslation ifTrue: [^ aPoint + offset].	p2 := aPoint + offset.	p3 := (((p2 x * angle cos) - (p2 y * angle sin))		@ ((p2 y * angle cos) + (p2 x * angle sin)))			/ scale.	^ p3! !!Rectangle methodsFor: 'testing' stamp: 'ar 9/10/2000 15:29'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false].	^ true! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:20'!debugging: aBoolean	Debugging := aBoolean! !!GIFReadWriter methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:18'!nextImage	"Read in the next GIF image from the stream. Read it all intomemory first for speed."	| f thisImageColorTable |	stream class == ReadWriteStream ifFalse: [		stream binary.		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable := nil.	self readHeader.	f := self readBody.	self close.	f == nil ifTrue: [^ self error: 'corrupt GIF file'].	thisImageColorTable := localColorTable ifNil: [colorPalette].	transparentIndex ifNotNil: [		transparentIndex + 1 > thisImageColorTable size ifTrue: [			thisImageColorTable := thisImageColorTable 				forceTo: transparentIndex + 1 				paddingWith: Color white		].		thisImageColorTable at: transparentIndex + 1 put: Color transparent	].	f colors: thisImageColorTable.	^ f! !!Color class methodsFor: 'other' stamp: ''!shutDown	"Color shutDown"	ColorChart := nil.		"Palette of colors for the user to pick from"	CachedColormaps := nil.	"Maps to translate between color depths"	MaskingMap := nil.		"Maps all colors except transparent to black for creating a mask"! !!Form methodsFor: 'displaying' stamp: 'ar 2/13/2001 22:13'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine adjustedR |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine := (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	"there seems to be a slight bug in B3D which the following adjusts for"	adjustedR := (aRectangle withRight: aRectangle right + 1) translateBy: 0@1.	engine viewport: adjustedR.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!Form methodsFor: 'filling' stamp: ''!fillFromYColorBlock: colorBlock	"Vertical Gradient Fill.	Supply relative y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| yRel |	0 to: height-1 do:		[:y |  yRel := y asFloat / (height-1) asFloat.		self fill: (0@y extent: width@1) 			fillColor: (colorBlock value: yRel)]"((Form extent: 100@100 depth: Display depth)	fillFromYColorBlock: [:y | Color r: y g: 0.0 b: 0.5]) display"! !!Form methodsFor: 'accessing' stamp: ''!depth: bitsPerPixel	(bitsPerPixel > 32 or:		[(bitsPerPixel bitAnd: bitsPerPixel-1) ~= 0])		ifTrue: [self halt: 'bitsPerPixel must be 1, 2, 4, 8, 16 or 32'].	depth := bitsPerPixel! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:04'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor := Cursor new.		self initXeq.		self initSquare.		self initNormalWithMask.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		self initBottomLeft.		self initBottomRight.		self initResizeLeft.		self initResizeTop.		self initResizeTopLeft.		self initResizeTopRight.		self initTopLeft.		self initTopRight.		self makeCursorsWithMask.		"Cursor initialize"! !!HostFont methodsFor: 'private-creation' stamp: 'yo 2/14/2004 01:41'!fontName: fontName size: ptSize emphasis: emphasisCode rangesArray: rangesArray	"		^HostFont fontName: ('MS UI Gothic') size: 12 emphasis: 0 rangesArray: EFontBDFFontReaderForRanges basicNew rangesForJapanese.	"	| fontHandle xStart w glyphForm fontHeight fw enc rangesStream currentRange |	fontHandle := self primitiveCreateFont: fontName size: ptSize emphasis: emphasisCode.	fontHandle ifNil:[^nil].	ranges := rangesArray.	ranges ifNil: [ranges := Array with: (Array with: 0 with: 255)].	pointSize := ptSize.	name := fontName.	emphasis := emphasisCode.	minAscii := 0.	maxAscii := ranges last last.	ascent := self primitiveFontAscent: fontHandle.	descent := self primitiveFontDescent: fontHandle.	kernPairs := Array new: (self primitiveFontNumKernPairs: fontHandle).	1 to: kernPairs size do:[:i|		kernPairs at: i put: (self primitiveFont: fontHandle getKernPair: i)].	fontHeight := ascent + descent.	xTable := Array new: maxAscii + 3.	fullWidth := Array new: maxAscii + 1.	xStart := maxWidth := 0.	rangesStream := ReadStream on: (ranges collect: [:e | (e first to: e second)]).	currentRange := rangesStream next.	0 to: maxAscii do:[:i|		xTable at: i+1 put: xStart.		i > currentRange last ifTrue: [			[rangesStream atEnd not and: [currentRange := rangesStream next. currentRange last < i]] whileTrue.			rangesStream atEnd ifTrue: [].		].		(currentRange includes: i) ifTrue: [			xTable at: i+1 put: xStart.			fw := self primitiveFont: fontHandle fullWidthOfChar: i.			(#(	1 "anchored morph"				9 "tab"				10 "LF"				13 "CR"			) includes: i) ifTrue:[fw := {0. 0. 0}].			fullWidth at: i+1 put: fw.			w := fw at: 2.			(fw at: 1) > 0 ifTrue:[w := w + (fw at: 1)].			(fw at: 3) > 0 ifTrue:[w := w + (fw at: 3)].			w > maxWidth ifTrue:[maxWidth := w].			xStart := xStart + w].		].	xStart = 0 ifTrue:[^nil].	strikeLength := xStart.	xTable at: maxAscii+1 put: xStart.	xTable at: maxAscii+2 put: xStart.	xTable at: maxAscii+3 put: xStart.	glyphs := Form extent: xTable last @ fontHeight depth: 1.	glyphForm := Form extent: maxWidth @ fontHeight depth: 1.	0 to: maxAscii do:[:i|		glyphForm fillWhite.		self primitiveFont: fontHandle glyphOfChar: i into: glyphForm.		xStart := xTable at: i+1.		glyphForm displayOn: glyphs at: xStart@0.		"glyphForm displayOn: Display at: xStart@0."	].	enc := self primitiveFontEncoding: fontHandle.	enc = 1 ifTrue:[characterToGlyphMap := self isoToSqueakMap].	self primitiveDestroyFont: fontHandle.	^self! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/23/2000 12:52'!characterToGlyphMap: anArray	characterToGlyphMap := anArray.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'BG 3/16/2005 08:24'!parseNextMarker	"Parse the next marker of the stream"	| byte discardedBytes |	discardedBytes := 0.	[(byte := self next) = 16rFF] whileFalse: [discardedBytes := discardedBytes + 1].		[[(byte := self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes := discardedBytes + 2].	discardedBytes > 0 ifTrue: [self "notifyWithLabel: 'warning: extraneous data discarded'"].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte printStringHex , ' cannot be handled']])! !!Quadrangle methodsFor: 'bordering' stamp: ''!borderWidth: anInteger 	"Set the borderWidth of the receiver to anInteger."	borderWidth := anInteger! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/16/2003 17:22'!testFromString	"read SE file from string		PNMReadWriter testFromString	"	| prw f s |	prw := self new.	s := 'P1#origin 1 03 11	01'.	prw stream: (ReadStream on: s from: 1 to: (s size)).	f := prw nextImage.	f morphEdit.	Transcript cr;show:'Origin=', prw origin asString; cr.! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 4/26/2001 21:04'!benchmark3		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!Pen methodsFor: 'operations' stamp: 'di 11/4/97 20:11'!goto: aPoint 	"Move the receiver to position aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change."	| old |	old := location.	location := aPoint.	penDown ifTrue: [self drawFrom: old rounded								to: location rounded]	"NOTE:  This should be changed so it does NOT draw the first point, so as	not to overstrike at line junctions.  At the same time, place should draw	a single dot if the pen is down, as should down (put-pen-down) if it	was not down before."! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk 5/7/1998 17:35'!formFromServerFile: fileName	"Answer a ColorForm stored on the file with the given name.  Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	| form urls doc |	urls := Utilities serverUrls collect:		[:url | url, fileName].  " fileName starts with: 'updates/'  "	urls do: [:aURL |		(fileName findTokens: '.') last asLowercase = 'gif' ifTrue: [			form := HTTPSocket httpGif: aURL.			form = (ColorForm extent: 20@20 depth: 8) 				ifTrue: [self inform: 'The file ',aURL,' is ill formed.'].			^ form].		(fileName findTokens: '.') last asLowercase = 'bmp' ifTrue: [			doc := HTTPSocket httpGet: aURL accept: 'image/bmp'.			form := Form fromBMPFile: doc.			doc close.			form ifNil: [self inform: 'The file ',aURL,' is ill formed.'. ^ Form new]				ifNotNil: [^ form]].		self inform: 'File ', fileName, 'does not end with .gif or .bmp'].	self inform: 'That file not found on any server we know'.! !!Cursor class methodsFor: 'class initialization' stamp: 'jrp 8/7/2005 07:54'!initResizeTopRight       ResizeTopRightCursor :=               (Cursor extent: 16@16 fromArray: #(               2r0000000000000000               2r0000000001111100               2r0000000000111100               2r0000000000011100               2r0000000000101100               2r0000000001000100               2r0000000010000000               2r0000000100000000               2r0000001000000000               2r0100010000000000               2r0110100000000000               2r0111000000000000               2r0111100000000000               2r0111110000000000               2r0000000000000000               2r0000000000000000)       offset: -7@-7) withMask! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 9/28/2004 16:55'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	^self rotateBy: deg magnify: 1 smoothing: cellSize" | a f |  f := Form fromDisplay: (0@0 extent: 200@200).  a := 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a := a+5) smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'tpr 9/28/2004 17:00'!magnify: aRectangle by: scale smoothing: cellSize        "Answer a Form created as a scaling of the receiver.        Scale may be a Float or even a Point, and may be greater or less than 1.0."        | newForm |        newForm := self blankCopyOf: aRectangle scaledBy: scale.        (WarpBlt current toForm: newForm)                sourceForm: self;                colorMap: (self colormapIfNeededFor: newForm);                cellSize: cellSize;  "installs a new colormap if cellSize > 1"                combinationRule: 3;                copyQuad: aRectangle innerCorners toRect: newForm boundingBox.        ^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f := Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:        [cp := Sensor cursorPoint.        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!FontSet class methodsFor: 'compiling' stamp: 'di 1/24/2005 12:40'!compileFont: strikeFont 	| tempName literalString header sizeStr familyName |	tempName := 'FontTemp.sf2'.	strikeFont writeAsStrike2named: tempName.	literalString := (Base64MimeConverter mimeEncode: (FileStream readOnlyFileNamed: tempName) binary) contents fullPrintString.	sizeStr := strikeFont pointSize asString.	familyName := strikeFont name first: (strikeFont name findLast: [:x | x isDigit not]).	header := 'size' , sizeStr , '	^ self fontNamed: ''' , familyName , sizeStr , ''' fromMimeLiteral:' .	self class		compile: header , literalString		classified: 'fonts'		notifying: nil.	FileDirectory default deleteFileNamed: tempName! !!PNGReadWriter methodsFor: 'writing' stamp: 'nk 2/17/2004 14:57'!writeIDATChunkOn: aStream	"Write the IDAT chunk"	| z |	aStream nextPutAll: 'IDAT' asByteArray.	z := ZLibWriteStream on: aStream.	form depth <= 8 		ifTrue:[self writeType3DataOn: z]		ifFalse:[ self writeType6DataOn: z].	self debugging ifTrue: [		Transcript cr;			nextPutAll: 'compressed size=';			print: aStream position;			nextPutAll: ' uncompressed size=';			print: z position  ]! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastCharacterExtentSetX: xVal	lastCharacterExtent := xVal @ lastCharacterExtent y! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab := true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab := false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!Point methodsFor: 'private' stamp: 'sw 3/21/2000 13:24'!setX: xValue setY: yValue	x := xValue.	y := yValue! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 8/28/2002 16:35'!fixXTable	| newXTable val |	xTable size >= 258 ifTrue: [		^ self.	].	newXTable := Array new: 258.	1 to: xTable size do: [:i |		newXTable at: i put: (xTable at: i).	].	val := xTable at: (xTable size).		xTable size + 1 to: 258 do: [:i |		newXTable at: i put: val.	].	minAscii := 0.	maxAscii := 255.	xTable := newXTable.! !!Point methodsFor: 'point functions' stamp: 'ar 8/26/2001 22:15'!normalized	"Optimized for speed -- ar 8/26/2001"	| r |	r := ((x*x) + (y * y)) sqrt.	^(x / r) @ (y / r)! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!parseStartOfInput	restartInterval := 0.	densityUnit := 0.	xDensity := 1.	yDensity := 1! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hACTable	hACTable ifNil: [hACTable := Array new: HuffmanTableSize].	^ hACTable! !!BitBlt methodsFor: 'copying' stamp: ''!copy: destRectangle from: sourcePt in: srcForm	| destOrigin |	sourceForm := srcForm.	halftoneForm := nil.	combinationRule := 3.  "store"	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	self copyBits! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:38'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map := (Color cachedColormapFrom: self depth to: self depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!JPEGReadWriter2 class methodsFor: 'image reading/writing' stamp: 'jm 12/22/2001 11:55'!putForm: aForm quality: quality progressiveJPEG: progressiveFlag onFileNamed: fileName	"Store the given Form as a JPEG file of the given name, overwriting any existing file of that name. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."	| writer |	FileDirectory deleteFilePath: fileName.	writer := self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [		writer nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag].	writer close.! !!PNMReadWriter methodsFor: 'accessing' stamp: 'jdr 10/15/2003 15:35'!pragma: s	pragma := s! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 5/24/2004 17:54'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right.	In the process, characters would overlap, so we widen them all first.	"	| extraWidth newGlyphs newXTable x newX w extraOnLeft |  	extraOnLeft := (self height-1-self ascent+4)//4 max: 0.	extraWidth := ((self ascent-5+4)//4 max: 0) + extraOnLeft.	newGlyphs := Form extent: (glyphs width + (maxAscii + 1 - minAscii*extraWidth)) @ glyphs height.	newXTable := xTable copy.	"Copy glyphs into newGlyphs with room on left and right for overlap."	minAscii to: maxAscii+1 do:		[:ascii | x := xTable at: ascii+1.  w := (xTable at: ascii+2) - x.		newX := newXTable at: ascii+1.		newGlyphs copy: ((newX + extraOnLeft) @ 0 extent: w @ glyphs height)			from: x @ 0 in: glyphs rule: Form over.		newXTable at: ascii+2 put: newX + w + extraWidth].			glyphs := newGlyphs. 	xTable := newXTable.	"Slide the bitmaps left and right for synthetic italic effect."	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		glyphs copy: (1@0 extent: glyphs width @ (self ascent - y))			from: 0@0 in: glyphs rule: Form over].	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		glyphs copy: (0@y extent: glyphs width @ glyphs height)			from: 1@y in: glyphs rule: Form over].	fallbackFont ifNotNil: [		fallbackFont := fallbackFont emphasized: 2	].! !!JPEGReadWriter methodsFor: 'private' stamp: 'ar 3/4/2001 17:34'!on: aStream	super on: aStream.	stream := JPEGReadStream on: stream upToEnd.! !!DisplayText methodsFor: 'accessing' stamp: ''!offset: aPoint 	"Refer to the comment in DisplayObject|offset:."	offset := aPoint! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!initializeSampleStreamBlocks: aCollection	mcuBlocks := aCollection.	self resetSampleStream! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:08'!copyPixels: y at: startX by: incX	"Handle interlaced pixels of supported colorTypes"	| s |	s := #(copyPixelsGray:at:by: nil copyPixelsRGB:at:by: copyPixelsIndexed:at:by:		  copyPixelsGrayAlpha:at:by: nil copyPixelsRGBA:at:by:) at: colorType+1.	self perform: s asSymbol with: y with: startX with: incX! !!TextStyle methodsFor: 'private' stamp: ''!consolidate	"If this style includes any fonts that are also in the default style,	then replace them with references to the default ones.""	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]"	| defFonts font |	defFonts := TextStyle default fontArray.	1 to: fontArray size do:		[:i | font := fontArray at: i.		1 to: defFonts size do:			[:j | (font name asUppercase copyWithout: $ )			= ((defFonts at: j) name asUppercase copyWithout: $ )			ifTrue: [fontArray at: i put: (defFonts at: j)]]]! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/16/1998 23:46'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x := aPoint x asFloat - (self a13).	y := aPoint y asFloat - (self a23).	a11 := self a11.	a12 := self a12.	a21 := self a21.	a22 := self a22.	det := (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det := 1.0 / det.	detX := (x * a22) - (a12 * y).	detY := (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!XBMReadWriter methodsFor: 'accessing' stamp: 'nk 7/16/2003 18:18'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know about all possible image file types."	| first |	stream ascii.	self skipCComments.	first := (stream next: 7) asString.	stream binary.	^ (first = '#define')! !!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28'!as8BitColorForm	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."	| f map |	f := ColorForm extent: self extent depth: 8.	self displayOn: f at: self offset negated.	map := Color indexedColors copy.	map at: 1 put: Color transparent.	f colors: map.	f offset: self offset.	^ f! !!CursorWithMask methodsFor: 'mask' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm := aForm! !!Form class methodsFor: 'examples' stamp: ''!exampleMagnify	| f m |	f := Form fromUser.	m := f magnify: f boundingBox by: 5 @ 5.	m displayOn: Display at: Sensor waitButton	"Form exampleMagnify."! !!PNGReadWriter methodsFor: 'filtering' stamp: 'DSM 3/25/2000 17:54'!filterHorizontal: count	"Use the pixel to the left as a predictor"	| delta |	delta := bitsPerPixel // 8 max: 1.	delta+1 to: count do: [ :i |		thisScanline at: i put: (((thisScanline at: i) +(thisScanline at: i-delta)) bitAnd: 255) ]! !!WarpBlt methodsFor: 'primitives' stamp: ''!sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX := sourceY := 0.	self destRect: aRectangle.	fixedPt1 := (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	p1x := (pts at: 1) x * fixedPt1.	p2x := (pts at: 2) x * fixedPt1.	p3x := (pts at: 3) x * fixedPt1.	p4x := (pts at: 4) x * fixedPt1.	p1y := (pts at: 1) y * fixedPt1.	p2y := (pts at: 2) y * fixedPt1.	p3y := (pts at: 3) y * fixedPt1.	p4y := (pts at: 4) y * fixedPt1.	p1z := p2z := p3z := p4z := 16384.  "z-warp ignored for now"! !!FontSet class methodsFor: 'converting' stamp: 'sma 12/29/1999 12:27'!convertTextStyleNamed: aString	| style fontSet |	(style := TextStyle named: aString) ifNil: [^ self error: 'unknown text style ' , aString].	fontSet := self fontSetClass: aString.	style fontArray do: [:each | fontSet compileFont: each]! !!Color class methodsFor: 'class initialization' stamp: ''!initializeGrayToIndexMap	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."	"Color initializeGrayToIndexMap"	| grayLevels grayIndices c distToClosest dist indexOfClosest |	"record the level and index of each gray in the 8-bit color table"	grayLevels := OrderedCollection new.	grayIndices := OrderedCollection new.	"Note: skip the first entry, which is reserved for transparent"	2 to: IndexedColors size do: [:i |		c := IndexedColors at: i.		c saturation = 0.0 ifTrue: [  "c is a gray"			grayLevels add: (c privateBlue) >> 2.  "top 8 bits; R, G, and B are the same"			grayIndices add: i - 1]].  "pixel values are zero-based"	grayLevels := grayLevels asArray.	grayIndices := grayIndices asArray.	"for each gray level in [0..255], select the closest match"	GrayToIndexMap := ByteArray new: 256.	0 to: 255 do: [:level |		distToClosest := 10000.  "greater than distance to any real gray"		1 to: grayLevels size do: [:i |			dist := (level - (grayLevels at: i)) abs.			dist < distToClosest ifTrue: [				distToClosest := dist.				indexOfClosest := grayIndices at: i]].		GrayToIndexMap at: (level + 1) put: indexOfClosest].! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'yo 3/14/2005 06:48'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt := BitBlt asGrafPort toForm: aParagraph destinationForm.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt combinationRule:		((Display depth = 1)			ifTrue:				[aParagraph rule]			ifFalse:				[Form paint]).	bitBlt colorMap:		(Bitmap with: 0      "Assumes 1-bit deep fonts"				with: (bitBlt destForm pixelValueFor: aParagraph foregroundColor)).	bitBlt clipRect: clippingRectangle! !!Point methodsFor: 'point functions' stamp: 'ar 5/23/2001 21:29'!squaredDistanceTo: aPoint	"Answer the distance between aPoint and the receiver."	| delta |	delta := aPoint - self.	^delta dotProduct: delta! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 8/5/2003 13:11'!newForJapaneseFromEFontBDFFile: fileName name: aString overrideWith: otherFileName	| n |	n := self new.	n readEFontBDFForJapaneseFromFile: fileName name: aString overrideWith: otherFileName.	^ n.! !!WarpBlt class methodsFor: 'examples' stamp: ''!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box := 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp := (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 := box center.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!StrikeFont methodsFor: 'accessing' stamp: ''!name: aString	"Set the receiver's name."	name := aString! !!TextStyle methodsFor: 'tabs and margins' stamp: ''!nextTabXFrom: anX leftMargin: leftMargin rightMargin: rightMargin 	"Tab stops are distances from the left margin. Set the distance into the 	argument, anX, normalized for the paragraph's left margin."	| normalizedX tabX |	normalizedX := anX - leftMargin.	1 to: tabsArray size do: 		[:i | (tabX := tabsArray at: i) > normalizedX 				ifTrue: [^leftMargin + tabX min: rightMargin]].	^rightMargin! !!TextStyle class methodsFor: 'constants' stamp: 'nk 7/3/2003 19:11'!named: familyName	"Answer the TextStyle with the given name, or nil."	"TextStyle named: 'NewYork'"	| textStyle |	textStyle := TextConstants at: familyName ifAbsent: [ ^nil ].	(textStyle isKindOf: self) ifFalse: [ ^nil ].	^textStyle! !!StrikeFont methodsFor: 'character shapes' stamp: 'yo 12/1/2003 17:01'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii := character charCode.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii := maxAscii + 1].	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	leftX < 0 ifTrue: [^ glyphs copy: (0@0 corner: 0@self height)].	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!DisplayText methodsFor: 'display box access' stamp: ''!computeBoundingBox 	"Compute minimum enclosing rectangle around characters."	| character font width carriageReturn lineWidth lineHeight |	carriageReturn := Character cr.	width := lineWidth := 0.	font := textStyle defaultFont.	lineHeight := textStyle lineGrid.	1 to: text size do: 		[:i | 		character := text at: i.		character = carriageReturn		  ifTrue: 			[lineWidth := lineWidth max: width.			lineHeight := lineHeight + textStyle lineGrid.			width := 0]		  ifFalse: [width := width + (font widthOf: character)]].	lineWidth := lineWidth max: width.	^offset extent: lineWidth @ lineHeight! !!Form methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:44'!readAttributesFrom: aBinaryStream	| offsetX offsetY |	depth := aBinaryStream next.	(self depth isPowerOfTwo and: [self depth between: 1 and: 32])		ifFalse: [self error: 'invalid depth; bad Form file?'].	width := aBinaryStream nextWord.	height := aBinaryStream nextWord.	offsetX  := aBinaryStream nextWord.	offsetY := aBinaryStream nextWord.	offsetX > 32767 ifTrue: [offsetX := offsetX - 65536].	offsetY > 32767 ifTrue: [offsetY := offsetY - 65536].	offset := Point x: offsetX y: offsetY.	! !!FontSet class methodsFor: 'installing' stamp: 'sma 12/30/1999 15:05'!installAsTextStyle  "FontSetNewYork installAsTextStyle"	| selectors |	(TextConstants includesKey: self fontName) ifTrue:		[(self confirm: self fontName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	selectors := (self class selectors select: [:s | s beginsWith: 'size']) asSortedCollection.	TextConstants		at: self fontName		put: (TextStyle fontArray: (selectors collect: [:each | self perform: each]))! !!Form methodsFor: 'analyzing' stamp: ''!innerPixelRectFor: pv orNot: not	"Return a rectangle describing the smallest part of me that includes 	all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	| xTally yTally |	xTally := self xTallyPixelValue: pv orNot: not.	yTally := self yTallyPixelValue: pv orNot: not.	^ ((xTally findFirst: [:t | t>0]) - 1) @ ((yTally findFirst: [:t | t>0]) - 1)		corner:			(xTally findLast: [:t | t>0])@(yTally findLast: [:t | t>0])! !!Form methodsFor: 'scaling, rotation' stamp: 'wiz 1/22/2006 01:15'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot scale |	direction == #none ifTrue: [^ self].	scale :=  (direction = #pi ifTrue: [width@height] ifFalse: [height@width]) / self extent .	newForm := self blankCopyOf: self boundingBox scaledBy: scale.	quad := self boundingBox innerCorners.	rot := #(right pi left) indexOf: direction.	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededFor: newForm);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/2/1998 23:09'!transformPoint: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x := (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y := (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!BitBlt methodsFor: 'private' stamp: 'hg 6/27/2000 12:27'!cachedFontColormapFrom: sourceDepth to: destDepth	| srcIndex map |	CachedFontColorMaps class == Array 		ifFalse: [CachedFontColorMaps := (1 to: 9) collect: [:i | Array new: 32]].	srcIndex := sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex := 9].	(map := (CachedFontColorMaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map := (Color cachedColormapFrom: sourceDepth to: destDepth) copy.	(CachedFontColorMaps at: srcIndex) at: destDepth put: map.	^ map! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 1/5/2002 18:03'!allAreasOutsideList: aCollection startingAt: startIndex do: aBlock	"Enumerate aBlock with all areas of the receiver not overlapping 	any rectangle in the given collection"	| yOrigin yCorner aRectangle index rr |	index := startIndex.	"Find the next intersecting rectangle from aCollection"	[index <= aCollection size ifFalse:[^aBlock value: self].	aRectangle := aCollection at: index.	origin <= aRectangle corner and: [aRectangle origin <= corner]] 		whileFalse:[index := index + 1].	"aRectangle is intersecting; process it"	aRectangle origin y > origin y 		ifTrue: [rr := origin corner: corner x @ (yOrigin := aRectangle origin y).				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yOrigin := origin y].	aRectangle corner y < corner y		ifTrue: [rr := origin x @ (yCorner := aRectangle corner y) corner: corner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock]		ifFalse: [yCorner := corner y].	aRectangle origin x > origin x 		ifTrue: [rr := origin x @ yOrigin corner: aRectangle origin x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].	aRectangle corner x < corner x 		ifTrue: [rr := aRectangle corner x @ yOrigin corner: corner x @ yCorner.				rr allAreasOutsideList: aCollection startingAt: index+1 do: aBlock].! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/7/2001 01:00'!decodeMCU	| comp ci |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	1 to: mcuMembership size do:[:i|		ci := mcuMembership at: i.		comp := currentComponents at: ci.		self			primDecodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)			stream: stream.	].	restartsToGo := restartsToGo - 1.! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel := anInteger! !!StrikeFont methodsFor: 'accessing' stamp: 'ar 5/23/2000 12:52'!characterToGlyphMap	^characterToGlyphMap ifNil:[characterToGlyphMap := self createCharacterToGlyphMap].! !!DisplayScreen methodsFor: 'private' stamp: 'di 3/3/1999 10:00'!copyFrom: aForm	"Take on all state of aForm, with complete sharing"	super copyFrom: aForm.	clippingBox := super boundingBox! !!BitBlt methodsFor: 'accessing' stamp: 'ar 10/4/2000 16:37'!clipRect: aRectangle 	"Set the receiver's clipping area rectangle to be the argument, aRectangle."	clipX := aRectangle left truncated.	clipY := aRectangle top truncated.	clipWidth := aRectangle right truncated - clipX.	clipHeight := aRectangle bottom truncated - clipY.! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:50'!buildfontNamed: nm fromForms: forms startingAtAscii: startAscii	ascent: a descent: d maxWid: m	"This builds a StrikeFont instance from existing forms."	| lastAscii width ascii charForm missingForm tempGlyphs |	name := nm.	ascent := 11.	descent := 3.	maxWidth := 16.	pointSize := 8.	name := (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii := 258.	maxAscii := 0.	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	type := 0.  "ignored for now"	tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	1 to: forms size do:		[:i | charForm := forms at: i. width := charForm width.		ascii := startAscii-1+i.		self displayChar: ascii form: charForm.		ascii = 256			ifTrue: [missingForm := charForm deepCopy]			ifFalse:			[minAscii := minAscii min: ascii.			maxAscii := maxAscii max: ascii.			lastAscii+1 to: ascii-1 do: [:as | xTable at: as+2 put: (xTable at: as+1)].			tempGlyphs copy: ((xTable at: ascii+1)@0									extent: charForm extent)						from: 0@0 in: charForm rule: Form over.			xTable at: ascii+2 put: (xTable at: ascii+1) + width.			lastAscii := ascii]].	lastAscii+1 to: maxAscii+1 do: [:as | xTable at: as+2 put: (xTable at: as+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'nk 3/15/2004 19:46'!writeStyle: aTextStyle named: familyName toChangeSet: csName	"Write the text style to a change set, with a postscript that will re-load it.	NOTE: to do TTCFonts, you have to have a working ShortPointArray endianness conversion."	"	TTCFont recreateCache.	TextStyle writeStyle: (TextStyle named: #Arial) named: 'Arial' toChangeSet: 'ArialInstall'.		TextStyle writeStyle: (TextStyle named: #Accuny) named: 'Accuny' toChangeSet: 'AccunyInstall2'.	"	| cs mimeStream |	cs := ChangeSet basicNewNamed: csName.	cs adoptSelector: #collectionFromCompressedMIMEString: forClass: self class.	cs adoptSelector: #replaceStyle:with: forClass: self class.	cs adoptSelector: #replaceFontsIn:with: forClass: self class.	cs adoptSelector: #looseFontsFromFamily: forClass: self class.	((aTextStyle fontArray copyWithout: nil) collect: [ :f | f class ]) asSet do: [ :cls  | 		cs adoptSelector: #derivativeFonts forClass: cls.		cs adoptSelector: #releaseCachedState forClass: cls ].	cs preambleString: (String streamContents: [ :s |		s nextPutAll: '"Change Set:		'; nextPutAll: csName; cr;		nextPutAll: 'Date:		'; print: Date today; cr;		nextPutAll: 'Author:		'; nextPutAll: Utilities authorName; cr; cr;		nextPutAll: 'Installs the text style '''; nextPutAll: familyName; nextPutAll: ''''; cr;		nextPutAll: 'from a compressed MIME encoding in the postscript."'; cr. ]).	mimeStream := aTextStyle compressedMIMEEncodedStream.	cs postscriptString: (String streamContents: [ :s | s		nextPutAll: '"Postscript:'; cr;		nextPutAll: 'Install the text style from the compressed MIME encoding, and replace the old one.';		nextPut: $"; cr;		nextPutAll: 'TextConstants at: #';		nextPutAll: familyName;		nextPutAll: ' ifPresent: [ :oldStyle | TextConstants at: #';		nextPutAll: familyName;		nextPutAll: 'OLD put: oldStyle. TextConstants removeKey: #';		nextPutAll: familyName;		nextPutAll: ' ].';		cr;		nextPutAll: 'TextStyle collectionFromCompressedMIMEString: ';		cr;		print: mimeStream contents;		nextPut: $.; cr; cr;		nextPutAll: 'TextConstants at: #';		nextPutAll: familyName;		nextPutAll: 'OLD ifPresent: [ :oldStyle | TextStyle replaceStyle: oldStyle with: (TextStyle named: ''';		nextPutAll: familyName;		nextPutAll: ''') ].';		cr;		nextPutAll: 'TextStyle replaceFontsIn: (TextStyle looseFontsFromFamily: ''';		nextPutAll: familyName;		nextPutAll: ''') with: (TextStyle named: ''';		nextPutAll: familyName;		nextPutAll: ''').';				cr ]).	cs fileOut.! !!DisplayScreen methodsFor: 'private' stamp: 'bf 5/16/2006 11:35'!setExtent: aPoint depth: bitsPerPixel  "DisplayScreen startUp"	"This method is critical.  If the setExtent fails, there will be no	proper display on which to show the error condition..."	"ar 5/1/1999: ... and that is exactly why we check for the available display depths first."	"RAA 27 Nov 99 - if depth and extent are the same and acceptable, why go through this.	also - record when we change so worlds can tell if it is time to repaint"	(depth == bitsPerPixel and: [aPoint = self extent and: 					[self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [		bits := nil.  "Free up old bitmap in case space is low"		DisplayChangeSignature := (DisplayChangeSignature ifNil: [0]) + 1.		(self supportsDisplayDepth: bitsPerPixel)			ifTrue:[super setExtent: aPoint depth: bitsPerPixel]			ifFalse:[(self supportsDisplayDepth: bitsPerPixel negated)				ifTrue:[super setExtent: aPoint depth: bitsPerPixel negated]				ifFalse:["Search for a suitable depth"					super setExtent: aPoint depth: self findAnyDisplayDepth]].	].	clippingBox := super boundingBox! !!TextStyle methodsFor: 'accessing' stamp: ''!leftFlush	alignment := 0! !!CharacterScanner methodsFor: 'initialize' stamp: 'ar 12/31/2001 00:52'!initializeStringMeasurer	stopConditions := Array new: 258.	stopConditions at: CrossedX put: #crossedX.	stopConditions at: EndOfRun put: #endOfRun.! !!Bitmap methodsFor: 'accessing' stamp: 'ar 9/21/2001 23:06'!byteAt: byteAddress put: byte	"Insert a byte into a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:put:.  See Form pixelAt:put:  7/1/96 tk"	| longWord shift lowBits longAddr |	(byte < 0 or:[byte > 255]) ifTrue:[^self errorImproperStore].	lowBits := byteAddress - 1 bitAnd: 3.	longWord := self at: (longAddr := (byteAddress - 1 - lowBits) // 4 + 1).	shift := (3 - lowBits) * 8.	longWord := longWord - (longWord bitAnd: (16rFF bitShift: shift)) 		+ (byte bitShift: shift).	self at: longAddr put: longWord.	^ byte! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:23'!fontIndexOfSize: desiredHeight	"Returns an index in fontArray of the font with height <= desiredHeight"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch := 9999.  bestIndex := 1.	1 to: fontArray size do:		[:i | d := desiredHeight - (fontArray at: i) height.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex := i. bestMatch := d]].	^ bestIndex! !!BitBlt methodsFor: 'accessing' stamp: ''!clipX: anInteger 	"Set the receiver's clipping area top left x coordinate to be the argument, 	anInteger."	clipX := anInteger! !!HostFont methodsFor: 'accessing' stamp: 'ar 2/18/2001 20:04'!testEmbeddingFlags	"HostFont basicNew testEmbeddingFlags"	| list fontHandle |	list := self class listFontNames.	list do:[:fName|		fontHandle := self primitiveCreateFont: fName size: 12 emphasis: 0.		fontHandle ifNotNil:[			type := self primitiveFontEmbeddingFlags: fontHandle.			Transcript cr; show: fName,': ', type printString.			self primitiveDestroyFont: fontHandle.		].	].! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:46'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table := WordArray new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart := 2. "See above"	tableSize := 1 bitShift: minBits.	tableEnd := tableStart + tableSize.	"Store the terminal symbols"	valueIndex := (counts at: minBits+1).	tableIndex := 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex := tableIndex + 1].	"Fill up remaining entries with invalid entries"	tableStack := OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex := valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues := counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable := tableStack last.			lastTableStart := lastTable at: 2.			lastTableIndex := lastTable at: 3.			deltaBits := bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize := 1 bitShift: deltaBits.			tableStart := tableEnd.			tableEnd := tableEnd + tableSize.			[tableEnd > table size ]				whileTrue:[table := self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: lastTableIndex+1.			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries := numValues min: tableSize.			tableIndex := 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex := valueIndex + 1.				numValues := numValues - 1.				tableIndex := tableIndex+1].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!Form methodsFor: 'converting' stamp: 'di 10/16/2001 19:23'!copyWithColorsReducedTo: nColors	"Note: this has not been engineered.	There are better solutions in the literature."	| palette colorMap pc closest |	palette := self reducedPaletteOfSize: nColors.	colorMap := (1 to: (1 bitShift: depth)) collect:		[:i | pc := Color colorFromPixelValue: i-1 depth: depth.		closest := palette detectMin: [:c | c diff: pc].		closest pixelValueForDepth: depth].	^ self deepCopy copyBits: self boundingBox from: self at: 0@0 colorMap: (colorMap as: Bitmap)		! !!Pen methodsFor: 'operations' stamp: 'sw 10/5/2002 02:25'!arrowHeadFrom: prevPt to: newPt arrowSpec: anArrowSpec	"Put an arrowhead on the pen stroke from oldPt to newPt"	| pm af myColor finalPt delta |	myColor := self color.	delta := newPt - prevPt.	delta r <= 2 "pixels" ifTrue: [^ self].	finalPt := newPt + (Point r: sourceForm width degrees: delta degrees).	"in same direction"	pm := PolygonMorph vertices: (Array with: prevPt asIntegerPoint with: finalPt asIntegerPoint)  		color: myColor  "not used"		borderWidth: sourceForm width borderColor: myColor.	pm makeOpen; makeForwardArrow.	anArrowSpec ifNotNil: [pm arrowSpec: anArrowSpec].	af := pm arrowForms first.	"render it onto the destForm"	(FormCanvas on: destForm "Display") stencil: af at: af offset + (1@1)		color: myColor! !!ColorForm methodsFor: 'color manipulation' stamp: 'tk 3/2/98 15:42'!replaceColorAt: aPoint with: newColor	"Replace a color map entry with newColor.  The entry replaced is the one used by aPoint.  If there are are two entries in the colorMap for the oldColor, just replace ONE!!!!  There are often two whites or two blacks, and this is what you want, when replacing one."	| oldIndex |	self ensureColorArrayExists.	oldIndex := self pixelValueAt: aPoint.	colors at: oldIndex+1 put: newColor.	self clearColormapCache.! !!Form methodsFor: 'private' stamp: 'ar 12/19/2000 16:23'!privateFloodFillValue: aColor	"Private. Compute the pixel value in the receiver's depth but take into account implicit color conversions by BitBlt."	| f1 f2 bb |	f1 := Form extent: 1@1 depth: depth.	f2 := Form extent: 1@1 depth: 32.	bb := BitBlt toForm: f1.	bb fillColor: aColor; 		destRect: (0@0 corner: 1@1); 		combinationRule: 3; 		copyBits.	bb := BitBlt toForm: f2.	bb sourceForm: f1; 		sourceOrigin: 0@0;		destRect: (0@0 corner: 1@1);		combinationRule: 3;		copyBits.	^f2 pixelValueAt: 0@0.! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:22'!createAFormFrom: data	| error f |	error := ''.	f := [		self formFromStream: (RWBinaryOrTextStream with: data)	] ifError: [ :a :b |		error := a printString,'  ',b printString.		(StringMorph contents: error) color: Color red; imageForm	].	^{f. error}! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize := 10.	bb := otherImage boundingBox.	resultForm := self copy: (topLeft extent: bb extent).	maskForm := Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc := starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta := 1@0.					maskLoc := bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta := -1@0.					maskLoc := bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta := 0@1.					maskLoc := bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta := 0@-1.					maskLoc := bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm := (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel := #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect := (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect := 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect := smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc := maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!TextStyle class methodsFor: 'user interface' stamp: 'dgd 10/8/2003 18:38'!fontSizeSummary	"Open a text window with a simple summary of the available sizes in each of the fonts in the system."	"TextStyle fontSizeSummary"	| aString aList |	aList := self knownTextStyles.	aString := String streamContents:		[:aStream |			aList do: [:aStyleName |				aStream nextPutAll:					aStyleName, '  ',					(self fontPointSizesFor: aStyleName) asArray storeString.				aStream cr]].	(StringHolder new contents: aString)		openLabel: 'Font styles and sizes' translated! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 2/2/2001 15:47'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'primitiveComposeMatrix' module: 'Matrix2x3Plugin'>	matrix := aTransformation asMatrixTransform2x3.	a11 := self a11.		b11 := matrix a11.	a12 := self a12.		b12 := matrix a12.	a13 := self a13.		b13 := matrix a13.	a21 := self a21.		b21 := matrix a21.	a22 := self a22.		b22 := matrix a22.	a23 := self a23.		b23 := matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!BitBlt methodsFor: 'accessing' stamp: ''!clipHeight: anInteger 	"Set the receiver's clipping area height to be the argument, anInteger."	clipHeight := anInteger! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/18/1998 14:03'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 := self invertPoint: 0@0.	r1 := (self invertPoint: 1@0) - r3.	r2 := (self invertPoint: 0@1) - r3.	m := self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!MorphicTransform methodsFor: 'private' stamp: ''!setAngle: aFloat	angle := aFloat.! !!Point methodsFor: 'geometry' stamp: 'laza 1/6/2000 10:30'!sideOf: otherPoint 	"Returns #left, #right or #center if the otherPoint lies to the left, right 	or on the line given by the vector from 0@0 to self"	| side |	side := (self crossProduct: otherPoint) sign.	^ {#right. #center. #left} at: side + 2! !!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:40'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	self depth < 16		ifTrue: [map := (Color cachedColormapFrom: self depth to: self depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map := Color computeRGBColormapFor: self depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt current toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!TextStyle class methodsFor: 'user interface' stamp: 'nk 9/1/2004 13:18'!emphasisMenuForFont: font target: target selector: selector highlight: currentEmphasis	"Offer a font emphasis menu for the given style. If one is selected, pass that font to target with a call to selector. The fonts will be displayed in that font.	Answer nil if no derivatives exist.	" 	| aMenu derivs |	derivs := font derivativeFonts.	derivs isEmpty ifTrue: [ ^nil ].	aMenu := MenuMorph entitled: 'emphasis' translated.	derivs := derivs asOrderedCollection.	derivs addFirst: font.	derivs do: [ :df | 			aMenu 				add: (AbstractFont emphasisStringFor: df emphasis)				target: target 				selector: selector				argument: df.                aMenu lastItem font: df.                df emphasis == currentEmphasis ifTrue: [aMenu lastItem color: Color blue darker]].        ^ aMenu! !!Color methodsFor: 'conversions' stamp: ''!closestPixelValue4	"Return the nearest approximation to this color for a 4-bit deep Form."	| bIndex |	"fast special cases"	rgb = 0 ifTrue: [^ 1].  "black"	rgb = 16r3FFFFFFF ifTrue: [^ 2].  "opaque white"	rgb = PureRed privateRGB ifTrue: [^ 4].	rgb = PureGreen privateRGB ifTrue: [^ 5].	rgb = PureBlue privateRGB ifTrue: [^ 6].	rgb = PureCyan privateRGB ifTrue: [^ 7].	rgb = PureYellow privateRGB ifTrue: [^ 8].	rgb = PureMagenta privateRGB ifTrue: [^ 9].	bIndex := (self luminance * 8.0) rounded.  "bIndex in [0..8]"	^ #(		1	"black"		10	"1/8 gray"		11	"2/8 gray"		12	"3/8 gray"		3	"4/8 gray"		13	"5/8 gray"		14	"6/8 gray"		15	"7/8 gray"		2	"opaque white"	) at: bIndex + 1.! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt current toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r := Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies := (Display copy: r) tallyPixelValues.	nonZero := (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'jm 10/22/97 07:43'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs	"Slide this object across the display over the given number of steps, pausing for the given number of milliseconds after each step."	"Note: Does not display at the first point, but does at the last."	| i p delta |	i := 0.	p := startPoint.	delta := (stopPoint - startPoint) / nSteps asFloat.	^ self		follow: [(p := p + delta) truncated]		while: [			(Delay forMilliseconds: milliSecs) wait.			(i := i + 1) < nSteps]! !!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'BG 5/31/2003 16:08'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	paragraph := aParagraph.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			line := aParagraph lines at: lineIndex.			lastIndex := line first.               self setStopConditions. " causes an assignment to inst var.  alignment "			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			destY := lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			done := false.			string := text string.			self handleIndentation.			[done] whileFalse:[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				done := self perform: stopCondition].			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  , di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize abs < self depth ifFalse:		["Make sure there is enough space"		area := Display boundingBox area. "pixels"		Smalltalk isMorphic ifFalse:			[ScheduledControllers scheduledWindowControllers do:				[:aController | "This should be refined..."				aController view cacheBitsAsTwoTone ifFalse:					[area := area + aController view windowBox area]]].		need := (area * (pixelSize abs - self depth) // 8)  "new bytes needed"				+ Smalltalk lowSpaceThreshold.		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self error: 'Insufficient free space']].	self setExtent: self extent depth: pixelSize.	Smalltalk isMorphic ifFalse: [ScheduledControllers updateGray].	DisplayScreen startUp! !!Color class methodsFor: 'examples' stamp: ''!colorRampForDepth: depth extent: aPoint	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."	"(Color colorRampForDepth: Display depth extent: 256@80) display"	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"	| f dx dy r |	f := Form extent: aPoint depth: depth.	dx := aPoint x // 256.	dy := aPoint y // 4.	0 to: 255 do: [:i |		r := (dx * i)@0 extent: dx@dy.		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).		r := r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).		r := r translateBy: 0@dy.		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).		r := r translateBy: 0@dy.		f fill: r fillColor: (Color r: i g: i b: i range: 255)].	^ f! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:03'!roundNib: diameter	"Makes this pen draw with a round dot of the given diameter."	self sourceForm: (Form dotOfSize: diameter).	combinationRule := Form paint.! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 8/28/2002 16:37'!readCharacter: aBits from: aStream	| pos |	pos := 0.	12 timesRepeat: [		1 to: 2 do: [ :w |			aBits byteAt: (pos+w) put: (aStream next ). 		].		pos := pos + 4.	].! !!Bitmap class methodsFor: 'instance creation' stamp: 'di 2/12/98 14:34'!decompressFromByteArray: byteArray	| s bitmap size |	s := ReadStream on: byteArray.	size := self decodeIntFrom: s.	bitmap := self new: size.	bitmap decompress: bitmap fromByteArray: byteArray at: s position+1.	^ bitmap! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 20:07'!unhibernate	colors ifNotNil:[colors := colors asArray].	^super unhibernate.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 12/27/2002 16:57'!newFromEFontBDFFile: aFileName name: aString startRange: start endRange: end	| n |	n := self new.	n readEFontBDFFromFile: aFileName name: aString rangeFrom: start to: end.	^n.	"TextConstants at: #Helvetica put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'helvR12.bdf' name: 'Helvetica12'})"	"TextConstants at: #Lucida put: (TextStyle fontArray: {StrikeFont newFromBDFFile: 'luRS12.bdf' name: 'Lucida'})"	"TextStyle default fontAt: 5 put: (StrikeFont new readFromStrike2: 'helv12.sf2')."! !!StrikeFont methodsFor: 'accessing' stamp: ''!setGlyphs: newGlyphs	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."	glyphs := newGlyphs! !!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:32'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm := df.	sourceForm := sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule := cr.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourceOrigin x.	sourceY := sourceOrigin y.	width := extent x.	height := extent y.	aPoint := clipRect origin.	clipX := aPoint x.	clipY := aPoint y.	aPoint := clipRect corner.	clipWidth := aPoint x - clipX.	clipHeight := aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap := sourceForm colormapIfNeededFor: destForm]! !!DisplayScreen methodsFor: 'other' stamp: ''!replacedBy: aForm do: aBlock	"Permits normal display to draw on aForm instead of the display."	ScreenSave := self.	Display := aForm.	aBlock value.	Display := self.	ScreenSave := nil.! !!Pen methodsFor: 'operations' stamp: 'jm 4/28/1998 03:40'!color: aColorOrInteger	"Set the pen to the given color or to a color chosen from a fixed set of colors."	| count c |	aColorOrInteger isInteger		ifTrue: [			destForm depth = 1 ifTrue: [^ self fillColor: Color black].			count := 19.  "number of colors in color wheel"			c := (Color red wheel: count) at: ((aColorOrInteger * 7) \\ count) + 1]		ifFalse: [c := aColorOrInteger].  "assume aColorOrInteger is a Color"	self fillColor: c.! !!Cursor class methodsFor: 'class initialization' stamp: ''!initRightArrow 	RightArrowCursor  :=		      (Cursor	extent: 16@16	fromArray: #(		2r100000000000		2r111000000000		2r1111111110000000		2r111000000000		2r100000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).		"Cursor initRightArrow"! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 6/8/2000 20:36'!mappingTo: aColorMap	"Compute a new color map through the receiver and aColorMap.	Both maps are assumed to be mappings into canonical ARGB space"	| fixedMap |	self = aColorMap ifTrue:[^nil]. "No mapping needed"	aColorMap isIndexed ifTrue:[^nil]. "We can't compute mappings to an indexed map yet"	fixedMap := self class mappingFrom: self rgbaBitMasks to: aColorMap rgbaBitMasks.	self isIndexed ifFalse:[^fixedMap].	"If the receiver is indexed then we need to map the colors as well"	self flag: #untested.	^ColorMap		shifts: fixedMap shifts		masks: fixedMap masks		colors: (colors collect:[:pv| aColorMap pixelMap: pv]).! !!Form methodsFor: 'accessing' stamp: ''!bits: aBitmap 	"Reset the Bitmap containing the receiver's bits."	bits := aBitmap! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 15:44'!readHeader	"read header for pbm, pgm or ppm"	| tokens aux d c  |	tokens := OrderedCollection new.	aux := self getTokenPbm: tokens.	cols := aux at: 1. tokens := aux at: 2.	aux := self getTokenPbm: tokens.	rows := aux at: 1. tokens := aux at: 2.	(type = 1 or:[type = 4]) ifTrue:[		maxValue := 1	]	ifFalse: [		aux := self getTokenPbm: tokens.		maxValue := aux at: 1. tokens := aux at: 2.	].	d := {1 . 2 . 4 . 	8 . 		16 . 32}.	c := {2 . 4 . 16 . 256 . 32768 . 16777216}. 	(type = 3 or:[type = 6]) ifTrue: [		maxValue >= 65536 ifTrue:[			self error:'Pixmap > 48 bits not supported in PPM'		].		maxValue >= 256 ifTrue:[			self error:'Pixmap > 32 bits are not supported in Squeak'		].		maxValue < 32 ifTrue:[depth := 16] ifFalse:[depth := 32].	]	ifFalse: [		depth := nil.		1 to: c size do:[:i| ((c at: i) > maxValue and:[depth = nil]) ifTrue:[depth:=d at: i]].	].	Transcript cr; show: 'PBM file class ', type asString, ' size ', cols asString, ' x ', 		rows asString, ' maxValue =', maxValue asString, ' depth=', depth asString.! !!Point methodsFor: 'point functions' stamp: 'ar 5/22/2001 23:46'!insideTriangle: p1 with: p2 with: p3	"Return true if the receiver is within the triangle defined by the three coordinates.	Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."	| p0 b0 b1 b2 b3 |	p0 := self.	b0 := ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).	b0 isZero ifTrue:[^false]. "degenerate"	b0 := 1.0 / b0.	b1 := (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.	b2 := (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.	b3 := (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.	b1 < 0.0 ifTrue:[^false].	b2 < 0.0 ifTrue:[^false].	b3 < 0.0 ifTrue:[^false].	^true! !!Color methodsFor: 'conversions' stamp: 'di 3/25/2000 10:13'!balancedPatternForDepth: depth	"A generalization of bitPatternForDepth: as it exists.  Generates a 2x2 stipple of color.	The topLeft and bottomRight pixel are closest approx to this color"	| pv1 pv2 mask1 mask2 pv3 c |	(depth == cachedDepth and:[cachedBitPattern size = 2]) ifTrue: [^ cachedBitPattern].	(depth between: 4 and: 16) ifFalse: [^ self bitPatternForDepth: depth].	cachedDepth := depth.	pv1 := self pixelValueForDepth: depth."	Subtract error due to pv1 to get pv2.	pv2 := (self - (err1 := (Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	Subtract error due to 2 pv1's and pv2 to get pv3.	pv3 := (self - err1 - err1 - ((Color colorFromPixelValue: pv2 depth: depth) - self))						pixelValueForDepth: depth."	"Above two statements computed faster by the following..."	pv2 := (c := self - ((Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	pv3 := (c + (c - (Color colorFromPixelValue: pv2 depth: depth)))						pixelValueForDepth: depth.	"Return to a 2-word bitmap that encodes a 2x2 stipple of the given pixelValues."	mask1 := (#(- - -				16r01010101 - - -			"replicates every other 4 bits"			16r00010001 - - - - - - -	"replicates every other 8 bits"			16r00000001) at: depth).	"replicates every other 16 bits"	mask2 := (#(- - -				16r10101010 - - -			"replicates the other 4 bits"			16r01000100 - - - - - - -	"replicates the other 8 bits"			16r00010000) at: depth).	"replicates the other 16 bits"	^ cachedBitPattern := Bitmap with: (mask1*pv1) + (mask2*pv2) with: (mask1*pv3) + (mask2*pv1)! !!BitBlt methodsFor: 'private' stamp: 'yo 3/15/2005 09:47'!roundVariables	| maxVal minVal |	maxVal := SmallInteger maxVal.	minVal := SmallInteger minVal.	destX := destX asInteger min: maxVal max: minVal.	destY := destY asInteger min: maxVal max: minVal.	width := width asInteger min: maxVal max: minVal.	height := height asInteger min: maxVal max: minVal.	sourceX := sourceX asInteger min: maxVal max: minVal.	sourceY := sourceY asInteger min: maxVal max: minVal.	clipX := clipX asInteger min: maxVal max: minVal.	clipY := clipY asInteger min: maxVal max: minVal.	clipWidth := clipWidth asInteger min: maxVal max: minVal.	clipHeight := clipHeight asInteger min: maxVal max: minVal.! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 4/12/2005 19:53'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := (EncodedCharSet charsetAt: startEncoding) scanSelector.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!XBMReadWriter methodsFor: 'accessing' stamp: 'wdc 2/1/1999 07:15'!nextImage	"Read in the next xbm image from the stream."	| form long incount chunks byteWidth pad fourway outcount total |	stream reset.	stream ascii.	self readHeader.	form := ColorForm extent: width@height depth: 1.	incount := 0.	outcount :=1.	chunks := Array new: 4.	byteWidth := width + 7 // 8.	total := byteWidth * height.	byteWidth > 4		ifTrue: [ pad := byteWidth \\ 4]		ifFalse: [ pad := 4 - byteWidth ].	fourway := 0.	[(incount = total)] whileFalse: [		incount := incount + 1.		fourway := fourway + 1.		chunks at: fourway put: (Flipbits at: ((self parseByteValue) +1)).		(pad > 0 and: [(incount \\ byteWidth) = 0]) ifTrue: [			1 to: pad do:				[:q |	  			fourway := fourway + 1.				chunks at: fourway put: 0]		].		fourway = 4 ifTrue: [			long := Integer				byte1: (chunks at: 4)				byte2: (chunks at: 3)				byte3: (chunks at: 2)				byte4: (chunks at: 1).			(form bits) at: outcount put: long.			fourway := 0.			outcount := outcount + 1].		].	 ^ form ! !!HostFont class methodsFor: 'accessing' stamp: 'yo 2/14/2004 01:26'!textStyleFrom: fontName sizes: ptSizes ranges: ranges	| styleName fonts |	styleName := fontName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) displayProgressAt: Sensor cursorPoint		from: 1 to: ptSizes size during:[:bar|			fonts := ptSizes				collect:[:ptSize| bar value: (ptSizes indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0 rangesArray: ranges				]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!Form class methodsFor: 'file list services' stamp: 'nk 1/6/2004 12:36'!openImageInWindow: fullName	"Handle five file formats: GIF, JPG, PNG, Form storeOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream := (FileStream readOnlyFileNamed: fullName) binary.	image := self fromBinaryStream: myStream.	myStream close.	Smalltalk isMorphic ifTrue:[		Project current resourceManager 			addResource: image 			url: (FileDirectory urlForFileNamed: fullName) asString.	].	Smalltalk isMorphic		ifTrue: [(World drawingClass withForm: image) openInWorld]		ifFalse: [FormView open: image named: fullName]! !!Form methodsFor: 'displaying' stamp: 'ar 2/13/2001 22:12'!displayInterpolatedOn: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| engine := (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!WarpBlt class methodsFor: 'examples' stamp: 'sma 4/22/2000 20:23'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp := (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 := (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!values: anObject	values := anObject! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'ar 3/3/2001 23:07'!initialize	"JPEGReadWriter initialize"	"general constants"	DCTSize := 8.	MaxSample := (2 raisedToInteger: DCTSize) - 1.	SampleOffset := MaxSample // 2.	FloatSampleOffset := SampleOffset asFloat.	DCTSize2 := DCTSize squared.	QuantizationTableSize := 4.	HuffmanTableSize := 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits := 13.	Pass1Bits := 2.	DCTK1 := 2 sqrt.	DCTK2 := 1.847759065.	DCTK3 := 1.082392200.	DCTK4 := -2.613125930.	Pass1Div := 1 bitShift: ConstBits - Pass1Bits.	Pass2Div := 1 bitShift: ConstBits + Pass1Bits + 3.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 := 2446.	FIXn0n390180644 := 3196.	FIXn0n541196100 := 4433.	FIXn0n765366865 := 6270.	FIXn0n899976223 := 7373.	FIXn1n175875602 := 9633.	FIXn1n501321110 := 12299.	FIXn1n847759065 := 15137.	FIXn1n961570560 := 16069.	FIXn2n053119869 := 16819.	FIXn2n562915447 := 20995.	FIXn3n072711026 := 25172.	"fixed-point color conversion constants"	FIXn0n34414 := 22554.	FIXn0n71414 := 46802.	FIXn1n40200 := 91881.	FIXn1n77200 :=  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder := #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor := (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dithering masks"	(DitherMasks := Dictionary new)		add: 0 -> 0;		add: 1 -> 127;		add: 2 -> 63;		add: 4 -> 63;		add: 8 -> 31;		add: 16 -> 7;		add: 32 -> 0.	"dictionary of marker parsers"	(JFIFMarkerParser := Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!Cursor class methodsFor: 'class initialization' stamp: ''!initUp	UpCursor := 		    (Cursor	extent: 16@16	fromArray: #(		2r11000000000000		2r111100000000000		2r1111110000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!TextLineInterval methodsFor: 'scanning' stamp: ''!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad := paddingWidth // internalSpaces.	extraPad := paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!Color class methodsFor: 'class initialization' stamp: ''!initialize	"Color initialize"	"Details: Externally, the red, green, and blue components of color	are floats in the range [0.0..1.0]. Internally, they are represented	as integers in the range [0..ComponentMask] packing into a	small integer to save space and to allow fast hashing and	equality testing.	For a general description of color representations for computer	graphics, including the relationship between the RGB and HSV	color models used here, see Chapter 17 of Foley and van Dam,	Fundamentals of Interactive Computer Graphics, Addison-Wesley,	1982."	ComponentMask := 1023.	HalfComponentMask := 512.  "used to round up in integer calculations"	ComponentMax := 1023.0.  "a Float used to normalize components"	RedShift := 20.	GreenShift := 10.	BlueShift := 0.	PureRed		 := self r: 1 g: 0 b: 0.	PureGreen	 := self r: 0 g: 1 b: 0.	PureBlue	 := self r: 0 g: 0 b: 1.	PureYellow	 := self r: 1 g: 1 b: 0.	PureCyan	 := self r: 0 g: 1 b: 1.	PureMagenta := self r: 1 g: 0 b: 1.	RandomStream := Random new.	self initializeIndexedColors.	self initializeGrayToIndexMap.	self initializeNames.	self initializeHighLights.! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'nk 7/16/2003 17:59'!allTypicalFileExtensions	"Answer a collection of file extensions (lowercase) which files that my subclasses can read might commonly have"	"ImageReadWriter allTypicalFileExtensions"	| extensions |	extensions := Set new.	self allSubclassesDo: [ :cls | extensions addAll: cls typicalFileExtensions ].	^extensions! !!BitBlt methodsFor: 'copying' stamp: 'yo 3/15/2005 09:54'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 'primitiveCopyBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	"Check if BitBlt doesn't support full color maps"	(colorMap notNil and:[colorMap isColormap]) ifTrue:[		colorMap := colorMap colors.		^self copyBits].	"Check if clipping gots us way out of range"	self clipRange ifTrue:[self roundVariables. ^self copyBitsAgain].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	self roundVariables.	^ self copyBitsAgain! !!BitBlt class methodsFor: 'examples' stamp: 'di 12/1/97 12:09'!antiAliasDemo 	"To run this demo, use...		Display restoreAfter: [BitBlt antiAliasDemo]	Goes immediately into on-screen paint mode.  Option-Click to stop painting."	"This code exhibits alpha blending in any display depth by performing	the blend in an off-screen buffer with 32-bit pixels, and then copying	the result back onto the screen with an appropriate color map. - tk 3/10/97"		"This version uses a sliding buffer for painting that keeps pixels in 32 bits	as long as they are in the buffer, so as not to lose info by converting down	to display resolution and back up to 32 bits at each operation. - di 3/15/97"		"This version also uses WarpBlt to paint into twice as large a buffer,	and then use smoothing when reducing back down to the display.	In fact this same routine will now work for 3x3 soothing as well.	Remove the statements 'buff displayAt: 0@0' to hide the buffer. - di 3/19/97"	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect scale p0 |  	"compute color maps if needed"	Display depth <= 8 ifTrue: [		mapDto32 := Color cachedColormapFrom: Display depth to: 32.		map32toD := Color cachedColormapFrom: 32 to: Display depth].	"Create a brush with radially varying alpha"	brush := Form extent: 3@3 depth: 32.	brush fill: brush boundingBox fillColor: (Color red alpha: 0.05).	brush fill: (1@1 extent: 1@1) fillColor: (Color red alpha: 0.2).	scale := 2.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush := brush magnify: brush boundingBox by: scale.	"Now paint with the brush using alpha blending."	buffSize := 100.	buff := Form extent: (brush extent + buffSize) * scale depth: 32.  "Travelling 32-bit buffer"	dispToBuff := (WarpBlt toForm: buff)  "From Display to buff - magnify by 2"		sourceForm: Display;		colorMap: mapDto32;		combinationRule: Form over.	brushToBuff := (BitBlt toForm: buff)  "From brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	buffToDisplay := (WarpBlt toForm: Display)  "From buff to Display - shrink by 2"		sourceForm: buff;		colorMap: map32toD;		cellSize: scale;  "...and use smoothing"		combinationRule: Form over.	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"	[Sensor yellowButtonPressed] whileFalse:		[prevP := nil.		buffRect := Sensor cursorPoint - (buff extent // scale // 2) extent: buff extent // scale.		p0 := (buff extent // 2) - (buffRect extent // 2).		dispToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.buff displayAt: 0@0.  "** remove to hide sliding buffer **"		[Sensor redButtonPressed] whileTrue:			["Here is the painting loop"			p := Sensor cursorPoint - buffRect origin + p0.  "p, prevP are rel to buff origin"			(prevP == nil or: [prevP ~= p]) ifTrue:				[prevP == nil ifTrue: [prevP := p].				(p dist: prevP) > (buffSize-1) ifTrue:					["Stroke too long to fit in buffer -- clip to buffer,						and next time through will do more of it"					theta := (p-prevP) theta.					p := ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].				brushRect := p extent: brush extent.				((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:					["Brush is out of buffer region.  Scroll the buffer,						and fill vacated regions from the display"					delta := (brushRect amountToTranslateWithin: (buff boundingBox insetBy: scale)) // scale.					buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.					newBuffRect := buffRect translateBy: delta negated.					p := p translateBy: delta*scale.					prevP := prevP translateBy: delta*scale.					(newBuffRect areasOutside: buffRect) do:						[:r | dispToBuff copyQuad: r innerCorners toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].					buffRect := newBuffRect].				"Interpolate from prevP to p..."				brushToBuff drawFrom: prevP to: p withFirstPoint: false.buff displayAt: 0@0.  "** remove to hide sliding buffer **"				"Update (only) the altered pixels of the destination"				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.				updateRect := updateRect origin // scale * scale						corner: updateRect corner + scale // scale * scale.				buffToDisplay copyQuad: updateRect innerCorners							toRect: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale).				prevP := p]]]! !!BitBlt methodsFor: 'copying' stamp: ''!copy: destRectangle from: sourcePt in: srcForm halftoneForm: hf rule: rule 	| destOrigin |	sourceForm := srcForm.	self fillColor: hf.		"sets halftoneForm"	combinationRule := rule.	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	self copyBits! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 18:57'!initBottomLeft	BottomLeftCursor := 		(Cursor extent: 16@16			fromArray: #(		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1111111111111111		2r1111111111111111)			offset: 0@-16).! !!BitBlt methodsFor: 'line drawing' stamp: 'ar 2/2/2001 15:09'!drawLoopX: xDelta Y: yDelta 	"Primitive. Implements the Bresenham plotting algorithm (IBM Systems	Journal, Vol. 4 No. 1, 1965). It chooses a principal direction, and	maintains a potential, P. When P's sign changes, it is time to move in	the minor direction as well. This particular version does not write the	first and last points, so that these can be called for as needed in client code.	Optional. See Object documentation whatIsAPrimitive."	| dx dy px py P |	<primitive: 'primitiveDrawLoop' module: 'BitBltPlugin'>	dx := xDelta sign.	dy := yDelta sign.	px := yDelta abs.	py := xDelta abs.	"self copyBits."	py > px		ifTrue: 			["more horizontal"			P := py // 2.			1 to: py do: 				[:i |				destX := destX + dx.				(P := P - px) < 0 ifTrue: 						[destY := destY + dy.						P := P + py].				i < py ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			P := px // 2.			1 to: px do:				[:i |				destY := destY + dy.				(P := P - py) < 0 ifTrue: 						[destX := destX + dx.						P := P + px].				i < px ifTrue: [self copyBits]]]! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 5/24/2004 17:51'!makeCondensedGlyphs	"Make a condensed set of glyphs with same widths.	NOTE: this has been superceded by kerning -- should not get called"	| g newXTable x x1 w |	g := glyphs deepCopy.	newXTable := Array new: xTable size.	newXTable at: 1 put: (x := xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 := xTable at: i.  w := (xTable at: i+1) - x1.		w > 1 ifTrue: [w := w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x := x + w)].	xTable := newXTable.	glyphs := g.	fallbackFont ifNotNil: [		fallbackFont emphasized: 8	]."(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 1/19/2005 11:22'!newFromEFontBDFFile: fileName name: aString ranges: ranges	| n |	n := self new.	n readEFontBDFFromFile: fileName name: aString ranges: ranges.	^ n.! !!ImageReadWriter methodsFor: 'private' stamp: ''!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask := (1 bitShift: depth) - 1.	pixelInByte := 8 / depth.	bitsWidth := width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth := width * 8 + pad - 1 // pad * (pad / 8).	stopWidth := width * depth + 7 // 8.	trailingSize := width - (stopWidth - 1 * pixelInByte).	upBits := ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex := i - 1 * bitsWidth.		upBitIndex := i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val := bits at: (bitIndex := bitIndex + 1).			upBitIndex := upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val := val bitShift: depth negated]].		val := (bits at: (bitIndex := bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex := upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val := val bitShift: depth negated]].	^ upBits! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutRGB: aForm	| myType peeker f shift mask |	cols := aForm width.	rows := aForm height.	depth := aForm depth.	f := aForm.	depth < 16 ifTrue:[		f := aForm asFormOfDepth: 32.		depth := 32.	].	myType := $6.	"stream position: 0."	self writeHeader: myType.	depth = 32 ifTrue:[shift := 8. mask := 16rFF] ifFalse:[shift := 5. mask := 16r1F].	peeker := BitBlt current bitPeekerFromForm: f.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x | | p r g b |			p := peeker pixelAt: x@y.			b := p bitAnd: mask. p := p >> shift.			g := p bitAnd: mask. p := p >> shift.			r := p bitAnd: mask.			stream nextPut: r.			stream nextPut: g.			stream nextPut: b.		]	].! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:20'!getTokenPbm: aCollection	"get a number, return rest of collection"	| line tokens token |	tokens := aCollection.	tokens size = 0 ifTrue:[		[			line := self pbmGetLine.			line ifNil:[^{nil . nil}].			tokens := line findTokens: ' '.			tokens size = 0		] whileTrue:[].	].	"Transcript cr; show: tokens asString."	token := tokens removeFirst.	^{token asInteger . tokens}! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/16/2001 19:27'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	destX := destX + (w := anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex := lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!PNGReadWriter methodsFor: 'writing' stamp: 'BG 3/16/2005 08:26'!writeChunk: crcStream	| bytes length crc debug |	debug := self debugging.	bytes := crcStream originalContents.	length := crcStream position.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: length in: bytes.	crc := crc bitXor: 16rFFFFFFFF.	debug ifTrue: [ Transcript cr;		print: stream position; space;		nextPutAll: (bytes copyFrom: 1 to: 4) asString;		nextPutAll: ' len='; print: length;		nextPutAll: ' crc=0x'; nextPutAll: crc printStringHex  ].	stream nextNumber: 4 put: length-4. "exclude chunk name"	stream next: length putAll: bytes startingAt: 1.	stream nextNumber: 4 put: crc.	debug ifTrue: [ Transcript nextPutAll: ' afterPos='; print: stream position ].	crcStream resetToStart.! !!TextStyle class methodsFor: 'user interface' stamp: 'nk 9/1/2004 10:38'!modalMVCStyleSelectorWithTitle: title	"MVC Only!! Presents a modal font-style choice menu, answers a TextStyle or nil."	"TextStyle modalMVCStyleSelectorWithTitle: 'testing'"		| aMenu actualStyles |	aMenu := CustomMenu new.	actualStyles := self actualTextStyles.	actualStyles keysSortedSafely do: [ :styleName | | style |		style := actualStyles at: styleName.		aMenu add: styleName action: style	].	^aMenu startUpWithCaption: title.! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 21:06'!buildLookupTable: values counts: counts	| min max |	min := max := nil.	1 to: counts size do:[:i|		(counts at: i) = 0 ifFalse:[			min ifNil:[min := i-1].			max := i]].	^self		createHuffmanTables: values 		counts: {0},counts 		from: min+1 		to: max.! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!rotateBy: direction centerAt: c	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset := self - c.	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].	direction == #pi ifTrue: [^ c - offset].	self error: 'unrecognizable direction'! !!DisplayText methodsFor: 'accessing' stamp: ''!textStyle: aTextStyle 	"Set the style by which the receiver should display its text."	textStyle := aTextStyle.	form := nil.	self changed.	! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'DSM 3/26/2000 21:32'!copyPixels: y	"Handle non-interlaced pixels of supported colorTypes"	| s |	s := #(copyPixelsGray: nil copyPixelsRGB: copyPixelsIndexed:		  copyPixelsGrayAlpha: nil copyPixelsRGBA:) at: colorType+1.	self perform: s asSymbol with: y! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/7/2005 11:15'!glyphInfoOf: aCharacter into: glyphInfoArray	"Answer the width of the argument as a character in the receiver."	| code |	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont glyphInfoOf: aCharacter into: glyphInfoArray.		].		code := 0.	] ifTrue: [		code := aCharacter charCode.	].	glyphInfoArray at: 1 put: glyphs;		at: 2 put: (xTable at: code + 1);		at: 3 put: (xTable at: code + 2);		at: 4 put: (self ascentOf: aCharacter);		at: 5 put: self.	^ glyphInfoArray.! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!makeDerivedTables	| huffSize huffCode code si index lookbits |	mincode := Array new: 16.	maxcode := Array new: 17.	valptr := Array new: 17.	huffSize := OrderedCollection new.	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].	huffSize add: 0.	code := 0.	huffCode := Array new: huffSize size.	si := huffSize at: 1.	index := 1.	[(huffSize at: index) ~= 0] whileTrue:		[[(huffSize at: index) = si] whileTrue:			[huffCode at: index put: code.			index := index + 1.			code := code + 1].		code := code << 1.		si := si + 1].	index := 1.	1 to: 16 do:		[:l |		(bits at: l) ~= 0			ifTrue:				[valptr at: l put: index.				mincode at: l put: (huffCode at: index).				index := index + (bits at: l).				maxcode at: l put: (huffCode at: index-1)]			ifFalse:				[maxcode at: l put: -1]].	maxcode at: 17 put: 16rFFFFF.	lookaheadBits := (Array new: 1 << Lookahead) atAllPut: 0.	lookaheadSymbol := Array new: 1 << Lookahead.	index := 1.	1 to: Lookahead do:		[:l |		1 to: (bits at: l) do:			[:i |			lookbits := (huffCode at: index) << (Lookahead - l) + 1.			(1 << (Lookahead - l) to: 1 by: -1) do:				[:ctr |				lookaheadBits at: lookbits put: l.				lookaheadSymbol at: lookbits put: (values at: index).				lookbits := lookbits + 1].			index := index + 1]]! !!BDFFontReader class methodsFor: 'file creation' stamp: 'nop 1/23/2000 19:00'!convertFilesNamed: fileName toFamilyNamed: familyName inDirectoryNamed: dirName		"BDFFontReader convertFilesNamed: 'helvR' toFamilyNamed: 'Helvetica' inDirectoryNamed: '' "	"This utility converts X11 BDF font files to Squeak .sf2 StrikeFont files."	"For this utility to work as is, the BDF files must be named 'familyNN.bdf',	and must reside in the directory named by dirName (use '' for the current directory).	The output StrikeFont files will be named familyNN.sf2, and will be placed in the	current directory."	| f allFontNames sizeChars dir |	"Check for matching file names."	dir := dirName isEmpty		ifTrue: [FileDirectory default]		ifFalse: [FileDirectory default directoryNamed: dirName].	allFontNames := dir fileNamesMatching: fileName , '##.bdf'.	allFontNames isEmpty ifTrue: [^ self error: 'No files found like ' , fileName , 'NN.bdf'].		Utilities informUserDuring: [:info |		allFontNames do: [:fname | 			info value: 'Converting ', familyName, ' BDF file ', fname, ' to SF2 format'.			sizeChars := (fname copyFrom: fileName size + 1 to: fname size) copyUpTo: $. .			f := StrikeFont new readBDFFromFile: (dir fullNameFor: fname) name: familyName, sizeChars.			f writeAsStrike2named: familyName, sizeChars, '.sf2'.		].	]! !!Form methodsFor: 'transitions' stamp: 'jm 10/16/97 15:17'!wipeImage: otherImage at: topLeft delta: delta clippingBox: clipBox	| wipeRect bb nSteps |	bb := otherImage boundingBox.	wipeRect := delta x = 0		ifTrue:		[delta y = 0 ifTrue: [nSteps := 1. bb "allow 0@0"] ifFalse: [		nSteps := bb height//delta y abs + 1.  "Vertical movement"		delta y > 0			ifTrue: [bb topLeft extent: bb width@delta y]			ifFalse: [bb bottomLeft+delta extent: bb width@delta y negated]]]		ifFalse:		[nSteps := bb width//delta x abs + 1.  "Horizontal movement"		delta x > 0			ifTrue: [bb topLeft extent: delta x@bb height]			ifFalse: [bb topRight+delta extent: delta x negated@bb height]].	^ self wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex:		[:i | i <= nSteps			ifTrue: [wipeRect translateBy: (delta* (i-1))]			ifFalse: [nil]]! !!ColorForm methodsFor: 'displaying' stamp: 'ar 12/14/2001 18:14'!maskingMap	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."	| maskingMap |	maskingMap := Bitmap new: (1 bitShift: depth) withAll: 16rFFFFFFFF.	1 to: colors size do:[:i|		(colors at: i) isTransparent ifTrue:[maskingMap at: i put: 0].	].	colors size+1 to: maskingMap size do:[:i| maskingMap at: i put: 0].	^maskingMap! !!Pen methodsFor: 'operations' stamp: ''!place: aPoint 	"Set the receiver at position aPoint. No lines are drawn."	location := aPoint! !!DisplayScreen methodsFor: 'disk I/O' stamp: 'tk 9/28/2000 15:41'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to the Display in the other system instead.  "	"A path to me"	dp := DiskProxy global: #Display selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!benchmark2		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[1 to: 10 do:[:i| bb copyBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[1 to: 4 do:[:i| bb warpBits]].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!BitBlt methodsFor: 'accessing' stamp: ''!sourceY: anInteger 	"Set the receiver's source form top left y to be the argument, anInteger."	sourceY := anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!qTableIndex: anInteger	qTableIndex := anInteger! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/28/2000 12:06'!twoToneFromDisplay: aRectangle backgroundColor: bgColor	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."	| map |	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	"make a color map mapping the background color	 to zero and all other colors to one"	map := Bitmap new: (1 bitShift: (Display depth min: 9)).	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].	map at: (bgColor indexInMap: map) put: 0.	(BitBlt current toForm: self)		destOrigin: 0@0;		sourceForm: Display;		sourceRect: aRectangle;		combinationRule: Form over;		colorMap: map;		copyBits.! !!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!colors: colorList	"Set my color palette to the given collection."	| colorArray colorCount newColors |	colorList ifNil: [		colors := cachedDepth := cachedColormap := nil.		^ self].	colorArray := colorList asArray.	colorCount := colorArray size.	newColors := Array new: (1 bitShift: self depth).	1 to: newColors size do: [:i |		i <= colorCount			ifTrue: [newColors at: i put: (colorArray at: i)]			ifFalse: [newColors at: i put: Color transparent]].	colors := newColors.	cachedDepth := nil.	cachedColormap := nil.! !!GIFReadWriter methodsFor: 'private' stamp: ''!setParameters: initCodeSize	clearCode := 1 bitShift: initCodeSize.	eoiCode := clearCode + 1.	freeCode := clearCode + 2.	codeSize := initCodeSize + 1.	maxCode := (1 bitShift: codeSize) - 1! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:49'!readHeader	| is89 byte hasColorMap |	(self hasMagicNumber: 'GIF87a' asByteArray)		ifTrue: [is89 := false]		ifFalse: [(self hasMagicNumber: 'GIF89a' asByteArray)			ifTrue: [is89 := true]			ifFalse: [^ self error: 'This does not appear to be a GIF file']].	self readWord.	"skip Screen Width"	self readWord.	"skip Screen Height"	byte := self next.	hasColorMap := (byte bitAnd: 16r80) ~= 0.	bitsPerPixel := (byte bitAnd: 7) + 1.	byte := self next.	"skip background color."	self next ~= 0		ifTrue: [is89			ifFalse: [^self error: 'corrupt GIF file (screen descriptor)']].	hasColorMap		ifTrue:			[colorPalette := self readColorTable: (1 bitShift: bitsPerPixel)]		ifFalse:			["Transcript cr; show: 'GIF file does not have a color map.'."			colorPalette := nil "Palette monochromeDefault"].! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/15/2003 15:43'!testToSEFile: filename	"write SE file with origin		PNMReadWriter testToSEFile: 'Tools:Squeak3.4:outSE.pbm'.	"	| prw f |	prw := self new.	prw stream: ((FileStream newFileNamed: filename) binary).	prw pragma: '#origin 10 10', String lf.	f := Form fromUser.	prw nextPutImage: f! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ar 2/18/2004 23:58'!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits ff |	bitsPerChannel = 8 ifTrue: [		ff := Form extent: width@1 depth: 32 bits: thisScanline.		cachedDecoderMap 			ifNil:[cachedDecoderMap := self rgbaDecoderMapForDepth: depth].		(BitBlt toForm: form)			sourceForm: ff;			destOrigin: 0@y;			combinationRule: Form over;			colorMap: cachedDecoderMap;			copyBits.		^self.	].	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	i := -7.	0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.	].	tempForm displayOn: form at: 0@y rule: Form over.! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!bits: anObject	bits := anObject! !!FontSet class methodsFor: 'converting' stamp: 'sma 12/29/1999 21:18'!convertFontsNamed: familyName inDirectoryNamed: dirName		"FontSet convertFontsNamed: 'Tekton' inDirectoryNamed: 'Tekton Fonts' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and build	a fontset class from them.  If one already exists, the sizes that can be	found will be overwritten."	"For this utility to work as is, the BitFont data files must be named 'familyNN.BF',	and must reside in the directory named by dirName (use '' for the current directory)."	| allFontNames fontSet dir |	"Check first for matching file names and usable FontSet class name."	dir := dirName isEmpty		ifTrue: [FileDirectory default]		ifFalse: [FileDirectory default directoryNamed: dirName].	allFontNames := dir fileNamesMatching: familyName , '##.BF'.	allFontNames isEmpty ifTrue: [^ self error: 'No files found like ' , familyName , 'NN.BF'].	fontSet := self fontSetClass: familyName.	allFontNames do:		[:each |		Transcript cr; show: each.		fontSet compileFont: (StrikeFont new readFromBitFont: (dir fullNameFor: each))]! !!Form class methodsFor: 'examples' stamp: ''!exampleShrink	| f s |	f := Form fromUser.	s := f shrink: f boundingBox by: 2 @ 5.	s displayOn: Display at: Sensor waitButton		"Form exampleShrink."! !!TextStyle class methodsFor: 'instance creation' stamp: 'rbb 2/18/2005 13:18'!changeDefaultFontSizeBy: delta      "TextStyle changeDefaultFontSizeBy: 1"	"This sample method recreates the default textStyle, with font 1 being a size	larger than the smallest.  It then initializes most references in the system	as well, although most windows will have to beclosed and reopened to get the effect."	| allFonts |	allFonts := TextStyle default fontArray asSortedCollection: [:a :b | a height < b height].	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: ((1 to: allFonts size) collect: [:i | allFonts atWrap: i+delta])).	"rbb 2/18/2005 13:18 - How should this work for UIManager?"	PopUpMenu initialize.  "Change this method for difft menu font"	ListParagraph initialize.  "Change this method for difft ListPane font"	StandardSystemView initialize.  "Change this method for difft Window label font"! !!TextStyle methodsFor: 'private' stamp: ''!fontAt: index put: font	"Automatically grow the array.  8/20/96 tk"	index > fontArray size ifTrue: [		fontArray := fontArray, (Array new: index - fontArray size)].	fontArray at: index put: font! !!TextStyle methodsFor: 'accessing' stamp: 'ar 9/21/2000 15:17'!alignment: anInteger 	"Set the current setting of the alignment to be anInteger:	0=left flush, 1=right flush, 2=centered, 3=justified."	alignment := anInteger \\ (Justified + 1)! !!Form methodsFor: 'image manipulation' stamp: 'LB 8/26/2002 18:08'!stencil	"return a 1-bit deep, black-and-white stencil of myself"	| canvas |	canvas := FormCanvas extent: self extent depth: 1.	canvas fillColor: (Color white).	canvas stencil: self at: 0@0  				sourceRect: (Rectangle origin: 0@0 corner: self extent) color: Color black.	^ canvas form! !!Form methodsFor: 'private' stamp: 'ar 5/28/2000 15:49'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width := extent x asInteger.	width < 0 ifTrue: [width := 0].	height := extent y asInteger.	height < 0 ifTrue: [height := 0].	depth := bitsPerPixel.	(bits isNil or:[self bitsSize = bitmap size]) ifFalse:[^self error:'Bad dimensions'].	bits := bitmap! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 12/17/2001 02:13'!placeEmbeddedObject: anchoredMorph	| descent |	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: ["It doesn't fit"		"But if it's the first character then leave it here"		lastIndex < line first ifFalse:[			line stop: lastIndex-1.			^ false]].	descent := lineHeight - baseline.	lineHeight := lineHeight max: anchoredMorph height.	baseline := lineHeight - descent.	line stop: lastIndex.	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/7/2001 01:01'!perScanSetup	mcusPerRow := (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan := (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership := OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuMembership := mcuMembership asArray.	mcuSampleBuffer := (1 to: mcuMembership size) collect: [:i | IntegerArray new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer := Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo := restartInterval.! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location := aPoint.	direction := aFloat.	penDown := aBoolean! !!ColorForm methodsFor: 'private' stamp: 'jm 11/16/97 09:07'!clearColormapCache	cachedDepth := nil.	cachedColormap := nil.! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:10'!initMove	MoveCursor := 		Cursor 			extent: 16@16			fromArray: #(		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100          0)			offset: 0@0.! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 2/24/2001 22:39'!replaceByResource: aForm	"Replace the receiver by some resource that just got loaded"	(self extent = aForm extent and:[self depth = aForm depth]) ifTrue:[		bits := aForm bits.	].! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm := self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice := Form extent: width@1.	copyBlt := (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt := (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:43'!filterAverage: count	"Use the average of the pixel to the left and the pixel above as a predictor"	| delta |	delta := bitsPerPixel // 8 max: 1.	1 to: delta do: [:i |		thisScanline at: i put: ((thisScanline at: i) + ((prevScanline at: i) // 2) bitAnd: 255)].	delta + 1 to: count do: [:i |		thisScanline at: i put:			((thisScanline at: i)			+ ((prevScanline at: i)			+ (thisScanline at: i - delta) // 2) bitAnd: 255)]! !!HostFont methodsFor: 'accessing' stamp: 'ar 2/18/2001 20:01'!getFontData	| fontHandle bufSize buffer |	fontHandle := self primitiveCreateFont: name size: pointSize emphasis: emphasis.	fontHandle ifNil:[^nil].	bufSize := self primitiveFontDataSize: fontHandle.	buffer := ByteArray new: bufSize.	self primitiveFont: fontHandle getData: buffer.	^buffer! !!Form methodsFor: 'private' stamp: '6/9/97 16:10 di'!setExtent: extent depth: bitsPerPixel	"Create a virtual bit map with the given extent and bitsPerPixel."	width := extent x asInteger.	width < 0 ifTrue: [width := 0].	height := extent y asInteger.	height < 0 ifTrue: [height := 0].	depth := bitsPerPixel.	bits := Bitmap new: self bitsSize! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:02'!initTopRight	TopRightCursor := 		(Cursor extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011)			offset: -16@0).! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:16'!setScale: aPoint	"Set the raw scale in the receiver"	| pt |	pt := aPoint asPoint.	self a11: pt x asFloat.	self a22: pt y asFloat.! !!AnimatedGIFReadWriter methodsFor: 'accessing' stamp: 'bf 2/25/2005 11:11'!allImages	| body colorTable |	stream class == ReadWriteStream ifFalse: [		stream binary.		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable := nil.	forms := OrderedCollection new.	delays := OrderedCollection new.	comments := OrderedCollection new.	self readHeader.	[(body := self readBody) == nil]		whileFalse: [colorTable := localColorTable						ifNil: [colorPalette].			transparentIndex				ifNotNil: [transparentIndex + 1 > colorTable size						ifTrue: [colorTable := colorTable forceTo: transparentIndex + 1 paddingWith: Color white].					colorTable at: transparentIndex + 1 put: Color transparent].			body colors: colorTable.			forms add: body.			delays add: delay].	^ forms! !!Form methodsFor: 'transitions' stamp: 'jm 5/21/1998 23:46'!slideImage: otherImage at: topLeft delta: delta	"Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse		at: 40@40 delta: 3@-4"	| bb nSteps clipRect |	bb := otherImage boundingBox.	clipRect := topLeft extent: otherImage extent.	nSteps := 1.	delta x = 0 ifFalse: [nSteps := nSteps max: (bb width//delta x abs) + 1].	delta y = 0 ifFalse: [nSteps := nSteps max: (bb height//delta y abs) + 1].	1 to: nSteps do:			[:i | self copyBits: bb from: otherImage				at: delta*(i-nSteps) + topLeft				clippingBox: clipRect rule: Form paint fillColor: nil.			Display forceDisplayUpdate]! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!priorDCValue: aNumber	priorDCValue := aNumber! !!TextStyle class methodsFor: 'user interface' stamp: 'nk 9/1/2004 10:37'!mvcPromptForFont: aPrompt andSendTo: aTarget withSelector: aSelector	"MVC Only!! prompt for a font and if one is provided, send it to aTarget using a message with selector aSelector."	| aMenu aChoice aStyle namesAndSizes aFont |	"TextStyle mvcPromptForFont: 'Choose system font style' andSendTo: TextStyle withSelector: #setSystemFontTo:"	aMenu := CustomMenu new.	self actualTextStyles keysSortedSafely do:		[:styleName |			aMenu add: styleName action: styleName].	aChoice := aMenu startUpWithCaption: aPrompt.	aChoice ifNil: [^ self].	aMenu := CustomMenu new.	aStyle := self named: aChoice.	(namesAndSizes := aStyle fontNamesWithPointSizes) do:		[:aString | aMenu add: aString action: aString].	aChoice := aMenu startUpWithCaption: nil.	aChoice ifNil: [^ self].	aFont := aStyle fontAt: (namesAndSizes indexOf: aChoice).	aTarget perform: aSelector with: aFont! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'sr 6/6/2000 05:37'!slideWithFirstFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs 	"Slide this object across the display over the given number of steps, 	pausing for the given number of milliseconds after each step."	"Note: Does display at the first point and at the last."	| i p delta |	i := 0.	delta := stopPoint - startPoint / nSteps asFloat.	p := startPoint - delta.	^ self follow: [(p := p + delta) truncated]		while: 			[(Delay forMilliseconds: milliSecs) wait.			(i := i + 1) <= nSteps]! !!CompositionScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 02:06'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 9/16/2002 15:07'!fixForISO8859From: aStrikeFont	| fixer m mappingTable |	fixer := StrikeFontFixer newOn: aStrikeFont.	self reset.	xTable := aStrikeFont xTable copy.	glyphs := Form extent: aStrikeFont glyphs extent.	maxAscii := 255.	minAscii := 0.	mappingTable := fixer mappingTable.	"stopConditions := nil."	0 to: 255 do: [:i |		(m := mappingTable at: i+1) ~= nil ifTrue: [			self characterFormAt: (Character value: i)				put: (aStrikeFont characterFormAt: (Character value: m)).		] ifFalse: [			self characterFormAt: (Character value: i)				put: (aStrikeFont characterFormAt: (Character space)).		]	].	^self.	! !!TextStyle class methodsFor: 'TextConstants access' stamp: 'nk 9/1/2004 11:00'!actualTextStyles	| aDict |	"TextStyle actualTextStyles"	"Answer dictionary whose keys are the names of styles in the system and whose values are the actual styles"	aDict := TextConstants select: [:thang | thang isKindOf: self ].	self defaultFamilyNames do: [ :sym | aDict removeKey: sym ].	^ aDict! !!DisplayScreen methodsFor: 'other' stamp: ''!clippingTo: aRect do: aBlock	"Display clippingTo: Rectangle fromUser do:	[ScheduledControllers restore: Display fullBoundingBox]"	| saveClip |	saveClip := clippingBox.	clippingBox := aRect.	aBlock value.	clippingBox := saveClip! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/14/2001 23:31'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log := WriteStream on: String new.	destRect := 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest := nil.			dest := Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source := nil. bb := nil.				source := Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb := WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededFor: dest).				bb combinationRule: rule.				"Measure speed of copyBits"				t := Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t := Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !!CharacterScanner methodsFor: 'private' stamp: 'tak 3/12/2005 00:43'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont := font.	text == nil ifFalse:[		emphasisCode := 0.		kern := 0.		indentationLevel := 0.		alignment := textStyle alignment.		font := nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font := font emphasized: emphasisCode.	priorFont ifNotNil: [destX := destX + priorFont descentKern].	destX := destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX := destX max: leftMargin].	kern := kern - font baseKern.	"Install various parameters from the font."	spaceWidth := font widthOf: Space.	xTable := font xTable.	stopConditions := DefaultStopConditions.! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!pixelMap: pixelValue	"Perform a reverse pixel mapping operation"	| pv |	colors == nil		ifTrue:[pv := pixelValue]		ifFalse:[pv := colors at: pixelValue].	(shifts == nil and:[masks == nil]) 		ifFalse:[pv := (((pv bitAnd: self redMask) bitShift: self redShift) bitOr: 				((pv bitAnd: self greenMask) bitShift: self greenShift)) bitOr:					(((pv bitAnd: self blueMask) bitShift: self blueShift) bitOr: 						((pv bitAnd: self alphaMask) bitShift: self alphaShift))].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv := 1]].	^pv! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 5/15/2001 16:12'!mapPixel: pixelValue	"Perform a forward pixel mapping operation"	| pv |	(shifts == nil and:[masks == nil]) ifFalse:[		pv := (((pixelValue bitAnd: self redMask) bitShift: self redShift) bitOr:			((pixelValue bitAnd: self greenMask) bitShift: self greenShift)) bitOr:			(((pixelValue bitAnd: self blueMask) bitShift: self blueShift) bitOr:			((pixelValue bitAnd: self alphaMask) bitShift: self alphaShift)).	] ifTrue:[pv := pixelValue].	colors ifNotNil:[pv := colors at: pv].	"Need to check for translucency else Form>>paint goes gaga"	pv = 0 ifTrue:[pixelValue = 0 ifFalse:[pv := 1]].	^pv! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/28/2000 22:08'!inverseMap	"Return the inverse map of the receiver"	| newMasks newShifts |	colors ifNotNil:[^self error:'Not yet implemented'].	newMasks := WriteStream on: (Array new: 4).	newShifts := WriteStream on: (Array new: 4).	masks with: shifts do:[:mask :shift|		newMasks nextPut: (mask bitShift: shift).		newShifts nextPut: shift negated].	^ColorMap		shifts: newShifts contents		masks: newMasks contents! !!CharacterScanner methodsFor: 'initialize' stamp: 'RAA 5/7/2001 10:11'!wantsColumnBreaks: aBoolean	wantsColumnBreaks := aBoolean! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:50'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f := FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens := (f upTo: Character cr)  findTokens: ' '.	iRect := Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent := iRect top.	descent := iRect bottom negated.		tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	[charLine := self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p := f position.		rectLine := f upTo: Character cr.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens := rectLine findTokens: ' '.					left := (tokens at: 5) asNumber. right := (tokens at: 8) asNumber]			ifFalse: [left := right := 0. f position: p].		width:= (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii := 256].		('x''*' match: charLine) ifTrue:			[ascii := Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm := Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line := f upTo: Character cr.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm := charForm deepCopy]				ifFalse:				[minAscii := minAscii min: ascii.				maxAscii := maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii := ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!PNMReadWriter methodsFor: 'reading' stamp: 'md 10/20/2004 15:45'!readData	"generic data"	| data nBits nBytes val sample |	stream binary.	data := OrderedCollection new.	nBits := maxValue floorLog:2.	nBytes := (nBits+1) >> 3.	(nBits+1 rem: 8) > 0 ifTrue:[nBytes := nBytes+1].	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val := 0.			1 to: nBytes do: [:n |				sample := stream next.				val := val << 8 + sample.			].			data add: val.		]	].	^data! !!TextStyle methodsFor: 'accessing' stamp: ''!rightFlush	alignment := 1! !!InfiniteForm methodsFor: 'private' stamp: ''!form: aForm	patternForm := aForm! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!colormapFromARGB	"Return a ColorMap mapping from canonical ARGB space into the receiver.	Note: This version is optimized for Squeak forms."	| map nBits |	self hasNonStandardPalette 		ifTrue:[^ColorMap mappingFromARGB: self rgbaBitMasks].	self depth <= 8 ifTrue:[		map := Color colorMapIfNeededFrom: 32 to: self depth.		map size = 512 ifTrue:[nBits := 3].		map size = 4096 ifTrue:[nBits := 4].		map size = 32768 ifTrue:[nBits := 5].		^ColorMap			shifts: (Array 						with: 3 * nBits - 24						with: 2 * nBits - 16						with: 1 * nBits - 8						with: 0)			masks: (Array						with: (1 << nBits) - 1 << (24 - nBits)						with: (1 << nBits) - 1 << (16 - nBits)						with: (1 << nBits) - 1 << (8 - nBits)						with: 0)			colors: map].	self depth = 16 ifTrue:[		^ColorMap			shifts: #(-9 -6 -3 0)			masks: #(16rF80000 16rF800 16rF8 0)].	self depth = 32 ifTrue:[		^ColorMap			shifts: #(0 0 0 0)			masks: #(16rFF0000 16rFF00 16rFF 16rFF000000)].	self error:'Bad depth'! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 8/30/2000 10:00'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii := character asciiValue.	ascii < minAscii ifTrue: [^ self error: 'Cant store characters below min ascii'].	ascii > maxAscii ifTrue:		[(self confirm:'This font does not accomodate ascii values higher than ' , maxAscii printString , '.Do you wish to extend it permanently to handle values up to ' , ascii printString)			ifTrue: [self extendMaxAsciiTo: ascii]			ifFalse: [^ self error: 'No change made']].	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	widthDif := characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs := Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs := newGlyphs.		"adjust further entries on xTable"		xTable := xTable copy.		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f := TextStyle defaultFont.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!WarpBlt class methodsFor: 'examples' stamp: ''!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box := 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map := (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d := Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t := i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp := (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 := box center.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:45'!filterPaeth: count	"Select one of (the pixel to the left, the pixel above and the pixel to above left) to	predict the value of this pixel"	| delta |	delta := bitsPerPixel // 8 max: 1.	1 to: delta do: [ :i |		thisScanline at: i put:			(((thisScanline at: i) + (prevScanline at: i)) bitAnd: 255)].	delta+1 to: count do: [ :i |		thisScanline			at: i			put: (((thisScanline at: i) + (self				paethPredictLeft: (thisScanline at: i-delta)				above: (prevScanline at: i)				aboveLeft: (prevScanline at: i-delta)))					bitAnd: 255)]! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 2/18/1999 08:56'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask ext |	ext := aForm extent.	cursor := self extent: ext.	cursor copy: (1@1 extent: ext) from: 0@0 in: aForm rule: Form over.	mask := Form extent: ext.	(1@1) eightNeighbors do:		[:p | mask copy: (p extent: ext) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: ((aForm offset - (1@1)) max: ext negated).	^ cursor! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream := currentComponents at: 1.	cbSampleStream := currentComponents at: 2.	crSampleStream := currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits := mcuImageBuffer bits.	1 to: bits size do:		[:i |		y := ySampleStream nextSample.		cb := cbSampleStream nextSample - SampleOffset.		cr := crSampleStream nextSample - SampleOffset.		red := y + ((FIXn1n40200 * cr) // 65536) + (residuals at: 1).		red > MaxSample			ifTrue: [red := MaxSample]			ifFalse: [red < 0 ifTrue: [red := 0]].		residuals at: 1 put: (red bitAnd: ditherMask).		red := red bitAnd: MaxSample - ditherMask.		red < 1 ifTrue: [red := 1].		green := y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + (residuals at: 2).		green > MaxSample			ifTrue: [green := MaxSample]			ifFalse: [green < 0 ifTrue: [green := 0]].		residuals at: 2 put: (green bitAnd: ditherMask).		green := green bitAnd: MaxSample - ditherMask.		green < 1 ifTrue: [green := 1].		blue := y + ((FIXn1n77200 * cb) // 65536) + (residuals at: 3).		blue > MaxSample			ifTrue: [blue := MaxSample]			ifFalse: [blue < 0 ifTrue: [blue := 0]].		residuals at: 3 put: (blue bitAnd: ditherMask).		blue := blue bitAnd: MaxSample - ditherMask.		blue < 1 ifTrue: [blue := 1].		bits at: i put: 16rFF000000 + (red bitShift: 16) + (green bitShift: 8) + blue].	! !!AbstractFont methodsFor: 'measuring' stamp: 'tak 1/11/2005 17:20'!approxWidthOfText: aText"Return the width of aText -- quickly, and a little bit dirty. Used by lists morphs containing Text objects to get a quick, fairly accurate measure of the width of a list item."    | w |        (aText isNil or: [aText size == 0 ])        ifTrue:[^0].           w := self        widthOfString: aText asString.     "If the text has no emphasis, just return the string size.  If it is empasized,     just approximate the width by adding about 20% to the width"       (((aText runLengthFor: 1) == aText size)        and: [(aText emphasisAt: 1) == 0 ])            ifTrue:[^w]            ifFalse:[ ^w * 6 // 5 ]. ! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:29'!readPalette	| r g b array |	self next = 12 ifFalse: [self error: 'no Color Palette!!'].	array := Array new: (1 bitShift: bitsPerPixel).	1 to: array size do:		[:i |		r := self next.  g := self next.  b := self next.		array at: i put: (Color r: r g: g b: b range: 255)].	^ array.! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:46'!readAttributesFrom: aBinaryStream	super readAttributesFrom: aBinaryStream.	colors := ColorArray new: (2 raisedTo: depth).	1 to: colors size do: [:idx | 		colors basicAt: idx put: (aBinaryStream nextLittleEndianNumber: 4).	]. 	! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:33'!xTable: anObject	xTable := anObject.! !!Pen methodsFor: 'operations' stamp: ''!up	"Set the state of the receiver's pen to up (no drawing)."	penDown := false! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hDCTable	hDCTable ifNil: [hDCTable := Array new: HuffmanTableSize].	^ hDCTable! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10 and:   "check for no change every 10 smears"		[count := 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count := count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!DisplayText class methodsFor: 'examples' stamp: 'tk 11/28/2001 16:03'!example	"Continually prints two lines of text wherever you point with the cursor.  Terminate by pressing any button on the	mouse."	| tx |	tx := 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color transparent.	tx := tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !!TextStyle methodsFor: 'accessing' stamp: ''!firstIndent: anInteger 	"Set the horizontal indenting of the first line of a paragraph in the style 	of the receiver to be the argument, anInteger."	firstIndent := anInteger! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'RAA 5/7/2001 10:12'!setFont	super setFont.	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions := stopConditions copy].	stopConditions at: Space asciiValue + 1 put: #space.	wantsColumnBreaks == true ifTrue: [		stopConditions at: TextComposer characterForColumnBreak asciiValue + 1 put: #columnBreak.	].! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'nk 3/15/2004 19:37'!looseFontsFromFamily: familyName	"	TextStyle looseFontsFromFamily: 'Accuny'	TextStyle looseFontsFromFamily: 'Accujen'	TextStyle actualTextStyles keys collect: [ :k | TextStyle looseFontsFromFamily: k ]	"	| looseFonts realStyle classes |	realStyle := TextStyle named: familyName.	classes := ((realStyle fontArray copyWithout: nil) collect: [ :f | f class ]) asSet.	classes do: [ :cls | cls allSubInstancesDo: [ :f | f releaseCachedState ]].	Smalltalk garbageCollect.	looseFonts := IdentitySet new.	classes do: [ :cls |		looseFonts addAll: ((cls allSubInstances select: [ :ea | ea familyName = familyName ])			reject: [ :f | realStyle fontArray anySatisfy: [ :fn | fn == f or: [ fn derivativeFonts includes: f ] ]]) ].	^looseFonts! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray := ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte := self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Color methodsFor: 'conversions' stamp: ''!halfTonePattern2	"Return a halftone-pattern to approximate luminance levels on 2-bit deep Forms."	| lum |	lum := self luminance.	lum < 0.125 ifTrue: [^ Bitmap with: 16r55555555].  "black"	lum < 0.25 ifTrue: [^ Bitmap with: 16r55555555 with: 16rDDDDDDDD].  "1/8 gray"	lum < 0.375 ifTrue: [^ Bitmap with: 16rDDDDDDDD with: 16r77777777].  "2/8 gray"	lum < 0.5 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16r77777777].  "3/8 gray"	lum < 0.625 ifTrue: [^ Bitmap with: 16rFFFFFFFF].  "4/8 gray"	lum < 0.75 ifTrue: [^ Bitmap with: 16rFFFFFFFF with: 16rBBBBBBBB].  "5/8 gray"	lum < 0.875 ifTrue: [^ Bitmap with: 16rEEEEEEEE with: 16rBBBBBBBB].  "6/8 gray"	lum < 1.0 ifTrue: [^ Bitmap with: 16rAAAAAAAA with: 16rBBBBBBBB].  "7/8 gray"	^ Bitmap with: 16rAAAAAAAA  "opaque white""handy expression for computing patterns for 2x2 tiles; set p to a string of 4 letters (e.g., 'wggw' for a gray-and- white checkerboard) and print the result of evaluating:| p d w1 w2 |p := 'wggw'.d := Dictionary new.d at: $b put: '01'.d at: $w put: '10'.d at: $g put: '11'.w1 := (d at: (p at: 1)), (d at: (p at: 2)).w1 := '2r', w1, w1, w1, w1, w1, w1, w1, w1, ' hex'.w2 := (d at: (p at: 3)), (d at: (p at: 4)).w2 := '2r', w2, w2, w2, w2, w2, w2, w2, w2, ' hex'.Array with: (Compiler evaluate: w1) with: (Compiler evaluate: w2) "! !!Form methodsFor: 'analyzing' stamp: 'jm 12/5/97 19:48'!colorsUsed	"Return a list of the Colors this form uses."	| tallies tallyDepth usedColors |	tallies := self tallyPixelValues.	tallyDepth := (tallies size log: 2) asInteger.	usedColors := OrderedCollection new.	tallies doWithIndex: [:count :i |		count > 0 ifTrue: [			usedColors add: (Color colorFromPixelValue: i - 1 depth: tallyDepth)]].	^ usedColors asArray! !!GIFReadWriter methodsFor: 'private-bits access' stamp: ''!flushBits	remainBitCount = 0 ifFalse:		[self nextBytePut: bufByte.		remainBitCount := 0].	self flushBuffer! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 6/18/2000 19:16'!deferUpdates: aBoolean	| wasDeferred |	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen. If this underlying platform does not support deferred updates, this primitive will fail. Answer whether updates were deferred before if the primitive succeeds, nil if it fails."	wasDeferred := DeferringUpdates == true.	DeferringUpdates := aBoolean.	^(self primitiveDeferUpdates: aBoolean) ifNotNil: [wasDeferred]! !!Bitmap class methodsFor: 'utilities' stamp: 'sd 6/28/2003 09:33'!swapBytesIn: aNonPointerThing from: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words.	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack := Form new hackBits: aNonPointerThing.	blt := (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 2/2/2001 15:47'!= aMatrixTransform2x3 	| length |	<primitive: 'primitiveEqual' module: 'FloatArrayPlugin'>	self class = aMatrixTransform2x3 class ifFalse: [^ false].	length := self size.	length = aMatrixTransform2x3 size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aMatrixTransform2x3 at: i) ifFalse: [^ false]].	^ true! !!DisplayScreen methodsFor: 'other' stamp: ''!boundingBox	clippingBox == nil		ifTrue: [clippingBox := super boundingBox].	^ clippingBox! !!Quadrangle methodsFor: 'bordering' stamp: ''!borderColor: aColor 	"Set the borderColor of the receiver to aColor, a Form."	borderColor := aColor! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font := aFont! !!Bitmap methodsFor: 'filing' stamp: 'di 2/11/98 21:34'!readCompressedFrom: strm	"Decompress an old-style run-coded stream into this bitmap:		[0 means end of runs]		[n = 1..127] [(n+3) copies of next byte]		[n = 128..191] [(n-127) next bytes as is]		[n = 192..255] [(n-190) copies of next 4 bytes]"	| n byte out outBuff bytes |	out := WriteStream on: (outBuff := ByteArray new: self size*4).	[(n := strm next) > 0] whileTrue:		[(n between: 1 and: 127) ifTrue:			[byte := strm next.			1 to: n+3 do: [:i | out nextPut: byte]].		(n between: 128 and: 191) ifTrue:			[1 to: n-127 do: [:i | out nextPut: strm next]].		(n between: 192 and: 255) ifTrue:			[bytes := (1 to: 4) collect: [:i | strm next].			1 to: n-190 do: [:i | bytes do: [:b | out nextPut: b]]]].	out position = outBuff size ifFalse: [self error: 'Decompression size error'].	"Copy the final byteArray into self"	self copyFromByteArray: outBuff.! !!MorphicTransform methodsFor: 'private' stamp: ''!setScale: aFloat	scale := aFloat.! !!Form methodsFor: 'scaling, rotation' stamp: 'ar 5/14/2001 23:33'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm := self class extent: self extent depth: depth.	quad := self boundingBox innerCorners.	quad := (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt current toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededFor: newForm);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 12/16/2001 19:27'!placeEmbeddedObject: anchoredMorph	"Workaround: The following should really use #textAnchorType"	anchoredMorph relativeTextAnchorPosition ifNotNil:[^true].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth := anchoredMorph width.	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/6/2001 22:28'!parseAPPn	| length buffer thumbnailLength markerStart |	markerStart := self position.	length := self nextWord.	buffer := self next: 4.	(buffer asString = 'JFIF') ifFalse: [		"Skip APPs that we're not interested in"		stream next: length-6.		^self].	self next.	majorVersion := self next.	minorVersion := self next.	densityUnit := self next.	xDensity := self nextWord.	yDensity := self nextWord.	thumbnailLength := self next * self next * 3.	length := length - (self position - markerStart).	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].	self next: length! !!Bitmap methodsFor: 'accessing' stamp: 'ar 3/3/2001 22:42'!integerAt: index put: anInteger	"Store the integer at the given index"	| word |	<primitive: 166>	anInteger < 0		ifTrue:["word := 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[word := anInteger].	self  basicAt: index put: word.	^anInteger! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 15:49'!readBWreverse: flagXor	"B&W for PAM"	| val form bytesRow nBytes |	stream binary.	form := Form extent: cols@rows depth: 1.	nBytes := (cols/8) ceiling.	bytesRow := (cols/32) ceiling * 4.	0 to: rows-1 do: [:y | | i |		i := 1 + (bytesRow*y).		0 to: nBytes-1 do: [:x |			val := stream next.			flagXor ifTrue:[val := val bitXor: 16rFF].			form bits byteAt: i put: val.			i := i+1.		]	].	^form! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 20:05'!paethPredictLeft: a above: b aboveLeft: c	"Predicts the value of a pixel based on nearby pixels, based onPaeth (GG II, 1991)"	| pa pb pc |	pa := b > c ifTrue: [b - c] ifFalse: [c - b].	pb := a > c ifTrue: [a - c] ifFalse: [c - a].	pc := a + b - c - c.	pc < 0 ifTrue: [		pc := pc * -1].	((pa <= pb) and: [pa <= pc]) ifTrue: [^ a].	(pb <= pc) ifTrue: [^ b].	^ c! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:28'!oldColorPaletteForDepth: depth extent: paletteExtent	"Returns a form of the given size showing a color palette for the given depth."	"(Color oldColorPaletteForDepth: Display depth extent: 720@100) display"	| c p f nSteps rect w h q |	f := Form extent: paletteExtent depth: depth.	f fill: f boundingBox fillColor: Color white.	nSteps := depth > 8 ifTrue: [12] ifFalse: [6].	w := paletteExtent x // (nSteps * nSteps).	h := paletteExtent y - 20 // nSteps.	0 to: nSteps-1 do: [:r |		0 to: nSteps-1 do: [:g |			0 to: nSteps-1 do: [:b |				c := Color r: r g: g b: b range: nSteps - 1.				rect := ((r * nSteps * w) + (b * w)) @ (g * h) extent: w@(h + 1).				f fill: rect fillColor: c]]].	q := Quadrangle origin: paletteExtent - (50@19) corner: paletteExtent.	q displayOn: f.	'Trans.' displayOn: f at: q origin + (9@1).	w := ((paletteExtent x - q width - 130) // 64) max: 1.	p := paletteExtent x - q width - (64 * w) - 1 @ (paletteExtent y - 19).	0 to: 63 do:		[:v | c := Color r: v g: v b: v range: 63.		f fill: ((v * w)@0 + p extent: (w + 1)@19) fillColor: c].	^ f! !!DisplayText methodsFor: 'private' stamp: 'nk 6/25/2003 12:51'!composeForm	"For the TT strings in MVC widgets in a Morphic world such as a progress bar, the form is created by Morphic machinery."	| canvas tmpText |	Smalltalk isMorphic		ifTrue:			[tmpText := TextMorph new contentsAsIs: text deepCopy.			foreColor ifNotNil: [tmpText text addAttribute: (TextColor color: foreColor)].			backColor ifNotNil: [tmpText backgroundColor: backColor].			tmpText setTextStyle: textStyle.			canvas := FormCanvas on: (Form extent: tmpText extent depth: 32).			tmpText drawOn: canvas.			form := canvas form.		]		ifFalse: [form := self asParagraph asForm]! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 5/27/2001 16:30'!pixelValueForDepth: d	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord := super pixelValueForDepth: d.	d < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 16:16'!objectForDataStream: refStream	| prj repl |	prj := refStream project.	prj ifNil:[^super objectForDataStream: refStream].	ResourceCollector current ifNil:[^super objectForDataStream: refStream].	repl := ResourceCollector current objectForDataStream: refStream fromForm: self.	^repl! !!MorphicTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 20:58'!setIdentiy	scale := 1.0.	offset := 0@0.	angle := 0.0.! !!CharacterScanner methodsFor: 'scanning' stamp: 'tak 3/12/2005 00:43'!measureString: aString inFont: aFont from: startIndex to: stopIndex	"WARNING: In order to use this method the receiver has to be set up using #initializeStringMeasurer"	destX := destY := lastIndex := 0.	xTable := aFont xTable.	self scanCharactersFrom: startIndex to: stopIndex in: aString rightX: 999999 stopConditions: stopConditions kern: 0.	^destX! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'mir 11/19/2003 12:19'!readBitData	"using modified Lempel-Ziv Welch algorithm."	| outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar i bytes f c packedBits hasLocalColor localColorSize maxOutCodes |	maxOutCodes := 4096.	offset := self readWord@self readWord. "Image Left@Image Top"	width := self readWord.	height := self readWord.	"---	Local Color Table Flag        1 Bit	Interlace Flag                1 Bit	Sort Flag                     1 Bit	Reserved                      2 Bits	Size of Local Color Table     3 Bits	----"	packedBits := self next.	interlace := (packedBits bitAnd: 16r40) ~= 0.	hasLocalColor := (packedBits bitAnd: 16r80) ~= 0.	localColorSize := 1 bitShift: ((packedBits bitAnd: 16r7) + 1).	hasLocalColor ifTrue: [localColorTable := self readColorTable: localColorSize].	pass := 0.	xpos := 0.	ypos := 0.	rowByteSize := ((width + 3) // 4) * 4.	remainBitCount := 0.	bufByte := 0.	bufStream := ReadStream on: ByteArray new.	outCodes := ByteArray new: maxOutCodes + 1.	outCount := 0.	bitMask := (1 bitShift: bitsPerPixel) - 1.	prefixTable := Array new: 4096.	suffixTable := Array new: 4096.	initCodeSize := self next.	self setParameters: initCodeSize.	bitsPerPixel > 8 ifTrue: [^self error: 'never heard of a GIF that deep'].	bytes := ByteArray new: rowByteSize * height.	[(code := self readCode) = eoiCode] whileFalse:		[code = clearCode			ifTrue:				[self setParameters: initCodeSize.				curCode := oldCode := code := self readCode.				finChar := curCode bitAnd: bitMask.				"Horrible hack to avoid running off the end of the bitmap.  Seems to cure problem reading some gifs!!? tk 6/24/97 20:16"				xpos = 0 ifTrue: [						ypos < height ifTrue: [							bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar]]					ifFalse: [bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar].				self updatePixelPosition]			ifFalse:				[curCode := inCode := code.				curCode >= freeCode ifTrue:					[curCode := oldCode.					outCodes at: (outCount := outCount + 1) put: finChar].				[curCode > bitMask] whileTrue:					[outCount > maxOutCodes						ifTrue: [^self error: 'corrupt GIF file (OutCount)'].					outCodes at: (outCount := outCount + 1)						put: (suffixTable at: curCode + 1).					curCode := prefixTable at: curCode + 1].				finChar := curCode bitAnd: bitMask.				outCodes at: (outCount := outCount + 1) put: finChar.				i := outCount.				[i > 0] whileTrue:					["self writePixel: (outCodes at: i) to: bits"					bytes at: (ypos * rowByteSize) + xpos + 1 put: (outCodes at: i).					self updatePixelPosition.					i := i - 1].				outCount := 0.				prefixTable at: freeCode + 1 put: oldCode.				suffixTable at: freeCode + 1 put: finChar.				oldCode := inCode.				freeCode := freeCode + 1.				self checkCodeSize]].	prefixTable := suffixTable := nil.	f := ColorForm extent: width@height depth: 8.	f bits copyFromByteArray: bytes.	"Squeak can handle depths 1, 2, 4, and 8"	bitsPerPixel > 4 ifTrue: [^ f].	"reduce depth to save space"	c := ColorForm extent: width@height		depth: (bitsPerPixel = 3 ifTrue: [4] ifFalse: [bitsPerPixel]).	f displayOn: c.	^ c! !!StrikeFont methodsFor: 'accessing' stamp: 'sma 5/5/2000 14:21'!pointSize: anInteger	pointSize := anInteger! !!BitBlt methodsFor: 'private' stamp: 'ar 5/14/2001 23:43'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	sourceForm ifNotNil:[lastSourceDepth := sourceForm depth].	sourceForm := aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Uses caching for reasonable efficiency"		colorMap := self cachedFontColormapFrom: sourceForm depth to: destForm depth.		colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).		"Ignore any halftone pattern since we use a color map approach here"		halftoneForm := nil].	sourceY := 0.	height := aStrikeFont height.! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'nk 9/1/2004 11:03'!replaceStyle: oldStyle with: newStyle	"	TextStyle replaceStyle: (TextStyle named: #AccunyOLD) with: (TextStyle named: #Accuny)	"	"Try to find corresponding fonts in newStyle and substitute the fonts in oldStyle for them."	| oldKeys |	oldKeys := Set new.	TextConstants keysAndValuesDo: [ :k :v | v = oldStyle ifTrue: [ oldKeys add: k ]].	oldKeys removeAllFoundIn: self defaultFamilyNames.	self replaceFontsIn: oldStyle fontArray with: newStyle.	oldStyle becomeForward: newStyle.	oldKeys do: [ :k | TextConstants removeKey: k ].! !!StrikeFont methodsFor: 'private' stamp: 'yo 5/20/2004 10:51'!leftAndRighOrNilFor: char	| code leftX |	code := char charCode.	((code between: self minAscii and: self maxAscii) not) ifTrue: [		code := $? charCode.	].	leftX := xTable at: code + 1.	leftX < 0 ifTrue: [		code := $? charCode.		leftX := xTable at: code + 1.	].	^ Array with: leftX with: (xTable at: code + 2).! !!GIFReadWriter methodsFor: 'private' stamp: ''!checkCodeSize	(freeCode > maxCode and: [codeSize < 12])		ifTrue:			[codeSize := codeSize + 1.			maxCode := (1 bitShift: codeSize) - 1]! !!StrikeFont methodsFor: 'emphasis' stamp: ''!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis := code! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 19:41'!mappingFrom: srcBitMasks to: dstBitMasks	"Return a color map mapping from the array of source bit masks	to the array of dest bit masks."	| shifts masks shiftAndMask |	shifts := IntegerArray new: 4.	masks := WordArray new: 4.	1 to: 4 do:[:i|		shiftAndMask := self mapBitsFrom: (srcBitMasks at: i) to: (dstBitMasks at: i).		shifts at: i put: (shiftAndMask at: 1).		masks at: i put: (shiftAndMask at: 2).	].	^self shifts: shifts masks: masks! !!Cursor class methodsFor: 'class initialization' stamp: 'ar 7/18/2009 20:42'!makeCursorsWithMask	"Cursor initialize;makeCursorsWithMask"	self classPool associationsDo: [:var |		((var value isKindOf: Cursor) and:[var value hasMask not])			ifTrue: [var value: var value withMask]]! !!StrikeFont methodsFor: 'file in/out' stamp: ''!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line := file upTo: Character cr.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'make arrows' stamp: 'sps 10/15/2003 17:06'!makeReturnArrow"Replace the caret character with an arrow"	| arrowForm arrowCanvas arrowHeadLength arrowX arrowTop arrowBottom |	arrowForm := (self characterFormAt: $^) copy.	arrowCanvas := arrowForm getCanvas.	arrowCanvas fillColor: Color white.	arrowHeadLength := ((arrowForm width - 2)// 2).	arrowX := (arrowHeadLength max: (arrowForm width // 2)).	arrowTop := arrowForm height // 4. 	arrowBottom := (arrowTop + (arrowForm width * 4 // 5 )).	arrowBottom := (arrowBottom min: arrowForm height) max: (arrowForm height * 2 // 3).	"Draw the lines"	arrowCanvas line: (arrowX@arrowTop) to: (arrowX@arrowBottom) color: Color black.	arrowCanvas 		line: (arrowX@arrowTop) 		to: ((arrowX - arrowHeadLength)@(arrowTop + arrowHeadLength)) 		color: Color black.	arrowCanvas 		line: (arrowX@arrowTop) 		to: ((arrowX + arrowHeadLength)@(arrowTop + arrowHeadLength)) 		color: Color black.	"Replace the glyph"	self characterFormAt: $^ put: arrowForm.! !!Form methodsFor: 'displaying' stamp: ''!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Graphically, it means nothing to scale a Form by floating point values.  	Because scales and other display parameters are kept in floating point to 	minimize round off errors, we are forced in this routine to round off to the 	nearest integer."	| absolutePoint scale magnifiedForm |	absolutePoint := displayTransformation applyTo: relativePoint.	absolutePoint := absolutePoint x asInteger @ absolutePoint y asInteger.	displayTransformation noScale		ifTrue: [magnifiedForm := self]		ifFalse: 			[scale := displayTransformation scale.			scale := scale x @ scale y.			(1@1 = scale)					ifTrue: [scale := nil. magnifiedForm := self]					ifFalse: [magnifiedForm := self magnify: self boundingBox by: scale]].	magnifiedForm		displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!TextLineInterval methodsFor: 'private' stamp: ''!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces := spacesInteger.	paddingWidth := padWidthInteger! !!Form methodsFor: 'color mapping' stamp: 'ar 5/15/2001 16:16'!pixelWordFor: aColor	"Return the pixel word for representing the given color on the receiver"	| basicPattern |	self hasNonStandardPalette 		ifFalse:[^aColor pixelWordForDepth: self depth].	basicPattern := self pixelValueFor: aColor.	self depth = 32 		ifTrue:[^basicPattern]		ifFalse:[^aColor pixelWordFor: self depth filledWith: basicPattern]! !!CompositionScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:36'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent := font descent.				baseline := font ascent.				lineHeight := baseline + descent]		ifFalse: [descent := lineHeight - baseline max: font descent.				baseline := baseline max: font ascent.				lineHeight := lineHeight max: baseline + descent]! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:48'!readColorTable: numberOfEntries	| array r g b |	array := Array new: numberOfEntries.	1 to: array size do: [ :i |		r := self next.  		g := self next.  		b := self next.		array at: i put: (Color r: r g: g b: b range: 255)	].	^array! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!skipMarker	| length markerStart |	markerStart := self position.	length := self nextWord.	self next: length - (self position - markerStart)! !!TextLineInterval methodsFor: 'accessing' stamp: ''!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces := spacesInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'ar 3/4/2001 01:19'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth := mw.	mcuHeight := mh.	dctSize := ds.	hSampleFactor := mcuWidth // widthInBlocks.	vSampleFactor := mcuHeight // heightInBlocks! !!PNMReadWriter class methodsFor: 'testing' stamp: 'jdr 10/11/2003 14:49'!testFromSEFile: filename	"read SE file, check origin		PNMReadWriter testFromSEFile: 'Tools:Squeak3.4:eliseSE.pbm'.	"	| prw f |	prw := self new.	prw stream: (FileStream readOnlyFileNamed: filename).	f := prw nextImage.	f morphEdit.	prw inspect! !!Rectangle methodsFor: 'transforming' stamp: 'JMM 10/21/2003 17:26'!newRectButtonPressedDo: newRectBlock 	"Track the outline of a new rectangle until mouse button 	changes. newFrameBlock produces each new rectangle from the 	previous. Only tracks while mouse is down."	| rect newRect buttonNow aHand delay |	delay := Delay forMilliseconds: 10.	buttonNow := Sensor anyButtonPressed.	rect := self.	Display		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	[buttonNow]		whileTrue: [delay wait.			buttonNow := Sensor anyButtonPressed.			newRect := newRectBlock value: rect.			newRect = rect				ifFalse: [Display						border: rect						width: 2						rule: Form reverse						fillColor: Color gray.					Display						border: newRect						width: 2						rule: Form reverse						fillColor: Color gray.					rect := newRect]].	Display		border: rect		width: 2		rule: Form reverse		fillColor: Color gray.	" pay the price for reading the sensor directly ; get this party started "	Smalltalk isMorphic		ifTrue: [aHand := World activeHand.			aHand newMouseFocus: nil;				 showTemporaryCursor: nil;				 flushEvents].	Sensor processEvent: Sensor createMouseEvent.	^ rect! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i := 0.	clipRect := topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect := clipRect intersect: clipBox].	[rectOrList := rectForIndexBlock value: (i := i + 1).	 rectOrList == nil]		whileFalse: [			t := Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime := 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!StrikeFont methodsFor: 'file in/out' stamp: 'sma 12/30/1999 14:20'!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name := fileName copyUpTo: $. .  "Drop filename extension"	file := FileStream readOnlyFileNamed: fileName.	file binary.	[self readFromStrike2Stream: file] ensure: [file close]! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id: anObject	id := anObject! !!BitBlt methodsFor: 'private' stamp: 'yo 3/11/2005 14:49'!primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta	| ascii |	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>	startIndex to: stopIndex do:[:charIndex|		ascii := (aString at: charIndex) asciiValue.		sourceX := xTable at: ascii + 1.		width := (xTable at: ascii + 2) - sourceX.		self copyBits.		destX := destX + width + kernDelta.	].! !!ColorForm methodsFor: 'private' stamp: 'jm 4/5/1999 10:11'!setColors: colorArray cachedColormap: aBitmap depth: anInteger	"Semi-private. Set the color array, cached colormap, and cached colormap depth to avoid having to recompute the colormap when switching color palettes in animations."	colors := colorArray.	cachedDepth := anInteger.	cachedColormap := aBitmap.! !!Rectangle class methodsFor: 'instance creation' stamp: ''!fromUser: gridPoint	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners. 	The cursor reamins linked with the sensor, but	the outline is kept gridded."	| originRect |	originRect := Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: 0@0) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: 0@0]].	^ Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: (Sensor cursorPoint grid: gridPoint)]]! !!Color class methodsFor: 'examples' stamp: ''!showHuesInteractively	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."	"Color showHuesInteractively"	| p s v |	[Sensor anyButtonPressed] whileFalse: [		p := Sensor cursorPoint.		s := p x asFloat / 300.0.		v := p y asFloat / 300.0.		self showColors: (self wheel: 12 saturation: s brightness: v)].	^ (s min: 1.0) @ (v min: 1.0)! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:15'!insertMorph: aMorph named: aString into: aBook	| newPage |	aBook ifNil: [^self].	newPage := aBook insertPageLabel: aString morphs: {aMorph}.	newPage color: Color lightYellow.	newPage extent: (		newPage submorphs inject: 10@10 into: [ :ex :m |			m left: 10.			ex max: m width @ m bottom		]	) + (20@20).! !!Color methodsFor: 'access' stamp: ''!saturation	"Return the saturation of this color, a value between 0.0 and 1.0."	| r g b max min |	r := self privateRed.	g := self privateGreen.	b := self privateBlue. 	max := min := r.	g > max ifTrue: [max := g].	b > max ifTrue: [max := b].	g < min ifTrue: [min := g].	b < min ifTrue: [min := b].	max = 0		ifTrue: [ ^ 0.0 ]		ifFalse: [ ^ (max - min) asFloat / max asFloat ].! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 5/24/2004 17:54'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g := glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs := g.	fallbackFont ifNotNil: [		fallbackFont := fallbackFont emphasized: 16	].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'mir 6/12/2001 11:28'!parseFirstMarker	| marker |	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].	marker := self next.	marker = 16rD9		ifTrue: [^self "halt: 'EOI encountered.'"].	marker = 16rD8 ifFalse: [self error: 'SOI marker expected'].	self parseStartOfInput.! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:47'!read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width	| pixIndex rgb bitsIndex |	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := 			(pixelLine at: (pixIndex := pixIndex+1)) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).		formBits at: (bitsIndex := bitsIndex+1) put: rgb.	].! !!Color class methodsFor: 'instance creation' stamp: 'tk 8/15/2001 11:03'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r := (p bitShift: -10) bitAnd: 16r1F.		g := (p bitShift: -5) bitAnd: 16r1F.		b := p bitAnd: 16r1F.		(r = 0 and: [g = 0]) ifTrue: [			b = 0 ifTrue: [^Color transparent].			b = 1 ifTrue: [^Color black]].		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		r := (p bitShift: -16) bitAnd: 16rFF.		g := (p bitShift: -8) bitAnd: 16rFF.		b := p bitAnd: 16rFF.		alpha := p bitShift: -24.		alpha = 0 ifTrue: [^Color transparent].		(r = 0 and: [g = 0 and: [b = 0]])  ifTrue: [^Color transparent].		alpha < 255			ifTrue: [^ (Color r: r g: g b: b range: 255) alpha: (alpha asFloat / 255.0)]			ifFalse: [^ (Color r: r g: g b: b range: 255)]].	d = 12 ifTrue: [		"four bits per component"		r := (p bitShift: -8) bitAnd: 16rF.		g := (p bitShift: -4) bitAnd: 16rF.		b := p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r := (p bitShift: -6) bitAnd: 16r7.		g := (p bitShift: -3) bitAnd: 16r7.		b := p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:42'!encompassing: listOfPoints	"A number of callers of encompass: should use this method."	| topLeft bottomRight |	topLeft := bottomRight := nil.	listOfPoints do:		[:p | topLeft == nil			ifTrue: [topLeft := bottomRight := p]			ifFalse: [topLeft := topLeft min: p.					bottomRight := bottomRight max: p]].	^ topLeft corner: bottomRight! !!BitBlt methodsFor: 'accessing' stamp: ''!sourceX: anInteger 	"Set the receiver's source form top left x to be the argument, anInteger."	sourceX := anInteger! !!Pen methodsFor: 'private' stamp: ''!sourceForm: aForm	(aForm depth = 1 and: [destForm depth > 1])		ifTrue: ["Map 1-bit source to all ones for color mask"				colorMap := Bitmap with: 0 with: 16rFFFFFFFF]		ifFalse: [colorMap := nil].	^ super sourceForm: aForm! !!BitBlt methodsFor: 'copying' stamp: ''!copyForm: srcForm to: destPt rule: rule color: color	sourceForm := srcForm.	halftoneForm := color.	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	self copyBits! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:49'!readPlainRGB	"RGB form, use 32 bits"	| val form poker tokens aux |	maxValue > 255 ifTrue:[self error:'RGB value > 32 bits not supported in Squeak'].	form := Form extent: cols@rows depth: 32.	poker := BitBlt current bitPokerToForm: form.	tokens := OrderedCollection new.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x | | r g b|			aux := self getTokenPbm: tokens. r := aux at: 1. tokens := aux at: 2.			aux := self getTokenPbm: tokens. g := aux at: 1. tokens := aux at: 2.			aux := self getTokenPbm: tokens. b := aux at: 1. tokens := aux at: 2.			val := self r: r g: g b: b for: depth.			poker pixelAt: x@y put: val.		]	].	^form! !!BitBlt class methodsFor: 'private' stamp: 'jrm 2/21/2001 23:45'!exampleAt: originPoint rule: rule fillColor: mask 	"This builds a source and destination form and copies the source to the	destination using the specifed rule and mask. It is called from the method	named exampleOne. Only works with Display depth of 1"	| s d border aBitBlt | 	border:=Form extent: 32@32.	border fillBlack.	border fill: (1@1 extent: 30@30) fillColor: Color white.	s := Form extent: 32@32.	s fillWhite.	s fillBlack: (7@7 corner: 25@25).	d := Form extent: 32@32.	d fillWhite.	d fillBlack: (0@0 corner: 32@16).	s displayOn: Display at: originPoint.	border displayOn: Display at: originPoint rule: Form under.	d displayOn: Display at: originPoint + (s width @0).	border displayOn: Display at: originPoint + (s width @0) rule: Form under.	d displayOn: Display at: originPoint + (s extent // (2 @ 1)). 	aBitBlt := BitBlt		destForm: Display		sourceForm: s		fillColor: mask		combinationRule: rule		destOrigin: originPoint + (s extent // (2 @ 1))		sourceOrigin: 0 @ 0		extent: s extent		clipRect: Display computeBoundingBox.	aBitBlt copyBits.	border 		displayOn: Display at: originPoint + (s extent // (2 @ 1))		rule: Form under.	"BitBlt exampleAt: 100@100 rule: 0 fillColor: nil"  ! !!StrikeFont methodsFor: 'Mac reader' stamp: ''!xTableFromHex: file	| strike num str wid |	strike := file.	xTable := (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | 			num := Number readFrom: (str := strike next: 4) base: 16. 			xTable at: index put: num].	1 to: xTable size - 1 do: [:ind |		wid := (xTable at: ind+1) - (xTable at: ind).		(wid < 0) | (wid > 40) ifTrue: [			file close.			self error: 'illegal character width']].! !!HostFont methodsFor: 'accessing' stamp: 'yo 2/17/2004 16:23'!widthOfString: aString from: firstIndex to: lastIndex		^ (aString copyFrom: firstIndex to: lastIndex) inject: 0 into: [:s :t | s := s + (self widthOf: t)].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/10/2004 23:55'!processBackgroundChunk	| val red green blue max |	"Transcript show: '  BACKGROUND: ',chunk printString."	colorType = 3 ifTrue: [		backColor := palette at: chunk first + 1.		^self	].	max := (2 raisedTo: bitsPerChannel) - 1.	(colorType = 0 or: [colorType = 4]) ifTrue: [		val := chunk unsignedShortAt: 1 bigEndian: true.		backColor := Color gray: val / max.		^self	].	(colorType = 2 or: [colorType = 6]) ifTrue: [		red := chunk unsignedShortAt: 1 bigEndian: true.		green := chunk unsignedShortAt: 3 bigEndian: true.		blue := chunk unsignedShortAt: 5 bigEndian: true.		backColor := Color r: red/max g: green/max b: blue/max.		^self	]."self halt.""====The bKGD chunk specifies a default background color to present the image against. Note that viewers are not bound to honor this chunk; a viewer can choose to use a different background. For color type 3 (indexed color), the bKGD chunk contains:    Palette index:  1 byteThe value is the palette index of the color to be used as background. For color types 0 and 4 (grayscale, with or without alpha), bKGD contains:    Gray:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes are used regardless of the image bit depth.) The value is the gray level to be used as background. For color types 2 and 6 (truecolor, with or without alpha), bKGD contains:    Red:   2 bytes, range 0 .. (2^bitdepth)-1   Green: 2 bytes, range 0 .. (2^bitdepth)-1   Blue:  2 bytes, range 0 .. (2^bitdepth)-1(For consistency, 2 bytes per sample are used regardless of the image bit depth.) This is the RGB color to be used as background. When present, the bKGD chunk must precede the first IDAT chunk, and must follow the PLTE chunk, if any. ==="! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'JMM 1/11/2005 14:45'!nextPutImage: aForm quality: quality progressiveJPEG: progressiveFlag	"Encode the given Form on my stream with the given settings. Quality goes from 0 (low) to 100 (high), where -1 means default. If progressiveFlag is true, encode as a progressive JPEG."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm := (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct := ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	buffer := ByteArray new: sourceForm width * sourceForm height + 1024.	byteCount := self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: progressiveFlag		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	stream next: byteCount putAll: buffer startingAt: 1.	self close.! !!Point methodsFor: 'point functions' stamp: 'laza 12/13/1999 11:43'!octantOf: otherPoint 	"Return 1..8 indicating relative direction to otherPoint.  	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"	"[Sensor anyButtonPressed] whileFalse: [(Display boundingBox center 	octantOf: Sensor cursorPoint) printString displayAt: 0@0]"	| quad moreHoriz |	(x = otherPoint x and: [y > otherPoint y])		ifTrue: [^ 6].	"special case"	(y = otherPoint y and: [x < otherPoint x])		ifTrue: [^ 8].	quad := self quadrantOf: otherPoint.	moreHoriz := (x - otherPoint x) abs >= (y - otherPoint y) abs.	(quad even eqv: moreHoriz)		ifTrue: [^ quad * 2]		ifFalse: [^ quad * 2 - 1]! !!Cursor methodsFor: 'displaying' stamp: 'bf 10/13/1999 13:05'!showWhile: aBlock 	"While evaluating the argument, aBlock, make the receiver be the cursor 	shape."	| oldcursor |	oldcursor := Sensor currentCursor.	self show.	^aBlock ensure: [oldcursor show]! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!heightInBlocks: anInteger	heightInBlocks := anInteger! !!Form class methodsFor: 'examples' stamp: 'tk 7/4/2000 12:08'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors := Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade := Form extent: diam@diam offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball := Form dotOfSize: diam.	color := 8.	[ true ] whileTrue:		[port := BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue := OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter := Sensor cursorPoint.		colr := colors atWrap: (color := color + 5).  "choose increment relatively prime to colors size"		colr2 := colr alphaMixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter := filter * 4 + Sensor cursorPoint // 5.			point := Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q := queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!Form methodsFor: 'converting' stamp: 'ar 5/17/2001 15:39'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	self depth = 32 ifFalse: [		f32 := Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm := Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result := ColorForm extent: width@height depth: 8.	map := Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb := (BitBlt current toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map := Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt current toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays := (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 90.0]				ifFalse: [^ 270.0]]		ifFalse: 			[tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^ theta radiansToDegrees]						ifFalse: [^ 360.0 + theta radiansToDegrees]]				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !!BitBlt class methodsFor: 'examples' stamp: 'jrm 2/21/2001 23:43'!exampleTwo	"This is to test painting with a gray tone. It also tests that the seaming with gray patterns is correct in the microcode. Lets you paint for a while and then automatically stops. This only works at Depth of 1."	| f aBitBlt displayDepth |	"create a small black Form source as a brush. "	displayDepth := Display depth.	Display newDepth: 1.	f := Form extent: 20 @ 20.	f fillBlack.	"create a BitBlt which will OR gray into the display. "	aBitBlt := BitBlt		destForm: Display		sourceForm: f		fillColor: Color gray		combinationRule: Form over		destOrigin: Sensor cursorPoint		sourceOrigin: 0 @ 0		extent: f extent		clipRect: Display computeBoundingBox.	"paint the gray Form on the screen for a while. "	[Sensor anyButtonPressed] whileFalse: 		[aBitBlt destOrigin: Sensor cursorPoint.		aBitBlt copyBits].	Display newDepth: displayDepth.	"BitBlt exampleTwo"! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:21'!testTabletTracking	"A very simple example of drawing using the pen of a digitizing tablet such as a Wacom ArtZ tablet. This requires the optional tablet support primitives which may not be supported on all platforms. Compare the tracking speed of this example with that of testMouseTracking. On a Macintosh, the tablet primitives provide roughly 120 samples/second versus only 60 mouse samples/second, and the difference is noticable. Works best in full screen mode. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testTabletTracking"	| tabletScale pen p |	tabletScale := self tabletScaleFactor.	pen := Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p := (Sensor tabletPoint * tabletScale) rounded.		     Sensor tabletPressure > 0				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:32'!setFont	specialWidth := nil.	super setFont! !!StrikeFont methodsFor: 'Mac reader' stamp: ''!strikeFromHex: file width: w height: h	"read in just the raw strike bits from a hex file.  No spaces or returns.  W is in words (2 bytes), h in pixels." 	| newForm theBits offsetX offsetY str num cnt |	offsetX  := 0.	offsetY := 0.	offsetX > 32767 ifTrue: [offsetX := offsetX - 65536]. "stored two's-complement"	offsetY > 32767 ifTrue: [offsetY := offsetY - 65536]. "stored two's-complement"	newForm := Form extent: strikeLength @ h offset: offsetX @ offsetY.	theBits := newForm bits.	cnt := 0.		"raster may be 16 bits, but theBits width is 32" 	1 to: theBits size do: [:i | 		(cnt := cnt + 32) > strikeLength 		  ifTrue: [cnt := 0.			num := Number readFrom: (str := file next: 4) base: 16]		  ifFalse: [			cnt = strikeLength ifTrue: [cnt := 0].			num := Number readFrom: (str := file next: 8) base: 16].		theBits at: i put: num].	glyphs := newForm.! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:09'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix := pix size.	r := 0. g := 0. b := 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb := sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [self rgbMap: (pix at: i) from: 5 to: 8]].		r := r + ((rgb bitShift: -16) bitAnd: 16rFF).		g := g + ((rgb bitShift: -8) bitAnd: 16rFF).		b := b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor := 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor := 5].				destForm depth = 32 ifTrue: [bitsPerColor := 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor := 3].				destMap size = 4096 ifTrue: [bitsPerColor := 4].				destMap size = 32768 ifTrue: [bitsPerColor := 5]].	d := bitsPerColor - 8.	rgb := ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!StrikeFont class methodsFor: 'font creation' stamp: 'ar 6/4/2000 22:27'!fromHostFont: fontName size: fontSize flags: fontFlags weight: fontWeight	"		^StrikeFont fromHostFont: (StrikeFont hostFontFromUser)					size: 12 flags: 0 weight: 4.	"	| fontHandle glyphs xTable xStart maxWidth w glyphForm ascent descent fontHeight |	fontHandle := self primitiveCreateFont: fontName size: fontSize flags: fontFlags weight: fontWeight.	ascent := self primitiveFontAscent: fontHandle.	descent := self primitiveFontDescent: fontHandle.	fontHeight := ascent + descent.	xTable := Array new: 258.	xStart := maxWidth := 0.	0 to: 255 do:[:i|		xTable at: i+1 put: xStart.		w := self primitiveFont: fontHandle widthOfChar: i.		w > maxWidth ifTrue:[maxWidth := w].		xStart := xStart + w].	xTable at: 256 put: xStart.	xTable at: 257 put: xStart.	xTable at: 258 put: xStart.	glyphs := Form extent: xTable last @ fontHeight depth: 1.	glyphForm := Form extent: maxWidth @ fontHeight depth: 1.	0 to: 255 do:[:i|		glyphForm fillWhite.		self primitiveFont: fontHandle glyphOfChar: i into: glyphForm.		xStart := xTable at: i+1.		glyphForm displayOn: glyphs at: xStart@0.		glyphForm displayOn: Display at: xStart@0.	].	self primitiveDestroyFont: fontHandle.	^Array with: glyphs with: xTable! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nk 7/27/2004 17:18'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo := width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX * 3) + 1.		xx := startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: xx put: pixel.			i := i + 3.			xx := xx + incX.		]	] ifFalse: [		i := (startX // incX * 6) + 1.		xx := startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: xx put: pixel.			i := i + 6.			xx := xx + incX.		].	].	transparentPixelValue ifNotNil: [		startX to: width-1 by: incX do: [ :x |			(tempBits at: x+1) = transparentPixelValue ifTrue: [				tempBits at: x+1 put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jm 11/20/2001 10:01'!imageExtent: aByteArray 	"Answer the extent of the compressed image encoded in the given ByteArray."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	jpegDecompressStruct := ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	self		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w := self primImageWidth: jpegDecompressStruct.	h := self primImageHeight: jpegDecompressStruct.	^ w @ h! !!CornerRounder methodsFor: 'all' stamp: 'kfr 8/4/2003 23:28'!tweakCornersOf: aMorph on: aCanvas in: bounds borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits fourColors mask outBits shadowColor corners |	shadowColor := aCanvas shadowColor.	aCanvas shadowColor: nil. "for tweaking it's essential"	w > 0 ifTrue:[			fourColors := shadowColor 				ifNil:[aMorph borderStyle colorsAtCorners]				ifNotNil:[Array new: 4 withAll: Color transparent]].	mask := Form extent: cornerMasks first extent depth: aCanvas depth.	corners := bounds corners.	cornerList do:[:i|		corner := corners at: i.		saveBits := underBits at: i.		saveBits ifNotNil:[			i = 1 ifTrue: [offset := 0@0].			i = 2 ifTrue: [offset := 0@saveBits height negated].			i = 3 ifTrue: [offset := saveBits extent negated].			i = 4 ifTrue: [offset := saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits := aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:[								aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]].	aCanvas shadowColor: shadowColor. "restore shadow color"! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:30'!fromUser	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."	"Note: Since the color chart is cached, you may need to do 'ColorChart := nil' after changing the oldColorPaletteForDepth:extent: method."	"Color fromUser"	| d startPt save tr oldColor c here s |	d := Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart := self oldColorPaletteForDepth: d extent: (2 * 144)@80].	Sensor cursorPoint y < Display center y 		ifTrue: [startPt := 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt := 0@0].	save := Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr := ColorChart extent - (50@19) corner: ColorChart extent.	tr := tr translateBy: startPt.	oldColor := nil.	[Sensor anyButtonPressed] whileFalse: [		c := Display colorAt: (here := Sensor cursorPoint).		(tr containsPoint: here)			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]			ifTrue: [				c := Color transparent.				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].		c = oldColor ifFalse: [			Display fillWhite: (20@61 + startPt extent: 135@19).			c isTransparent				ifTrue: [s := 'transparent']				ifFalse: [s := c shortPrintString.						s := s copyFrom: 7 to: s size - 1].			s displayAt: 20@61 + startPt.			oldColor := c]].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!pixelAt: aPoint put: pixelValue	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPokerToForm:.  Overwrites the pixel at aPoint."	destX := aPoint x.	destY := aPoint y.	sourceForm unhibernate. "before poking"	sourceForm bits at: 1 put: pixelValue.	self copyBits"| bb |bb := (BitBlt bitPokerToForm: Display).[Sensor anyButtonPressed] whileFalse:	[bb pixelAt: Sensor cursorPoint put: 55]"! !!DisplayText methodsFor: 'displaying' stamp: 'yo 6/23/2003 20:05'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"For TT font, rule 34 is used if possible."	"Refer to the comment in 	DisplayObject|displayOn:at:clippingBox:rule:mask:."	| form1 rule |	form1 := self form.	rule := (ruleInteger = Form over and: [backColor isTransparent])				ifTrue: [form1 depth = 32 ifTrue: [rule := 34] ifFalse: [Form paint]]				ifFalse: [ruleInteger].	form1 depth = 32 ifTrue: [rule := 34].	form1		displayOn: aDisplayMedium		at: aDisplayPoint + offset		clippingBox: clipRectangle		rule: rule		fillColor: aForm! !!Point methodsFor: 'truncation and round off' stamp: ''!truncateTo: grid	"Answer a Point that is the receiver's x and y truncated to grid x and 	grid y."	| gridPoint |	gridPoint := grid asPoint.	^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !!Color methodsFor: 'private' stamp: ''!setRed: r green: g blue: b range: range	"Initialize this color's r, g, and b components to the given values in the range [0..r]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb :=		((((r * ComponentMask) // range) bitAnd: ComponentMask) bitShift: RedShift) +		((((g * ComponentMask) // range) bitAnd: ComponentMask) bitShift: GreenShift) +		 (((b * ComponentMask) // range) bitAnd: ComponentMask).	cachedDepth := nil.	cachedBitPattern := nil.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/7/2000 09:30'!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8 ifTrue: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x put: pixel.			i := i + 3.		]	] ifFalse: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x put: pixel.			i := i + 6.		]	].	transparentPixelValue ifNotNil: [		1 to: width do: [ :x |			(tempBits at: x) = transparentPixelValue ifTrue: [				tempBits at: x put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/4/2001 17:26'!setStream: aStream	"Feed it in from an existing source"	stream := JPEGReadStream on: aStream upToEnd.! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/13/96'!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color colorNames) returns a list of all color names.  "	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str := newName asString.	sym := str asSymbol.	cap := str capitalized.	csym := cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor := str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'named colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	(ColorNames includes: sym) ifFalse: [		ColorNames add: sym].	^ self classPool at: csym put: aColor! !!BitBlt methodsFor: 'private' stamp: 'ar 10/25/1998 17:30'!copyBitsFrom: x0 to: x1 at: y	destX := x0.	destY := y.	sourceX := x0.	width := (x1 - x0).	self copyBits.! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'yo 6/23/2003 19:58'!discardOtherSizes	"This method trys to discard the fonts in non-standard size.  If the size is still in use, there will be a problem."	| newArray |	self isTTCStyle ifFalse: [^ self].	newArray := fontArray select: [:s | TTCFont pointSizes includes: s pointSize].	self newFontArray: newArray."(TextConstants at: #ComicSansMS) discardOtherSizes"! !!StrikeFont methodsFor: 'accessing' stamp: 'tak 12/22/2004 01:25'!fallbackFont	^ fallbackFont		ifNil: [fallbackFont := FixedFaceFont new errorFont fontSize: self height]! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:14'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord := super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!BitBlt class methodsFor: 'examples' stamp: 'ar 5/4/2001 16:02'!exampleColorMap	"BitBlt exampleColorMap"	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."	| cc bb |	cc := ColorMap masks: {		1 << (Display depth-1). "mask out high bit of color component"		1 << (Display depth-1) - 1. "mask all other bits"		0.		0}		shifts: {			1 - Display depth. "shift right to bottom most position"			1. "shift all other pixels one bit left"			0.			0}.	bb := BitBlt toForm: Display.	bb 		sourceForm: Display;		combinationRule: 3;		colorMap: cc.	1 to: Display depth do:[:i|		bb copyBits.		Display forceDisplayUpdate.	].! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:21'!growHuffmanTable: table	| newTable |	newTable := table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!Pen methodsFor: 'geometric designs' stamp: ''!hilberts: n   "Display restoreAfter: [Display fillWhite.  Pen new hilberts: 5]"	"Draws n levels of nested Hilbert curves"	| s |	self up; turn: 90; go: 128; down.	1 to: n do: 		[:i | 		s := 256 bitShift: 0 - i.		self defaultNib: n - i * 2 + 1.		self color: i+1.		self up; go: 0 - s / 2; turn: -90; go: s / 2; turn: 90; down.		self hilbert: i side: s.		self go: s.		self hilbert: i side: s.		self go: s]! !!WarpBlt methodsFor: 'setup' stamp: 'jm 4/11/1999 12:00'!cellSize: s	cellSize := s.	cellSize = 1 ifTrue: [^ self].	colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth.! !!BitBlt methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor	"Set up the parameters.  Since the glyphs in a TTCFont is 32bit depth form, it tries to use rule=34 to get better AA result if possible."	((aTTCFont depth = 32)) ifTrue: [		destForm depth <= 8 ifTrue: [			self colorMap: (self cachedFontColormapFrom: aTTCFont depth to: destForm depth).			self combinationRule: Form paint.		] ifFalse: [			self colorMap: nil.			self combinationRule: 34.		].		halftoneForm := nil.		sourceY := 0.		height := aTTCFont height.	].! !!GIFReadWriter methodsFor: 'private-packing' stamp: ''!flushBuffer	bufStream isEmpty ifTrue: [^self].	self nextPut: bufStream size.	self nextPutAll: bufStream contents.	bufStream := WriteStream on: (ByteArray new: 256)! !!BMPReadWriter methodsFor: 'writing' stamp: 'yo 2/18/2004 17:57'!nextPutImage: aForm	| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen |	depth := aForm depth.	[#(1 4 8 32) includes: depth] whileFalse:[depth := depth + 1 asLargerPowerOfTwo].	image := aForm asFormOfDepth: depth.	image unhibernate.	bhSize := 14.  "# bytes in file header"	biSize := 40.  "info header size in bytes"	biWidth := image width.	biHeight := image height.	biClrUsed := depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits := biSize + bhSize + (4*biClrUsed).	rowBytes := ((depth min: 24) * biWidth + 31 // 32) * 4.	biSizeImage := biHeight * rowBytes.	"Write the file header"	stream position: 0.	stream nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	stream nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	stream nextLittleEndianNumber: 4 put: 0.  "bfReserved"	stream nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	stream position: bhSize.	stream nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	stream nextLittleEndianNumber: 4 put: image width.  "biWidth"	stream nextLittleEndianNumber: 4 put: image height.  "biHeight"	stream nextLittleEndianNumber: 2 put: 1.  "biPlanes"	stream nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	stream nextLittleEndianNumber: 4 put: 0.  "biCompression"	stream nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	stream nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	stream nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	stream nextLittleEndianNumber: 4 put: biClrUsed.	stream nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues := image colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb := colorValues at: i.			0 to: 24 by: 8 do: [:j | stream nextPut: (rgb >> j bitAnd: 16rFF)]]].	depth < 32 ifTrue: [		"depth = 1, 4 or 8."		data := image bits asByteArray.		ppw := 32 // depth.		scanLineLen := biWidth + ppw - 1 // ppw * 4.  "# of bytes in line"		1 to: biHeight do: [:i |			stream next: scanLineLen putAll: data startingAt: (biHeight-i)*scanLineLen+1.		].	] ifFalse: [		1 to: biHeight do:[:i |			data := (image copy: (0@(biHeight-i) extent: biWidth@1)) bits.			1 to: data size do: [:j | stream nextLittleEndianNumber: 3 put: (data at: j)].			1 to: (data size*3)+3//4*4-(data size*3) do: [:j | stream nextPut: 0 "pad to 32-bits"]		].	].	stream position = (bfOffBits + biSizeImage) ifFalse: [self error:'Write failure'].	stream close.! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm := Form extent: self extent.  destForm fillBlack.	tempForm := Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!BitBlt methodsFor: 'accessing' stamp: ''!width: anInteger 	"Set the receiver's destination form width to be the argument, anInteger."	width := anInteger! !!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!initialize	Lookahead := 8.	BitBufferSize := 16! !!BitBlt methodsFor: 'private' stamp: ''!paintBits	"Perform the paint operation, which requires two calls to BitBlt."	| color oldMap saveRule |	sourceForm depth = 1 ifFalse: 		[^ self halt: 'paint operation is only defined for 1-bit deep sourceForms'].	saveRule := combinationRule.	color := halftoneForm.  halftoneForm := nil.	oldMap := colorMap.	"Map 1's to ALL ones, not just one"	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule := Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm := color.	combinationRule := Form under.	self copyBits.	"then OR, with whatever color, into the hole"	colorMap := oldMap.	combinationRule := saveRule" | dot |dot := Form dotOfSize: 32.((BitBlt destForm: Display		sourceForm: dot		fillColor: Color lightGray		combinationRule: Form paint		destOrigin: Sensor cursorPoint		sourceOrigin: 0@0		extent: dot extent		clipRect: Display boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)) copyBits"! !!HostFont class methodsFor: 'accessing' stamp: 'rbb 2/18/2005 13:23'!fontNameFromUser	"HostFont fontNameFromUser"	| fontNames index labels |	fontNames := self listFontNames asSortedCollection.	labels := WriteStream on: (String new: 100).	fontNames do:[:fn| labels nextPutAll: fn] separatedBy:[labels cr].	index := (UIManager default chooseFrom: (labels contents substrings) title: 'Choose your font').	index = 0 ifTrue:[^nil].	^fontNames at: index! !!BitBlt methodsFor: 'accessing' stamp: ''!height: anInteger 	"Set the receiver's destination form height to be the argument, anInteger."	height := anInteger! !!Point methodsFor: 'geometry' stamp: 'ar 4/6/2000 18:37'!to: end1 intersects: start2 to: end2 	"Returns true if the linesegment from start1 (=self) to end1 intersects      	    with the segment from start2 to end2, otherwise false."	| start1 sideStart sideEnd |	start1 := self.	(((start1 = start2 or: [end1 = end2])		or: [start1 = end2])		or: [start2 = end1])		ifTrue: [^ true].	sideStart := start1 to: end1 sideOf: start2.	sideEnd := start1 to: end1 sideOf: end2.	sideStart = sideEnd ifTrue: [^ false].	sideStart := start2 to: end2 sideOf: start1.	sideEnd := start2 to: end2 sideOf: end1.	sideStart = sideEnd ifTrue: [^ false].	^ true! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits := ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte := bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits := nil.  "Let GC reclaim the old bits before the copy if necessary"		bits := compactBits copyFrom: 1 to: lastByte]! !!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!hotColdShades: thisMany	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "	"Color showColors: (Color hotColdShades: 25)"	| n s1 s2 s3 s4 s5 |	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].	n := thisMany // 5.	s1 := self white mix: self yellow shades: (thisMany - (n*4)).	s2 := self yellow mix: self red shades: n+1.	s2 := s2 copyFrom: 2 to: n+1.	s3 := self red mix: self green darker shades: n+1.	s3 := s3 copyFrom: 2 to: n+1.	s4 := self green darker mix: self blue shades: n+1.	s4 := s4 copyFrom: 2 to: n+1.	s5 := self blue mix: self black shades: n+1.	s5 := s5 copyFrom: 2 to: n+1.	^ s1, s2, s3, s4, s5! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:21'!writeBitData: bits	"using modified Lempel-Ziv Welch algorithm."	| maxBits maxMaxCode tSize initCodeSize ent tShift fCode pixel index disp nomatch |	pass := 0.	xpos := 0.	ypos := 0.	rowByteSize := width * 8 + 31 // 32 * 4.	remainBitCount := 0.	bufByte := 0.	bufStream := WriteStream on: (ByteArray new: 256).	maxBits := 12.	maxMaxCode := 1 bitShift: maxBits.	tSize := 5003.	prefixTable := Array new: tSize.	suffixTable := Array new: tSize.	initCodeSize := bitsPerPixel <= 1 ifTrue: [2] ifFalse: [bitsPerPixel].	self nextPut: initCodeSize.	self setParameters: initCodeSize.	tShift := 0.	fCode := tSize.	[fCode < 65536] whileTrue:		[tShift := tShift + 1.		fCode := fCode * 2].	tShift := 8 - tShift.	1 to: tSize do: [:i | suffixTable at: i put: -1].	self writeCodeAndCheckCodeSize: clearCode.	ent := self readPixelFrom: bits.	[(pixel := self readPixelFrom: bits) == nil] whileFalse:		[		fCode := (pixel bitShift: maxBits) + ent.		index := ((pixel bitShift: tShift) bitXor: ent) + 1.		(suffixTable at: index) = fCode			ifTrue: [ent := prefixTable at: index]			ifFalse:				[nomatch := true.				(suffixTable at: index) >= 0					ifTrue:						[disp := tSize - index + 1.						index = 1 ifTrue: [disp := 1].						"probe"						[(index := index - disp) < 1 ifTrue: [index := index + tSize].						(suffixTable at: index) = fCode							ifTrue:								[ent := prefixTable at: index.								nomatch := false.								"continue whileFalse:"].						nomatch and: [(suffixTable at: index) > 0]]							whileTrue: ["probe"]].				"nomatch"				nomatch ifTrue:					[self writeCodeAndCheckCodeSize: ent.					ent := pixel.					freeCode < maxMaxCode						ifTrue:							[prefixTable at: index put: freeCode.							suffixTable at: index put: fCode.							freeCode := freeCode + 1]						ifFalse:							[self writeCodeAndCheckCodeSize: clearCode.							1 to: tSize do: [:i | suffixTable at: i put: -1].							self setParameters: initCodeSize]]]].	prefixTable := suffixTable := nil.	self writeCodeAndCheckCodeSize: ent.	self writeCodeAndCheckCodeSize: eoiCode.	self flushCode.	self nextPut: 0.	"zero-length packet"! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor := CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor := (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX := textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex := lastIndex + 1.	^false! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 12/28/2002 21:02'!readEFontBDFFromFile: fileName name: aString rangeFrom: startRange to: endRange	| fontReader stream |	fontReader := EFontBDFFontReader readOnlyFileNamed: fileName.	stream := ReadStream on: (fontReader readFrom: startRange to: endRange).	xTable := stream next.	glyphs := stream next.	minAscii := stream next.	maxAscii := stream next.	maxWidth := stream next.	ascent := stream next.	descent := stream next.	pointSize := stream next.	name := aString.	type := 0. "no one see this"	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	self reset.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!parseStartOfFile	| length markerStart value n |	markerStart := self position.	length := self nextWord.	dataPrecision := self next.	dataPrecision = 8		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].	height := self nextWord.	width := self nextWord.	n := self next.	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].	(length - (self position - markerStart)) ~= (n * 3)		ifTrue: [self error: 'component length is incorrect'].	components := Array new: n.	1 to: components size do:		[:i |		components			at: i			put:				(JPEGColorComponent new					id: self next;					"heightInBlocks: (((value := self next) >> 4) bitAnd: 16r0F);					widthInBlocks: (value bitAnd: 16r0F);"					widthInBlocks: (((value := self next) >> 4) bitAnd: 16r0F);					heightInBlocks: (value bitAnd: 16r0F);					qTableIndex: self next + 1)]! !!Rectangle methodsFor: 'private' stamp: ''!setOrigin: topLeft corner: bottomRight	origin := topLeft.	corner := bottomRight! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 3/7/2001 00:18'!decompressionTest	"Test decompression; don't generate actual image"	| xStep yStep x y |MessageTally spyOn:[	ditherMask := DitherMasks at: 32.	residuals := WordArray new: 3.	sosSeen := false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	xStep := mcuWidth * DCTSize.	yStep := mcuHeight * DCTSize.	y := 0.	1 to: mcuRowsInScan do:		[:row |		x := 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			x := x + xStep].		y := y + yStep].].! !!Form class methodsFor: 'examples' stamp: ''!exampleBorder    "Form exampleBorder"	"This example demonstrates the border finding algorithm. Start	by having the user sketch on the screen (end with option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of the region to be	outlined, and the region begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	Cursor crossHair showWhile:		[interiorPoint := Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeBorder: Color blue width: 2 interiorPoint: interiorPoint			sharpCorners: false internal: false].	f displayOn: Display at: r origin	! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:02'!defaultNib: widthInteger 	"Nib is the tip of a pen. This sets up the pen, with a nib of width widthInteger. You can also set the shape of the pen nib using:		roundNib: widthInteger, or		squareNib: widthInteger, or		sourceForm: aForm""Example:	| bic |	bic := Pen new sourceForm: Cursor normal.	bic combinationRule: Form paint; turn: 90.	10 timesRepeat: [bic down; go: 3; up; go: 10]."	self color: Color black.	self squareNib: widthInteger.! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:02'!initCrossHair	CrossHairCursor :=   		(Cursor			extent: 16@16			fromArray: #(		2r0000000000000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0111111111111100		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000000000000		2r0)			offset: -7@-7).		! !!PCXReadWriter methodsFor: 'accessing' stamp: 'tao 10/6/97 10:11'!nextImage	"Read in the next PCX image from the stream."	| bytes form |	self readHeader.	bytes := self readBody.	colorPalette := self readPalette.	self close.	form := ColorForm extent: width@height depth: bitsPerPixel.	(Form new hackBits: bytes) displayOn: (Form new hackBits: form bits).	form colors: colorPalette.	^ form! !!Bitmap methodsFor: 'filing' stamp: 'ar 2/3/2001 16:11'!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	i := index.  "byteArray read index"	end := ba size.	k := 1.  "bitmap write index"	pastEnd := bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt := ba at: i.  i := i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]				ifFalse: [anInt := 0.						1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].		n := anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code := anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data := ba at: i.  i := i+1.						data := data bitOr: (data bitShift: 8).						data := data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data := 0.						1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data := 0.							1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].							bm at: k put: data.  k := k+1]]]! !!Pen methodsFor: 'operations' stamp: 'sw 10/5/2002 02:11'!arrowHeadFrom: prevPt to: newPt forPlayer: aPlayer	"Put an arrowhead on the pen stroke from oldPt to newPt"		| aSpec |	(aPlayer notNil and: [(aSpec := aPlayer costume renderedMorph valueOfProperty: #arrowSpec) notNil]) 		ifFalse:			[aSpec := Preferences parameterAt: #arrowSpec "may well be nil"].	self arrowHeadFrom: prevPt to: newPt arrowSpec: aSpec! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 11/30/2003 17:08'!readEFontBDFForJapaneseFromFile: fileName name: aString overrideWith: otherFileName	| fontReader stream |	fontReader := EFontBDFFontReaderForRanges readOnlyFileNamed: fileName.	stream := ReadStream on: (fontReader readRanges: fontReader rangesForJapanese overrideWith: otherFileName otherRanges: {Array with: 8481 with: 12320} additionalOverrideRange: fontReader additionalRangesForJapanese).	xTable := stream next.	glyphs := stream next.	minAscii := stream next.	maxAscii := stream next.	maxWidth := stream next.	ascent := stream next.	descent := stream next.	pointSize := stream next.	name := aString.	type := 0. "no one see this"	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	self reset.! !!Form methodsFor: 'bordering' stamp: 'ar 5/28/2000 12:07'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a border whose rectangular area is defined by rect. Thewidth of the border of each side is borderWidth. Uses fillColor for drawingthe border."        | blt |        blt := (BitBlt current toForm: self) combinationRule: rule; fillColor: fillColor.        blt sourceOrigin: 0@0.        blt destOrigin: rect origin.        blt width: rect width; height: borderWidth; copyBits.        blt destY: rect corner y - borderWidth; copyBits.        blt destY: rect origin y + borderWidth.        blt height: rect height - borderWidth - borderWidth; width:borderWidth; copyBits.        blt destX: rect corner x - borderWidth; copyBits! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/7/2001 00:58'!idctMCU	| comp fp ci |	fp := self useFloatingPoint.	1 to: mcuMembership size do:[:i|		ci := mcuMembership at: i.		comp := currentComponents at: ci.		fp ifTrue:[			self idctBlockFloat: (mcuSampleBuffer at: i) component: comp.		] ifFalse:[			self primIdctInt: (mcuSampleBuffer at: i)				qt: (qTable at: comp qTableIndex)]].! !!StrikeFont methodsFor: 'displaying' stamp: 'tak 1/11/2005 18:03'!widthOfString: aString from: firstIndex to: lastIndex	| resultX |	resultX := 0.	firstIndex to: lastIndex do:[:i | 		resultX := resultX + (self widthOf: (aString at: i))].	^ resultX.! !!BitBlt methodsFor: 'private' stamp: 'ar 3/8/2003 00:34'!clipRange	"clip and adjust source origin and extent appropriately"	"first in x"	| sx sy dx dy bbW bbH |	"fill in the lazy state if needed"	destX ifNil:[destX := 0].	destY ifNil:[destY := 0].	width ifNil:[width := destForm width].	height ifNil:[height := destForm height].	sourceX ifNil:[sourceX := 0].	sourceY ifNil:[sourceY := 0].	clipX ifNil:[clipX := 0].	clipY ifNil:[clipY := 0].	clipWidth ifNil:[clipWidth := destForm width].	clipHeight ifNil:[clipHeight := destForm height].	destX >= clipX		ifTrue: [sx := sourceX.				dx := destX.				bbW := width]		ifFalse: [sx := sourceX + (clipX - destX).				bbW := width - (clipX - destX).				dx := clipX].	(dx + bbW) > (clipX + clipWidth)		ifTrue: [bbW := bbW - ((dx + bbW) - (clipX + clipWidth))].	"then in y"	destY >= clipY		ifTrue: [sy := sourceY.				dy := destY.				bbH := height]		ifFalse: [sy := sourceY + clipY - destY.				bbH := height - (clipY - destY).				dy := clipY].	(dy + bbH) > (clipY + clipHeight)		ifTrue: [bbH := bbH - ((dy + bbH) - (clipY + clipHeight))].	sourceForm ifNotNil:[		sx < 0			ifTrue: [dx := dx - sx.					bbW := bbW + sx.					sx := 0].		sx + bbW > sourceForm width			ifTrue: [bbW := bbW - (sx + bbW - sourceForm width)].		sy < 0			ifTrue: [dy := dy - sy.					bbH := bbH + sy.					sy := 0].		sy + bbH > sourceForm height			ifTrue: [bbH := bbH - (sy + bbH - sourceForm height)].	].	(bbW <= 0 or:[bbH <= 0]) ifTrue:[		sourceX := sourceY := destX := destY := clipX := clipY := width := height := 0.		^true].	(sx = sourceX 		and:[sy = sourceY 		and:[dx = destX 		and:[dy = destY 		and:[bbW = width 		and:[bbH = height]]]]]) ifTrue:[^false].	sourceX := sx.	sourceY := sy.	destX := dx.	destY := dy.	width := bbW.	height := bbH.	^true! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:44'!resetBitBuffer	bitBuffer := 0.	bitsInBuffer := 0.! !!DisplayObject class methodsFor: 'fileIn/Out' stamp: ''!writeCollection: coll onFileNamed: fileName 	"Saves a collection of Forms on the file fileName in the format:		fileCode, {depth, extent, offset, bits}."	| file |	file := FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	coll do: [:f | f writeOn: file].	file close" | f c | c := OrderedCollection new.[(f := Form fromUser) boundingBox area>25] whileTrue: [c add: f].Form writeCollection: c onFileNamed: 'test.forms'.c := Form collectionFromFileNamed: 'test.forms'.1 to: c size do: [:i | (c at: i) displayAt: 0@(i*100)]."! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap: aBitmap	"Install the map used for tallying pixels"	colorMap := aBitmap! !!Color methodsFor: 'printing' stamp: ''!shortPrintString	"Return a short (but less precise) print string for use where space is tight."	| s |	s := WriteStream on: ''.	s		nextPutAll: '(' , self class name;		nextPutAll: ' r: ';		nextPutAll: (self red roundTo: 0.01) printString;		nextPutAll: ' g: ';		nextPutAll: (self green roundTo: 0.01) printString;		nextPutAll: ' b: ';		nextPutAll: (self blue roundTo: 0.01) printString;		nextPutAll: ')'.	^ s contents! !!Bitmap methodsFor: 'accessing' stamp: ''!byteAt: byteAddress	"Extract a byte from a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:.  See Form pixelAt:  7/1/96 tk"	| lowBits |	lowBits := byteAddress - 1 bitAnd: 3.	^((self at: byteAddress - 1 - lowBits // 4 + 1)		bitShift: (lowBits - 3) * 8)		bitAnd: 16rFF! !!StrikeFont methodsFor: 'character shapes' stamp: 'btr 11/18/2002 15:00'!edit: character 	"Open a Bit Editor on the given character. Note that you must do an accept 	(in the option menu of the bit editor) if you want this work. 	Accepted edits will not take effect in the font until you leave or close the bit editor. 	Also note that unaccepted edits will be lost when you leave or close."	"Note that BitEditor only works in MVC currently."	"(TextStyle default fontAt: 1) edit: $:="	| charForm editRect scaleFactor bitEditor savedForm r |	charForm := self characterFormAt: character.	editRect := BitEditor locateMagnifiedView: charForm scale: (scaleFactor := 8 @ 8).	bitEditor := BitEditor				bitEdit: charForm				at: editRect topLeft				scale: scaleFactor				remoteView: nil.	savedForm := Form fromDisplay: (r := bitEditor displayBox							expandBy: (0 @ 23 corner: 0 @ 0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !!CompositeTransform methodsFor: 'initialization' stamp: 'di 3/4/98 19:17'!globalTransform: gt localTransform: lt	globalTransform := gt.	localTransform := lt! !!BitBlt methodsFor: 'private' stamp: ''!eraseBits	"Perform the erase operation, which puts 0's in the destination	wherever the source (which is assumed to be just 1 bit deep)	has a 1.  This requires the colorMap to be set in order to AND	all 1's into the destFrom pixels regardless of their size."	| oldMask oldMap |	oldMask := halftoneForm.	halftoneForm := nil.	oldMap := colorMap.	self colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).	combinationRule := Form erase.	self copyBits. 		"Erase the dest wherever the source is 1"	halftoneForm := oldMask.	"already converted to a Bitmap"	colorMap := oldMap! !!Color class methodsFor: 'examples' stamp: ''!showHSVPalettes	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."	"Color showHSVPalettes"	| left top c |	left := top := 0.	0 to: 179 by: 15 do: [:h |		0 to: 10 do: [:s |			left := (h * 4) + (s * 4).			0 to: 10 do: [:v |				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.				top := (v * 4).				Display fill: (left@top extent: 4@4) fillColor: c.				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.				top := (v * 4) + 50.				Display fill: (left@top extent: 4@4) fillColor: c]]].! !!FormSetFont methodsFor: 'as yet unclassified' stamp: 'ar 5/23/2000 12:49'!fromFormArray: formArray asciiStart: asciiStart ascent: ascentVal	| height width x badChar |	type := 2.	name := 'aFormFont'.	minAscii := asciiStart.	maxAscii := minAscii + formArray size - 1.	ascent := ascentVal.	subscript := superscript := emphasis := 0.	height := width := 0.	maxWidth := 0.	formArray do:		[:f | width := width + f width.		maxWidth := maxWidth max: f width.		height := height max: f height + f offset y].	badChar := (Form extent: 7@height) borderWidth: 1.	width := width + badChar width.	descent := height - ascent.	pointSize := height.	glyphs := Form extent: width @ height depth: formArray first depth.	xTable := Array new: maxAscii + 3 withAll: 0.	x := 0.	formArray doWithIndex:		[:f :i | f displayOn: glyphs at: x@0.		xTable at: minAscii + i+1 put: (x := x + f width)].	badChar displayOn: glyphs at: x@0.	xTable at: maxAscii + 3 put: x + badChar width.	characterToGlyphMap := nil.! !!Bitmap methodsFor: 'filing' stamp: 'RAA 7/28/2000 08:40'!compressGZip	| ba hackwa hackba blt rowsAtATime sourceOrigin rowsRemaining bufferStream gZipStream |"just hacking around to see if further compression would help Nebraska"	bufferStream := RWBinaryOrTextStream on: (ByteArray new: 5000).	gZipStream := GZipWriteStream on: bufferStream.	ba := nil.	rowsAtATime := 20000.		"or 80000 bytes"	hackwa := Form new hackBits: self.	sourceOrigin := 0@0.	[(rowsRemaining := hackwa height - sourceOrigin y) > 0] whileTrue: [		rowsAtATime := rowsAtATime min: rowsRemaining.		(ba isNil or: [ba size ~= (rowsAtATime * 4)]) ifTrue: [			ba := ByteArray new: rowsAtATime * 4.			hackba := Form new hackBits: ba.			blt := (BitBlt toForm: hackba) sourceForm: hackwa.		].		blt 			combinationRule: Form over;			sourceOrigin: sourceOrigin;			destX: 0 destY: 0 width: 4 height: rowsAtATime;			copyBits.		"bufferStream nextPutAll: ba."		sourceOrigin := sourceOrigin x @ (sourceOrigin y + rowsAtATime).	].	gZipStream close.	^bufferStream contents! !!Form class methodsFor: 'examples' stamp: ''!xorHack: size  "Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect := 5@5 extent: size@size.	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	Display border: (rect topRight - (0@2) extent: rect extent*2 + 4) width: 2.	Form exampleSketch.	form := Form fromDisplay: rect.	bb := form boundingBox.	i := 0.	[Sensor yellowButtonPressed] whileFalse:		[[Sensor redButtonPressed] whileTrue:			[i := i + 1.			(Array with: 0@1 with: 0@-1 with: 1@0 with: -1@0) do:				[:d | form copyBits: bb from: form at: d					clippingBox: bb rule: Form reverse fillColor: nil].			form displayAt: rect topLeft.			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).		Sensor waitButton].! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 4/19/2001 05:44'!addExtraRegion: aRectangle for: regionDrawer	"Register the given rectangle as a region which is drawn by the specified region drawer. The region will be excluded from any updates when #forceDamageToScreen: is called. Note that the rectangle is only valid for a single update cycle; once #forceDamageToScreen: has been called, the region drawer and its region are being removed from the list"	extraRegions ifNil:[extraRegions := #()].	extraRegions := extraRegions copyWith: (Array with: regionDrawer with: aRectangle).! !!Color methodsFor: 'private' stamp: ''!setRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb :=		(((r * ComponentMax) rounded bitAnd: ComponentMask) bitShift: RedShift) +		(((g * ComponentMax) rounded bitAnd: ComponentMask) bitShift: GreenShift) +		 ((b * ComponentMax) rounded bitAnd: ComponentMask).	cachedDepth := nil.	cachedBitPattern := nil.! !!Quadrangle methodsFor: 'private' stamp: ''!setRegion: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	origin := aRectangle origin.	corner := aRectangle corner.	borderWidth := anInteger.	borderColor := aMask1.	insideColor := aMask2! !!Cursor class methodsFor: 'class initialization' stamp: 'jrp 8/6/2005 22:55'!initResizeTopLeft       ResizeTopLeftCursor :=               (Cursor extent: 16@16 fromArray: #(               2r0000000000000000               2r0111110000000000               2r0111100000000000               2r0111000000000000               2r0110100000000000               2r0100010000000000               2r0000001000000000               2r0000000100000000               2r0000000010000000               2r0000000001000100               2r0000000000101100               2r0000000000011100               2r0000000000111100               2r0000000001111100               2r0000000000000000               2r0000000000000000)       offset: -7@-7) withMask! !!TextStyle methodsFor: 'accessing' stamp: ''!lineGrid: anInteger 	"Set the relative space between lines of a paragraph in the style of the 	receiver to be the argument, anInteger."	lineGrid := anInteger! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'tk9/13/97 16:13'!putForm: aForm onStream: aWriteStream	"Store the given form on a file of the given name."	| writer |	writer := self on: aWriteStream.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !!Color methodsFor: 'conversions' stamp: 'di 6/23/97 23:27'!halfTonePattern1	"Return a halftone-pattern to approximate luminance levels on 1-bit deep Forms."	| lum |	lum := self luminance.	lum < 0.1 ifTrue: [^ Bitmap with: 16rFFFFFFFF]. "black"	lum < 0.4 ifTrue: [^ Bitmap with: 16rBBBBBBBB with: 16rEEEEEEEE]. "dark gray"	lum < 0.6 ifTrue: [^ Bitmap with: 16r55555555 with: 16rAAAAAAAA]. "medium gray"	lum < 0.9 ifTrue: [^ Bitmap with: 16r44444444 with: 16r11111111]. "light gray"	^ Bitmap with: 0  "1-bit white"! !!DisplayScreen methodsFor: 'other' stamp: 'hmm 2/2/2001 10:14'!deferUpdatesIn: aRectangle while: aBlock	| result |	(self deferUpdates: true) ifTrue: [^aBlock value].	result := aBlock value.	self deferUpdates: false.	self forceToScreen: aRectangle.	^result! !!CharacterScanner methodsFor: 'scanner methods' stamp: 'yo 12/27/2002 04:33'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		maxAscii := font maxAsciiFor: startEncoding.		f := font fontArray at: startEncoding + 1.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		"destX printString displayAt: 0@(lastIndex*20)."		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!CornerRounder methodsFor: 'all' stamp: 'di 6/24/1999 09:35'!masterMask: maskForm masterOverlay: overlayForm	cornerMasks := #(none left pi right) collect:		[:dir | (maskForm rotateBy: dir centerAt: 0@0) offset: 0@0].	cornerOverlays := #(none left pi right) collect:		[:dir | (overlayForm rotateBy: dir centerAt: 0@0) offset: 0@0].! !!Pen class methodsFor: 'instance creation' stamp: ''!newOnForm: aForm	| pen |	pen := super new.	pen setDestForm: aForm.	pen sourceOrigin: 0@0.	pen home.	pen defaultNib: 1.	pen north.	pen down.	^ pen! !!Color methodsFor: 'private' stamp: ''!setHue: hue saturation: saturation brightness: brightness	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."	| s v hf i f p q t | 	s := (saturation asFloat max: 0.0) min: 1.0.	v := (brightness asFloat max: 0.0) min: 1.0.	"zero saturation yields gray with the given brightness"	s = 0.0 ifTrue: [ ^ self setRed: v green: v blue: v ].	hf := hue asFloat.	(hf < 0.0 or: [hf >= 360.0])		ifTrue: [hf := hf - ((hf quo: 360.0) asFloat * 360.0)].	hf := hf / 60.0.	i := hf asInteger.  "integer part of hue"	f := hf fractionPart.         "fractional part of hue"	p := (1.0 - s) * v.	q := (1.0 - (s * f)) * v.	t := (1.0 - (s * (1.0 - f))) * v.	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].	self error: 'implementation error'.! !!Cursor class methodsFor: 'class initialization' stamp: 'jrp 8/6/2005 22:50'!initResizeLeft       ResizeLeftCursor :=               (Cursor extent: 16@16 fromArray: #(               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000100000010000               2r0001100000011000               2r0011100000011100               2r0111111111111110               2r0011100000011100               2r0001100000011000               2r0000100000010000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000 )       offset: -7@-7 ) withMask! !!CharacterBlock methodsFor: 'private' stamp: ''!moveBy: aPoint 	"Change the corner positions of the receiver so that its area translates by 	the amount defined by the argument, aPoint."	origin := origin + aPoint.	corner := corner + aPoint! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 11/12/2000 19:10'!intersect: aRectangle 	"Answer a Rectangle that is the area in which the receiver overlaps with 	aRectangle. Optimized for speed; old code read:		^Rectangle 			origin: (origin max: aRectangle origin)			corner: (corner min: aRectangle corner)	"	| aPoint left right top bottom |	aPoint := aRectangle origin.	aPoint x > origin x ifTrue:[left := aPoint x] ifFalse:[left := origin x].	aPoint y > origin y ifTrue:[top := aPoint y] ifFalse:[top := origin y].	aPoint := aRectangle corner.	aPoint x < corner x ifTrue:[right := aPoint x] ifFalse:[right := corner x].	aPoint y < corner y ifTrue:[bottom := aPoint y] ifFalse:[bottom := corner y].	^Rectangle		origin: (left@top)		corner: (right@bottom)! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode := emphasisCode bitOr: code! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!scaleQuantizationTable: table	| index |	index := 1.	1 to: DCTSize do:		[:row |		1 to: DCTSize do:			[:col |			table at: index				put: ((table at: index) * (QTableScaleFactor at: row) *					(QTableScaleFactor at: col)) rounded.			index := index + 1]].	^ table! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 5/2/1999 07:09'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	sourceForm := srcForm.	sourceX := sourceY := 0.	destX := dstRectangle left.	destY := dstRectangle top.	width := dstRectangle width.	height := dstRectangle height.	w := 16384 * (srcForm width - 1).	h := 16384 * (srcForm height - 1).	p1x := 0.	p2x := 0.	p3x := w.	p4x := w.	p1y := 0.	p2y := h.	p3y := h.	p4y := 0.	p1z := p2z := p3z := p4z := 16384.  "z-warp ignored for now"! !!JPEGReadStream methodsFor: 'huffman trees' stamp: 'ar 3/4/2001 18:44'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded := (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex := 2.							"First real table"	[bits := self getBits: bitsNeeded.			"Get bits"	value := table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex := value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded := (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:45'!readIndexedBmpFile: colors	"Read uncompressed pixel data of depth d from the given BMP stream, where d is 1, 4, 8, or 16"	| form bytesPerRow pixelData pixelLine startIndex map bitBlt mask |	colors 		ifNil:[form := Form extent: biWidth@biHeight depth: biBitCount]		ifNotNil:[form := ColorForm extent: biWidth@biHeight depth: biBitCount.				form colors: colors].	bytesPerRow := (((biBitCount* biWidth) + 31) // 32) * 4.	pixelData := ByteArray new: bytesPerRow * biHeight.	biHeight to: 1 by: -1 do: [:y |		pixelLine := stream next: bytesPerRow.		startIndex := ((y - 1) * bytesPerRow) + 1.		pixelData 			replaceFrom: startIndex 			to: startIndex + bytesPerRow - 1 			with: pixelLine 			startingAt: 1].	form bits copyFromByteArray: pixelData.	biBitCount = 16 ifTrue:[		map := ColorMap shifts: #(8 -8 0 0) masks: #(16rFF 16rFF00 0 0).		mask := 16r80008000.	].	biBitCount = 32 ifTrue:[		map := ColorMap shifts: #(24 8 -8 -24) masks: #(16rFF 16rFF00 16rFF0000 16rFF000000).		mask := 16rFF000000.	].	map ifNotNil:[		bitBlt := BitBlt toForm: form.		bitBlt sourceForm: form.		bitBlt colorMap: map.		bitBlt combinationRule: Form over.		bitBlt copyBits.	].	mask ifNotNil:[		bitBlt := BitBlt toForm: form.		bitBlt combinationRule: 7 "bitOr:with:".		bitBlt halftoneForm: (Bitmap with: mask).		bitBlt copyBits.	].	^ form! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:23'!copyPixelsIndexed: y at: startX by: incX	"Handle interlaced indexed color mode (colorType = 3)"	| offset b bits w pixel mask pixPerByte shifts blitter pixelNumber rawByte |	offset := y*rowSize+1.	bits := form bits.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				w := offset + (x>>2).				b := 3 - (x \\ 4) * 8.				pixel := (thisScanline at: x // incX + 1)<<b.				mask := (255<<b) bitInvert32.				bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)].			^ self ].	bitsPerChannel = 1 ifTrue: [		pixPerByte := 8.		mask := 1.		shifts := #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte := 4.		mask := 3.		shifts := #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte := 2.		mask := 15.		shifts := #(4 0).	].	blitter := BitBlt current bitPokerToForm: form.	pixelNumber := 0.	startX to: width-1 by: incX do: [ :x |		rawByte := thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel := (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber := pixelNumber + 1.	].! !!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| halfword |	depth = 32 ifTrue: [^ pixelValue].	depth = 16		ifTrue: [halfword := pixelValue]		ifFalse: [halfword := pixelValue * 					(#(16rFFFF				"replicates at every bit"						16r5555 -			"replicates every 2 bits"						16r1111 - - -			"replicates every 4 bits"						16r0101) at: depth)	"replicates every 8 bits"].	^ halfword bitOr: (halfword bitShift: 16)! !!TextStyle methodsFor: 'accessing' stamp: ''!baseline: anInteger 	"Set the distance from the top of the line to the bottom of most of the 	characters."	baseline := anInteger! !!Point methodsFor: 'point functions' stamp: 'spfa 11/6/2004 16:01'!dist: aPoint 	"Answer the distance between aPoint and the receiver."	| dx dy |	dx := aPoint x - x.	dy := aPoint y - y.	^ ((dx * dx) + (dy * dy)) sqrt! !!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord := 32//self depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt current toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp := self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt current toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f := Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff := f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jmv 12/7/2001 13:48'!uncompress: aByteArray into: aForm doDithering: ditherFlag	"Uncompress an image from the given ByteArray into the given Form. 	Fails if the given Form has the wrong dimensions or depth.	If aForm has depth 16 and ditherFlag = true, do ordered dithering."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	aForm unhibernate.	jpegDecompressStruct := ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w := self primImageWidth: jpegDecompressStruct.	h := self primImageHeight: jpegDecompressStruct.	((aForm width = w) & (aForm height = h)) ifFalse: [		^ self error: 'form dimensions do not match'].	"odd width images of depth 16 give problems; avoid them"	w odd		ifTrue: [			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]		ifFalse: [			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].	self primJPEGReadImage: jpegDecompressStruct		fromByteArray: aByteArray		onForm: aForm		doDithering: ditherFlag		errorMgr: jpegErrorMgr2Struct.! !!GIFReadWriter methodsFor: 'private-decoding' stamp: ''!skipBitData	| misc blocksize |	self readWord.  "skip Image Left"	self readWord.  "skip Image Top"	self readWord.  "width"	self readWord.  "height"	misc := self next.	(misc bitAnd: 16r80) = 0 ifFalse: [ "skip colormap"		1 to: (1 bitShift: (misc bitAnd: 7) + 1) do: [:i |			self next; next; next]].	self next.  "minimum code size"	[(blocksize := self next) > 0]		whileTrue: [self next: blocksize]! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'bf 5/29/2003 01:38'!writeHeader	| byte |	stream position = 0 ifTrue: [		"For first image only"		self nextPutAll: 'GIF89a' asByteArray.		self writeWord: width.	"Screen Width"		self writeWord: height.	"Screen Height"		byte := 16r80.  "has color map"		byte := byte bitOr: ((bitsPerPixel - 1) bitShift: 5).  "color resolution"		byte := byte bitOr: bitsPerPixel - 1.  "bits per pixel"		self nextPut: byte.		self nextPut: 0.		"background color."		self nextPut: 0.		"reserved"		colorPalette do: [:pixelValue |			self	nextPut: ((pixelValue bitShift: -16) bitAnd: 255);				nextPut: ((pixelValue bitShift: -8) bitAnd: 255);				nextPut: (pixelValue bitAnd: 255)].		loopCount notNil ifTrue: [			"Write a Netscape loop chunk"			self nextPut: Extension.			self nextPutAll: #(255 11 78 69 84 83 67 65 80 69 50 46 48 3 1) asByteArray.			self writeWord: loopCount.			self nextPut: 0]].	delay notNil | transparentIndex notNil ifTrue: [		self nextPut: Extension;			nextPutAll: #(16rF9 4) asByteArray;			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [9]);			writeWord: (delay isNil ifTrue: [0] ifFalse: [delay]);			nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [transparentIndex]);			nextPut: 0].	self nextPut: ImageSeparator.	self writeWord: 0.		"Image Left"	self writeWord: 0.		"Image Top"	self writeWord: width.	"Image Width"	self writeWord: height.	"Image Height"	byte := interlace ifTrue: [16r40] ifFalse: [0].	self nextPut: byte.! !!Form methodsFor: 'scaling, rotation' stamp: ''!shrink: aRectangle by: scale 	| scalePt |	scalePt := scale asPoint.	^ self magnify: aRectangle by: (1.0 / scalePt x asFloat) @ (1.0 / scalePt y asFloat)! !!TextStyle methodsFor: 'accessing' stamp: ''!justified	alignment := 3! !!CharacterScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:13'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text := aParagraph text.	textStyle := aParagraph textStyle. ! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/17/2001 15:40'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	self depth = 32		ifTrue: [cm := (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm := Bitmap new: (1 bitShift: (self depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd := newColor pixelValueForDepth: self depth.	cm at: (oldColor pixelValueForDepth: (self depth min: 16))+1 put: newInd.	target := newColor isTransparent 		ifTrue: [ff := Form extent: self extent depth: depth.			ff fillWithColor: newColor.  ff]		ifFalse: [self].	(BitBlt current toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'color mapping' stamp: 'di 10/16/2001 15:23'!reducedPaletteOfSize: nColors	"Return an array of colors of size nColors, such that those colors	represent well the pixel values actually found in this form."	| threshold tallies colorTallies dist delta palette cts top cluster |	tallies := self tallyPixelValues.  "An array of tallies for each pixel value"	threshold := width * height // 500.	"Make an array of (color -> tally) for all tallies over threshold"	colorTallies := Array streamContents:		[:s | tallies withIndexDo:			[:v :i | v >= threshold ifTrue:				[s nextPut: (Color colorFromPixelValue: i-1 depth: depth) -> v]]].	"Extract a set of clusters by picking the top tally, and then removing all others	whose color is within dist of it.  Iterate the process, adjusting dist until we get nColors."	dist := 0.2.  delta := dist / 2.		[cts := colorTallies copy.		palette := Array streamContents: [:s |			[cts isEmpty] whileFalse:				[top := cts detectMax: [:a | a value].				cluster := cts select: [:a | (a key diff: top key) < dist].				s nextPut: top key -> (cluster detectSum: [:a | a value]).				cts := cts copyWithoutAll: cluster]].		palette size = nColors or: [delta < 0.001]]		whileFalse:			[palette size > nColors				ifTrue: [dist := dist + delta]				ifFalse: [dist := dist - delta].			delta := delta / 2].	^ palette collect: [:a | a key]! !!HostFont class methodsFor: 'accessing' stamp: 'ar 6/4/2000 23:18'!listFontNames	"HostFont listFontNames"	"List all the OS font names"	| font fontNames index |	fontNames := WriteStream on: Array new.	index := 0.	[font := self listFontName: index.	font == nil] whileFalse:[		fontNames nextPut: font.		index := index + 1].	^fontNames contents! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: self depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 		ifTrue: [^ cachedColormap].	newMap := Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth := destDepth.	^ cachedColormap := newMap.! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 12/18/2003 23:30'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset x |	offset := bonkForm offset x.	bb := BitBlt current toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	x := self xTable.	(x isMemberOf: SparseLargeTable) ifTrue: [		x base to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	] ifFalse: [		1 to: x size-1 do: [:i | bb destX: (x at: i) + offset; copyBits].	].! !!Form methodsFor: 'analyzing' stamp: 'ar 5/28/2000 12:09'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm := self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice := Form extent: 1@height.	copyBlt := (BitBlt current destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt := (BitBlt current toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Color methodsFor: 'private' stamp: 'ls 9/24/1999 20:04'!setRGB: rgb0	rgb == nil ifFalse: [self attemptToMutateError].	rgb := rgb0! !!Cursor class methodsFor: 'class initialization' stamp: ''!initMarker	MarkerCursor := 		Cursor			extent: 16@16			fromArray: #(		2r0111000000000000		2r1111100000000000		2r1111100000000000		2r0111000000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)			offset: 0@0.! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!tab	| currentX |	currentX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^ self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false! !!Bitmap class methodsFor: 'instance creation' stamp: 'di 2/9/98 16:02'!decodeIntFrom: s	"Decode an integer in stream s as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes	"			| int |	int := s next.	int <= 223 ifTrue: [^ int].	int <= 254 ifTrue: [^ (int-224)*256 + s next].	int := s next.	1 to: 3 do: [:j | int := (int bitShift: 8) + s next].	^ int! !!Form methodsFor: 'filling' stamp: ''!fillFromXColorBlock: colorBlock	"Horizontal Gradient Fill.	Supply relative x in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| xRel |	0 to: width-1 do:		[:x |  xRel := x asFloat / (width-1) asFloat.		self fill: (x@0 extent: 1@height) 			fillColor: (colorBlock value: xRel)]"((Form extent: 100@100 depth: Display depth)	fillFromXColorBlock: [:x | Color r: x g: 0.0 b: 0.5]) display"! !!Quadrangle methodsFor: 'bordering' stamp: ''!insideColor: aColor 	"Set the insideColor of the receiver to aColor, a Form."	insideColor := aColor! !!Rectangle methodsFor: 'rectangle functions' stamp: ''!amountToTranslateWithin: aRectangle	"Answer a Point, delta, such that self + delta is forced within aRectangle."	"Altered so as to prefer to keep self topLeft inside when all of self	cannot be made to fit 7/27/96 di"	| dx dy |	dx := 0.  dy := 0.	self right > aRectangle right ifTrue: [dx := aRectangle right - self right].	self bottom > aRectangle bottom ifTrue: [dy := aRectangle bottom - self bottom].	(self left + dx) < aRectangle left ifTrue: [dx := aRectangle left - self left].	(self top + dy) < aRectangle top ifTrue: [dy := aRectangle top - self top].	^ dx@dy! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 22:55'!initRead	ReadCursor :=  		(Cursor			extent: 16@16			fromArray: #(		2r0000000000000000		2r0000000000000000		2r0001000000001000		2r0010100000010100		2r0100000000100000		2r1111101111100000		2r1000010000100000		2r1000010000100000		2r1011010110100000		2r0111101111000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).! !!Color class methodsFor: 'other' stamp: 'di 3/29/1999 13:33'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded := 1 bitShift: depth]		ifFalse: [sizeNeeded := 4096].	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:		[MaskingMap := Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.		MaskingMap at: 1 put: 0.  "transparent"].	^ MaskingMap! !!BitBlt methodsFor: 'accessing' stamp: ''!clipY: anInteger 	"Set the receiver's clipping area top left y coordinate to be the argument, 	anInteger."	clipY := anInteger! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder := self as: PenPointRecorder).	region := Rectangle encompassing: recorder points.	tileForm := Form extent: region extent+6.	tilePen := Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor := halftoneForm.	drawBlock value: self.	halftoneForm := saveColor.	shape := (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Color class methodsFor: 'instance creation' stamp: 'dvf 6/16/2000 17:48'!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"	| aColorHex red green blue |	aString isEmptyOrNil ifTrue: [^ Color white].	aString first = $#		ifTrue: [aColorHex := aString copyFrom: 2 to: aString size]		ifFalse: [aColorHex := aString].	[aColorHex size = 6		ifTrue:			[aColorHex := aColorHex asUppercase.			red := ('16r', (aColorHex copyFrom: 1 to: 2)) asNumber/255.			green := ('16r', (aColorHex copyFrom: 3 to: 4)) asNumber/255.			blue := ('16r', (aColorHex copyFrom: 5 to: 6)) asNumber/255.			^ self r: red g: green b: blue]]	ifError: [:err :rcvr | "not a hex color triplet" ].		"try to match aColorHex with known named colors"	aColorHex := aColorHex asLowercase.	^self perform: (ColorNames detect: [:i | i asString asLowercase = aColorHex]		ifNone: [#white])! !!Color class methodsFor: 'class initialization' stamp: 'dwh 7/7/1999 23:57'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames := OrderedCollection new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 15:50'!unhibernate	"If my bitmap has been compressed into a ByteArray,	then expand it now, and return true."	| resBits |	bits isForm ifTrue:[		resBits := bits.		bits := Bitmap new: self bitsSize.		resBits displayResourceFormOn: self.		^true].	bits == nil ifTrue:[bits := Bitmap new: self bitsSize. ^true].	(bits isMemberOf: ByteArray)		ifTrue: [bits := Bitmap decompressFromByteArray: bits. ^ true].	^ false! !!Pen methodsFor: 'geometric designs' stamp: 'jm 8/1/97 11:42'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color := 1.	[ true ] whileTrue:		[ history := OrderedCollection new.		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter := lastPoint := Sensor mousePoint.		20 timesRepeat: [ history addLast: lastPoint ].		self color: (color := color + 1).		[ Sensor redButtonPressed ] whileTrue: 			[ newPoint := Sensor mousePoint.			(newPoint = lastPoint) ifFalse:				[ ancientPoint := history removeFirst.				filter := filter * 4 + newPoint // 5.				self place: filter.				self goto: ancientPoint.				lastPoint := newPoint.				history addLast: filter ] ] ]! !!StrikeFont methodsFor: 'character shapes' stamp: ''!widen: char by: delta	| newForm |	^ self alter: char formBlock:  "Make a new form, wider or narrower..."		[:charForm | newForm := Form extent: charForm extent + (delta@0).		charForm displayOn: newForm.  "Copy this image into it"		newForm]    "and substitute it in the font"! !!ColorForm methodsFor: 'postscript generation' stamp: ''!asFormWithSingleTransparentColors	| transparentIndexes |	transparentIndexes := self transparentColorIndexes.	transparentIndexes size <= 1 ifTrue:[^self]		ifFalse:[^self mapTransparencies:transparentIndexes].! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 11/12/2002 12:56'!fixAscent: a andDescent: d head: h	| bb newGlyphs |	"(a + d) = (ascent + descent) ifTrue: ["		ascent := a.		descent := d.		newGlyphs := Form extent: (glyphs width@(h + glyphs height)).		bb := BitBlt toForm: newGlyphs.		bb copy: (0@h extent: (glyphs extent)) from: 0@0 in: glyphs			fillColor: nil rule: Form over.		glyphs := newGlyphs.	"]."! !!WarpBlt methodsFor: 'primitives' stamp: 'nk 4/17/2004 19:50'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 'primitiveWarpBits' module: 'BitBltPlugin'>	"Check for compressed source, destination or halftone forms"	((sourceForm isForm) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isForm) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isForm) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne := 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix := Array new: n*n].	nSteps := height-1 max: 1.	deltaP12 := (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA := (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 := (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB := (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker := BitBlt current bitPeekerFromForm: sourceForm.	poker := BitBlt current bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps := width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB := (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp := (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp := sp + deltaPAB].		pA := pA + deltaP12.		pB := pB + deltaP43]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:12'!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel transparentIndex |	blitter := BitBlt current bitPokerToForm: form.	transparentIndex := form colors size.	bitsPerChannel = 16		ifTrue: [0				to: width - 1				do: [:x | blitter pixelAt: x @ y put: 255							- (thisScanline at: x << 1 + 1)].			^ self]		ifFalse: [bitsPerChannel = 8				ifTrue: [1						to: width						do: [:x | blitter								pixelAt: x - 1 @ y								put: (thisScanline at: x)].					^ self].			bitsPerChannel = 1				ifTrue: [pixPerByte := 8.					mask := 1.					shifts := #(7 6 5 4 3 2 1 0 )].			bitsPerChannel = 2				ifTrue: [pixPerByte := 4.					mask := 3.					shifts := #(6 4 2 0 )].			bitsPerChannel = 4				ifTrue: [pixPerByte := 2.					mask := 15.					shifts := #(4 0 )].			pixelNumber := 0.			0 to: width - 1 do: [:x | 				rawByte := thisScanline at: pixelNumber // pixPerByte + 1.				pixel := rawByte							>> (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.				pixel = transparentPixelValue ifTrue: [pixel := transparentIndex].				blitter pixelAt: x @ y put: pixel.				pixelNumber := pixelNumber + 1			]		]! !!CharacterBlock methodsFor: 'private' stamp: 'di 10/23/97 22:33'!stringIndex: anInteger text: aText topLeft: topLeft extent: extent	stringIndex := anInteger.	text := aText.	super setOrigin: topLeft corner: topLeft + extent ! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'yo 11/18/2002 13:16'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	(((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]]) or: [				((lastIndex < line last)				and: [((text at: lastIndex) leadingChar ~= (text at: lastIndex+1) leadingChar)					and: [lastIndex ~= characterIndex]])])		ifTrue:	["We're really at the end of a real run."				runLength := (text runLengthFor: (lastIndex := lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop := characterIndex	"scanning for index"]					ifFalse:	[lineStop := line last			"scanning for point"].				(runStopIndex := lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex := lineStop].				self setStopConditions.				^false].	lastCharacter := text at: lastIndex.	characterPoint := destX @ destY.	((lastCharacter = Space and: [alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex :=  lastIndex + 1.				lastCharacter := nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex := lastIndex + 1.	^true! !!Form methodsFor: 'private' stamp: ''!initFromArray: array	"Fill the bitmap from array.  If the array is shorter,	then cycle around in its contents until the bitmap is filled."	| ax aSize array32 i j word16 |	ax := 0.	aSize := array size.	aSize > bits size ifTrue:		["backward compatibility with old 16-bit bitmaps and their forms"		array32 := Array new: height * (width + 31 // 32).		i := j := 0.		1 to: height do:			[:y | 1 to: width+15//16 do:				[:x16 | word16 := array at: (i := i + 1).				x16 odd ifTrue: [array32 at: (j := j+1) put: (word16 bitShift: 16)]						ifFalse: [array32 at: j put: ((array32 at: j) bitOr: word16)]]].		^ self initFromArray: array32].	1 to: bits size do:		[:index |		(ax := ax + 1) > aSize ifTrue: [ax := 1].		bits at: index put: (array at: ax)]! !!Form methodsFor: 'filling' stamp: 'ar 5/14/2001 23:46'!floodFill2: aColor at: interiorPoint	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE: This is a less optimized variant for flood filling which is precisely along the lines of Heckbert's algorithm. For almost all cases #floodFill:at: will be faster (see the comment there) but this method is left in both as reference and as a fallback if such a strange case is encountered in reality."	| peeker poker stack old new x y top x1 x2 dy left goRight |	peeker := BitBlt current bitPeekerFromForm: self.	poker := BitBlt current bitPokerToForm: self.	stack := OrderedCollection new: 50.	"read old pixel value"	old := peeker pixelAt: interiorPoint.	"compute new value"	new := self pixelValueFor: aColor.	old = new ifTrue:[^self]. "no point, is there?!!"	x := interiorPoint x.	y := interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		top := stack removeLast.		y := top at: 1. x1 := top at: 2. x2 := top at: 3. dy := top at: 4.		y := y + dy.		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		x := x1.		[x >= 0 and:[(peeker pixelAt: x@y) = old]] whileTrue:[			poker pixelAt: x@y put: new.			x := x - 1].		goRight := x < x1.		left := x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x := x1 + 1].		[			goRight ifTrue:[				[x < width and:[(peeker pixelAt: x@y) = old]] whileTrue:[					poker pixelAt: x@y put: new.					x := x + 1].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x := x + 1) <= x2 and:[(peeker pixelAt: x@y) ~= old]] whileTrue.			left := x.			goRight := true.		x <= x2] whileTrue.	].! !!BitBlt methodsFor: 'accessing' stamp: ''!destX: x destY: y width: w height: h	"Combined init message saves 3 sends from DisplayScanner"	destX := x.	destY := y.	width := w.	height := h.! !!Form class methodsFor: 'instance creation' stamp: 'mir 11/19/2001 14:13'!fromFileNamed: fileName	"Read a Form or ColorForm from the given file."	| file form |	file := (FileStream readOnlyFileNamed: fileName) binary.	form := self fromBinaryStream: file.	Smalltalk isMorphic ifTrue:[		Project current resourceManager			addResource: form			url: (FileDirectory urlForFileNamed: file name) asString].	file close.	^ form! !!Quadrangle methodsFor: 'initialize-release' stamp: ''!initialize	"Initialize the region to a null Rectangle, the borderWidth to 1, the 	borderColor to black, and the insideColor to white."	origin := 0 @ 0.	corner := 0 @ 0.	borderWidth := 1.	borderColor := Color black.	insideColor := Color white.! !!BitBlt methodsFor: 'accessing' stamp: ''!sourceOrigin: aPoint 	"Set the receiver's source form coordinates to be those of the argument, 	aPoint."	sourceX := aPoint x.	sourceY := aPoint y! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 4/28/2000 16:10'!fixOneWideChars 	"This fixes all 1-wide characters to be 2 wide with blank on the right	so as not to cause artifacts in neighboring characters in bold or italic."	| twoWide |	minAscii to: maxAscii do:		[:i | (self widthOf: (Character value: i)) = 1 ifTrue:			[twoWide := Form extent: 2@glyphs height.			(self characterFormAt: (Character value: i)) displayOn: twoWide at: 0@0.			self characterFormAt: (Character value: i) put: twoWide]]."StrikeFont allInstancesDo: [:f | f fixOneWideChars].StrikeFont shutDown.  'Flush synthetic fonts'."! !!Color methodsFor: 'private' stamp: ''!flushCache	"Flush my cached bit pattern."	cachedDepth := nil.	cachedBitPattern := nil.! !!XBMReadWriter methodsFor: 'private' stamp: 'wdc 2/2/1999 15:20'!parseByteValue	"skip over separators and return next bytevalue parsed as a C language number:		0ddd is an octal digit.		0xddd is a hex digit.		ddd is decimal."	| source mybase |	stream skipSeparators.	source := ReadWriteStream on: String new.	[stream atEnd or: [ stream peek isSeparator ]]		whileFalse: [source nextPut: self next asUppercase].	mybase := 10. "Base 10 default"	source reset.	(source peek = $0) ifTrue: [		mybase := 8. "Octal or Hex, say its Octal unless overridden."		source next.		(source peek = $X) ifTrue: [			mybase := 16. "Ah.  It's Hex."			source next.			]		].	^ Integer readFrom: source base: mybase! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:08'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d := nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 << nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel << d.			mask := mask << d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 << nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel >> d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix >> d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream := FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!Form class methodsFor: 'examples' stamp: ''!exampleSketch	"This is a simple drawing algorithm to get a sketch on the display screen.	Draws whenever mouse button down.  Ends with option-click."	| aPen color |	aPen := Pen new.	color := 0.	[Sensor yellowButtonPressed]		whileFalse:		[aPen place: Sensor cursorPoint; color: (color := color + 1).		[Sensor redButtonPressed]			whileTrue: [aPen goto: Sensor cursorPoint]].	Sensor waitNoButton.	"Form exampleSketch"! !!Form methodsFor: 'scaling, rotation' stamp: 'RAA 7/13/2000 12:09'!scaledToSize: newExtent	| scale |	newExtent = self extent ifTrue: [^self].	scale := newExtent x / self width min: newExtent y / self height.	^self magnify: self boundingBox by: scale smoothing: 2.! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent := xVal @ lastSpaceOrTabExtent y! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:13'!simplePressurePen	"An example of using a pressure sensitive pen to control the thickness of the pen. This requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen simplePressurePen"	| tabletScale pen pressure p |	tabletScale := self tabletScaleFactor.	pen := Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p := (Sensor tabletPoint * tabletScale) rounded.			pressure := (15.0 * Sensor tabletPressure) rounded.		     pressure > 0				ifTrue: [					pen roundNib: pressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!StrikeFont class methodsFor: 'accessing' stamp: 'rej 9/29/2007 08:50'!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f := fonts at: i].	].	^f! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'di 9/3/2000 16:20'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!Bitmap methodsFor: 'as yet unclassified' stamp: 'yo 2/18/2004 18:28'!asByteArray	"Faster way to make a byte array from me.	copyFromByteArray: makes equal Bitmap."	| f bytes hack |	f := Form extent: 4@self size depth: 8 bits: self.	bytes := ByteArray new: self size * 4.	hack := Form new hackBits: bytes.	SmalltalkImage current isLittleEndian ifTrue:[hack swapEndianness].	hack copyBits: f boundingBox		from: f		at: (0@0)		clippingBox: hack boundingBox		rule: Form over		fillColor: nil		map: nil.	"f displayOn: hack."	^ bytes.! !!GIFReadWriter methodsFor: 'private-packing' stamp: ''!fillBuffer	| packSize |	packSize := self next.	bufStream := ReadStream on: (self next: packSize)! !!StrikeFont methodsFor: 'file in/out' stamp: 'ls 4/11/2000 18:57'!writeAsStrike2named: fileName	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	| file |	file := FileStream fileNamed: fileName.	self writeAsStrike2On: file.	file close.! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:39'!fadeImageVert: otherImage at: topLeft	"Display fadeImageVert: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	| d |	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((mask width//2//d-i*d)@0 extent: i*2*d@mask height) fillColor: Color black.		i <= (mask width//d)]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 01:50'!embeddedObject	| savedIndex |	savedIndex := lastIndex.	text attributesAt: lastIndex do:[:attr| 		attr anchoredMorph ifNotNil:[			"Following may look strange but logic gets reversed.			If the morph fits on this line we're not done (return false for true) 			and if the morph won't fit we're done (return true for false)"			(self placeEmbeddedObject: attr anchoredMorph) ifFalse:[^true]]].	lastIndex := savedIndex + 1. "for multiple(!!) embedded morphs"	^false! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:36'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart := self position.	length := self nextWord.	[self position - markerStart >= length] whileFalse:		[index := self next.		isACTable := (index bitAnd: 16r10) ~= 0.		index := (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits := self next: 16.		count := bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal := self next: count.		hTable := stream buildLookupTable: huffVal counts: bits.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!Form class methodsFor: 'instance creation' stamp: 'nk 7/7/2003 18:19'!fromBinaryStream: aBinaryStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."	| firstByte |	aBinaryStream binary.	firstByte := aBinaryStream next.	firstByte = 1 ifTrue: [		"old Squeakform format"		^ self new readFromOldFormat: aBinaryStream].	firstByte = 2 ifTrue: [		"new Squeak form format"		^ self new readFrom: aBinaryStream].	"Try for JPG, GIF, or PCX..."	"Note: The following call closes the stream."	^ ImageReadWriter formFromStream: aBinaryStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: ''!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer := self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !!StrikeFont class methodsFor: 'derivative font caching' stamp: 'tak 3/11/2005 16:27'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allSubInstancesDo: [:sf | sf reset].	StrikeFontSet allSubInstancesDo: [:sf | sf reset].	DefaultStringScanner := nil.! !!Pen methodsFor: 'operations' stamp: 'sw 10/5/2002 03:17'!arrowHead	"Put an arrowhead on the previous pen stroke"	" | pen | pen := Pen new. 20 timesRepeat: [pen turn: 360//20; go: 20; arrowHead]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: (Preferences parameterAt: #arrowSpec ifAbsent: [5 @ 4])]! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutGray: aForm	| myType peeker val |	cols := aForm width.	rows := aForm height.	depth := aForm depth.	"stream position: 0."	aForm depth = 1 ifTrue:[myType := $4] ifFalse:[myType := $5].	self writeHeader: myType.	peeker := BitBlt current bitPeekerFromForm: aForm.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			val := peeker pixelAt: x@y.			stream nextPut: val.		]	].! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 19:01'!initTopLeft	TopLeftCursor := 		(Cursor extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0@0).! !!Point methodsFor: 'private' stamp: 'tk 10/4/2001 16:16'!setR: rho degrees: degrees 	| radians |	radians := degrees asFloat degreesToRadians.	x := rho asFloat * radians cos.	y := rho asFloat * radians sin.! !!StrikeFont methodsFor: 'testing' stamp: ''!checkCharacter: character 	"Answer a Character that is within the ascii range of the receiver--either 	character or the last character in the receiver."	| ascii |  	ascii := character asciiValue.	((ascii < minAscii) or: [ascii > maxAscii])			ifTrue: [^maxAscii asCharacter]			ifFalse:	[^character]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGrayAlpha: y	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b := BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i := (x << 1) + 1.				gray := thisScanline at: i.				pixel := ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i := (x << 2) + 1.				gray := thisScanline at: i.				pixel := ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!Color methodsFor: 'conversions' stamp: 'hmm 4/25/2000 09:40'!bitPatternForDepth: depth	"Return a Bitmap, possibly containing a stipple pattern, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps. The resulting Bitmap may be multiple words to represent a stipple pattern of several lines.  "	"See also:	pixelValueAtDepth:	-- value for single pixel				pixelWordAtDepth:	-- a 32-bit word filled with the pixel value"	"Details: The pattern for the most recently requested depth is cached."	"Note for depths > 2, there are stippled and non-stippled versions (generated with #balancedPatternForDepth: and #bitPatternForDepth:, respectively). The stippled versions don't work with the window bit caching of StandardSystemView, so we make sure that for these depths, only unstippled patterns are returned"	(depth == cachedDepth and: [depth <= 2 or: [cachedBitPattern size = 1]]) ifTrue: [^ cachedBitPattern].	cachedDepth := depth.	depth > 2 ifTrue: [^ cachedBitPattern := Bitmap with: (self pixelWordForDepth: depth)].	depth = 1 ifTrue: [^ cachedBitPattern := self halfTonePattern1].	depth = 2 ifTrue: [^ cachedBitPattern := self halfTonePattern2].! !!Rectangle methodsFor: 'accessing' stamp: 'di 11/17/2001 14:01'!area	"Answer the receiver's area, the product of width and height."	| w |	(w := self width) <= 0 ifTrue: [^ 0].	^ w * self height max: 0! !!Color methodsFor: 'conversions' stamp: 'jm 1/26/2001 15:11'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack := 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val := (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val := LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val = 0 ifTrue: [val at: 1 put: 1].  "closest non-transparent black"		val at: 4 put: 16rFF.  "opaque alpha"		^ val].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val := (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val := (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!StrikeFont methodsFor: 'accessing' stamp: 'yo 1/6/2005 04:19'!glyphOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| code |	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [			^ fallbackFont glyphOf: aCharacter.		].		^ (Form extent: 1@self height) fillColor: Color white	].	code := aCharacter charCode.	^ glyphs copy: (((xTable at: code + 1)@0) corner: (xTable at: code +2)@self height).! !!StrikeFont class methodsFor: 'font creation' stamp: 'rbb 2/18/2005 13:21'!hostFontFromUser	"StrikeFont hostFontFromUser"	| fontNames index labels |	fontNames := self listFontNames asSortedCollection.	labels := WriteStream on: (String new: 100).	fontNames do:[:fn| labels nextPutAll: fn] separatedBy:[labels cr].	index := (UIManager default chooseFrom: (labels contents substrings) 				title: 'Choose your font').	index = 0 ifTrue:[^nil].	^fontNames at: index! !!Form methodsFor: 'transitions' stamp: 'ar 5/28/2000 12:12'!pageWarp: otherImage at: topLeft forward: forward	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect := otherImage boundingBox.	oldPage := self copy: (pageRect translateBy: topLeft).	(forward ifTrue: [oldPage] ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom := self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).	nSteps := 8.	buffer := Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.	d := pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.	1 to: nSteps-1 do:		[:i | forward			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.					p := pageRect topRight + (d * i // nSteps)]			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.					p := pageRect topRight + (d * (nSteps-i) // nSteps)].		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.		leafRect := pageRect topLeft corner: p x @ (pageRect bottom + p y).		sourceQuad := Array with: pageRect topLeft			with: pageRect bottomLeft + (0@p y)			with: pageRect bottomRight			with: pageRect topRight - (0@p y).		warp := (WarpBlt current toForm: buffer)				clipRect: leafRect;				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);				combinationRule: Form paint.		warp copyQuad: sourceQuad toRect: leafRect.		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.		Display forceDisplayUpdate].	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.	Display forceDisplayUpdate."1 to: 4 do: [:corner | Display pageWarp:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 forward: false]"! !!Color class methodsFor: 'colormaps' stamp: 'jm 5/2/1999 07:24'!cachedColormapFrom: sourceDepth to: destDepth	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."	| srcIndex map |	CachedColormaps class == Array ifFalse: [CachedColormaps := (1 to: 9) collect: [:i | Array new: 32]].	srcIndex := sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex := 9].	(map := (CachedColormaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map := self computeColormapFrom: sourceDepth to: destDepth.	(CachedColormaps at: srcIndex) at: destDepth put: map.	^ map! !!Form methodsFor: 'copying' stamp: ''!copy: aRect 	"Return a new form which derives from the portion of the original form delineated by aRect."	| newForm |	newForm := self class extent: aRect extent depth: depth.	^ newForm copyBits: aRect from: self at: 0@0		clippingBox: newForm boundingBox rule: Form over fillColor: nil! !!TextStyle methodsFor: 'private' stamp: ''!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font := self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 5/19/2004 11:34'!characters: anInterval in: sourceString displayAt: aPoint clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm kernDelta: kernDelta on: aBitBlt	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint leftX rightX sourceRect |	destPoint := aPoint.	anInterval do: 		[:i |		self flag: #yoDisplay.		"if the char is not supported, fall back to the specified fontset."		ascii := (sourceString at: i) charCode.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii := maxAscii].		leftX := xTable at: ascii + 1.		rightX := xTable at: ascii + 2.		sourceRect := leftX@0 extent: (rightX-leftX) @ self height.		aBitBlt copyFrom: sourceRect in: glyphs to: destPoint.		destPoint := destPoint + ((rightX-leftX+kernDelta)@0).		"destPoint printString displayAt: 0@(i*20)"].	^ destPoint! !!StrikeFont class methodsFor: 'font creation' stamp: 'ar 6/4/2000 21:12'!listFontNames	"StrikeFont listFontNames"	"List all the OS font names"	| font fontNames index |	fontNames := WriteStream on: Array new.	index := 0.	[font := self listFont: index.	font == nil] whileFalse:[		fontNames nextPut: font.		index := index + 1].	^fontNames contents! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'nk 7/27/2004 17:57'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm := Form extent: width@1 depth: 32.	tempBits := tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.			i := i + 4.		]	] ifFalse: [		i := (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.			i := i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paintAlpha.! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!updateDCValue: aNumber	priorDCValue := priorDCValue + aNumber.	^priorDCValue! !!StrikeFont methodsFor: 'file in/out' stamp: ''!readBFHeaderFrom: f	name := self restOfLine: 'Font name = ' from: f.	ascent := (self restOfLine: 'Ascent = ' from: f) asNumber.	descent := (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth := (self restOfLine: 'Maximum width = ' from: f) asNumber.	pointSize := (self restOfLine: 'Font size = ' from: f) asNumber.	name := (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii := 258.	maxAscii := 0.	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	type := 0.  "ignored for now"! !!StrikeFont methodsFor: 'file in/out' stamp: 'ar 5/23/2000 12:53'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type := file nextInt32.  type = 2 ifFalse: [file close. self error: 'not strike2 format'].	minAscii := file nextInt32.	maxAscii := file nextInt32.	maxWidth := file nextInt32.	ascent := file nextInt32.	descent := file nextInt32.	pointSize := file nextInt32.	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := file nextInt32.	xTable := (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs := Form new readFrom: file.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	characterToGlyphMap := nil.! !!JPEGReadWriter methodsFor: 'public access' stamp: 'ar 10/28/2001 16:25'!nextImageDitheredToDepth: depth	| form xStep yStep x y bb |	ditherMask := DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	residuals := WordArray new: 3.	sosSeen := false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form := Form extent: (width @ height) depth: depth.	bb := BitBlt current toForm: form.	bb sourceForm: mcuImageBuffer.	bb colorMap: (mcuImageBuffer colormapIfNeededFor: form).	bb sourceRect: mcuImageBuffer boundingBox.	bb combinationRule: Form over.	xStep := mcuWidth * DCTSize.	yStep := mcuHeight * DCTSize.	y := 0.	1 to: mcuRowsInScan do:		[:row |		x := 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			bb destX: x; destY: y; copyBits.			x := x + xStep].		y := y + yStep].	^ form! !!Form class methodsFor: 'examples' stamp: ''!makeStar  "See the similar example in OpaqueForm"	| sampleForm pen |	sampleForm := Form extent: 50@50.  "Make a form"	pen := Pen newOnForm: sampleForm.	pen place: 24@50; turn: 18.		"Draw a 5-pointed star on it."	1 to: 5 do: [:i | pen go: 19; turn: 72; go: 19; turn: -144].	^ sampleForm"Form makeStar follow: [Sensor cursorPoint]				while: [Sensor noButtonPressed]"! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 08:47'!floodFill: aColor at: interiorPoint tolerance: tolerance	"Fill the shape (4-connected) at interiorPoint.  The algorithm is based on Paul Heckbert's 'A Seed Fill Algorithm', Graphic Gems I, Academic Press, 1990.	NOTE (ar): This variant has been heavily optimized to prevent the overhead of repeated calls to BitBlt. Usually this is a really big winner but the runtime now depends a bit on the complexity of the shape to be filled. For extremely complex shapes (say, a Hilbert curve) with very few pixels to fill it can be slower than #floodFill2:at: since it needs to repeatedly read the source bits. However, in all practical cases I found this variant to be 15-20 times faster than anything else.	Further note (di):  I have added a feature that allows this routine to fill areas of approximately constant color (such as  photos, scans, and jpegs).  It does this by computing a color map for the peeker that maps all colors close to 'old' into colors identical to old.  This mild colorblindness achieves the desired effect with no further change or degradation of the algorithm.  tolerance should be 0 (exact match), or a value corresponding to those returned by Color>>diff:, with 0.1 being a reasonable starting choice."	| peeker poker stack old new x y top x1 x2 dy left goRight span spanBits w box debug |	debug := false. "set it to true to see the filling process"	box := interiorPoint extent: 1@1.	span := Form extent: width@1 depth: 32.	spanBits := span bits.	peeker := BitBlt current toForm: span.	peeker 		sourceForm: self; 		combinationRule: 3; 		width: width; 		height: 1.	"read old pixel value"	peeker sourceOrigin: interiorPoint; destOrigin: interiorPoint x @ 0; width: 1; copyBits.	old := spanBits at: interiorPoint x + 1.	"compute new value (take care since the algorithm will fail if old = new)"	new := self privateFloodFillValue: aColor.	old = new ifTrue: [^ box].	tolerance > 0 ifTrue:		["Set up color map for approximate fills"		peeker colorMap: (self floodFillMapFrom: self to: span mappingColorsWithin: tolerance to: old)].	poker := BitBlt current toForm: self.	poker 		fillColor: aColor;		combinationRule: 3;		width: width;		height: 1.	stack := OrderedCollection new: 50.	x := interiorPoint x.	y := interiorPoint y.	(y >= 0 and:[y < height]) ifTrue:[		stack addLast: {y. x. x. 1}. "y, left, right, dy"		stack addLast: {y+1. x. x. -1}].	[stack isEmpty] whileFalse:[		debug ifTrue:[self displayOn: Display].		top := stack removeLast.		y := top at: 1. x1 := top at: 2. x2 := top at: 3. dy := top at: 4.		y := y + dy.		debug ifTrue:[			(Line from: (x1-1)@y to: (x2+1)@y 				withForm: (Form extent: 1@1 depth: 8) fillWhite) displayOn: Display].		"Segment of scanline (y-dy) for x1 <= x <= x2 was previously filled.		Now explore adjacent pixels in scanline y."		peeker sourceOrigin: 0@y; destOrigin: 0@0; width: width; copyBits.			"Note: above is necessary since we don't know where we'll end up filling"		x := x1.		w := 0.		[x >= 0 and:[(spanBits at: x+1) = old]] whileTrue:[			w := w + 1.			x := x - 1].		w > 0 ifTrue:[			"overwrite pixels"			poker destOrigin: x+1@y; width: w; copyBits.			box := box quickMerge: ((x+1@y) extent: w@1)].		goRight := x < x1.		left := x+1.		(left < x1 and:[y-dy >= 0 and:[y-dy < height]]) 			ifTrue:[stack addLast: {y. left. x1-1. 0-dy}].		goRight ifTrue:[x := x1 + 1].		[			goRight ifTrue:[				w := 0.				[x < width and:[(spanBits at: x+1) = old]] whileTrue:[					w := w + 1.					x := x + 1].				w > 0 ifTrue:[					"overwrite pixels"					poker destOrigin: (x-w)@y; width: w; copyBits.					box := box quickMerge: ((x-w@y) extent: w@1)].				(y+dy >= 0 and:[y+dy < height]) 					ifTrue:[stack addLast: {y. left. x-1. dy}].				(x > (x2+1) and:[y-dy >= 0 and:[y-dy >= 0]]) 					ifTrue:[stack addLast: {y. x2+1. x-1. 0-dy}]].			[(x := x + 1) <= x2 and:[(spanBits at: x+1) ~= old]] whileTrue.			left := x.			goRight := true.		x <= x2] whileTrue.	].	^box! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 1/15/2004 16:48'!newForKoreanFromEFontBDFFile: fileName name: aString overrideWith: otherFileName	| n |	n := self new.	n readEFontBDFForKoreanFromFile: fileName name: aString overrideWith: otherFileName.	^ n.! !!Color methodsFor: 'printing' stamp: 'bf 5/25/2000 16:52'!printOn: aStream	| name |	(name := self name) ifNotNil:		[^ aStream			nextPutAll: 'Color ';			nextPutAll: name].	self storeOn: aStream.! !!ColorForm class methodsFor: 'as yet unclassified' stamp: ''!twoToneFromDisplay: aRectangle using: oldForm backgroundColor: bgColor	"Return a 1-bit deep ColorForm copied from the given rectangle of the display. All colors except the background color will be mapped to black."	| f |	((oldForm ~~ nil) and: [oldForm extent = aRectangle extent]) ifTrue: [		f := oldForm fromDisplay: aRectangle.	] ifFalse: [		f := ColorForm extent: aRectangle extent depth: 1.		f twoToneFromDisplay: aRectangle backgroundColor: bgColor.		f colors: (Array			with: bgColor			with: Color black)].	^ f! !!CompositionScanner methodsFor: 'scanning' stamp: 'hmm 7/20/2000 18:24'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount := 0.	done := false.	[done]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!DisplayText methodsFor: 'private' stamp: ''!setText: aText textStyle: aTextStyle offset: aPoint	text := aText.	textStyle := aTextStyle.	offset := aPoint.	form := nil! !!StrikeFont class methodsFor: 'examples' stamp: 'tpr 6/10/2005 16:07'!readStrikeFont2Family: familyName fromDirectory: aDirectory	"StrikeFont readStrikeFont2Family: 'Lucida' fromDirectory: FileDirectory default"	"This utility reads all available .sf2 StrikeFont files for a given family from  	the current directory. It returns an Array, sorted by size, suitable for handing 	to TextStyle newFontArray: ."	"For this utility to work as is, the .sf2 files must be named 'familyNN.sf2'."	| fileNames strikeFonts fontArray |	fileNames := aDirectory fileNamesMatching: familyName , '##.sf2'.	strikeFonts := fileNames collect: [:fname | StrikeFont new readFromStrike2: fname].	strikeFonts do: [ :font | font reset ].	strikeFonts := strikeFonts asSortedCollection: [:a :b | a height < b height].	fontArray := strikeFonts asArray.	^ fontArray"TextConstants at: #Lucida put: (TextStyle fontArray: (StrikeFont 	readStrikeFont2Family: 'Lucida'))."! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'ar 2/11/2004 00:55'!initialize	"	PNGReadWriter initialize	"	BPP := {	#(1 2 4 8 16).			#(0 0 0 0 0).			#(0 0 0 24 48).			#(1 2 4 8 0).			#(0 0 0 16 32).			#(0 0 0 0 0).			#(0 0 0 32 64).			#(0 0 0 0 0) }.	BlockHeight := #(8 8 4 4 2 2 1).	BlockWidth := #(8 4 4 2 2 1 1).	StandardColors := Color indexedColors collect:[:aColor|		Color 			r: (aColor red * 255) truncated / 255			g: (aColor green * 255) truncated / 255			b: (aColor blue * 255) truncated / 255.	].	StandardSwizzleMaps := Array new: 4.	#(1 2 4) do:[:i| StandardSwizzleMaps at: i put: (self computeSwizzleMapForDepth: i)].! !!Form methodsFor: 'displaying' stamp: 'ar 5/28/2000 12:08'!drawLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Refer to the comment in 	DisplayMedium|drawLine:from:to:clippingBox:rule:mask:." 		| dotSetter |	"set up an instance of BitBlt for display"	dotSetter := BitBlt current		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: anInteger		destOrigin: beginPoint		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint! !!Form methodsFor: 'transitions' stamp: 'di 1/28/1999 09:20'!zoomIn: goingIn orOutTo: otherImage at: topLeft vanishingPoint: vp 	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40.	Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40."	| nSteps j bigR lilR minTime startTime lead |	nSteps := 16.	minTime := 500.  "milliseconds"	startTime := Time millisecondClockValue.	^ self wipeImage: otherImage at: topLeft clippingBox: nil rectForIndex:		[:i | "i runs from 1 to nsteps"		i > nSteps			ifTrue: [nil "indicates all done"]			ifFalse:			["If we are going too fast, delay for a bit"			lead := startTime + (i-1*minTime//nSteps) - Time millisecondClockValue.			lead > 10 ifTrue: [(Delay forMilliseconds: lead) wait].			"Return an array with the difference rectangles for this step."			j := goingIn ifTrue: [i] ifFalse: [nSteps+1-i].			bigR := vp - (vp*(j)//nSteps) corner:				vp + (otherImage extent-vp*(j)//nSteps).			lilR := vp - (vp*(j-1)//nSteps) corner:				vp + (otherImage extent-vp*(j-1)//nSteps).			bigR areasOutside: lilR]]! !!Quadrangle methodsFor: 'bordering' stamp: ''!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border width of the receiver to a Rectangle that represents the 	left, right, top, and bottom border widths."	borderWidth := anInteger1 @ anInteger3 corner: anInteger2 @ anInteger4! !!Rectangle methodsFor: 'FMP' stamp: 'RAA 6/1/1999 17:41'!deltaToEnsureInOrCentered: r extra: aNumber	| dX dY halfXDiff halfYDiff |	dX := dY := 0.	halfXDiff := (r width - self width * aNumber) truncated.	halfYDiff := (r height - self height  * aNumber) truncated.	self left < r left		ifTrue: [dX := self left - r left - halfXDiff]		ifFalse: [self right > r right ifTrue: [dX := self right - r right + halfXDiff]].	self top < r top		ifTrue: [dY := self top - r top - halfYDiff]		ifFalse: [self bottom > r bottom ifTrue: [dY := self bottom - r bottom + halfYDiff]].	^dX @ dY! !!TextLineInterval methodsFor: 'accessing' stamp: ''!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	stop := stopInteger! !!StrikeFont methodsFor: 'displaying' stamp: 'yo 1/7/2005 15:16'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| destPoint leftX rightX glyphInfo char displayInfo destY |	destPoint := aPoint.	charIndex := startIndex.	glyphInfo := Array new: 5.	[charIndex <= stopIndex] whileTrue: [		char := aString at: charIndex.		(self hasGlyphOf: char) not ifTrue: [				displayInfo := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: stopIndex at: destPoint kern: kernDelta from: self baselineY: baselineY.				charIndex := displayInfo first.				destPoint := displayInfo second.		] ifFalse: [			self glyphInfoOf: char into: glyphInfo.			leftX := glyphInfo second.			rightX := glyphInfo third.			(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [				glyphInfo fifth installOn: aBitBlt.			].			aBitBlt sourceForm: glyphInfo first.			destY := baselineY - glyphInfo fourth. 			aBitBlt destX: destPoint x.			aBitBlt destY: destY.			aBitBlt sourceOrigin: leftX @ 0.			aBitBlt width: rightX - leftX.			aBitBlt height: self height.			aBitBlt copyBits.			destPoint := destPoint + (rightX - leftX + kernDelta @ 0).			charIndex := charIndex + 1.		].	].	^ Array with: charIndex with: destPoint.! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad := 0.	spaceCount := spaceCount + 1.	pad := line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^ false! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'ar 3/3/2001 20:07'!hibernate	"Make myself take up less space. See comment in Form>hibernate."	super hibernate.	self clearColormapCache.	colors ifNotNil:[colors := colors asColorArray].! !!DisplayObject methodsFor: 'displaying-Display' stamp: ''!slideFrom: startPoint to: stopPoint nSteps: nSteps 	"does not display at the first point, but does at the last"	| i p delta |	i:=0.  p:= startPoint.	delta := (stopPoint-startPoint) // nSteps.	^ self follow: [p:= p+delta]		while: [(i:=i+1) < nSteps]! !!Form methodsFor: 'resources' stamp: 'ar 12/9/2002 16:04'!readNativeResourceFrom: byteStream	| img aStream |	(byteStream isKindOf: FileStream) ifTrue:[		"Ugly, but ImageReadWriter will send #reset which is implemented as #reopen and we may not be able to do so."		aStream := RWBinaryOrTextStream with: byteStream contents.	] ifFalse:[		aStream := byteStream.	].	img := [ImageReadWriter formFromStream: aStream] on: Error do:[:ex| nil].	img ifNil:[^nil].	(img isColorForm and:[self isColorForm]) ifTrue:[		| cc |		cc := img colors.		img colors: nil.		img displayOn: self.		img colors: cc.	] ifFalse:[		img displayOn: self.	].	img := nil.! !!Form class methodsFor: 'instance creation' stamp: 'jm 3/27/98 16:28'!extent: extentPoint fromStipple: fourNibbles	"Answer an instance of me with bitmap initialized from	a repeating 4x4 bit stipple encoded in a 16-bit constant."	| nibble |	^ (self extent: extentPoint depth: 1)		initFromArray: ((1 to: 4) collect:				[:i | nibble := (fourNibbles bitShift: -4*(4-i)) bitAnd: 16rF.				16r11111111 * nibble])  "fill 32 bits with each 4-bit nibble"! !!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!bitPeekerFromForm: sourceForm	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."	| pixPerWord |	pixPerWord := 32 // sourceForm depth.	sourceForm unhibernate.	^ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)	 	sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: (pixPerWord - 1)@0		sourceOrigin: 0@0		extent: 1@1		clipRect: (0@0 extent: pixPerWord@1)! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 11/14/97 17:25'!colorAt: aPoint put: aColor	"Store the given color into the pixel at aPoint. The given color must match one of the colors in the receiver's colormap."	| i |	i := self colors indexOf: aColor		ifAbsent: [^ self error: 'trying to use a color that is not in my colormap'].	self pixelValueAt: aPoint put: i - 1.! !!WarpBlt class methodsFor: 'examples' stamp: ''!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 := Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 := Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp := (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p := Sensor cursorPoint.		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!GIFReadWriter methodsFor: 'private-bits access' stamp: ''!nextBits	| integer readBitCount shiftCount byte |	integer := 0.	remainBitCount = 0		ifTrue:			[readBitCount := 8.			shiftCount := 0]		ifFalse:			[readBitCount := remainBitCount.			shiftCount := remainBitCount - 8].	[readBitCount < codeSize]		whileTrue:			[byte := self nextByte.			byte == nil ifTrue: [^eoiCode].			integer := integer + (byte bitShift: shiftCount).			shiftCount := shiftCount + 8.			readBitCount := readBitCount + 8].	(remainBitCount := readBitCount - codeSize) = 0		ifTrue:	[byte := self nextByte]		ifFalse:	[byte := self peekByte].	byte == nil ifTrue: [^eoiCode].	^(integer + (byte bitShift: shiftCount)) bitAnd: maxCode! !!AnimatedGIFReadWriter class methodsFor: 'image reading/writing' stamp: 'mir 11/18/2003 17:00'!formsFromFileNamed: fileName 	| stream |	stream := FileStream readOnlyFileNamed: fileName.	^ self formsFromStream: stream! !!Bitmap methodsFor: 'filing' stamp: 'ar 2/3/2001 16:11'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size := bm size.	i := self encodeInt: size in: ba at: 1.	k := 1.	[k <= size] whileTrue:		[word := bm at: k.		lowByte := word bitAnd: 16rFF.		eqBytes := ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j := k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j := j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i := self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i := i+1]				ifFalse: [i := self encodeInt: j-k+1*4+2 in: ba at: i.						i := self encodeBytesOf: word in: ba at: i].			k := j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i := self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i := i+1.				k := k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j := j+1].				j = size ifTrue: [j := j + 1].				"We have one or more unmatching words, ending at j-1"				i := self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i := self encodeBytesOf: (bm at: m) in: ba at: i].				k := j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n := rawBytes := myBytes := 0.Form allInstancesDo:	[:f | f unhibernate.	b := f bits.	n := n + 1.	rawBytes := rawBytes + (b size*4).	myBytes := myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!TextStyle class methodsFor: 'user interface' stamp: 'sw 8/12/2004 19:08'!importFontsFromStyleFiles	"Import any and all of the fonts found in the default directory in files named ComicBold.style, ComicPlain.style, NewYork.style, Palatino.style, Courier.style"	| aName |	#('ComicBold' 'ComicPlain' 'NewYork' 'Palatino' 'Courier') do:		[:frag |			(TextStyle knownTextStyles includes: frag) ifFalse:				[(FileDirectory default fileExists: (aName := frag, '.style'))						ifTrue:							[TextStyle default collectionFromFileNamed: aName]]].! !!StrikeFont methodsFor: 'file in/out' stamp: 'md 11/14/2003 17:25'!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name := fileName copyUpTo: $..	"assumes extension (if any) is '.strike'"	strike := FileStream readOnlyFileNamed: name, '.strike.'.	strike binary.	"strip off direcory name if any"	startName := name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName := startName - 1].	name := name copyFrom: startName+1 to: name size.	type			:=		strike nextWord.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		:=		strike nextWord.	maxAscii		:=		strike nextWord.	maxWidth		:=		strike nextWord.	strikeLength	:=		strike nextWord.	ascent			:=		strike nextWord.	descent			:=		strike nextWord.	"xOffset			:="		strike nextWord. 		raster16			:=		strike nextWord.		superscript		:=		ascent - descent // 3.		subscript		:=		descent - ascent // 3.		emphasis		:=		0.	glyphs			:=	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable := (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	characterToGlyphMap := nil.! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57'!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor := aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!BitBlt methodsFor: 'copying' stamp: ''!fill: destRect fillColor: grayForm rule: rule	"Fill with a Color, not a Form. 6/18/96 tk"	sourceForm := nil.	self fillColor: grayForm.		"sets halftoneForm"	combinationRule := rule.	destX := destRect left.	destY := destRect top.	sourceX := 0.	sourceY := 0.	width := destRect width.	height := destRect height.	self copyBits! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'md 11/14/2003 16:51'!readHeader	| xMin xMax yMin yMax |	self next.	"skip over manufacturer field"	version := self next.	encoding := self next.	bitsPerPixel := self next.	xMin := self nextWord.	yMin := self nextWord.	xMax := self nextWord.	yMax := self nextWord.	width := xMax - xMin + 1.	height := yMax - yMin + 1.	self next: 4. "skip over device resolution"	self next: 49. "skip over EGA color palette"	colorPlanes := self next.	rowByteSize := self nextWord.	isGrayScale := (self next: 2) = 2.	self next: 58. "skip over filler"! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 9/23/2002 16:30'!readF12FromStream: aStream	| box blt |	minAscii := 0.	maxAscii := 94*94.	ascent := 12.	descent := 0.	pointSize := 12.	superscript := 0.	subscript := 0.	emphasis := 0.	maxWidth := 12.		box := Form extent: 12@12.	glyphs  := Form extent: (94*94*12)@12.	blt := BitBlt toForm: glyphs. 	xTable := XTableForFixedFont new.	xTable maxAscii: maxAscii + 3.	xTable width: 12.	1 to: 256 do:  [:index | 		1 to: 12 do: [:i |			aStream next.		].	].	(minAscii + 1 to: 94*94) do:  [:index | 		self readCharacter: (box bits) from: aStream.		blt copy: ((12*(index-1))@0 extent: 12@12) from: 0@0 in: box.	].! !!ImageReadWriter methodsFor: 'private' stamp: 'sd 1/30/2004 15:18'!on: aStream	(stream := aStream) reset.	stream binary.	"Note that 'reset' makes a file be text.  Must do this after."! !!TextStyle class methodsFor: 'instance creation' stamp: ''!initDefaultFontsAndStyle	"This provides the system with 10 and 12-pt basal fonts.	Bold and italic versions will be automatically generated as needed"	| fontArray |		fontArray := Array new: 2.	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: fontArray).	"TextStyle initDefaultFontsAndStyle."! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:03'!readPlainBW	"plain BW"	| val form poker |	form := Form extent: cols@rows depth: depth.	poker := BitBlt current bitPokerToForm: form.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			[val := stream next. (val = $0 or:[val = $1])] whileFalse:[				val ifNil:[self error:'End of file reading PBM'].			].			poker pixelAt: x@y put: (val asInteger).		]	].	^form! !!Bitmap class methodsFor: 'instance creation' stamp: 'ar 12/23/1999 14:35'!newFromStream: s	| len |	s next = 16r80 ifTrue:		["New compressed format"		len := self decodeIntFrom: s.		^ Bitmap decompressFromByteArray: (s nextInto: (ByteArray new: len))].	s skip: -1.	len := s nextInt32.	len <= 0		ifTrue: ["Old compressed format"				^ (self new: len negated) readCompressedFrom: s]		ifFalse: ["Old raw data format"				^ s nextWordsInto: (self new: len)]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'ar 3/4/2001 21:34'!idctBlockInt: anArray qt: qt	|  ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |	ws := Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	shift := 1 bitShift: ConstBits - Pass1Bits.	1 to: DCTSize do:		[:i |		anACTerm := nil.		1 to: DCTSize-1 do:[:row|			anACTerm ifNil:[				(anArray at: row * DCTSize + i) = 0 ifFalse:[anACTerm := row]]].		anACTerm == nil			ifTrue:				[dcval := (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.				0 to: DCTSize-1 do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 := (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 := (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 := (z2 + z3) * FIXn0n541196100.				t2 := z1 + (z3 * FIXn1n847759065 negated).				t3 := z1 + (z2 * FIXn0n765366865).				z2 := (anArray at: i) * (qt at: i).				z3 := (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 := (z2 + z3) bitShift: ConstBits.				t1 := (z2 - z3) bitShift: ConstBits.				t10 := t0 + t3.				t13 := t0 - t3.				t11 := t1 + t2.				t12 := t1 - t2.				t0 := (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 := (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 := (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 := (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 := t0 + t3.				z2 := t1 + t2.				z3 := t0 + t2.				z4 := t1 + t3.				z5 := (z3 + z4) * FIXn1n175875602.				t0 := t0 * FIXn0n298631336.				t1 := t1 * FIXn2n053119869.				t2 := t2 * FIXn3n072711026.				t3 := t3 * FIXn1n501321110.				z1 := z1 * FIXn0n899976223 negated.				z2 := z2 * FIXn2n562915447 negated.				z3 := z3 * FIXn1n961570560 negated.				z4 := z4 * FIXn0n390180644 negated.				z3 := z3 + z5.				z4 := z4 + z5.				t0 := t0 + z1 + z3.				t1 := t1 +z2 +z4.				t2 := t2 + z2 + z3.				t3 := t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].	"Pass 2: process rows from work array, store back into anArray"	shift := 1 bitShift: ConstBits + Pass1Bits + 3.	0 to: DCTSize2-DCTSize by: DCTSize do:		[:i |		z2 := ws at: i + 3.		z3 := ws at: i + 7.		z1 := (z2 + z3) * FIXn0n541196100.		t2 := z1 + (z3 * FIXn1n847759065 negated).		t3 := z1 + (z2 * FIXn0n765366865).		t0 := (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.		t1 := (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.		t10 := t0 + t3.		t13 := t0 - t3.		t11 := t1 + t2.		t12 := t1 -t2.		t0 := ws at: (i + 8).		t1 := ws at: (i + 6).		t2 := ws at: (i + 4).		t3 := ws at: (i + 2).		z1 := t0 + t3.		z2 := t1 + t2.		z3 := t0 + t2.		z4 := t1 + t3.		z5 := (z3 + z4) * FIXn1n175875602.		t0 := t0 * FIXn0n298631336.		t1 := t1 * FIXn2n053119869.		t2 := t2 * FIXn3n072711026.		t3 := t3 * FIXn1n501321110.		z1 := z1 * FIXn0n899976223 negated.		z2 := z2 * FIXn2n562915447 negated.		z3 := z3 * FIXn1n961570560 negated.		z4 := z4 * FIXn0n390180644 negated.		z3 := z3 + z5.		z4 := z4 + z5.		t0 := t0 + z1 + z3.		t1 := t1 + z2 + z4.		t2 := t2 + z2 + z3.		t3 := t3 + z1 + z4.		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].! !!BitBlt methodsFor: 'copying' stamp: ''!copyForm: srcForm to: destPt rule: rule fillColor: color	sourceForm := srcForm.	self fillColor: color.	"sets halftoneForm"	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	self copyBits! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'yo 3/17/2005 11:10'!addNewFontSize: pointSize	"Add a font in specified size to the array of fonts."	| f d newArray t isSet fallbackStyle |	fontArray first emphasis ~= 0 ifTrue: [		t := TextConstants at: self fontArray first familyName asSymbol.		t fonts first emphasis = 0 ifTrue: [			^ t addNewFontSize: pointSize.		].	].	pointSize <= 0 ifTrue: [^ nil].	fontArray do: [:s |		s pointSize = pointSize ifTrue: [^ s].	].	(isSet := fontArray first isKindOf: TTCFontSet) 	ifTrue:[		| fonts |		fonts := fontArray first fontArray collect: [ :font |			| newFont |			(font isNil)			ifTrue: [newFont := nil]			ifFalse: [				newFont := (font ttcDescription size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				newFont ttcDescription: font ttcDescription.				newFont pixelSize: pointSize * 96 // 72.				font derivativeFonts notEmpty ifTrue: [font derivativeFonts do: [ :proto |					proto ifNotNil: [						d := proto class new initialize.						d ttcDescription: proto ttcDescription.						d pixelSize: newFont pixelSize.						newFont derivativeFont: d]]].				].			newFont].		f := TTCFontSet newFontArray: fonts]	ifFalse: [		f := TTCFont new initialize.		f ttcDescription: fontArray first ttcDescription.		f pointSize: pointSize.		fontArray first derivativeFonts do: [:proto |			proto ifNotNil: [				d := TTCFont new initialize.				d ttcDescription: proto ttcDescription.				d pointSize: f pointSize.				f derivativeFont: d.			].		].	].	isSet ifFalse: [		fallbackStyle := TextStyle named: (fontArray first fallbackFont textStyleName).	].	newArray := ((fontArray copyWith: f) asSortedCollection: [:a :b | a pointSize <= b pointSize]) asArray.	self newFontArray: newArray.	isSet ifTrue: [		TTCFontSet register: newArray at: newArray first familyName asSymbol.	].	isSet ifFalse: [		f setupDefaultFallbackFontTo: fallbackStyle.		f derivativeFonts do: [:g | g setupDefaultFallbackFontTo: fallbackStyle].	].	^ self fontOfPointSize: pointSize! !!Pen methodsFor: 'geometric designs' stamp: ''!hilbert: n side: s 	"Draw an nth level Hilbert curve with side length s in the center of the 	screen. Write directly into the display's bitmap only. A Hilbert curve is 	a space-filling curve."	| a m |	n = 0 ifTrue: [^self turn: 180].	n > 0		ifTrue: 			[a := 90.			m := n - 1]		ifFalse: 			[a := -90.			m := n + 1].	self turn: a.	self hilbert: 0 - m side: s.	self turn: a; go: s.	self hilbert: m side: s.	self turn: 0 - a; go: s; turn: 0 - a.	self hilbert: m side: s.	self go: s; turn: a.	self hilbert: 0 - m side: s.	self turn: a	" 	(Pen new) hilbert: 3 side: 8. 	(Pen new sourceForm: Cursor wait) combinationRule: Form under; 	hilbert: 3 side: 25.	"! !!ColorForm methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:44'!colormapIfNeededFor: destForm	| newMap color pv |	(self hasNonStandardPalette or:[destForm hasNonStandardPalette]) ifFalse:[		^self colormapIfNeededForDepth: destForm depth.	].	colors == nil ifTrue: [		"use the standard colormap"		^ super colormapIfNeededFor: destForm].	(destForm depth = cachedDepth and:[cachedColormap isColormap]) 		ifTrue: [^ cachedColormap].	newMap := WordArray new: (1 bitShift: self depth).	1 to: colors size do: [:i |		color := colors at: i.		pv := destForm pixelValueFor: color.		(pv = 0 and:[color isTransparent not]) ifTrue:[pv := 1].		newMap at: i put: pv].	cachedDepth := destForm depth.	^cachedColormap := ColorMap shifts: nil masks: nil colors: newMap.! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!transformBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from global to local coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self transform: aRectangle topLeft)			corner: (self transform: aRectangle bottomRight)]	ifFalse:		[outerRect := Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self transform: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!Color methodsFor: 'conversions' stamp: ''!pixelWordForDepth: depth	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| pixelValue |	pixelValue := self pixelValueForDepth: depth.	^ self pixelWordFor: depth filledWith: pixelValue! !!Cursor class methodsFor: 'class initialization' stamp: 'JMM 10/21/2003 18:57'!initBottomRight	BottomRightCursor := 		(Cursor extent: 16@16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16@-16).! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:42'!fadeImageCoarse: otherImage at: topLeft	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j d |	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do: [:q | pix := pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[j := i-1//4+1.		(0 to: 28 by: 4) do: [:k |			mask bits at: j+k				put: ((mask bits at: j+k) bitOr: (pix bitShift: i-1\\4*d))].		"mask display." true]		ifFalse: [false]]! !!Color class methodsFor: 'other' stamp: ''!pixelScreenForDepth: depth	"Return a 50% stipple containing alternating pixels of all-zeros and all-ones to be used as a mask at the given depth."	| mask bits |	mask := (1 bitShift: depth) - 1.	bits := 2 * depth.	[bits >= 32] whileFalse: [		mask := mask bitOr: (mask bitShift: bits).  "double the length of mask"		bits := bits + bits].	^ Bitmap with: mask with: mask bitInvert32! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:12'!tabletScaleFactor	"Answer a Point that scales tablet coordinates to Display coordinates, where the full extent of the tablet maps to the extent of the entire Display."	| tabletExtent |	tabletExtent := Sensor tabletExtent.	^ (Display width asFloat / tabletExtent x) @ (Display height asFloat / tabletExtent y)! !!WarpBlt class methodsFor: 'form rotation' stamp: 'nk 4/17/2004 19:45'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect := srcForm boundingBox.	center := srcRect center.	radians := angleInDegrees degreesToRadians.	dstOrigin := dstCorner := center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p := ((corner - center) scaleBy: scalePoint) + center.		p := (p rotateBy: radians about: center) rounded.		dstOrigin := dstOrigin min: p.		dstCorner := dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect := dstOrigin corner: dstCorner.	inverseScale := (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad := dstRect innerCorners collect: [:corner |		p := corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc := srcForm.	(srcForm isColorForm)		ifTrue: [			cellSize > 1 | true "ar 12/27/2001: Always enable - else sketches won't work"				ifTrue: [					warpSrc := Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm := Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm := srcForm class extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm := srcForm class extent: dstRect extent depth: srcForm depth].	(WarpBlt toForm: dstForm)		sourceForm: warpSrc;		colorMap: (warpSrc colormapIfNeededFor: dstForm);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm isColorForm) ifTrue: [dstForm colors: srcForm colors copy].	newCenter := (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/14/2001 23:32'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm := srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule := rule.	destOrigin := destRectangle origin.	destX := destOrigin x.	destY := destOrigin y.	sourceX := sourcePt x.	sourceY := sourcePt y.	width := destRectangle width.	height := destRectangle height.	srcForm == nil ifFalse:		[colorMap := srcForm colormapIfNeededFor: destForm].	^ self copyBits! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'jmv 12/7/2001 13:49'!uncompress: aByteArray into: aForm	"Uncompress an image from the given ByteArray into the given Form.	Fails if the given Form has the wrong dimensions or depth.	If aForm has depth 16, do ordered dithering."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	aForm unhibernate.	jpegDecompressStruct := ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w := self primImageWidth: jpegDecompressStruct.	h := self primImageHeight: jpegDecompressStruct.	((aForm width = w) & (aForm height = h)) ifFalse: [		^ self error: 'form dimensions do not match'].	"odd width images of depth 16 give problems; avoid them"	w odd		ifTrue: [			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]		ifFalse: [			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].	self primJPEGReadImage: jpegDecompressStruct		fromByteArray: aByteArray		onForm: aForm		doDithering: true		errorMgr: jpegErrorMgr2Struct.! !!Form methodsFor: 'accessing' stamp: ''!offset: aPoint	offset := aPoint! !!StrikeFont methodsFor: 'character shapes' stamp: 'RAA 7/6/2000 16:50'!makeCarriageReturnsWhite	| crForm |	"Some larger fonts have a gray carriage return (from the zero wide fixup) make it white so it doesn't show"	crForm := self characterFormAt: 13 asCharacter.	crForm fillWhite.	self characterFormAt: 13 asCharacter put: crForm.! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'RAA 5/4/2001 13:52'!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	^true! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/25/2005 13:48'!read24BmpFile	"Read 24-bit pixel data from the given a BMP stream."	| form formBits pixelLine bitsIndex bitBlt |	form := Form extent: biWidth@biHeight depth: 32.	pixelLine := ByteArray new: (((24 * biWidth) + 31) // 32) * 4.	bitsIndex := form height - 1 * biWidth + 1.	formBits := form bits.	1 to: biHeight do: [:i |		pixelLine := stream nextInto: pixelLine.		self read24BmpLine: pixelLine into: formBits startingAt: bitsIndex width: biWidth.		bitsIndex := bitsIndex - biWidth.	].	bitBlt := BitBlt toForm: form.	bitBlt combinationRule: 7 "bitOr:with:".	bitBlt halftoneForm: (Bitmap with: 16rFF000000).	bitBlt copyBits.	^ form! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 6/16/2002 15:20'!readHeader	| reserved |	bfType := stream nextLittleEndianNumber: 2.	bfSize := stream nextLittleEndianNumber: 4.	reserved := stream nextLittleEndianNumber: 4.	bfOffBits := stream nextLittleEndianNumber: 4.	biSize := stream nextLittleEndianNumber: 4.	biWidth := stream nextLittleEndianNumber: 4.	biHeight := stream nextLittleEndianNumber: 4.	biPlanes := stream nextLittleEndianNumber: 2.	biBitCount := stream nextLittleEndianNumber: 2.	biCompression := stream nextLittleEndianNumber: 4.	biSizeImage := stream nextLittleEndianNumber: 4.	biXPelsPerMeter := stream nextLittleEndianNumber: 4.	biYPelsPerMeter := stream nextLittleEndianNumber: 4.	biClrUsed := stream nextLittleEndianNumber: 4.	biClrImportant := stream nextLittleEndianNumber: 4.! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 5/24/2004 17:54'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g := glyphs deepCopy.	bonkForm := (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs := g.	fallbackFont ifNotNil: [		fallbackFont := fallbackFont emphasized: 1	].! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/15/2003 15:48'!writeHeader: myType	"this is ascii"	stream nextPut: ($P asciiValue).	stream nextPut: (myType asciiValue).	stream nextPut: 10.		"nl"	pragma ifNotNil:[		stream nextPutAll: (pragma asByteArray).	].	stream nextPutAll: (cols printString) asByteArray.	stream nextPut: 32.		" "	stream nextPutAll: (rows printString) asByteArray.	stream nextPut: 10.		"nl"	depth > 1 ifTrue: [| d c maxV |		d := {1 . 2 . 4  . 8   . 16 . 32}.		c := {1 . 3 . 15 . 255 . 31 . 255}. 		maxV := nil.		1 to: d size do:[:i| ((d at: i) = depth and:[maxV = nil]) ifTrue:[maxV := c at: i]].		stream nextPutAll: (maxV printString) asByteArray.		stream nextPut: 10.		"nl"	]	! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'ar 3/4/2001 17:40'!processRestart	stream resetBitBuffer.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo := restartInterval.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'nk 9/1/2004 14:28'!fromUser: priorFont allowKeyboard: aBoolean	"rr 3/23/2004 10:02 : made the menu invoked modally, thus allowing	keyboard control" 	"StrikeFont fromUser"	"Present a menu of available fonts, and if one is chosen, return it.	Otherwise return nil."	| fontList fontMenu style active ptMenu label spec font |	fontList := StrikeFont actualFamilyNames.	fontMenu := MenuMorph new defaultTarget: self.	fontList do: [:fontName |		style := TextStyle named: fontName.		active := priorFont familyName sameAs: fontName.		ptMenu := MenuMorph new defaultTarget: self.		style pointSizes do: [:pt |			(active and:[pt = priorFont pointSize]) 				ifTrue:[label := '<on>'] 				ifFalse:[label := '<off>'].			label := label, pt printString, ' pt'.			ptMenu add: label 				target: fontMenu				selector: #modalSelection:				argument: {fontName. pt}].		style isTTCStyle ifTrue: [			ptMenu add: 'new size'				target: style selector: #addNewFontSizeDialog: argument: {fontName. fontMenu}.		].		active ifTrue:[label := '<on>'] ifFalse:[label := '<off>'].		label := label, fontName.		fontMenu add: label subMenu: ptMenu].	spec := fontMenu invokeModalAt: ActiveHand position in: ActiveWorld allowKeyboard: aBoolean.	spec ifNil: [^ nil].	style := TextStyle named: spec first.	style ifNil: [^ self].	font := style fonts detect: [:any | any pointSize = spec last] ifNone: [nil].	^ font! !!StrikeFont methodsFor: 'Mac reader' stamp: 'ar 5/23/2000 12:49'!readMacFontHex: fileName	"Read the hex version of a Mac FONT type resource.  See the method aComment for how to prepare the input file. 4/26/96 tk"	| file hh fRectWidth |	name := fileName.	"Palatino 12"	file := FileStream readOnlyFileNamed: fileName, ' hex'.	"See Inside Macintosh page IV-42 for this record"	"FontType := " Number readFrom: (file next: 4) base: 16.	emphasis		:=		0.	minAscii := Number readFrom: (file next: 4) base: 16.	maxAscii := Number readFrom: (file next: 4) base: 16.	maxWidth		:= Number readFrom: (file next: 4) base: 16.	"kernMax := " Number readFrom: (file next: 4) base: 16.	"NDescent := " Number readFrom: (file next: 4) base: 16.	fRectWidth :=  Number readFrom: (file next: 4) base: 16.	hh :=  Number readFrom: (file next: 4) base: 16.	"OWTLoc := " Number readFrom: (file next: 4) base: 16.	ascent			:= Number readFrom: (file next: 4) base: 16.	descent			:= Number readFrom: (file next: 4) base: 16.	"leading := " Number readFrom: (file next: 4) base: 16.	xOffset			:=		0. 		raster			:= Number readFrom: (file next: 4) base: 16.	strikeLength	:=		raster*16.	superscript		:=		ascent - descent // 3.		subscript		:=		descent - ascent // 3.		self strikeFromHex: file width: raster height: hh.	self xTableFromHex: file.	file close.	"Insert one pixel between each character.  And add space character."	self fixKerning: (fRectWidth - maxWidth).		"Recompute character to glyph mapping"	characterToGlyphMap := nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	dp := DiskProxy global: #StrikeFont selector: #familyName:size:emphasized:			args: (Array with: self familyName   with: self height					with: self emphasis).	refStrm replace: self with: dp.	^ dp! !!Color class methodsFor: 'color from user' stamp: 'jm 1/19/1999 11:33'!colorTest: depth extent: chartExtent colorMapper: colorMapper	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 7) asInteger / 7			g: (c green * 7) asInteger / 7			b: (c blue * 3) asInteger / 3]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 5) asInteger / 5			g: (c green * 5) asInteger / 5			b: (c blue * 5) asInteger / 5]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 15) asInteger / 15			g: (c green * 15) asInteger / 15			b: (c blue * 15) asInteger / 15]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 31) asInteger / 31			g: (c green * 31) asInteger / 31			b: (c blue * 31) asInteger / 31]) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette := Form extent: chartExtent depth: depth.	transCaption := "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt := transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth := 10.	startHue := 338.0.	vSteps := palette height - transHt // 2.	hSteps := palette width - grayWidth.	x := 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue := Color h: h asFloat s: 1.0 v: 1.0.		y := transHt+1.		0 to: vSteps do: [:n | 			c := basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			c := colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		1 to: vSteps do: [:n | 			c := Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			c := colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		x := x + 1].	y := transHt + 1.	1 to: vSteps * 2 do: [:n | 		c := Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		c := colorMapper value: c.		palette fill: (x@y extent: 10@1) fillColor: c.		y := y + 1].	^ palette! !!Cursor methodsFor: 'converting' stamp: 'RAA 8/14/2000 10:14'!asCursorForm	| form |	form := StaticForm extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/11/2004 01:02'!processPLTEChunk	| colorCount i |	colorCount := chunk size // 3. "TODO - validate colorCount against depth"	palette := Array new: colorCount.	0 to: colorCount-1 do: [ :index |		i := index * 3 + 1.		palette at: index+1 put:			(Color r: (chunk at: i)/255.0 g: (chunk at: i+1)/255.0 b: (chunk at: i+2)/255.0)		].! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'sd 1/30/2004 15:19'!nextImageSuggestedDepth: depth	"Decode and answer a Form of the given depth from my stream. Close the stream if it is a file stream. Possible depths are 16-bit and 32-bit."	| bytes width height form jpegDecompressStruct jpegErrorMgr2Struct depthToUse |	bytes := stream upToEnd.	stream close.	jpegDecompressStruct := ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: bytes		errorMgr: jpegErrorMgr2Struct.	width := self primImageWidth: jpegDecompressStruct.	height := self primImageHeight: jpegDecompressStruct.	"Odd width images of depth 16 gave problems. Avoid them (or check carefully!!)"	depthToUse := ((depth = 32) | width odd) ifTrue: [32] ifFalse: [16].	form := Form extent: width@height depth: depthToUse.	(width = 0 or: [height = 0]) ifTrue: [^ form].	self		primJPEGReadImage: jpegDecompressStruct		fromByteArray: bytes		onForm: form		doDithering: true		errorMgr: jpegErrorMgr2Struct.	^ form! !!MorphicTransform methodsFor: 'private' stamp: ''!setOffset: aPoint angle: a scale: s	offset := aPoint.	angle := a.	scale := s! !!ColorForm methodsFor: 'accessing' stamp: 'mir 7/21/1999 11:51'!colorsFromArray: colorArray	| colorList |	colorList := colorArray collect: [:colorDef |		Color fromArray: colorDef].	self colors: colorList! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55'!alphaMixed: proportion with: aColor 	"Answer this color mixed with the given color. The proportion, a number 	between 0.0 and 1.0, determines what what fraction of the receiver to  	use in the mix. For example, 0.9 would yield a color close to the  	receiver. This method uses RGB interpolation; HSV interpolation can lead 	to surprises.  Mixes the alphas (for transparency) also."	| frac1 frac2 |	frac1 := proportion asFloat min: 1.0 max: 0.0.	frac2 := 1.0 - frac1.	^ Color		r: self red * frac1 + (aColor red * frac2)		g: self green * frac1 + (aColor green * frac2)		b: self blue * frac1 + (aColor blue * frac2)		alpha: self alpha * frac1 + (aColor alpha * frac2)! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!acTableIndex: anInteger	acTableIndex := anInteger! !!DisplayScanner methodsFor: 'private' stamp: 'hmm 9/16/2000 21:29'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt := aBitBlt.	bitBlt sourceX: 0; width: 0.	"Init BitBlt so that the first call to a primitive will not fail"	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!IdentityTransform class methodsFor: 'class initialization' stamp: 'ar 9/11/2000 21:24'!initialize	"IdentityTransform initialize"	Default := self basicNew.! !!Form class methodsFor: 'instance creation' stamp: 'ar 5/28/2000 12:07'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius := diameter//2.	form := self extent: diameter@diameter offset: (0@0) - (radius@radius).		bb := (BitBlt current toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect := form boundingBox.	centerX := rect center x.	centerY := rect center y.	centerYBias := rect height odd ifTrue: [0] ifFalse: [1].	centerXBias := rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared := (rect height asFloat / 2.0) squared - 0.01.	xOverY := rect width asFloat / rect height asFloat.	maxy := rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx := ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"! !!GIFReadWriter class methodsFor: 'class initialization' stamp: ''!initialize	"GIFReadWriter initialize"	ImageSeparator := $, asInteger.	Extension := $!! asInteger.	Terminator := $; asInteger.! !!FontSet class methodsFor: 'private' stamp: 'sma 12/29/1999 12:58'!fontSetClass: aString	| className fontSet |	className := (self name , (aString select: [:c | c isAlphaNumeric]) capitalized) asSymbol.	fontSet := Smalltalk		at: className		ifAbsentPut: [self			subclass: className			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self fontCategory].	(fontSet inheritsFrom: self) ifFalse: [^ self error: 'The name ' , className , ' is already in use'].	^ fontSet! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'di 10/19/97 12:05'!slideFrom: startPoint to: stopPoint nSteps: nSteps delay: milliSecs andStay: stayAtEnd	"Does not display at the first point, but does at the last.	Moreover, if stayAtEnd is true, it leaves the dragged image at the stopPoint"	| i done |	i := 0.	^ self follow: [startPoint + ((stopPoint-startPoint) * i // nSteps)]		while: [milliSecs ifNotNil: [(Delay forMilliseconds: milliSecs) wait].				((done := (i := i+1) > nSteps) and: [stayAtEnd])					ifTrue: [^ self "Return without clearing the image"].				done not]! !!Color class methodsFor: 'colormaps' stamp: 'jm 12/4/97 15:25'!computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."	| mask map c |	(#(3 4 5) includes: bitsPerColor)		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].	mask := (1 bitShift: bitsPerColor) - 1.	map := Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		c := Color			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)			b: ((i bitShift: 0) bitAnd: mask)			range: mask.		map at: i + 1 put: (c pixelValueForDepth: destDepth)].	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"	^ map! !!DisplayObject methodsFor: 'displaying-Display' stamp: ''!follow: locationBlock while: durationBlock   "Move an image around on the Display. Restore the background   continuously without causing flashing. The argument, locationBlock,   supplies each new location, and the argument, durationBlock, supplies   true to continue, and then false to stop.   8/20/96 sw: call follow:while:bitsBehind: to do the real work.  Note that thmethod   now returns the final bits behind as method value."    | bitsBehind loc |   bitsBehind := Form fromDisplay: ((loc := locationBlock value) extent: self extent).   ^ self follow: locationBlock while: durationBlock bitsBehind: bitsBehind startingLoc: loc! !!ImageReadWriter methodsFor: 'private' stamp: ''!hasMagicNumber: aByteArray	| position |	position := stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!dcTableIndex: anInteger	dcTableIndex := anInteger! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!text: t textStyle: ts	text := t.	textStyle := ts! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'mu 8/17/2003 00:42'!writeAttributesOn: file	| colorArray |	super writeAttributesOn: file.	colorArray := self colors asColorArray.	1 to: (2 raisedTo: depth) do: [:idx |		file nextLittleEndianNumber: 4 put: (colorArray basicAt: idx).	] ! !!Color class methodsFor: 'colormaps' stamp: 'jm 3/25/1999 19:48'!computeColormapFrom: sourceDepth to: destDepth	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."	| map bitsPerColor |	sourceDepth < 16 ifTrue: [		"source is 1-, 2-, 4-, or 8-bit indexed color"		map := (IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))					collect: [:c | c pixelValueForDepth: destDepth].		map := map as: Bitmap.	] ifFalse: [		"source is 16-bit or 32-bit RGB"		destDepth > 8			ifTrue: [bitsPerColor := 5]  "retain maximum color resolution"			ifFalse: [bitsPerColor := 4].		map := self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].	"Note: zero is transparent except when source depth is one-bit deep"	sourceDepth > 1 ifTrue: [map at: 1 put: 0].	^ map! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'hmm 2/2/2001 15:07'!indentationLevel: anInteger	super indentationLevel: anInteger.	nextLeftMargin := leftMargin.	indentationLevel timesRepeat: [		nextLeftMargin := textStyle nextTabXFrom: nextLeftMargin					leftMargin: leftMargin					rightMargin: rightMargin]! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'nk 3/15/2004 19:25'!replaceFontsIn: oldFontArray with: newStyle	"	TextStyle replaceFontsIn: (TextStyle looseFontsFromFamily: #Accuny) with: (TextStyle named: #Accuny)	"	"Try to find corresponding fonts in newStyle and substitute them for the fonts in oldFontArray"	newStyle fontArray do: [ :newFont | newFont releaseCachedState ].	oldFontArray do: [ :oldFont | | newFont |		oldFont reset.		newFont := (newStyle fontOfPointSize: oldFont pointSize) emphasis: oldFont emphasis.		oldFont becomeForward: newFont ].	StringMorph allSubInstancesDo: [ :s | s layoutChanged ].	TextMorph allSubInstancesDo: [ :s | s layoutChanged ].	SystemWindow allInstancesDo: [ :w | [ w update: #relabel ] on: Error do: [ :ex | ] ].	World ifNotNilDo: [ :w | w changed ].! !!DisplayText methodsFor: 'accessing' stamp: ''!text: aText 	"Set the receiver to display the argument, aText."		text := aText.	form := nil.	self changed.	! !!Rectangle methodsFor: 'accessing' stamp: ''!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 := self topLeft corner: self bottomRight - (1@1).	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !!Color class methodsFor: 'class initialization' stamp: ''!initializeIndexedColors	"Build an array of colors corresponding to the fixed colormap used	 for display depths of 1, 2, 4, or 8 bits."	"Color initializeIndexedColors"	| a index grayVal |	a := Array new: 256.	"1-bit colors (monochrome)"	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"	"additional colors for 2-bit color"	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"	"additional colors for 4-bit color"	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"	"additional colors for 8-bit color"	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"	index := 17.	1 to: 31 do: [:v |		(v \\ 4) = 0 ifFalse: [			grayVal := v / 32.0.			a at: index put: (Color r: grayVal g: grayVal b: grayVal).			index := index + 1]].	"The remainder of color table defines a color cube with six steps	 for each primary color. Note that the corners of this cube repeat	 previous colors, but this simplifies the mapping between RGB colors	 and color map indices. This color cube spans indices 40 through 255	 (indices 41-256 in this 1-based array)."	0 to: 5 do: [:r |		0 to: 5 do: [:g |			0 to: 5 do: [:b |				index := 41 + ((36 * r) + (6 * b) + g).				index > 256 ifTrue: [					self error: 'index out of range in color table compuation'].				a at: index put: (Color r: r g: g b: b range: 5)]]].	IndexedColors := a.! !!StrikeFont methodsFor: 'multibyte character methods' stamp: 'yo 1/6/2005 04:18'!hasGlyphOf: aCharacter	| code |	code := aCharacter charCode.	((code between: self minAscii and: self maxAscii) not) ifTrue: [		^ false.	].	(xTable at: code + 1) < 0 ifTrue: [		^ false.	].	^ true.! !!DisplayScanner methodsFor: 'scanning' stamp: 'yo 10/7/2002 18:38'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	destY := lineY + line baseline - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		lastIndex > runStopIndex ifTrue: [done := true].	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!BitBlt class methodsFor: 'instance creation' stamp: 'di 3/2/98 12:53'!bitPokerToForm: destForm	"Answer an instance to be used for valueAt: aPoint put: pixValue.	The source for a 1x1 copyBits will be the low order of (bits at: 1)"	| pixPerWord |	pixPerWord := 32//destForm depth.	destForm unhibernate.	^ self destForm: destForm	 	sourceForm: (Form extent: pixPerWord@1 depth: destForm depth)		halftoneForm: nil combinationRule: Form over		destOrigin: 0@0 sourceOrigin: (pixPerWord-1)@0		extent: 1@1 clipRect: (0@0 extent: destForm extent)! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 20:42'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:[			byte := self next.			(byte = 16rFF and: [(self peekFor: 16r00) not])					ifTrue:						[self position: self position - 1.						^0].			bitBuffer := (bitBuffer bitShift: 8) bitOr: byte.			bitsInBuffer := bitsInBuffer + 8].	^ bitsInBuffer! !!DisplayText methodsFor: 'color' stamp: ''!foregroundColor: cf backgroundColor: cb	foreColor := cf.	backColor := cb! !!Cursor class methodsFor: 'class initialization' stamp: ''!initSquare	SquareCursor := 		(Cursor			extent: 16@16			fromArray: #(		2r0		2r0		2r0		2r0		2r0		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: -8@-8).	! !!BitBlt methodsFor: 'accessing' stamp: ''!destY: anInteger 	"Set the top left y coordinate of the receiver's destination form to be the 	argument, anInteger."	destY := anInteger! !!PenPointRecorder methodsFor: 'line drawing' stamp: 'md 11/14/2003 16:56'!drawFrom: p1 to: p2	"Overridden to skip drawing but track bounds of the region traversed."	points ifNil: [points := OrderedCollection with: p1].	points addLast: p2! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect := Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/4/2001 18:38'!initialSOSSetup	mcuWidth := (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight := (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	stream resetBitBuffer.! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 12:30'!defaultFontIndex	^ defaultFontIndex ifNil: [defaultFontIndex := 1]! !!Form methodsFor: 'private' stamp: 'ar 10/30/2000 23:22'!setResourceBits: aForm	"Private. Really. Used for setting the 'resource bits' when externalizing some form"	bits := aForm.! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'ar 3/4/2001 22:16'!nextSample	| dx dy blockIndex sampleIndex sample |	dx := currentX // hSampleFactor.	dy := currentY // vSampleFactor.	blockIndex := dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex := dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample := (mcuBlocks at: blockIndex) at: sampleIndex.	currentX := currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX := 0.			currentY := currentY + 1].	^ sample! !!BitBlt methodsFor: 'copying' stamp: 'ar 3/1/2004 13:49'!pixelAt: aPoint	"Assumes this BitBlt has been set up specially (see the init message,	BitBlt bitPeekerFromForm:.  Returns the pixel at aPoint."	sourceX := aPoint x.	sourceY := aPoint y.	destForm unhibernate. "before poking"	destForm bits at: 1 put: 0.  "Just to be sure"	self copyBits.	^ destForm bits at: 1! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 3/5/2002 09:57'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff := ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff := ReferenceStream fileNamed: fileName.	this := ff nextAndClose.	"Only works if file created by special code above"	newName := this fontArray first familyName.	this fontArray do: [:aFont | aFont familyName = newName ifFalse: [		self error: 'All must be same family']].	style := TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights := style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!Pen methodsFor: 'operations' stamp: ''!turn: degrees 	"Change the direction that the receiver faces by an amount equal to the 	argument, degrees."	direction := direction + degrees! !!StrikeFont methodsFor: 'Mac reader' stamp: ''!fixKerning: extraWidth	"Insert one pixel (extraWidth) between each character.  And add the bits for the space character"	"Create a space character Form.  Estimate width by ascent / 2 - 1"	| characterForm char leftX |	characterForm := Form extent: (ascent//2 - 1) @ self height.	self characterFormAt: $  put: characterForm.	"Put one pixel of space after every character.  Mac fonts have no space in the bitmap."	extraWidth <= 0 ifTrue: [^ self].	minAscii to: maxAscii do: [:ascii |		char := Character value: ascii.		leftX := xTable at: ascii + 1.		characterForm := Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.		].	! !!HostFont class methodsFor: 'accessing' stamp: 'yo 2/14/2004 01:57'!rangesForJapanese	| basics etc |	basics := {		Array with: 0 with: 255	}.	etc := {		Array with: 16r370 with: 16r3FF. "greek"		Array with: 16r400 with: 16r52F. "cyrillic"		Array with: 16r1D00 with: 16r1D7F. "phonetic"		Array with: 16r1E00 with: 16r1EFF. "latin extended additional"		Array with: 16r2000 with: 16r206F. "general punctuation"		Array with: 16r20A0 with: 16r20CF. "currency symbols"		Array with: 16r2100 with: 16r214F. "letterlike"		Array with: 16r2150 with: 16r218F. "number form"		Array with: 16r2190 with: 16r21FF. "arrows"		Array with: 16r2200 with: 16r22FF. "math operators"		Array with: 16r2300 with: 16r23FF. "misc tech"		Array with: 16r2460 with: 16r24FF. "enclosed alnum"		Array with: 16r2500 with: 16r257F. "box drawing"		Array with: 16r2580 with: 16r259F. "box elem"		Array with: 16r25A0 with: 16r25FF. "geometric shapes"		Array with: 16r2600 with: 16r26FF. "misc symbols"		Array with: 16r2700 with: 16r27BF. "dingbats"		Array with: 16r27C0 with: 16r27EF. "misc math A"		Array with: 16r27F0 with: 16r27FF. "supplimental arrow A"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2980 with: 16r29FF. "misc math B"		Array with: 16r2A00 with: 16r2AFF. "supplimental math op"		Array with: 16r2900 with: 16r297F. "supplimental arrow B"		Array with: 16r2E80 with: 16r2EFF. "cjk radicals suppliment"		Array with: 16r2F00 with: 16r2FDF. "kangxi radicals"		Array with: 16r3000 with: 16r303F. "cjk symbols"		Array with: 16r3040 with: 16r309F. "hiragana"		Array with: 16r30A0 with: 16r30FF. "katakana"		Array with: 16r3190 with: 16r319F. "kanbun"		Array with: 16r31F0 with: 16r31FF. "katakana extension"		Array with: 16r3200 with: 16r32FF. "enclosed CJK"		Array with: 16r3300 with: 16r33FF. "CJK compatibility"		Array with: 16r3400 with: 16r4DBF. "CJK unified extension A"		Array with: 16r4E00 with: 16r9FAF. "CJK ideograph"		Array with: 16rF900 with: 16rFAFF. "CJK compatiblity ideograph"		Array with: 16rFE30 with: 16rFE4F. "CJK compatiblity forms"		Array with: 16rFF00 with: 16rFFEF. "half and full"	}.	^ basics, etc.! !!FormStub methodsFor: 'accessing' stamp: 'ar 2/24/2001 22:02'!locator: aString	locator := aString! !!Form methodsFor: 'filling' stamp: 'di 2/19/1999 07:07'!anyShapeFill	"Fill the interior of the outermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape:fillColor: to paint a solid color.  See also convexShapeFill:"	| shape |	"Draw a seed line around the edge and fill inward from the outside."	shape := self findShapeAroundSeedBlock: [:f | f borderWidth: 1].	"Reverse so that this becomes solid in the middle"	shape := shape reverse.	"Finally erase any bits from the original so the fill is only elsewhere"	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 10/17/2001 10:10'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	self depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."		"bwForm := self makeBWForm: interiorColor."	"won't work for two whites"	interiorPixVal := self pixelValueAt: interiorPoint.	bwForm := Form extent: self extent.	map := Bitmap new: (1 bitShift: (self depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd := self depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd := bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color := Color colorFromPixelValue: interiorPixVal depth: self depth.				ind := color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm := bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	self eraseShape: bwForm.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!ImageReadWriter methodsFor: 'private' stamp: ''!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize := width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize := width * depth + newPad - 1 // newPad * (newPad / 8).	newBits := ByteArray new: dstRowByteSize * height.	srcRowBase := 1.	rowEndOffset := dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase := srcRowBase + srcRowByteSize].	^newBits! !!TextLineInterval methodsFor: 'updating' stamp: ''!slide: delta 	"Change the starting and stopping points of the line by delta."	start := start + delta.	stop := stop + delta! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'ar 2/11/2004 01:27'!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^ palette,{Color transparent}		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette,{Color transparent}.		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette,{Color transparent}		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		"??transparent??"		].! !!ColorForm methodsFor: 'copying' stamp: 'ar 5/28/2000 12:06'!copy: aRect 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."	| newForm |	newForm := self class extent: aRect extent depth: depth.	((BitBlt current		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: aRect origin		extent: aRect extent		clipRect: newForm boundingBox)		colorMap: nil) copyBits.	colors ifNotNil: [newForm colors: colors copy].	^ newForm! !!Form methodsFor: 'converting' stamp: 'ar 6/16/2002 17:44'!asFormOfDepth: d	| newForm |	d = self depth ifTrue:[^self].	newForm := Form extent: self extent depth: d.	(BitBlt current toForm: newForm)		colorMap: (self colormapIfNeededFor: newForm);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	^newForm! !!Cursor class methodsFor: 'class initialization' stamp: ''!initOrigin	OriginCursor :=   		(Cursor			extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0@0).! !!BitBlt methodsFor: 'private' stamp: ''!setDestForm: df	| bb |	bb := df boundingBox.	destForm := df.	clipX := bb left.	clipY := bb top.	clipWidth := bb width.	clipHeight := bb height! !!StrikeFont methodsFor: 'file in/out' stamp: 'ls 3/27/2000 17:43'!writeAsStrike2On: file	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!Form class methodsFor: 'examples' stamp: ''!exampleEdits	"In Form category editing are messages edit and bitEdit that make it possible to 	create editors on instances of Form. 	 	This is the general form editor:	| f | 	f := Form fromUser. 	f edit. 	 	This is the general bit editor:	| f | 	f := Form fromUser. 	f bitEdit."! !!Color methodsFor: 'other' stamp: 'tk 6/14/96'!display	"Show a swatch of this color tracking the cursor until the next mouseClick. "	"Color red display"	| f |	f := Form extent: 40@20 depth: Display depth.	f fillColor: self.	Cursor blank showWhile:		[f follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]]! !!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!wheel: thisMany	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "	| sat bri hue step c |	sat := self saturation.	bri := self brightness.	hue := self hue.	step := 360.0 / (thisMany max: 1).	^ (1 to: thisMany) collect: [:num |		c := Color h: hue s: sat v: bri.  "hue is taken mod 360"		hue := hue + step.		c]."(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]"! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 := 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Color methodsFor: 'private' stamp: 'di 11/2/97 12:19'!setPrivateRed: r green: g blue: b	"Initialize this color's r, g, and b components to the given values in the range [0..ComponentMax].  Encoded in a single variable as 3 integers in [0..1023]."	rgb == nil ifFalse: [self attemptToMutateError].	rgb := ((r min: ComponentMask max: 0) bitShift: RedShift) +		((g min: ComponentMask max: 0) bitShift: GreenShift) +		 (b min: ComponentMask max: 0).	cachedDepth := nil.	cachedBitPattern := nil.! !!BDFFontReader class methodsFor: 'resource download' stamp: 'nop 2/11/2001 00:24'!downloadFonts  "BDFFontReader downloadFonts"	"Download a standard set of BDF sources from x.org.  	The combined size of these source files is around 1.2M; after conversion 	to .sf2 format they may be deleted."	| heads tails filenames baseUrl basePath newUrl newPath document f |	heads := #( 'charR' 'courR' 'helvR' 'lubR' 'luRS' 'lutRS' 'ncenR' 'timR' ).	tails := #( '08' '10' '12' '14' '18' '24').	filenames := OrderedCollection new.	heads do: [:head |		filenames addAll: (tails collect: [:tail | head , tail , '.bdf'])	].	baseUrl := Url absoluteFromText: 'http://ftp.x.org/pub/R6.4/xc/fonts/bdf/75dpi/'.	basePath := baseUrl path.	filenames do: [:filename |		newUrl := baseUrl clone.		newPath := OrderedCollection newFrom: basePath.		newPath addLast: filename.		newUrl path: newPath.		Utilities informUser: 'Fetching ' , filename during: 			[document := newUrl retrieveContents].		f := CrLfFileStream newFileNamed: filename.		f nextPutAll: document content.		f close.	].! !!Rectangle methodsFor: 'rectangle functions' stamp: ''!quickMerge: aRectangle 	"Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."	| useRcvr rOrigin rCorner minX maxX minY maxY |	useRcvr := true.	rOrigin := aRectangle topLeft.	rCorner := aRectangle bottomRight.	minX := rOrigin x < origin x ifTrue: [useRcvr := false. rOrigin x] ifFalse: [origin x].	maxX := rCorner x > corner x ifTrue: [useRcvr := false. rCorner x] ifFalse: [corner x].	minY := rOrigin y < origin y ifTrue: [useRcvr := false. rOrigin y] ifFalse: [origin y].	maxY := rCorner y > corner y ifTrue: [useRcvr := false. rCorner y] ifFalse: [corner y].	useRcvr		ifTrue: [^ self]		ifFalse: [^ Rectangle origin: minX@minY corner: maxX@maxY].! !!Color class methodsFor: 'examples' stamp: ''!showColors: colorList	"Display the given collection of colors across the top of the Display."	| w r |	w := Display width // colorList size.	r := 0@0 extent: w@((w min: 30) max: 10).	colorList do: [:c |		Display fill: r fillColor: c.		r := r translateBy: w@0].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/10/2004 23:55'!processIHDRChunk	width := chunk longAt: 1 bigEndian: true.	height := chunk longAt: 5 bigEndian: true.	bitsPerChannel := chunk at: 9.	colorType := chunk at: 10.	"compression := chunk at: 11." "TODO - validate compression"	"filterMethod := chunk at: 12." "TODO - validate filterMethod"	interlaceMethod := chunk at: 13. "TODO - validate interlace method"	(#(2 4 6) includes: colorType)		ifTrue: [depth := 32].	(#(0 3) includes: colorType) ifTrue: [		depth := bitsPerChannel min: 8.		colorType = 0 ifTrue: [ "grayscale"			palette := self grayColorsFor: depth.		].	].	bitsPerPixel := (BPP at: colorType+1) at: bitsPerChannel highBit.	bytesPerScanline := width * bitsPerPixel + 7 // 8.	rowSize := width * depth + 31 >> 5.! !!Cursor class methodsFor: 'class initialization' stamp: 'jrp 8/6/2005 22:54'!initResizeTop    "Cursor initResizeTop"       ResizeTopCursor :=               (Cursor extent: 16@16 fromArray: #(               2r000000100000000               2r000001110000000               2r000011111000000               2r000111111100000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000111111100000               2r000011111000000               2r000001110000000               2r000000100000000               2r000000000000000)       offset: -7@-7) withMask! !!Form methodsFor: 'image manipulation' stamp: 'jm 6/30/1999 15:36'!trimBordersOfColor: aColor	"Answer a copy of this Form with each edge trimmed in to the first pixel that is not of the given color. (That is, border strips of the given color are removed)."	| r |	r := self rectangleEnclosingPixelsNotOfColor: aColor.	^ self copy: r! !!TextStyle methodsFor: 'accessing' stamp: ''!leading: yDelta	leading := yDelta! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 10:07'!readBody	| array scanLine rowBytes position byte count pad |	pad := #(0 3 2 1) at: (width \\ 4 + 1).	array := ByteArray new: ((width + pad) * height * bitsPerPixel) // 8.	scanLine := ByteArray new: rowByteSize.	position := 1.	1 to: height do:		[:line |		rowBytes := 0.		[rowBytes < rowByteSize] whileTrue:			[byte := self next.			byte < 16rC0				ifTrue:					[rowBytes := rowBytes + 1.					scanLine at: rowBytes put: byte]				ifFalse:					[count := byte - 16rC0.					byte := self next.					1 to: count do: [:i | scanLine at: rowBytes + i put: byte].					rowBytes := rowBytes + count]].		array			replaceFrom: position			to: position + width - 1			with: scanLine			startingAt: 1.		position := position + width + pad].	^ array! !!Form methodsFor: 'converting' stamp: 'jm 4/5/1999 19:20'!colorReduced	"Return a color-reduced ColorForm version of the receiver, if possible, or the receiver itself if not."	| tally tallyDepth colorCount newForm cm oldPixelValues newFormColors nextColorIndex c |	tally := self tallyPixelValues asArray.	tallyDepth := (tally size log: 2) asInteger.	colorCount := 0.	tally do: [:n | n > 0 ifTrue: [colorCount := colorCount + 1]].	(tally at: 1) = 0 ifTrue: [colorCount := colorCount + 1].  "include transparent"	colorCount > 256 ifTrue: [^ self].  "cannot reduce"	newForm := self formForColorCount: colorCount.	"build an array of just the colors used, and a color map to translate	 old pixel values to their indices into this color array"	cm := Bitmap new: tally size.	oldPixelValues := self colormapIfNeededForDepth: 32.	newFormColors := Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex := 2.	2 to: cm size do: [:i |		(tally at: i) > 0 ifTrue: [			oldPixelValues = nil				ifTrue: [c := Color colorFromPixelValue: i - 1 depth: tallyDepth]				ifFalse: [c := Color colorFromPixelValue: (oldPixelValues at: i) depth: 32].			newFormColors at: nextColorIndex put: c.			cm at: i put: nextColorIndex - 1.  "pixel values are zero-based indices"			nextColorIndex := nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm copyBits: self boundingBox		from: self		at: 0@0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	newForm offset: offset.	^ newForm! !!Form methodsFor: 'transitions' stamp: 'jm 5/21/1998 23:46'!fadeImage: otherImage at: topLeft	indexAndMaskDo: indexAndMaskBlock	"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm |	imageRect := otherImage boundingBox.	resultForm := self copy: (topLeft extent: imageRect extent).	maskForm := Form extent: 32@32.	index := 0.	[indexAndMaskBlock value: (index := index+1) value: maskForm]	whileTrue:		[maskForm reverse.		resultForm copyBits: imageRect from: resultForm at: 0@0			clippingBox: imageRect rule: Form over fillColor: maskForm.		maskForm reverse.		resultForm copyBits: imageRect from: otherImage at: 0@0			clippingBox: imageRect rule: Form under fillColor: maskForm.		self copyBits: imageRect from: resultForm at: topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate]! !!StrikeFont methodsFor: 'character shapes' stamp: 'yo 12/28/2002 22:37'!characterFormAtMulti: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii := character charCode.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii := maxAscii + 1].	leftX := xTable at: ascii + 1.	rightX := xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 17:19'!cleanLine	"upTo LF or CR, tab as space"	| line loop b |	line := WriteStream with: ''.	loop := true.	[loop] whileTrue: [		b := stream next.		b ifNil:[			loop := false		"EOS"		]		ifNotNil: [			(b = (Character cr) or:[b = Character lf]) ifTrue:[				loop := false.			]			ifFalse:[				b = (Character tab) ifTrue:[b := Character space].				line nextPut: b.			]		]	].	^line contents! !!TranslucentColor methodsFor: 'private' stamp: ''!setRgb: rgbValue alpha: alphaValue	"Set the state of this translucent color. Alpha is represented internally by an integer in the range 0..255."	rgb == nil ifFalse: [self attemptToMutateError].	rgb := rgbValue.	alpha := (255.0 * alphaValue) asInteger min: 255 max: 0.! !!StrikeFont methodsFor: 'file in/out' stamp: ''!displayChar: ascii form: charForm	"Convenience utility used during conversion of BitFont files"	| m bigForm |	Display fillBlack: (0@0 extent: 20@14).	ascii printString displayAt: 0@2.	charForm width > 0 ifTrue:		[m := 5.		bigForm := charForm magnify: charForm boundingBox by: m@m.		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.		bigForm displayAt: 50@2.		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].! !!HostFont methodsFor: 'emphasis' stamp: 'ar 8/29/2000 21:18'!emphasized: code	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	derivativeFonts == nil ifTrue:[derivativeFonts := Array new: 32].	derivative := derivativeFonts at: (safeCode := code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis := 1 bitShift: safeCode highBit - 1.	base := self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative := (base copy name: base name) makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative := (base copy name: base name) makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative := (base copy name: base name) makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative := (base copy name: base name) makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative := (base copy name: base name) makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!SegmentScanner methodsFor: 'as yet unclassified' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	"Make a local copy of stop conditions so we don't modify the default"	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions := stopConditions copy].	stopConditions at: Space asciiValue + 1 put: nil.! !!StrikeFont class methodsFor: 'instance creation' stamp: 'yo 9/23/2002 16:28'!newFromF12File: aFileName	"StrikeFont newFromF12File: 'kaname.f12'"	| file n |	('*.F12' match: aFileName) ifFalse: ["self halt. " "likely incompatible"].	file := FileStream readOnlyFileNamed: aFileName.	file binary.	n := self new.	n name: (FileDirectory baseNameFor: (FileDirectory localNameFor: aFileName)).	n readF12FromStream: file.	^ n.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/29/2004 04:19'!processNonInterlaced	| z filter temp copyMethod debug |	debug := self debugging.	copyMethod := #(copyPixelsGray: nil copyPixelsRGB: copyPixelsIndexed:		  copyPixelsGrayAlpha: nil copyPixelsRGBA:) at: colorType+1.	debug ifTrue: [ Transcript cr; nextPutAll: 'NI chunk size='; print: chunk size ].	z := ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline := ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter := (z next: 1) first.		debug ifTrue:[filtersSeen add: filter].		thisScanline := z next: bytesPerScanline into: thisScanline startingAt: 1.		(debug and: [ thisScanline size < bytesPerScanline ]) ifTrue: [ Transcript nextPutAll: ('wanted {1} but only got {2}' format: { bytesPerScanline. thisScanline size }); cr ].		filter = 0 ifFalse:[self filterScanline: filter count: bytesPerScanline].		self perform: copyMethod with: y.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		].	z atEnd ifFalse:[self error:'Unexpected data'].	debug ifTrue: [Transcript  nextPutAll: ' compressed size='; print: z position  ].! !!DisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text := t.	textStyle := ts. 	foregroundColor := paragraphColor := foreColor.	(backgroundColor := backColor) isTransparent ifFalse:		[fillBlt := blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges := shadowMode! !!StrikeFont class methodsFor: 'examples' stamp: ''!convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and then 	write them out in strike2 (*.sf2) format which is much more compact,	and which can be read in again very quickly."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as the image."	| f |	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:		[:fname | Transcript cr; show: fname.		f := StrikeFont new readFromBitFont: fname.		f writeAsStrike2named: f name , '.sf2']! !!DisplayText methodsFor: 'converting' stamp: 'tk 10/21/97 12:28'!asParagraph	"Answer a Paragraph whose text and style are identical to that of the 	receiver."	| para |	para := Paragraph withText: text style: textStyle.	para foregroundColor: foreColor backgroundColor: backColor.	backColor isTransparent ifTrue: [para rule: Form paint].	^ para! !!DisplayText methodsFor: 'displaying' stamp: ''!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Refer to the comment in 	DisplayObject|displayOn:transformation:clippingBox:align:with:rule:mask:."	| absolutePoint |	absolutePoint := displayTransformation applyTo: relativePoint.	absolutePoint := absolutePoint x asInteger @ absolutePoint y asInteger.	self displayOn: aDisplayMedium		at: absolutePoint - alignmentPoint		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!TextLineInterval methodsFor: 'accessing' stamp: ''!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth := padWidthInteger! !!CharacterBlock methodsFor: 'accessing' stamp: 'di 12/2/97 14:33'!textLine: aLine	textLine := aLine! !!Form methodsFor: 'other' stamp: 'dgd 8/26/2003 21:44'!setAsBackground	"Set this form as a background image."	| world newColor |	Smalltalk isMorphic 		ifTrue:			[world := self currentWorld.			newColor := InfiniteForm with: self.			self rememberCommand:				(Command new cmdWording: 'set background to a picture' translated;					undoTarget: world selector: #color: argument: world color;					redoTarget: world selector: #color: argument: newColor).			world color: newColor]		ifFalse:			[ScheduledControllers screenController model form: self.			Display restoreAfter: []]! !!Pen methodsFor: 'operations' stamp: 'ar 5/28/2000 12:10'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale := sourceForm width.	wasDown := penDown.	lineStart := location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form := font characterFormAt: char.			charStart := location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart := location.				bb := BitBlt current bitPeekerFromForm: form.				pix := RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: TextStyle defaultFont]"! !!Form methodsFor: 'accessing' stamp: 'ar 5/28/2000 00:48'!hasBeenModified: aBool	"Change the receiver to reflect the modification state"	aBool ifTrue:[^self unhibernate].	self shouldPreserveContents		ifTrue:[self hibernate]		ifFalse:[bits := nil]! !!BitBlt methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:33'!clipByX1: x1 y1: y1 x2: x2 y2: y2	| right bottom |	right := clipX + clipWidth.	bottom := clipY + clipHeight.	x1 > clipX ifTrue:[clipX := x1].	y1 > clipY ifTrue:[clipY := y1].	x2 < right ifTrue:[right := x2].	y2 < bottom ifTrue:[bottom := y2].	clipWidth := right - clipX.	clipHeight := bottom - clipY.	clipWidth < 0 ifTrue:[clipWidth := 0].	clipHeight < 0 ifTrue:[clipHeight := 0].! !!BitBlt methodsFor: 'accessing' stamp: ''!clipWidth: anInteger 	"Set the receiver's clipping area width to be the argument, anInteger."	clipWidth := anInteger! !!TextPrinter class methodsFor: 'accessing' stamp: 'dew 3/7/2000 20:39'!defaultTextPrinter	"This is the global default TextPrinter instance."	DefaultTextPrinter isNil ifTrue: [DefaultTextPrinter := self new].	^DefaultTextPrinter! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'ar 5/14/2001 23:35'!feltTip: width cellSize: cellSize	"Warning: This example potentially uses a large amount of memory--it creates a Form with cellSize squared bits for every Display pixel."	"In this example, all drawing is done into a large, monochrome Form and then scaled down onto the Display using smoothing. The larger the cell size, the more possible shades of gray can be generated, and the smoother the resulting line appears. A cell size of 8 yields 64 possible grays, while a cell size of 16 gives 256 levels, which is about the maximum number of grays that the human visual system can distinguish. The width parameter determines the maximum line thickness. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen feltTip: 2.7 cellSize: 8"	| tabletScale bitForm pen warp p srcR dstR nibSize startP r |	tabletScale := self tabletScaleFactor.	bitForm := Form extent: Display extent * cellSize depth: 1.	pen := Pen newOnForm: bitForm.	pen color: Color black.	warp := (WarpBlt current toForm: Display)		sourceForm: bitForm;		colorMap: (bitForm colormapIfNeededFor: Display);		cellSize: cellSize;		combinationRule: Form over.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p := (Sensor tabletPoint * cellSize * tabletScale) rounded.			nibSize := (Sensor tabletPressure * (cellSize * width)) rounded.		     nibSize > 0				ifTrue: [					pen squareNib: nibSize.					startP := pen location.					pen goto: p.					r := startP rect: pen location.					dstR := (r origin // cellSize) corner: ((r corner + nibSize + (cellSize - 1)) // cellSize).					srcR := (dstR origin * cellSize) corner: (dstR corner * cellSize).					warp copyQuad: srcR innerCorners toRect: dstR]				ifFalse: [					pen place: p]]].! !!TextStyle class methodsFor: 'mime file in/out' stamp: 'nk 1/19/2004 20:36'!collectionFromCompressedMIMEString: aString	"aString holds a compressed, Base64 representation of a SmartRefStream storage of a TextStyle.	Install the TextStyle."	| this newName style heights data |	data := (Base64MimeConverter mimeDecode: aString as: String) unzipped.	(RWBinaryOrTextStream with: data) reset; fileIn.	this := SmartRefStream scannedObject.	"now install it"	newName := this fontArray first familyName.	this fontArray do: [:aFont | aFont familyName = newName ifFalse: [		self error: 'All must be same family']].	style := TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights := style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!GIFReadWriter methodsFor: 'private-bits access' stamp: ''!nextBitsPut: anInteger	| integer writeBitCount shiftCount |	shiftCount := 0.	remainBitCount = 0		ifTrue:			[writeBitCount := 8.			integer := anInteger]		ifFalse:			[writeBitCount := remainBitCount.			integer := bufByte + (anInteger bitShift: 8 - remainBitCount)].	[writeBitCount < codeSize]		whileTrue:			[self nextBytePut: ((integer bitShift: shiftCount) bitAnd: 255).			shiftCount := shiftCount - 8.			writeBitCount := writeBitCount + 8].	(remainBitCount := writeBitCount - codeSize) = 0		ifTrue: [self nextBytePut: (integer bitShift: shiftCount)]		ifFalse: [bufByte := integer bitShift: shiftCount].	^anInteger! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex := targetIndex.	characterPoint := 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!BDFFontReader class methodsFor: 'resource download' stamp: 'nop 1/23/2000 18:44'!installX11Fonts "BDFFontReader installX11Fonts"	"Installs previously-converted .sf2 fonts into the TextConstants dictionary.  This makes them available as TextStyles everywhere in the image."	| families fontArray textStyle |	families := #( 'Courier' 'Helvetica' 'LucidaBright' 'Lucida' 'LucidaTypewriter' 'NewCenturySchoolbook' 'TimesRoman' ).	families do: [:family |		fontArray := StrikeFont readStrikeFont2Family: family.		textStyle := TextStyle fontArray: fontArray.		TextConstants at: family asSymbol put: textStyle.	].! !!StrikeFont methodsFor: 'emphasis' stamp: 'yo 5/24/2004 17:54'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g := glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs := g.	fallbackFont ifNotNil: [		fallbackFont := fallbackFont emphasized: 4	].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/29/2004 04:19'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrement startingRow cx sc temp |	startingCol := #(0 4 0 2 0 1 0 ).	colIncrement := #(8 8 4 4 2 2 1 ).	rowIncrement := #(8 8 8 4 4 2 2 ).	startingRow := #(0 0 4 0 2 0 1 ).	z := ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx := colIncrement at: pass.				sc := startingCol at: pass.				bytesPerPass := width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline := ByteArray new: bytesPerPass.				thisScanline := ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						filter := z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline := z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].	z atEnd ifFalse:[self error:'Unexpected data'].! !!Form methodsFor: 'bordering' stamp: 'di 10/21/2001 09:39'!shapeBorder: aColor width: borderWidth	"A simplified version for shapes surrounded by transparency (as SketchMorphs).	Note also this returns a new form that may be larger, and does not affect the original."	| shapeForm borderForm newForm |	newForm := Form extent: self extent + (borderWidth*2) depth: self depth.	newForm fillColor: Color transparent.	self displayOn: newForm at: (0@0) + borderWidth.	"First identify the shape in question as a B/W form"	shapeForm := (newForm makeBWForm: Color transparent) reverse.	"Now find the border of that shape"	borderForm := shapeForm borderFormOfWidth: borderWidth sharpCorners: false.	"Finally use that shape as a mask to paint the border with color"	^ newForm fillShape: borderForm fillColor: aColor! !!Form methodsFor: 'displaying' stamp: 'ar 5/17/2001 15:40'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	Smalltalk at: #B3DRenderEngine ifPresentAndInMemory:		[:engineClass | engine := engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx := self asTexture.	(blitter := BitBlt current toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap := Bitmap new: (self depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (tx pixelWordFor: World color).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!Form methodsFor: 'converting' stamp: 'ar 7/23/1999 17:04'!orderedDither32To16	"Do an ordered dithering for converting from 32 to 16 bit depth."	| ditherMatrix ii out inBits outBits index pv dmv r di dmi dmo g b pvOut outIndex |	self depth = 32 ifFalse:[^self error:'Must be 32bit for this'].	ditherMatrix := #(	0	8	2	10						12	4	14	6						3	11	1	9						15	7	13	5).	ii := (0 to: 31) collect:[:i| i].	out := Form extent: self extent depth: 16.	inBits := self bits.	outBits := out bits.	index := outIndex := 0.	pvOut := 0.	0 to: self height-1 do:[:y|		0 to: self width-1 do:[:x|			pv := inBits at: (index := index + 1).			dmv := ditherMatrix at: (y bitAnd: 3) * 4 + (x bitAnd: 3) + 1.			r := pv bitAnd: 255.	di := r * 496 bitShift: -8.			dmi := di bitAnd: 15.	dmo := di bitShift: -4.			r := dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			g := (pv bitShift: -8) bitAnd: 255.	di := g * 496 bitShift: -8.			dmi := di bitAnd: 15.	dmo := di bitShift: -4.			g := dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			b := (pv bitShift: -16) bitAnd: 255.	di := b * 496 bitShift: -8.			dmi := di bitAnd: 15.	dmo := di bitShift: -4.			b := dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			pvOut := (pvOut bitShift: 16) + 						(b bitShift: 10) + (g bitShift: 5) + r.			(x bitAnd: 1) = 1 ifTrue:[				outBits at: (outIndex := outIndex+1) put: pvOut.				pvOut := 0].		].		(self width bitAnd: 1) = 1 ifTrue:[			outBits at: (outIndex := outIndex+1) put: (pvOut bitShift: -16).			pvOut := 0].	].	^out! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'sd 1/30/2004 15:18'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass := self withAllSubclasses		detect: [:subclass | subclass understandsImageFormat: aBinaryStream]		ifNone: [			aBinaryStream close.			^self error: 'image format not recognized'].	reader := readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form := reader nextImage.		reader close].	^ form! !!JPEGReadStream methodsFor: 'accessing' stamp: 'ar 3/4/2001 18:43'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer ifTrue:[		self fillBuffer.		requestedBits > bitsInBuffer ifTrue:[			self error: 'not enough bits available to decode']].	value := bitBuffer bitShift: (requestedBits - bitsInBuffer).	bitBuffer := bitBuffer bitAnd: (1 bitShift: (bitsInBuffer - requestedBits)) -1.	bitsInBuffer := bitsInBuffer - requestedBits.	^ value! !!Color class methodsFor: 'class initialization' stamp: 'tk 6/22/96'!initializeHighLights	"Create a set of Bitmaps for quickly reversing areas of the screen without converting colors. "	"Color initializeHighLights"	| t |	t := Array new: 32.	t at: 1 put: (Bitmap with: 16rFFFFFFFF).	t at: 2 put: (Bitmap with: 16rFFFFFFFF).	t at: 4 put: (Bitmap with: 16r55555555).	t at: 8 put: (Bitmap with: 16r7070707).	t at: 16 put: (Bitmap with: 16rFFFFFFFF).	t at: 32 put: (Bitmap with: 16rFFFFFFFF).	HighLightBitmaps := t.! !!TextLineInterval methodsFor: 'scanning' stamp: ''!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad := paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!CharacterScanner methodsFor: 'private' stamp: 'ar 12/15/2001 23:31'!setAlignment: style	alignment := style.	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'ar 3/4/2001 22:18'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream := currentComponents at: 1.	cbSampleStream := currentComponents at: 2.	crSampleStream := currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits := mcuImageBuffer bits.	1 to: bits size do:		[:i |		y := ySampleStream nextSample.		cb := cbSampleStream nextSample - FloatSampleOffset.		cr := crSampleStream nextSample - FloatSampleOffset.		red := self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green := self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue := self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: 16rFF000000 + (red << 16) + (green << 8) + blue].	! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 5/3/2001 13:02'!hash	| result |	<primitive: 'primitiveHashArray' module: 'FloatArrayPlugin'>	result := 0.	1 to: self size do:[:i| result := result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!HostFont class methodsFor: 'accessing' stamp: 'ar 8/28/2000 17:27'!textStyleFromUser	"HostFont textStyleFromUser"	| styleName fonts |	styleName := self fontNameFromUser ifNil:[^self].	styleName := styleName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	fonts := #(10 12 14 16 18 20 22 24 26 28 30 36 48 60 72 90).	('Rendering ', styleName) displayProgressAt: Sensor cursorPoint		from: 1 to: fonts size during:[:bar|			fonts := fonts				collect:[:ptSize| bar value: (fonts indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!JPEGReadWriter2 methodsFor: 'public access' stamp: 'JMM 1/11/2005 14:56'!compress: aForm quality: quality	"Encode the given Form and answer the compressed ByteArray. Quality goes from 0 (low) to 100 (high), where -1 means default."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"odd width images of depth 16 give problems; avoid them."	sourceForm := (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct := ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct := ByteArray new: self primJPEGErrorMgr2StructSize.	buffer := ByteArray new: sourceForm width * sourceForm height + 1024.	byteCount := self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: false		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	^ buffer copyFrom: 1 to: byteCount! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!resetSampleStream	currentX := 0.	currentY := 0! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side := self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:09'!mapBitsFrom: srcBitMask to: dstBitMask	"Return an array consisting of the shift and the mask for	mapping component values out of srcBitMask and into dstBitMask.	While this computation is somewhat complicated it eases the batch	conversion of all the pixels in BitBlt."	| srcBits dstBits srcLow srcHigh dstLow dstHigh bits mask shift |	(srcBitMask = 0 or:[dstBitMask = 0]) ifTrue:[^#(0 0)]. "Zero mask and shift"	"Compute low and high bit position for source and dest bit mask"	srcLow := srcBitMask lowBit - 1.	srcHigh := srcBitMask highBit.	dstLow := dstBitMask lowBit - 1.	dstHigh := dstBitMask highBit.	"Compute the number of bits in source and dest bit mask"	srcBits := srcHigh - srcLow.		dstBits := dstHigh - dstLow.	"Compute the maximum number of bits we can transfer inbetween"	bits := srcBits min: dstBits.	"Compute the (unshifted) transfer mask"	mask := (1 bitShift: bits) - 1.	"Shift the transfer mask to the mask the highest n bits of srcBitMask"	mask := mask bitShift: (srcHigh - bits).	"Compute the delta shift so that the most significant bit of the	source bit mask falls on the most significant bit of the dest bit mask.	Note that delta is used for #bitShift: so		shift > 0 : shift right		shift < 0 : shift left	e.g., if dstHigh > srcHigh we need to shift left and if dstHigh < srcHigh	we need to shift right. This leads to:"	shift := dstHigh - srcHigh.	"And that's all we need"	^Array with: shift with: mask! !!Form methodsFor: 'scaling, rotation' stamp: ''!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f := Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp := Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f := Form fromDisplay: ((p := Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 := f magnify: f boundingBox by: 5@3.	(f2 shrink: f2 boundingBox by: 5@3) displayAt: p]"! !!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!mix: color2 shades: thisMany	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "	"Color showColors: (Color red mix: Color green shades: 12)"	| redInc greenInc blueInc rr gg bb c out |	thisMany = 1 ifTrue: [^ Array with: color2].	redInc := color2 red - self red / (thisMany-1).	greenInc := color2 green - self green / (thisMany-1).	blueInc := color2 blue - self blue / (thisMany-1).	rr := self red.  gg := self green.  bb := self blue.	out := (1 to: thisMany) collect: [:num |		c := Color r: rr g: gg b: bb.		rr := rr + redInc.		gg := gg + greenInc.		bb := bb + blueInc.		c].	out at: out size put: color2.	"hide roundoff errors"	^ out! !!BitBlt methodsFor: 'accessing' stamp: ''!combinationRule: anInteger 	"Set the receiver's combination rule to be the argument, anInteger, a 	number in the range 0-15."	combinationRule := anInteger! !!Form methodsFor: 'transitions' stamp: 'ar 5/17/2001 15:41'!fadeImageFine: otherImage at: topLeft	"Display fadeImageFine: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| pix j ii d |	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do:						[:q | pix := pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[ii := #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14) at: i.		j := ii//4+1.		(0 to: 28 by: 4) do:			[:k | mask bits at: j+k put:				((mask bits at: j+k) bitOr: (pix bitShift: ii\\4*d))].		true]		ifFalse: [false]]! !!CharacterScanner methodsFor: 'scanner methods' stamp: 'yo 3/13/2003 11:57'!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		maxAscii := font maxAsciiFor: startEncoding.		f := font fontArray at: startEncoding + 1.		"xTable := f xTable.		maxAscii := xTable size - 2."		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [(stopConditions at: ascii + 1) ~~ nil]) ifTrue: [^ stops at: ascii + 1].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		"destX printString displayAt: 0@(lastIndex*20)."		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!Form methodsFor: 'scaling, rotation' stamp: ''!rotateBy: deg	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	^ self rotateBy: deg smoothing: 1" | a f |  f := Form fromDisplay: (0@0 extent: 200@200).  a := 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a := a+5)) display].f display"! !!DisplayScanner methodsFor: 'scanning' stamp: 'ar 12/17/2001 13:28'!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/18/98 14:19'!writeOn: aStream 	"Store the array of bits onto the argument, aStream. A leading byte of 16r80 identifies this as compressed by compressToByteArray (qv)."	| b |	aStream nextPut: 16r80.	b := self compressToByteArray.	aStream		nextPutAll: (self encodeInt: b size);		nextPutAll: b.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setOffset: aPoint	"Set the raw offset in the receiver"	| pt |	pt := aPoint asPoint.	self a13: pt x asFloat.	self a23: pt y asFloat.! !!StrikeFont methodsFor: 'file in/out' stamp: 'yo 1/15/2004 16:48'!readEFontBDFForKoreanFromFile: fileName name: aString overrideWith: otherFileName	| fontReader stream |	fontReader := EFontBDFFontReaderForRanges readOnlyFileNamed: fileName.	stream := ReadStream on: (fontReader readRanges: fontReader rangesForKorean overrideWith: otherFileName otherRanges: {Array with: 8481 with: 12320} additionalOverrideRange: fontReader additionalRangesForKorean).	xTable := stream next.	glyphs := stream next.	minAscii := stream next.	maxAscii := stream next.	maxWidth := stream next.	ascent := stream next.	descent := stream next.	pointSize := stream next.	name := aString.	type := 0. "no one see this"	superscript := ascent - descent // 3.		subscript := descent - ascent // 3.		emphasis := 0.	self reset.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'ar 3/3/2001 22:19'!parseQuantizationTable	| length markerStart n prec value table |	markerStart := self position.	length := self nextWord.	[self position - markerStart >= length] whileFalse:		[value := self next.		n := (value bitAnd: 16r0F) + 1.		prec := (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table := IntegerArray new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value := (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!Rectangle methodsFor: 'rectangle functions' stamp: 'ar 10/25/2005 17:22'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"     (self intersects: aRectangle)		ifFalse: [^Array with: self].	areas := OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin := aRectangle origin y))]		ifFalse: [yOrigin := origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner := aRectangle corner y) corner: corner)]		ifFalse: [yCorner := corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 8/26/2001 20:54'!transformDirection: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x := (aPoint x * self a11) + (aPoint y * self a12).	y := (aPoint x * self a21) + (aPoint y * self a22).	^x @ y! !!DisplayObject methodsFor: 'displaying-generic' stamp: ''!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	"Display the receiver where a DisplayTransformation is provided as an 	argument, rule is ruleInteger and mask is aForm. Translate by 	relativePoint-alignmentPoint. Information to be displayed must be 	confined to the area that intersects with clipRectangle."	| absolutePoint |	absolutePoint := displayTransformation applyTo: relativePoint.	self displayOn: aDisplayMedium		at: (absolutePoint - alignmentPoint) 		clippingBox: clipRectangle 		rule: ruleInteger 		fillColor: aForm ! !!DisplayScreen methodsFor: 'displaying' stamp: 'ar 5/15/2001 20:08'!forceDamageToScreen: allDamage	"Force all the damage rects to the screen."	| rectList excluded remaining regions |	rectList := allDamage.	"Note: Reset extra regions at the beginning to prevent repeated errors"	regions := extraRegions.	extraRegions := nil.	regions ifNotNil:[		"exclude extra regions"		regions do:[:drawerAndRect|			excluded := drawerAndRect at: 2.			remaining := WriteStream on: #().			rectList do:[:r|				remaining nextPutAll:(r areasOutside: excluded)].			rectList := remaining contents].	].	rectList do:[:r| self forceToScreen: r].	regions ifNotNil:[		"Have the drawers paint what is needed"		regions do:[:drawerAndRect| (drawerAndRect at: 1) forceToScreen].	].! !!ColorForm methodsFor: 'private' stamp: 'jm 2/24/98 18:53'!unusedColormapEntry	"Return the index of an unused color map entry, or zero if there isn't one."	| tallies |	tallies := self tallyPixelValues.	1 to: tallies size do: [:i |		(tallies at: i) = 0 ifTrue: [^ i]].	^ 0! !!Form methodsFor: 'filling' stamp: 'ar 5/17/2001 15:38'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker := BitBlt current bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel := y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel := x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: self depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d := 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!BitBlt methodsFor: 'copying' stamp: 'yo 5/20/2004 14:30'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY := aPoint y.	destX := aPoint x.	"the following are not really needed, but theBitBlt primitive will fail if not set"	sourceX ifNil: [sourceX := 100].	width ifNil: [width := 100].	self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.	^ destX@destY.! !!BitBlt class methodsFor: 'examples' stamp: 'dew 9/18/2001 02:30'!exampleOne	"This tests BitBlt by displaying the result of all sixteen combination rules that BitBlt is capable of using. (Please see the comment in BitBlt for the meaning of the combination rules). This only works at Display depth of 1. (Rule 15 does not work?)"	| path displayDepth |	displayDepth := Display depth.	Display newDepth: 1.	path := Path new.	0 to: 3 do: [:i | 0 to: 3 do: [:j | path add: j * 100 @ (i * 75)]].	Display fillWhite.	path := path translateBy: 60 @ 40.	1 to: 16 do: [:index | BitBlt			exampleAt: (path at: index)			rule: index - 1			fillColor: nil].	[Sensor anyButtonPressed] whileFalse: [].	Display newDepth: displayDepth.	"BitBlt exampleOne"! !!Quadrangle methodsFor: 'bordering' stamp: ''!region: aRectangle 	"Set the rectangular area of the receiver to aRectangle."	origin := aRectangle origin.	corner := aRectangle corner! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!qTable	qTable ifNil: [qTable := Array new: QuantizationTableSize].	^ qTable! !!FormSetFont class methodsFor: 'examples' stamp: 'ar 1/15/2001 18:38'!copy: charForm toClipBoardAs: char ascent: ascent	Clipboard clipboardText:		(Text string: char asString			attribute: (TextFontReference toFont: 				(FormSetFont new					fromFormArray: (Array with: charForm)					asciiStart: char asciiValue					ascent: ascent)))"	The S in the Squeak welcome window was installed by doing the following	in a workspace (where the value of, eg, charForm will persist through BitEdit...	f := TextStyle default fontAt: 4.	oldS := f characterFormAt: $S.	charForm := Form extent: oldS extent depth: 8.	oldS displayOn: charForm.	charForm bitEdit.	...Play around with the BitEditor, then accept and close...	FormSetFont copy: charForm toClipBoardAs: $S ascent: f ascent.	...Then do a paste into the Welcome window"! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 9/3/2000 13:22'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative := derivativeFonts at: (safeCode := code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis := 1 bitShift: safeCode highBit - 1.	base := self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative := (base copy ensureCleanBold name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative := (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative := (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative := (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative := (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!XBMReadWriter class methodsFor: 'class initialization' stamp: 'wdc 2/2/1999 15:28'!initialize	"XBMReadWriter initialize"	| flippedByte |	Flipbits := (0 to: 255) collect:     [:n |  "Compute the bit-reversal of the 8-bit value, n"     flippedByte := 0.     0 to: 7 do:          [:i |          flippedByte := flippedByte bitOr: ((n >> i bitAnd: 1) << (7-i))].         flippedByte]! !!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00'!mixed: proportion with: aColor 	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 	aColor alphaMixed: proportion with: anotherColor	"	| frac1 frac2 |	frac1 := proportion asFloat min: 1.0 max: 0.0.	frac2 := 1.0 - frac1.	^ Color		r: self red * frac1 + (aColor red * frac2)		g: self green * frac1 + (aColor green * frac2)		b: self blue * frac1 + (aColor blue * frac2)! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'yo 10/4/2002 20:43'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	self setConditionArray: (alignment = Justified ifTrue: [#paddedSpace])."	alignment = Justified ifTrue: [		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions := stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]"! !!JPEGReadStream class methodsFor: 'class initialization' stamp: 'ar 3/4/2001 18:32'!initialize	"JPEGReadStream initialize"	MaxBits := 16.! !!Quadrangle methodsFor: 'displaying-generic' stamp: ''!displayOn: aDisplayMedium align: aPoint1 with: aPoint2 clippingBox: aRectangle	"Display the border and region of the receiver so that its position at 	aPoint1 is aligned with position aPoint2. The displayed information 	should be clipped so that only information with the area determined by 	aRectangle is displayed."	| savedRegion |	savedRegion := self region.	self region: ((savedRegion align: aPoint1 with: aPoint2) intersect: aRectangle).	self displayOn: aDisplayMedium.	self region: savedRegion! !!Point methodsFor: 'transforming' stamp: ''!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p := self - center.	r := p r.	theta := angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Form methodsFor: 'image manipulation' stamp: 'ar 5/28/2000 12:09'!smear: dir distance: dist	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb := BitBlt current destForm: self sourceForm: self fillColor: nil		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox.	skew := 1.	[skew < dist] whileTrue:		[bb destOrigin: dir*skew; copyBits.		skew := skew+skew]! !!Color methodsFor: 'access' stamp: ''!hue	"Return the hue of this color, an angle in the range [0.0..360.0]."	| r g b max min span h |	r := self privateRed.	g := self privateGreen.	b := self privateBlue. 	max := ((r max: g) max: b).	min := ((r min: g) min: b).	span := (max - min) asFloat.	span = 0.0 ifTrue: [ ^ 0.0 ].	r = max ifTrue: [		h := ((g - b) asFloat / span) * 60.0.	] ifFalse: [		g = max			ifTrue: [ h := 120.0 + (((b - r) asFloat / span) * 60.0). ]			ifFalse: [ h := 240.0 + (((r - g) asFloat / span) * 60.0). ].	].	h < 0.0 ifTrue: [ h := 360.0 + h ].	^ h! !!Form methodsFor: 'filling' stamp: 'di 10/20/2001 10:09'!floodFillMapFrom: sourceForm to: scanlineForm mappingColorsWithin: dist to: centerPixVal	"This is a helper routine for floodFill.  It's written for clarity (scanning the entire	map using colors) rather than speed (which would require hacking rgb components	in the nieghborhood of centerPixVal.  Note that some day a better proximity metric	would be (h s v) where tolerance could be reduced in hue."	| colorMap centerColor |	scanlineForm depth = 32 ifFalse: [self error: 'depth 32 assumed'].	"First get a modifiable identity map"	colorMap := 	(Color cachedColormapFrom: sourceForm depth to: scanlineForm depth) copy.	centerColor := Color colorFromPixelValue: (centerPixVal bitOr: 16rFFe6) depth: scanlineForm depth.	"Now replace all entries that are close to the centerColor"	1 to: colorMap size do:		[:i | ((Color colorFromPixelValue: ((colorMap at: i) bitOr: 16rFFe6) depth: scanlineForm depth)				diff: centerColor) <= dist ifTrue: [colorMap at: i put: centerPixVal]].	^ colorMap! !!Cursor class methodsFor: 'class initialization' stamp: 'di 7/30/2001 10:32'!initMenu 	MenuCursor  :=		        (Cursor	extent: 16@16	fromArray: #(		2r1111111111100000		2r1000000000100000		2r1010011000100000		2r1000000000100000		2r1101001101100000		2r1111111111100000		2r1000000000100000		2r1011001010100000		2r1000000000100000		2r1010110010100000		2r1000000000100000		2r1010010100100000		2r1000000000100000		2r1111111111100000		0)	offset: 0@0).! !!TextLineInterval methodsFor: 'private' stamp: ''!lineHeight: height baseline: ascent	lineHeight := height.	baseline := ascent! !!CharacterScanner methodsFor: 'initialize' stamp: 'ls 1/14/2002 21:26'!initialize	destX := destY := leftMargin := 0.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:09'!copyPixelsGrayAlpha: y at: startX by: incX	"Handle interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b := BitBlt current bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i := (x // incX << 1) + 1.				gray := thisScanline at: i.				pixel := ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i := (x // incX << 2) + 1.				gray := thisScanline at: i.				pixel := ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57'!readColorMap	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| colorCount colors maxLevel b g r ccStream |	colorCount := (bfOffBits - 54) // 4.	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	biBitCount >= 16 ifTrue:[^nil].	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"		"default monochrome color map"		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel := (2 raisedTo: biBitCount) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	ccStream := ReadStream on: (stream next: colorCount*4).	colors := Array new: colorCount.	1 to: colorCount do: [:i |		b := ccStream next.		g := ccStream next.		r := ccStream next.		ccStream next. "skip reserved"		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!TextStyle class methodsFor: 'user interface' stamp: 'nk 9/1/2004 10:34'!modalStyleSelectorWithTitle: title	"Presents a modal font-style choice menu, answers a TextStyle or nil."	"TextStyle modalStyleSelectorWithTitle: 'testing'"		| menu actualStyles |	Smalltalk isMorphic ifFalse: [ ^self modalMVCStyleSelectorWithTitle: title ].	menu := MenuMorph entitled: title.	actualStyles := self actualTextStyles.	actualStyles keysSortedSafely do: [ :styleName | | style |		style := actualStyles at: styleName.		menu add: styleName target: menu selector: #modalSelection: argument: style.		menu lastItem font: (style fontOfSize: 18)	].	^menu invokeModal.! !!TextStyle methodsFor: 'private' stamp: 'tk 8/20/96'!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	, Make size depend on first font."	fontArray := anArray.	lineGrid := (fontArray at: 1) height + leading.	"For whole family"	baseline := (fontArray at: 1) ascent + leading.	alignment := 0.	firstIndent := 0.	restIndent := 0.	rightIndent := 0.	tabsArray := DefaultTabsArray.	marginTabsArray := DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/10/2003 15:09'!pbmGetLine	"Get the next non-comment line from the PBM stream	Look for 'pragmas' - commands hidden in the comments"	 	| line |	[		line := self cleanLine.		line ifNil: [^nil].		(line size > 0 and:[(line at: 1) = $#]) ifTrue:[			self pbmParam: line.		].		(line size = 0) or:[(line at: 1) = $#]	] 	whileTrue: [].	^line! !!HostFont class methodsFor: 'accessing' stamp: 'ar 1/27/2002 19:37'!textStyleFrom: fontName	"HostFont textStyleFromUser"	| styleName fonts |	styleName := fontName asSymbol.	"(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]]."	fonts := #(10 11 12 13 14 16 18 20 22 24 26 28 30 36 48 60 72 90).	('Rendering ', styleName) displayProgressAt: Sensor cursorPoint		from: 1 to: fonts size during:[:bar|			fonts := fonts				collect:[:ptSize| bar value: (fonts indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'nk 6/12/2004 16:31'!fontIndexOfPointSize: desiredPointSize	"Returns an index in fontArray of the font with pointSize <= desiredPointSize"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch := 9999.  bestIndex := 1.	1 to: fontArray size do:		[:i | d := desiredPointSize - (fontArray at: i) pointSize.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex := i. bestMatch := d]].	^ bestIndex! !!PNGReadWriter methodsFor: 'chunks' stamp: 'ar 2/11/2004 12:14'!processNextChunk	| length chunkType crc chunkCrc |	length := self nextLong.	chunkType := (self next: 4) asString.	chunk := self next: length.	chunkCrc := self nextLong bitXor: 16rFFFFFFFF.	crc := self updateCrc: 16rFFFFFFFF from: 1 to: 4 in: chunkType.	crc := self updateCrc: crc from: 1 to: length in: chunk.	crc = chunkCrc ifFalse:[		self error: 'PNGReadWriter crc error in chunk ', chunkType.	].	chunkType = 'IEND' ifTrue: [^self	"*should* be the last chunk"].	chunkType = 'sBIT' ifTrue: [^self processSBITChunk "could indicate unusual sample depth in original"].	chunkType = 'gAMA' ifTrue: [^self 	"indicates gamma correction value"].	chunkType = 'bKGD' ifTrue: [^self processBackgroundChunk].	chunkType = 'pHYs' ifTrue: [^self processPhysicalPixelChunk].	chunkType = 'tRNS' ifTrue: [^self processTransparencyChunk].	chunkType = 'IHDR' ifTrue: [^self processIHDRChunk].	chunkType = 'PLTE' ifTrue: [^self processPLTEChunk].	chunkType = 'IDAT' ifTrue: [		"---since the compressed data can span multiple		chunks, stitch them all together first. later,		if memory is an issue, we need to figure out how		to do this on the fly---"		globalDataChunk := globalDataChunk ifNil: [chunk] ifNotNil:			[globalDataChunk,chunk].		^self	].	unknownChunks add: chunkType.! !!BitBlt methodsFor: 'copying' stamp: 'di 7/17/97 10:04'!copyForm: srcForm to: destPt rule: rule colorMap: map	sourceForm := srcForm.	halftoneForm := nil.	combinationRule := rule.	destX := destPt x + sourceForm offset x.	destY := destPt y + sourceForm offset y.	sourceX := 0.	sourceY := 0.	width := sourceForm width.	height := sourceForm height.	colorMap := map.	self copyBits! !!DisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor := textColor! !!Rectangle class methodsFor: 'instance creation' stamp: 'btr 2/14/2003 16:29'!merging: listOfRects 	"A number of callers of merge: should use this method."	| minX minY maxX maxY |	listOfRects		do: [:r | minX				ifNil: [minX := r topLeft x. minY := r topLeft y.					maxX := r bottomRight x. maxY := r bottomRight y]				ifNotNil: [minX := minX min: r topLeft x. minY := minY min: r topLeft y.					maxX := maxX max: r bottomRight x. maxY := maxY max: r bottomRight y]].	^ minX@minY corner: maxX@maxY! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 3/27/2000 16:10'!fillZeroWidthSlots	| nullGlyph |	"Note: this is slow because it copies the font once for every replacement."	nullGlyph := (Form extent: 1@glyphs height) fillGray.	"Now fill the empty slots with narrow box characters."	minAscii to: maxAscii do:		[:i | (self widthOf: (Character value: i)) = 0 ifTrue:			[self characterFormAt: (Character value: i) put: nullGlyph]].! !!DisplayObject class methodsFor: 'fileIn/Out' stamp: 'mdr 8/31/2000 19:11'!collectionFromFileNamed: fileName 	"Answer a collection of Forms read from the external file 	named fileName. The file format is: fileCode, {depth, extent, offset, bits}."	| formList f fileCode |	formList := OrderedCollection new.	f := (FileStream readOnlyFileNamed: fileName) binary.	fileCode := f next.	fileCode = 1		ifTrue: [			[f atEnd] whileFalse: [formList add: (self new readFromOldFormat: f)]]		ifFalse: [			fileCode = 2 ifFalse: [self error: 'unknown Form file format'. ^ formList].			[f atEnd] whileFalse: [formList add: (self new readFrom: f)]].	f close.	^ formList! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 13:50'!defaultFontIndex: anIndex	defaultFontIndex := anIndex! !!Pen methodsFor: 'operations' stamp: ''!home	"Place the receiver at the center of its frame."	location := destForm boundingBox center! !!BitBlt methodsFor: 'accessing' stamp: ''!destX: anInteger 	"Set the top left x coordinate of the receiver's destination form to be the 	argument, anInteger."	destX := anInteger! !!DisplayScreen methodsFor: 'other' stamp: ''!fullScreen   "Display fullScreen"	ScreenSave notNil ifTrue: [Display := ScreenSave].	clippingBox := super boundingBox! !!HostFont class methodsFor: 'accessing' stamp: 'ar 1/27/2002 20:12'!textStyleFrom: fontName sizes: ptSizes	| styleName fonts |	styleName := fontName asSymbol.	(TextConstants includesKey: styleName)		ifTrue:[(self confirm: styleName , ' is already defined in TextConstants.Do you want to replace that definition?')			ifFalse: [^ self]].	('Rendering ', styleName) displayProgressAt: Sensor cursorPoint		from: 1 to: ptSizes size during:[:bar|			fonts := ptSizes				collect:[:ptSize| bar value: (ptSizes indexOf: ptSize).							   self fontName: styleName 									size: ptSize									emphasis: 0]				thenSelect:[:font| font notNil]]. "reject those that failed"	fonts size = 0 ifTrue:[^self error:'Could not create font style', styleName].	TextConstants		at: styleName		put: (TextStyle fontArray: fonts).! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft := aPoint x - self left.	distToRight := self right - aPoint x.	distToTop := aPoint y - self top.	distToBottom := self bottom - aPoint y.	closest := distToLeft. side := #left.	distToRight < closest ifTrue: [closest := distToRight. side := #right].	distToTop < closest ifTrue: [closest := distToTop. side := #top].	distToBottom < closest ifTrue: [closest := distToBottom. side := #bottom].	^ side" | r | r := Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/15/2003 12:35'!readHeaderPAM	"read pam header, not tested"	| loop line tokens key val |	tupleType := ''.	loop := true.	loop whileTrue:[		line := self pbmGetLine.		tokens := line findTokens: ' '.		tokens size = 2 ifTrue:[			key := tokens at: 1 asUppercase.			val := tokens at: 2.			key caseOf: {				['WIDTH'] 		-> [cols := val asInteger].				['HEIGHT'] 		-> [rows := val asInteger].				['DEPTH'] 		-> [depth := val asInteger].				['MAXVAL']		-> [maxValue := val asInteger].				['TUPLETYPE']	-> [tupleType := tupleType, ' ', val].				['ENDHDR']		-> [loop := false].			}		]	].	Transcript cr; show: 'PAM file class ', type asString, ' size ', cols asString, ' x ', 		rows asString, ' maxValue =', maxValue asString, ' depth=', depth asString.! !!TextStyle methodsFor: 'accessing' stamp: ''!rightIndent: anInteger 	"Answer the right margin indent for the lines of a paragraph in the style 	of the receiver to be the argument, anInteger."	rightIndent := anInteger! !!PNMReadWriter methodsFor: 'writing' stamp: 'jdr 10/16/2003 16:08'!nextPutBW: aForm reverse: flagXor	| myType val nBytes bytesRow |	cols := aForm width.	rows := aForm height.	depth := aForm depth.	"stream position: 0."	aForm depth = 1 ifTrue:[myType := $4] ifFalse:[myType := $5].	self writeHeader: myType.	stream binary.	nBytes := (cols/8) ceiling.	bytesRow := (cols/32) ceiling * 4.	0 to: rows-1 do: [:y | | i |		i := 1 + (bytesRow*y).		0 to: nBytes-1 do: [:x |			val := aForm bits byteAt: i.			flagXor ifTrue:[val := val bitXor: 16rFF].			stream nextPut: val.			i := i+1.		]	].! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/10/2003 15:11'!pbmParam: line	"Look for a parameter hidden in a comment"	| key tokens |	tokens := line findTokens: ' '.	key := (tokens at: 1) asLowercase.	(key = '#origin' and:[tokens size = 3]) ifTrue:[	"ORIGIN key word"		"This is for SE files as described in:		Algoritms For Image Processing And Computer Vision. J. R. Parker"		origin := ((tokens at: 2) asInteger) @ ((tokens at: 3) asInteger)	].! !!BitBlt methodsFor: 'accessing' stamp: ''!sourceForm: aForm 	"Set the receiver's source form to be the argument, aForm."	sourceForm := aForm! !!Form methodsFor: 'color mapping' stamp: ''!makeBWForm: foregroundColor	"Map this form into a B/W form with 1's in the foreground regions."	| bwForm map |	bwForm := Form extent: self extent.	map := self newColorMap.  "All non-foreground go to 0's"	map at: (foregroundColor indexInMap: map) put: 1.	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	^ bwForm! !!DisplayScanner methodsFor: 'private' stamp: 'di 9/3/2000 16:13'!setFont 	foregroundColor := paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: Color transparent.	text ifNotNil:[destY := lineY + line baseline - font ascent]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 12/8/1999 18:02'!consistOnlyOf: aFont	fontArray := Array with: aFont.	defaultFontIndex := 1! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 4/30/1998 11:22'!pointNearestTo: aPoint	"Return the point on my border closest to aPoint"	| side |	(self containsPoint: aPoint)		ifTrue:			[side := self sideNearestTo: aPoint.			side == #right ifTrue: [^ self right @ aPoint y].			side == #left ifTrue: [^ self left @ aPoint y].			side == #bottom ifTrue: [^ aPoint x @ self bottom].			side == #top ifTrue: [^ aPoint x @ self top]]		ifFalse:			[^ aPoint adhereTo: self]! !!Cursor class methodsFor: 'class initialization' stamp: 'kfr 7/12/2003 21:27'!initWait	WaitCursor := 		  (Cursor			extent: 16@16			fromArray: #(		2r1111111111111100		2r1000000000000100		2r0100000000001000		2r0010000000010000		2r0001110011100000		2r0000111111000000		2r0000011110000000		2r0000011110000000		2r0000100101000000		2r0001000100100000		2r0010000110010000		2r0100001111001000		2r1000111111110100		2r1111111111111100		0)			offset: 0@0).! !!Form class methodsFor: 'examples' stamp: ''!exampleSpaceFill    "Form exampleSpaceFill"	"This example demonstrates the area filling algorithm. Starts by having	the user sketch on the screen (ended by option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of some region to be	filled, and the filling begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	Cursor crossHair showWhile:		[interiorPoint := Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeFill: Color gray interiorPoint: interiorPoint].	f displayOn: Display at: r origin	! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/14/2001 23:25'!fillColor: aColorOrPattern 	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"	aColorOrPattern == nil ifTrue: [halftoneForm := nil. ^ self].	destForm == nil ifTrue: [self error: 'Must set destForm first'].	halftoneForm := destForm bitPatternFor: aColorOrPattern ! !!CornerRounder class methodsFor: 'all' stamp: 'di 6/28/1999 15:51'!initialize  "CornerRounder initialize"	CR0 := CR1 := self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r110e26 2r1000e26 2r10000e26 2r10000e26 2r100000e26)				offset: 0@0).	CR2 := self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11100e26 2r11000e26 2r111000e26)				offset: 0@0).! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:37'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 := p1 x asFloat.	y1 := p1 y asFloat.	x21 := p2 x asFloat - x1.	y21 := p2 y asFloat - y1.	t := ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old := 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new := (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old := new) extent: 10@10)]]"! !!MorphicTransform methodsFor: 'private' stamp: ''!setOffset: aPoint	offset := aPoint.! !!TextLineInterval class methodsFor: 'instance creation' stamp: ''!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| newSelf |	newSelf := super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !!Bitmap methodsFor: 'filing' stamp: 'jm 2/12/98 17:32'!encodeInt: int	"Encode the integer int as per encodeInt:in:at:, and return it as a ByteArray"	| byteArray next |	byteArray := ByteArray new: 5.	next := self encodeInt: int in: byteArray at: 1.	^ byteArray copyFrom: 1 to: next - 1! !!Color class methodsFor: 'class initialization' stamp: 'ar 2/16/2000 21:56'!initializeTranslucentPatterns	"Color initializeTranslucentPatterns"	| mask bits pattern patternList |	TranslucentPatterns := Array new: 8.	#(1 2 4 8) do:[:d|		patternList := Array new: 5.		mask := (1 bitShift: d) - 1.		bits := 2 * d.		[bits >= 32] whileFalse: [			mask := mask bitOr: (mask bitShift: bits).  "double the length of mask"			bits := bits + bits].		"0% pattern"		pattern := Bitmap with: 0 with: 0.		patternList at: 1 put: pattern.		"25% pattern"		pattern := Bitmap with: mask with: 0.		patternList at: 2 put: pattern.		"50% pattern"		pattern := Bitmap with: mask with: mask bitInvert32.		patternList at: 3 put: pattern.		"75% pattern"		pattern := Bitmap with: mask with: 16rFFFFFFFF.		patternList at: 4 put: pattern.		"100% pattern"		pattern := Bitmap with: 16rFFFFFFFF with: 16rFFFFFFFF.		patternList at: 5 put: pattern.		TranslucentPatterns at: d put: patternList.	].! !!StrikeFont methodsFor: 'character shapes' stamp: ''!characterForm: char pixelValueAt: pt put: val	| f |	f := self characterFormAt: char.	f pixelAt: pt put: val.	self characterFormAt: char put: val! !!ColorForm methodsFor: 'postscript generation' stamp: ''!getTransparencyUnificationLUT	| lut transparentIndex |	lut := Array new:colors size.	transparentIndex := self indexOfColor:Color transparent.	1 to: colors size do:		[ :i | lut at:i put:(((colors at:i) = Color transparent) ifTrue:[transparentIndex] ifFalse:[i])]. ! !!ColorForm class methodsFor: 'as yet unclassified' stamp: 'nk 4/17/2004 19:44'!mappingWhiteToTransparentFrom: aFormOrCursor	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."	| f map |	aFormOrCursor depth <= 8 ifFalse: [		^ self error: 'argument depth must be 8-bits per pixel or less'].	(aFormOrCursor isColorForm) ifTrue: [		f := aFormOrCursor deepCopy.		map := aFormOrCursor colors.	] ifFalse: [		f := ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.		f copyBits: aFormOrCursor boundingBox			from: aFormOrCursor			at: 0@0			clippingBox: aFormOrCursor boundingBox			rule: Form over			fillColor: nil.		map := Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].	map := map collect: [:c |		c = Color white ifTrue: [Color transparent] ifFalse: [c]].	f colors: map.	^ f! !!InfiniteForm methodsFor: 'displaying' stamp: 'nk 4/17/2004 19:48'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm isForm) ifFalse:		[^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].	"Do it iteratively"	targetBox := aDisplayMedium boundingBox intersect: clipRectangle.	patternBox := patternForm boundingBox.	bb := BitBlt current destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	bb colorMap:		(patternForm colormapIfNeededFor: aDisplayMedium).	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:55'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	spaceX := destX.	destX := spaceX + spaceWidth.	spaceIndex := lastIndex.	lineHeightAtSpace := lineHeight.	baselineAtSpace := baseline.	lastIndex := lastIndex + 1.	spaceCount := spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !!GIFReadWriter methodsFor: 'accessing' stamp: '6/18/97 13:18 '!setStream: aStream	"Feed it in from an existing source"	stream := aStream! !!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!atMostAsLuminentAs: aFloat	| revisedColor |	revisedColor := self.	[revisedColor luminance > aFloat] whileTrue: [revisedColor := revisedColor slightlyDarker].	^revisedColor! !CharacterScanner initialize!Cursor initialize!JPEGReadWriter initialize!Color initialize!JPEGHuffmanTable initialize!PNGReadWriter initialize!IdentityTransform initialize!GIFReadWriter initialize!XBMReadWriter initialize!JPEGReadStream initialize!CornerRounder initialize!