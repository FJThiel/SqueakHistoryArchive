"Change Set:		8363Kernel-ar.322Kernel-ar.322:Faster #ensure: handling: Instead of having the default path use thisContext>>tempAt:put: (which is very slow for the JIT) use a temp assignment and let only the termination handling actually do #tempAt:put:.Part 2 updates termination handling to the new scheme."!!ContextPart methodsFor: 'controlling' stamp: 'ar 3/4/2009 14:57'!restart	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: nil to: self].	self privRefresh.	ctxt := thisContext.	[	ctxt := ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		(ctxt tempAt: 2) ifNil:[			ctxt tempAt: 2 put: true.			unwindBlock := ctxt tempAt: 1.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	self jump.! !!Process methodsFor: 'changing process state' stamp: 'ar 3/24/2009 16:31'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			(ctxt tempAt: 2) ifNil:[				ctxt tempAt: 2 put: nil.				unwindBlock := ctxt tempAt: 1.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		"Always suspend the process first so it doesn't accidentally get woken up"		oldList := self suspend.		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!ContextPart methodsFor: 'controlling' stamp: 'ar 3/4/2009 14:58'!resume: value	"Unwind thisContext to self and resume with value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: value to: self].	ctxt := thisContext.	[	ctxt := ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		(ctxt tempAt: 2) ifNil:[			ctxt tempAt: 2 put: true.			unwindBlock := ctxt tempAt: 1.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	^ value! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ar 3/4/2009 14:59'!unwindTo: aContext	| ctx unwindBlock |	ctx := self.	[(ctx := ctx findNextUnwindContextUpTo: aContext) isNil] whileFalse: [		(ctx tempAt: 2) ifNil:[			ctx tempAt: 2 put: true.			unwindBlock := ctx tempAt: 1.			unwindBlock value]	].! !