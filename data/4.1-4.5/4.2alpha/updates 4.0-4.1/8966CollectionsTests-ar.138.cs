"Change Set:		8966CollectionsTests-ar.138CollectionsTests-ar.138:Remove unnecessary use of traits in ReadStreamTest. Makes it possible to load CollectionTests into images w/o traits support.CollectionsTests-ar.136:More tests, including KeyedSet and WeakSet.CollectionsTests-ar.137:Fixes a typo in SetWithNilTest."!ClassTestCase subclass: #ReadStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CollectionsTests-Streams'!!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:41'!testUpTo	| returnValue stream |	returnValue := (self emptyStream upTo: nil).	self assert: returnValue isCollection.	self assert: returnValue isEmpty.		stream := self streamOnArray.	returnValue := stream upTo: #(a b c).	self assert: returnValue = #(1).	self assert: stream peek = false.		stream := self streamOnArray.	returnValue := stream upTo: true.	self assert: returnValue = #(1 #(a b c) false).	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:44'!testReset	| stream |	stream := self emptyStream.	stream reset.	self assert: stream position = 0.		stream := self streamOnArray.	stream reset.	self assert: stream position = 0.	self deny: stream atEnd.	stream position: 3.	self assert: stream atEnd.	stream reset.	self assert: stream position = 0.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:11'!testBackUpToEmptyPattern1	"This test represents the current behavior which is not clearly defined and could be revised."	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self should: [stream backUpTo: ''] raise: Error.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:07'!testBackUpTo1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self assert: (stream backUpTo: 'ab').	self assert: stream peek = $g! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:37'!testPeek2	| stream |	stream := self streamOn: #(nil nil nil).		self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.	self assert: stream peek isNil.	stream next.		"Yes, #peek answers nil when there is no more element to read."	self assert: stream peek isNil.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:23'!testNext	|stream|	stream := self streamOnArray.	self assert: stream next = 1.	self assert: stream next = #(a b c).	self assert: stream next = false.		stream := self streamOnString.	self assert: stream next = $a.	self assert: stream next = $b.	self assert: stream next = $c.	self assert: stream next = $d.	self assert: stream next = $e.	! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:30'!testNextMatchFor	| stream |	stream := self streamOnArray.	self assert: (stream nextMatchFor: 1).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).		stream := self streamOnArray.	self deny: (stream nextMatchFor: false).	self assert: (stream nextMatchFor: #(a b c)).	self assert: (stream nextMatchFor: false).! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testIdentitySetWithNil	self runSetWithNilTestOf: [IdentitySet new]! !!ReadStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo	self emptyStream do: [:value | self fail]! !!ReadStreamTest methodsFor: 'helpers' stamp: 'dc 3/7/2007 13:55'!streamOn: aCollection	^ self classUnderTest on: aCollection! !!ReadStreamTest methodsFor: 'tests - enumerating' stamp: 'dc 2/28/2007 16:20'!testDo2	| stream string |	stream := self streamOnArray.	string := String new.		stream do: [:value | string := string, ' ', value asString].		self assert: string = (' ', 1 asString, ' ', #(a b c) asString, ' ', false asString)! !!ReadStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:17'!testSkipTo	| stream |	stream := self emptyStream.	self deny: (stream skipTo: nil).		stream := self streamOnArray.	self deny: stream atEnd.	self deny: (stream skipTo: nil).	self assert: stream atEnd.		stream := self streamOnArray.	self assert: stream peek = 1.	self assert: (stream skipTo: #(a b c)).	self assert: stream peek = false.	self assert: (stream skipTo: false).	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/28/2007 15:38'!testPosition	| stream |	self assert: self emptyStream position isZero.		stream := self streamOnArray.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.	stream next.	self assert: stream position = 3.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:20'!testOldBack	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream oldBack = $a.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:32'!testContents	| stream |	self assert: self emptyStream contents = ''.		stream := self streamOnArray.	self assert: stream contents = #(1 #(a b c) false).	stream position: 3.	self assert: stream contents = #(1 #(a b c) false).		stream := self streamOnString.	self assert: stream contents = 'abcde'.	stream setToEnd.	self assert: stream contents = 'abcde'.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 15:40'!testNexts2	| stream |	stream := self streamOnArray.	self assert: (stream next: 2) = #(1 #(a b c)).	self assert: (stream next: 1) = #(false).! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testOldBackOnPosition1	"Test the old behavior of the method back. The method #oldBack is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. The method #oldBack considers that the pointer is *on* an element. (Damien Cassou - 1 August 2007)"	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream oldBack = nil.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:28'!testKeyedSetWithNil	| set |	self runSetWithNilTestOf: [KeyedSet keyBlock:[:o| o]].	set := KeyedSet keyBlock:[:o| o].	set add: nil.	self assert: (set at: nil) == nil.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:24'!testNexts	self assert: (self emptyStream next: 0) isEmpty.	self assert: (self streamOnArray next: 0) isEmpty.	self assert: (self streamOnArray next: 1) = #(1).	self assert: (self streamOnArray next: 2) = #(1 #(a b c)).	self assert: (self streamOnArray next: 3) = #(1 #(a b c) false).! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:40'!testWeakSetWithNil	| set |	self runSetWithNilTestOf: [WeakSet new].	"Ensure that GCed entries don't count"	set := WeakSet with: Object new.	Smalltalk garbageCollect.	set do:[:x| self assert: false]. 	"test for de facto emptyness"	self deny: (set includes: nil).	set add: nil.	self assert: (set includes: nil).	set remove: nil.	self deny: (set includes: nil).! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:47'!testSetToEnd	| stream |	stream := self emptyStream.	stream setToEnd.	self assert: stream atEnd.		stream := self streamOnArray.	stream setToEnd.	self assert: stream atEnd.	stream position: 1.	self deny: stream atEnd.	stream setToEnd.	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 2/27/2007 17:41'!testSetPosition	| stream |	stream := self emptyStream.	self should: [stream position: -2] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	stream := self streamOnArray.	self should: [stream position: -1] raise: Error.	self shouldnt: [stream position: 0] raise: Error.	self shouldnt: [stream position: 1] raise: Error.	self shouldnt: [stream position: 2] raise: Error.	"According to ANSI Smalltalk Standard 1.9 Draft, the following should be tested too:	self should: [stream position: 3] raise: Error.		However, I don't see the point of raising an error when positioning at the end.		I prefer testing the absence of error:	"	self shouldnt: [stream position: 3] raise: Error.	self should: [stream position: 4] raise: Error.! !!ReadStreamTest methodsFor: 'tests - positionning' stamp: 'dc 3/1/2007 15:18'!testSkipTo2	| stream |		stream := self streamOnString.	self assert: (stream skipTo: $b).	self assert: stream peek = $c.	self assert: (stream skipTo: $d).	self assert: stream peek = $e.	self assert: (stream skipTo: $e).	self assert: stream atEnd.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:28'!testKeyedIdentitySetWithNil	| set |	self runSetWithNilTestOf: [KeyedIdentitySet keyBlock:[:o| o]].	set := KeyedIdentitySet keyBlock:[:o| o].	set add: nil.	self assert: (set at: nil) == nil.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:22'!testBackOnPosition1	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next.	self assert: stream back = $a.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testSetWithNil	self runSetWithNilTestOf: [Set new]! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 2/28/2007 16:10'!testAtEnd	| stream |	self assert: self emptyStream atEnd.	stream := self streamOnArray.	self deny: stream atEnd.	stream next: 3.	self assert: stream atEnd.! !!ReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 3/7/2007 13:50'!testNew	self should: [self classUnderTest new] raise: Error.! !!ReadStreamTest methodsFor: 'tests - back' stamp: 'dc 8/1/2007 16:19'!testBack	"Test the new implemtation of the method back."	|stream|	stream := self streamOn: 'abc'.	stream next: 2.	self assert: stream back = $b.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:24'!testPluggableSetWithNil	self runSetWithNilTestOf: [PluggableSet new]! !!ReadStreamTest methodsFor: 'tests - instance creation' stamp: 'dc 2/28/2007 15:39'!testOn	self shouldnt: [self streamOn: '  '] raise: Error.	self assert: (self streamOn: '  ') position isZero.! !!ReadStreamTest methodsFor: 'tests - positioning' stamp: 'dc 8/2/2007 12:08'!testBackUpToPatternNotFound1	|stream|	stream := ReadStream on: 'abcdabg'.	stream setToEnd.	self deny: (stream backUpTo: 'zz').	self assert: stream position = 0! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/1/2007 12:42'!testUpTo2	| returnValue stream |	stream := self streamOnString.	returnValue := stream upTo: $d.	self assert: returnValue = 'abc'.	self assert: stream peek = $e.! !!SetWithNilTest methodsFor: 'tests' stamp: 'ar 2/1/2010 21:43'!runSetWithNilTestOf: newSet	"Run the common tests for the given set class"	self shouldnt:[newSet value add: nil] raise: Error.	self shouldnt:[newSet value addAll: #(nil nil nil)] raise: Error.	self assert: (newSet value add: nil; yourself) size = 1.	self assert: (newSet value addAll: #(nil nil nil); yourself) size = 1.	self assert: ((newSet value add: nil; yourself) includes: nil).	self assert: ((newSet value addAll: #(nil nil nil); yourself) includes: nil).	self assert: (newSet value add: nil; yourself) anyOne = nil.	self assert: ((newSet value add: nil; yourself) remove: nil) == nil.	self assert: ((newSet value add: nil; yourself) remove: nil; yourself) isEmpty.	self assert: (newSet value addAll: #(1 nil foo); yourself) size = 3.	self assert: ((newSet value addAll: #(1 nil foo); yourself) remove: nil; yourself) size = 2.	self assert: ((newSet value add: nil; yourself) collect:[:x| x]) = (newSet value add: nil; yourself).	self assert: ((newSet value add: nil; yourself) collect:[:x| x] as: Array) = #(nil).	self deny: ((newSet value) includes: nil).	self deny: ((newSet value add: 3; yourself) includes: nil).	self deny: ((newSet value add: 3; remove: 3; yourself) includes: nil).! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:54'!testPeekFor2	| stream negative number |	stream := self streamOn: '- 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.	stream := self streamOn: '-145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self assert: negative.	self assert: number = '145'.		stream := self streamOn: ' 145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.		stream := self streamOn: '145'.	negative := stream peekFor: $-.	stream peekFor: Character space.	number := stream next: 3.	self deny: negative.	self assert: number = '145'.! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 3/6/2007 18:26'!testContents2	"From ANSI Smalltalk Standard draft 1.9: 			it is unspecified whether or not the returned collection [using #contents] is the same object as the backing store collection. However, if the returned collection is not the same object as the stream backing store collection then the class of the returned collection is the same class as would be returned if the message #select: was sent to the backing store collection."			"In Squeak, there is #species to know what class should be used on copy, selection..."	| interval stream streamContents |	interval := 1 to: 32.	stream := self streamOn: interval.	streamContents := stream contents.		(streamContents == interval)		ifFalse: [self assert: streamContents class = Interval new species]! !!ReadStreamTest methodsFor: 'tests - accessing' stamp: 'dc 2/28/2007 16:35'!testPeek	| stream |	stream := self streamOnArray.		self assert: stream peek = 1.	self deny: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self assert: stream peek = #(a b c).	self deny: stream peek = false.		stream next.		self deny: stream peek = 1.	self deny: stream peek = #(a b c).	self assert: stream peek = false.		stream next.		"In ANSI Smalltalk Standard Draft, it is said that nil will return nil at the end when using #peek."	self assert: stream peek isNil.! !!ReadStreamTest methodsFor: 'tests - testing' stamp: 'dc 3/1/2007 14:48'!testPeekFor	| stream |	stream := self streamOnArray.	self assert: (stream peekFor: 1).	self assert: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).	stream := self streamOnArray.	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).	self assert: (stream peekFor: 1).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: false).	self assert: (stream peekFor: #(a b c)).		self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self assert: (stream peekFor: false).		self assert: (stream atEnd).	self deny: (stream peekFor: nil).	self deny: (stream peekFor: 1).	self deny: (stream peekFor: #(a b c)).	self deny: (stream peekFor: false).! !TGettableStreamTest removeSelector: #testPeek!TGettableStreamTest removeSelector: #testPeekFor!TGettableStreamTest removeSelector: #testUpTo!TStreamTest removeSelector: #classUnderTest!Smalltalk removeClassNamed: #TReadStreamTest!Smalltalk removeClassNamed: #TGettableStreamTest!TStreamTest removeSelector: #emptyStream!TPuttableStreamTest removeSelector: #testNextPutAllReplacing!TReadStreamTest removeSelector: #testNew!TGettableStreamTest removeSelector: #testPeek2!TGettableStreamTest removeSelector: #testNext!TGettableStreamTest removeSelector: #testNextMatchFor!Smalltalk removeClassNamed: #TWriteStreamTest!TReadStreamTest removeSelector: #testOn!TGettableStreamTest removeSelector: #testOldBack!TGettableStreamTest removeSelector: #testDo!TPuttableStreamTest removeSelector: #testNextPutAllAppending!TSequencedStreamTest removeSelector: #testBackUpToPatternNotFound1!TGettableStreamTest removeSelector: #testDo2!TReadStreamTest removeSelector: #testContents2!TGettableStreamTest removeSelector: #testSkipTo!TGettableStreamTest removeSelector: #testNexts2!TGettableStreamTest removeSelector: #testOldBackOnPosition1!TGettableStreamTest removeSelector: #testNexts!TStreamTest removeSelector: #streamOnString!TSequencedStreamTest removeSelector: #testBackUpToEmptyPattern1!TStreamTest removeSelector: #streamOn:!TStreamTest removeSelector: #streamOnArray!TSequencedStreamTest removeSelector: #testReset!TGettableStreamTest removeSelector: #testSkipTo2!TPuttableStreamTest removeSelector: #testNextPutReplacing!TGettableStreamTest removeSelector: #testBackOnPosition1!TSequencedStreamTest removeSelector: #testBackUpTo1!TGettableStreamTest removeSelector: #testAtEnd!TReadStreamTest removeSelector: #testPosition!Smalltalk removeClassNamed: #TStreamTest!TSequencedStreamTest removeSelector: #testContents!TGettableStreamTest removeSelector: #testBack!Smalltalk removeClassNamed: #TPuttableStreamTest!TPuttableStreamTest removeSelector: #testNextPutAppending!TSequencedStreamTest removeSelector: #testSetToEnd!TSequencedStreamTest removeSelector: #testSetPosition!Smalltalk removeClassNamed: #TSequencedStreamTest!TGettableStreamTest removeSelector: #testUpTo2!TGettableStreamTest removeSelector: #testPeekFor2!