"Change Set:		7309Compiler-ar.68Compiler-ar.68:Prerequiste changes for Closure installation."!SelectorNode subclass: #KeyWordNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Syntax'!ParseNodeVisitor subclass: #TempNumberNormalizingVisitor	instanceVariableNames: 'count temps'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!ParseNode subclass: #NewArrayNode	instanceVariableNames: 'numElements'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!Notification subclass: #ReparseAfterSourceEditing	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!ParseNode subclass: #Encoder	instanceVariableNames: 'scopeTable nTemps supered requestor class selector literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!Object subclass: #ParseNodeVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!ParseNode subclass: #LeafNode	instanceVariableNames: 'key code index'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!VariableNode subclass: #InstanceVariableNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block primitive encoder temporaries properties sourceText'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!VariableNode subclass: #FieldNode	instanceVariableNames: 'fieldDef rcvrNode readNode writeNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!ParseNode subclass: #BlockArgsNode	instanceVariableNames: 'temporaries'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Syntax'!TempVariableNode subclass: #RemoteTempVectorNode	instanceVariableNames: 'remoteTemps readNode writeNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!InstanceVariableNode subclass: #MaybeContextInstanceVariableNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!VariableNode subclass: #LiteralVariableNode	instanceVariableNames: 'readNode writeNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!VariableNode subclass: #TempVariableNode	instanceVariableNames: 'isAnArg hasRefs hasDefs scope argType'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!!TempVariableNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:51'!accept: aVisitor	aVisitor visitTempVariableNode: self! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitFieldNode: aFieldNode! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitSelectorNode: aSelectorNode! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1! !!VariableNode methodsFor: 'initialize-release' stamp: 'eem 5/14/2008 16:01'!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	^self name: varName key: objRef code: (self code: (index := i) type: type)! !!ParseNode methodsFor: 'printing' stamp: 'eem 5/6/2008 15:18'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPut: ${.	self printOn: aStream indent: 0.	aStream nextPut: $}.! !!TempNumberNormalizingVisitor methodsFor: 'private' stamp: 'eem 9/25/2008 09:50'!renumberTemp: tempNode	| name newName |	tempNode isIndirectTempVector ifTrue:		[tempNode remoteTemps do:			[:remoteTempNode| self renumberTemp: remoteTempNode].		 ^self].	(temps includes: tempNode) ifTrue: [^self].	name := tempNode key.	name size >= 2 ifFalse: [^self].	name first = $t ifFalse: [^self].	2 to: name size do:		[:i|		(name at: i) isDigit ifFalse: [^self]].	newName := 't', (count := count + 1) printString.	tempNode name: newName key: newName code: tempNode code.	temps add: tempNode	! !!Parser methodsFor: 'temps' stamp: 'eem 5/13/2008 12:17'!bindTemp: name in: methodSelector	^name! !!VariableNode methodsFor: 'testing' stamp: 'eem 5/14/2008 09:13'!isSelfPseudoVariable	"Answer if this ParseNode represents the 'self' pseudo-variable."	^ key = 'self' or: [name = '{{self}}']! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!sizeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeForValue: encoder) + 			(readNode size: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeForValue: encoder) + 		(super sizeForValue: encoder) + 			(readNode size: encoder args: 1 super: false)! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:53'!visitReturnNode: aReturnNode	aReturnNode expr accept: self! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:55'!accept: aVisitor	aVisitor visitNewArrayNode: self! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/23/2008 10:56'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimized].	^true! !!LeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!key: object code: byte	key := object.	code := byte! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 16:02'!visitMessageNode: aMessageNode.	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:41'!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key == 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!TempVariableNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:54'!asMorphicSyntaxIn: parent	^ parent addToken: self name type: #tempVariable on: self! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:32'!visitVariableNode: aVariableNode! !!BlockNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:28'!printArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^ self].	arguments do:		[:arg | aStream nextPut: $:;  nextPutAll: arg key;  space].	aStream nextPut: $|; space.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue:		[aStream crtab: level]! !!MethodNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 12:57'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits literals stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |		literals := encoder allLiterals.		(nLits := literals size) > 255 ifTrue:			[^self error: 'Too many literals referenced'].		1 to: nLits do: [:lit | m literalAt: lit put: (literals at: lit)].		m properties: properties.		^m].	nArgs := arguments size.	blkSize := block sizeForEvaluatedValue: encoder.	(nLits := (literals := encoder allLiterals) size) > 255 ifTrue:		[^self error: 'Too many literals referenced'].	method := CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm := ReadWriteStream with: method.	strm position: method initialPC - 1.	stack := ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue:		[^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	^method! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar := 30 asCharacter.    aStream := WriteStream on: (String new: 200).    self step.    [hereChar == $"]        whileFalse:            [(hereChar == stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment := OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken! !!Parser class methodsFor: 'class initialization' stamp: 'eem 9/10/2008 09:58'!initialize	Preferences		addBooleanPreference: #allowUnderscoreAssignment 		category: #compiler 		default: false		balloonHelp: 'If enabled, the compiler will accept _ (underscore) for assignment.\This provides backward compatibility with the pre-ANSI compiler.' withCRs.	Preferences		addBooleanPreference: #allowBlockArgumentAssignment 		category: #compiler 		default: false		balloonHelp: 'If enabled, the compiler will allow assignment into block arguments.\This provides backward compatibility with the pre-closure compiler.' withCRs.! !!TempVariableNode methodsFor: 'testing' stamp: 'ar 7/10/2009 22:40'!beMethodArg	argType := #method! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:50'!accept: aVisitor	aVisitor visitMessageNode: self! !!BlockNode methodsFor: 'tiles' stamp: 'RAA 2/27/2001 09:48'!asMorphicCollectSyntaxIn: parent	^parent 		blockNodeCollect: self 		arguments: arguments 		statements: statements! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitRemoteTempVectorNode: aRemoteTempVectorNode! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!emitLoad: stack on: strm	rcvrNode emitForValue: stack on: strm.	fieldDef accessKey ifNotNil:[		super emitForValue: stack on: strm.	].! !!SelectorNode methodsFor: 'testing' stamp: 'eem 9/25/2008 15:18'!isForFFICall	^key includesSubString: '()/'! !!Encoder methodsFor: 'encoding' stamp: 'eem 6/24/2008 14:23'!doItInContextName	^'_thisContext'! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 6/19/2008 09:36'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!Compiler methodsFor: 'public access' stamp: 'eem 5/15/2008 15:05'!parserClass	^parser ifNil: [self class parserClass] ifNotNil: [parser class]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/23/2008 13:14'!noteSpecialSelector: selectorSymbol	"special > 0 denotes specially treated (potentially inlined) messages. "	special := MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/23/2008 10:47'!emitIfNil: stack on: strm value: forValue	| theNode theSize |	theNode := arguments first.	theSize := sizes at: 1.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: selector key == #ifNotNil:		dist: theSize 		pop: stack 		on: strm.	pc := strm position.	forValue 		ifTrue: 			[strm nextPut: Pop.			 stack pop: 1.			 theNode emitForEvaluatedValue: stack on: strm]			ifFalse:			[theNode emitForEvaluatedEffect: stack on: strm].! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:50'!accept: aVisitor	aVisitor visitInstanceVariableNode: self! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:50'!accept: aVisitor	aVisitor visitLiteralVariableNode: self! !!SelectorNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:50'!printOn: aStream indent: level 	aStream nextPutAll: (key == nil							ifTrue: ['<key==nil>']							ifFalse: [key])! !!MethodNode methodsFor: 'converting' stamp: 'eem 6/20/2008 14:50'!prepareForRegeneration	"Nothing to do for vanilla nodes."! !!MessageNode methodsFor: 'tiles' stamp: 'RAA 2/15/2001 19:34'!asMorphicSyntaxIn: parent	^parent 		vanillaMessageNode: self 		receiver: receiver 		selector: selector 		arguments: arguments! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!emitStorePop: stack on: strm	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!MessageNode methodsFor: 'visiting' stamp: 'ar 7/10/2009 23:08'!argumentsInEvaluationOrder	"Answer the receivers arguments in evaluation order.	 If the receiver is a transformed to:do: node this will undo the misordering done by the transformation."	^(special > 0	   and: [(MacroTransformers at: special) == #transformToDo:	   and: [arguments size >= 7]])		"arguments are in a weid order and may be nil in a transformed to:do: loop.  sigh...		 c.f. emitCodeForToDo:encoder:value:"		ifTrue:			[(arguments at: 7)	"limitInit"				ifNil: [{	(arguments at: 4).	"initStmt"						(arguments at: 5).	"test"						(arguments at: 3).	"block"						(arguments at: 6) 	"incStmt" }]				ifNotNilDo: [:limitInit|						{ limitInit.						(arguments at: 4).	"initStmt"						(arguments at: 5).	"test"						(arguments at: 3).	"block"						(arguments at: 6) 	"incStmt" }]]		ifFalse:			[arguments]! !!VariableNode methodsFor: 'code generation' stamp: 'eem 9/5/2008 18:14'!fieldOffset	"Return temp or instVar offset for this variable"	^index ifNil: [code < 256					ifTrue: [code \\ 16]					ifFalse: [code \\ 256]]! !!Parser methodsFor: 'public access' stamp: 'eem 7/2/2008 11:24'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt					encoder: (self encoder init: class context: ctxt notifying: self)] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := ReadStream on: requestor text string].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!FieldNode methodsFor: 'initialize-release' stamp: 'eem 5/12/2008 13:40'!name: varName key: objRef index: i type: type	fieldDef := objRef.	^super name: varName key: objRef key index: nil type: LdLitType! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!encodeReceiverOn: encoder	"encode the receiver node"	rcvrNode := encoder encodeVariable: 'self'.! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/23/2008 10:51'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: (BlockNode withJust: NodeNil) noteOptimized						with: arguments first noteOptimized.		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimized.	^true! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitForReturn: stack on: strm	(code >= LdSelf and: [code <= LdNil])		ifTrue: 			["short returns"			strm nextPut: EndMethod - 4 + (code - LdSelf).			stack push: 1 "doesnt seem right"]		ifFalse: 			[super emitForReturn: stack on: strm]! !!MessageNode methodsFor: 'initialize-release' stamp: 'eem 5/10/2008 12:10'!receiver: rcvr selector: aSelector arguments: args precedence: p from: encoder 	"Compile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: aSelector.	(self transform: encoder)		ifTrue: 			[selector isNil ifTrue:				[selector := SelectorNode new 								key: (MacroSelectors at: special)								code: #macro]]		ifFalse: 			[selector := encoder encodeSelector: aSelector.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:22'!visitFutureNode: aFutureNode.	aFutureNode receiver accept: self.	(aFutureNode originalSelector isKindOf: SelectorNode) ifTrue:		[aFutureNode originalSelector accept: self]! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!Scanner methodsFor: 'expression types' stamp: 'eem 5/13/2008 12:44'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(typeTable at: hereChar charCode) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two chaacters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(typeTable at: hereChar charCode) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !!VariableNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:37'!printOn: aStream indent: level 	aStream nextPutAll: name! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:13'!visitBlockNode: aBlockNode	aBlockNode statements do:		[:statement| statement accept: self]! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!sizeForEffect: encoder	^0! !!VariableNode methodsFor: 'testing' stamp: 'eem 5/14/2008 09:18'!type	"This code attempts to reconstruct the type from its encoding in code.		This allows one to test, for instance, (aNode type = LdInstType)."	| type |	code < 0 ifTrue: [^code negated].	code >= 256 ifTrue: [^code // 256].	type := CodeBases findFirst: [:one | code < one].	^type = 0 ifTrue: [5] ifFalse: [type - 1]! !!FieldNode methodsFor: 'accessing' stamp: 'eem 5/12/2008 13:40'!fieldDef	^fieldDef! !!LeafNode methodsFor: 'initialize-release' stamp: 'eem 5/14/2008 15:56'!key: object index: i type: type	key := object.	code := (self code: i type: type).	index := i! !!LeafNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 15:25'!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 3/26/2004 15:45'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar = $' 		and: [aheadChar = $' 				ifTrue: [self step. false]				ifFalse: [true]]]		whileFalse: 			[buffer nextPut: self step.			(hereChar = 30 asCharacter and: [source atEnd])				ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token := buffer contents.	tokenType := #string! !!Parser methodsFor: 'error correction' stamp: 'eem 6/23/2008 10:42'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges := false.	str := requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		(UIManager default chooseFrom: #('yes' 'no') title:			((temp , ' appears to be\unused in this method.\OK to remove it?' withCRs) asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end := tempsMark.			["Beginning at right temp marker..."			start := end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]				whileFalse:					["Search left for the unused temp"					end := requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start := start-1].				requestor correctFrom: start to: end with: ''.				str := str copyReplaceFrom: start to: end with: ''. 				madeChanges := true.				tempsMark := tempsMark - (end-start+1)]]			ifFalse:			[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'ar 12/27/2004 09:42'!queryUndefined	| varStart varName | 	varName := parseNode key.	varStart := self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	(UIManager default chooseFrom: #('yes' 'no') title:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!MessageNode methodsFor: 'private' stamp: 'vb 4/15/2007 09:10'!checkBlock: node as: nodeName from: encoder	^self checkBlock: node as: nodeName from: encoder maxArgs: 0! !!Encoder methodsFor: 'initialize-release' stamp: 'eem 5/6/2008 12:12'!initScopeAndLiteralTables	scopeTable := StdVariables copy.	litSet := StdLiterals copy.	"comments can be left hanging on nodes from previous compilations.	 probably better than this hack fix is to create the nodes afresh on each compilation."	scopeTable do:		[:varNode| varNode comment: nil].	litSet do:		[:varNode| varNode comment: nil].	selectorSet := StdSelectors copy.	litIndSet := Dictionary new: 16.	literalStream := WriteStream on: (Array new: 32)! !!Parser methodsFor: 'expression types' stamp: 'eem 5/13/2008 14:32'!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [self interactive				ifFalse: [tempsMark := 1]				ifTrue: [tempsMark := requestor selectionInterval first].			^ #()].		tempsMark := (prevEnd ifNil: [0]) + 1.		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:51'!accept: aVisitor	aVisitor visitRemoteTempVectorNode: self! !!LeafNode methodsFor: 'copying' stamp: 'eem 7/12/2008 17:24'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."key := key.		Weakly copied"code := code veryDeepCopyWith: deepCopier.index := index veryDeepCopyWith: deepCopier.! !!MessageNode methodsFor: 'macro transformations' stamp: ''!transformCase: encoder	| caseNode |	caseNode _ arguments first.	(caseNode isKindOf: BraceNode)		ifTrue:			[^(caseNode blockAssociationCheck: encoder) and:			 	[arguments size = 1 or:					[self checkBlock: arguments last as: 'otherwise arg' from: encoder]]].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not])		ifTrue:			[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!LiteralNode methodsFor: 'initialize-release' stamp: 'eem 5/14/2008 09:30'!name: literal key: object index: i type: type	"For compatibility with Encoder>>name:key:class:type:set:"	^self key: object index: i type: type! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!sizeForStorePop: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStorePop: encoder].	code < 0 ifTrue:[		index := self index.		code := self code: index type: LdLitType].	writeNode := encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder) + 1! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!sizeForStore: encoder	| index |	(key isVariableBinding and:[key isSpecialWriteBinding]) 		ifFalse:[^super sizeForStore: encoder].	code < 0 ifTrue:[		index := self index.		code := self code: index type: LdLitType].	writeNode := encoder encodeSelector: #value:.	^(writeNode size: encoder args: 1 super: false) + (super sizeForValue: encoder)! !!MessageNode methodsFor: 'code generation' stamp: 'eem 7/29/2008 20:44'!emitForValue: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			pc := strm position + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'initialize-release' stamp: 'eem 7/18/2008 16:26'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range	"Compile."	((selName == #future) or:[selName == #future:]) ifTrue:		[Smalltalk at: #FutureNode ifPresent:			[:futureNode|			^futureNode new				receiver: rcvr				selector: selName				arguments: args				precedence: p				from: encoder				sourceRange: range]].	(rcvr isFutureNode	 and: [rcvr futureSelector == nil]) ifTrue:		"Transform regular message into future"		[^rcvr futureMessage: selName			arguments: args			from: encoder			sourceRange: range].	encoder noteSourceRange: range forNode: self.	^self		receiver: rcvr		selector: selName		arguments: args		precedence: p		from: encoder! !!Parser methodsFor: 'private' stamp: ''!initPattern: aString notifying: req return: aBlock	| result |	self		init: (ReadStream on: aString asString)		notifying: req		failBlock: [^nil].	encoder := self.	result := aBlock value: (self pattern: false inContext: nil).	encoder := failBlock := nil.  "break cycles"	^result! !!Compiler methodsFor: 'public access' stamp: 'eem 5/15/2008 15:11'!parse: textOrStream in: aClass notifying: req	"Compile the argument, textOrStream, with respect to the class, aClass, and	 answer the MethodNode that is the root of the resulting parse tree.  Notify the	 argument, req, if an error occurs. The failBlock is defaulted to an empty block."	self from: textOrStream class: aClass context: nil notifying: req.	^self parser		parse: sourceStream		class: class		noPattern: false		context: context		notifying: requestor		ifFail: []! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:01'!emitForValue: stack on: strm	super emitForValue: stack on: strm.	readNode ifNotNil:[readNode emit: stack args: 0 on: strm super: false].! !!Encoder methodsFor: 'private' stamp: 'eem 6/19/2008 13:02'!warnAboutShadowed: name	requestor addWarning: name,' is shadowed'.	selector ifNotNil:		[Transcript cr; show: class name,'>>', selector, '(', name,' is shadowed)']! !!Scanner methodsFor: 'expression types' stamp: 'ar 5/10/2005 12:24'!scanLitWord	"Accumulate keywords and asSymbol the result."	| t |	[(self typeTableAt: hereChar) = #xLetter]		whileTrue: 			[t := token.			self xLetter.			token := t , token].	token := token asSymbol! !!ParseNode methodsFor: 'testing' stamp: 'ar 7/10/2009 22:42'!isMessageNode	^false! !!MethodNode methodsFor: 'source mapping' stamp: 'eem 6/20/2008 15:09'!rawSourceRangesAndMethodDo: aBinaryBlock	"Evaluate aBinaryBlock with the rawSourceRanges and method generated from the receiver."	| methNode method |	methNode := sourceText					ifNil: "No source, use decompile string as source to map from"						[self parserClass new							encoderClass: encoder class;							parse: self decompileString							class: self methodClass]					ifNotNil: [self prepareForRegeneration.							 self].	method := methNode generate: #(0 0 0 0).  "set bytecodes to map to"	^aBinaryBlock		value: methNode encoder rawSourceRanges		value: method! !!MessageNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:09'!printReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^ self].	"Force parens around keyword receiver of kwd message"	rcvr printOn: aStream indent: level precedence: precedence! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'eem 8/21/2008 14:02'!codeInst: index	^InstanceVariableNode new		name: (instVars at: index + 1 ifAbsent: ['unknown', index asString])		index: index + 1! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:52'!accept: aVisitor	aVisitor visitMethodNode: self.	^aVisitor! !!BlockNode methodsFor: 'accessing' stamp: 'ar 7/10/2009 22:56'!temporaries	^temporaries! !!TempNumberNormalizingVisitor methodsFor: 'initialize-release' stamp: 'eem 9/23/2008 21:42'!initialize	count := 0.	temps := IdentitySet new! !!AssignmentNode methodsFor: 'printing' stamp: 'eem 5/6/2008 13:48'!printOn: aStream indent: level 	variable printOn: aStream indent: level.	aStream nextPutAll: ' := '.	value printOn: aStream indent: level + 2! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 15:41'!printKeywords: key arguments: args on: aStream indent: level	| keywords indent arg kwd doCrTab |	args size = 0 ifTrue:		[aStream space; nextPutAll: key.		 ^self].	keywords := key keywords.	doCrTab := args size > 2				or: [{receiver} , args anySatisfy:						[:thisArg |						thisArg notNil						and: [thisArg isBlockNode							 or: [thisArg isMessageNode and: [thisArg precedence >= 3]]]]].	1 to: (args size min: keywords size) do:		[:i |		arg := args at: i.		kwd := keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent := 1] "newline after big args"			ifFalse: [aStream space. indent := 0].		aStream nextPutAll: kwd; space.		arg printOn: aStream			indent: level + 1 + indent			precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence])]! !!Scanner methodsFor: 'expression types' stamp: 'ar 5/10/2005 12:24'!scanToken	[(tokenType := self typeTableAt: hereChar) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark := source position - 1.	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token := self step asSymbol "else just unique the first char"].	^token! !!Parser methodsFor: 'public access' stamp: 'eem 6/19/2008 09:38'!encoder	encoder isNil ifTrue:		[encoder := Encoder new].	^encoder! !!MethodNode methodsFor: 'accessing' stamp: 'ar 7/10/2009 22:56'!selectorNode	"Answer a SelectorNode for the message selector of the method represented by the receiver."	^(selectorOrFalse isMemberOf: SelectorNode)		ifTrue: [selectorOrFalse]		ifFalse: [SelectorNode new key: selectorOrFalse]! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:48'!accept: aVisitor	aVisitor visitSelectorNode: self! !!Scanner methodsFor: 'multi-character scans' stamp: 'eem 5/13/2008 13:00'!xBinary	tokenType := #binary.	token := String with: self step.	[hereChar ~~ $- and: [(self typeTableAt: hereChar) == #xBinary]] whileTrue:		[token := token, (String with: self step)].	token := token asSymbol! !!Scanner class methodsFor: 'instance creation' stamp: 'ar 1/30/2005 11:50'!new	^self basicNew initScanner! !!Scanner class methodsFor: 'testing' stamp: 'eem 9/29/2008 21:28'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i := aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [^('$''"()#0123456789_' includes: (aSymbol at: 1)) not].	ascii := (aSymbol at: 1) charCode.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type := TypeTable at: ascii ifAbsent: [#xLetter].	(type == #xColon or: [type == #verticalBar or: [type == #xBinary]]) ifTrue:		[^i = 1].	type == #xLetter ifTrue:		[[i > 1] whileTrue:			[ascii := (aSymbol at: i) charCode.			ascii = 0 ifTrue: [^false].			type := TypeTable at: ascii ifAbsent: [#xLetter].			(type == #xLetter or: [type == #xDigit or: [type == #xColon]]) ifFalse:				[^false].			i := i - 1].		^true].	^false! !!MethodNode methodsFor: 'tiles' stamp: 'RAA 2/16/2001 15:44'!asMorphicSyntaxIn: parent		^parent		methodNodeInner: self 		selectorOrFalse: selectorOrFalse 		precedence: precedence 		arguments: arguments 		temporaries: temporaries 		primitive: primitive 		block: block! !!TempNumberNormalizingVisitor methodsFor: 'visiting' stamp: 'eem 9/25/2008 11:52'!visitBlockNode: aBlockNode	aBlockNode arguments do:		[:tempNode|		self renumberTemp: tempNode].	aBlockNode temporaries do:		[:tempNode|		(tempNode scope >= 0 or: [tempNode isIndirectTempVector]) ifTrue:			[self renumberTemp: tempNode]].	super visitBlockNode: aBlockNode! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!LiteralNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:46'!printOn: aStream indent: level	key isVariableBinding		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##'; nextPutAll: key key]]		ifFalse:			[key storeOn: aStream]! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 16:34'!currentValueIn: aContext	aContext ifNil: [^nil].	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) value printString	! !!VariableNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:32'!accept: aVisitor	aVisitor visitVariableNode: self! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitCommentNode: aCommentNode! !!MethodNode methodsFor: 'printing' stamp: 'eem 7/18/2008 17:31'!printPropertiesOn: aStream	properties ifNil: [^self].	properties pragmas do:		[ :each |		 "Don't decompile basic primitives that return self, i-vars, etc."		 each keyword = #primitive:			ifFalse: [ aStream crtab: 1. each printOn: aStream ]			ifTrue: [ ((each argumentAt: 1) between: 255 and: 519) ifFalse:						[ aStream crtab: 1. self printPrimitiveOn: aStream ] ] ]! !!InstanceVariableNode methodsFor: 'initialize-release' stamp: 'eem 5/13/2008 10:17'!name: varName index: varIndex	^self name: varName index: varIndex-1 type: LdInstType! !!VariableNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:54'!asMorphicSyntaxIn: parent	^ parent addToken: self name			type: #variable 			on: self clone	"don't hand out the prototype!! See VariableNode>>initialize"! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:14'!accept: aVisitor	aVisitor visitBraceNode: self! !!MethodNode methodsFor: 'printing' stamp: 'eem 9/25/2008 15:22'!printOn: aStream	| selectorNode |	selectorNode := self selectorNode.	precedence = 1		ifTrue:			[selectorNode isForFFICall				ifTrue: [selectorNode							printAsFFICallWithArguments: arguments							on: aStream							indent: 0]				ifFalse: [aStream nextPutAll: selectorNode key]]		ifFalse:			[selectorNode key keywords with: arguments do:				[:kwd :arg |				aStream nextPutAll: kwd; space; nextPutAll: arg key; space]].	comment == nil ifFalse:		[aStream crtab: 1.		 self printCommentOn: aStream indent: 1].	block printTemporaries: temporaries on: aStream doPrior: [aStream crtab: 1].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	aStream crtab: 1.	block printStatementsOn: aStream indent: 0! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!emitStore: stack on: strm	writeNode ifNil:[^super emitStore: stack on: strm].	writeNode			emit: stack			args: 1			on: strm			super: false.! !!CommentNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:43'!accept: aVisitor	aVisitor visitCommentNode: self! !!MessageNode methodsFor: 'printing' stamp: 'eem 5/6/2008 13:57'!printIfOn: aStream indent: level	receiver ifNotNil:		[receiver printOn: aStream indent: level + 1 precedence: precedence].	(arguments last isJust: NodeNil) ifTrue:		[^self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!AssignmentNode methodsFor: 'printing' stamp: 'eem 5/9/2008 18:44'!printOn: aStream indent: level precedence: p	aStream nextPut: $(.	self printOn: aStream indent: level.	aStream nextPut: $)! !!BraceNode methodsFor: 'tiles' stamp: 'di 11/13/2000 21:17'!asMorphicSyntaxIn: parent	| row |	row := (parent addRow: #brace on: self) layoutInset: 1.	row addMorphBack: (StringMorph new contents: 		(String streamContents: [:aStream | self printOn: aStream indent: 0])).	^row! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitLiteralVariableNode: aLiteralVariableNode! !!ParseNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:47'!addCommentToMorph: aMorph	| row |	(self comment isNil or: [self comment isEmpty]) ifTrue: [^ self].	row := aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!ParseNode methodsFor: 'testing' stamp: 'eem 7/18/2008 16:22'!isFutureNode	^false! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 16:13'!visitCascadeNode: aCascadeNode	aCascadeNode receiver accept: self.	aCascadeNode messages do:		[:message| self visitMessageNodeInCascade: message]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/23/2008 11:00'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimized].	^true! !!FieldNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:49'!accept: aVisitor	aVisitor visitFieldNode: self! !!ReturnNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:18'!printOn: aStream indent: level	aStream nextPutAll: '^ '. "make this a preference??"	expr printOn: aStream indent: level.	expr printCommentOn: aStream indent: level! !!VariableNode methodsFor: 'testing' stamp: 'eem 5/21/2008 11:06'!index	"This code attempts to reconstruct the index from its encoding in code."	code < 0 ifTrue:[^nil].	code > 256 ifTrue:		[self assert: index = (code \\ 256).		^code \\ 256].	code >= (CodeBases at: self type) ifTrue:		[self assert: index = (code - (CodeBases at: self type)).		^code - (CodeBases at: self type)].	self assert: index = (code - self type).	^code - self type! !!BlockNode class methodsFor: 'instance creation' stamp: 'eem 5/19/2008 17:10'!withJust: aNode	^ self new statements: (Array with: aNode) returns: false! !!Parser methodsFor: 'error handling' stamp: 'eem 5/14/2008 13:34'!addWarning: aString	"ignored by the default compiler."! !!MethodNode methodsFor: 'converting' stamp: 'eem 5/6/2008 15:17'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^self printString! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:53'!visitMethodNode: aMethodNode	aMethodNode block accept: self! !!Parser methodsFor: 'public access' stamp: 'eem 5/6/2008 13:42'!parseArgsAndTemps: aString notifying: req         "Parse the argument, aString, notifying req if an error occurs. Otherwise,         answer a two-element Array containing Arrays of strings (the argument         names and temporary variable names)."        aString == nil ifTrue: [^#()].        doitFlag := false.               "Don't really know if a doit or not!!"        ^self initPattern: aString                notifying: req                return: [:pattern | (pattern at: 2) , (self temporariesIn: (pattern at: 1))]! !!LeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!emitLong: mode on: aStream 	"Emit extended variable access."	| type index |	code < 256		ifTrue:			[code < 16			ifTrue: [type := 0.					index := code]			ifFalse: [code < 32					ifTrue: [type := 1.							index := code - 16]					ifFalse: [code < 96							ifTrue: [type := code // 32 + 1.									index := code \\ 32]							ifFalse: [self error: 									'Sends should be handled in SelectorNode']]]]		ifFalse: 			[index := code \\ 256.			type := code // 256 - 1].	index <= 63 ifTrue:		[aStream nextPut: mode.		^ aStream nextPut: type * 64 + index].	"Compile for Double-exetended Do-anything instruction..."	mode = LoadLong ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(64 0 96 128) at: type+1).  "Cant be temp (type=1)"		^ aStream nextPut: index].	mode = Store ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(160 0 0 224) at: type+1).  "Cant be temp or const (type=1 or 2)"		^ aStream nextPut: index].	mode = StorePop ifTrue:		[aStream nextPut: DblExtDoAll.		aStream nextPut: (#(192 0 0 0) at: type+1).  "Can only be inst"		^ aStream nextPut: index].! !!VariableNode methodsFor: 'initialize-release' stamp: 'eem 5/14/2008 09:33'!name: varName index: i type: type	"Only used for initting instVar refs"	^self name: varName key: varName index: i type: type! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!Parser methodsFor: 'expression types' stamp: 'eem 7/18/2008 15:57'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	properties := MethodProperties new.	encoder := encoderToUse.	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [ self pragmaSequence ].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [ self pragmaSequence ].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^ methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:02'!sizeForValue: encoder	| index |	(key isVariableBinding and:[key isSpecialReadBinding]) 		ifFalse:[^super sizeForValue: encoder].	code < 0 ifTrue:[		index := self index.		code := self code: index type: LdLitType].	readNode := encoder encodeSelector: #value.	^(readNode size: encoder args: 0 super: false) + (super sizeForValue: encoder)! !!VariableNode methodsFor: 'testing' stamp: 'ar 3/26/2004 15:46'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^code < LdNil! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!Decompiler methodsFor: 'public access' stamp: 'eem 9/23/2008 22:07'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	^(constructor		codeMethod: aSelector		block: block		tempVars: tempVars		primitive: method primitive		class: aClass)			accept: TempNumberNormalizingVisitor new;			yourself! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:16'!accept: aVisitor	aVisitor visitCascadeNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/19/2008 17:12'!noteOptimized	optimized := true! !!ParseNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:50'!printCommentOn: aStream indent: indent 	| thisComment |	self comment == nil ifTrue: [^ self].	1 to: self comment size	   do: [:index |		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment := self comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"].	self comment: nil! !!MessageNode methodsFor: 'testing' stamp: 'ar 7/10/2009 22:42'!isMessageNode	^true! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]! !!Encoder methodsFor: 'accessing' stamp: 'ar 9/9/2006 12:06'!selector	^selector! !!MessageNode methodsFor: 'private' stamp: 'eem 9/25/2008 14:48'!checkBlock: node as: nodeName from: encoder maxArgs: maxArgs	"vb: #canBeSpecialArgument for blocks hardcodes 0 arguments as the requirement for special blocks. We work around that here by further checking the number of arguments for blocks.."	node canBeSpecialArgument ifTrue: 		[^node isBlockNode].	^node isBlockNode		ifTrue:			[node numberOfArguments <= maxArgs				ifTrue: [true]				ifFalse: [encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' has too many arguments']]		ifFalse:			[encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:12'!accept: aVisitor	aVisitor visitAssignmentNode: self! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!BlockNode methodsFor: 'testing' stamp: 'eem 9/25/2008 12:10'!isBlockNode	^true! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 5/10/2005 12:23'!typeTableAt: aCharacter	^typeTable at: aCharacter charCode ifAbsent:[#xLetter]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 01:59'!emitLoad: stack on: strm	writeNode ifNil:[^super emitLoad: stack on: strm].	code < 256		ifTrue: [strm nextPut: code]		ifFalse: [self emitLong: LoadLong on: strm].	stack push: 1.! !!MethodNode methodsFor: 'converting' stamp: 'eem 5/6/2008 15:17'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^self asColorizedSmalltalk80Text! !!Encoder methodsFor: 'initialize-release' stamp: 'eem 7/18/2008 12:51'!init: aClass context: aContext notifying: req	requestor := req.	class := aClass.	nTemps := 0.	supered := false.	self initScopeAndLiteralTables.	class variablesAndOffsetsDo:		[:variable "<String|CFieldDefinition>" :offset "<Integer|nil>" |		offset isNil			ifTrue: [scopeTable						at: variable name						put: ((Smalltalk at: #FieldNode ifAbsent: [self error: 'FiledNode is missing'])								new fieldDefinition: variable)]			ifFalse: [scopeTable						at: variable						put: (offset >= 0								ifTrue: [InstanceVariableNode new											name: variable index: offset]								ifFalse: [MaybeContextInstanceVariableNode new											name: variable index: offset negated])]].	aContext ~~ nil ifTrue:		[| homeNode |		 homeNode := self bindTemp: self doItInContextName.		 "0th temp = aContext passed as arg"		 aContext tempNames withIndexDo:			[:variable :index|			scopeTable				at: variable				put: (MessageAsTempNode new						receiver: homeNode						selector: #namedTempAt:						arguments: (Array with: (self encodeLiteral: index))						precedence: 3						from: self)]].	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32! !!Compiler class methodsFor: 'accessing' stamp: 'eem 5/13/2008 11:37'!parserClass	"Answer a parser class to use for parsing methods compiled by instances of the receiver."	^Parser! !!FieldNode methodsFor: 'initialize-release' stamp: 'eem 5/12/2008 13:40'!fieldDefinition: fieldDefinition	self name: fieldDefinition name key: fieldDefinition index: nil type: LdLitType! !!BlockNode methodsFor: 'accessing' stamp: 'ar 7/10/2009 22:55'!arguments	^arguments! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitNewArrayNode: aNewArrayNode! !!Parser methodsFor: 'expression types' stamp: 'eem 7/16/2008 11:05'!pattern: fromDoit inContext: ctxt	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>	{selector, arguments, precedence}."	| args selector |	doitFlag := fromDoit.	fromDoit ifTrue:		[^ctxt == nil			ifTrue: [{#DoIt. {}. 1}]			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3}]].	hereType == #word ifTrue: [^ {self advance asSymbol. {}. 1}].	(hereType == #binary or: [hereType == #verticalBar]) ifTrue: 		[selector := self advance asSymbol.		args := Array with: (encoder bindArg: self argumentName).		^ {selector. args. 2}].	hereType == #keyword ifTrue: 		[selector := WriteStream on: (String new: 32).		args := OrderedCollection new.		[hereType == #keyword] whileTrue:[			selector nextPutAll: self advance.			args addLast: (encoder bindArg: self argumentName).		].		^ {selector contents asSymbol. args. 3}].	hereType == #positionalMessage ifTrue:[		args := OrderedCollection new.		selector := self advance.		hereType == #rightParenthesis ifTrue:[self advance. ^{(selector,'/0') asSymbol. args. 1}].		[			args addLast: (encoder bindArg: self argumentName).			hereType == #rightParenthesis ifTrue:[				self advance. 				selector := (selector,'/', args size printString) asSymbol.				^{selector. args. 1}].			here == #, ifFalse:[self expected: 'comma'].			self advance.		] repeat.	].	^self expected: 'Message pattern'! !!VariableNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:54'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		index := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		index := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!MethodNode methodsFor: 'converting' stamp: 'ar 7/10/2009 23:08'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	| printText |	printText := self printString asText.	^(Smalltalk at: #SHTextStylerST80 ifAbsent: [nil])		ifNotNilDo: [:stylerClass| stylerClass new styledTextFor: printText]		ifNil: [printText]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitLiteralNode: aLiteralNode! !!MessageNode methodsFor: 'printing' stamp: 'eem 5/6/2008 13:56'!printCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode := arguments first.	otherwise := arguments last.	(arguments size = 1 or: [otherwise isJustCaseError]) ifTrue:		[otherwise := nil].	receiver		printOn: aStream		indent: level		precedence: 3.	aStream nextPutAll: ' caseOf: '.	braceNode isVariableReference		ifTrue: [braceNode printOn: aStream indent: level]		ifFalse: 			[aStream nextPutAll: '{'; crtab: level + 1.			 braceNode casesForwardDo:				[:keyNode :valueNode :last | 				keyNode printOn: aStream indent: level + 1.				aStream nextPutAll: ' -> '.				valueNode isComplex					ifTrue: 						[aStream crtab: level + 2.						extra := 1]					ifFalse: [extra := 0].				valueNode printOn: aStream indent: level + 1 + extra.				last ifTrue: [aStream nextPut: $}]					ifFalse: [aStream nextPut: $.;							 crtab: level + 1]]].	otherwise notNil ifTrue:		[aStream crtab: level + 1; nextPutAll: ' otherwise: '.		 extra := otherwise isComplex					ifTrue: 						[aStream crtab: level + 2.						 1]					ifFalse: [0].		 otherwise printOn: aStream indent: level + 1 + extra]! !!CascadeNode methodsFor: 'tiles' stamp: 'RAA 2/22/2001 13:56'!asMorphicSyntaxIn: parent	^parent		cascadeNode: self 		receiver: receiver 		messages: messages! !!Parser methodsFor: 'error correction' stamp: 'eem 8/21/2008 14:13'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	| tempIvar labels actions lines alternatives binding userSelection choice action |	"Check if this is an i-var, that has been corrected already (ugly)"	(encoder classEncoding allInstVarNames includes: proposedVariable) ifTrue: [		^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive 		ifFalse: [ ^encoder undeclared: proposedVariable ].	"First check to see if the requestor knows anything about the variable"	tempIvar := proposedVariable first canBeNonGlobalVarInitial.	(tempIvar and: [ (binding := requestor bindingOf: proposedVariable) notNil ])		ifTrue: [ ^encoder global: binding name: proposedVariable ].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	labels := OrderedCollection new. actions := OrderedCollection new. lines := OrderedCollection new.	alternatives := encoder possibleVariablesFor: proposedVariable.	tempIvar 		ifTrue: [ 			labels add: 'declare temp'. 			actions add: [ self declareTempAndPaste: proposedVariable ].			labels add: 'declare instance'.			actions add: [ self declareInstVar: proposedVariable ] ]		ifFalse: [ 			labels add: 'define new class'.			actions add: [self defineClass: proposedVariable].			labels add: 'declare global'.			actions add: [ self declareGlobal: proposedVariable ].			encoder classEncoding == UndefinedObject ifFalse: [ 				labels add: 'declare class variable'.				actions add: [ self declareClassVar: proposedVariable ] ] ].	lines add: labels size.	alternatives do: [ :each | 		labels add: each.		actions add: [ 			self substituteWord: each wordInterval: spot offset: 0.			encoder encodeVariable: each ] fixTemps ].	lines add: labels size.	labels add: 'cancel'.	"Display the pop-up menu"	choice := (UIManager default chooseFrom: labels asArray lines: lines asArray		title:  'Unknown variable: ', proposedVariable, ' please correct, or cancel:').	action := actions at: choice ifAbsent: [ ^self fail ].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Scanner methodsFor: 'multi-character scans' stamp: 'eem 5/13/2008 13:05'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type := self typeTableAt: hereChar) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar := aheadChar.			aheadChar := source atEnd							ifTrue: [30 asCharacter "doit"]							ifFalse: [source next]].	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])					ifTrue: 						[buffer nextPut: self step.						"Allow any number of embedded colons in literal symbols"						[(self typeTableAt: hereChar) == #xColon] whileTrue:							[buffer nextPut: self step].						#keyword]					ifFalse: 						[type == #leftParenthesis 							ifTrue:								[buffer nextPut: self step; nextPut: $).								 #positionalMessage]							ifFalse:[#word]].	token := buffer contents! !!AssignmentNode methodsFor: 'tiles' stamp: 'RAA 2/26/2001 16:17'!asMorphicSyntaxIn: parent	^parent assignmentNode: self variable: variable value: value! !!Encoder methodsFor: 'accessing' stamp: 'ar 9/9/2006 12:06'!selector: aSymbol	selector := aSymbol! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:48'!accept: aVisitor	aVisitor visitLiteralNode: self! !!DecompilerConstructor methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:44'!accept: aVisitor	"I am not really a ParseNode.  Only here to access constants defined in parseNode."	self shouldNotImplement! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!emitForEffect: stack on: strm! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'ar 8/14/2003 02:00'!emitStorePop: stack on: strm	writeNode ifNil:[^super emitStorePop: stack on: strm].	self emitStore: stack on: strm.	strm nextPut: Pop.	stack pop: 1.! !!TempVariableNode methodsFor: 'initialize-release' stamp: 'eem 9/8/2008 18:27'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	isAnArg := hasDefs := hasRefs := false.	scope := level.	^super name: varName key: varName index: i type: type! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!sizeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeForValue: encoder) + 			(writeNode size: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeForValue: encoder) + 		(super sizeForValue: encoder) +			(writeNode size: encoder args: 2 super: false)! !!MethodNode methodsFor: 'source mapping' stamp: 'eem 6/4/2008 19:21'!rawSourceRanges	^self rawSourceRangesAndMethodDo: [:rawSourceRanges :method| rawSourceRanges]! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!LeafNode methodsFor: 'copying' stamp: 'eem 5/14/2008 11:25'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.key := (deepCopier references at: key ifAbsent: [key]).! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitTempVariableNode: aTempVariableNode! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!sizeForStorePop: encoder	^(self sizeForStore: encoder) + 1! !!TempVariableNode methodsFor: 'printing' stamp: 'eem 5/8/2008 11:39'!printOn: aStream indent: level 	aStream nextPutAll: name! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:13'!accept: aVisitor	aVisitor visitBlockNode: self! !!LeafNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!ParseNode methodsFor: 'testing' stamp: 'eem 9/25/2008 12:11'!isBlockNode	^false! !!LiteralNode methodsFor: 'tiles' stamp: 'tk 8/24/2001 15:43'!asMorphicSyntaxIn: parent	| row |	row := parent addRow: #literal on: self.	(key isVariableBinding) ifFalse: [		row layoutInset: 1.		^ row addMorphBack: (row addString: key storeString special: false)].	key key isNil ifTrue: [		^ row addTextRow: ('###',key value soleInstance name)	] ifFalse: [		^ row addTextRow: ('##', key key)	].	! !!Encoder methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:44'!accept: aVisitor	"I am not really a ParseNode.  Only here to access constants defined in parseNode."	self shouldNotImplement! !!MaybeContextInstanceVariableNode methodsFor: 'accessing' stamp: 'eem 6/19/2008 09:27'!code	"Answer a bogus code to avoid creating quick methods.	 See MethodNode>>generate:ifQuick:"	^LoadLong! !!CascadeNode methodsFor: 'accessing' stamp: 'eem 9/10/2008 15:15'!messages	^messages! !!BlockNode methodsFor: 'tiles' stamp: 'RAA 2/16/2001 09:08'!asMorphicSyntaxIn: parent	^parent 		blockNode: self 		arguments: arguments 		statements: statements! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:26'!emitForEffect: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	pc := aStream position + 1. "debug pc is first byte of the store".	variable emitStorePop: stack on: aStream! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!emitForValue: stack on: aStream	fieldDef accessKey ifNil:[		rcvrNode emitForValue: stack on: aStream.		readNode emit: stack args: 0 on: aStream super: false.	] ifNotNil:[		rcvrNode emitForValue: stack on: aStream.		super emitForValue: stack on: aStream.		readNode emit: stack args: 1 on: aStream super: false.	].! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 16:13'!visitMessageNodeInCascade: aMessageNode.	"receiver is nil for cascades"	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!Encoder methodsFor: 'private' stamp: 'ar 3/26/2004 15:44'!interactive	^requestor interactive! !!LeafNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 15:24'!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!VariableNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:46'!sizeForReturn: encoder	(code >= LdSelf and: [code <= LdNil])		ifTrue: ["short returns" ^1].	^super sizeForReturn: encoder! !!LeafNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/19/2008 15:10'!sizeCodeForValue: encoder	self subclassResponsibility! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:26'!emitForValue: stack on: aStream	variable emitLoad: stack on: aStream.	value emitForValue: stack on: aStream.	pc := aStream position + 1. "debug pc is first byte of the store"	variable emitStore: stack on: aStream! !!Compiler methodsFor: 'public access' stamp: 'eem 5/6/2008 15:16'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode := self format: sourceStream noPattern: false ifFail: [^ nil].	aSymbol == #colorPrint ifTrue:		[^aNode asColorizedSmalltalk80Text].	^aNode decompileString! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 16:12'!printOn: aStream indent: level	"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	special > 0 ifTrue:		[^self perform: self macroPrinter with: aStream with: level].	self printReceiver: receiver on: aStream indent: level.	selector isForFFICall		ifTrue:			[aStream space.			 selector				printAsFFICallWithArguments: arguments				on: aStream				indent: 0]		ifFalse:			[self printKeywords: selector key				 arguments: arguments				 on: aStream				 indent: level]! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:53'!accept: aVisitor	aVisitor visitReturnNode: self! !!LeafNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^self! !!ParseNode methodsFor: 'visiting' stamp: 'eem 5/30/2008 09:36'!accept: aVisitor	^self subclassResponsibility! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 13:06'!currentValueIn: aContext	^nil! !!MaybeContextInstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 5/14/2008 09:11'!assignmentCheck: encoder at: location	^(encoder cantStoreInto: name) ifTrue: [location] ifFalse: [-1]! !!VariableNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:46'!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name := string.	key := object.	code := byte! !!BlockNode methodsFor: 'accessing' stamp: 'gk 4/6/2006 11:29'!returnSelfIfNoOther: encoder	self returns ifTrue:[^self].	statements last == NodeSelf ifFalse: [		statements := statements copyWith: (encoder encodeVariable: 'self').	].	self returnLast.! !!ReturnNode methodsFor: 'tiles' stamp: 'RAA 2/26/2001 06:44'!asMorphicSyntaxIn: parent	^parent returnNode: self expression: expr! !!MethodNode methodsFor: 'tiles' stamp: 'tk 8/5/2001 11:40'!asMorphicSyntaxUsing: aClass		^ Cursor wait showWhile: [		(aClass methodNodeOuter: self) finalAppearanceTweaks]		! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 12:24'!asMorphicSyntaxIn: parent	| morph |	"Default for missing implementations"	morph := parent addColumn: #error on: self.	morph addTextRow: self class printString.	^morph	! !!MessageNode methodsFor: 'printing' stamp: 'eem 5/6/2008 14:14'!printWhileOn: aStream indent: level	self printReceiver: receiver on: aStream indent: level.	(arguments isEmpty not	 and: [arguments first isJust: NodeNil]) ifTrue:			[selector := SelectorNode new							key:									(selector key == #whileTrue:										ifTrue: [#whileTrue]										ifFalse: [#whileFalse])							code: #macro.			arguments := Array new].	self printKeywords: selector key arguments: arguments		on: aStream indent: level! !!Parser methodsFor: 'error correction' stamp: 'eem 8/21/2008 13:56'!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 15:57'!reserve: encoder 	"If this is a yet unused literal of type -code, reserve it."	code < 0 ifTrue: [code := self code: (index := encoder litIndex: key) type: 0 - code]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 5/30/2008 10:07'!visitInstanceVariableNode: anInstanceVariableNode! !!SelectorNode methodsFor: 'initialize-release' stamp: 'eem 5/14/2008 09:30'!name: literal key: object index: i type: type	"For compatibility with Encoder>>name:key:class:type:set:"	^self key: object index: i type: type! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:14'!visitBraceNode: aBraceNode	aBraceNode elements do:		[:element| element accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:10'!visitAssignmentNode: anAssignmentNode	"N.B.  since assigment happens after the value is evaluated the value is visited first."	anAssignmentNode value accept: self.	anAssignmentNode variable accept: self! !!Parser methodsFor: 'expression types' stamp: 'eem 8/4/2008 10:56'!statements: argNodes innerBlock: inner blockNode: theBlockNode	| stmts returns start |	"give initial comment to block, since others trail statements"	theBlockNode comment: currentComment.	stmts := OrderedCollection new.	returns := false.	hereType ~~ #rightBracket ifTrue:		[[theBlockNode startOfLastStatement: (start := self startOfNextToken).		  (returns := self matchReturn)			ifTrue: 				[self expression ifFalse:					[^self expected: 'Expression to return'].				 self addComment.				 stmts addLast: (parseNode isReturningIf								ifTrue: [parseNode]								ifFalse: [ReturnNode new											expr: parseNode											encoder: encoder											sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						 stmts addLast: parseNode]					ifFalse: 						[self addComment.						 stmts size = 0 ifTrue: 							[stmts addLast: 								(encoder encodeVariable:									(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		  returns ifTrue: 			[self match: #period.			 (hereType == #rightBracket or: [hereType == #doIt]) ifFalse:				[^self expected: 'End of block']].		  returns not and: [self match: #period]] whileTrue].	theBlockNode		arguments: argNodes		statements: stmts		returns: returns		from: encoder.	parseNode := theBlockNode.	^true! !!Scanner methodsFor: 'expression types' stamp: 'eem 5/13/2008 12:47'!scanLitVec	| s |	s := WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]] whileFalse:		[tokenType = #leftParenthesis			ifTrue: 				[self scanToken; scanLitVec]			ifFalse: 				[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])					ifTrue: 						[self scanLitWord.						token = #true ifTrue: [token := true].						token = #false ifTrue: [token := false].						token = #nil ifTrue: [token := nil]]					ifFalse:						[(token == #- 						  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue: 							[self scanToken.							 token := token negated]]].		s nextPut: token.		self scanToken].	token := s contents! !!Parser methodsFor: 'public access' stamp: 'eem 5/14/2008 15:24'!encoderClass: anEncoderClass	encoder notNil ifTrue:		[self error: 'encoder already set'].	encoder := anEncoderClass new! !!BlockNode methodsFor: 'printing' stamp: 'ar 7/10/2009 22:57'!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	(tempSequence == nil	 or: [tempSequence size = 0	 or: [tempSequence allSatisfy: [:temp|								   temp scope < 0								   and: [temp isIndirectTempVector not]]]]) ifTrue:		[^false].	aBlock value.	aStream nextPut: $|.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 tempVariableNode scope >= 0 ifTrue:						[aStream space; nextPutAll: tempVariableNode key]]]			ifFalse:				[tempNode scope >= 0 ifTrue:					[aStream space; nextPutAll: tempNode key]]].	aStream		space;		nextPut: $|.	^true! !!Parser methodsFor: 'public access' stamp: 'ar 9/27/2005 19:19'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	^self parse: sourceStream class: class category: nil noPattern: noPattern context: ctxt notifying: req ifFail: aBlock ! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/12/2008 13:40'!emitStore: stack on: strm	fieldDef accessKey ifNil:[		writeNode emit: stack args: 1 on: strm super: false.	] ifNotNil:[		writeNode emit: stack args: 2 on: strm super: false.	].! !!LeafNode methodsFor: 'initialize-release' stamp: 'ar 3/26/2004 15:44'!name: ignored key: object code: byte	key := object.	code := byte! !!Decompiler methodsFor: 'private' stamp: 'eem 5/13/2008 15:41'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames := self class allInstVarNames.	code := (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , (code copyFrom: 4 to: code size), '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!LeafNode methodsFor: 'code generation' stamp: 'ar 3/26/2004 15:44'!sizeForValue: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 1].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!FieldNode methodsFor: 'testing' stamp: 'eem 5/12/2008 13:40'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name) ifTrue: [^location].	fieldDef toSet ifNil:[		encoder interactive ifTrue:[^location].		fieldDef := fieldDef clone assignDefaultSetter.	].	^-1! !!TempNumberNormalizingVisitor methodsFor: 'visiting' stamp: 'eem 9/23/2008 21:48'!visitTempVariableNode: aTempVariableNode		self renumberTemp: aTempVariableNode! !SyntaxAttribute removeSelector: #emphasis:!VariableNode removeSelector: #name:!SyntaxAttribute classSide removeSelector: #color:emphasis:!SyntaxAttribute removeSelector: #emphasis!LeafNode removeSelector: #key:!SyntaxAttribute removeSelector: #attributeList!SyntaxAttribute removeSelector: #color:!SyntaxAttribute removeSelector: #color!LeafNode removeSelector: #code:!LeafNode removeSelector: #name:key:index:type:!Parser removeSelector: #keylessMessagePartTest:repeat:!BlockNode removeSelector: #arguments:statements:returns:from:sourceRange:!Smalltalk removeClassNamed: #SyntaxAttribute!Parser initialize!