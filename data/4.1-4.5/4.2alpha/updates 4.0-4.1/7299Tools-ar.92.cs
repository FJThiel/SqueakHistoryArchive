"Change Set:		7299Tools-ar.92Tools-ar.92:Prerequiste changes for Closure installation."!Inspector subclass: #ContextVariablesInspector	instanceVariableNames: 'fieldList'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!Object subclass: #DebuggerMethodMap	instanceVariableNames: 'timestamp methodReference methodNode abstractSourceRanges sortedSourceMap'	classVariableNames: 'MapCacheEntries MapCache'	poolDictionaries: ''	category: 'Tools-Debugger'!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC debuggerMap savedCursor isolationHead failedProject errorWasInUIProcess labelString'	classVariableNames: 'ContextStackKeystrokes ErrorRecursion'	poolDictionaries: ''	category: 'Tools-Debugger'!DebuggerMethodMap subclass: #DebuggerMethodMapForClosureCompiledMethods	instanceVariableNames: 'blockExtentsToTempRefs startpcsToTempRefs'	classVariableNames: 'FirstTime'	poolDictionaries: ''	category: 'Tools-Debugger'!DebuggerMethodMap subclass: #DebuggerMethodMapForBlueBookMethods	instanceVariableNames: 'tempNames'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!Debugger methodsFor: 'context stack menu' stamp: 'eem 5/21/2008 10:39'!implement: aMessage inClass: aClass		aClass		compile: aMessage createStubMethod		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').	self setContentsToForceRefetch.	self selectedContext privRefreshWith: (aClass lookupSelector: aMessage selector).	self selectedContext method numArgs > 0 ifTrue:		[(self selectedContext tempAt: 1) arguments withIndexDo:			[:arg :index|			self selectedContext tempAt: index put: arg]].	self resetContext: self selectedContext.	self debug.! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'eem 6/5/2008 09:14'!voidMapCache	MapCache := WeakIdentityKeyDictionary new.	MapCacheEntries := 16! !!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'eem 6/26/2008 22:59'!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod	MapCache finalizeValues.	[MapCache size >= MapCacheEntries] whileTrue:		[| mapsByAge |		 mapsByAge := MapCache keys asSortedCollection:							[:m1 :m2|							(MapCache at: m1) timestamp							< (MapCache at: m2) timestamp].		mapsByAge notEmpty ifTrue: "There be race conditions and reentrancy issues here"			[MapCache removeKey: mapsByAge last]].	^MapCache		at: aCompiledMethod		put: aDebuggerMethodMap! !!DebuggerMethodMap methodsFor: 'initialize-release' stamp: 'eem 6/5/2008 09:21'!forMethod: aMethod "<CompiledMethod>" methodNode: theMethodNode "<MethodNode>"	methodReference := WeakArray with: aMethod.	methodNode := theMethodNode.	self markRecentlyUsed! !!Debugger methodsFor: 'accessing' stamp: 'eem 6/24/2008 09:53'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		result := self contents: aText notifying: aController.		self contentsChanged.		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	contents := aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil.			debuggerMap := nil].	self resetContext: ctxt.	Smalltalk isMorphic ifTrue:		[World			addAlarm: #changed:			withArguments: #(contentsSelection)			for: self			at: (Time millisecondClockValue + 200)].	^true! !!Debugger methodsFor: 'code pane menu' stamp: 'sd 11/20/2005 21:27'!runToSelection: selectionInterval	| currentContext |	self pc first >= selectionInterval first ifTrue: [ ^self ].	currentContext := self selectedContext.	[ currentContext == self selectedContext and: [ self pc first < selectionInterval first ] ] whileTrue: [ self doStep ].! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/10/2008 09:44'!namedTempAt: index in: aContext	"Answer the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:"	self subclassResponsibility! !!Debugger methodsFor: 'private' stamp: 'eem 6/5/2008 16:31'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| isNewMethod selectedContextSlotName index |	contextStackIndex := anInteger.	anInteger = 0 ifTrue:		[currentCompiledMethod := debuggerMap := contents := nil.		 self changed: #contextStackIndex.		 self decorateButtons.		 self contentsChanged.		 contextVariablesInspector object: nil.		 receiverInspector object: self receiver.		 ^self].	selectedContextSlotName := contextVariablesInspector selectedSlotName.	isNewMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)].	isNewMethod ifTrue:		[debuggerMap := nil.		 contents := self selectedMessage.		 self contentsChanged.		 self pcRange].	self changed: #contextStackIndex.	self decorateButtons.	contextVariablesInspector object: self selectedContext.	((index := contextVariablesInspector fieldList indexOf: selectedContextSlotName) ~= 0	 and: [index ~= contextVariablesInspector selectionIndex]) ifTrue:		[contextVariablesInspector toggleIndex: index].	receiverInspector object: self receiver.	isNewMethod ifFalse:		[self changed: #contentsSelection]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'ar 7/10/2009 23:19'!privateTempRefsForContext: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents	"Answer the sequence of temps in scope in aContext in the natural order,	 outermost arguments and temporaries first, innermost last.  Each temp is	 a pair of the temp's name followed by a reference.  The reference can be		integer - index of temp in aContext		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index in aContext		#( outer. temp reference ) - a temp reference in an outer context."	self ensureExtentsMapsInitialized.	^startpcsToTempRefs		at: aContext startpc		ifAbsentPut:			[| localRefs |			 localRefs := blockExtentsToTempRefs at: (theContextsStartpcsToBlockExtents at: aContext startpc).			 aContext outerContext				ifNil: [localRefs]				ifNotNilDo:					[:outer| | outerTemps |					"Present temps in the order outermost to innermost left-to-right, but replace					 copied outermost temps with their innermost copies"					 outerTemps := (self										privateTempRefsForContext: outer										startpcsToBlockExtents: theContextsStartpcsToBlockExtents) collect:						[:outerPair|						localRefs							detect: [:localPair| outerPair first = localPair first]							ifNone: [{ outerPair first. { #outer. outerPair last } }]].					outerTemps,					 (localRefs reject: [:localPair| outerTemps anySatisfy: [:outerPair| localPair first = outerPair first]])]]! !!Debugger methodsFor: 'code pane menu' stamp: 'nk 8/6/2003 13:52'!codePaneMenu: aMenu shifted: shifted	aMenu add: 'run to here' target: self selector: #runToSelection: argument: thisContext sender receiver selectionInterval.	aMenu addLine.	super codePaneMenu: aMenu shifted: shifted.	^aMenu.! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'eem 6/10/2008 09:37'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2 ifTrue: [^object stackPtr > 0 ifTrue: [object top]].	selectionIndex = 3 ifTrue: [^object tempsAndValues].	^object debuggerMap namedTempAt: selectionIndex - 3 in: object! !!DebuggerMethodMapForBlueBookMethods methodsFor: 'initialize-release' stamp: 'eem 6/5/2008 10:34'!forMethod: aMethod "<CompiledMethod>" methodNode: aMethodNode "<MethodNode>"	super forMethod: aMethod methodNode: aMethodNode.	tempNames := methodNode encoder tempNames! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'eem 6/5/2008 10:50'!sourceText	^methodNode sourceText! !!DebuggerMethodMapForBlueBookMethods methodsFor: 'accessing' stamp: 'eem 6/3/2008 11:43'!namedTempAt: index in: aContext	"Answer the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:"	^aContext tempAt: index! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'eem 7/18/2008 11:18'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	^selectionIndex = 1		ifTrue: [object]		ifFalse: [object namedTempAt: selectionIndex - 3 put: anObject]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'accessing' stamp: 'eem 7/29/2008 19:33'!namedTempAt: index put: aValue in: aContext	"Assign the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:.	 If the value is a copied value we also need to set it along the lexical chain."	^self		privateTempAt: index		in: aContext		put: aValue		startpcsToBlockExtents: aContext method startpcsToBlockExtents! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'accessing' stamp: 'eem 7/29/2008 18:26'!tempNamesForContext: aContext	"Answer an Array of all the temp names in scope in aContext starting with	 the home's first local (the first argument or first temporary if no arguments)."	^(self		privateTempRefsForContext: aContext		startpcsToBlockExtents: aContext method startpcsToBlockExtents) collect:			[:pair| pair first]! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/5/2008 09:21'!method	^methodReference at: 1! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 20:03'!privateTempAt: index in: aContext put: aValue startpcsToBlockExtents: theContextsStartpcsToBlockExtents	| nameRefPair |	nameRefPair := (self privateTempRefsForContext: aContext						 startpcsToBlockExtents: theContextsStartpcsToBlockExtents)						at: index						ifAbsent: [aContext errorSubscriptBounds: index].	^self privateDereference: nameRefPair last in: aContext put: aValue! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/2/2008 18:32'!timestamp	^timestamp! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 19:26'!privateDereference: tempReference in: aContext	"Fetch the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue: [aContext tempAt: tempReference]		ifFalse:			[tempReference first == #outer				ifTrue: [self privateDereference: tempReference last							in: aContext outerContext]				ifFalse: [(aContext tempAt: tempReference first)							at: tempReference second]]! !!ContextVariablesInspector methodsFor: 'accessing' stamp: 'ar 4/11/2006 02:33'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection.		Because no object's inspectorClass method answers this class, it is OK for this method to	override Inspector >> inspect: "	fieldList := nil.	object := anObject.	self initialize.	! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 20:09'!ensureExtentsMapsInitialized	| encoderTempRefs "<Dictionary of: Interval -> <Array of: <String | <Array of: String>>>>" |	blockExtentsToTempRefs ifNotNil: [^self].	blockExtentsToTempRefs := Dictionary new.	startpcsToTempRefs := Dictionary new.	encoderTempRefs := methodNode blockExtentsToTempRefs.	encoderTempRefs keysAndValuesDo:		[:blockExtent :tempVector|		blockExtentsToTempRefs			at: blockExtent			put: (Array streamContents:					[:stream|					tempVector withIndexDo:						[:nameOrSequence :index|						nameOrSequence isString							ifTrue:								[stream nextPut: {nameOrSequence. index}]							ifFalse:								[nameOrSequence withIndexDo:									[:name :indirectIndex|									stream nextPut: { name. { index. indirectIndex }}]]]])]! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'eem 6/5/2008 09:14'!initialize	"DebuggerMethodMap initialize"	self voidMapCache! !!Debugger methodsFor: 'context stack (message list)' stamp: 'eem 6/5/2008 11:27'!selectedMessage	"Answer the source code of the currently selected context."	debuggerMap isNil ifTrue:		[debuggerMap := self selectedContext debuggerMap].	^contents := debuggerMap sourceText asText makeSelectorBold! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/3/2008 12:21'!markRecentlyUsed	timestamp := Time totalSeconds! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/10/2008 09:44'!namedTempAt: index put: aValue in: aContext	"Assign the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:"	self subclassResponsibility! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/10/2008 09:45'!tempNamesForContext: aContext	"Answer an Array of all the temp names in scope in aContext starting with	 the home's first local (the first argument or first temporary if no arguments)."	self subclassResponsibility! !!DebuggerMethodMap methodsFor: 'accessing' stamp: 'eem 6/10/2008 09:47'!tempsAndValuesForContext: aContext	"Return a string of the temporary variabls and their current values"	| aStream |	aStream := WriteStream on: (String new: 100).	(self tempNamesForContext: aContext) doWithIndex:		[:title :index |		 aStream nextPutAll: title; nextPut: $:; space; tab.		 aContext print: (self namedTempAt: index in: aContext) on: aStream.		 aStream cr].	^aStream contents! !!ProcessBrowser methodsFor: 'accessing' stamp: 'eem 6/12/2008 12:41'!stackListIndex: index 	stackListIndex := index.	selectedContext := (stackList notNil						and: [index > 0]) ifTrue:							[stackList at: index ifAbsent: []].	selectedClass := nil.	selectedSelector := nil.	methodText := nil.	self changed: #stackListIndex.	self changed: #selectedMethod! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'eem 7/29/2008 17:12'!abstractSourceMap	"Answer with a Dictionary of abstractPC <Integer> to sourceRange <Interval>."	| theMethodToScan rawSourceRanges concreteSourceRanges abstractPC scanner client |	abstractSourceRanges ifNotNil:		[^abstractSourceRanges].	"If the methodNode hasn't had a method generated it doesn't have pcs set in its	 nodes so we must generate a new method and might as well use it for scanning."	methodNode rawSourceRangesAndMethodDo:		[:ranges :method|		 rawSourceRanges := ranges.		 theMethodToScan := method].	concreteSourceRanges := Dictionary new.	rawSourceRanges keysAndValuesDo:		[:node :range|		node pc ~= 0 ifTrue:			[concreteSourceRanges at: node pc put: range]].	abstractPC := 1.	abstractSourceRanges := Dictionary new.	scanner := InstructionStream on: theMethodToScan.	client := InstructionClient new.	[(concreteSourceRanges includesKey: scanner pc) ifTrue:		[abstractSourceRanges at: abstractPC put: (concreteSourceRanges at: scanner pc)].	 abstractPC := abstractPC + 1.	 scanner interpretNextInstructionFor: client.	 scanner atEnd] whileFalse.	^abstractSourceRanges! !!Inspector methodsFor: 'selecting' stamp: 'eem 5/21/2008 11:46'!selectedSlotName	^ self fieldList at: self selectionIndex ifAbsent: []! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'eem 7/29/2008 16:54'!forMethod: aMethod "<CompiledMethod>" methodNode: methodNode "<MethodNode>"	"Uncached instance creation method for private use or for tests.	 Please consider using forMethod: instead."	^(aMethod isBlueBookCompiled			ifTrue: [DebuggerMethodMapForBlueBookMethods]			ifFalse: [DebuggerMethodMapForClosureCompiledMethods]) new		forMethod: aMethod		methodNode: methodNode! !!DebuggerMethodMapForBlueBookMethods methodsFor: 'accessing' stamp: 'eem 6/3/2008 11:43'!namedTempAt: index put: aValue in: aContext	"Assign the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:"	^aContext tempAt: index put: aValue! !!CodeHolder methodsFor: 'contents' stamp: 'eem 5/7/2008 12:06'!contentsSymbol	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"	^ contentsSymbol ifNil:		[contentsSymbol := Preferences browseWithPrettyPrint								ifTrue:									[Preferences colorWhenPrettyPrinting										ifTrue:	[#colorPrint]										ifFalse:	[#prettyPrint]]								ifFalse:									[#source]]! !!DebuggerMethodMapForBlueBookMethods methodsFor: 'accessing' stamp: 'eem 6/3/2008 11:42'!tempNamesForContext: aContext	"Answer an Array of all the temp names in scope in aContext starting with	 the home's first local (the first argument or first temporary if no arguments)."	^tempNames! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'ar 7/10/2009 23:18'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	"Answer the indices in the source code for the supplied pc.	 If the context is the actve context (is at the hot end of the stack)	 then its pc is the current pc.  But if the context isn't, because it is	 suspended sending a message, then its current pc is the previous pc."	| pc i end |	pc := self method abstractPCForConcretePC: (contextIsActiveContext													ifTrue: [contextsConcretePC]													ifFalse: [(self method pcPreviousTo: contextsConcretePC)																ifNotNilDo: [:prevpc| prevpc]																ifNil: [contextsConcretePC]]).	(self abstractSourceMap includesKey: pc) ifTrue:		[^self abstractSourceMap at: pc].	sortedSourceMap ifNil:		[sortedSourceMap := self abstractSourceMap.		 sortedSourceMap := (sortedSourceMap keys collect: 								[:key| key -> (sortedSourceMap at: key)]) asSortedCollection].	(sortedSourceMap isNil or: [sortedSourceMap isEmpty]) ifTrue: [^1 to: 0].	i := sortedSourceMap indexForInserting: (pc -> nil).	i < 1 ifTrue: [^1 to: 0].	i > sortedSourceMap size ifTrue:		[end := sortedSourceMap inject: 0 into:			[:prev :this | prev max: this value last].		^end+1 to: end].	^(sortedSourceMap at: i) value	"| method source scanner map |	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.	 source := method getSourceFromFile asString.	 scanner := InstructionStream on: method.	 map := method debuggerMap.	 Array streamContents:		[:ranges|		[scanner atEnd] whileFalse:			[| range |			 range := map rangeForPC: scanner pc contextIsActiveContext: true.			 ((map abstractSourceMap includesKey: scanner abstractPC)			  and: [range first ~= 0]) ifTrue:				[ranges nextPut: (source copyFrom: range first to: range last)].			scanner interpretNextInstructionFor: InstructionClient new]]"! !!ProcessBrowser methodsFor: 'stack list' stamp: 'ar 7/10/2009 23:19'!pcRange	"Answer the indices in the source code for the method corresponding to  	the selected context's program counter value."	(selectedContext isNil or: [methodText isEmptyOrNil])		ifTrue: [^ 1 to: 0].	^selectedContext debuggerMap		rangeForPC: (selectedContext pc ifNotNilDo: [:pc| pc] ifNil: [selectedContext method endPC])		contextIsActiveContext: stackListIndex = 1! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 20:02'!privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents	| nameRefPair |	nameRefPair := (self privateTempRefsForContext: aContext						 startpcsToBlockExtents: theContextsStartpcsToBlockExtents)						at: index						ifAbsent: [aContext errorSubscriptBounds: index].	^self privateDereference: nameRefPair last in: aContext! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'private' stamp: 'eem 7/29/2008 19:26'!privateDereference: tempReference in: aContext put: aValue	"Assign the temporary with reference tempReference in aContext.	 tempReference can be		integer - direct temp reference		#( indirectionVectorIndex tempIndex ) - remote temp in indirectionVector at index		#( outer. temp reference ) - a temp reference in an outer context."	^tempReference isInteger		ifTrue: [aContext tempAt: tempReference put: aValue]		ifFalse:			[tempReference first == #outer				ifTrue: [self privateDereference: tempReference last							in: aContext outerContext							put: aValue]				ifFalse: [(aContext tempAt: tempReference first)							at: tempReference second							put: aValue]]! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'eem 6/5/2008 09:19'!forMethod: aMethod "<CompiledMethod>"	"Answer a DebuggerMethodMap suitable for debugging activations of aMethod.	 Answer an existing instance from the cache if it exists, cacheing a new one if required."	^MapCache		at: aMethod		ifAbsent: [self					cacheDebugMap:						(self							forMethod: aMethod							methodNode: aMethod methodNode)					forMethod: aMethod]! !!Debugger methodsFor: 'code pane' stamp: 'eem 6/5/2008 10:54'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	(selectingPC and: [contextStackIndex ~= 0]) ifFalse:		[^1 to: 0].	self selectedContext isDead ifTrue:		[^1 to: 0].	debuggerMap ifNil:		[debuggerMap := self selectedContext debuggerMap].	^debuggerMap		rangeForPC: self selectedContext pc		contextIsActiveContext: contextStackIndex = 1! !!ContextVariablesInspector methodsFor: 'accessing' stamp: 'eem 5/21/2008 12:31'!fieldList 	"Refer to the comment in Inspector|fieldList."	object == nil ifTrue: [^Array with: 'thisContext'].	^fieldList ifNil:[fieldList := (Array with: 'thisContext' with: 'stack top' with: 'all temp vars') , object tempNames]! !!DebuggerMethodMapForClosureCompiledMethods methodsFor: 'accessing' stamp: 'eem 7/29/2008 19:28'!namedTempAt: index in: aContext	"Answer the value of the temp at index in aContext where index is relative	 to the array of temp names answered by tempNamesForContext:"	^self		privateTempAt: index		in: aContext		startpcsToBlockExtents: aContext method startpcsToBlockExtents! !!Browser methodsFor: 'class functions' stamp: 'eem 5/7/2008 12:04'!classDefinitionText	"return the text to display for the definition of the currently selected class"	| theClass |	^(theClass := self selectedClassOrMetaClass) ifNil: [''] ifNotNil: [theClass definition]! !DebuggerMethodMap initialize!