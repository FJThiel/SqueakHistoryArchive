"Change Set:		7750Graphics-ar.75Graphics-ar.75:Remove some no longer necessary methods in TextStyle which introduced dependencies on Morphic and MVC.Graphics-jmv.74:Always do the second BitBlt pass for AA StrikeFonts if destDepth=32, as it might happen that the destination has transparent pixels that we need to make opaque.Remove the (now unused) #properAlphaForBlackText preference. Set the correct alpha value in colormaps used for AA StrikeFonts (This will only have effect when a bug in rule rgbAdd in Bitblt is fixed)"!!BitBlt class methodsFor: 'class initialization' stamp: 'jmv 9/7/2009 09:32'!initialize	self recreateColorMaps! !!BitBlt methodsFor: 'private' stamp: 'jmv 9/7/2009 09:27'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth targetColor |	sourceForm ifNotNil:[lastSourceDepth := sourceForm depth].	sourceForm := aStrikeFont glyphs.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm := nil.	sourceY := 0.	height := aStrikeFont height.	sourceForm depth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency"			colorMap := self cachedFontColormapFrom: sourceForm depth to: destForm depth.			colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).	]	ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ Preferences subPixelRenderColorFonts ]]) ifTrue: [			destForm depth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: 37.		"RGBMul"				colorMap := (destForm depth = 32 or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp we always need the second pass, as the source could have transparent pixels, and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: 25.		"Paint"				targetColor := foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap := self colorConvertingMap: targetColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]		]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destForm depth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).			colorMap := self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: false		]	].! !!Color class methodsFor: 'colormaps' stamp: 'jmv 9/7/2009 09:30'!computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.	keepSubPix		ifTrue: [ Answer colors that also include subpixelAA ]		ifFalse: [ 			Take fullpixel luminance level. Apply it to targetColor.			I.e. answer colors with NO subpixelAA ]"	| mask map c bitsPerColor r g b f v |	destDepth > 8		ifTrue: [bitsPerColor := 5]  "retain maximum color resolution"		ifFalse: [bitsPerColor := 4].	"Usually a bit less is enough, but make it configurable"	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.	mask := (1 bitShift: bitsPerColor) - 1.	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).	0 to: map size - 1 do: [:i |		r := (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.		g := (i bitShift: 0 - bitsPerColor) bitAnd: mask.		b := (i bitShift: 0) bitAnd: mask.		f := 1.0 - (r + g + b / 3.0 / mask).		c := targetColor notNil			ifTrue: [				(keepSubPix and: [destDepth > 8]) ifTrue: [						Color							r: 1.0 - (r/mask) * targetColor red							g: 1.0 - (g/mask) * targetColor green							b: 1.0 - (b/mask) * targetColor blue							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]				ifFalse: [					destDepth = 32						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]			ifFalse: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"		v := destDepth = 32			ifTrue: [ c pixelValueForDepth: destDepth]			ifFalse: [				f < 0.1					ifTrue: [ 0 ]					ifFalse: [ c pixelValueForDepth: destDepth ]].		map at: i + 1 put: v ].	^ map! !TextStyle class removeSelector: #modalMVCStyleSelectorWithTitle:!TextStyle class removeSelector: #mvcPromptForFont:andSendTo:withSelector:!TextStyle class removeSelector: #modalStyleSelectorWithTitle:!BitBlt initialize!