"Change Set:		8341Kernel-ar.321Kernel-ar.321:Faster #ensure: handling: Instead of having the default path use thisContext>>tempAt:put: (which is very slow for the JIT) use a temp assignment and let only the termination handling actually do #tempAt:put:.Part 1 introduces a version of #ensure: which is compatible with both versions of termination handling.Kernel-ar.315:Future proofing: For speed and simplicity, Cog requires LargeNegativeInteger to be compact at 4 (replacing PseudoContext). Integer>>initialize now takes care of that and documents (via LPITest and LNITest) the compact class requirements of LPI and LNI.There  is no actual impact except that LNIs will shave off a header word which in typical images makes no difference whatsover (LargeNegativeInteger instanceCount < 100 in a typical trunk image).Kernel-nice.316:Add the ANSI float characterization methods every other Smalltalk has but Squeak.Also add #predecessor and #successor.These changes are already in Pharo.Kernel-nice.317:A faster successor/predecessor implementation thanks to suggestions of Paolo Bonzini and the help of #ulp (unit of least precision - that is the least significant bit of a Float).It works well with default IEEE754 rounding mode (round to nearest even). Don't know about alternate modes, but we don't use them right now.Kernel-dtl.318:Remove Object>>couldOpenInMorphic and eliminate 'world hacking' method category.Kernel-ul.319:From: http://bugs.squeak.org/view.php?id=7166- improved preformance for Behavior >> #allSelectors- added Behavior >> #allSelectorsBelow:Kernel-ar.320:Signal OutOfMemory instead of calling signalLowSpace."!!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:43'!emin	"Answer exponent of minimal normalized representable value"		^-1022! !!BlockClosure methodsFor: 'exceptions' stamp: 'ar 12/4/2009 18:14'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| complete returnValue b |	<primitive: 198>	returnValue := self valueNoContextSwitch.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	(aBlock == nil or:[complete == true]) ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "Could be aBlock := nil, but arguments cannot be modified"		complete := true.		b value.	].	^ returnValue! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:20'!fmax	"Answer the maximum finite floating point value representable."		^MaxVal! !!Float methodsFor: 'truncation and round off' stamp: 'nice 12/2/2009 17:35'!predecessor	| ulp |	self isFinite ifFalse: [		(self isNaN or: [self negative]) ifTrue: [^self].		^Float fmax].	self = 0.0 ifTrue: [^Float fmin negated].	ulp := self ulp.	^self - (0.5 * ulp) = self		ifTrue: [self - ulp]		ifFalse: [self - (0.5 * ulp)]! !!Float methodsFor: 'truncation and round off' stamp: 'nice 12/2/2009 17:35'!successor	| ulp |	self isFinite ifFalse: [		(self isNaN or: [self positive]) ifTrue: [^self].		^Float fmax negated].	self = 0.0 ifTrue: [^Float fmin].	ulp := self ulp.	^self + (0.5 * ulp) = self		ifTrue: [self + ulp]		ifFalse: [self + (0.5 * ulp)]! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:33'!fmin	"Answer minimum positive representable value."		^self denormalized		ifTrue: [self fminDenormalized]		ifFalse: [self fminNormalized]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'dc 9/28/2008 15:54'!allSelectorsBelow: topClass 	| coll |	coll := IdentitySet new.	self withAllSuperclassesDo: 			[:aClass | 			aClass = topClass				ifTrue: [^ coll ]				ifFalse: [aClass selectorsDo: [ :sel | coll add: sel ]]].	^ coll	! !!Float class methodsFor: 'constants' stamp: 'nice 6/11/2009 12:40'!precision	"Answer the apparent precision of the floating point representation.	That is the maximum number of radix-based digits (bits if radix=2) representable in floating point without round off error.	Technically, 52 bits are stored in the representation, and normalized numbers have an implied leading 1 that does not need to be stored.	Note that denormalized floating point numbers don't have the implied leading 1, and thus gradually loose precision.	This format conforms IEEE 754 double precision standard."		^53! !!Behavior methodsFor: 'instance creation' stamp: 'ar 12/4/2009 13:46'!basicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	OutOfMemory signal.	^ self basicNew  "retry if user proceeds"! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:16'!radix	"Answer the radix used for internal floating point representation."		^2! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:22'!fminNormalized	"Answer the minimum normalized value representable."		^1.0 timesTwoPower: -1022! !!Float class methodsFor: 'constants' stamp: 'nice 6/11/2009 12:30'!epsilon	"Answer difference between 1.0 and previous representable value"		^1.0 timesTwoPower: 1 - self precision! !!Integer class methodsFor: 'class initialization' stamp: 'ar 11/30/2009 22:01'!initialize	"Integer initialize"	"Ensure we have the right compact class index"	"LPI has been a compact class forever - just ensure basic correctness"	(LargePositiveInteger indexIfCompact = 5) ifFalse:[		(Smalltalk compactClassesArray at: 5)			ifNil:[LargePositiveInteger becomeCompactSimplyAt: 5]			ifNotNil:[self error: 'Unexpected compact class setup']].	"Cog requires LNI to be compact at 4 (replacing PseudoContext)"	(LargeNegativeInteger indexIfCompact = 4) ifFalse:[		"PseudoContext will likely get removed at some point so write this test		without introducing a hard dependency"		(Smalltalk compactClassesArray at: 4) name == #PseudoContext			ifTrue:[Smalltalk compactClassesArray at: 4 put: nil].		(Smalltalk compactClassesArray at: 4)			ifNil:[LargeNegativeInteger becomeCompactSimplyAt: 4]			ifNotNil:[self error: 'Unexpected compact class setup']].! !!Float methodsFor: 'truncation and round off' stamp: 'nice 12/1/2009 12:30'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	self isFinite ifFalse: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				| di df q r |				di := 1 + (SmallInteger maxVal bitShift: -1).				df := di asFloat.				q := self quo: df.				r := self - (q asFloat * df).				^q * di + r truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]				! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 12/4/2009 18:15'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| complete returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	(aBlock == nil or:[complete == true]) ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "aBlock := nil"		complete := true.		b value.	].	^ returnValue! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'ar 12/4/2009 13:46'!newMethod: numberOfBytes header: headerWord 	"Primitive. Answer an instance of me. The number of literals (and other 	information) is specified the headerWord. The first argument specifies 	the number of fields for bytecodes in the method. Fail if either 	argument is not a SmallInteger, or if numberOfBytes is negative. Once 	the header of a method is set by this primitive, it cannot be changed in 	any way. Essential. See Object documentation whatIsAPrimitive."	<primitive: 79>	(numberOfBytes isInteger and:	 [headerWord isInteger and:	 [numberOfBytes >= 0]]) ifTrue: [		"args okay; space must be low"		OutOfMemory signal.		"retry if user proceeds"		^ self newMethod: numberOfBytes header: headerWord	].	^self primitiveFailed! !!Float methodsFor: 'truncation and round off' stamp: 'nice 12/1/2009 12:07'!ulp	"Answer the unit of least precision of self (the power of two corresponding to last bit of mantissa)"		| exponent |	self isFinite ifFalse: [		self isNaN ifTrue: [^self].		^Float infinity].	self = 0.0 ifTrue: [^Float fmin].	exponent := self exponent.	^exponent < self class emin		ifTrue: [Float fminDenormalized] 		ifFalse: [Float epsilon timesTwoPower: exponent]! !!Float class methodsFor: 'constants' stamp: 'nice 6/11/2009 12:29'!denormalized	"Answer whether implementation supports denormalized numbers (also known as gradual underflow)."		^true! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 12/3/2009 04:47'!allSelectors    "Answer all selectors understood by instances of the receiver"    ^(Array streamContents: [ :stream |        self withAllSuperclassesDo: [ :aClass |            aClass selectorsDo: [ :each |                 stream nextPut: each ] ] ]) asIdentitySet! !!Behavior methodsFor: 'instance creation' stamp: 'ar 12/4/2009 13:46'!basicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		OutOfMemory signal.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:42'!emax	"Answer exponent of maximal representable value"		^1023! !!Float class methodsFor: 'constants' stamp: 'nice 6/8/2009 15:22'!fminDenormalized	"Answer the minimum denormalized value representable."		^1.0 timesTwoPower: MinValLogBase2! !Object removeSelector: #couldOpenInMorphic!Integer initialize!