"Change Set:		8071Compiler-nice.96Compiler-nice.96:Test and minimal change to isLiteralSymbol: to make the test pass.This is related to http://bugs.squeak.org/view.php?id=7211I did not apply change proposed above, though it might be a good idea to restrict unquoted notation to explicitely documented valid Smalltalk literals.There are pending decisions about wide characters and binary selectors to be resolved first.Compiler-nice.94:Ensure usage of #typeTableAt:  rather than typeTable ivar to handle Wide charactersCompiler-nice.95:Be verbose in case of illegal characterThis might be usefull if the character is not not visible, or not displayable by current font."!TestCase subclass: #ScannerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!!ScannerTest methodsFor: 'testing' stamp: 'nice 10/10/2008 20:42'!testLiteralSymbols	self assert: ('*+-/\~=<>&@%,|' allSatisfy: [:char | Scanner isLiteralSymbol: (Symbol with: char)])		description: 'single letter binary symbols can be printed without string quotes'.			self assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | Scanner isLiteralSymbol: str asSymbol])		description: 'valid ascii selector symbols can be printed without string quotes'.			((32 to: 126) collect: [:ascii | Character value: ascii]) ,	#(':x:yourself' '::' 'x:yourself' '123' 'x0:1:2:' 'x.y.z' '1abc' 'a1b0c2' ' x' 'x ' '+x-y' '||' '--' '++' '+-' '+/-' '-/+' '<|>' '#x' '()' '[]' '{}' '')		do: [:str |			self assert: (Compiler evaluate: str asSymbol printString) = str asSymbol				description: 'in all case, a Symbol must be printed in an interpretable fashion']! !!Scanner class methodsFor: 'testing' stamp: 'nice 10/27/2009 15:08'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type next |	i := aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [^('$''"()#0123456789_' includes: (aSymbol at: 1)) not		and: ["should be (TypeTable at: (aSymbol at: 1) charCode ifAbsent: [#xLetter]) ~~ #xDelimiter"			(aSymbol at: 1) isSeparator not]].	ascii := (aSymbol at: 1) charCode.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type := TypeTable at: ascii ifAbsent: [#xLetter].	(type == #xColon or: [type == #verticalBar or: [type == #xBinary]]) ifTrue:		[^i = 1].	type == #xLetter ifTrue:		[next := nil.		[i > 1] whileTrue:			[ascii := (aSymbol at: i) charCode.			ascii = 0 ifTrue: [^false].			type := TypeTable at: ascii ifAbsent: [#xLetter].			(type == #xLetter or: [type == #xDigit or: [type == #xColon]]) ifFalse:				[^false].			(next == #xDigit and: [type == #xColon]) ifTrue: [^false].			next := type.			i := i - 1].		^true].	^false! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 10/27/2009 12:35'!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character (char code ' , hereChar charCode , ' 16r' , hereChar charCode hex , ')' at: mark! !!Scanner methodsFor: 'expression types' stamp: 'nice 10/27/2009 10:46'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two chaacters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !