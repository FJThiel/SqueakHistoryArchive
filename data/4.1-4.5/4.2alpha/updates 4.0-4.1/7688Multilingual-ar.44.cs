"Change Set:		7688Multilingual-ar.44Multilingual-ar.44:FreeTypePlus integration: Deal with the extensions and overrides in the m17n scanner classes and TTCFont.Multilingual-ar.41:Simplified handling for decomposed Unicode input. UnicodeInputInterpreter deals with the composition based on the composition operations provided by Unicode:- Unicode>>isComposed: aCharacter- Unicode>>isComposable: aCharacter- Unicode>>compose: baseChar with: compositionChar- Unicode>>decompose: composedCharSee the method comments for more information.Multilingual-ar.42:Compute TTCFont spacing based on the 'true typographic metrics' stored in the OS/2 table of the ttf description. After loading, execute the following to flush out any pending cached values:	TTCFont allInstancesDo:[:font| font flushCachedValues]Multilingual-ar.43:Fix one of the font tests."!KeyboardInputInterpreter subclass: #UnicodeInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!Object subclass: #MultiCharacterScanner	instanceVariableNames: 'destX lastIndex xTable destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks presentation presentationLine numOfComposition baselineY firstDestX pendingKernX'	classVariableNames: 'DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition'	poolDictionaries: 'TextConstants'	category: 'Multilingual-Scanning'!EncodedCharSet subclass: #Unicode	instanceVariableNames: ''	classVariableNames: 'Cc Cf Cn Co Compositions Cs DecimalProperty Decompositions GeneralCategory Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs'	poolDictionaries: ''	category: 'Multilingual-Encodings'!!TTCFont methodsFor: 'private' stamp: 'ar 8/29/2009 19:16'!computeForm: char	"Compute the glyph form for the given character"	^ttcDescription renderGlyph: char height: self height fgColor: foregroundColor bgColor: Color transparent depth: self depth! !!Unicode class methodsFor: 'composing' stamp: 'ar 8/17/2009 21:58'!parseCompositionMappingFrom: stream	"Parse the Unicode composition mappings from the given stream"	"		Unicode initializeCompositionMappings.	"	| toNumber fields codePoint decomposed baseChar compChar line |	toNumber := [:quad | quad inject: 0 into:[:sum :ch| sum * 16 + ch digitValue]].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	[stream atEnd] whileFalse:[		line := ((stream upToAnyOf: String crlf) copyUpTo: $#) withBlanksTrimmed readStream.		fields := Array streamContents:[:s|[line atEnd] whileFalse:[s nextPut: (line upTo: $;)]].		fields size > 6 ifTrue:[			codePoint := toNumber value: (fields at: 1).			decomposed := (fields at: 6) findTokens: ' '.			(decomposed size = 2 and:[decomposed first first ~= $<]) ifTrue:[				decomposed := decomposed collect: toNumber.				baseChar := decomposed first.		"base character"				compChar := decomposed second.	"composition character"				Decompositions at: codePoint put: (Array with: baseChar with: compChar).				(Compositions at: baseChar ifAbsentPut:[IdentityDictionary new])					at: compChar put: codePoint.			].		].	].! !!Unicode class methodsFor: 'composing' stamp: 'ar 8/17/2009 21:38'!compose: baseChar with: compositionChar	"Answers the composition of baseChar and compositionChar if such a combination exists.	Answers nil if the combination does not exist."	^Character value: 		((Compositions at: baseChar asInteger ifAbsent:[^nil])			at: compositionChar asInteger ifAbsent:[^nil])! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 10:43'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	pendingKernX := 0.	^false! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'tween 4/2/2007 23:59'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue floatDestX widthAndKernedWidth nextChar |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stopConditions at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextChar := (lastIndex + 1 <= stopIndex) 			ifTrue:[sourceString at: lastIndex + 1]			ifFalse:[nil].		font 			widthAndKernedWidthOfLeft: ((char isMemberOf: CombinedChar) ifTrue:[char base] ifFalse:[char]) 			right: nextChar			into: widthAndKernedWidth.		nextDestX := floatDestX + (widthAndKernedWidth at: 1).			nextDestX > rightX ifTrue: [^ stops at: CrossedX].		floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).		destX := floatDestX.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!TTCFont methodsFor: 'initialize' stamp: 'tween 4/23/2006 22:52'!derivativeFont: aNewlyCreatedDerivativeFont mainFont: aMainFont	self derivativeFont: aNewlyCreatedDerivativeFont at: aMainFont emphasis.	aNewlyCreatedDerivativeFont emphasis: aMainFont emphasis.	aNewlyCreatedDerivativeFont lineGlyph: (aMainFont ttcDescription at: $_).! !!Unicode class methodsFor: 'class initialization' stamp: 'ar 8/17/2009 21:57'!initialize	" Unicode initialize "	self initializeTagConstants.	Compositions isEmptyOrNil ifTrue:[self initializeCompositionMappings].! !!Unicode class methodsFor: 'class initialization' stamp: 'ar 8/17/2009 20:48'!initializeTagConstants	"Initialize the Unicode tag constants"	Cn := 0. 	Cc := 1. 	Cf := 2. 	Co := 3. 	Cs := 4. 	Ll := 5. 	Lm := 6. 	Lo := 7. 	Lt := 8. 	Lu := 9. 	Mc := 10. 	Me := 11. 	Mn := 12. 	Nd := 13. 	Nl := 14. 	No := 15. 	Pc := 16. 	Pd := 17. 	Pe := 18. 	Pf := 19. 	Pi := 20. 	Po := 21. 	Ps := 22. 	Sc := 23. 	Sk := 24. 	Sm := 25. 	So := 26. 	Zl := 27. 	Zp := 28. 	Zs := 29.! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:18'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	pendingKernX := 0.	lastIndex:= lastIndex + 1.	^false! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:21'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	pendingKernX := 0.	(breakAtSpace) ifTrue: [		spaceCount >= 1 ifTrue:			["The common case. First back off to the space at which we wrap."			line stop: breakableIndex.			presentationLine stop: breakableIndex - numOfComposition.			lineHeight := lineHeightAtBreak.			baseline := baselineAtBreak.			spaceCount := spaceCount - 1.			breakableIndex := breakableIndex - 1.			"Check to see if any spaces preceding the one at which we wrap.				Double space after punctuation, most likely."			[(spaceCount > 1 and: [(text at: breakableIndex) = Space])]				whileTrue:					[spaceCount := spaceCount - 1.					"Account for backing over a run which might						change width of space."					font := text fontAt: breakableIndex withStyle: textStyle.					breakableIndex := breakableIndex - 1.					spaceX := spaceX - (font widthOf: Space)].			line paddingWidth: rightMargin - spaceX.			presentationLine paddingWidth: rightMargin - spaceX.			presentationLine internalSpaces: spaceCount.			line internalSpaces: spaceCount]		ifFalse:			["Neither internal nor trailing spaces -- almost never happens."			lastIndex := lastIndex - 1.			[destX <= rightMargin]				whileFalse:					[destX := destX - (font widthOf: (text at: lastIndex)).					lastIndex := lastIndex - 1].			spaceX := destX.			line paddingWidth: rightMargin - destX.			presentationLine paddingWidth: rightMargin - destX.			presentationLine stop: (lastIndex max: line first).			line stop: (lastIndex max: line first)].		^true	].	(breakableIndex isNil or: [breakableIndex < line first]) ifTrue: [		"Any breakable point in this line.  Just wrap last character."		breakableIndex := lastIndex - 1.		lineHeightAtBreak := lineHeight.		baselineAtBreak := baseline.	].	"It wasn't a space, but anyway this is where we break the line."	line stop: breakableIndex.	presentationLine stop: breakableIndex.	lineHeight := lineHeightAtBreak.	baseline := baselineAtBreak.	^ true.! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:52'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad := 0.	spaceCount := spaceCount + 1.	pad := line justifiedPadFor: spaceCount font: font.	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^ false! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 10:56'!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	pendingKernX := 0.! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 11:17'!columnBreak	pendingKernX := 0.	^true! !!Unicode class methodsFor: 'composing' stamp: 'ar 8/17/2009 21:56'!initializeCompositionMappings	"Unicode initializeCompositionMappings"	| stream |	Compositions := IdentityDictionary new.	Decompositions := IdentityDictionary new.	UIManager default informUserDuring:[:bar|		bar value: 'Downloading Unicode data'.		stream := HTTPClient httpGet: 'http://unicode.org/Public/UNIDATA/UnicodeData.txt'.		(stream isKindOf: RWBinaryOrTextStream) ifFalse:[^self error: 'Download failed'].		stream reset.		bar value: 'Updating Composition Mappings'.		self parseCompositionMappingFrom: stream.	].! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:52'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1) font: font)).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab := true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab := false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 10:14'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding floatDestX widthAndKernedWidth nextChar atEndOfRun |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	atEndOfRun := false.	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [ascii < stopConditions size and: [(stopConditions at: ascii + 1) ~~ nil]]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextChar := (lastIndex + 1 <= stopIndex) 			ifTrue:[sourceString at: lastIndex + 1]			ifFalse:[				atEndOfRun := true.				"if there is a next char in sourceString, then get the kern 				and store it in pendingKernX"				lastIndex + 1 <= sourceString size					ifTrue:[sourceString at: lastIndex + 1]					ifFalse:[	nil]].		font 			widthAndKernedWidthOfLeft: (sourceString at: lastIndex) 			right: nextChar			into: widthAndKernedWidth.		nextDestX := floatDestX + (widthAndKernedWidth at: 1).		nextDestX > rightX ifTrue: [destX ~= firstDestX ifTrue: [^stops at: CrossedX]].		floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).		atEndOfRun 			ifTrue:[				pendingKernX := (widthAndKernedWidth at: 2) - (widthAndKernedWidth at: 1).				floatDestX := floatDestX - pendingKernX].		destX := floatDestX .		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!UnicodeInputInterpreter methodsFor: 'converting' stamp: 'ar 8/27/2009 19:57'!nextCharFrom: sensor firstEvt: evtBuf	"Compose Unicode character sequences"	| peekEvent keyValue composed |	"Only try this if the first event is composable and is a character event"	((Unicode isComposable: (keyValue := evtBuf sixth)) 		and:[evtBuf fourth = EventKeyChar]) ifTrue:[			"If we have a pending keyDown in the queue, skip that to get to the keystroke"			peekEvent := sensor peekEvent.			(peekEvent notNil and: [peekEvent fourth = EventKeyDown]) ifTrue: [				"skipEvent := "sensor nextEvent.				peekEvent := sensor peekEvent].			"If we have another character event in the queue, compose it"			(peekEvent notNil 				and: [peekEvent first = EventTypeKeyboard 				and:[peekEvent fourth = EventKeyChar]]) ifTrue:[					composed := Unicode compose: keyValue with: peekEvent sixth.					composed ifNotNil:[						sensor nextEvent.						^composed]]].	"XXXX: Fixme. We should put the skipped event back if we haven't consumed it."	^keyValue asCharacter! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'tween 8/1/2006 20:22'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos underline strikeout |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			underline := (emphasisCode bitAnd: 4) > 0.			strikeout := (emphasisCode bitAnd: 16) > 0.			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY.			underline 				ifTrue:[font displayUnderlineOn: bitBlt from: lastPos x@baselineY to: destX@baselineY].			strikeout 				ifTrue:[font displayStrikeoutOn: bitBlt from: lastPos x@baselineY to: destX@baselineY ] ].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done := true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:12'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	pendingKernX := 0.	destX := textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex := lastIndex + 1.	^false! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 18:17'!height	"Answer my height in pixels. This will answer a Float."	^height ifNil:[height := self pixelSize + self lineGap]! !!MultiCharacterScanner methodsFor: 'private' stamp: 'tween 4/6/2007 10:16'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont := font.	text == nil ifFalse:[		emphasisCode := 0.		kern := 0.		indentationLevel := 0.		alignment := textStyle alignment.		font := nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font := font emphasized: emphasisCode.	priorFont 		ifNotNil: [			font = priorFont 				ifTrue:[					"font is the same, perhaps the color has changed?					We still want kerning between chars of the same					font, but of different color. So add any pending kern to destX"					destX := destX + (pendingKernX ifNil:[0])].			destX := destX + priorFont descentKern].	pendingKernX := 0. "clear any pending kern so there is no danger of it being added twice"	destX := destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX := destX max: leftMargin].	kern := kern - font baseKern.	"Install various parameters from the font."	spaceWidth := font widthOf: Space.	xTable := font xTable."	map := font characterToGlyphMap."	stopConditions := DefaultStopConditions.! !!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:52'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount  font: font).	lastIndex := lastIndex + 1.	pendingKernX := 0.	^ false! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 19:12'!lineGap	"Answer the line gap from the ttf description"	^self pixelSize * ttcDescription typographicLineGap // 			(ttcDescription typographicAscender - ttcDescription typographicDescender)! !!TTCFont methodsFor: 'initialize' stamp: 'tween 4/23/2006 22:54'!lineGlyph: ignore	^self! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 19:03'!lineGrid	"Answer the relative space between lines"	^ self ascent + self descent! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:51'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	pendingKernX := 0.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount  font: font).	lastIndex := lastIndex + 1.	^ false! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 18:26'!pixelSize	"Make sure that we don't return a Fraction"	^(TextStyle pointsToPixels: pointSize) truncated! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 19:25'!ascent	^ascent ifNil:[ascent := (ttcDescription typographicAscender * self pixelScale) truncated].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 18:26'!descent	"One is added to make sure the gap between lines is filled.  If we don't add, multi line selection in a text pane look ugly."	^descent ifNil:[descent := self height - self ascent].! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 10:11'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char floatDestX widthAndKernedWidth nextChar atEndOfRun |	<primitive: 103>	lastIndex := startIndex.	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	atEndOfRun := false.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextChar := (lastIndex + 1 <= stopIndex) 				ifTrue:[sourceString at: lastIndex + 1]				ifFalse:[					atEndOfRun := true.					"if there is a next char in sourceString, then get the kern 					and store it in pendingKernX"					lastIndex + 1 <= sourceString size						ifTrue:[sourceString at: lastIndex + 1]						ifFalse:[	nil]].			font 				widthAndKernedWidthOfLeft: char 				right: nextChar				into: widthAndKernedWidth.			nextDestX := floatDestX + (widthAndKernedWidth at: 1).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).			atEndOfRun 				ifTrue:[					pendingKernX := (widthAndKernedWidth at: 2) - (widthAndKernedWidth at: 1).					floatDestX := floatDestX - pendingKernX].			destX := floatDestX.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops at: EndOfRun! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/29/2009 19:15'!pixelScale	"Answer the scale factor to convert from the truetype's units into the receiver's pixel size. The scale for a font is computed by *excluding* the linegap (leading) in the font. Consequently, the height of the font (including linegap/leading) will be larger than the pixel size."	^self pixelSize asFloat / 		(ttcDescription typographicAscender - 			ttcDescription typographicLineGap - 			ttcDescription typographicDescender)! !!Unicode class methodsFor: 'character classification' stamp: 'ar 8/17/2009 21:37'!isComposable: aCharacter	"Answers true if the given character has any composition sequences"	^Compositions includesKey: aCharacter asInteger! !!TTCFont methodsFor: 'initialize' stamp: 'tween 4/23/2006 21:45'!initialize: aFont	self initialize.	self ttcDescription: aFont ttcDescription.! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:11'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!TTCFont methodsFor: 'private' stamp: 'ar 8/29/2009 19:04'!flushCachedValues	"Flush all values computed from ttcDescription and cached for speed"	"TTCFont allInstancesDo:[:font| font flushCachedValues]"	height := ascent := descent := nil.! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:19'!tab	pendingKernX := 0.	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex := lastIndex + 1.	^ false! !!Unicode class methodsFor: 'character classification' stamp: 'ar 8/17/2009 21:37'!isComposed: aCharacter	"Answers true if the given character can be decomposed into a Unicode sequence."	^Decompositions includesKey: aCharacter asInteger! !!Unicode class methodsFor: 'composing' stamp: 'ar 8/17/2009 21:38'!decompose: aCharacter	"Answers the decomposed sequence for the given character if such a sequence	exists. If there is no decomposition for the character, answer nil."	^String withAll: ((Decompositions at: aCharacter asInteger ifAbsent:[^nil]) 		collect:[:v| Character value: v]).! !!FontTest methodsFor: 'testing' stamp: 'ar 8/29/2009 23:10'!testResetAfterEmphasized	"self debug: #testResetAfterEmphasized"	| normal derivative |	normal := TextStyle defaultFont.	derivative := normal emphasized: 3.	self assert: (normal derivativeFonts at: 3) == derivative.	normal reset.	self assert: (normal derivativeFonts select:[:any| any isSynthetic]) isEmpty! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:11'!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !TTCFont class removeSelector: #scale:!TTCFont class removeSelector: #repairBadSizes!Unicode initialize!