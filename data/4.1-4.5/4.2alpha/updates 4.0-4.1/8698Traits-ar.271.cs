"Change Set:		8698Traits-ar.271Traits-ar.271:Fix a few issues where we should operate on the elements of the trait transform instead of the transform itself.Traits-ar.270:Final cleanup touches: Remove some unused or duplicate left-overs."!!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/31/2009 15:29'!includesTrait: aTrait	^self traitComposition anySatisfy:[:each| each includesTrait: aTrait]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/31/2009 15:38'!installTraitsFrom: aTraitComposition	"Install the traits from the given composition. This method implements	the core composition method - all others are just optimizations for	particular cases. Consequently, the optimized versions can always fall	back to this method when things get too hairy."	| allTraits methods oldMethod removals oldCategories |	(self traitComposition isEmpty and: [aTraitComposition isEmpty]) ifTrue: [^self].	"Check for cycles"	allTraits := aTraitComposition gather: [:t | t allTraits copyWith: t].	(allTraits includes: self) ifTrue:[^self error: 'Cyclic trait definition detected'].	"XXXX: addUser/removeUser should be part of setter, but subclass 	override prevents it until we've got rid of Traits mess."	self traitComposition do:[:tc|  tc removeTraitUser: self].	self traitComposition: aTraitComposition.	aTraitComposition do:[:tc| tc addTraitUser: self].	"Assemble the methods in a new dictionary first.	Uses a Dictionary instead of a MethodDictionary for speed (MDs grow by #become:)"	methods := Dictionary new.	"Stick in the local methods first, since this avoids generating conflict methods unnecessarily"	self selectorsAndMethodsDo:[:sel :newMethod|		(self isLocalMethod: newMethod)			ifTrue:[methods at: sel put:newMethod]].	"Now assemble the traits methods"	aTraitComposition do:[:trait|		trait selectorsAndMethodsDo:[:sel :newMethod|			oldMethod := methods at: sel ifAbsentPut:[newMethod].			newMethod == oldMethod ifFalse:["a conflict"				(self isLocalMethod: oldMethod) ifFalse:[					methods at: sel put: (self resolveTraitsConflict: sel from: oldMethod to: newMethod).				].			].		].	].	"Apply the changes. We first add the new or changed methods."	oldCategories := Set new.	methods keysAndValuesDo:[:sel :newMethod|		oldMethod := self compiledMethodAt: sel ifAbsent:[nil].		oldMethod == newMethod ifFalse:[			self traitAddSelector: sel withMethod: newMethod.			(self organization categoryOfElement: sel) ifNotNil:[:cat| oldCategories add: cat].			self organization classify: sel under: 				(newMethod methodHome organization categoryOfElement: newMethod selector).		]].	"Now remove the old or obsoleted ones"	removals := OrderedCollection new.	self selectorsDo:[:sel| (methods includesKey: sel) ifFalse:[removals add: sel]].	removals do:[:sel| self traitRemoveSelector: sel].	"Clean out empty categories"	oldCategories do:[:cat|		(self organization isEmptyCategoryNamed: cat)			ifTrue:[self organization removeCategory: cat]].	self isMeta ifFalse:[self classSide updateTraitsFrom: aTraitComposition].! !TraitComposition removeSelector: #removeTraitUser:!Trait class removeSelector: #initialize!TraitComposition removeSelector: #removeUser:!TraitComposition removeSelector: #addTraitUser:!TraitDescription removeSelector: #removeUser:!TraitComposition removeSelector: #addUser:!TraitComposition removeSelector: #includesTrait:!Array removeSelector: #asTraitComposition!TraitDescription removeSelector: #addUser:!Trait initialize!