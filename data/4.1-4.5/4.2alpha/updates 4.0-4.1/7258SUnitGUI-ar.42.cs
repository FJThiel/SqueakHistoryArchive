"Change Set:		7258SUnitGUI-ar.42SUnitGUI-ar.42:Merge SUnitGUI from Pharo to support package based test coverage.SUnitGUI-marcus.denker.8:- add #numberOfMethods	- fix Behavior>>linesOfCode to be traits-aware	- create all morphic events with basicNew to save the send of #initialize	- optimized path for Morph>>#fillStyle for emoty morph-extension. (Called a lot)	- optimized path for Morph>>#shadowOffset for empy morphExtension (called a lot)	- remove call to 'self flag #arNote' in Morph>>#transformedFrom: (called on mouse-move)	- remove MorphEvent>>#convertFromObsolete	- remove turtle trails check from Morph>>#drawOn:	- remove more calls to #flag:	- some simple code simplification (e.g. call #methods, not #methodDict values, more isEmpty)	- remove AbstractEvent>>#saveChangeNotificationAsSARFileWithNumber:SUnitGUI-AlexandreBergel.9:Adding an history for SUnit. Pair programming with GwenaelSUnitGUI-GwenaelCasaccio.10:Added a show progress in the TestRunnerSUnitGUI-AlexandreBergel.11:Bug fixed when updating the button 'show progress'SUnitGUI-AlexandreBergel.12:Use a workspace to display the progressSUnitGUI-AlexandreBergel.13:Use a workspace to display the progressSUnitGUI-stephane.ducasse.14:fixing PopUpMenu plague!!!!!Please use UIManager default instead.SUnitGUI-lr.15:- move history/diff/store actions to context menu on resultsSUnitGUI-stephane_ducasse.16:Various etoy cleaningSUnitGUI-marcus_denker.17:- ifNotNilDo: calls renamed- Issue 232:	Recreate Special Objects Array should preserve external semaphores + FixSUnitGUI-simon_denier.18:Test history recoverySUnitGUI-simon_denier.19:update TestRunner to use TestResult/TestCase history protocolSUnitGUI-simon_denier.20:rename testClasses in classesTested to avoid confusion with a test methodSUnitGUI-sd.21:Morph D->I cleaning	defaultVariableName	doMenuItem:	noteNegotiatedName: uniqueName for: requestedName     variableDocks- SUnit extension (icon)SUnitGUI-marcus_denker.22:overridesSUnitGUI-stephane_ducasse.23:-378 : testRunner dependencies on RBEnvironment-423: SmallLand update Mechanism-More Collection TestsSUnitGUI-lr.24:- added a menu item to browse classes from the test runnerSUnitGUI-stephane_ducasse.25:- Damien Cassou more tests- Lukas Renggli Browse class in Sunit BrowserSUnitGUI-adrian_lienhard.26:Issue 628: Shortcut for 'Debug it' (thanks cdrick65)Issue 633: Bring back keyboard shortcut for 'case insensitive search for method strings containing it'Issue 625: 'recent submissions' missingIssue 626: TestRunner showing wrong status colour when expected failures are present (thanks Julien)SUnitGUI-lr.27:- simple coverage display when running testsSUnitGUI-lr.28:- display percentage of not covered methods- further reduced the code that is run while wrappers are installedSUnitGUI-lr.29:- play better with systems that do reflection (pragmas)SUnitGUI-stephane_ducasse.30: Issue 648: Opening protocol browser results in a MessageNotUnderstood: CompiledMethod>>category		CompiledMethod>>category by eric Issue 684: Recent Morphic ChangesetsRemoved BorderedMorph>>areasRemainingToFill:Issue 691: integrate Setting System-SettingIssue 696: SuniGUi showing coverage SUnit coverage enhancementIssue 697: New Socket IPv6 new socket primitive and IPv6 changesSUnitGUI-stephane_ducasse.34:Issue 710:	Merge Tool diff fix	Fixes for edge cases when handling conflicts.	Fixes for original MC merge browser.SUnitGUI Improvement	- do not offer to test coverage of kernel/collection/exception/sunit packages, that will only crash the system	- do not consider methods with <ignoreForCoverage> annotation	- improving the error messages	- don t try show a list if all methods are covered	- really save the history	- do not wrap abstract methods, they won t be called anyway	- update the history even after coverage is run	Settings Integration enh	- Code cleaning (less classes, more comments)SUnitGUI-stephane_ducasse.37:- Issue 730 SUnitGui	- do not consider package declarations from superclasses	- filter the package declaration from the coverage set	- added the method TestCase>>#packageNamesUnderTest that can be overridden in TestCase sub-classes to let the test runner automatically know what code to instrument- Issue 519:	Cannot pass a script to the VM- Issue 731 Scriptloader add FFI loading as convenience method for easy loading- Issue 622:	there is a deprecated method call when using the method finder- Issue 732 numberOfDigits- Issue 728:	isLiteralSymbol broken by closure mergeSUnitGUI-onierstrasz.38:Added possibility to declare classNamesNotUnderTest on the class side.Refcatored runCoverage into several helper methods.SUnitGUI-stephane_ducasse.39:- 819 argumentCount- stef fixing his methods (tests)- Issue 820:	Re-implement Boolean>>#==> that was removed because it was not license clean-  Issue 821:	Preference to settings refactoring: #confirmFirstUseOfStyle case- Issue 657:	About dialog is too big	http://code.google.com/p/pharo/issues/detail?id=657- Issue 832:	morphs do not respect the damagerect	http://code.google.com/p/pharo/issues/detail?id=832	- Issue 36: 7085 WriteStreamTestAndFiz- categorize methods in ClassCommentReader- Issue 801:	Copy protection missing in CharacterSet complement (part of mantis 6367)	http://code.google.com/p/pharo/issues/detail?id=801- Issue 834: Boolean Setting 	http://code.google.com/p/pharo/issues/detail?id=834- Issue 835:	TestRunner enh	http://code.google.com/p/pharo/issues/detail?id=835SUnitGUI-lr.40:- fixed test runner class selection bug- move polymorph overrides to SUnitGUI packageSUnitGUI-stephane_ducasse.41:Issue 927:	SLICE-FixClassSelectionInTestRunner	- fixed test runner class selection bug	- move polymorph overrides to SUnitGUI package"!Object subclass: #TestRunner	instanceVariableNames: 'categories categoriesSelected classes classIndex classesSelected failedList failedSelected errorList errorSelected lastUpdate result previousRun'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnitGUI'!ProtoObject subclass: #TestCoverage	instanceVariableNames: 'hasRun reference method'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnitGUI'!!TestRunner methodsFor: 'utilities' stamp: 'ar 7/9/2009 14:40'!findCategories	| visible |	visible := Set new.	self baseClass withAllSubclassesDo: [ :each |		each category ifNotNilDo: [ :category |			visible add: category ] ].	^ Array streamContents: [ :stream |		Smalltalk organization categories do: [ :each |			(visible includes: each)				ifTrue: [ stream nextPut: each ] ] ].! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectInverseClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := classes asSet 		removeAll: classesSelected;		yourself.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 19:41'!hasHistory	self flag: #Useless. "No Senders?"	^ true! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:21'!mark	hasRun := true! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/1/2008 12:00'!historyMenuList	^ {'** save current result **'}, (self previousRun collect: [:ts | ts printString])! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 19:36'!saveResultInHistory	result dispatchResultsIntoHistory! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 17:02'!showProgress	| testCaseClasses d t string |	testCaseClasses := (self suiteAll tests collect: [:testCase | testCase class]) asSet.		"At the end of the algorithm, d will contains all the diff between what was saved and the current result"	d := Dictionary new.	d at: #passed put: OrderedCollection new.	d at: #failures put: OrderedCollection new.	d at: #errors put: OrderedCollection new.	testCaseClasses do: [ :cls |		(cls class methodDict includesKey: #lastStoredRun)			ifTrue: [t := cls lastStoredRun.					(t at: #passed) do: [:s | 												(result isErrorFor: cls selector: s)												ifTrue: [(d at: #errors) add: {cls . s}].											(result isFailureFor: cls selector: s)												ifTrue: [(d at: #failures) add: {cls . s}]  ].																(t at: #failures) do: [:s | (result isPassedFor: cls selector: s)												ifTrue: [(d at: #passed) add: {cls . s}].											(result isErrorFor: cls selector: s)												ifTrue: [(d at: #errors) add: {cls . s}]].																(t at: #errors) do: [:s | 	(result isPassedFor: cls selector: s)												ifTrue: [(d at: #passed) add: {cls . s}].											(result isFailureFor: cls selector: s)												ifTrue: [(d at: #failures) add: {cls . s}]]]].						string := String streamContents: [:str|		str nextPutAll: '----------------'; cr.		str nextPutAll: 'Diff between current result and saved result'; cr.		str nextPutAll: 'New passed: '.		(d at: #passed) do: [:s| str nextPutAll: s printString, ' '].		str cr.		str nextPutAll: 'New failures: '.		(d at: #failures) do: [:s| str nextPutAll: s printString, ' '].		str cr.				str nextPutAll: 'New errors: '.		(d at: #errors) do: [:s| str nextPutAll: s printString, ' '].		str cr].		Workspace new contents: string; openLabel: 'SUnit Progress' string.	! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:45'!classMenu: aMenu	^ aMenu		title: 'Classes';		add: 'Browse' action: #browseClass;		addLine;		add: 'Select all' action: #selectAllClasses;		add: 'Select subclasses' action: #selectSubclasses;		add: 'Select inversion' action: #selectInverseClasses;		add: 'Select none' action: #selectNoClasses;		addLine;		add: 'Filter...' action: #filterClasses;		addLine;		add: 'Refresh' action: #updateClasses;		yourself.! !!TestRunner methodsFor: 'actions' stamp: 'simon.denier 11/13/2008 19:34'!runAll	self reset; runSuite: self suiteAll.	self saveResultInHistory! !!TestCase class methodsFor: '*sunitgui' stamp: 'lr 4/12/2009 00:27'!packageNamesUnderTest	"Answer a collection of package names under test. This is used by the test runner to automatically instrument the code in these packages when checking for test coverage."		^ #()! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectAllCategories	categoriesSelected := categories asSet.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectAllClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := classes asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:31'!uninstall	reference actualClass methodDictionary		at: reference methodSymbol		put: method! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:49'!browseClass	(classes at: classIndex ifAbsent: [ ^ self ]) browse! !!TestRunner methodsFor: 'history saving' stamp: 'GwenaelCasaccio 10/1/2008 22:00'!hasResults	^ result notNil! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectInverseCategories	categoriesSelected := categories asSet 		removeAll: categoriesSelected;		yourself.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 20:26'!doesNotUnderstand: aMessage	^ method perform: aMessage selector withArguments: aMessage arguments! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/12/2008 11:55'!showDiffWith: aTestResult	| string diff |	diff := result diff: aTestResult.	string := String streamContents: [:str|		str nextPutAll: '----------------'; cr.		str nextPutAll: 'Diff between current result with: ', aTestResult asString; cr.		str nextPutAll: 'New passed: '.		diff first do: [:s| str nextPutAll: s printString, ' '].		str cr.		str nextPutAll: 'New failures: '.		diff second do: [:s| str nextPutAll: s printString, ' '].		str cr.				str nextPutAll: 'New errors: '.		diff third do: [:s| str nextPutAll: s printString, ' '].		str cr].		Workspace new contents: string; openLabel: 'SUnit Progress'	! !!TestRunner methodsFor: 'updating' stamp: 'AlexandreBergel 10/1/2008 23:09'!updateResults	"<lint: #expect rule: #guardingClause>"	"<lint: #expect rule: #longMethods>"	self updateStatus: false.	failedList size = result failures size ifFalse: [		failedList := result failures asArray			sort: [ :a :b | a printString <= b printString ].		failedSelected := nil.		self 			changed: #failedList; 			changed: #failedSelected;			changed: #hasFailures;			changed: #hasProgress  ].	errorList size = result errors size ifFalse: [		errorList := result errors asArray			sort: [ :a :b | a printString <= b printString ].		errorSelected := nil.		self 			changed: #errorList; 			changed: #errorSelected;			changed: #hasErrors;			changed: #hasProgress ].! !!TestRunner methodsFor: 'actions' stamp: 'lr 3/30/2009 14:50'!runSuite: aTestSuite	self basicRunSuite: aTestSuite do: [ :each | self runTest: each ].	self updateResults! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 16:47'!excludeClassesNotUnderTestFrom: methods 	| theClass |	classesSelected do: 		[ :class | 		(class class selectors includes: #classNamesNotUnderTest) ifTrue: 			[ class classNamesNotUnderTest do: 				[ :className | 				theClass := Smalltalk classNamed: className.				theClass ifNotNil:[				theClass methods do: 					[ :each | 					methods 						remove: each methodReference						ifAbsent: [  ] ].				theClass class methods do: 					[ :each | 					methods 						remove: each methodReference						ifAbsent: [  ] ]] ] ] ]! !!TestRunner methodsFor: 'accessing-menu' stamp: 'lr 10/21/2008 18:05'!failureMenu: aMenu	^ aMenu! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 11:59'!selectNoClasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		classesSelected := Set new.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestCoverage methodsFor: 'testing' stamp: 'lr 3/30/2009 15:09'!hasRun	^ hasRun! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 7/4/2009 15:10'!filterClasses	| pattern |	pattern := UIManager default 		request: 'Pattern to select tests:' 		initialAnswer: '*'.	pattern isNil ifTrue: [ ^ self ].	classesSelected := (classes select: [ :each | 		pattern match: each name ]) asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!buildFailureListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Failure List';		list: #failedList; 		menu: #failureMenu:;		getIndex: #failedSelected; 		setIndex: #failedSelected:;		yourself.! !!TestCoverage methodsFor: 'initialization' stamp: 'lr 3/30/2009 15:19'!initializeOn: aMethodReference	hasRun := false.	reference := aMethodReference.	method := reference compiledMethod! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:26'!flushCache! !!TestRunner methodsFor: 'accessing-menu' stamp: 'simon.denier 11/13/2008 19:43'!statusMenu: aMenu	^ aMenu		add: 'History' action: #showHistoryMenu;		add: 'Store result as progress reference' action: #storeResultIntoTestCases;		add: 'Show progress' action: #showProgress; 		yourself! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:05'!buildStatusWith: aBuilder	^ aBuilder pluggableInputFieldSpec new		model: self;		menu: #statusMenu:;		color: #statusColor;		getText: #statusText;		yourself.! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:40'!addMethodsUnderTestIn: packages to: methods 	packages		do: [:package | package isNil				ifFalse: [package methods						do: [:method | ((#(#packageNamesUnderTest #classNamesNotUnderTest ) includes: method methodSymbol)									or: [method compiledMethod isAbstract											or: [method compiledMethod refersToLiteral: #ignoreForCoverage]])								ifFalse: [methods add: method]]]]! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:14'!collectCoverageFor: methods	| wrappers suite |	wrappers := methods collect: [ :each | TestCoverage on: each ].	suite := self		reset;		suiteAll.		[ wrappers do: [ :each | each install ].	[ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.	wrappers := wrappers reject: [ :each | each hasRun ].	wrappers isEmpty 		ifTrue: 			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]		ifFalse: 			[ MessageSet 				openMessageList: (wrappers collect: [ :each | each reference ])				name: 'Not Covered Code (' , (100 - (100 * wrappers size // methods size)) printString , '% Code Coverage)' ].	self saveResultInHistory! !!TestRunner methodsFor: 'accessing-testing' stamp: 'jf 3/4/2009 11:59'!statusColor	result hasFailures 		ifTrue:[ ^ Color yellow ].	result hasErrors 		ifTrue: [ ^ Color red ].	^ Color green! !!TestRunner methodsFor: 'history saving' stamp: 'stephane.ducasse 10/12/2008 19:24'!showHistoryMenu	| selectionIndex selectedPreviousResult actionIndex |	selectionIndex := UIManager default chooseFrom: self historyMenuList title: 'History:'.	"We pressed outside the menu"	selectionIndex isZero ifTrue: [ ^ self ]. 					"save current result is selected"	selectionIndex = 1 ifTrue: [ self previousRun addFirst: result. ^ self ]. 				selectedPreviousResult := self previousRun at: (selectionIndex - 1). 	actionIndex := (UIManager default chooseFrom: #('delete' 'show diff')  title:  'Action:').	actionIndex = 1 ifTrue: [ self previousRun remove: selectedPreviousResult. ^ self ].	actionIndex = 2 ifTrue: [ self showDiffWith: selectedPreviousResult].	! !!TestCoverage methodsFor: 'private' stamp: 'lr 3/30/2009 15:27'!reference	^ reference! !!TestRunner methodsFor: 'accessing-ui' stamp: 'lr 3/30/2009 14:42'!buttons	^ #(( 'Run Selected' #runAll #hasRunnable )		( 'Run Profiled' #runProfiled #hasRunnable )		( 'Run Coverage' #runCoverage #hasRunnable )		( 'Run Failures' #runFailures #hasFailures )		( 'Run Errors' #runErrors #hasErrors ))! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!filterCategories	| pattern |	pattern := UIManager default 		request: 'Pattern to select categories:' 		initialAnswer: '*'.	pattern isNil ifTrue: [ ^ self ].	categoriesSelected := (categories 		select: [ :each | pattern match: each ]) asSet.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'accessing-classes' stamp: 'gvc 7/24/2007 12:01'!selectSubclasses	"Fixed to update all selections now that the	selection invalidation has been optimised."		| classesForPackages |	classesForPackages := self findClassesForCategories: categoriesSelected.		classesSelected := (classesSelected gather: [ :class |		class withAllSubclasses select: [ :each |			classesForPackages includes: each ] ])		asSet.	self		changed: #allSelections;		changed: #classSelected;		changed: #hasRunnable! !!TestRunner methodsFor: 'accessing-categories' stamp: 'lr 7/4/2009 15:08'!selectNoCategories	categoriesSelected := Set new.	self changed: #allSelections; changed: #categorySelected; updateClasses! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:15'!runCoverage	| packages methods |	packages := Set new.	self addDeclaredPackagesUnderTestTo: packages.	packages isEmpty ifTrue: 		[ packages := self promptForPackages ].	methods := OrderedCollection new.	self 		addMethodsUnderTestIn: packages		to: methods.	self excludeClassesNotUnderTestFrom: methods.	methods isEmpty ifTrue: 		[ ^ UIManager default inform: 'No methods found for coverage analysis.' ].	self collectCoverageFor: methods! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:11'!promptForPackages	| packages |	packages := (PackageOrganizer default packages				reject: [:package | (package packageName beginsWith: 'Kernel')						or: [(package packageName beginsWith: 'Collections')								or: [(package packageName beginsWith: 'Exceptions')										or: [(package packageName beginsWith: 'SUnit')												or: [(package packageName beginsWith: 'System')														or: [package packageName includesSubstring: 'Test' caseSensitive: false]]]]]])				sort: [:a :b | a packageName < b packageName].	packages := Array				with: (UIManager default						chooseFrom: (packages								collect: [:package | package packageName])						values: packages						title: 'Select Package').	^ packages! !!TestRunner methodsFor: 'building' stamp: 'lr 10/21/2008 18:04'!buildErrorListWith: aBuilder	^ aBuilder pluggableListSpec new		model: self;		name: 'Error List';		list: #errorList; 		menu: #errorMenu:;		getIndex: #errorSelected; 		setIndex: #errorSelected:;		yourself.! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 20:28'!storeResultIntoTestCases	result classesTested do: [:testCaseCls | testCaseCls generateLastStoredRunMethod ]! !!TestRunner methodsFor: 'history saving' stamp: 'AlexandreBergel 10/1/2008 11:46'!previousRun	^ previousRun ifNil: [ previousRun := OrderedCollection new ]! !!TestCoverage methodsFor: 'evaluation' stamp: 'lr 3/30/2009 15:32'!run: aSelector with: anArray in: aReceiver	self mark; uninstall.	^ aReceiver withArgs: anArray executeMethod: method! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:48'!classSelected: anInteger	classIndex := anInteger.	self changed: #classSelected! !!TestRunner methodsFor: 'actions' stamp: 'onierstrasz 5/14/2009 14:05'!addDeclaredPackagesUnderTestTo: packages 	classesSelected do: 		[ :class | 		(class class selectors includes: #packageNamesUnderTest) ifTrue: 			[ class packageNamesUnderTest do: [ :name | packages add: (PackageInfo named: name) ] ] ]! !!TestRunner methodsFor: 'updating' stamp: 'lr 1/20/2009 14:48'!updateClasses	| classesForCategories |	classesForCategories := self findClassesForCategories: categoriesSelected.	classes := classesForCategories asArray		sort: [ :a :b | self sortClass: a before: b ].	classIndex := 0.	classesSelected := classesSelected isNil		ifTrue: [ classesForCategories ]		ifFalse: [ 			classesSelected				select: [ :each | classesForCategories includes: each ] ].	self changed: #classList; changed: #classSelected; changed: #hasRunnable.! !!TestRunner methodsFor: 'accessing-menu' stamp: 'lr 10/21/2008 18:10'!errorMenu: aMenu	^ self statusMenu: aMenu! !!TestCoverage methodsFor: 'actions' stamp: 'lr 3/30/2009 15:20'!install	reference actualClass methodDictionary		at: reference methodSymbol		put: self! !!TestRunner methodsFor: 'accessing-classes' stamp: 'lr 1/20/2009 14:46'!classSelected	^ classIndex! !!TestRunner methodsFor: 'history saving' stamp: 'simon.denier 11/13/2008 20:28'!hasProgress	result classesTested do: [:cls |		(cls class methodDictionary includesKey: #lastStoredRun)			ifTrue: [^ true]].	^ false! !!TestCoverage class methodsFor: 'instance creation' stamp: 'lr 3/30/2009 15:23'!on: aMethodReference	^ self new initializeOn: aMethodReference! !TestRunner removeSelector: #browseSentMessages!TestRunner removeSelector: #browseTestClasses!TestRunner removeSelector: #browseReferencedClasses!