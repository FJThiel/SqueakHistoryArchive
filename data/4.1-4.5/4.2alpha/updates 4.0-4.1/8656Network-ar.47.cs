"Change Set:		8656Network-ar.47Network-ar.47:Add HTTPProgress for put operations (uploads).Network-ar.45:Merging Network-tonyg.35:Do not specify ':80' (or other port number) in HTTP request 'Host' header unless a port number was explicitly specified, because doing so changes the meaning of the request when HTTP virtual-hosts are being used.Network-ar.46:Add an HTTPProgress notification that can be used to display progress during HTTPSocket httpGet: operations."!Notification subclass: #HTTPProgress	instanceVariableNames: 'total amount'	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!HTTPProgress methodsFor: 'accessing' stamp: 'ar 12/30/2009 16:15'!total	"Answer the total size of the download, if known"	^total! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 16:28'!sendDataWithProgress: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(HTTPProgress new)			total: bytesToSend;			amount: bytesSent;			signal: 'Uploading...'.		(self waitForSendDoneUntil: (Socket deadlineSecs: 60))			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		bytesSent := bytesSent + count].	^ bytesSent! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 16:27'!sendCommandWithProgress: commandString	"Send the given command as a single line followed by a <CR><LF> terminator."	self sendDataWithProgress: commandString, CrLf.! !!HTTPProgress methodsFor: 'accessing' stamp: 'ar 12/30/2009 16:15'!amount	"Answer the completed amount of the download (if known)"	^amount! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 12/30/2009 16:32'!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server"	| bare serverName specifiedServer port page serverAddr authorization s list header firstData length aStream command digest |	Socket initializeNetwork. 	"parse url"	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName := bare copyUpTo: $/.	specifiedServer := serverName.	(serverName includes: $:) ifFalse: [ port := self defaultPort ] ifTrue: [		port := (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName := serverName copyUpTo: $:.	].	page := bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page := '/'].	(self shouldUseProxy: serverName) ifTrue: [ 		page := 'http://', serverName, ':', port printString, page.		"put back together"		serverName := self httpProxyServer.		port := self httpProxyPort].  	"make the request"		serverAddr := NetNameResolver addressForName: serverName timeout: 20.	serverAddr ifNil: [		^ 'Could not resolve the server named: ', serverName].	authorization := ' Basic ', (user , ':' , passwd) base64Encoded.[	s := HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	command := 		'PUT ', page, ' HTTP/1.0', CrLf, 		self userAgentString, CrLf,		'Host: ', specifiedServer, CrLf, 		'ACCEPT: */*', CrLf,		HTTPProxyCredentials,		'Authorization: ' , authorization , CrLf , 		'Content-length: ', contents size printString, CrLf , CrLf , 		contents.	s sendCommandWithProgress: command.	"get the header of the reply"	list := s getResponseUpTo: CrLf, CrLf ignoring: String cr.	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData := list at: 3.	"dig out some headers"	s header: header.(authorization beginsWith: 'Digest ') notand: [(digest := self digestFrom: s method: 'PUT' url: url user: user password: passwd) notNil]]	whileTrue: [authorization :=  'Digest ', digest].	length := s getHeader: 'content-length'.	length ifNotNil: [ length := length asNumber ].	"Suppress progress during response handling"	[aStream := s getRestOfBuffer: firstData totalLength: length] 		on: HTTPProgress do:[:ex| ex resume].	s destroy.	"Always OK to destroy!!"	^ header, aStream contents! !!HTTPProgress methodsFor: 'accessing' stamp: 'ar 12/30/2009 16:15'!total: bytes	"Answer the total size of the download, if known"	total := bytes! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 12/30/2009 16:17'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port bare page index connectToHost connectToPort aStream portSuffix |	Socket initializeNetwork.	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare := bare copyUpTo: $#.  "remove fragment, if specified"	serverName := bare copyUpTo: $/.	page := bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index := serverName indexOf: $:.			port := (serverName copyFrom: index+1 to: serverName size) asNumber.			portSuffix := ':', port printString.			serverName := serverName copyFrom: 1 to: index-1. ]		ifFalse: [			port := self defaultPort.			portSuffix := ''. ].	page size = 0 ifTrue: [page := '/'].	"add arguments"	args ifNotNil: [page := page, (self argString: args) ].	(self shouldUseProxy: serverName)		ifFalse: [ 			connectToHost := serverName.			connectToPort := port ]		ifTrue:  [			page := 'http://', serverName, portSuffix, page.		"put back together"			connectToHost := self httpProxyServer.			connectToPort := self httpProxyPort].		HTTPProgress signal: 'Looking up ', connectToHost.	serverAddr := NetNameResolver addressForName: connectToHost timeout: 20.	serverAddr ifNil: [^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [ | sock length firstData list type header newUrl |	sock := HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	"Transcript cr;show: url; cr.	Transcript show: page; cr."	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, CrLf,		'Host: ', serverName, portSuffix, CrLf.	"blank line automatically added"	list := sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData := list at: 3.	header isEmpty 		ifTrue: [aStream := 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length := sock getHeader: 'content-length'.			length ifNotNil: [ length := length asNumber ].			type := sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl := sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl := self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType request: requestString] ].			aStream := sock getRestOfBuffer: firstData totalLength: length.			"a 400-series error"			sock responseCode first = $4 ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifTrue: [ ^aStream ].	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2009 16:16'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf := String new: length.	response := RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf := String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(HTTPProgress new)			total: length;			amount: response position;			signal: 'Downloading...'.		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead := self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response position). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	"Transcript cr; show: 'data byte count: ', response position printString."	"Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed'])."	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPProgress methodsFor: 'accessing' stamp: 'ar 12/30/2009 16:15'!amount: bytes	"Set the completed amount of the download (if known)"	amount := bytes! !