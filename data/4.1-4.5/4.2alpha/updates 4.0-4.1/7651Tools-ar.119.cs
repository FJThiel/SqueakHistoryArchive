"Change Set:		7651Tools-ar.119Tools-ar.119:Merged Tools-rkrk.113:Adding tests for optional hierarchical class ordering in Browser introduced in Tools-rkrk.111.Tools-rss.107:Removed the line from CodeHolder>>contentsSymbolQuints that makes the colorPrint option appear in the system browser's source menu.I'm going to look at seeing where else these might be sent, as one or more might be unload candidates:colorPrinttoggleColorPrintcolorPrintStringTools-rkrk.108:Fixed bug #0007389: Lexicon>>categoryMenu: MNU when opening a context menu in the category list in a protocol browserTools-rkrk.109:Fix for http://bugs.squeak.org/view.php?id=7390Extended Lexicon so that necessary buttons for controlling the browser are appearing again.Tools-rss.110:Removing cruft left over from colorPrint browser option and colorWhenPrettyPrinting preference.Tools-rkrk.111:Optionally order and indent classes by hierarchy in the Browser.Enable with:Preferences enable: #listClassesHierarchically.Tools-rkrk.112:Preferences isn't used anymore for listing classes hierarchically in the browser. Use Browser listClassesHierarchically: true to enable the feature.Tools-rkrk.114:The debugger doesn't show custom messages. This means that notifications like Monticello's warning that changes are going to be lost aren't displayed anymore.This fixs adds an instance variable to Debugger which stores the message.#preDebugNotifierContentsFrom: method is removed since it is apperently not used anymore.Tools-rkrk.115:Bugfix for hierarchical browser class lists introduced in Tools-rkrk.111 when browsing Traits.Tools-nice.116:Fix for http://bugs.squeak.org/view.php?id=6812Inspecting a WeakSet will raise a DebuggerThis is because field names were collected in a WeakSet and would die pretty soon...Tools-ar.117:Merging Tools-rkrk.116:- disable multiselect fo VersionsBrowser (makes no sense there)- adding revert button to VersionsBrowser so you don't need to open a menu to revert to the selected versionTools-rkrk.113:Adding tests for optional hierarchical class ordering in Browser introduced in Tools-rkrk.111.Tools-ar.118:Fixes a small annoyance in MessageSets: when browsing senders, the initial selection wasn't auto-selecting the search string but only after the entry was deselected and selected again."!TestCase subclass: #BrowserHierarchicalListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Browser-Tests'!CodeHolder subclass: #Debugger	instanceVariableNames: 'interruptedProcess interruptedController contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC debuggerMap savedCursor isolationHead failedProject errorWasInUIProcess labelString message'	classVariableNames: 'ContextStackKeystrokes ErrorRecursion'	poolDictionaries: ''	category: 'Tools-Debugger'!CodeHolder subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated'	classVariableNames: 'ListClassesHierarchically RecentClasses'	poolDictionaries: ''	category: 'Tools-Browser'!!Debugger methodsFor: 'toolbuilder' stamp: 'rkrk 8/24/2009 05:52'!buildNotifierWith: builder label: label message: messageString	| windowSpec listSpec textSpec panelSpec buttonSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec extent: 450 @ 156. "nice and wide to show plenty of the error msg"	windowSpec label: label.	windowSpec children: OrderedCollection new.	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self preDebugButtonQuads do:[:spec|		buttonSpec := builder pluggableButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		buttonSpec help: spec fourth.		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	panelSpec frame: (0@0 corner: 1@0.2).	windowSpec children add: panelSpec.	Preferences eToyFriendly | messageString notNil ifFalse:[		listSpec := builder pluggableListSpec new.		listSpec 			model: self;			list: #contextStackList; 			getIndex: #contextStackIndex; 			setIndex: #debugAt:; 			frame: (0@0.2 corner: 1@1).		windowSpec children add: listSpec.	] ifTrue:[		message := messageString.		textSpec := builder pluggableTextSpec new.		textSpec 			model: self;			getText: #preDebugMessageString; 			setText: nil; 			selection: nil; 			menu: #debugProceedMenu:;			frame: (0@0.2corner: 1@1).		windowSpec children add: textSpec.	].	^windowSpec! !!CodeHolder methodsFor: 'controls' stamp: 'rss 8/22/2009 12:49'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source			togglePlainSource 			showingPlainSourceString	'source'		'the textual source code as written')(documentation	toggleShowDocumentation	showingDocumentationString	'documentation'		'the first comment in the method')-(prettyPrint		togglePrettyPrint 			prettyPrintString			'prettyPrint'			'the method source presented in a standard text format')-(showDiffs		toggleRegularDiffing		showingRegularDiffsString	'showDiffs'				'the textual source diffed from its prior version')(prettyDiffs		togglePrettyDiffing			showingPrettyDiffsString	'prettyDiffs'		'formatted textual source diffed from formatted form of prior version')-(decompile		toggleDecompile				showingDecompileString		'decompile'			'source code decompiled from byteCodes')(byteCodes		toggleShowingByteCodes		showingByteCodesString		'byteCodes'			'the bytecodes that comprise the compiled method')-(tiles			toggleShowingTiles 			showingTilesString			'tiles'				'universal tiles representing the method'))! !!Browser class methodsFor: 'preferences' stamp: 'rkrk 8/23/2009 18:30'!listClassesHierarchically: aBool	ListClassesHierarchically := aBool! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 03:02'!selectedClassName	| className |	className := self classList		at: classListIndex		ifAbsent: [^ nil].	self class listClassesHierarchically ifTrue: [		className := className withoutLeadingBlanks asSymbol].	^ className.! !!VersionsBrowser methodsFor: 'toolbuilder' stamp: 'rkrk 8/24/2009 07:08'!optionalButtonPairs	^ #(('revert' fileInSelections 'resubmit the selected version, so that it becomes the current version')) , super optionalButtonPairs! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 05:26'!buildCustomButtonsWith: builder	"This method if very similar to StringHolder>>buildOptionalButtonsWith:.	Refactor and pass in button specs?"	| panelSpec buttonSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self customButtonSpecs do: [:spec |		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec size > 2 ifTrue: [buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	self addSpecialButtonsTo: panelSpec with: builder.	^panelSpec! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'rkrk 8/24/2009 05:10'!testListClassesHierarchically1	| result classes category |	category := 'Collections-Abstract'.	result := self hierarchicalClassListForCategory: category.	self assert: (SystemOrganization listAtCategoryNamed: category) size equals: result size.	classes := result collect: [:ea | self nameToClass: ea].	classes withIndexDo: [:ea : i |		classes 			from: 1 to: i			do: [:other | self assertCorrectOrderOf: other followedBy: ea in: classes]].! !!Browser methodsFor: 'initialize-release' stamp: 'rkrk 8/24/2009 00:34'!setClass: aBehavior selector: aSymbol	"Set the state of a new, uninitialized Browser."	| isMeta aClass messageCatIndex |	aBehavior ifNil: [^ self].	(aBehavior isKindOf: Metaclass)		ifTrue: [			isMeta := true.			aClass := aBehavior soleInstance]		ifFalse: [			isMeta := false.			aClass := aBehavior].	self selectCategoryForClass: aClass.	self classListIndex: (self classListIndexOf: aClass name).	self metaClassIndicated: isMeta.	aSymbol ifNil: [^ self].	messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: (messageCatIndex > 0		ifTrue: [messageCatIndex + 1]		ifFalse: [0]).	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex: (		(aBehavior organization listAtCategoryNumber: messageCatIndex)			indexOf: aSymbol).! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 00:41'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList := RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ Beeper beep].	className := UIManager default chooseFrom: recentList values: recentList.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classListIndexOf: class name)! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'rkrk 8/24/2009 01:38'!selectedClassName	"Answer the name of the class currently selected.   di	  bug fix for the case where name cannot be found -- return nil rather than halt"	| aName |	aName := self classList at: classListIndex ifAbsent: [^ nil].	^ (aName copyWithout: Character space) asSymbol! !!BrowserHierarchicalListTest methodsFor: 'helper' stamp: 'rkrk 8/24/2009 05:05'!hierarchicalClassListForCategory: category	| b index |	b := Browser new.	index := b systemCategoryList indexOf: category.	b systemCategoryListIndex: index.	^ b hierarchicalClassList.! !!Debugger methodsFor: 'toolbuilder' stamp: 'rkrk 8/24/2009 05:48'!preDebugMessageString	^ message ifNil: ['An error has occurred; you should probably just hit ''abandon''.  Sorry!!'].! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 00:21'!defaultClassList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	^ systemCategoryListIndex = 0		ifTrue: [Array new]		ifFalse: [systemOrganizer listAtCategoryNumber: systemCategoryListIndex]! !!ChangeSorter methodsFor: 'code pane' stamp: 'rss 8/23/2009 12:51'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType | 	self clearUserEditFlag.	currentClassName ifNil: [^ contents := myChangeSet preambleString ifNil: ['']].	class := self selectedClassOrMetaClass.	(sel := self selectedMessageName) == nil		ifFalse: [changeType := (myChangeSet atSelector: (sel := sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents := 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents := 'Added then removed (see versions)'].			class ifNil: [^ contents := 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents := 'Method was added, but cannot be found!!'].			contents := class sourceCodeAt: sel.			(#(prettyPrint prettyDiffs) includes: contentsSymbol) ifTrue:				[contents :=  class prettyPrinterClass					format: contents in: class notifying: nil].			self showingAnyKindOfDiffs				ifTrue: [contents := self diffFromPriorSourceFor: contents].			^ contents := contents asText makeSelectorBoldIn: class]		ifTrue: [strm := WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents := strm contents].! !!WeakSetInspector methodsFor: 'accessing' stamp: 'nice 12/15/2007 11:59'!fieldList	| slotIndices |	object ifNil: [^ Set new].		"Implementation note: do not use objectArray withIndexCollect: as super	because this might collect indices in a WeakArray, leading to constantly changing fieldList	as explained at http://bugs.squeak.org/view.php?id=6812"		slotIndices := (Array new: object size) writeStream.	object array withIndexDo: [:each :i |		(each notNil and: [each ~= flagObject]) ifTrue: [slotIndices nextPut: i printString]].		^ self baseFieldList		, slotIndices contents! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 03:02'!classListIndexOf: className 	| classList |	classList := self classList.	self class listClassesHierarchically		ifTrue: [classList := classList collect: [:ea | ea withoutLeadingBlanks asSymbol]].	^ classList indexOf: className.! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 05:27'!buildCodePaneWith: builder		| spec standardButtonPanel codePane customPanelSpec |	spec := super buildCodePaneWith: builder.	standardButtonPanel := spec children		detect: [:ea | ea isKindOf:  PluggablePanelSpec]		ifNone: [^ spec]. "do nothing if optionalButtons not enabled"	customPanelSpec := self buildCustomButtonsWith: builder.	customPanelSpec frame: (0@0.12 corner: 1@0.24).	spec children add: customPanelSpec after: standardButtonPanel.	"resize code pane so that new panel fits in"	codePane := spec children detect: [:ea | ea isKindOf:  PluggableCodePaneSpec].	codePane frame:  (codePane frame withTop: 0.24).	^ spec.! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/7/2009 23:24'!openOnClass: aTargetClass showingSelector: aSelector	currentVocabulary ifNil: [currentVocabulary := Vocabulary fullVocabulary].	targetClass := aTargetClass.	self initialLimitClass.		self reformulateCategoryList.	ToolBuilder open: self.	self adjustWindowTitle.! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 03:04'!buildCategoryListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #categoryList; 		getIndex: #categoryListIndex; 		setIndex: #categoryListIndex:; 		menu: #categoryListMenu:shifted:; 		keyPress: #categoryListKey:from:.	^listSpec! !!BrowserHierarchicalListTest methodsFor: 'assertion' stamp: 'rkrk 8/24/2009 05:03'!assertCorrectOrderOf: classB followedBy: classA in: classCollection	"classB comes before classA. Assert that classB is a superclass of classB or that 	a common superclass is in front of both"	| commonSuperclasses commonSuperclass classAIndex classBIndex superIndex |	classA == classB ifTrue: [^ self].	(classA inheritsFrom: classB) ifTrue: [^ self].	commonSuperclasses := classA withAllSuperclasses intersection: classB withAllSuperclasses.	commonSuperclass := commonSuperclasses first.	(classCollection includes: commonSuperclass) ifFalse: [^ self].	classAIndex := classCollection indexOf: classA.	classBIndex := classCollection indexOf: classB.	superIndex := classCollection indexOf: commonSuperclass.	(superIndex < classAIndex and: [superIndex < classBIndex]) ifTrue: [^self].	self fail.! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'rss 8/23/2009 11:03'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	contents := class sourceCodeAt: selector.	Preferences browseWithPrettyPrint 		ifTrue: 			[contents := class prettyPrinterClass 						format: contents						in: class						notifying: nil						decorated: false].	self showingAnyKindOfDiffs 		ifTrue: 			[contents := self 						methodDiffFor: contents						class: self selectedClass						selector: self selectedMessageName						meta: self metaClassIndicated].	^contents asText makeSelectorBoldIn: class! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'rkrk 8/24/2009 05:07'!testListClassesHierarchicallyIndent	| result dict indent |	result := self hierarchicalClassListForCategory: 'Tools-Browser'.	"Create class->indent mapping"	dict := result inject: Dictionary new into: [:classIndentMapping :className |		indent := className count: [:char | char = Character space or: [char = Character tab]].		classIndentMapping at: (self nameToClass: className) put: indent.		classIndentMapping].	"assert that indent of class is larger than indent of superclass"	dict keysAndValuesDo: [:class :myIndent |		dict at: class superclass ifPresent: [:superIndent |			self assert: myIndent > superIndent]].! !!MessageSet methodsFor: 'toolbuilder' stamp: 'ar 8/25/2009 00:22'!buildWith: builder	| windowSpec max result |	self wantsOptionalButtons ifTrue:[max := 0.3] ifFalse:[max := 0.3].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	self changed: #autoSelect.	^result! !!Lexicon methodsFor: 'limit class' stamp: 'rkrk 8/23/2009 05:29'!setLimitClass: aClass	"Set aClass as the limit class for this browser"	| currentClass currentSelector |	currentClass := self selectedClassOrMetaClass.	currentSelector := self selectedMessageName.	self limitClass: aClass.	categoryList := nil.	self categoryListIndex: 0.	self changed: #categoryList.	self changed: #methodList.	self changed: #contents.	self changed: #limitClassString.	self adjustWindowTitle.	self hasSearchPane		ifTrue:			[self setMethodListFromSearchString].	self maybeReselectClass: currentClass selector: currentSelector	! !!CodeHolder methodsFor: 'message list' stamp: 'rss 8/23/2009 12:52'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^'missing'].	sourceString := class ultimateSourceCodeAt: selector ifAbsent: [^'error'].	self validateMessageSource: sourceString forSelector: selector.	(#(#prettyPrint #prettyDiffs) 		includes: contentsSymbol) 			ifTrue: 				[sourceString := class prettyPrinterClass 							format: sourceString							in: class							notifying: nil].	self showingAnyKindOfDiffs 		ifTrue: [sourceString := self diffFromPriorSourceFor: sourceString].	^sourceString! !!BrowserHierarchicalListTest methodsFor: 'helper' stamp: 'rkrk 8/24/2009 04:32'!nameToClass: classNameWithIndent	^ Smalltalk classNamed: classNameWithIndent withoutLeadingBlanks asSymbol! !!Browser methodsFor: 'traits' stamp: 'rkrk 8/24/2009 00:41'!defineTrait: defString notifying: aController  	| defTokens keywdIx envt oldTrait newTraitName trait |	oldTrait := self selectedClassOrMetaClass.	defTokens := defString findTokens: Character separators.	keywdIx := defTokens findFirst: [:x | x = 'category'].	envt := self selectedEnvironment.	keywdIx := defTokens findFirst: [:x | x = 'named:'].	newTraitName := (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldTrait isNil or: [oldTrait baseTrait name asString ~= newTraitName])		and: [envt includesKey: newTraitName asSymbol]) ifTrue:			["Attempting to define new class/trait over existing one when				not looking at the original one in this browser..."			(self confirm: ((newTraitName , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newTraitName size))				ifFalse: [^ false]].	trait := Compiler evaluate: defString notifying: aController logged: true.	^(trait isKindOf: TraitBehavior)		ifTrue: [			self changed: #classList.			self classListIndex: (self classListIndexOf: trait baseTrait name).			self clearUserEditFlag; editClass.			true]		ifFalse: [ false ]! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 06:30'!createHierarchyTreeOf: col	"Create a tree from a flat collection of classes"	| childs transformed val indexes |	transformed := col collect: [:ea | 		childs := col select: [:class | class isTrait not and: [class superclass = ea]].		indexes := childs collect: [:child | col indexOf: child].		ea -> indexes].	transformed copy do: [:ea |		ea value: (ea value collect: [:idx | 			val := transformed at: idx.			transformed at: idx put: nil.			val])].	^ transformed select: [:ea | ea notNil].! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 01:48'!flattenHierarchyTree: classHierarchy on: col indent: indent	| class childs plusIndent |	plusIndent := String space.	classHierarchy do: [:assoc |		class := assoc key.		col add: indent , class name.		childs := assoc value.		self			flattenHierarchyTree: childs			on: col			indent: indent , plusIndent].	^ col! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 00:45'!selectClass: classNotMeta	self classListIndex: (self classListIndexOf: classNotMeta name)! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 00:30'!openOnClass: aTargetClass inWorld: ignored showingSelector: aSelector	^self openOnClass: aTargetClass showingSelector: aSelector! !!VersionsBrowser methodsFor: 'user interface' stamp: 'rkrk 8/24/2009 07:17'!initialExtent	"adopt the extent so that the revert button fits in"	^650@400! !!CodeHolder methodsFor: 'contents' stamp: 'rss 8/23/2009 10:34'!contentsSymbol	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"	^ contentsSymbol ifNil:		[contentsSymbol := Preferences browseWithPrettyPrint								ifTrue:									[#prettyPrint]								ifFalse:									[#source]]! !!Browser methodsFor: 'class functions' stamp: 'rkrk 8/24/2009 00:43'!renameClass	| oldName newName obs |	classListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	oldName := self selectedClass name.	newName := self request: 'Please type new class name' initialAnswer: oldName.	newName = ''		ifTrue: [^ self].	"Cancel returns ''"	newName := newName asSymbol.	newName = oldName		ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changed: #classList.	self classListIndex: (self classListIndexOf: newName).	obs := self systemNavigation				allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty		ifFalse: [self systemNavigation				browseMessageList: obs				name: 'Obsolete References to ' , oldName				autoSelect: oldName]! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 17:07'!buildWith: builder	"Create the ui for the browser"	| windowSpec max |	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 0.5@max) -> [self buildCategoryListWith: builder].		(0.5@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	^builder build: windowSpec! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 03:02'!classList	^ self class listClassesHierarchically		ifTrue: [self hierarchicalClassList]		ifFalse: [self defaultClassList].! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 05:31'!addSpecialButtonsTo: buttonPanelSpec with: builder	| homeCatBtnSpec menuBtnSpec mostGenericBtnSpec |	homeCatBtnSpec := builder pluggableButtonSpec new		model: self;		action: #showHomeCategory;		label: (ScriptingSystem formAtKey: #Cat) asMorph;		help: 'show this method''s home category';		yourself.	menuBtnSpec := builder pluggableButtonSpec new		model: self;		action: #offerMenu;		label: (ScriptingSystem formAtKey: #TinyMenu) asMorph;		help: 'click here to get a menu with further options';		yourself.	mostGenericBtnSpec :=builder pluggableButtonSpec new		model: self;		action: #chooseLimitClass;		label: #limitClassString;		help: 'Governs which classes'' methods should be shown.  If this is the same as the viewed class, then only methods implemented in that class will be shown.  If it is ProtoObject, then methods of all classes in the vocabulary will be shown.'.	buttonPanelSpec children		add: homeCatBtnSpec;		addFirst: mostGenericBtnSpec;		addFirst: menuBtnSpec.! !!Browser methodsFor: 'class list' stamp: 'rkrk 8/24/2009 01:50'!hierarchicalClassList	"classNames are an arbitrary collection of classNames of the system.	Reorder those class names so that they are sorted and indended by inheritance"	| classes |	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].	^ self		flattenHierarchyTree: (self createHierarchyTreeOf: classes)		on: OrderedCollection new		indent: ''.! !!ChangeList methodsFor: 'toolbuilder' stamp: 'rkrk 8/24/2009 07:02'!buildWith: builder	^self buildWith: builder multiSelect: self showsVersions not! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'rkrk 8/24/2009 05:09'!testListClassesHierarchically2	| result classes category |	category := 'Tools-Browser'.	result := self hierarchicalClassListForCategory: category.	self assert: (SystemOrganization listAtCategoryNamed: category) size equals: result size.	classes := result collect: [:ea | self nameToClass: ea].	classes withIndexDo: [:ea : i |		classes 			from: 1 to: i			do: [:other | self assertCorrectOrderOf: other followedBy: ea in: classes]].! !!Lexicon methodsFor: 'toolbuilder' stamp: 'sw 1/24/2001 21:25'!wantsAnnotationPane	"This kind of browser always wants annotation panes, so answer true"	^ true! !!Browser class methodsFor: 'preferences' stamp: 'rkrk 8/23/2009 18:27'!listClassesHierarchically	<preference: 'List classes hierarchically'		category: 'browsing'		description: 'When enabled, the class list in the browser is arranged and indented with regard to the class hierarchy.'		type: #Boolean>	^ListClassesHierarchically ifNil: [false]! !CodeHolder removeSelector: #colorPrintString!CodeHolder removeSelector: #toggleColorPrint!Debugger removeSelector: #preDebugNotifierContentsFrom:!CodeHolder removeSelector: #showingColorPrint!