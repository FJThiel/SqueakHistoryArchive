"Change Set:		7393Collections-jmv.113Collections-jmv.113:Added #withoutJustTrailingDigits, that is like #withoutTrailingDigits, but does not trim at the first space.Collections-nice.100:Fix for Interval>>#includes: and #indexOf:http://bugs.squeak.org/view.php?id=1602http://bugs.squeak.org/view.php?id=1603http://bugs.squeak.org/view.php?id=6455http://bugs.squeak.org/view.php?id=7180Note: repeat after me:Interval of Floats are evil.Though the noble fuzzy inclusions tests (corrected by this patch), some interval will fail in finding their own elements:| eps i |eps := (1.0 timesTwoPower: -52) * 1.25.i := (1 to: 1+(99*eps) by: eps).^(i includes: (i at: 2))Collections-ar.101:Allow Text>>runLengthFor: to return 0 for an empty text so that client code does not need to guard specifically against the situation. This is similar to other methods that behave identically in this situation (#emphasisAt:, #fontAt:) .Collections-ar.102:Conversion functions for base64. Just as we have 	'Hello World' zipped unzipped = 'Hello World'we can now use the similarly useful	'Hello World' base64Encoded base64Decoded = 'Hello World'or more practically useful since this is what often happens in transmissions of lengthy data over text channels:	'Hello World' zipped base64Encoded 		base64Decoded unzipped = 'Hello World'.Collections-nice.103:Fix forhttp://bugs.squeak.org/view.php?id=6994#(1 2 3) asByteArray as: Interval.Note: this does not fix #(nil) as: Interval.Collections-nice.104:Fix forhttp://bugs.squeak.org/view.php?id=7136LinkedList #add:after: bugCollections-nice.105:Fix for http://bugs.squeak.org/view.php?id=7121add:beforeIndex: and add:afterIndex: do not work as advertised Collections-nice.106:Fix for http://bugs.squeak.org/view.php?id=6998WideString>>at:put: does not return the put-objectCollections-nice.107:Fix forhttp://bugs.squeak.org/view.php?id=67821.0 / (FloatArray with: 2.0)Note: the fix also handle case of gradual underflow like:self assert: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2.Collections-nice.108:Fix forhttp://bugs.squeak.org/view.php?id=7175CharacterSetComplement cannot printString Collections-nice.109:Test forhttp://bugs.squeak.org/view.php?id=6482Interval storeOn: incorrect for some ScaledDecimalSome ScaledDecimal have more bits than printed.Example: 0.5s1 squared will print 0.2s1However 0.5s1 squared * 4 = 1Thus (0 to: 1 by: 0.5s1 squared) size = 5(0 0.25 0.5 0.75 1)If you storeString and reinterpret, you get size 6(0 0.2 0.4 0.6 0.8 1.0)Interval SHOULD use storeOn: and not rely on Number>>printOn:This is some sort of violation of encapsulation.And it is defeated by introduction of a new species of Number (ScaledDecimal)...Collections-nice.110:Fix forhttp://bugs.squeak.org/view.php?id=6777CharacterSet copy is shallow... 'If we change the copy, do we change the original?We'd better not'| cs1 cs2 |cs1 := CharacterSet separators.cs2 := cs1 copy.cs2 remove: Character tab.^self assert: (cs1 includes: Character tab). Collections-nice.111:Fix forhttp://bugs.squeak.org/view.php?id=7172CharacterSetComplement byteArrayMap optimization is slow Add an inst var to cache this information.Rationale: #byteArrayMap is a method dedicated to optimization of speed, there is no reason why we should spoil the game with introduction of CharacterSetComplement in 3.10.Collections-ar.112:Text class fromString: no longer creates a text attribute referring to the current default font index. This caused extremely strange effects when such text is displayed using any non-default text style."!Collection subclass: #CharacterSetComplement	instanceVariableNames: 'absent byteArrayMapCache'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!String methodsFor: 'converting' stamp: 'ar 7/22/2009 22:00'!base64Decoded	"Decode the receiver from base 64"	"'SGVsbG8gV29ybGQ=' base64Decoded"	^(Base64MimeConverter mimeDecode: self as: self class)! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 8/31/2008 14:54'!remove: aCharacter	"This means aCharacter is now absent from myself.	It must be added to my absent."		byteArrayMapCache := nil.	^absent add: aCharacter! !!FloatArray methodsFor: 'arithmetic' stamp: 'nice 11/24/2007 00:10'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a Number. If possible,	convert it to a float and perform the (more efficient) primitive operation."	selector == #+ ifTrue:[^self + rcvr].	selector == #* ifTrue:[^self * rcvr].	selector == #- ifTrue:[^self negated += rcvr].	selector == #/ ifTrue:[		"DO NOT USE TRIVIAL CODE			^self reciprocal * rcvr		BECAUSE OF GRADUAL UNDERFLOW		self should: (1.0e-39 / (FloatArray with: 1.0e-39)) first < 2."			^(self class new: self size withAll: rcvr) / self		].	^super adaptToNumber: rcvr andSend: selector! !!WideString methodsFor: 'accessing' stamp: 'nice 4/2/2008 23:53'!at: index put: aCharacter 	"Store the Character in the field of the receiver indicated by the index."	aCharacter isCharacter ifFalse:[self errorImproperStore].	self wordAt: index put: aCharacter asInteger.	^aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 8/31/2008 14:56'!add: aCharacter 	"a character is present if not absent, so adding a character is removing it from the absent"		(absent includes: aCharacter)		ifTrue:			[byteArrayMapCache := nil.			absent remove: aCharacter].	^ aCharacter! !!String methodsFor: 'converting' stamp: 'ar 7/22/2009 22:00'!base64Encoded	"Encode the receiver as base64"	"'Hello World' base64Encoded"	^(Base64MimeConverter mimeEncode: (ReadStream on: self)) contents! !!CharacterSetComplement methodsFor: 'initialize-release' stamp: 'nice 8/31/2008 14:56'!complement: aCharacterSet	"initialize with the complement"		byteArrayMapCache := nil.	absent := aCharacterSet.	! !!Interval methodsFor: 'accessing' stamp: 'nice 2/3/2008 21:18'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock 	"startIndex is an positive integer, the collection index where the search is started."	"during the computation of val , floats are only used when the receiver	contains floats"	| index val |	(self rangeIncludes: anElement)		ifFalse: [^ exceptionBlock value].	val := anElement - self first / self increment.	val isFloat		ifTrue: [(val - val rounded) abs * 100000000 < 1				ifTrue: [index := val rounded + 1]				ifFalse: [^ exceptionBlock value]]		ifFalse: [val isInteger				ifTrue: [index := val + 1]				ifFalse: [^ exceptionBlock value]].	"finally, the value of startIndex comes into play:"	^ index < startIndex		ifTrue: [exceptionBlock value]		ifFalse: [index]! !!OrderedCollection methodsFor: 'adding' stamp: 'ar 7/15/2008 23:05'!add: newObject beforeIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just before index. Answer newObject."	(index between: 1 and: self size+1) ifFalse:[^self errorSubscriptBounds: index].	self insert: newObject before: firstIndex + index - 1.	^ newObject! !!String methodsFor: 'converting' stamp: 'jmv 8/6/2009 09:17'!withoutJustTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit := (self findFirst: [:m | m isDigit]).	^ firstDigit > 0		ifTrue:			[(self copyFrom: 1 to: firstDigit-1) withoutTrailingBlanks]		ifFalse:			[self]"'Wh oopi e234' withoutJustTrailingDigits'Wh oopi e 234' withoutJustTrailingDigits"! !!LinkedList methodsFor: 'adding' stamp: 'nice 7/28/2008 22:37'!add: link after: otherLink	"Add otherLink  after link in the list. Answer aLink."	| savedLink |	lastLink == otherLink ifTrue: [^ self addLast: link].	savedLink := otherLink nextLink.	otherLink nextLink: link.	link nextLink:  savedLink.	^link.! !!Interval methodsFor: 'printing' stamp: 'nice 5/12/2007 00:55'!storeOn: aStream 	aStream nextPut: $(;	 store: start;	 nextPutAll: ' to: ';	 store: stop.	step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; store: step].	aStream nextPut: $)! !!Text methodsFor: 'emphasis' stamp: 'ar 7/22/2009 21:52'!runLengthFor: characterIndex 	"Answer the count of characters remaining in run beginning with 	characterIndex."	self size = 0 ifTrue:[^0]. "null tolerates access"	^runs runLengthAt: characterIndex! !!CharacterSetComplement methodsFor: 'printing' stamp: 'nice 11/19/2007 23:55'!storeOn: aStream	"Store a description of the elements of the complement rather than self."		aStream nextPut: $(.	absent storeOn: aStream.	aStream nextPut: $); space; nextPutAll: #complement.! !!Text class methodsFor: 'instance creation' stamp: 'ar 8/4/2009 23:54'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, aString."	^ self string: aString attributes:  #()! !!Interval class methodsFor: 'instance creation' stamp: 'nice 3/27/2008 00:17'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."    | newInterval n |    (n := aCollection size) <= 1 ifTrue: [		n = 0 ifTrue: [^self from: 1 to: 0].		^self from: aCollection first to: aCollection last].    	newInterval := self from: aCollection first to: aCollection last	by: (aCollection last - aCollection first) // (n - 1).	aCollection ~= newInterval		ifTrue: [			"Give a second chance, because progression might be arithmetic, but = answer false"			(newInterval hasEqualElements: aCollection) ifFalse: [				self error: 'The argument is not an arithmetic progression']].	^newInterval"	Interval newFrom: {1. 2. 3}	{33. 5. -23} as: Interval	{33. 5. -22} as: Interval    (an error)	(-4 to: -12 by: -1) as: Interval	#(2 4 6) asByteArray as: Interval."! !!OrderedCollection methodsFor: 'adding' stamp: 'ar 7/15/2008 23:03'!add: newObject afterIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just after index. Answer newObject."	(index between: 0 and: self size) ifFalse:[^self errorSubscriptBounds: index].	self insert: newObject before: firstIndex + index.	^ newObject! !!CharacterSetComplement methodsFor: 'private' stamp: 'nice 8/31/2008 14:28'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^byteArrayMapCache ifNil: [byteArrayMapCache := absent byteArrayMap collect: [:i | 1 - i]]! !!CharacterSetComplement methodsFor: 'printing' stamp: 'nice 11/19/2007 23:54'!printOn: aStream	"Print a description of the complement rather than self.	Rationale: self would be too long to print."		aStream nextPut: $(.	absent printOn: aStream.	aStream nextPut: $); space; nextPutAll: #complement.! !!CharacterSet methodsFor: 'copying' stamp: 'nice 11/20/2007 00:40'!postCopy	map := map copy! !Interval removeSelector: #includes:!Interval removeSelector: #valuesInclude:!