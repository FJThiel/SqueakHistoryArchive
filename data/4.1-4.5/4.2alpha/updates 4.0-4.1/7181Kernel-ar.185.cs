"Change Set:		7181Kernel-ar.185Kernel-ar.185:Fixes ClassBuilder's resistance to change a class from being a #subclass: to being a #variableSubclass: due to a test that should only be run for actual subclasses but was invoked for the superclass too. A test is provided in KernelTest-ar.67.Kernel-dtl.173:Remove <lf> and fix underscores for Kernel-Chronology.Reference Mantis 5229: Linefeeds in 22 Methods in 3.9g-7061and Mantis 5675: Many method sources and class comments have been contaminated with Character lf.Removed line feed characters and converted underscores to := for assignment, added missing indentation to one method.Original author initials and timestamps have been retained.Tricked Monticello into saving methods as 'changed' by one of the following: - add or remove a line terminator to the method - remove unnecessary trailing $. at end of methodKernel-dtl.174:Remove <lf> characters from a couple of methods in Kernel-Chronology missed in the last update.Kernel-dtl.175:Remove <lf> characters from class comments of TimeSpan and Year. Add a bogus class veriable to each, to trick Monticello into accepting the change. The class variables will be removed in the next update.Kernel-dtl.176:Remove temporary class variables from TimeSpan and Year. This completes removal of <lf> characters from these classes.Kernel-dtl.177:Reference Mantis 0007356: DateAndTime fromSeconds: 0.5 => walkback, broken since Mantis 4669Allow #fromSeconds: to accept non-integer arguments, and update Time>>printString to display fractional seconds for better compatibility with the original Squeak implementation. The expressions 'DateAndTime fromSeconds: 0.5' and 'Time fromSeconds: 0.5' now behave as expected.This change set fixes a limitation of #fromSeconds: that was introduced in Mantis 4669: [ENH] TimeForSpeed. It changes the corresponding #fromSeconds: and #printString for class Time to match DateAndTime and to be more compatible with the original Squeak implementation.Kernel-dtl.178:Reference Mantis 7367: Add #asTimeStamp to TimeStamp class>>currentAdd an #asTimeStamp to implementation of TimeStamp class>>current. Ensures that #current always answers an instance of TimeStamp even if the superclass implementation is modified. Permits external package TimeZoneDatabase to avoid packaging conflicts. There is no impact on function or performance. All Chronology tests are green.Kernel-dtl.179:Reference Mantis 7361: Float >= primitive failure code sends > instead of >=Updated Float>>>= to fix error in fallback code (typo)"!Magnitude subclass: #Duration	instanceVariableNames: 'nanos seconds'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!Timespan subclass: #Year	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!Object subclass: #TimeZone	instanceVariableNames: 'offset abbreviation name'	classVariableNames: ''	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!Magnitude subclass: #Timespan	instanceVariableNames: 'start duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Chronology'!!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 5/21/2003 08:35'!current	^ self starting: DateAndTime now! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!print24	"Return as 8-digit string 'hh:mm:ss', with leading zeros if needed"	^String streamContents:		[ :aStream | self print24: true on: aStream ]! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 18:48'!starting: aDateAndTime duration: aDuration	^ self basicNew 		start: aDateAndTime asDateAndTime;		duration: aDuration;		yourself! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:45'!duration	| ts last |	self isSuspended 		ifTrue:			[ (ts := self timespans) isEmpty ifTrue: 				[ ts := { Timespan starting: DateAndTime now duration: Duration zero } ] ]		ifFalse:			[ last := self timespans last.			ts := self timespans allButLast				add: (last duration: (DateAndTime now - last start); yourself);				yourself ].			^ (ts collect: [ :t | t duration ]) sum! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:09'!offset: anOffset	"Answer a <DateAndTime> equivalent to the receiver but with its local time 	being offset from UTC by offset."	^ self class basicNew 		ticks: self ticks offset: anOffset asDuration;		yourself! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/24/2003 11:03'!meridianAbbreviation	^ self asTime meridianAbbreviation! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:41'!meridianAbbreviation	^ self hour < 12 ifTrue: ['AM'] ifFalse: ['PM']! !!Week class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 09:30'!startDay: aSymbol	(DayNames includes: aSymbol)		ifTrue: [ StartDay := aSymbol ]		ifFalse: [ self error: aSymbol, ' is not a recognised day name' ]! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:46'!state: aSymbol	state := aSymbol! !!Month class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:21'!readFrom: aStream	| m y c |	m := (ReadWriteStream with: '') reset.	[(c := aStream next) isSeparator] whileFalse: [m nextPut: c].	[(c := aStream next) isSeparator] whileTrue.	y := (ReadWriteStream with: '') reset.	y nextPut: c.	[aStream atEnd] whileFalse: [y nextPut: aStream next].	^ self 		month: m contents		year: y contents"Month readFrom: 'July 1998' readStream"! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!minutes	"Answer the number of minutes the receiver represents."	^ (seconds rem: SecondsInHour) quo: SecondsInMinute! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 09:17'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: start;		nextPut: $D;		print: duration;		nextPut: $)! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:45'!asYear	^ start asYear! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 23:56'!asDate	^ Date starting: self! !!Duration methodsFor: 'private' stamp: 'brp 9/25/2003 14:42'!storeOn: aStream	aStream		nextPut: $(;		nextPutAll: self className;		nextPutAll: ' seconds: ';		print: seconds;		nextPutAll: ' nanoSeconds: ';		print: nanos;		nextPut: $)! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:48'!midnight	"Answer a DateAndTime starting at midnight local time"	^ self		dayMonthYearDo: [ :d :m :y | self class year: y month: m day: d ]! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:04'!yyyymmdd	"Format the date in ISO 8601 standard like '2002-10-22'."	^ self printFormat: #(3 2 1 $- 1 1 2)! !!Duration methodsFor: 'private' stamp: 'gk 8/30/2006 23:41'!ticks	"Answer an array {days. seconds. nanoSeconds}. Used by DateAndTime and Time."	| days |	days := self days.	^ Array 		with: days		with: seconds - (days * SecondsInDay)		with: nanos! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!print24: hr24 on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am' "	self print24: hr24 showSeconds: true on: aStream! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!index	^ self monthIndex! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:45'!asNanoSeconds	"Answer the number of nanoseconds since midnight"	^ self asDuration asNanoSeconds! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:29'!asNanoSeconds	"Answer the number of nanoseconds since midnight"	^ self asDuration asNanoSeconds! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:06'!printFormat: formatArray 	"Answer a String describing the receiver using the argument formatArray."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream format: formatArray.	^ aStream contents! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 15:49'!hash	^ self asUTC ticks hash! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:11'!hash	^ self ticks hash! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:57'!to: anEnd by: aDuration	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ (Schedule starting: self ending: (anEnd asDateAndTime))		schedule: (Array with: aDuration asDuration);		yourself! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 23:13'!suspend	| ts |	self isActive ifTrue:		[ ts := self timespans last.		ts duration: (DateAndTime now - ts start).		self state: #suspended]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 13:11'!asLocal		^ (self offset = self class localOffset)		ifTrue: [self]		ifFalse: [self utcOffset: self class localOffset]! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 11:54'!reset	self suspend.	timespans := nil! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:03'!nanoSeconds	^ nanos! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 7/27/2003 15:25'!year: year day: dayOfYear hour: hour minute: minute second: second	^ self		year: year		day: dayOfYear		hour: hour		minute: minute		second: second		offset: self localOffset! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!hhmm24	"Return a string of the form 1123 (for 11:23 am), 2154 (for 9:54 pm), of exactly 4 digits"	^(String streamContents: 		[ :aStream | self print24: true showSeconds: false on: aStream ])			copyWithout: $:! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!offset	^ offset! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:51'!scheduleDo: aBlock	self between: (self start) and: (self end) do: aBlock! !!Time class methodsFor: 'squeak protocol' stamp: 'brp` 8/24/2003 19:26'!hour: hour minute: minute second: second  nanoSecond: nanoCount	"Answer a Time - only second precision for now"	^ self 		seconds: (hour * SecondsInHour) + (minute * SecondsInMinute) + second 		nanoSeconds: nanoCount! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:50'!every: aDuration do: aBlock	| element end |	element := self start.	end := self end.	[ element <= end ] whileTrue:		[ aBlock value: element.		element := element + aDuration. ]! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount	"Private - only used by Time class."	seconds := secondCount.	nanos := 0! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!abbreviation	^ abbreviation! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!positive	^ seconds = 0 ifTrue: [ nanos positive ] ifFalse: [ seconds positive ]! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:08'!asSeconds	"Answer the seconds since the Squeak epoch: 1 January 1901"	^ start asSeconds! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:50'!monthsDo: aBlock	self do: aBlock with: start asMonth! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!monthAbbreviation	^ self monthName copyFrom: 1 to: 3! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:57'!new	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"	^ self epoch! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!negated	^ self class seconds: seconds negated nanoSeconds: nanos negated! !!Week class methodsFor: 'squeak protocol' stamp: 'gk 8/30/2006 15:10'!starting: aDateAndTime duration: aDuration	"Override - the duration is always one week.	 Week will start from the Week class>>startDay"	| midnight delta adjusted |	midnight := aDateAndTime asDateAndTime midnight.	delta := ((midnight dayOfWeek + 7 - (DayNames indexOf: self startDay)) rem: 7) abs.	adjusted := midnight - (Duration days: delta seconds: 0).	^ super starting: adjusted duration: (Duration weeks: 1)! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:58'!do: aBlock with: aFirstElement	self do: aBlock with: aFirstElement when: [ :t | true ]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/24/2003 12:25'!dayOfWeek	"Sunday=1, ... , Saturday=7"	^ (jdn + 1 rem: 7) + 1! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:07'!mmddyyyy	"Answer the receiver rendered in standard U.S.A format mm/dd/yyyy.	Note that the name here is slightly misleading -- the month and day numbers don't show leading zeros, 	so that for example February 1 1996 is 2/1/96"	^ self printFormat: #(2 1 3 $/ 1 1)! !!Week methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:37'!printOn: aStream	aStream nextPutAll: 'a Week starting: '.	self start printOn: aStream! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!name	^ self monthName! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'avi 2/21/2004 18:46'!hour12	"Answer an <integer> between 1 and 12, inclusive, representing the hour 	of the day in the 12-hour clock of the local time of the receiver."	^ self hour24 - 1 \\ 12 + 1! !!Time methodsFor: 'ansi protocol' stamp: 'avi 2/21/2004 18:45'!hour12	"Answer an <integer> between 1 and 12, inclusive, representing the hour 	of the day in the 12-hour clock of the local time of the receiver."	^ self hour24 - 1 \\ 12 + 1! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:03'!asMilliSeconds	^ ((seconds * NanosInSecond) + nanos) // (10 raisedToInteger: 6)! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:51'!weeks	| weeks |	weeks := OrderedCollection new.	self weeksDo: [ :m | weeks add: m ].	^ weeks asArray! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!previous	^ self class starting: (self start - 1)! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:03'!asNanoSeconds	^ (seconds * NanosInSecond) + nanos! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!hash 	^seconds bitXor: nanos! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 18:30'!hours	^ self hour! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!abs	^ self class seconds: seconds abs nanoSeconds: nanos abs! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:48'!previous	^ self class starting: (start - duration) duration: duration! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!monthName	^ start monthName! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 23:59'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Date fromSeconds: secondCount)		with: (Time fromSeconds: secondCount \\ 86400)! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:05'!month	^ self 		dayMonthYearDo: [ :d :m :y | m ]! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:07'!\\ operand	"modulo. Remainder defined in terms of //. Answer a Duration with the 	same sign as aDuration. operand is a Duration or a Number."	^ operand isNumber		ifTrue: [ self class nanoSeconds: (self asNanoSeconds \\ operand) ]		ifFalse: [ self - (operand * (self // operand)) ]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:05'!year	^ self		dayMonthYearDo: [ :d :m :y | y ]! !!TimeZone methodsFor: 'private' stamp: 'brp 9/4/2003 06:37'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self abbreviation;		nextPut: $)! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:47'!monthIndex	^ self month! !!Float methodsFor: 'comparing' stamp: 'eem 7/6/2009 11:11'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>=! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/24/2003 12:19'!yesterday	^ self today asDate previous asDateAndTime! !!Date methodsFor: 'smalltalk-80' stamp: 'brp 1/16/2004 14:30'!previous: dayName 	"Answer the previous date whose weekday name is dayName."	| days |	days := 7 + self weekdayIndex - (self class dayOfWeek: dayName) \\ 7.	days = 0 ifTrue: [ days := 7 ].	^ self subtractDays: days! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 9/4/2003 06:42'!timeZoneName	^ self class localTimeZone name! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:50'!months	| months |	months := OrderedCollection new: 12.	self monthsDo: [ :m | months add: m ].	^ months asArray.! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:44'!timespans	^ timespans ifNil: [ timespans := OrderedCollection new ]! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:01'!daysInMonth	self shouldNotImplement! !!Time class methodsFor: 'general inquiries' stamp: 'brp 8/23/2003 23:59'!humanWordsForSecondsAgo: secs	| date today |	"Return natural language for this date and time in the past."	secs <= 1 ifTrue: [^ 'a second ago'].	secs < 45 ifTrue: [^ secs printString, ' seconds ago'].	secs < 90 ifTrue: [^ 'a minute ago'].	secs < "45*60" 2700 ifTrue: [^ (secs//60) printString, ' minutes ago'].	secs < "90*60" 5400 ifTrue: [^ 'an hour ago'].	secs < "18*60*60" 64800 ifTrue: [^ (secs//3600) printString, ' hours ago'].	date := Date fromSeconds: self totalSeconds - secs.		"now work with dates"	today := Date today.	date > (today subtractDays: 2) ifTrue: [^ 'yesterday'].	date > (today subtractDays: 8) ifTrue: [^ 'last ', date dayOfWeekName].	date > (today subtractDays: 13) ifTrue: [^ 'a week ago'].	date > (today subtractDays: 28) ifTrue: [		^ ((today subtractDate: date)//7) printString, ' weeks ago'].	date > (today subtractDays: 45) ifTrue: [^ 'a month ago'].	date > (today subtractDays: 300) ifTrue: [^ 'last ', date monthName].	^ date monthName, ', ', date year printString"Example#(0.5 30 62 130 4000 10000 60000 90000 345600 864000 1728000 3456000 17280000 34560000 345600000) 		collect: [:ss | Time humanWordsForSecondsAgo: ss]."! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:00'!year: year month: month day: day hour: hour minute: minute second: second	"Return a DateAndTime"	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		offset: self localOffset! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:59'!duration: aDuration	"Set the Duration of this timespan"	duration := aDuration! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:44'!asDate	^ start asDate! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!between: aStart and: anEnd do: aBlock	| element end i |	end := self end min: anEnd.	element := self start.		i := 1.	[ element < aStart ] whileTrue:		[ element := element + (schedule at: i).		i := i + 1. (i > schedule size) ifTrue: [i := 1]].	i := 1.	[ element <= end ] whileTrue:		[ aBlock value: element.		element := element + (schedule at: i).		i := i + 1.		(i > schedule size) ifTrue: [i := 1]]! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!schedule: anArrayOfDurations	schedule := anArrayOfDurations! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 9/23/2004 09:53'!end	^ self duration asNanoSeconds = 0		ifTrue: [ self start ]		ifFalse: [ self next start - DateAndTime clockPrecision ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:09'!today	^ self midnight! !!Date methodsFor: 'printing' stamp: 'BP 3/23/2001 12:27'!printOn: aStream	self printOn: aStream format: #(1 2 3 $  3 1 )! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!hash	^ start hash + duration hash! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:51'!workDatesDo: aBlock	"Exclude Saturday and Sunday"	self do: aBlock with: start asDate when: [ :d | d dayOfWeek < 6 ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asWeek	^ Week starting: self! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:47'!next	^ self class starting: (start + duration) duration: duration! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:48'!daysInYear	"Answer the number of days in the year represented by the receiver."	^ self asYear daysInYear! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!name: aString	name := aString! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:53'!year: year day: dayOfYear	"Return a DateAndTime"	^ self		year: year		day: dayOfYear		hour: 0		minute: 0		second: 0! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:49'!dates	| dates |	dates := OrderedCollection new.	self datesDo: [ :m | dates add: m ].	^ dates asArray! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:49'!noon	"Answer a DateAndTime starting at noon"	^ self dayMonthYearDo: 		[ :d :m :y | self class year: y month: m day: d hour: 12 minute: 0 second: 0 ]! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'KLC 5/9/2008 20:13'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick :=  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!hours	"Answer the number of hours the receiver represents."	^ (seconds rem: SecondsInDay) quo: SecondsInHour! !!Stopwatch methodsFor: 'squeak protocol' stamp: 'brp 9/24/2003 22:47'!state	^ state ifNil: [ state := #suspended ]! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 09:21'!readFrom: aStream 	"Read a Date from the stream in any of the forms:  			<day> <monthName> <year>		(5 April 1982; 5-APR-82)  			<monthName> <day> <year>		(April 5, 1982)  			<monthNumber> <day> <year>		(4/5/82) 			<day><monthName><year>			(5APR82)"	| day month year |	aStream peek isDigit		ifTrue: [day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue: ["number/name... or name..."			month := WriteStream						on: (String new: 10).			[aStream peek isLetter]				whileTrue: [month nextPut: aStream next].			month := month contents.			day isNil				ifTrue: ["name/number..."					[aStream peek isAlphaNumeric]						whileFalse: [aStream skip: 1].					day := Integer readFrom: aStream]]		ifFalse: ["number/number..."			month := Month nameOfMonth: day.			day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	year := Integer readFrom: aStream.	year < 10 ifTrue: [year := 2000 + year] 		ifFalse: [ year < 1900 ifTrue: [ year := 1900 + year]].	^ self		year: year		month: month		day: day! !!TimeZone class methodsFor: 'instance creation' stamp: 'brp 9/4/2003 06:33'!offset: aDuration name: aName abbreviation: anAbbreviation	^ self new		offset: aDuration;		name: aName;		abbreviation: anAbbreviation;		yourself! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:31'!second	^ (Duration seconds: seconds) seconds! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:19'!second	^ self asDuration seconds! !!Date class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 22:02'!year: year month: month day: day	^ self starting: (DateAndTime year: year month: month day: day)! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 14:29'!// operand	"operand is a Duration or a Number"	^ operand isNumber		ifTrue: [ self class nanoSeconds: (self asNanoSeconds // operand) asInteger ]		ifFalse: [ self asNanoSeconds // operand asDuration asNanoSeconds ]! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 8/24/2003 00:00'!dateAndTimeNow	"Answer an Array whose with Date today and Time now."	^ Time dateAndTimeNow! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!dateAndTimes	| dateAndTimes |	dateAndTimes := OrderedCollection new.	self scheduleDo: [ :e | dateAndTimes add: e ].	^ dateAndTimes asArray! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 1/7/2004 16:25'!monthAbbreviation	^ start monthAbbreviation! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:02'!newDay: day month: month year: year 	^ self year: year month: month day: day! !!Time methodsFor: 'private' stamp: 'gk 8/31/2006 00:20'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Time class."	seconds := secondCount.	nanos := nanoCount! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!abbreviation: aString	abbreviation := aString! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:42'!starting: aDateAndTime	^ self starting: aDateAndTime duration: Duration zero! !!Week class methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 09:34'!nameOfDay: anIndex	^ DayNames at: anIndex! !!Schedule methodsFor: 'enumerating' stamp: 'brp 5/13/2003 09:50'!schedule	^ schedule! !!Time class methodsFor: 'benchmarks' stamp: 'BP 3/30/2001 15:25'!benchmarkPrimitiveResponseDelay	"Time benchmarkPrimitiveResponseDelay"	"Benchmark the overhead for primitive dispatches with an active Delay.	On the VM level, this tests the efficiency of ioLowResMSecs."	"PII/400 Windows98: 0.128 microseconds per prim"	"ar 9/6/1999: This value is *extremely* important for stuff like sockets etc.	I had a bad surprise when Michael pointed this particular problem out:	Using the hardcoded clock() call for ioLowResMSecs on Win32 resulted in an overhead	of 157.4 microseconds per primitive call - meaning you can't get no more than	approx. 6000 primitives per second on my 400Mhz PII system with an active delay!!	BTW, it finally explains why Squeak seemed soooo slow when running PWS or 	other socket stuff. The new version (not using clock() but some Windows function) 	looks a lot better (see above; approx. 8,000,000 prims per sec with an active delay)."	| nLoops bb index baseTime actualTime delayTime |	delayTime := 5000. "Time to run this test is approx. 3*delayTime"	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	bb := Array new: 1. "The object we send the prim message to"	"Compute the # of loops we'll run in a decent amount of time"	[(Delay forMilliseconds: delayTime) wait] 		forkAt: Processor userInterruptPriority.	nLoops := 0.	[Delay anyActive] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		nLoops := nLoops + 1.	].	"Flush the cache and make sure #basicSize is in there"	Object flushCache.	bb basicSize.	"Now run the loop without any active delay	for getting an idea about its actual speed."	baseTime := self millisecondClockValue.	index := nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index := index - 1.	].	baseTime := self millisecondClockValue - baseTime.	"Setup the active delay but try to never make it active"	[(Delay forMilliseconds: delayTime + delayTime) wait] 		forkAt: Processor userInterruptPriority.	"And run the loop"	actualTime := self millisecondClockValue.	index := nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index := index - 1.	].	actualTime := self millisecondClockValue - actualTime.	"And get us some result"	^((actualTime - baseTime) * 1000 asFloat / (nLoops * 10) truncateTo: 0.001) printString,		' microseconds overhead per primitive call'! !!Year class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 13:53'!starting: aDateAndTime duration: aDuration 	"Override - start from midnight"	| midnight |	midnight := aDateAndTime asDateAndTime midnight.	^ super		starting: midnight		duration: (Duration days: (self daysInYear: midnight year))! !!Time class methodsFor: 'general inquiries' stamp: 'BP 3/30/2001 15:25'!namesForTimes: arrayOfSeconds	| simpleEnglish prev final prevPair myPair |	"Return English descriptions of the times in the array.  They are each seconds since 1901.  If two names are the same, append the date and time to distinguish them."	simpleEnglish := arrayOfSeconds collect: [:secsAgo |		self humanWordsForSecondsAgo: self totalSeconds - secsAgo].	prev := ''.	final := simpleEnglish copy.	simpleEnglish withIndexDo: [:eng :ind | 		eng = prev ifFalse: [eng]			ifTrue: ["both say 'a month ago'"				prevPair := self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind-1).				myPair := self dateAndTimeFromSeconds: 						(arrayOfSeconds at: ind).				(final at: ind-1) = prev ifTrue: ["only has 'a month ago'"					final at: ind-1 put: 							(final at: ind-1), ', ', prevPair first mmddyyyy].				final at: ind put: 							(final at: ind), ', ', myPair first mmddyyyy.				prevPair first = myPair first 					ifTrue: [						(final at: ind-1) last == $m ifFalse: ["date but no time"							final at: ind-1 put: 								(final at: ind-1), ', ', prevPair second printMinutes].						final at: ind put: 							(final at: ind), ', ', myPair second printMinutes]].		prev := eng].	^ final! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:02'!negative	^ self positive not! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 13:42'!asDelay	^ Delay forDuration: self! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:48'!start	"Answer the start DateAndTime of this timespan"	^ start! !!Time class methodsFor: 'general inquiries' stamp: 'BP 3/30/2001 15:25'!condenseBunches: aCollectionOfSeconds	| secArray pause now out prev bunchEnd ago |	"Identify the major intervals in a bunch of numbers.  	Each number is a seconds since 1901 that represents a date and time.	We want the last event in a bunch.  Return array of seconds for:		Every event in the last half hour.		Every bunch separated by 30 min in the last 24 hours.		Every bunch separated by two hours before that."	"Time condenseBunches: 		(#(20 400 401  20000 20200 20300 40000 45000  200000 201000 202000) 			collect: [ :tt | self totalSeconds - tt])"	secArray := aCollectionOfSeconds asSortedCollection.	pause := 1.	now := self totalSeconds.	out := OrderedCollection new.	prev := 0.	bunchEnd := nil.	secArray reverseDo: [:secs | "descending"		ago := now - secs.		ago > (60*30) ifTrue: [pause := "60*30" 1800].		ago > (60*60*24) ifTrue: [pause := "60*120" 7200].		ago - prev >= pause ifTrue: [out add: bunchEnd.  bunchEnd := secs].		prev := ago].	out add: bunchEnd.	out removeFirst.	^ out! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 15:44'!daysLeftInYear	"Answer the number of days in the year after the date of the receiver."	^ self daysInYear - self dayOfYear! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asMonth	^ Month starting: self! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/21/2003 08:38'!printOn: aStream	aStream nextPutAll: 'a Year ('.	self start year printOn: aStream.	aStream nextPutAll: ')'! !!Year methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:01'!asYear	^ self! !!Duration class methodsFor: 'squeak protocol' stamp: 'gk 8/31/2006 01:30'!nanoSeconds: nanos	"This method is slow. If you have nanos less than 10^6 you should use #seconds:nanoSeconds: instead."	| quo |	quo := nanos quo: NanosInSecond.	^ self basicNew		seconds: quo		nanoSeconds: nanos - (quo * NanosInSecond)! !!Week class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:34'!indexOfDay: aSymbol	^ DayNames indexOf: aSymbol! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:29'!name	^ name! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:54'!year: year month: month day: day hour: hour minute: minute	"Return a DateAndTime" 	^ self 		year: year 		month: month 		day: day 		hour: hour		minute: minute		second: 0! !!Date methodsFor: 'printing' stamp: 'BP 3/23/2001 12:27'!storeOn: aStream	aStream print: self printString; nextPutAll: ' asDate'! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:38'!truncateTo: aDuration	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 4 minutes."	^ self class		nanoSeconds: (self asNanoSeconds truncateTo: aDuration asNanoSeconds)! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 21:03'!asSeconds	"Return the number of seconds since the Squeak epoch"	^ (self - (self class epoch)) asSeconds! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 15:55'!asSeconds	"Answer the number of seconds since midnight of the receiver."	^ seconds! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:02'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 1901."	^ self fromDays: ((Duration seconds: seconds) days)! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:51'!years	| years |	years := OrderedCollection new.	self yearsDo: [ :m | years add: m ].	^ years asArray! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 18:58'!milliseconds: currentTime since: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	| delta |	delta := currentTime - lastTime.	^ delta < 0		ifTrue: [SmallInteger maxVal + delta]		ifFalse: [delta]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 7/9/2005 08:45'!+ operand	"operand conforms to protocol Duration"	| ticks | 	ticks := self ticks + (operand asDuration ticks) .	^ self class basicNew		ticks: ticks		offset: self offset; 		yourself! !!Timespan class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:16'!starting: startDateAndTime ending: endDateAndTime	^ self 		starting: startDateAndTime 		duration: (endDateAndTime asDateAndTime - startDateAndTime)! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:00'!< comparand	^ self asNanoSeconds < comparand asNanoSeconds! !!Time class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:05'!hour: hour minute: minute second: second	"Answer a Time"	^ self hour: hour minute: minute second: second nanoSecond: 0! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:09'!midnight	^ self now midnight! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!offset	^ offset! !!Month class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:27'!daysInMonth: indexOrName forYear: yearInteger 	| index |	index := indexOrName isInteger 				ifTrue: [indexOrName]				ifFalse: [self indexOfMonth: indexOrName].	^ (DaysInMonth at: index)			+ ((index = 2					and: [Year isLeapYear: yearInteger])						ifTrue: [1] ifFalse: [0])! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!isLeapYear	^ Year isLeapYear: self year! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!hour	^ self hour24! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:10'!hour	^ self hour24! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:01'!asDuration	"Answer the duration since midnight"	^ Duration seconds: seconds nanoSeconds: nanos! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:36'!year: year month: month day: day hour: hour minute: minute second: second offset: offset	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond: 0		offset: offset! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 15:42'!roundTo: aDuration	"e.g. if the receiver is 5 minutes, 37 seconds, and aDuration is 2 minutes, answer 6 minutes."	^ self class nanoSeconds: (self asNanoSeconds roundTo: aDuration asNanoSeconds)! !!TimeZone methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:28'!offset: aDuration	offset := aDuration! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!month	^ start month! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 1/9/2004 06:25'!= comparand 	"Answer whether the argument is a <Duration> representing the same 	period of time as the receiver."	^ self == comparand		ifTrue: [true]		ifFalse: 			[self species = comparand species 				ifTrue: [self asNanoSeconds = comparand asNanoSeconds]				ifFalse: [false] ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:37'!utcOffset: anOffset	"Answer a <DateAndTime> equivalent to the receiver but offset from UTC by anOffset"	| equiv |	equiv := self + (anOffset asDuration - self offset).	^ equiv ticks: (equiv ticks) offset: anOffset asDuration; yourself! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 21:08'!julianDayNumber: aJulianDayNumber	^ self basicNew		ticks: aJulianDayNumber days ticks offset: self localOffset;		yourself! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:48'!daysInMonth	"Answer the number of days in the month represented by the receiver."	^ self asMonth daysInMonth! !!TimeStamp class methodsFor: 'squeak protocol' stamp: 'dtl 7/13/2009 13:45'!current	| ts ticks |	ts := super now asTimeStamp.	ticks := ts ticks.	ticks at: 3 put: 0.	ts ticks: ticks offset: ts offset.	^ ts! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!year	^ start year! !!Duration methodsFor: 'private' stamp: 'gk 8/31/2006 01:33'!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Duration class"	seconds := secondCount.	nanos := nanoCount rounded! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:50'!to: anEnd	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ Timespan starting: self ending: (anEnd asDateAndTime)! !!Time class methodsFor: 'benchmarks' stamp: 'brp 8/24/2003 00:06'!benchmarkMillisecondClock		"Time benchmarkMillisecondClock"	"Benchmark the time spent in a call to Time>>millisecondClockValue.	On the VM level this tests the efficiency of calls to ioMSecs()."	"PII/400 Windows 98: 0.725 microseconds per call"	| temp1 temp2 temp3 delayTime nLoops time |	delayTime := 5000. "Time to run benchmark is approx. 2*delayTime"	"Don't run the benchmark if we have an active delay since	we will measure the additional penalty in the primitive dispatch	mechanism (see #benchmarkPrimitiveResponseDelay)."	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	"Flush the cache for this benchmark so we will have	a clear cache hit for each send to #millisecondClockValue below"	Object flushCache.	temp1 := 0.	temp2 := self. "e.g., temp1 == Time"	temp3 := self millisecondClockValue + delayTime.	"Now check how often we can run the following loop in the given time"	[temp2 millisecondClockValue < temp3]		whileTrue:[temp1 := temp1 + 1].	nLoops := temp1. "Remember the loops we have run during delayTime"	"Setup the second loop"	temp1 := 0.	temp3 := nLoops.	"Now measure how much time we spend without sending #millisecondClockValue"	time := Time millisecondClockValue.	[temp1 < temp3]		whileTrue:[temp1 := temp1 + 1].	time := Time millisecondClockValue - time.	"And compute the number of microseconds spent per call to #millisecondClockValue"	^((delayTime - time * 1000.0 / nLoops) truncateTo: 0.001) printString,		' microseconds per call to Time>>millisecondClockValue'! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 10:34'!dayOfWeekAbbreviation	^ self dayOfWeekName copyFrom: 1 to: 3! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:29'!hour24	^ (Duration seconds: seconds) hours! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:17'!hour24	^ self asDuration hours! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 1/9/2004 05:39'!- operand	"operand conforms to protocol DateAndTime or protocol Duration"	^ (operand respondsTo: #asDateAndTime)		ifTrue: 			[ | lticks rticks |			lticks := self asLocal ticks.			rticks := operand asDateAndTime asLocal ticks.			Duration 				seconds: (SecondsInDay *(lticks first - rticks first)) + 							(lticks second - rticks second) 				nanoSeconds: (lticks third - rticks third) ]		ifFalse:		 	[ self + (operand negated) ]! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!* operand	"operand is a Number" 	^ self class nanoSeconds: ( (self asNanoSeconds * operand) asInteger)! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!minute	^ (Duration seconds: seconds) minutes! !!Schedule methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:38'!includes: aDateAndTime	| dt |	dt := aDateAndTime asDateAndTime.	self scheduleDo: [ :e | e = dt ifTrue: [^true] ].	^ false! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!asWeek	^ start asWeek! !!Date methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 16:10'!asDate	^ self! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:43'!< comparand	^ self start < comparand! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!asSeconds	^ seconds! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:45'!daysInYear	"Answer the number of days in the month represented by the receiver."	^ start daysInYear! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/24/2003 12:19'!tomorrow	^ self today asDate next asDateAndTime! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'brp 7/27/2003 15:28'!year: year day: dayOfYear hour: hour minute: minute second: second offset: offset 	"Return a DataAndTime"	| y d |	y := self		year: year		month: 1		day: 1		hour: hour		minute: minute		second: second		nanoSecond: 0		offset: offset.	d := Duration days: (dayOfYear - 1).	^ y + d! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:49'!duration	^ Duration zero! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:46'!asDateAndTime	^ self! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!+ operand	"operand is a Duration" 	^ self class nanoSeconds: (self asNanoSeconds + operand asNanoSeconds)! !!TimeZone class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:38'!default	"Answer the default time zone - GMT"	^ self timeZones detect: [ :tz | tz offset = Duration zero ]! !!Time methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 19:32'!duration	^ Duration zero! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:49'!julianDayNumber	^ jdn! !!ChronologyConstants class methodsFor: 'as yet unclassified' stamp: 'brp 9/25/2003 10:49'!initialize	"ChronologyConstants initialize" 	SqueakEpoch := 2415386. 		"Julian day number of 1 Jan 1901" 	SecondsInDay := 86400.	SecondsInHour := 3600.	SecondsInMinute := 60.	NanosInSecond := 10 raisedTo: 9.	NanosInMillisecond := 10 raisedTo: 6.	DayNames := #(Sunday Monday Tuesday Wednesday Thursday Friday Saturday).			MonthNames := #(January February March April May June July 			August September October November December).	DaysInMonth := #(31 28 31 30 31 30 31 31 30 31 30 31)! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:04'!asMonth	^ self! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:36'!current	^ self now! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 1/7/2004 16:05'!includes: aDateAndTime	^ (aDateAndTime isKindOf: Timespan)			ifTrue: [ (self includes: aDateAndTime start)						and: [ self includes: aDateAndTime end ] ]			ifFalse: [ aDateAndTime asDateAndTime between: start and: self end ]! !!Timespan methodsFor: 'enumerating' stamp: 'brp 5/13/2003 08:49'!datesDo: aBlock	self do: aBlock with: start asDate! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:01'!asDuration	^ self! !!Week class methodsFor: 'squeak protocol' stamp: 'brp 1/30/2005 09:17'!startDay	^ StartDay ifNil: [ StartDay := DayNames first ]! !!Time methodsFor: 'printing' stamp: 'dtl 6/25/2009 19:13'!printOn: aStream 	self print24: false		showSeconds: (self seconds ~= 0				or: [self nanoSecond ~= 0])		on: aStream! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:47'!asYear	^ Year starting: self! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'kph 10/13/2006 04:33'!setJdn: j seconds: s nano: n offset: ojdn := j.seconds := s.nanos :=  n.offset :=  o! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!asMonth	^ start asMonth! !!Date class methodsFor: 'squeak protocol' stamp: 'BP 3/23/2001 12:36'!starting: aDateAndTime	^super starting: (aDateAndTime midnight) duration: (Duration days: 1)! !!Timespan methodsFor: 'private' stamp: 'brp 5/13/2003 08:59'!do: aBlock with: aFirstElement when: aConditionBlock	| element end |	element := aFirstElement.	end := self end.	[ element start <= end ] whileTrue:		[(aConditionBlock value: element)			ifTrue: [ aBlock value: element ].		element := element next. ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:36'!fromString: aString	^ self readFrom: (ReadStream on: aString)! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 12/19/2006 15:01'!readFrom: aStream	| bc year month day hour minute second nanos offset buffer ch |	aStream peek = $- ifTrue: [ aStream next. bc := -1] ifFalse: [bc := 1].	year := (aStream upTo: $-) asInteger * bc.	month := (aStream upTo: $-) asInteger.	day := (aStream upTo: $T) asInteger.	hour := (aStream upTo: $:) asInteger. 	buffer := '00:' copy. ch := nil.	minute := WriteStream on: buffer.	[ aStream atEnd | (ch = $:) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch := minute nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch := $: ].	minute := ((ReadStream on: buffer) upTo: ch) asInteger.	buffer := '00.' copy.	second := WriteStream on: buffer.	[ aStream atEnd | (ch = $.) | (ch = $+) | (ch = $-) ]		whileFalse: [ ch := second nextPut: aStream next. ].	(ch isNil or: [ch isDigit]) ifTrue: [ ch := $. ].	second := ((ReadStream on: buffer) upTo: ch) asInteger.	buffer := '000000000+' copy.	(ch = $.) ifTrue: [ 		nanos := WriteStream on: buffer.		[ aStream atEnd | ((ch := aStream next) = $+) | (ch = $-) ]			whileFalse: [ nanos nextPut: ch. ].		(ch isNil or: [ch isDigit]) ifTrue: [ ch := $+ ].	].	nanos := buffer asInteger.	aStream atEnd		ifTrue: [ offset := self localOffset ]		ifFalse:		 	[offset := Duration fromString: (ch asString, '0:', aStream upToEnd).			(offset = self localOffset) ifTrue: [ offset := self localOffset ]].	^ self		year: year		month: month		day: day		hour: hour		minute: minute		second: second		nanoSecond:  nanos		offset: offset.	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:59'!- operand	"operand is a Duration" 	^ self + operand negated! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:49'!middleOf: aDuration	"Return a Timespan where the receiver is the middle of the Duration"	| duration |	duration := aDuration asDuration.	^ Timespan starting: (self - (duration / 2)) duration: duration! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 20:07'!readFrom: aStream	"Read a Time from the stream in the form:		<hour>:<minute>:<second> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"	| hour minute second ampm |	hour := Integer readFrom: aStream.	minute := 0.	second := 0.	(aStream peekFor: $:) ifTrue:		[ minute := Integer readFrom: aStream.		(aStream peekFor: $:) ifTrue: [ second := Integer readFrom: aStream ]].	aStream skipSeparators.	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 		[ampm := aStream next asLowercase.		(ampm = $p and: [hour < 12]) ifTrue: [hour := hour + 12].		(ampm = $a and: [hour = 12]) ifTrue: [hour := 0].		(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].	^ self hour: hour minute: minute second: second	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !!Date methodsFor: 'printing' stamp: 'brp 7/27/2003 16:05'!printOn: aStream format: formatArray 	"Print a description of the receiver on aStream using the format 	denoted the argument, formatArray: 			#(item item item sep monthfmt yearfmt twoDigits) 			items: 1=day 2=month 3=year will appear in the order given, 			separated by sep which is eaither an ascii code or character. 			monthFmt: 1=09 2=Sep 3=September 			yearFmt: 1=1996 2=96 			digits: (missing or)1=9 2=09. 		See the examples in printOn: and mmddyy"	| gregorian twoDigits element monthFormat |	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].	1 to: 3 do: 		[ :i | 			element := formatArray at: i.			element = 1				ifTrue: [twoDigits						ifTrue: [aStream								nextPutAll: (gregorian first asString										padded: #left										to: 2										with: $0)]						ifFalse: [gregorian first printOn: aStream]].			element = 2				ifTrue: [monthFormat := formatArray at: 5.					monthFormat = 1						ifTrue: [twoDigits								ifTrue: [aStream										nextPutAll: (gregorian middle asString												padded: #left												to: 2												with: $0)]								ifFalse: [gregorian middle printOn: aStream]].					monthFormat = 2						ifTrue: [aStream								nextPutAll: ((Month nameOfMonth: gregorian middle)										copyFrom: 1										to: 3)].					monthFormat = 3						ifTrue: [aStream								nextPutAll: (Month nameOfMonth: gregorian middle)]].			element = 3				ifTrue: [(formatArray at: 6)							= 1						ifTrue: [gregorian last printOn: aStream]						ifFalse: [aStream								nextPutAll: ((gregorian last \\ 100) asString										padded: #left										to: 2										with: $0)]].			i < 3				ifTrue: [(formatArray at: 4)							~= 0						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 20:54'!year: year month: month day: day	"Return a DateAndTime, midnight local time" 	^ self 		year: year 		month: month 		day: day 		hour: 0		minute: 0! !!Week methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:36'!asWeek	^ self! !!Time class methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:50'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	^ self dateAndTimeFromSeconds: self totalSeconds! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:47'!intersection: aTimespan	 "Return the Timespan both have in common, or nil"	 | aBegin anEnd |	 aBegin := self start max: aTimespan start.	 anEnd := self end min: aTimespan end.	 anEnd < aBegin ifTrue: [^nil].	 ^ self class starting: aBegin ending: anEnd! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 9/15/2003 14:05'!+ operand	"operand conforms to protocol Duration"		^ self class starting: (self start + operand) duration: self duration! !!Time methodsFor: 'private' stamp: 'gk 8/30/2006 23:28'!ticks: anArray	"ticks is an Array: { days. seconds. nanoSeconds }"	seconds := anArray at: 2.	nanos := anArray at: 3! !!Time methodsFor: 'printing' stamp: 'dtl 6/25/2009 19:24'!print24: hr24 showSeconds: showSeconds on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"	| h m s |	h := self hour. m := self minute. s := self second.	hr24		ifTrue: 			[ h < 10 ifTrue: [ aStream nextPutAll: '0' ].			h printOn: aStream ]		ifFalse:			[ h > 12				ifTrue: [h - 12 printOn: aStream]				ifFalse: 					[h < 1						ifTrue: [ 12 printOn: aStream ]						ifFalse: [ h printOn: aStream ]]].	aStream nextPutAll: (m < 10 ifTrue: [':0'] ifFalse: [':']).	m printOn: aStream.	showSeconds ifTrue:		[ aStream nextPutAll: (s < 10 ifTrue: [':0'] ifFalse: [':']).		self nanoSecond == 0			ifTrue: [s asInteger printOn: aStream]			ifFalse: [(s + (self nanoSecond / NanosInSecond) asFloat) printOn: aStream]].	hr24 ifFalse:		[ aStream nextPutAll: (h < 12 ifTrue: [' am'] ifFalse: [' pm']) ].! !!DateAndTime methodsFor: 'private' stamp: 'gk 8/30/2006 23:01'!ticks: ticks offset: utcOffset	"ticks is {julianDayNumber. secondCount. nanoSeconds}"	self normalize: 3 ticks: ticks base: NanosInSecond.	self normalize: 2 ticks: ticks base: SecondsInDay.	jdn	:= ticks at: 1.	seconds	:= ticks at: 2.	nanos := ticks at: 3.	offset := utcOffset! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 15:44'!firstDayOfMonth	^ self asMonth start day! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:44'!isLeapYear	^ start isLeapYear! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 07:50'!nanoSecond	^ nanos! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 1/7/2004 15:45'!minutes	^ self minute! !!Time methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 19:33'!nanoSecond	^ nanos! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:02'!addTime: timeAmount	"Answer a Time that is timeInterval after the receiver. timeInterval is an 	instance of Date or Time."	^ self class seconds: self asSeconds + timeAmount asSeconds! !!Time class methodsFor: 'squeak protocol' stamp: 'BP 3/30/2001 15:25'!millisecondsSince: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	^self milliseconds: self millisecondClockValue since: lastTime! !!Week class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:34'!dayNames	^ DayNames! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!storeOn: aStream	aStream print: self printString; nextPutAll: ' asTime'! !!Timespan methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 08:45'!daysInMonth	^ start daysInMonth! !!DateAndTime class methodsFor: 'smalltalk-80' stamp: 'dtl 6/21/2009 23:37'!fromSeconds: seconds 	"Answer a DateAndTime since the Squeak epoch: 1 January 1901"	| integerSeconds nanos |	integerSeconds := seconds truncated.	integerSeconds = seconds		ifTrue: [nanos := 0]		ifFalse: [nanos := (seconds - integerSeconds * NanosInSecond) asInteger].	^ self basicNew		ticks: (Array				with: SqueakEpoch				with: integerSeconds				with: nanos)		offset: self localOffset! !!DateAndTime methodsFor: 'private' stamp: 'brp 8/23/2003 15:45'!ticks	"Private - answer an array with our instance variables. Assumed to be UTC "	^ Array with: jdn with: seconds with: nanos! !!Duration methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 08:00'!/ operand	"operand is a Duration or a Number"	^ operand isNumber		ifTrue: [ self class nanoSeconds: (self asNanoSeconds / operand) asInteger ]		ifFalse: [ self asNanoSeconds / operand asDuration asNanoSeconds ]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 16:12'!date: aDate time: aTime	^ self 		year: aDate year 		day: aDate dayOfYear 		hour: aTime hour 		minute: aTime minute 		second: aTime second! !!Time class methodsFor: 'smalltalk-80' stamp: 'dtl 6/25/2009 07:43'!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	| integerSeconds nanos |	integerSeconds := secondCount truncated.	integerSeconds = secondCount		ifTrue: [nanos := 0]		ifFalse: [nanos := (secondCount - integerSeconds * NanosInSecond) asInteger].	^ self seconds: integerSeconds nanoSeconds: nanos! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 17:09'!noon	^ self now noon! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'bvs 9/29/2004 16:43'!year: year month: month day: day hour: hour minute: minute second: second nanoSecond: nanoCount offset: offset	"Return a DateAndTime"	| monthIndex daysInMonth p q r s julianDayNumber since |	monthIndex := month isInteger ifTrue: [month] ifFalse: [Month indexOfMonth: month].	daysInMonth := Month		daysInMonth: monthIndex		forYear: year.	day < 1 ifTrue: [self error: 'day may not be zero or negative'].	day > daysInMonth ifTrue: [self error: 'day is after month ends']. 			p := (monthIndex - 14) quo: 12.	q := year + 4800 + p.	r := monthIndex - 2 - (12 * p).	s := (year + 4900 + p) quo: 100.	julianDayNumber := 		( (1461 * q) quo: 4 ) +			( (367 * r) quo: 12 ) - 				( (3 * s) quo: 4 ) + 					( day - 32075 ).	since := Duration days: julianDayNumber hours: hour 				minutes: minute seconds: second nanoSeconds: nanoCount.	^ self basicNew 		ticks: since ticks offset: offset;		yourself! !!Duration methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 13:22'!printOn: aStream	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]" 	| d h m s n |	d := self days abs.	h := self hours abs.	m := self minutes abs. 	s := self seconds abs truncated.	n := self nanoSeconds abs. 	self negative ifTrue: [ aStream nextPut: $- ].	d printOn: aStream. aStream nextPut: $:.	h < 10 ifTrue: [ aStream nextPut: $0. ].	h printOn: aStream. aStream nextPut: $:.	m < 10 ifTrue: [ aStream nextPut: $0. ].	m printOn: aStream. aStream nextPut: $:.	s < 10 ifTrue: [ aStream nextPut: $0. ].	s printOn: aStream.	n = 0 ifFalse:		[ | z ps |		aStream nextPut: $..		ps := n printString padded: #left to: 9 with: $0. 		z := ps findLast: [ :c | c asciiValue > $0 asciiValue ].		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ]! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:49'!to: anEnd	"Answer an Timespan. anEnd must be aDateAndTime or a Timespan"	^ Timespan starting: (self start) ending: (anEnd asDateAndTime)! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:28'!dayOfWeekName	^ Week nameOfDay: self dayOfWeek! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 1/9/2004 16:46'!union: aTimespan	 "Return the Timespan spanned by both"	| aBegin anEnd |	aBegin := self start min: aTimespan start.	anEnd := self end max: aTimespan end.	^ Timespan starting: aBegin ending: (anEnd + DateAndTime clockPrecision)! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 17:53'!day	^ self dayOfYear! !!Timespan methodsFor: 'ansi protocol' stamp: 'brp 9/15/2003 14:07'!- operand	"operand conforms to protocol DateAndTime or protocol Duration"	^ (operand respondsTo: #asDateAndTime)	 	ifTrue: [ self start - operand ]		ifFalse: [ self + (operand negated) ]! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/13/2009 21:19'!validateSubclass: subclass canKeepLayoutFrom: oldClass forSubclassFormat: newType 	"Returns whether the immediate subclasses of oldClass can keep its layout"	"Note: Squeak does not appear to model classFormat relationships.. so I'm putting some logic here. bkv 4/2/2003"		"Only run this test for a real subclass - otherwise this prevents changing	a class from #subclass: to #variableSubclass: etc."	subclass = oldClass ifTrue:[^true].	 "isWeak implies isVariant"						 (oldClass isVariable and: [ subclass isWeak ])		ifFalse: [ "In general we discourage format mis-matches"				  (subclass typeOfClass == newType) 				   	ifFalse: [ self error: subclass name,' cannot be recompiled'.							  ^ false ]].	^ true! !!Duration class methodsFor: 'squeak protocol' stamp: 'brp 8/23/2003 12:47'!readFrom: aStream	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]	To assiste DateAndTime>>#readFrom: SS may be unpadded or absent."	| sign days hours minutes seconds nanos ws ch |	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	days := (aStream upTo: $:) asInteger sign: sign.	hours := (aStream upTo: $:) asInteger sign: sign.	minutes := (aStream upTo: $:) asInteger sign: sign.	aStream atEnd 		ifTrue: [seconds := 0. nanos := 0]		ifFalse: 			[ ws := String new writeStream.			[ch := aStream next. (ch isNil) | (ch = $.)]				whileFalse: [ ws nextPut: ch ].			seconds := ws contents asInteger sign: sign.			ws reset.			9 timesRepeat: 				[ ch := aStream next. 				ws nextPut: (ch ifNil: [$0] ifNotNil: [ch]) ].			nanos := ws contents asInteger sign: sign].	^ self days: days hours: hours minutes: minutes seconds: seconds nanoSeconds: nanos.	"	'0:00:00:00' asDuration		'0:00:00:00.000000001' asDuration		'0:00:00:00.999999999' asDuration		'0:00:00:00.100000000' asDuration		'0:00:00:00.10' asDuration		'0:00:00:00.1' asDuration		'0:00:00:01' asDuration		'0:12:45:45' asDuration		'1:00:00:00' asDuration		'365:00:00:00' asDuration		'-7:09:12:06.10' asDuration		'+0:01:02' asDuration		'+0:01:02:3' asDuration 	"! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:48'!start: aDateAndTime	"Store the start DateAndTime of this timespan"	start := aDateAndTime asDateAndTime! !!Month class methodsFor: 'squeak protocol' stamp: 'brp 7/1/2003 13:59'!starting: aDateAndTime duration: aDuration 	"Override - a each month has a defined duration"	| start adjusted days |	start := aDateAndTime asDateAndTime.	adjusted := DateAndTime				year: start year				month: start month				day: 1.	days := self daysInMonth: adjusted month forYear: adjusted year.	^ super		starting: adjusted		duration: (Duration days: days)! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 5/13/2003 07:30'!monthName	^ Month nameOfMonth: self month! !!Time methodsFor: 'smalltalk-80' stamp: 'brp 8/23/2003 19:24'!intervalString	"Treat the time as a difference.  Give it in hours and minutes with two digits of accuracy."	| d |	d := self asDuration.	^ String streamContents: [ :s |		d hours > 0 ifTrue: [s print: d hours; nextPutAll: ' hours'].		d minutes > 0 ifTrue: [s space; print: d minutes; nextPutAll: ' minutes'].		d seconds > 0 ifTrue: [s space; print: d seconds; nextPutAll: ' seconds'] ]! !!Time methodsFor: 'printing' stamp: 'BP 3/30/2001 15:25'!printMinutes	"Return as string 'hh:mm pm'  "	^String streamContents:		[ :aStream | self print24: false showSeconds: false on: aStream ]! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 9/4/2003 06:42'!timeZoneAbbreviation	^ self class localTimeZone abbreviation! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 7/27/2003 15:47'!dayMonthYearDo: aBlock	"Evaluation the block with three arguments: day month, year."	| l n i j dd mm yyyy |	l := jdn + 68569.	n := 4 * l // 146097.	l := l - (146097 * n + 3 // 4).	i := 4000 * (l + 1) // 1461001.	l := l - (1461 * i // 4) + 31.	j := 80 * l // 2447.	dd := l - (2447 * j // 80).	l := j // 11.	mm := j + 2 - (12 * l).	yyyy := 100 * (n - 49) + i + l.	^ aBlock		value: dd		value: mm		value: yyyy! !!Month methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:05'!printOn: aStream	aStream nextPutAll: self monthName, ' ', self year printString! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:45'!duration	"Answer the Duration of this timespan"	^ duration! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:44'!asDateAndTime	^ start! !!Date class methodsFor: 'smalltalk-80' stamp: 'brp 7/27/2003 16:01'!today	^ self current! !!Year class methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 09:00'!isLeapYear: aYearInteger	| adjustedYear |	adjustedYear := aYearInteger > 0		ifTrue: [aYearInteger]		ifFalse: [(aYearInteger + 1) negated].	"There was no year 0"	^ ((adjustedYear \\ 4 ~= 0) or: [(adjustedYear \\ 100 = 0) and: [adjustedYear \\ 400 ~= 0]]) not! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 9/25/2003 16:01'!to: anEnd by: aDuration do: aBlock	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"	^ (self to: anEnd by: aDuration) scheduleDo: aBlock! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp` 8/24/2003 19:11'!epoch	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"	^ self julianDayNumber: SqueakEpoch! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 8/23/2003 21:03'!dayOfMonth	"Answer which day of the month is represented by the receiver."	^ self		dayMonthYearDo: [ :d :m :y | d ]! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 5/13/2003 07:50'!monthIndex	^ self month! !!Timespan methodsFor: 'squeak protocol' stamp: 'brp 5/13/2003 08:47'!julianDayNumber	^ start julianDayNumber! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'brp 8/24/2003 00:00'!asTime	^ Time seconds: seconds nanoSeconds: nanos! !!DateAndTime methodsFor: 'smalltalk-80' stamp: 'brp 7/1/2003 18:31'!seconds	^ self second! !ChronologyConstants initialize!