"Change Set:		7668Graphics-ar.71Graphics-ar.71:First pass on FreeTypePlus integration. Deal with all of the overrides and add kerning support to CharacterScanner. This gets rid of all of the FTP extensions on Graphics package and the fumbling with CharacterScanner ivar list.Graphics-ar.70:Add a workaround for BitBlt not returning the advance width from the displayString primitive."!Object subclass: #AbstractFont	instanceVariableNames: ''	classVariableNames: 'ForceNonSubPixelCount'	poolDictionaries: ''	category: 'Graphics-Fonts'!Object subclass: #CharacterScanner	instanceVariableNames: 'destX lastIndex xTable destY stopConditions text textStyle alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth emphasisCode kern indentationLevel wantsColumnBreaks pendingKernX'	classVariableNames: 'DefaultStopConditions NilCondition PaddedSpaceCondition SpaceCondition'	poolDictionaries: 'TextConstants'	category: 'Graphics-Text'!!CompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:14'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	line stop: lastIndex.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	^true! !!TextStyle class methodsFor: 'user interface' stamp: 'tween 3/29/2007 13:49'!fontMenuForStyle: styleName target: target selector: selector highlight: currentFont 	"Offer a font menu for the given style. If one is selected, pass 	that font to target with a  	call to selector. The fonts will be displayed in that font."	| aMenu displayFont |	aMenu := MenuMorph entitled: styleName.	(TextStyle named: styleName)		ifNotNilDo: [:s | s isTTCStyle				ifTrue: [aMenu						add: 'New Size'						target: self						selector: #chooseTTCFontSize:						argument: {styleName. target. selector}]].	(self pointSizesFor: styleName)		do: [:pointSize | 			| font subMenu | 			font := (self named: styleName)						fontOfPointSize: pointSize.			subMenu := self						emphasisMenuForFont: font						target: target						selector: selector						highlight: (currentFont								ifNotNilDo: [:cf | (cf familyName = styleName											and: [cf pointSize = font pointSize])										ifTrue: [currentFont emphasis]]).			subMenu				ifNil: [aMenu						add: pointSize asString , ' Point'						target: target						selector: selector						argument: font]				ifNotNil: [aMenu add: pointSize asString , ' Point' subMenu: subMenu].			displayFont := font.			(font isSymbolFont or:[(font hasDistinctGlyphsForAll: pointSize asString , ' Point') not])				ifTrue:[					"don't use a symbol font to display its own name!!!!"					displayFont := self default fontOfPointSize: pointSize].			aMenu lastItem font: displayFont.			currentFont				ifNotNilDo: [:cf | (cf familyName = styleName							and: [cf pointSize = font pointSize])						ifTrue: [aMenu lastItem color: Color blue darker]]].	^ aMenu! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:14'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	pendingKernX := 0.	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight := lineHeightAtSpace.		baseline := baselineAtSpace.		spaceCount := spaceCount - 1.		spaceIndex := spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount := spaceCount - 1.				"Account for backing over a run which might					change width of space."				font := text fontAt: spaceIndex withStyle: textStyle.				spaceIndex := spaceIndex - 1.				spaceX := spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex := lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX := destX - (font widthOf: (text at: lastIndex)).				lastIndex := lastIndex - 1].		spaceX := destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!BitBlt methodsFor: 'accessing' stamp: 'tween 8/1/2006 17:52'!combinationRule	"Answer the receiver's combinationRule"		^combinationRule! !!AbstractFont class methodsFor: 'utilities' stamp: 'nk 9/1/2004 11:41'!emphasisStringFor: emphasisCode	"Answer a translated string that represents the attributes given in emphasisCode."	| emphases bit |	emphasisCode = 0 ifTrue: [ ^'Normal' translated ].	emphases := (IdentityDictionary new)		at: 1 put: 'Bold' translated;		at: 2 put: 'Italic' translated;		at: 4 put: 'Underlined' translated;		at: 8 put: 'Narrow' translated;		at: 16 put: 'StruckOut' translated;		yourself.	bit := 1.	^String streamContents: [ :s |		[ bit < 32 ] whileTrue: [ | code |			code := emphasisCode bitAnd: bit.			code isZero ifFalse: [ s nextPutAll: (emphases at: code); space ].			bit := bit bitShift: 1 ].		s position isZero ifFalse: [ s skip: -1 ].	]! !!CharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 09:53'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char  floatDestX widthAndKernedWidth nextChar atEndOfRun |	<primitive: 103>	lastIndex := startIndex.	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	atEndOfRun := false.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextChar := (lastIndex + 1 <= stopIndex) 				ifTrue:[sourceString at: lastIndex + 1]				ifFalse:[					atEndOfRun := true.					"if there is a next char in sourceString, then get the kern 					and store it in pendingKernX"					lastIndex + 1 <= sourceString size						ifTrue:[sourceString at: lastIndex + 1]						ifFalse:[	nil]].			font 				widthAndKernedWidthOfLeft: char 				right: nextChar				into: widthAndKernedWidth.			nextDestX := floatDestX + (widthAndKernedWidth at: 1).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).			atEndOfRun 				ifTrue:[					pendingKernX := (widthAndKernedWidth at: 2) - (widthAndKernedWidth at: 1).					floatDestX := floatDestX - pendingKernX].			destX := floatDestX.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops at: EndOfRun! !!AbstractFont methodsFor: 'testing' stamp: 'tween 3/29/2007 13:25'!hasGlyphsForAll: asciiString	"Answer true if the receiver has glyphs for all the characters	in asciiString, false otherwise.	The default behaviour is to answer true, but subclasses may reimplement"		^true! !!AbstractFont methodsFor: 'testing' stamp: 'tween 4/6/2007 12:58'!isSubPixelPositioned	"Answer true if the receiver is currently using subpixel positioned	glyphs, false otherwise. This affects how padded space sizes are calculated	when composing text. 	Currently, only FreeTypeFonts are subPixelPositioned, and only when not	Hinted"		^false ! !!AbstractFont methodsFor: 'measuring' stamp: 'tween 3/31/2007 20:17'!linearWidthOf: aCharacter	"This is the scaled, unrounded advance width."	^self widthOf: aCharacter! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:49'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterIndex == nil ifFalse: [		"If the last character of the last line is a space,		and it crosses the right margin, then locating		the character block after it is impossible without this hack."		characterIndex > text size ifTrue: [			lastIndex := characterIndex.			characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ (destY + line lineHeight).			^true]].	characterPoint x <= (destX + (lastCharacterExtent x // 2))		ifTrue:	[lastCharacter := (text at: lastIndex).				characterPoint := destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter := (text at: line last).				characterPoint := destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex := lastIndex + 1.	lastCharacter := text at: lastIndex.	currentX := destX + lastCharacterExtent x + kern.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint := currentX @ destY.	lastCharacter = Space ifFalse: [^ true].	"Yukky if next character is space or tab."	alignment = Justified ifTrue:		[self lastCharacterExtentSetX:			(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1) font: font)).		^ true].	true ifTrue: [^ true].	"NOTE:  I find no value to the following code, and so have defeated it - DI"	"See tabForDisplay for illumination on the following awfulness."	leadingTab := true.	line first to: lastIndex - 1 do:		[:index | (text at: index) ~= Tab ifTrue: [leadingTab := false]].	(alignment ~= Justified or: [leadingTab])		ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX					leftMargin: leftMargin rightMargin: rightMargin) -						currentX]		ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -						(line justifiedTabDeltaFor: spaceCount))) -							currentX) max: 0)].	^ true! !!AbstractFont methodsFor: 'kerning' stamp: 'tween 4/3/2007 16:47'!widthAndKernedWidthOfLeft: leftCharacter right: rightCharacterOrNil into: aTwoElementArray	"Set the first element of aTwoElementArray to the width of leftCharacter and 	the second element to the width of left character when kerned with	rightCharacterOrNil. Answer aTwoElementArray"	| w k |	w := self widthOf: leftCharacter.	rightCharacterOrNil isNil		ifTrue:[			aTwoElementArray 				at: 1 put: w; 				at: 2 put: w]		ifFalse:[			k := self kerningLeft: leftCharacter right: rightCharacterOrNil.			aTwoElementArray 				at: 1 put: w; 				at: 2 put: w+k].	^aTwoElementArray	! !!AbstractFont methodsFor: 'kerning' stamp: 'tween 3/10/2007 13:08'!kerningLeft: leftChar right: rightChar	^0! !!TextLineInterval methodsFor: 'scanning' stamp: 'tween 4/6/2007 12:48'!justifiedPadFor: spaceIndex font: aFont	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	^(aFont notNil and:[aFont isSubPixelPositioned])		ifTrue:[paddingWidth * 1.0 / internalSpaces]		ifFalse:[			pad := paddingWidth // internalSpaces.			spaceIndex <= (paddingWidth \\ internalSpaces)				ifTrue: [pad + 1]				ifFalse: [pad]]! !!TextStyle class methodsFor: 'user interface' stamp: 'tween 8/10/2006 07:16'!emphasisMenuForFont: font target: target selector: selector highlight: currentEmphasis	"Offer a font emphasis menu for the given style. If one is selected, pass that font to target with a call to selector. The fonts will be displayed in that font.	Answer nil if no derivatives exist.	" 	| aMenu derivs |	derivs := font derivativeFonts.	derivs isEmpty ifTrue: [ ^nil ].	aMenu := MenuMorph entitled: 'emphasis' translated.	derivs := derivs asOrderedCollection.	derivs addFirst: font.	derivs do: [ :df | 			aMenu 				add: df emphasisString				target: target 				selector: selector				argument: df.                aMenu lastItem font: df.                df emphasis == currentEmphasis ifTrue: [aMenu lastItem color: Color blue darker]].        ^ aMenu! !!AbstractFont methodsFor: 'testing' stamp: 'tween 3/29/2007 13:32'!isSymbolFont	"Answer true if the receiver is a Symbol font, false otherwise.	The default is to answer false, subclasses can reimplement"		^false! !!CharacterScanner methodsFor: 'private' stamp: 'tween 4/6/2007 09:59'!setFont	| priorFont |	"Set the font and other emphasis."	priorFont := font.	text == nil ifFalse:[		emphasisCode := 0.		kern := 0.		indentationLevel := 0.		alignment := textStyle alignment.		font := nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font := font emphasized: emphasisCode.	priorFont 		ifNotNil: [			font = priorFont 				ifTrue:[					"font is the same, perhaps the color has changed?					We still want kerning between chars of the same					font, but of different color. So add any pending kern to destX"					destX := destX + (pendingKernX ifNil:[0])].			destX := destX + priorFont descentKern].	pendingKernX := 0. "clear any pending kern so there is no danger of it being added twice"	destX := destX - font descentKern.	"NOTE: next statement should be removed when clipping works"	leftMargin ifNotNil: [destX := destX max: leftMargin].	kern := kern - font baseKern.	"Install various parameters from the font."	spaceWidth := font widthOf: Space.	xTable := font xTable.	stopConditions := DefaultStopConditions.! !!AbstractFont methodsFor: 'displaying' stamp: 'tween 7/29/2006 14:36'!displayStrikeoutOn: aDisplayContext from: baselineStartPoint to: baselineEndPoint	"display the strikeout if appropriate for the receiver"! !!AbstractFont methodsFor: 'accessing' stamp: 'tween 8/10/2006 07:16'!emphasisString	"Answer a translated string that represents the receiver's emphasis."		^self emphasisStringFor: self emphasis! !!AbstractFont methodsFor: 'displaying' stamp: 'tween 7/29/2006 13:51'!displayUnderlineOn: aDisplayContext from: baselineStartPoint to: baselineEndPoint	"display the underline if appropriate for the receiver"! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:15'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	pendingKernX := 0.	destX := textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex := lastIndex + 1.	^false! !!AbstractFont methodsFor: 'accessing' stamp: 'tween 8/10/2006 07:13'!emphasisStringFor: emphasisCode	"Answer a translated string that represents the attributes given in emphasisCode."		^self class emphasisStringFor: emphasisCode! !!AbstractFont class methodsFor: 'utilities' stamp: 'ar 8/30/2009 16:48'!forceNonSubPixelCount	"Answer the force non-subpixel count"	^ForceNonSubPixelCount ifNil:[ForceNonSubPixelCount := 0]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:51'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount font: font).	lastIndex := lastIndex + 1.	^ false! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 8/29/2009 23:08'!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| leftX rightX glyphInfo char destY form gfont destX destPt |	destX := aPoint x.	charIndex := startIndex.	glyphInfo := Array new: 5.	startIndex to: stopIndex do:[:charIndex|		char := aString at: charIndex.		(self hasGlyphOf: char) ifTrue: [			self glyphInfoOf: char into: glyphInfo.			form := glyphInfo at: 1.			leftX := glyphInfo at: 2.			rightX := glyphInfo at: 3.			destY := glyphInfo at: 4.			gfont := glyphInfo at: 5.			(gfont == aBitBlt lastFont) ifFalse: [gfont installOn: aBitBlt].			destY := baselineY - destY. 			aBitBlt displayGlyph: form at: destX @ destY left: leftX right: rightX font: self.			destX := destX + (rightX - leftX + kernDelta).		] ifFalse:[			destPt := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: charIndex at: destX @ aPoint y kern: kernDelta from: self baselineY: baselineY.			destPt x = destX ifTrue:[				"In some situations BitBlt doesn't return the advance width from the primitive.				Work around the situation"				destX := destX + (self widthOfString: aString from: startIndex to: stopIndex) + kernDelta.			] ifFalse:[destX := destPt x].		].	].	^destX @ aPoint y! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 12:50'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad := 0.	spaceCount := spaceCount + 1.	pad := line justifiedPadFor: spaceCount font: font.	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent := lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex := lastIndex + 1.	destX := destX + lastSpaceOrTabExtent x.	^ false! !!CharacterScanner methodsFor: 'scanning' stamp: 'tween 4/6/2007 11:16'!columnBreak	pendingKernX := 0.	^true! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tween 4/23/2006 22:46'!addNewFontSize: pointSize	"Add a font in specified size to the array of fonts."	| f d newArray t isSet |	fontArray first emphasis ~= 0 ifTrue: [		t := TextConstants at: self fontArray first familyName asSymbol.		t fonts first emphasis = 0 ifTrue: [			^ t addNewFontSize: pointSize.		].	].	pointSize <= 0 ifTrue: [^ nil].	fontArray do: [:s |		s pointSize = pointSize ifTrue: [^ s].	].	(isSet := fontArray first isKindOf: TTCFontSet) 	ifTrue:[		| fonts |		fonts := fontArray first fontArray collect: [ :font |			| newFont |			(font isNil)			ifTrue: [newFont := nil]			ifFalse: [				newFont := (font ttcDescription size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				newFont ttcDescription: font ttcDescription.				newFont pixelSize: pointSize * 96 // 72.				font derivativeFonts notEmpty ifTrue: [font derivativeFonts do: [ :proto |					proto ifNotNil: [						d := proto class new initialize.						d ttcDescription: proto ttcDescription.						d pixelSize: newFont pixelSize.						newFont derivativeFont: d]]].				].			newFont].		f := TTCFontSet newFontArray: fonts]	ifFalse: [		f := fontArray first class new initialize: fontArray first.		f pointSize: pointSize.		fontArray first derivativeFonts do: [:proto |			proto ifNotNil: [				d := proto class new initialize: proto.				d pointSize: f pointSize.				f derivativeFont: d mainFont: proto.			].		].	].	newArray := ((fontArray copyWith: f) asSortedCollection: [:a :b | a pointSize <= b pointSize]) asArray.	self newFontArray: newArray.	isSet ifTrue: [		TTCFontSet register: newArray at: newArray first familyName asSymbol.	].	^ self fontOfPointSize: pointSize! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:13'!columnBreak	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	line stop: lastIndex.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	^true! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 8/29/2009 23:05'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."		| pt |	(aString isByteString) ifFalse: [^ self displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: aPoint y + self ascent.].	pt := aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.	pt = aPoint ifFalse:[^pt].	"In some situations BitBlt doesn't return the advance width from the primitive.	Work around the situation"	^aPoint x + (self widthOfString: aString from: startIndex to: stopIndex) + (stopIndex-startIndex+1*kernDelta) @ aPoint y! !!AbstractFont methodsFor: 'testing' stamp: 'tween 3/29/2007 13:43'!hasDistinctGlyphsForAll: asciiString	"Answer true if the receiver has glyphs for all the characters	in asciiString and no single glyph is shared by more than one character, false otherwise.	The default behaviour is to answer true, but subclasses may reimplement"		^true! !!AbstractFont class methodsFor: 'utilities' stamp: 'ar 8/30/2009 14:03'!forceNonSubPixelDuring: aBlock	"Forces all font rendering to suppress subpixel anti-aliasing during the execution of aBlock"	ForceNonSubPixelCount ifNil:[ForceNonSubPixelCount := 0].	ForceNonSubPixelCount := ForceNonSubPixelCount + 1.	aBlock ensure:[ForceNonSubPixelCount := ForceNonSubPixelCount - 1]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'tween 4/6/2007 11:14'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	pendingKernX := 0.	spaceX := destX.	destX := spaceX + spaceWidth.	spaceIndex := lastIndex.	lineHeightAtSpace := lineHeight.	baselineAtSpace := baseline.	lastIndex := lastIndex + 1.	spaceCount := spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !