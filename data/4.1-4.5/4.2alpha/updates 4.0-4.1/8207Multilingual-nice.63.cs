"Change Set:		8207Multilingual-nice.63Multilingual-nice.63:Cosmetic changes inspired from Cuis: avoid using == JustifiedThis is an Integer and should be compared using =Multilingual-nice.60:Hack to handle crlf pair composition and displayMultilingual-nice.61:Character lf is breakableMultilingual-nice.62:Fix a crlf case"!!MultiDisplayScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 15:01'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	pendingKernX := 0.	(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]])		ifTrue: [lastIndex := lastIndex + 2]		ifFalse: [lastIndex := lastIndex + 1].	^false! !!MultiTextComposer methodsFor: 'as yet unclassified' stamp: 'nice 11/16/2009 22:39'!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine := scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		presentationLines addLast: scanner getPresentationLine.		presentation ifNil: [presentation := scanner getPresentation]			ifNotNil: [presentation := presentation, scanner getPresentation].		actualHeight := actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex := myLine last + 1.		lastChar := theText at: myLine last.		(CharacterSet crlf includes: lastChar) ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 14:59'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	pendingKernX := 0.	(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]])		ifTrue: [lastIndex := lastIndex + 2]		ifFalse: [lastIndex := lastIndex + 1].	^false! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'nice 11/17/2009 03:29'!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	pendingKernX := 0.! !!Latin2Environment class methodsFor: 'rendering support' stamp: 'nice 11/16/2009 15:36'!isBreakableAt: index in: text	| char |	char := text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	char = Character lf ifTrue: [^ true].	^ false.! !!MultiCharacterScanner class methodsFor: 'class initialization' stamp: 'nice 11/16/2009 15:04'!initialize"	MultiCharacterScanner initialize"	| a |	a := Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: Character lf asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition := a copy.	DefaultStopConditions := a copy.	PaddedSpaceCondition := a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition := a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'nice 11/17/2009 03:28'!tab	| currentX |	currentX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^ self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false! !!MultiCompositionScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 10:02'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]]) ifTrue: [lastIndex := lastIndex + 1].	line stop: lastIndex.	presentationLine stop: lastIndex - numOfComposition.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	presentationLine paddingWidth: rightMargin - spaceX.	^true! !!Latin1Environment class methodsFor: 'rendering support' stamp: 'nice 11/16/2009 15:36'!isBreakableAt: index in: text	| char |	char := text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	char = Character lf ifTrue: [^ true].	^ false.! !!MultiCharacterBlockScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 14:52'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				baselineY := line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]])					ifTrue: [lastIndex := lastIndex + 2]					ifFalse: [lastIndex := lastIndex + 1].				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!MultiCanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'nice 11/17/2009 03:28'!tab	pendingKernX := 0.	destX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex := lastIndex + 1.	^ false! !!Latin1 class methodsFor: 'accessing - displaying' stamp: 'nice 11/16/2009 15:36'!isBreakableAt: index in: text	| char |	char := text at: index.	char = Character space ifTrue: [^ true].	char = Character cr ifTrue: [^ true].	char = Character lf ifTrue: [^ true].	^ false.! !MultiCharacterScanner initialize!