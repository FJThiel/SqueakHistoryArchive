"Change Set:		9351Monticello-ar.364Monticello-ar.364:Some fixes for Monticello:- Deal with nil subclasses properly- Handle DuplicateVariableError to allow moving variables between subclasses and superclasses when reshaping classes- Load errorDefinitions right away since any delayed class definitions should be present before methods can be loaded."!!MCPackageLoader methodsFor: 'private' stamp: 'ar 2/13/2010 15:31'!basicLoad	"Load the contents of some package. This is the core loading method	in Monticello. Be wary about modifying it unless you understand the details	and dependencies of the various entities being modified."	| pkgName |	errorDefinitions := OrderedCollection new.	"Obviously this isn't the package name but we don't have anything else	to use here. ChangeSet current name will generally work since a CS is 	usually installed prior to installation."	pkgName := ChangeSet current name.	[["Pass 1: Load everything but the methods,  which are collected in methodAdditions."	additions do: [:ea | 		ea isMethodDefinition 			ifTrue:[methodAdditions add: ea asMethodAddition]			ifFalse:[[ea load]on: Error do: [errorDefinitions add: ea]].	] displayingProgress: 'Reshaping ', pkgName.	"Try again any delayed definitions"	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea load] 		displayingProgress: 'Reloading ', pkgName.	"Pass 2: We compile new / changed methods"	methodAdditions do:[:ea| ea createCompiledMethod] 		displayingProgress: 'Compiling ', pkgName.	'Installing ', pkgName displayProgressAt: Sensor cursorPoint from: 0 to: 2 during:[:bar|		"There is no progress *during* installation since a progress bar update		will redraw the world and potentially call methods that we're just trying to install."		bar value: 1.		"Pass 3: Install the new / changed methods		(this is a separate pass to allow compiler changes to be loaded)"		methodAdditions do:[:ea| ea installMethod].		"Pass 4: Remove the obsolete methods"		removals do:[:ea| ea unload].	].	"Finally, notify observers for the method additions"	methodAdditions do: [:each | each notifyObservers] 		"the message is fake but actually telling people how much time we spend		in the notifications is embarrassing so lie instead"		displayingProgress: 'Installing ', pkgName.	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] 		displayingProgress: 'Initializing ', pkgName.	] on: InMidstOfFileinNotification do: [:n | n resume: true]	] ensure: [self flushChangesFile]! !!MCClassDefinition methodsFor: 'comparing' stamp: 'eem 9/25/2009 12:59'!requirements	^superclassName == #nil		ifTrue: [self poolDictionaries]		ifFalse: [(Array with: superclassName), self poolDictionaries]! !!MCClassDefinition methodsFor: 'installing' stamp: 'ar 2/13/2010 15:21'!createClass	| superClass class composition |	superClass := superclassName == #nil ifFalse:					[Smalltalk at: superclassName].	[class := (ClassBuilder new)			name: name 			inEnvironment: superClass environment 			subclassOf: superClass			type: type 			instanceVariableNames: self instanceVariablesString 			classVariableNames: self classVariablesString 			poolDictionaries: self sharedPoolsString			category: category.	] on: Warning, DuplicateVariableError do:[:ex| ex resume].	"The following is written to support traits unloading"	composition := Compiler evaluate: (self traitComposition ifNil:['{}']).	(composition isEmpty and:[class traitComposition isEmpty]) ifFalse:[		class setTraitComposition: composition asTraitComposition.	].	composition := Compiler evaluate: (self classTraitComposition ifNil:['{}']).	(composition isEmpty and:[class class traitComposition isEmpty]) ifFalse:[		class class setTraitComposition: composition asTraitComposition.	].	^class! !